id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:13264,Testability,log,logical,13264,"rage (MC/DC) is the percentage of individual; branch conditions that have been shown to independently affect the decision; outcome of the boolean expression they comprise. This is accomplished using; the analysis of executed control flow through the expression (i.e. test; vectors) to show that as a condition's outcome is varied between ""true"" and; false"", the decision's outcome also varies between ""true"" and false"", while; the outcome of all other conditions is held fixed (or they are masked out as; unevaluatable, as happens in languages whose logical operators have; short-circuit semantics). MC/DC builds on top of branch coverage and; requires that all code blocks and all execution paths have been tested. This; statistic is hidden by default in reports, but it can be enabled via the; ``-show-mcdc-summary`` option as long as code was also compiled using the; clang option ``-fcoverage-mcdc``. * Boolean expressions that are only comprised of one condition (and therefore; have no logical operators) are not included in MC/DC analysis and are; trivially deducible using branch coverage. Of these six statistics, function coverage is usually the least granular while; branch coverage (with MC/DC) is the most granular. 100% branch coverage for a; function implies 100% region coverage for a function. The project-wide totals; for each statistic are listed in the summary. Format compatibility guarantees; ===============================. * There are no backwards or forwards compatibility guarantees for the raw; profile format. Raw profiles may be dependent on the specific compiler; revision used to generate them. It's inadvisable to store raw profiles for; long periods of time. * Tools must retain **backwards** compatibility with indexed profile formats.; These formats are not forwards-compatible: i.e, a tool which uses format; version X will not be able to understand format version (X+k). * Tools must also retain **backwards** compatibility with the format of the; coverage mappin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:21231,Testability,log,logical,21231,"e these macro-based; boolean expressions in the overall branch coverage count for a function or; source file. Branch coverage is not tracked for constant folded branch conditions since; branches are not generated for these cases. In the source-based file-level; sub-view, these branches will simply be shown as ``[Folded - Ignored]`` so that; users are informed about what happened. Branch coverage is tied directly to branch-generating conditions in the source; code. Users should not see hidden branches that aren't actually tied to the; source code. MC/DC Instrumentation; ---------------------. When instrumenting for Modified Condition/Decision Coverage (MC/DC) using the; clang option ``-fcoverage-mcdc``, users are limited to at most **six** leaf-level; conditions in a boolean expression. A warning will be generated for boolean; expressions that contain more than six, and they will not be instrumented for; MC/DC. Also, if a boolean expression is embedded in the nest of another boolean; expression but separated by a non-logical operator, this is also not supported.; For example, in ``x = (a && b && c && func(d && f))``, the ``d && f`` case; starts a new boolean expression that is separated from the other conditions by; the operator ``func()``. When this is encountered, a warning will be generated; and the boolean expression will not be instrumented. Switch statements; -----------------. The region mapping for a switch body consists of a gap region that covers the; entire body (starting from the '{' in 'switch (...) {', and terminating where the; last case ends). This gap region has a zero count: this causes ""gap"" areas in; between case statements, which contain no executable code, to appear uncovered. When a switch case is visited, the parent region is extended: if the parent; region has no start location, its start location becomes the start of the case.; This is used to support switch statements without a ``CompoundStmt`` body, in; which the switch body and the single",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:1736,Usability,simpl,simply,1736," to the source-based kind. The code coverage workflow; ==========================. The code coverage workflow consists of three main steps:. * Compiling with coverage enabled. * Running the instrumented program. * Creating coverage reports. The next few sections work through a complete, copy-'n-paste friendly example; based on this program:. .. code-block:: cpp. % cat <<EOF > foo.cc; #define BAR(x) ((x) || (x)); template <typename T> void foo(T x) {; for (unsigned I = 0; I < 10; ++I) { BAR(I); }; }; int main() {; foo<int>(0);; foo<float>(0);; return 0;; }; EOF. Compiling with coverage enabled; ===============================. To compile code with coverage enabled, pass ``-fprofile-instr-generate; -fcoverage-mapping`` to the compiler:. .. code-block:: console. # Step 1: Compile with coverage enabled.; % clang++ -fprofile-instr-generate -fcoverage-mapping foo.cc -o foo. Note that linking together code with and without coverage instrumentation is; supported. Uninstrumented code simply won't be accounted for in reports. To compile code with Modified Condition/Decision Coverage (MC/DC) enabled,; pass ``-fcoverage-mcdc`` in addition to the clang options specified above.; MC/DC is an advanced form of code coverage most applicable in the embedded; space. Running the instrumented program; ================================. The next step is to run the instrumented program. When the program exits it; will write a **raw profile** to the path specified by the ``LLVM_PROFILE_FILE``; environment variable. If that variable does not exist, the profile is written; to ``default.profraw`` in the current directory of the program. If; ``LLVM_PROFILE_FILE`` contains a path to a non-existent directory, the missing; directory structure will be created. Additionally, the following special; **pattern strings** are rewritten:. * ""%p"" expands out to the process ID. * ""%h"" expands out to the hostname of the machine running the program. * ""%t"" expands out to the value of the ``TMPDIR`` environment",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:6500,Usability,simpl,simplest,6500,"VM_PROFILE_FILE`` for each invocation. The pattern strings ""%p"" or ""%Nm""; may help to avoid corruption due to concurrency. Note that ""%p"" is also a Lit; token and needs to be escaped as ""%%p"". .. code-block:: console. % clang++ -fprofile-instr-generate -fcoverage-mapping -mllvm -runtime-counter-relocation foo.cc -o foo. Creating coverage reports; =========================. Raw profiles have to be **indexed** before they can be used to generate; coverage reports. This is done using the ""merge"" tool in ``llvm-profdata``; (which can combine multiple raw profiles and index them at the same time):. .. code-block:: console. # Step 3(a): Index the raw profile.; % llvm-profdata merge -sparse foo.profraw -o foo.profdata. For an example of merging multiple profiles created by testing,; see the LLVM `coverage build script <https://github.com/llvm/llvm-zorg/blob/main/zorg/jenkins/jobs/jobs/llvm-coverage>`_. There are multiple different ways to render coverage reports. The simplest; option is to generate a line-oriented report:. .. code-block:: console. # Step 3(b): Create a line-oriented coverage report.; % llvm-cov show ./foo -instr-profile=foo.profdata. This report includes a summary view as well as dedicated sub-views for; templated functions and their instantiations. For our example program, we get; distinct views for ``foo<int>(...)`` and ``foo<float>(...)``. If; ``-show-line-counts-or-regions`` is enabled, ``llvm-cov`` displays sub-line; region counts (even in macro expansions):. .. code-block:: none. 1| 20|#define BAR(x) ((x) || (x)); ^20 ^2; 2| 2|template <typename T> void foo(T x) {; 3| 22| for (unsigned I = 0; I < 10; ++I) { BAR(I); }; ^22 ^20 ^20^20; 4| 2|}; ------------------; | void foo<int>(int):; | 2| 1|template <typename T> void foo(T x) {; | 3| 11| for (unsigned I = 0; I < 10; ++I) { BAR(I); }; | ^11 ^10 ^10^10; | 4| 1|}; ------------------; | void foo<float>(int):; | 2| 1|template <typename T> void foo(T x) {; | 3| 11| for (unsigned I = 0; I < 10; ++I) { BAR(I)",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:9600,Usability,guid,guide,9600," generate a file-level summary of coverage statistics instead of a; line-oriented report, try:. .. code-block:: console. # Step 3(c): Create a coverage summary.; % llvm-cov report ./foo -instr-profile=foo.profdata; Filename Regions Missed Regions Cover Functions Missed Functions Executed Lines Missed Lines Cover Branches Missed Branches Cover; --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------; /tmp/foo.cc 13 0 100.00% 3 0 100.00% 13 0 100.00% 12 2 83.33%; --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------; TOTAL 13 0 100.00% 3 0 100.00% 13 0 100.00% 12 2 83.33%. The ``llvm-cov`` tool supports specifying a custom demangler, writing out; reports in a directory structure, and generating html reports. For the full; list of options, please refer to the `command guide; <https://llvm.org/docs/CommandGuide/llvm-cov.html>`_. A few final notes:. * The ``-sparse`` flag is optional but can result in dramatically smaller; indexed profiles. This option should not be used if the indexed profile will; be reused for PGO. * Raw profiles can be discarded after they are indexed. Advanced use of the; profile runtime library allows an instrumented program to merge profiling; information directly into an existing raw profile on disk. The details are; out of scope. * The ``llvm-profdata`` tool can be used to merge together multiple raw or; indexed profiles. To combine profiling data from multiple runs of a program,; try e.g:. .. code-block:: console. % llvm-profdata merge -sparse foo1.profraw foo2.profdata -o foo3.profdata. Exporting coverage data; =======================. Coverage data can be exported into JSON using the ``llvm-cov export``; sub-command. There is a comprehensive reference which defines the structure of; the exported data at",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:14756,Usability,simpl,simplification,14756,"lity guarantees for the raw; profile format. Raw profiles may be dependent on the specific compiler; revision used to generate them. It's inadvisable to store raw profiles for; long periods of time. * Tools must retain **backwards** compatibility with indexed profile formats.; These formats are not forwards-compatible: i.e, a tool which uses format; version X will not be able to understand format version (X+k). * Tools must also retain **backwards** compatibility with the format of the; coverage mappings emitted into instrumented binaries. These formats are not; forwards-compatible. * The JSON coverage export format has a (major, minor, patch) version triple.; Only a major version increment indicates a backwards-incompatible change. A; minor version increment is for added functionality, and patch version; increments are for bugfixes. Impact of llvm optimizations on coverage reports; ================================================. llvm optimizations (such as inlining or CFG simplification) should have no; impact on coverage report quality. This is due to the fact that the mapping; from source regions to profile counters is immutable, and is generated before; the llvm optimizer kicks in. The optimizer can't prove that profile counter; instrumentation is safe to delete (because it's not: it affects the profile the; program emits), and so leaves it alone. Note that this coverage feature does not rely on information that can degrade; during the course of optimization, such as debug info line tables. Using the profiling runtime without static initializers; =======================================================. By default the compiler runtime uses a static initializer to determine the; profile output path and to register a writer function. To collect profiles; without using static initializers, do this manually:. * Export a ``int __llvm_profile_runtime`` symbol from each instrumented shared; library and executable. When the linker finds a definition of this symbol, it; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst:20491,Usability,simpl,simply,20491," cannot set a line; execution count to the count from a gap region unless that region is the only; one on a line. Gap regions are used to eliminate unnatural artifacts in coverage reports, such; as red ""unexecuted"" highlights present at the end of an otherwise covered line,; or blue ""executed"" highlights present at the start of a line that is otherwise; not executed. Branch regions; --------------; When viewing branch coverage details in source-based file-level sub-views using; ``--show-branches``, it is recommended that users show all macro expansions; (using option ``--show-expansions``) since macros may contain hidden branch; conditions. The coverage summary report will always include these macro-based; boolean expressions in the overall branch coverage count for a function or; source file. Branch coverage is not tracked for constant folded branch conditions since; branches are not generated for these cases. In the source-based file-level; sub-view, these branches will simply be shown as ``[Folded - Ignored]`` so that; users are informed about what happened. Branch coverage is tied directly to branch-generating conditions in the source; code. Users should not see hidden branches that aren't actually tied to the; source code. MC/DC Instrumentation; ---------------------. When instrumenting for Modified Condition/Decision Coverage (MC/DC) using the; clang option ``-fcoverage-mcdc``, users are limited to at most **six** leaf-level; conditions in a boolean expression. A warning will be generated for boolean; expressions that contain more than six, and they will not be instrumented for; MC/DC. Also, if a boolean expression is embedded in the nest of another boolean; expression but separated by a non-logical operator, this is also not supported.; For example, in ``x = (a && b && c && func(d && f))``, the ``d && f`` case; starts a new boolean expression that is separated from the other conditions by; the operator ``func()``. When this is encountered, a warning will be ge",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SourceBasedCodeCoverage.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:19032,Availability,error,errors,19032,"ed the ODR check for the declarations in the global module; fragment by default. Users who want more strict check can still use the; ``-Xclang -fno-skip-odr-check-in-gmf`` flag to get the ODR check enabled. It is also; encouraged to report issues if users find false positive ODR violations or false negative ODR; violations with the flag enabled. ABI Impacts; -----------. The declarations in a module unit which are not in the global module fragment have new linkage names. For example,. .. code-block:: c++. export module M;; namespace NS {; export int foo();; }. The linkage name of ``NS::foo()`` would be ``_ZN2NSW1M3fooEv``.; This couldn't be demangled by previous versions of the debugger or demangler.; As of LLVM 15.x, users can utilize ``llvm-cxxfilt`` to demangle this:. .. code-block:: console. $ llvm-cxxfilt _ZN2NSW1M3fooEv. The result would be ``NS::foo@M()``, which reads as ``NS::foo()`` in module ``M``. The ABI implies that we can't declare something in a module unit and define it in a non-module unit (or vice-versa),; as this would result in linking errors. If we still want to implement declarations within the compatible ABI in module unit,; we can use the language-linkage specifier. Since the declarations in the language-linkage specifier; is attached to the global module fragments. For example:. .. code-block:: c++. export module M;; namespace NS {; export extern ""C++"" int foo();; }. Now the linkage name of ``NS::foo()`` will be ``_ZN2NS3fooEv``. Performance Tips; ----------------. Reduce duplications; ~~~~~~~~~~~~~~~~~~~. While it is legal to have duplicated declarations in the global module fragments; of different module units, it is not free for clang to deal with the duplicated; declarations. In other word, for a translation unit, it will compile slower if the; translation unit itself and its importing module units contains a lot duplicated; declarations. For example,. .. code-block:: c++. // M-partA.cppm; module;; #include ""big.header.h""; export module ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:38139,Availability,error,errors,38139,"ules.; To address the requirement, clang-scan-deps will recognize the specified preprocessor options; in the given command line and generate the corresponding dependency information. For example,. .. code-block:: console. $ clang-scan-deps -format=p1689 -- ../bin/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o -MD -MT impl_part.ddi -MF impl_part.dep; $ cat impl_part.dep. We will get:. .. code-block:: text. impl_part.ddi: \; /usr/include/bits/wchar.h /usr/include/bits/types/wint_t.h \; /usr/include/bits/types/mbstate_t.h \; /usr/include/bits/types/__mbstate_t.h /usr/include/bits/types/__FILE.h \; /usr/include/bits/types/FILE.h /usr/include/bits/types/locale_t.h \; /usr/include/bits/types/__locale_t.h \; ... When clang-scan-deps detects ``-MF`` option, clang-scan-deps will try to write the; dependency information for headers to the file specified by ``-MF``. Possible Issues: Failed to find system headers; ----------------------------------------------. In case the users encounter errors like ``fatal error: 'stddef.h' file not found``,; probably the specified ``<path-to-compiler-executable>/clang++`` refers to a symlink; instead a real binary. There are 4 potential solutions to the problem:. * (1) End users can resolve the issue by pointing the specified compiler executable to; the real binary instead of the symlink.; * (2) End users can invoke ``<path-to-compiler-executable>/clang++ -print-resource-dir``; to get the corresponding resource directory for your compiler and add that directory; to the include search paths manually in the build scripts.; * (3) Build systems that use a compilation database as the input for clang-scan-deps; scanner, the build system can add the flag ``--resource-dir-recipe invoke-compiler`` to; the clang-scan-deps scanner to calculate the resources directory dynamically.; The calculation happens only once for a unique ``<path-to-compiler-executable>/clang++``.; * (4) For build systems that invokes the clang-scan-deps scanner per file, rep",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:38159,Availability,error,error,38159,"ules.; To address the requirement, clang-scan-deps will recognize the specified preprocessor options; in the given command line and generate the corresponding dependency information. For example,. .. code-block:: console. $ clang-scan-deps -format=p1689 -- ../bin/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o -MD -MT impl_part.ddi -MF impl_part.dep; $ cat impl_part.dep. We will get:. .. code-block:: text. impl_part.ddi: \; /usr/include/bits/wchar.h /usr/include/bits/types/wint_t.h \; /usr/include/bits/types/mbstate_t.h \; /usr/include/bits/types/__mbstate_t.h /usr/include/bits/types/__FILE.h \; /usr/include/bits/types/FILE.h /usr/include/bits/types/locale_t.h \; /usr/include/bits/types/__locale_t.h \; ... When clang-scan-deps detects ``-MF`` option, clang-scan-deps will try to write the; dependency information for headers to the file specified by ``-MF``. Possible Issues: Failed to find system headers; ----------------------------------------------. In case the users encounter errors like ``fatal error: 'stddef.h' file not found``,; probably the specified ``<path-to-compiler-executable>/clang++`` refers to a symlink; instead a real binary. There are 4 potential solutions to the problem:. * (1) End users can resolve the issue by pointing the specified compiler executable to; the real binary instead of the symlink.; * (2) End users can invoke ``<path-to-compiler-executable>/clang++ -print-resource-dir``; to get the corresponding resource directory for your compiler and add that directory; to the include search paths manually in the build scripts.; * (3) Build systems that use a compilation database as the input for clang-scan-deps; scanner, the build system can add the flag ``--resource-dir-recipe invoke-compiler`` to; the clang-scan-deps scanner to calculate the resources directory dynamically.; The calculation happens only once for a unique ``<path-to-compiler-executable>/clang++``.; * (4) For build systems that invokes the clang-scan-deps scanner per file, rep",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:40074,Availability,redundant,redundant,40074,"or build systems that invokes the clang-scan-deps scanner per file, repeatedly; calculating the resource directory may be inefficient. In such cases, the build; system can cache the resource directory by itself and pass ``-resource-dir <resource-dir>``; explicitly in the command line options:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 -resource-dir <resource-dir> mod.cppm -c -o mod.o. Possible Questions; ==================. How modules speed up compilation; --------------------------------. A classic theory for the reason why modules speed up the compilation is:; if there are ``n`` headers and ``m`` source files and each header is included by each source file,; then the complexity of the compilation is ``O(n*m)``;; But if there are ``n`` module interfaces and ``m`` source files, the complexity of the compilation is; ``O(n+m)``. So, using modules would be a big win when scaling.; In a simpler word, we could get rid of many redundant compilations by using modules. Roughly, this theory is correct. But the problem is that it is too rough.; The behavior depends on the optimization level, as we will illustrate below. First is ``O0``. The compilation process is described in the following graph. .. code-block:: none. ├-------------frontend----------┼-------------middle end----------------┼----backend----┤; │ │ │ │; └---parsing----sema----codegen--┴----- transformations ---- codegen ----┴---- codegen --┘. ┌---------------------------------------------------------------------------------------┐; | │; | source file │; | │; └---------------------------------------------------------------------------------------┘. ┌--------┐; │ │; │imported│; │ │; │ code │; │ │; └--------┘. Here we can see that the source file (could be a non-module unit or a module unit) would get processed by the; whole pipeline.; But the imported code would only get involved in semantic analysis, which is mainly about name lookup,; overload re",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:40945,Deployability,pipeline,pipeline,40945,"le interfaces and ``m`` source files, the complexity of the compilation is; ``O(n+m)``. So, using modules would be a big win when scaling.; In a simpler word, we could get rid of many redundant compilations by using modules. Roughly, this theory is correct. But the problem is that it is too rough.; The behavior depends on the optimization level, as we will illustrate below. First is ``O0``. The compilation process is described in the following graph. .. code-block:: none. ├-------------frontend----------┼-------------middle end----------------┼----backend----┤; │ │ │ │; └---parsing----sema----codegen--┴----- transformations ---- codegen ----┴---- codegen --┘. ┌---------------------------------------------------------------------------------------┐; | │; | source file │; | │; └---------------------------------------------------------------------------------------┘. ┌--------┐; │ │; │imported│; │ │; │ code │; │ │; └--------┘. Here we can see that the source file (could be a non-module unit or a module unit) would get processed by the; whole pipeline.; But the imported code would only get involved in semantic analysis, which is mainly about name lookup,; overload resolution and template instantiation.; All of these processes are fast relative to the whole compilation process.; More importantly, the imported code only needs to be processed once in frontend code generation,; as well as the whole middle end and backend.; So we could get a big win for the compilation time in O0. But with optimizations, things are different:. (we omit ``code generation`` part for each end due to the limited space). .. code-block:: none. ├-------- frontend ---------┼--------------- middle end --------------------┼------ backend ----┤; │ │ │ │; └--- parsing ---- sema -----┴--- optimizations --- IPO ---- optimizations---┴--- optimizations -┘. ┌-----------------------------------------------------------------------------------------------┐; │ │; │ source file │; │ │; └---------------------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:21061,Energy Efficiency,reduce,reduce,21061,"ons; ... // M-partZ.cppm; module;; #include ""big.header.h""; export module M:partZ;; ... // M.cppm; export module M;; export import :partA;; export import :partB;; ...; export import :partZ;. // use.cpp; import M;; ... // use declarations from module M. When ``big.header.h`` is big enough and there are a lot of partitions,; the compilation of ``use.cpp`` may be slower than; the following style significantly:. .. code-block:: c++. module;; #include ""big.header.h""; export module m:big.header.wrapper;; export ... // export the needed declarations. // M-partA.cppm; export module M:partA;; import :big.header.wrapper;; ... // M-partB.cppm; export module M:partB;; import :big.header.wrapper;; ... // other partitions; ... // M-partZ.cppm; export module M:partZ;; import :big.header.wrapper;; ... // M.cppm; export module M;; export import :partA;; export import :partB;; ...; export import :partZ;. // use.cpp; import M;; ... // use declarations from module M. The key part of the tip is to reduce the duplications from the text includes. Known Problems; --------------. The following describes issues in the current implementation of modules.; Please see https://github.com/llvm/llvm-project/labels/clang%3Amodules for more issues; or file a new issue if you don't find an existing one.; If you're going to create a new issue for standard C++ modules,; please start the title with ``[C++20] [Modules]`` (or ``[C++23] [Modules]``, etc); and add the label ``clang:modules`` (if you have permissions for that). For higher level support for proposals, you could visit https://clang.llvm.org/cxx_status.html. Including headers after import is problematic; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. For example, the following example can be accept:. .. code-block:: c++. #include <iostream>; import foo; // assume module 'foo' contain the declarations from `<iostream>`. int main(int argc, char *argv[]); {; std::cout << ""Test\n"";; return 0;; }. but it will get rejected if we reverse the order of `",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:475,Integrability,interface,interfaces,475,"====================; Standard C++ Modules; ====================. .. contents::; :local:. Introduction; ============. The term ``modules`` has a lot of meanings. For the users of Clang, modules may; refer to ``Objective-C Modules``, ``Clang C++ Modules`` (or ``Clang Header Modules``,; etc.) or ``Standard C++ Modules``. The implementation of all these kinds of modules in Clang; has a lot of shared code, but from the perspective of users, their semantics and; command line interfaces are very different. This document focuses on; an introduction of how to use standard C++ modules in Clang. There is already a detailed document about `Clang modules <Modules.html>`_, it; should be helpful to read `Clang modules <Modules.html>`_ if you want to know; more about the general idea of modules. Since standard C++ modules have different semantics; (and work flows) from `Clang modules`, this page describes the background and use of; Clang with standard C++ modules. Modules exist in two forms in the C++ Language Specification. They can refer to; either ""Named Modules"" or to ""Header Units"". This document covers both forms. Standard C++ Named modules; ==========================. This document was intended to be a manual first and foremost, however, we consider it helpful to; introduce some language background here for readers who are not familiar with; the new language feature. This document is not intended to be a language; tutorial; it will only introduce necessary concepts about the; structure and building of the project. Background and terminology; --------------------------. Modules; ~~~~~~~. In this document, the term ``Modules``/``modules`` refers to standard C++ modules; feature if it is not decorated by ``Clang``. Clang Modules; ~~~~~~~~~~~~~. In this document, the term ``Clang Modules``/``Clang modules`` refer to Clang; c++ modules extension. These are also known as ``Clang header modules``,; ``Clang module map modules`` or ``Clang c++ modules``. Module and module unit; ~~~~~",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:2597,Integrability,interface,interface,2597,"; ~~~~~~~. In this document, the term ``Modules``/``modules`` refers to standard C++ modules; feature if it is not decorated by ``Clang``. Clang Modules; ~~~~~~~~~~~~~. In this document, the term ``Clang Modules``/``Clang modules`` refer to Clang; c++ modules extension. These are also known as ``Clang header modules``,; ``Clang module map modules`` or ``Clang c++ modules``. Module and module unit; ~~~~~~~~~~~~~~~~~~~~~~. A module consists of one or more module units. A module unit is a special; translation unit. Every module unit must have a module declaration. The syntax; of the module declaration is:. .. code-block:: c++. [export] module module_name[:partition_name];. Terms enclosed in ``[]`` are optional. The syntax of ``module_name`` and ``partition_name``; in regex form corresponds to ``[a-zA-Z_][a-zA-Z_0-9\.]*``. In particular, a literal dot ``.``; in the name has no semantic meaning (e.g. implying a hierarchy). In this document, module units are classified into:. * Primary module interface unit. * Module implementation unit. * Module interface partition unit. * Internal module partition unit. A primary module interface unit is a module unit whose module declaration is; ``export module module_name;``. The ``module_name`` here denotes the name of the; module. A module should have one and only one primary module interface unit. A module implementation unit is a module unit whose module declaration is; ``module module_name;``. A module could have multiple module implementation; units with the same declaration. A module interface partition unit is a module unit whose module declaration is; ``export module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. An internal module partition unit is a module unit whose module declaration; is ``module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. In this document, we use the following umbrella terms:. * A ``module interface unit",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:2652,Integrability,interface,interface,2652,"fers to standard C++ modules; feature if it is not decorated by ``Clang``. Clang Modules; ~~~~~~~~~~~~~. In this document, the term ``Clang Modules``/``Clang modules`` refer to Clang; c++ modules extension. These are also known as ``Clang header modules``,; ``Clang module map modules`` or ``Clang c++ modules``. Module and module unit; ~~~~~~~~~~~~~~~~~~~~~~. A module consists of one or more module units. A module unit is a special; translation unit. Every module unit must have a module declaration. The syntax; of the module declaration is:. .. code-block:: c++. [export] module module_name[:partition_name];. Terms enclosed in ``[]`` are optional. The syntax of ``module_name`` and ``partition_name``; in regex form corresponds to ``[a-zA-Z_][a-zA-Z_0-9\.]*``. In particular, a literal dot ``.``; in the name has no semantic meaning (e.g. implying a hierarchy). In this document, module units are classified into:. * Primary module interface unit. * Module implementation unit. * Module interface partition unit. * Internal module partition unit. A primary module interface unit is a module unit whose module declaration is; ``export module module_name;``. The ``module_name`` here denotes the name of the; module. A module should have one and only one primary module interface unit. A module implementation unit is a module unit whose module declaration is; ``module module_name;``. A module could have multiple module implementation; units with the same declaration. A module interface partition unit is a module unit whose module declaration is; ``export module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. An internal module partition unit is a module unit whose module declaration; is ``module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. In this document, we use the following umbrella terms:. * A ``module interface unit`` refers to either a ``primary module interface unit``; or a ``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:2729,Integrability,interface,interface,2729," this document, the term ``Clang Modules``/``Clang modules`` refer to Clang; c++ modules extension. These are also known as ``Clang header modules``,; ``Clang module map modules`` or ``Clang c++ modules``. Module and module unit; ~~~~~~~~~~~~~~~~~~~~~~. A module consists of one or more module units. A module unit is a special; translation unit. Every module unit must have a module declaration. The syntax; of the module declaration is:. .. code-block:: c++. [export] module module_name[:partition_name];. Terms enclosed in ``[]`` are optional. The syntax of ``module_name`` and ``partition_name``; in regex form corresponds to ``[a-zA-Z_][a-zA-Z_0-9\.]*``. In particular, a literal dot ``.``; in the name has no semantic meaning (e.g. implying a hierarchy). In this document, module units are classified into:. * Primary module interface unit. * Module implementation unit. * Module interface partition unit. * Internal module partition unit. A primary module interface unit is a module unit whose module declaration is; ``export module module_name;``. The ``module_name`` here denotes the name of the; module. A module should have one and only one primary module interface unit. A module implementation unit is a module unit whose module declaration is; ``module module_name;``. A module could have multiple module implementation; units with the same declaration. A module interface partition unit is a module unit whose module declaration is; ``export module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. An internal module partition unit is a module unit whose module declaration; is ``module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. In this document, we use the following umbrella terms:. * A ``module interface unit`` refers to either a ``primary module interface unit``; or a ``module interface partition unit``. * An ``importable module unit`` refers to either a ``module interface u",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:2933,Integrability,interface,interface,2933,"`,; ``Clang module map modules`` or ``Clang c++ modules``. Module and module unit; ~~~~~~~~~~~~~~~~~~~~~~. A module consists of one or more module units. A module unit is a special; translation unit. Every module unit must have a module declaration. The syntax; of the module declaration is:. .. code-block:: c++. [export] module module_name[:partition_name];. Terms enclosed in ``[]`` are optional. The syntax of ``module_name`` and ``partition_name``; in regex form corresponds to ``[a-zA-Z_][a-zA-Z_0-9\.]*``. In particular, a literal dot ``.``; in the name has no semantic meaning (e.g. implying a hierarchy). In this document, module units are classified into:. * Primary module interface unit. * Module implementation unit. * Module interface partition unit. * Internal module partition unit. A primary module interface unit is a module unit whose module declaration is; ``export module module_name;``. The ``module_name`` here denotes the name of the; module. A module should have one and only one primary module interface unit. A module implementation unit is a module unit whose module declaration is; ``module module_name;``. A module could have multiple module implementation; units with the same declaration. A module interface partition unit is a module unit whose module declaration is; ``export module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. An internal module partition unit is a module unit whose module declaration; is ``module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. In this document, we use the following umbrella terms:. * A ``module interface unit`` refers to either a ``primary module interface unit``; or a ``module interface partition unit``. * An ``importable module unit`` refers to either a ``module interface unit``; or a ``internal module partition unit``. * A ``module partition unit`` refers to either a ``module interface partition unit``; or a ``interna",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:3143,Integrability,interface,interface,3143,"tion is:. .. code-block:: c++. [export] module module_name[:partition_name];. Terms enclosed in ``[]`` are optional. The syntax of ``module_name`` and ``partition_name``; in regex form corresponds to ``[a-zA-Z_][a-zA-Z_0-9\.]*``. In particular, a literal dot ``.``; in the name has no semantic meaning (e.g. implying a hierarchy). In this document, module units are classified into:. * Primary module interface unit. * Module implementation unit. * Module interface partition unit. * Internal module partition unit. A primary module interface unit is a module unit whose module declaration is; ``export module module_name;``. The ``module_name`` here denotes the name of the; module. A module should have one and only one primary module interface unit. A module implementation unit is a module unit whose module declaration is; ``module module_name;``. A module could have multiple module implementation; units with the same declaration. A module interface partition unit is a module unit whose module declaration is; ``export module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. An internal module partition unit is a module unit whose module declaration; is ``module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. In this document, we use the following umbrella terms:. * A ``module interface unit`` refers to either a ``primary module interface unit``; or a ``module interface partition unit``. * An ``importable module unit`` refers to either a ``module interface unit``; or a ``internal module partition unit``. * A ``module partition unit`` refers to either a ``module interface partition unit``; or a ``internal module partition unit``. Built Module Interface file; ~~~~~~~~~~~~~~~~~~~~~~~~~~~. A ``Built Module Interface file`` stands for the precompiled result of an importable module unit.; It is also called the acronym ``BMI`` generally. Global module fragment; ~~~~~~~~~~~~~~~~~~~~~~. In",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:3582,Integrability,interface,interface,3582,"ation unit. * Module interface partition unit. * Internal module partition unit. A primary module interface unit is a module unit whose module declaration is; ``export module module_name;``. The ``module_name`` here denotes the name of the; module. A module should have one and only one primary module interface unit. A module implementation unit is a module unit whose module declaration is; ``module module_name;``. A module could have multiple module implementation; units with the same declaration. A module interface partition unit is a module unit whose module declaration is; ``export module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. An internal module partition unit is a module unit whose module declaration; is ``module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. In this document, we use the following umbrella terms:. * A ``module interface unit`` refers to either a ``primary module interface unit``; or a ``module interface partition unit``. * An ``importable module unit`` refers to either a ``module interface unit``; or a ``internal module partition unit``. * A ``module partition unit`` refers to either a ``module interface partition unit``; or a ``internal module partition unit``. Built Module Interface file; ~~~~~~~~~~~~~~~~~~~~~~~~~~~. A ``Built Module Interface file`` stands for the precompiled result of an importable module unit.; It is also called the acronym ``BMI`` generally. Global module fragment; ~~~~~~~~~~~~~~~~~~~~~~. In a module unit, the section from ``module;`` to the module declaration is called the global module fragment. How to build projects using modules; -----------------------------------. Quick Start; ~~~~~~~~~~~. Let's see a ""hello world"" example that uses modules. .. code-block:: c++. // Hello.cppm; module;; #include <iostream>; export module Hello;; export void hello() {; std::cout << ""Hello World!\n"";; }. // use.cpp; import Hello;;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:3635,Integrability,interface,interface,3635,"ation unit. * Module interface partition unit. * Internal module partition unit. A primary module interface unit is a module unit whose module declaration is; ``export module module_name;``. The ``module_name`` here denotes the name of the; module. A module should have one and only one primary module interface unit. A module implementation unit is a module unit whose module declaration is; ``module module_name;``. A module could have multiple module implementation; units with the same declaration. A module interface partition unit is a module unit whose module declaration is; ``export module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. An internal module partition unit is a module unit whose module declaration; is ``module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. In this document, we use the following umbrella terms:. * A ``module interface unit`` refers to either a ``primary module interface unit``; or a ``module interface partition unit``. * An ``importable module unit`` refers to either a ``module interface unit``; or a ``internal module partition unit``. * A ``module partition unit`` refers to either a ``module interface partition unit``; or a ``internal module partition unit``. Built Module Interface file; ~~~~~~~~~~~~~~~~~~~~~~~~~~~. A ``Built Module Interface file`` stands for the precompiled result of an importable module unit.; It is also called the acronym ``BMI`` generally. Global module fragment; ~~~~~~~~~~~~~~~~~~~~~~. In a module unit, the section from ``module;`` to the module declaration is called the global module fragment. How to build projects using modules; -----------------------------------. Quick Start; ~~~~~~~~~~~. Let's see a ""hello world"" example that uses modules. .. code-block:: c++. // Hello.cppm; module;; #include <iostream>; export module Hello;; export void hello() {; std::cout << ""Hello World!\n"";; }. // use.cpp; import Hello;;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:3667,Integrability,interface,interface,3667,"ation unit. * Module interface partition unit. * Internal module partition unit. A primary module interface unit is a module unit whose module declaration is; ``export module module_name;``. The ``module_name`` here denotes the name of the; module. A module should have one and only one primary module interface unit. A module implementation unit is a module unit whose module declaration is; ``module module_name;``. A module could have multiple module implementation; units with the same declaration. A module interface partition unit is a module unit whose module declaration is; ``export module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. An internal module partition unit is a module unit whose module declaration; is ``module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. In this document, we use the following umbrella terms:. * A ``module interface unit`` refers to either a ``primary module interface unit``; or a ``module interface partition unit``. * An ``importable module unit`` refers to either a ``module interface unit``; or a ``internal module partition unit``. * A ``module partition unit`` refers to either a ``module interface partition unit``; or a ``internal module partition unit``. Built Module Interface file; ~~~~~~~~~~~~~~~~~~~~~~~~~~~. A ``Built Module Interface file`` stands for the precompiled result of an importable module unit.; It is also called the acronym ``BMI`` generally. Global module fragment; ~~~~~~~~~~~~~~~~~~~~~~. In a module unit, the section from ``module;`` to the module declaration is called the global module fragment. How to build projects using modules; -----------------------------------. Quick Start; ~~~~~~~~~~~. Let's see a ""hello world"" example that uses modules. .. code-block:: c++. // Hello.cppm; module;; #include <iostream>; export module Hello;; export void hello() {; std::cout << ""Hello World!\n"";; }. // use.cpp; import Hello;;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:3755,Integrability,interface,interface,3755,"le unit whose module declaration is; ``export module module_name;``. The ``module_name`` here denotes the name of the; module. A module should have one and only one primary module interface unit. A module implementation unit is a module unit whose module declaration is; ``module module_name;``. A module could have multiple module implementation; units with the same declaration. A module interface partition unit is a module unit whose module declaration is; ``export module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. An internal module partition unit is a module unit whose module declaration; is ``module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. In this document, we use the following umbrella terms:. * A ``module interface unit`` refers to either a ``primary module interface unit``; or a ``module interface partition unit``. * An ``importable module unit`` refers to either a ``module interface unit``; or a ``internal module partition unit``. * A ``module partition unit`` refers to either a ``module interface partition unit``; or a ``internal module partition unit``. Built Module Interface file; ~~~~~~~~~~~~~~~~~~~~~~~~~~~. A ``Built Module Interface file`` stands for the precompiled result of an importable module unit.; It is also called the acronym ``BMI`` generally. Global module fragment; ~~~~~~~~~~~~~~~~~~~~~~. In a module unit, the section from ``module;`` to the module declaration is called the global module fragment. How to build projects using modules; -----------------------------------. Quick Start; ~~~~~~~~~~~. Let's see a ""hello world"" example that uses modules. .. code-block:: c++. // Hello.cppm; module;; #include <iostream>; export module Hello;; export void hello() {; std::cout << ""Hello World!\n"";; }. // use.cpp; import Hello;; int main() {; hello();; return 0;; }. Then we type:. .. code-block:: console. $ clang++ -std=c++20 Hello.cppm --precompile",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:3872,Integrability,interface,interface,3872,"le. A module should have one and only one primary module interface unit. A module implementation unit is a module unit whose module declaration is; ``module module_name;``. A module could have multiple module implementation; units with the same declaration. A module interface partition unit is a module unit whose module declaration is; ``export module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. An internal module partition unit is a module unit whose module declaration; is ``module module_name:partition_name;``. The ``partition_name`` should be; unique within any given module. In this document, we use the following umbrella terms:. * A ``module interface unit`` refers to either a ``primary module interface unit``; or a ``module interface partition unit``. * An ``importable module unit`` refers to either a ``module interface unit``; or a ``internal module partition unit``. * A ``module partition unit`` refers to either a ``module interface partition unit``; or a ``internal module partition unit``. Built Module Interface file; ~~~~~~~~~~~~~~~~~~~~~~~~~~~. A ``Built Module Interface file`` stands for the precompiled result of an importable module unit.; It is also called the acronym ``BMI`` generally. Global module fragment; ~~~~~~~~~~~~~~~~~~~~~~. In a module unit, the section from ``module;`` to the module declaration is called the global module fragment. How to build projects using modules; -----------------------------------. Quick Start; ~~~~~~~~~~~. Let's see a ""hello world"" example that uses modules. .. code-block:: c++. // Hello.cppm; module;; #include <iostream>; export module Hello;; export void hello() {; std::cout << ""Hello World!\n"";; }. // use.cpp; import Hello;; int main() {; hello();; return 0;; }. Then we type:. .. code-block:: console. $ clang++ -std=c++20 Hello.cppm --precompile -o Hello.pcm; $ clang++ -std=c++20 use.cpp -fmodule-file=Hello=Hello.pcm Hello.pcm -o Hello.out; $ ./Hello.out; Hello Worl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:4978,Integrability,interface,interface,4978," Built Module Interface file; ~~~~~~~~~~~~~~~~~~~~~~~~~~~. A ``Built Module Interface file`` stands for the precompiled result of an importable module unit.; It is also called the acronym ``BMI`` generally. Global module fragment; ~~~~~~~~~~~~~~~~~~~~~~. In a module unit, the section from ``module;`` to the module declaration is called the global module fragment. How to build projects using modules; -----------------------------------. Quick Start; ~~~~~~~~~~~. Let's see a ""hello world"" example that uses modules. .. code-block:: c++. // Hello.cppm; module;; #include <iostream>; export module Hello;; export void hello() {; std::cout << ""Hello World!\n"";; }. // use.cpp; import Hello;; int main() {; hello();; return 0;; }. Then we type:. .. code-block:: console. $ clang++ -std=c++20 Hello.cppm --precompile -o Hello.pcm; $ clang++ -std=c++20 use.cpp -fmodule-file=Hello=Hello.pcm Hello.pcm -o Hello.out; $ ./Hello.out; Hello World!. In this example, we make and use a simple module ``Hello`` which contains only a; primary module interface unit ``Hello.cppm``. Then let's see a little bit more complex ""hello world"" example which uses the 4 kinds of module units. .. code-block:: c++. // M.cppm; export module M;; export import :interface_part;; import :impl_part;; export void Hello();. // interface_part.cppm; export module M:interface_part;; export void World();. // impl_part.cppm; module;; #include <iostream>; #include <string>; module M:impl_part;; import :interface_part;. std::string W = ""World."";; void World() {; std::cout << W << std::endl;; }. // Impl.cpp; module;; #include <iostream>; module M;; void Hello() {; std::cout << ""Hello "";; }. // User.cpp; import M;; int main() {; Hello();; World();; return 0;; }. Then we are able to compile the example by the following command:. .. code-block:: console. # Precompiling the module; $ clang++ -std=c++20 interface_part.cppm --precompile -o M-interface_part.pcm; $ clang++ -std=c++20 impl_part.cppm --precompile -fprebuilt-module-pa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:8043,Integrability,depend,depends,8043,"ut`` option generates the BMI as a by-product of the compilation.; If ``-fmodule-output=`` is specified, the BMI will be emitted the specified location. Then if; ``-fmodule-output`` and ``-c`` are specified, the BMI will be emitted in the directory of the; output file with the name of the input file with the new extension ``.pcm``. Otherwise, the BMI; will be emitted in the working directory with the name of the input file with the new extension; ``.pcm``. The style to generate BMIs by ``--precompile`` is called two-phase compilation since it takes; 2 steps to compile a source file to an object file. The style to generate BMIs by ``-fmodule-output``; is called one-phase compilation respectively. The one-phase compilation model is simpler; for build systems to implement and the two-phase compilation has the potential to compile faster due; to higher parallelism. As an example, if there are two module units A and B, and B depends on A, the; one-phase compilation model would need to compile them serially, whereas the two-phase compilation; model may be able to compile them simultaneously if the compilation from A.pcm to A.o takes a long; time. File name requirement; ~~~~~~~~~~~~~~~~~~~~~. The file name of an ``importable module unit`` should end with ``.cppm``; (or ``.ccm``, ``.cxxm``, ``.c++m``). The file name of a ``module implementation unit``; should end with ``.cpp`` (or ``.cc``, ``.cxx``, ``.c++``). The file name of BMIs should end with ``.pcm``.; The file name of the BMI of a ``primary module interface unit`` should be ``module_name.pcm``.; The file name of BMIs of ``module partition unit`` should be ``module_name-partition_name.pcm``. If the file names use different extensions, Clang may fail to build the module.; For example, if the filename of an ``importable module unit`` ends with ``.cpp`` instead of ``.cppm``,; then we can't generate a BMI for the ``importable module unit`` by ``--precompile`` option; since ``--precompile`` option now would only run preproc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:8631,Integrability,interface,interface,8631,"two-phase compilation since it takes; 2 steps to compile a source file to an object file. The style to generate BMIs by ``-fmodule-output``; is called one-phase compilation respectively. The one-phase compilation model is simpler; for build systems to implement and the two-phase compilation has the potential to compile faster due; to higher parallelism. As an example, if there are two module units A and B, and B depends on A, the; one-phase compilation model would need to compile them serially, whereas the two-phase compilation; model may be able to compile them simultaneously if the compilation from A.pcm to A.o takes a long; time. File name requirement; ~~~~~~~~~~~~~~~~~~~~~. The file name of an ``importable module unit`` should end with ``.cppm``; (or ``.ccm``, ``.cxxm``, ``.c++m``). The file name of a ``module implementation unit``; should end with ``.cpp`` (or ``.cc``, ``.cxx``, ``.c++``). The file name of BMIs should end with ``.pcm``.; The file name of the BMI of a ``primary module interface unit`` should be ``module_name.pcm``.; The file name of BMIs of ``module partition unit`` should be ``module_name-partition_name.pcm``. If the file names use different extensions, Clang may fail to build the module.; For example, if the filename of an ``importable module unit`` ends with ``.cpp`` instead of ``.cppm``,; then we can't generate a BMI for the ``importable module unit`` by ``--precompile`` option; since ``--precompile`` option now would only run preprocessor, which is equal to `-E` now.; If we want the filename of an ``importable module unit`` ends with other suffixes instead of ``.cppm``,; we could put ``-x c++-module`` in front of the file. For example,. .. code-block:: c++. // Hello.cpp; module;; #include <iostream>; export module Hello;; export void hello() {; std::cout << ""Hello World!\n"";; }. // use.cpp; import Hello;; int main() {; hello();; return 0;; }. Now the filename of the ``module interface`` ends with ``.cpp`` instead of ``.cppm``,; we can't com",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:9561,Integrability,interface,interface,9561," should end with ``.pcm``.; The file name of the BMI of a ``primary module interface unit`` should be ``module_name.pcm``.; The file name of BMIs of ``module partition unit`` should be ``module_name-partition_name.pcm``. If the file names use different extensions, Clang may fail to build the module.; For example, if the filename of an ``importable module unit`` ends with ``.cpp`` instead of ``.cppm``,; then we can't generate a BMI for the ``importable module unit`` by ``--precompile`` option; since ``--precompile`` option now would only run preprocessor, which is equal to `-E` now.; If we want the filename of an ``importable module unit`` ends with other suffixes instead of ``.cppm``,; we could put ``-x c++-module`` in front of the file. For example,. .. code-block:: c++. // Hello.cpp; module;; #include <iostream>; export module Hello;; export void hello() {; std::cout << ""Hello World!\n"";; }. // use.cpp; import Hello;; int main() {; hello();; return 0;; }. Now the filename of the ``module interface`` ends with ``.cpp`` instead of ``.cppm``,; we can't compile them by the original command lines. But we are still able to do it by:. .. code-block:: console. $ clang++ -std=c++20 -x c++-module Hello.cpp --precompile -o Hello.pcm; $ clang++ -std=c++20 use.cpp -fprebuilt-module-path=. Hello.pcm -o Hello.out; $ ./Hello.out; Hello World!. Module name requirement; ~~~~~~~~~~~~~~~~~~~~~~~. [module.unit]p1 says:. .. code-block:: text. All module-names either beginning with an identifier consisting of std followed by zero; or more digits or containing a reserved identifier ([lex.name]) are reserved and shall not; be specified in a module-declaration; no diagnostic is required. If any identifier in a reserved; module-name is a reserved identifier, the module name is reserved for use by C++ implementations;; otherwise it is reserved for future standardization. So all of the following name is not valid by default:. .. code-block:: text. std; std1; std.foo; __test; // and so on ... I",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:10708,Integrability,depend,dependent,10708,"sole. $ clang++ -std=c++20 -x c++-module Hello.cpp --precompile -o Hello.pcm; $ clang++ -std=c++20 use.cpp -fprebuilt-module-path=. Hello.pcm -o Hello.out; $ ./Hello.out; Hello World!. Module name requirement; ~~~~~~~~~~~~~~~~~~~~~~~. [module.unit]p1 says:. .. code-block:: text. All module-names either beginning with an identifier consisting of std followed by zero; or more digits or containing a reserved identifier ([lex.name]) are reserved and shall not; be specified in a module-declaration; no diagnostic is required. If any identifier in a reserved; module-name is a reserved identifier, the module name is reserved for use by C++ implementations;; otherwise it is reserved for future standardization. So all of the following name is not valid by default:. .. code-block:: text. std; std1; std.foo; __test; // and so on ... If you still want to use the reserved module names for any reason, use; ``-Wno-reserved-module-identifier`` to suppress the warning. How to specify the dependent BMIs; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. There are 3 methods to specify the dependent BMIs:. * (1) ``-fprebuilt-module-path=<path/to/directory>``.; * (2) ``-fmodule-file=<path/to/BMI>`` (Deprecated).; * (3) ``-fmodule-file=<module-name>=<path/to/BMI>``. The option ``-fprebuilt-module-path`` tells the compiler the path where to search for dependent BMIs.; It may be used multiple times just like ``-I`` for specifying paths for header files. The look up rule here is:. * (1) When we import module M. The compiler would look up M.pcm in the directories specified; by ``-fprebuilt-module-path``.; * (2) When we import partition module unit M:P. The compiler would look up M-P.pcm in the; directories specified by ``-fprebuilt-module-path``. The option ``-fmodule-file=<path/to/BMI>`` tells the compiler to load the specified BMI directly.; The option ``-fmodule-file=<module-name>=<path/to/BMI>`` tells the compiler to load the specified BMI; for the module specified by ``<module-name>`` when necessary. T",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:10794,Integrability,depend,dependent,10794,"le -o Hello.pcm; $ clang++ -std=c++20 use.cpp -fprebuilt-module-path=. Hello.pcm -o Hello.out; $ ./Hello.out; Hello World!. Module name requirement; ~~~~~~~~~~~~~~~~~~~~~~~. [module.unit]p1 says:. .. code-block:: text. All module-names either beginning with an identifier consisting of std followed by zero; or more digits or containing a reserved identifier ([lex.name]) are reserved and shall not; be specified in a module-declaration; no diagnostic is required. If any identifier in a reserved; module-name is a reserved identifier, the module name is reserved for use by C++ implementations;; otherwise it is reserved for future standardization. So all of the following name is not valid by default:. .. code-block:: text. std; std1; std.foo; __test; // and so on ... If you still want to use the reserved module names for any reason, use; ``-Wno-reserved-module-identifier`` to suppress the warning. How to specify the dependent BMIs; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. There are 3 methods to specify the dependent BMIs:. * (1) ``-fprebuilt-module-path=<path/to/directory>``.; * (2) ``-fmodule-file=<path/to/BMI>`` (Deprecated).; * (3) ``-fmodule-file=<module-name>=<path/to/BMI>``. The option ``-fprebuilt-module-path`` tells the compiler the path where to search for dependent BMIs.; It may be used multiple times just like ``-I`` for specifying paths for header files. The look up rule here is:. * (1) When we import module M. The compiler would look up M.pcm in the directories specified; by ``-fprebuilt-module-path``.; * (2) When we import partition module unit M:P. The compiler would look up M-P.pcm in the; directories specified by ``-fprebuilt-module-path``. The option ``-fmodule-file=<path/to/BMI>`` tells the compiler to load the specified BMI directly.; The option ``-fmodule-file=<module-name>=<path/to/BMI>`` tells the compiler to load the specified BMI; for the module specified by ``<module-name>`` when necessary. The main difference is that; ``-fmodule-file=<path/to/BMI>`` w",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:11058,Integrability,depend,dependent,11058,"ther beginning with an identifier consisting of std followed by zero; or more digits or containing a reserved identifier ([lex.name]) are reserved and shall not; be specified in a module-declaration; no diagnostic is required. If any identifier in a reserved; module-name is a reserved identifier, the module name is reserved for use by C++ implementations;; otherwise it is reserved for future standardization. So all of the following name is not valid by default:. .. code-block:: text. std; std1; std.foo; __test; // and so on ... If you still want to use the reserved module names for any reason, use; ``-Wno-reserved-module-identifier`` to suppress the warning. How to specify the dependent BMIs; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. There are 3 methods to specify the dependent BMIs:. * (1) ``-fprebuilt-module-path=<path/to/directory>``.; * (2) ``-fmodule-file=<path/to/BMI>`` (Deprecated).; * (3) ``-fmodule-file=<module-name>=<path/to/BMI>``. The option ``-fprebuilt-module-path`` tells the compiler the path where to search for dependent BMIs.; It may be used multiple times just like ``-I`` for specifying paths for header files. The look up rule here is:. * (1) When we import module M. The compiler would look up M.pcm in the directories specified; by ``-fprebuilt-module-path``.; * (2) When we import partition module unit M:P. The compiler would look up M-P.pcm in the; directories specified by ``-fprebuilt-module-path``. The option ``-fmodule-file=<path/to/BMI>`` tells the compiler to load the specified BMI directly.; The option ``-fmodule-file=<module-name>=<path/to/BMI>`` tells the compiler to load the specified BMI; for the module specified by ``<module-name>`` when necessary. The main difference is that; ``-fmodule-file=<path/to/BMI>`` will load the BMI eagerly, whereas; ``-fmodule-file=<module-name>=<path/to/BMI>`` will only load the BMI lazily, which is similar; with ``-fprebuilt-module-path``. The option ``-fmodule-file=<path/to/BMI>`` for named modules is deprecated;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:12411,Integrability,depend,dependent,12411,"specified by ``-fprebuilt-module-path``. The option ``-fmodule-file=<path/to/BMI>`` tells the compiler to load the specified BMI directly.; The option ``-fmodule-file=<module-name>=<path/to/BMI>`` tells the compiler to load the specified BMI; for the module specified by ``<module-name>`` when necessary. The main difference is that; ``-fmodule-file=<path/to/BMI>`` will load the BMI eagerly, whereas; ``-fmodule-file=<module-name>=<path/to/BMI>`` will only load the BMI lazily, which is similar; with ``-fprebuilt-module-path``. The option ``-fmodule-file=<path/to/BMI>`` for named modules is deprecated; and is planning to be removed in future versions. In case all ``-fprebuilt-module-path=<path/to/directory>``, ``-fmodule-file=<path/to/BMI>`` and; ``-fmodule-file=<module-name>=<path/to/BMI>`` exist, the ``-fmodule-file=<path/to/BMI>`` option; takes highest precedence and ``-fmodule-file=<module-name>=<path/to/BMI>`` will take the second; highest precedence. We need to specify all the dependent (directly and indirectly) BMIs.; See https://github.com/llvm/llvm-project/issues/62707 for detail. When we compile a ``module implementation unit``, we must specify the BMI of the corresponding; ``primary module interface unit``.; Since the language specification says a module implementation unit implicitly imports; the primary module interface unit. [module.unit]p8. A module-declaration that contains neither an export-keyword nor a module-partition implicitly; imports the primary module interface unit of the module as if by a module-import-declaration. All of the 3 options ``-fprebuilt-module-path=<path/to/directory>``, ``-fmodule-file=<path/to/BMI>``; and ``-fmodule-file=<module-name>=<path/to/BMI>`` may occur multiple times.; For example, the command line to compile ``M.cppm`` in; the above example could be rewritten into:. .. code-block:: console. $ clang++ -std=c++20 M.cppm --precompile -fmodule-file=M:interface_part=M-interface_part.pcm -fmodule-file=M:impl_part=M-impl_part.pc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:12633,Integrability,interface,interface,12633,"<module-name>=<path/to/BMI>`` tells the compiler to load the specified BMI; for the module specified by ``<module-name>`` when necessary. The main difference is that; ``-fmodule-file=<path/to/BMI>`` will load the BMI eagerly, whereas; ``-fmodule-file=<module-name>=<path/to/BMI>`` will only load the BMI lazily, which is similar; with ``-fprebuilt-module-path``. The option ``-fmodule-file=<path/to/BMI>`` for named modules is deprecated; and is planning to be removed in future versions. In case all ``-fprebuilt-module-path=<path/to/directory>``, ``-fmodule-file=<path/to/BMI>`` and; ``-fmodule-file=<module-name>=<path/to/BMI>`` exist, the ``-fmodule-file=<path/to/BMI>`` option; takes highest precedence and ``-fmodule-file=<module-name>=<path/to/BMI>`` will take the second; highest precedence. We need to specify all the dependent (directly and indirectly) BMIs.; See https://github.com/llvm/llvm-project/issues/62707 for detail. When we compile a ``module implementation unit``, we must specify the BMI of the corresponding; ``primary module interface unit``.; Since the language specification says a module implementation unit implicitly imports; the primary module interface unit. [module.unit]p8. A module-declaration that contains neither an export-keyword nor a module-partition implicitly; imports the primary module interface unit of the module as if by a module-import-declaration. All of the 3 options ``-fprebuilt-module-path=<path/to/directory>``, ``-fmodule-file=<path/to/BMI>``; and ``-fmodule-file=<module-name>=<path/to/BMI>`` may occur multiple times.; For example, the command line to compile ``M.cppm`` in; the above example could be rewritten into:. .. code-block:: console. $ clang++ -std=c++20 M.cppm --precompile -fmodule-file=M:interface_part=M-interface_part.pcm -fmodule-file=M:impl_part=M-impl_part.pcm -o M.pcm. When there are multiple ``-fmodule-file=<module-name>=`` options for the same; ``<module-name>``, the last ``-fmodule-file=<module-name>=`` will override t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:12758,Integrability,interface,interface,12758,"necessary. The main difference is that; ``-fmodule-file=<path/to/BMI>`` will load the BMI eagerly, whereas; ``-fmodule-file=<module-name>=<path/to/BMI>`` will only load the BMI lazily, which is similar; with ``-fprebuilt-module-path``. The option ``-fmodule-file=<path/to/BMI>`` for named modules is deprecated; and is planning to be removed in future versions. In case all ``-fprebuilt-module-path=<path/to/directory>``, ``-fmodule-file=<path/to/BMI>`` and; ``-fmodule-file=<module-name>=<path/to/BMI>`` exist, the ``-fmodule-file=<path/to/BMI>`` option; takes highest precedence and ``-fmodule-file=<module-name>=<path/to/BMI>`` will take the second; highest precedence. We need to specify all the dependent (directly and indirectly) BMIs.; See https://github.com/llvm/llvm-project/issues/62707 for detail. When we compile a ``module implementation unit``, we must specify the BMI of the corresponding; ``primary module interface unit``.; Since the language specification says a module implementation unit implicitly imports; the primary module interface unit. [module.unit]p8. A module-declaration that contains neither an export-keyword nor a module-partition implicitly; imports the primary module interface unit of the module as if by a module-import-declaration. All of the 3 options ``-fprebuilt-module-path=<path/to/directory>``, ``-fmodule-file=<path/to/BMI>``; and ``-fmodule-file=<module-name>=<path/to/BMI>`` may occur multiple times.; For example, the command line to compile ``M.cppm`` in; the above example could be rewritten into:. .. code-block:: console. $ clang++ -std=c++20 M.cppm --precompile -fmodule-file=M:interface_part=M-interface_part.pcm -fmodule-file=M:impl_part=M-impl_part.pcm -o M.pcm. When there are multiple ``-fmodule-file=<module-name>=`` options for the same; ``<module-name>``, the last ``-fmodule-file=<module-name>=`` will override the previous; ``-fmodule-file=<module-name>=`` options. ``-fprebuilt-module-path`` is more convenient and ``-fmodule-file`` is f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:12914,Integrability,interface,interface,12914,"MI lazily, which is similar; with ``-fprebuilt-module-path``. The option ``-fmodule-file=<path/to/BMI>`` for named modules is deprecated; and is planning to be removed in future versions. In case all ``-fprebuilt-module-path=<path/to/directory>``, ``-fmodule-file=<path/to/BMI>`` and; ``-fmodule-file=<module-name>=<path/to/BMI>`` exist, the ``-fmodule-file=<path/to/BMI>`` option; takes highest precedence and ``-fmodule-file=<module-name>=<path/to/BMI>`` will take the second; highest precedence. We need to specify all the dependent (directly and indirectly) BMIs.; See https://github.com/llvm/llvm-project/issues/62707 for detail. When we compile a ``module implementation unit``, we must specify the BMI of the corresponding; ``primary module interface unit``.; Since the language specification says a module implementation unit implicitly imports; the primary module interface unit. [module.unit]p8. A module-declaration that contains neither an export-keyword nor a module-partition implicitly; imports the primary module interface unit of the module as if by a module-import-declaration. All of the 3 options ``-fprebuilt-module-path=<path/to/directory>``, ``-fmodule-file=<path/to/BMI>``; and ``-fmodule-file=<module-name>=<path/to/BMI>`` may occur multiple times.; For example, the command line to compile ``M.cppm`` in; the above example could be rewritten into:. .. code-block:: console. $ clang++ -std=c++20 M.cppm --precompile -fmodule-file=M:interface_part=M-interface_part.pcm -fmodule-file=M:impl_part=M-impl_part.pcm -o M.pcm. When there are multiple ``-fmodule-file=<module-name>=`` options for the same; ``<module-name>``, the last ``-fmodule-file=<module-name>=`` will override the previous; ``-fmodule-file=<module-name>=`` options. ``-fprebuilt-module-path`` is more convenient and ``-fmodule-file`` is faster since; it saves time for file lookup. Remember that module units still have an object counterpart to the BMI; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:13975,Integrability,interface,interfaces,13975,"by a module-import-declaration. All of the 3 options ``-fprebuilt-module-path=<path/to/directory>``, ``-fmodule-file=<path/to/BMI>``; and ``-fmodule-file=<module-name>=<path/to/BMI>`` may occur multiple times.; For example, the command line to compile ``M.cppm`` in; the above example could be rewritten into:. .. code-block:: console. $ clang++ -std=c++20 M.cppm --precompile -fmodule-file=M:interface_part=M-interface_part.pcm -fmodule-file=M:impl_part=M-impl_part.pcm -o M.pcm. When there are multiple ``-fmodule-file=<module-name>=`` options for the same; ``<module-name>``, the last ``-fmodule-file=<module-name>=`` will override the previous; ``-fmodule-file=<module-name>=`` options. ``-fprebuilt-module-path`` is more convenient and ``-fmodule-file`` is faster since; it saves time for file lookup. Remember that module units still have an object counterpart to the BMI; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. It is easy to forget to compile BMIs at first since we may envision module interfaces like headers.; However, this is not true.; Module units are translation units. We need to compile them to object files; and link the object files like the example shows. For example, the traditional compilation processes for headers are like:. .. code-block:: text. src1.cpp -+> clang++ src1.cpp --> src1.o ---,; hdr1.h --' +-> clang++ src1.o src2.o -> executable; hdr2.h --, |; src2.cpp -+> clang++ src2.cpp --> src2.o ---'. And the compilation process for module units are like:. .. code-block:: text. src1.cpp ----------------------------------------+> clang++ src1.cpp -------> src1.o -,; (header unit) hdr1.h -> clang++ hdr1.h ... -> hdr1.pcm --' +-> clang++ src1.o mod1.o src2.o -> executable; mod1.cppm -> clang++ mod1.cppm ... -> mod1.pcm --,--> clang++ mod1.pcm ... -> mod1.o -+; src2.cpp ----------------------------------------+> clang++ src2.cpp -------> src2.o -'. As the diagrams show, we need to compile the BMI from module units to object files an",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:16854,Integrability,depend,depends,16854,"-o M.pcm; $ clang++ -std=c++23 Use.cpp -fprebuilt-module-path=. The compiler would reject the example due to the inconsistent language options.; Not all options are language options.; For example, the following example is allowed:. .. code-block:: console. $ clang++ -std=c++20 M.cppm --precompile -o M.pcm; # Inconsistent optimization level.; $ clang++ -std=c++20 -O3 Use.cpp -fprebuilt-module-path=.; # Inconsistent debugging level.; $ clang++ -std=c++20 -g Use.cpp -fprebuilt-module-path=. Although the two examples have inconsistent optimization and debugging level, both of them are accepted. Note that **currently** the compiler doesn't consider inconsistent macro definition a problem. For example:. .. code-block:: console. $ clang++ -std=c++20 M.cppm --precompile -o M.pcm; # Inconsistent optimization level.; $ clang++ -std=c++20 -O3 -DNDEBUG Use.cpp -fprebuilt-module-path=. Currently Clang would accept the above example. But it may produce surprising results if the; debugging code depends on consistent use of ``NDEBUG`` also in other translation units. Definitions consistency; ^^^^^^^^^^^^^^^^^^^^^^^. The C++ language defines that same declarations in different translation units should have; the same definition, as known as ODR (One Definition Rule). Prior to modules, the translation; units don't dependent on each other and the compiler itself can't perform a strong; ODR violation check. With the introduction of modules, now the compiler have; the chance to perform ODR violations with language semantics across translation units. However, in the practice, we found the existing ODR checking mechanism is not stable; enough. Many people suffers from the false positive ODR violation diagnostics, AKA,; the compiler are complaining two identical declarations have different definitions; incorrectly. Also the true positive ODR violations are rarely reported.; Also we learned that MSVC don't perform ODR check for declarations in the global module; fragment. So in order to get ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:17176,Integrability,depend,dependent,17176,"el.; $ clang++ -std=c++20 -O3 Use.cpp -fprebuilt-module-path=.; # Inconsistent debugging level.; $ clang++ -std=c++20 -g Use.cpp -fprebuilt-module-path=. Although the two examples have inconsistent optimization and debugging level, both of them are accepted. Note that **currently** the compiler doesn't consider inconsistent macro definition a problem. For example:. .. code-block:: console. $ clang++ -std=c++20 M.cppm --precompile -o M.pcm; # Inconsistent optimization level.; $ clang++ -std=c++20 -O3 -DNDEBUG Use.cpp -fprebuilt-module-path=. Currently Clang would accept the above example. But it may produce surprising results if the; debugging code depends on consistent use of ``NDEBUG`` also in other translation units. Definitions consistency; ^^^^^^^^^^^^^^^^^^^^^^^. The C++ language defines that same declarations in different translation units should have; the same definition, as known as ODR (One Definition Rule). Prior to modules, the translation; units don't dependent on each other and the compiler itself can't perform a strong; ODR violation check. With the introduction of modules, now the compiler have; the chance to perform ODR violations with language semantics across translation units. However, in the practice, we found the existing ODR checking mechanism is not stable; enough. Many people suffers from the false positive ODR violation diagnostics, AKA,; the compiler are complaining two identical declarations have different definitions; incorrectly. Also the true positive ODR violations are rarely reported.; Also we learned that MSVC don't perform ODR check for declarations in the global module; fragment. So in order to get better user experience, save the time checking ODR and keep consistent; behavior with MSVC, we disabled the ODR check for the declarations in the global module; fragment by default. Users who want more strict check can still use the; ``-Xclang -fno-skip-odr-check-in-gmf`` flag to get the ODR check enabled. It is also; encouraged to repor",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:20563,Integrability,wrap,wrapper,20563,"e global module fragments; of different module units, it is not free for clang to deal with the duplicated; declarations. In other word, for a translation unit, it will compile slower if the; translation unit itself and its importing module units contains a lot duplicated; declarations. For example,. .. code-block:: c++. // M-partA.cppm; module;; #include ""big.header.h""; export module M:partA;; ... // M-partB.cppm; module;; #include ""big.header.h""; export module M:partB;; ... // other partitions; ... // M-partZ.cppm; module;; #include ""big.header.h""; export module M:partZ;; ... // M.cppm; export module M;; export import :partA;; export import :partB;; ...; export import :partZ;. // use.cpp; import M;; ... // use declarations from module M. When ``big.header.h`` is big enough and there are a lot of partitions,; the compilation of ``use.cpp`` may be slower than; the following style significantly:. .. code-block:: c++. module;; #include ""big.header.h""; export module m:big.header.wrapper;; export ... // export the needed declarations. // M-partA.cppm; export module M:partA;; import :big.header.wrapper;; ... // M-partB.cppm; export module M:partB;; import :big.header.wrapper;; ... // other partitions; ... // M-partZ.cppm; export module M:partZ;; import :big.header.wrapper;; ... // M.cppm; export module M;; export import :partA;; export import :partB;; ...; export import :partZ;. // use.cpp; import M;; ... // use declarations from module M. The key part of the tip is to reduce the duplications from the text includes. Known Problems; --------------. The following describes issues in the current implementation of modules.; Please see https://github.com/llvm/llvm-project/labels/clang%3Amodules for more issues; or file a new issue if you don't find an existing one.; If you're going to create a new issue for standard C++ modules,; please start the title with ``[C++20] [Modules]`` (or ``[C++23] [Modules]``, etc); and add the label ``clang:modules`` (if you have permissions for ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:20679,Integrability,wrap,wrapper,20679,"arations. In other word, for a translation unit, it will compile slower if the; translation unit itself and its importing module units contains a lot duplicated; declarations. For example,. .. code-block:: c++. // M-partA.cppm; module;; #include ""big.header.h""; export module M:partA;; ... // M-partB.cppm; module;; #include ""big.header.h""; export module M:partB;; ... // other partitions; ... // M-partZ.cppm; module;; #include ""big.header.h""; export module M:partZ;; ... // M.cppm; export module M;; export import :partA;; export import :partB;; ...; export import :partZ;. // use.cpp; import M;; ... // use declarations from module M. When ``big.header.h`` is big enough and there are a lot of partitions,; the compilation of ``use.cpp`` may be slower than; the following style significantly:. .. code-block:: c++. module;; #include ""big.header.h""; export module m:big.header.wrapper;; export ... // export the needed declarations. // M-partA.cppm; export module M:partA;; import :big.header.wrapper;; ... // M-partB.cppm; export module M:partB;; import :big.header.wrapper;; ... // other partitions; ... // M-partZ.cppm; export module M:partZ;; import :big.header.wrapper;; ... // M.cppm; export module M;; export import :partA;; export import :partB;; ...; export import :partZ;. // use.cpp; import M;; ... // use declarations from module M. The key part of the tip is to reduce the duplications from the text includes. Known Problems; --------------. The following describes issues in the current implementation of modules.; Please see https://github.com/llvm/llvm-project/labels/clang%3Amodules for more issues; or file a new issue if you don't find an existing one.; If you're going to create a new issue for standard C++ modules,; please start the title with ``[C++20] [Modules]`` (or ``[C++23] [Modules]``, etc); and add the label ``clang:modules`` (if you have permissions for that). For higher level support for proposals, you could visit https://clang.llvm.org/cxx_status.html. Including ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:20753,Integrability,wrap,wrapper,20753," the; translation unit itself and its importing module units contains a lot duplicated; declarations. For example,. .. code-block:: c++. // M-partA.cppm; module;; #include ""big.header.h""; export module M:partA;; ... // M-partB.cppm; module;; #include ""big.header.h""; export module M:partB;; ... // other partitions; ... // M-partZ.cppm; module;; #include ""big.header.h""; export module M:partZ;; ... // M.cppm; export module M;; export import :partA;; export import :partB;; ...; export import :partZ;. // use.cpp; import M;; ... // use declarations from module M. When ``big.header.h`` is big enough and there are a lot of partitions,; the compilation of ``use.cpp`` may be slower than; the following style significantly:. .. code-block:: c++. module;; #include ""big.header.h""; export module m:big.header.wrapper;; export ... // export the needed declarations. // M-partA.cppm; export module M:partA;; import :big.header.wrapper;; ... // M-partB.cppm; export module M:partB;; import :big.header.wrapper;; ... // other partitions; ... // M-partZ.cppm; export module M:partZ;; import :big.header.wrapper;; ... // M.cppm; export module M;; export import :partA;; export import :partB;; ...; export import :partZ;. // use.cpp; import M;; ... // use declarations from module M. The key part of the tip is to reduce the duplications from the text includes. Known Problems; --------------. The following describes issues in the current implementation of modules.; Please see https://github.com/llvm/llvm-project/labels/clang%3Amodules for more issues; or file a new issue if you don't find an existing one.; If you're going to create a new issue for standard C++ modules,; please start the title with ``[C++20] [Modules]`` (or ``[C++23] [Modules]``, etc); and add the label ``clang:modules`` (if you have permissions for that). For higher level support for proposals, you could visit https://clang.llvm.org/cxx_status.html. Including headers after import is problematic; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:20852,Integrability,wrap,wrapper,20852,"s. For example,. .. code-block:: c++. // M-partA.cppm; module;; #include ""big.header.h""; export module M:partA;; ... // M-partB.cppm; module;; #include ""big.header.h""; export module M:partB;; ... // other partitions; ... // M-partZ.cppm; module;; #include ""big.header.h""; export module M:partZ;; ... // M.cppm; export module M;; export import :partA;; export import :partB;; ...; export import :partZ;. // use.cpp; import M;; ... // use declarations from module M. When ``big.header.h`` is big enough and there are a lot of partitions,; the compilation of ``use.cpp`` may be slower than; the following style significantly:. .. code-block:: c++. module;; #include ""big.header.h""; export module m:big.header.wrapper;; export ... // export the needed declarations. // M-partA.cppm; export module M:partA;; import :big.header.wrapper;; ... // M-partB.cppm; export module M:partB;; import :big.header.wrapper;; ... // other partitions; ... // M-partZ.cppm; export module M:partZ;; import :big.header.wrapper;; ... // M.cppm; export module M;; export import :partA;; export import :partB;; ...; export import :partZ;. // use.cpp; import M;; ... // use declarations from module M. The key part of the tip is to reduce the duplications from the text includes. Known Problems; --------------. The following describes issues in the current implementation of modules.; Please see https://github.com/llvm/llvm-project/labels/clang%3Amodules for more issues; or file a new issue if you don't find an existing one.; If you're going to create a new issue for standard C++ modules,; please start the title with ``[C++20] [Modules]`` (or ``[C++23] [Modules]``, etc); and add the label ``clang:modules`` (if you have permissions for that). For higher level support for proposals, you could visit https://clang.llvm.org/cxx_status.html. Including headers after import is problematic; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. For example, the following example can be accept:. .. code-block:: c++. #include <iostrea",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:23856,Integrability,depend,depending,23856,"standable that why; the orders matter here in the case.; (Note that ""understandable"" is different from ""makes sense""). This is tracked in: https://github.com/llvm/llvm-project/issues/61465. Ignored PreferredName Attribute; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Due to a tricky problem, when Clang writes BMIs, Clang will ignore the ``preferred_name`` attribute, if any.; This implies that the ``preferred_name`` wouldn't show in debugger or dumping. This is tracked in: https://github.com/llvm/llvm-project/issues/56490. Don't emit macros about module declaration; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This is covered by P1857R3. We mention it again here since users may abuse it before we implement it. Someone may want to write code which could be compiled both by modules or non-modules.; A direct idea would be use macros like:. .. code-block:: c++. MODULE; IMPORT header_name; EXPORT_MODULE MODULE_NAME;; IMPORT header_name; EXPORT ... So this file could be triggered like a module unit or a non-module unit depending on the definition; of some macros.; However, this kind of usage is forbidden by P1857R3 but we haven't implemented P1857R3 yet.; This means that is possible to write illegal modules code now, and obviously this will stop working; once P1857R3 is implemented.; A simple suggestion would be ""Don't play macro tricks with module declarations"". This is tracked in: https://github.com/llvm/llvm-project/issues/56917. In consistent filename suffix requirement for importable module units; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Currently, clang requires the file name of an ``importable module unit`` should end with ``.cppm``; (or ``.ccm``, ``.cxxm``, ``.c++m``). However, the behavior is inconsistent with other compilers. This is tracked in: https://github.com/llvm/llvm-project/issues/57416. clang-cl is not compatible with the standard C++ modules; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Now we can't use the `/clang:-fmodule-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:26833,Integrability,message,messages,26833," module units. This is incorrect. Since both definitions of `fun()` has the same; spelling and `T` refers to the same type entity finally. So the program should be; fine. This is tracked in https://github.com/llvm/llvm-project/issues/78850. Using TU-local entity in other units; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Module units are translation units. So the entities which should only be local to the; module unit itself shouldn't be used by other units in any means. In the language side, to address the idea formally, the language specification defines; the concept of ``TU-local`` and ``exposure`` in; `basic.link/p14 <https://eel.is/c++draft/basic.link#14>`_,; `basic.link/p15 <https://eel.is/c++draft/basic.link#15>`_,; `basic.link/p16 <https://eel.is/c++draft/basic.link#16>`_,; `basic.link/p17 <https://eel.is/c++draft/basic.link#17>`_ and; `basic.link/p18 <https://eel.is/c++draft/basic.link#18>`_. However, the compiler doesn't support these 2 ideas formally.; This results in unclear and confusing diagnostic messages.; And it is worse that the compiler may import TU-local entities to other units without any; diagnostics. This is tracked in https://github.com/llvm/llvm-project/issues/78173. Header Units; ============. How to build projects using header unit; ---------------------------------------. .. warning::. The user interfaces of header units is highly experimental. There are still; many unanswered question about how tools should interact with header units.; The user interfaces described here may change after we have progress on how; tools should support for header units. Quick Start; ~~~~~~~~~~~. For the following example,. .. code-block:: c++. import <iostream>;; int main() {; std::cout << ""Hello World.\n"";; }. we could compile it as. .. code-block:: console. $ clang++ -std=c++20 -xc++-system-header --precompile iostream -o iostream.pcm; $ clang++ -std=c++20 -fmodule-file=iostream.pcm main.cpp. How to produce BMIs; ~~~~~~~~~~~~~~~~~~~. Similar to named modules, w",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:27151,Integrability,interface,interfaces,27151," entities which should only be local to the; module unit itself shouldn't be used by other units in any means. In the language side, to address the idea formally, the language specification defines; the concept of ``TU-local`` and ``exposure`` in; `basic.link/p14 <https://eel.is/c++draft/basic.link#14>`_,; `basic.link/p15 <https://eel.is/c++draft/basic.link#15>`_,; `basic.link/p16 <https://eel.is/c++draft/basic.link#16>`_,; `basic.link/p17 <https://eel.is/c++draft/basic.link#17>`_ and; `basic.link/p18 <https://eel.is/c++draft/basic.link#18>`_. However, the compiler doesn't support these 2 ideas formally.; This results in unclear and confusing diagnostic messages.; And it is worse that the compiler may import TU-local entities to other units without any; diagnostics. This is tracked in https://github.com/llvm/llvm-project/issues/78173. Header Units; ============. How to build projects using header unit; ---------------------------------------. .. warning::. The user interfaces of header units is highly experimental. There are still; many unanswered question about how tools should interact with header units.; The user interfaces described here may change after we have progress on how; tools should support for header units. Quick Start; ~~~~~~~~~~~. For the following example,. .. code-block:: c++. import <iostream>;; int main() {; std::cout << ""Hello World.\n"";; }. we could compile it as. .. code-block:: console. $ clang++ -std=c++20 -xc++-system-header --precompile iostream -o iostream.pcm; $ clang++ -std=c++20 -fmodule-file=iostream.pcm main.cpp. How to produce BMIs; ~~~~~~~~~~~~~~~~~~~. Similar to named modules, we could use ``--precompile`` to produce the BMI.; But we need to specify that the input file is a header by ``-xc++-system-header`` or ``-xc++-user-header``. Also we could use `-fmodule-header={user,system}` option to produce the BMI for header units; which has suffix like `.h` or `.hh`.; The value of `-fmodule-header` means the user search path or the syst",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:27305,Integrability,interface,interfaces,27305,"fication defines; the concept of ``TU-local`` and ``exposure`` in; `basic.link/p14 <https://eel.is/c++draft/basic.link#14>`_,; `basic.link/p15 <https://eel.is/c++draft/basic.link#15>`_,; `basic.link/p16 <https://eel.is/c++draft/basic.link#16>`_,; `basic.link/p17 <https://eel.is/c++draft/basic.link#17>`_ and; `basic.link/p18 <https://eel.is/c++draft/basic.link#18>`_. However, the compiler doesn't support these 2 ideas formally.; This results in unclear and confusing diagnostic messages.; And it is worse that the compiler may import TU-local entities to other units without any; diagnostics. This is tracked in https://github.com/llvm/llvm-project/issues/78173. Header Units; ============. How to build projects using header unit; ---------------------------------------. .. warning::. The user interfaces of header units is highly experimental. There are still; many unanswered question about how tools should interact with header units.; The user interfaces described here may change after we have progress on how; tools should support for header units. Quick Start; ~~~~~~~~~~~. For the following example,. .. code-block:: c++. import <iostream>;; int main() {; std::cout << ""Hello World.\n"";; }. we could compile it as. .. code-block:: console. $ clang++ -std=c++20 -xc++-system-header --precompile iostream -o iostream.pcm; $ clang++ -std=c++20 -fmodule-file=iostream.pcm main.cpp. How to produce BMIs; ~~~~~~~~~~~~~~~~~~~. Similar to named modules, we could use ``--precompile`` to produce the BMI.; But we need to specify that the input file is a header by ``-xc++-system-header`` or ``-xc++-user-header``. Also we could use `-fmodule-header={user,system}` option to produce the BMI for header units; which has suffix like `.h` or `.hh`.; The value of `-fmodule-header` means the user search path or the system search path.; The default value for `-fmodule-header` is `user`.; For example,. .. code-block:: c++. // foo.h; #include <iostream>; void Hello() {; std::cout << ""Hello World.\n"";;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:28997,Integrability,depend,dependent,28997,"ystem}` option to produce the BMI for header units; which has suffix like `.h` or `.hh`.; The value of `-fmodule-header` means the user search path or the system search path.; The default value for `-fmodule-header` is `user`.; For example,. .. code-block:: c++. // foo.h; #include <iostream>; void Hello() {; std::cout << ""Hello World.\n"";; }. // use.cpp; import ""foo.h"";; int main() {; Hello();; }. We could compile it as:. .. code-block:: console. $ clang++ -std=c++20 -fmodule-header foo.h -o foo.pcm; $ clang++ -std=c++20 -fmodule-file=foo.pcm use.cpp. For headers which don't have a suffix, we need to pass ``-xc++-header``; (or ``-xc++-system-header`` or ``-xc++-user-header``) to mark it as a header.; For example,. .. code-block:: c++. // use.cpp; import ""foo.h"";; int main() {; Hello();; }. .. code-block:: console. $ clang++ -std=c++20 -fmodule-header=system -xc++-header iostream -o iostream.pcm; $ clang++ -std=c++20 -fmodule-file=iostream.pcm use.cpp. How to specify the dependent BMIs; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. We could use ``-fmodule-file`` to specify the BMIs, and this option may occur multiple times as well. With the existing implementation ``-fprebuilt-module-path`` cannot be used for header units; (since they are nominally anonymous).; For header units, use ``-fmodule-file`` to include the relevant PCM file for each header unit. This is expect to be solved in future editions of the compiler either by the tooling finding and specifying; the -fmodule-file or by the use of a module-mapper that understands how to map the header name to their PCMs. Don't compile the BMI; ~~~~~~~~~~~~~~~~~~~~~. Another difference with modules is that we can't compile the BMI from a header unit.; For example:. .. code-block:: console. $ clang++ -std=c++20 -xc++-system-header --precompile iostream -o iostream.pcm; # This is not allowed!; $ clang++ iostream.pcm -c -o iostream.o. It makes sense due to the semantics of header units, which are just like headers. Include translatio",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:31865,Integrability,wrap,wrapping,31865,"e the ``#include <iostream>`` to ``import <iostream>;`` automatically. Relationships between Clang modules; -----------------------------------. Header units have pretty similar semantics with Clang modules.; The semantics of both of them are like headers. In fact, we could even ""mimic"" the sytle of header units by Clang modules:. .. code-block:: c++. module ""iostream"" {; export *; header ""/path/to/libstdcxx/iostream""; }. .. code-block:: console. $ clang++ -std=c++20 -fimplicit-modules -fmodule-map-file=.modulemap main.cpp. It would be simpler if we are using libcxx:. .. code-block:: console. $ clang++ -std=c++20 main.cpp -fimplicit-modules -fimplicit-module-maps. Since there is already one; `module map <https://github.com/llvm/llvm-project/blob/main/libcxx/include/module.modulemap.in>`_; in the source of libcxx. Then immediately leads to the question: why don't we implement header units through Clang header modules?. The main reason for this is that Clang modules have more semantics like hierarchy or; wrapping multiple headers together as a big module.; However, these things are not part of Standard C++ Header units,; and we want to avoid the impression that these additional semantics get interpreted as Standard C++ behavior. Another reason is that there are proposals to introduce module mappers to the C++ standard; (for example, https://wg21.link/p1184r2).; If we decide to reuse Clang's modulemap, we may get in trouble once we need to introduce another module mapper. So the final answer for why we don't reuse the interface of Clang modules for header units is that; there are some differences between header units and Clang modules and that ignoring those; differences now would likely become a problem in the future. Discover Dependencies; =====================. Prior to modules, all the translation units can be compiled parallelly.; But it is not true for the module units. The presence of module units requires; us to compile the translation units in a (topological) ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:32388,Integrability,interface,interface,32388,"0 main.cpp -fimplicit-modules -fimplicit-module-maps. Since there is already one; `module map <https://github.com/llvm/llvm-project/blob/main/libcxx/include/module.modulemap.in>`_; in the source of libcxx. Then immediately leads to the question: why don't we implement header units through Clang header modules?. The main reason for this is that Clang modules have more semantics like hierarchy or; wrapping multiple headers together as a big module.; However, these things are not part of Standard C++ Header units,; and we want to avoid the impression that these additional semantics get interpreted as Standard C++ behavior. Another reason is that there are proposals to introduce module mappers to the C++ standard; (for example, https://wg21.link/p1184r2).; If we decide to reuse Clang's modulemap, we may get in trouble once we need to introduce another module mapper. So the final answer for why we don't reuse the interface of Clang modules for header units is that; there are some differences between header units and Clang modules and that ignoring those; differences now would likely become a problem in the future. Discover Dependencies; =====================. Prior to modules, all the translation units can be compiled parallelly.; But it is not true for the module units. The presence of module units requires; us to compile the translation units in a (topological) order. The clang-scan-deps scanner implemented; `P1689 paper <https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1689r5.html>`_; to describe the order. Only named modules are supported now. We need a compilation database to use clang-scan-deps. See; `JSON Compilation Database Format Specification <JSONCompilationDatabase.html>`_; for example. Note that the ``output`` entry is necessary for clang-scan-deps; to scan P1689 format. Here is an example:. .. code-block:: c++. //--- M.cppm; export module M;; export import :interface_part;; import :impl_part;; export int Hello();. //--- interface_part.cppm; export",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:34815,Integrability,depend,dependency,34815,"port M;; import third_party_module;; int main() {; Hello();; World();; return 0;; }. And here is the compilation database:. .. code-block:: text. [; {; ""directory"": ""."",; ""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 M.cppm -c -o M.o"",; ""file"": ""M.cppm"",; ""output"": ""M.o""; },; {; ""directory"": ""."",; ""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 Impl.cpp -c -o Impl.o"",; ""file"": ""Impl.cpp"",; ""output"": ""Impl.o""; },; {; ""directory"": ""."",; ""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o"",; ""file"": ""impl_part.cppm"",; ""output"": ""impl_part.o""; },; {; ""directory"": ""."",; ""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 interface_part.cppm -c -o interface_part.o"",; ""file"": ""interface_part.cppm"",; ""output"": ""interface_part.o""; },; {; ""directory"": ""."",; ""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 User.cpp -c -o User.o"",; ""file"": ""User.cpp"",; ""output"": ""User.o""; }; ]. And we can get the dependency information in P1689 format by:. .. code-block:: console. $ clang-scan-deps -format=p1689 -compilation-database P1689.json. And we will get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""Impl.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ]; },; {; ""primary-output"": ""M.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; },; {; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ]; },; {; ""primary-output"": ""User.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; },; {; ""logical-name"": ""third_party_module""; }; ]; },; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:35179,Integrability,interface,interface,35179,"c++20 Impl.cpp -c -o Impl.o"",; ""file"": ""Impl.cpp"",; ""output"": ""Impl.o""; },; {; ""directory"": ""."",; ""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o"",; ""file"": ""impl_part.cppm"",; ""output"": ""impl_part.o""; },; {; ""directory"": ""."",; ""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 interface_part.cppm -c -o interface_part.o"",; ""file"": ""interface_part.cppm"",; ""output"": ""interface_part.o""; },; {; ""directory"": ""."",; ""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 User.cpp -c -o User.o"",; ""file"": ""User.cpp"",; ""output"": ""User.o""; }; ]. And we can get the dependency information in P1689 format by:. .. code-block:: console. $ clang-scan-deps -format=p1689 -compilation-database P1689.json. And we will get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""Impl.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ]; },; {; ""primary-output"": ""M.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; },; {; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ]; },; {; ""primary-output"": ""User.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; },; {; ""logical-name"": ""third_party_module""; }; ]; },; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; },; {; ""primary-output"": ""interface_part.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; }; ],; ""version"": 1; }. See the P1689 paper for the meaning of the fields. And if the user want a finer-grained control for any reason, e.g., to scan the generated source files,; the user can choose",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:35638,Integrability,interface,interface,35638,"""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 User.cpp -c -o User.o"",; ""file"": ""User.cpp"",; ""output"": ""User.o""; }; ]. And we can get the dependency information in P1689 format by:. .. code-block:: console. $ clang-scan-deps -format=p1689 -compilation-database P1689.json. And we will get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""Impl.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ]; },; {; ""primary-output"": ""M.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; },; {; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ]; },; {; ""primary-output"": ""User.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; },; {; ""logical-name"": ""third_party_module""; }; ]; },; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; },; {; ""primary-output"": ""interface_part.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; }; ],; ""version"": 1; }. See the P1689 paper for the meaning of the fields. And if the user want a finer-grained control for any reason, e.g., to scan the generated source files,; the user can choose to get the dependency information per file. For example:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o. And we'll get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:35897,Integrability,interface,interface,35897,"n-database P1689.json. And we will get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""Impl.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ]; },; {; ""primary-output"": ""M.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; },; {; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ]; },; {; ""primary-output"": ""User.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; },; {; ""logical-name"": ""third_party_module""; }; ]; },; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; },; {; ""primary-output"": ""interface_part.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; }; ],; ""version"": 1; }. See the P1689 paper for the meaning of the fields. And if the user want a finer-grained control for any reason, e.g., to scan the generated source files,; the user can choose to get the dependency information per file. For example:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o. And we'll get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part""; }; ]; }; ],; ""version"": 1; }. In this way, we can pass the single command line options after the ``--``.; Then clang-scan-deps will extract the necessary information from the options.; Note that we need to specify the path to the compiler executable instea",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:36207,Integrability,depend,dependency,36207,""": true,; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; },; {; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ]; },; {; ""primary-output"": ""User.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; },; {; ""logical-name"": ""third_party_module""; }; ]; },; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; },; {; ""primary-output"": ""interface_part.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; }; ],; ""version"": 1; }. See the P1689 paper for the meaning of the fields. And if the user want a finer-grained control for any reason, e.g., to scan the generated source files,; the user can choose to get the dependency information per file. For example:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o. And we'll get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part""; }; ]; }; ],; ""version"": 1; }. In this way, we can pass the single command line options after the ``--``.; Then clang-scan-deps will extract the necessary information from the options.; Note that we need to specify the path to the compiler executable instead of saying; ``clang++`` simply. The users may want the scanner to get the transitional dependency information for headers.; Otherwise, the users have to scan twice for the project, once for headers and once for modules.; To address the requirement, clang-scan-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:36525,Integrability,interface,interface,36525,"ird_party_module""; }; ]; },; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; },; {; ""primary-output"": ""interface_part.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; }; ],; ""version"": 1; }. See the P1689 paper for the meaning of the fields. And if the user want a finer-grained control for any reason, e.g., to scan the generated source files,; the user can choose to get the dependency information per file. For example:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o. And we'll get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part""; }; ]; }; ],; ""version"": 1; }. In this way, we can pass the single command line options after the ``--``.; Then clang-scan-deps will extract the necessary information from the options.; Note that we need to specify the path to the compiler executable instead of saying; ``clang++`` simply. The users may want the scanner to get the transitional dependency information for headers.; Otherwise, the users have to scan twice for the project, once for headers and once for modules.; To address the requirement, clang-scan-deps will recognize the specified preprocessor options; in the given command line and generate the corresponding dependency information. For example,. .. code-block:: console. $ clang-scan-deps -format=p1689 -- ../bin/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o -MD -MT impl_part.ddi -MF impl_part.dep; $ cat impl_part.dep. We will get:. .. code-block:: t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:37015,Integrability,depend,dependency,37015,"""version"": 1; }. See the P1689 paper for the meaning of the fields. And if the user want a finer-grained control for any reason, e.g., to scan the generated source files,; the user can choose to get the dependency information per file. For example:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o. And we'll get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part""; }; ]; }; ],; ""version"": 1; }. In this way, we can pass the single command line options after the ``--``.; Then clang-scan-deps will extract the necessary information from the options.; Note that we need to specify the path to the compiler executable instead of saying; ``clang++`` simply. The users may want the scanner to get the transitional dependency information for headers.; Otherwise, the users have to scan twice for the project, once for headers and once for modules.; To address the requirement, clang-scan-deps will recognize the specified preprocessor options; in the given command line and generate the corresponding dependency information. For example,. .. code-block:: console. $ clang-scan-deps -format=p1689 -- ../bin/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o -MD -MT impl_part.ddi -MF impl_part.dep; $ cat impl_part.dep. We will get:. .. code-block:: text. impl_part.ddi: \; /usr/include/bits/wchar.h /usr/include/bits/types/wint_t.h \; /usr/include/bits/types/mbstate_t.h \; /usr/include/bits/types/__mbstate_t.h /usr/include/bits/types/__FILE.h \; /usr/include/bits/types/FILE.h /usr/include/bits/types/locale_t.h \; /usr/include/bits/types/__locale_t.h \; ... When clang-scan-deps detects ``-MF`` option, clang-scan-deps will try to write the; dependency information for headers to the file specified by",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:37301,Integrability,depend,dependency,37301,"ile. For example:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o. And we'll get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part""; }; ]; }; ],; ""version"": 1; }. In this way, we can pass the single command line options after the ``--``.; Then clang-scan-deps will extract the necessary information from the options.; Note that we need to specify the path to the compiler executable instead of saying; ``clang++`` simply. The users may want the scanner to get the transitional dependency information for headers.; Otherwise, the users have to scan twice for the project, once for headers and once for modules.; To address the requirement, clang-scan-deps will recognize the specified preprocessor options; in the given command line and generate the corresponding dependency information. For example,. .. code-block:: console. $ clang-scan-deps -format=p1689 -- ../bin/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o -MD -MT impl_part.ddi -MF impl_part.dep; $ cat impl_part.dep. We will get:. .. code-block:: text. impl_part.ddi: \; /usr/include/bits/wchar.h /usr/include/bits/types/wint_t.h \; /usr/include/bits/types/mbstate_t.h \; /usr/include/bits/types/__mbstate_t.h /usr/include/bits/types/__FILE.h \; /usr/include/bits/types/FILE.h /usr/include/bits/types/locale_t.h \; /usr/include/bits/types/__locale_t.h \; ... When clang-scan-deps detects ``-MF`` option, clang-scan-deps will try to write the; dependency information for headers to the file specified by ``-MF``. Possible Issues: Failed to find system headers; ----------------------------------------------. In case the users encounter errors like ``fatal error: 'stddef.h' file not found``,; probably the specified ``<path-to-compil",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:37946,Integrability,depend,dependency,37946,"g; ``clang++`` simply. The users may want the scanner to get the transitional dependency information for headers.; Otherwise, the users have to scan twice for the project, once for headers and once for modules.; To address the requirement, clang-scan-deps will recognize the specified preprocessor options; in the given command line and generate the corresponding dependency information. For example,. .. code-block:: console. $ clang-scan-deps -format=p1689 -- ../bin/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o -MD -MT impl_part.ddi -MF impl_part.dep; $ cat impl_part.dep. We will get:. .. code-block:: text. impl_part.ddi: \; /usr/include/bits/wchar.h /usr/include/bits/types/wint_t.h \; /usr/include/bits/types/mbstate_t.h \; /usr/include/bits/types/__mbstate_t.h /usr/include/bits/types/__FILE.h \; /usr/include/bits/types/FILE.h /usr/include/bits/types/locale_t.h \; /usr/include/bits/types/__locale_t.h \; ... When clang-scan-deps detects ``-MF`` option, clang-scan-deps will try to write the; dependency information for headers to the file specified by ``-MF``. Possible Issues: Failed to find system headers; ----------------------------------------------. In case the users encounter errors like ``fatal error: 'stddef.h' file not found``,; probably the specified ``<path-to-compiler-executable>/clang++`` refers to a symlink; instead a real binary. There are 4 potential solutions to the problem:. * (1) End users can resolve the issue by pointing the specified compiler executable to; the real binary instead of the symlink.; * (2) End users can invoke ``<path-to-compiler-executable>/clang++ -print-resource-dir``; to get the corresponding resource directory for your compiler and add that directory; to the include search paths manually in the build scripts.; * (3) Build systems that use a compilation database as the input for clang-scan-deps; scanner, the build system can add the flag ``--resource-dir-recipe invoke-compiler`` to; the clang-scan-deps scanner to calculate the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:39893,Integrability,interface,interfaces,39893,"scanner, the build system can add the flag ``--resource-dir-recipe invoke-compiler`` to; the clang-scan-deps scanner to calculate the resources directory dynamically.; The calculation happens only once for a unique ``<path-to-compiler-executable>/clang++``.; * (4) For build systems that invokes the clang-scan-deps scanner per file, repeatedly; calculating the resource directory may be inefficient. In such cases, the build; system can cache the resource directory by itself and pass ``-resource-dir <resource-dir>``; explicitly in the command line options:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 -resource-dir <resource-dir> mod.cppm -c -o mod.o. Possible Questions; ==================. How modules speed up compilation; --------------------------------. A classic theory for the reason why modules speed up the compilation is:; if there are ``n`` headers and ``m`` source files and each header is included by each source file,; then the complexity of the compilation is ``O(n*m)``;; But if there are ``n`` module interfaces and ``m`` source files, the complexity of the compilation is; ``O(n+m)``. So, using modules would be a big win when scaling.; In a simpler word, we could get rid of many redundant compilations by using modules. Roughly, this theory is correct. But the problem is that it is too rough.; The behavior depends on the optimization level, as we will illustrate below. First is ``O0``. The compilation process is described in the following graph. .. code-block:: none. ├-------------frontend----------┼-------------middle end----------------┼----backend----┤; │ │ │ │; └---parsing----sema----codegen--┴----- transformations ---- codegen ----┴---- codegen --┘. ┌---------------------------------------------------------------------------------------┐; | │; | source file │; | │; └---------------------------------------------------------------------------------------┘. ┌--------┐; │ │; │imported│; │ │; │ co",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:40203,Integrability,depend,depends,40203,"ild; system can cache the resource directory by itself and pass ``-resource-dir <resource-dir>``; explicitly in the command line options:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 -resource-dir <resource-dir> mod.cppm -c -o mod.o. Possible Questions; ==================. How modules speed up compilation; --------------------------------. A classic theory for the reason why modules speed up the compilation is:; if there are ``n`` headers and ``m`` source files and each header is included by each source file,; then the complexity of the compilation is ``O(n*m)``;; But if there are ``n`` module interfaces and ``m`` source files, the complexity of the compilation is; ``O(n+m)``. So, using modules would be a big win when scaling.; In a simpler word, we could get rid of many redundant compilations by using modules. Roughly, this theory is correct. But the problem is that it is too rough.; The behavior depends on the optimization level, as we will illustrate below. First is ``O0``. The compilation process is described in the following graph. .. code-block:: none. ├-------------frontend----------┼-------------middle end----------------┼----backend----┤; │ │ │ │; └---parsing----sema----codegen--┴----- transformations ---- codegen ----┴---- codegen --┘. ┌---------------------------------------------------------------------------------------┐; | │; | source file │; | │; └---------------------------------------------------------------------------------------┘. ┌--------┐; │ │; │imported│; │ │; │ code │; │ │; └--------┘. Here we can see that the source file (could be a non-module unit or a module unit) would get processed by the; whole pipeline.; But the imported code would only get involved in semantic analysis, which is mainly about name lookup,; overload resolution and template instantiation.; All of these processes are fast relative to the whole compilation process.; More importantly, the imported code only n",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:43675,Integrability,interoperab,interoperability,43675,"izations---┴--- optimizations -┘. ┌-----------------------------------------------------------------------------------------------┐; │ │; │ source file │; │ │; └-----------------------------------------------------------------------------------------------┘; ┌---------------------------------------┐; │ │; │ │; │ imported code │; │ │; │ │; └---------------------------------------┘. It would be very unfortunate if we end up with worse performance after using modules.; The main concern is that when we compile a source file, the compiler needs to see the function body; of imported module units so that it can perform IPO (InterProcedural Optimization, primarily inlining; in practice) to optimize functions in current source file with the help of the information provided by; the imported module units.; In other words, the imported code would be processed again and again in importee units; by optimizations (including IPO itself).; The optimizations before IPO and the IPO itself are the most time-consuming part in whole compilation process.; So from this perspective, we might not be able to get the improvements described in the theory.; But we could still save the time for optimizations after IPO and the whole backend. Overall, at ``O0`` the implementations of functions defined in a module will not impact module users,; but at higher optimization levels the definitions of such functions are provided to user compilations for the; purposes of optimization (but definitions of these functions are still not included in the use's object file)-; this means the build speedup at higher optimization levels may be lower than expected given ``O0`` experience,; but does provide by more optimization opportunities. Interoperability with Clang Modules; -----------------------------------. We **wish** to support clang modules and standard c++ modules at the same time,; but the mixed using form is not well used/tested yet. Please file new github issues as you find interoperability problems.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:11523,Performance,load,load,11523,"ext. std; std1; std.foo; __test; // and so on ... If you still want to use the reserved module names for any reason, use; ``-Wno-reserved-module-identifier`` to suppress the warning. How to specify the dependent BMIs; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. There are 3 methods to specify the dependent BMIs:. * (1) ``-fprebuilt-module-path=<path/to/directory>``.; * (2) ``-fmodule-file=<path/to/BMI>`` (Deprecated).; * (3) ``-fmodule-file=<module-name>=<path/to/BMI>``. The option ``-fprebuilt-module-path`` tells the compiler the path where to search for dependent BMIs.; It may be used multiple times just like ``-I`` for specifying paths for header files. The look up rule here is:. * (1) When we import module M. The compiler would look up M.pcm in the directories specified; by ``-fprebuilt-module-path``.; * (2) When we import partition module unit M:P. The compiler would look up M-P.pcm in the; directories specified by ``-fprebuilt-module-path``. The option ``-fmodule-file=<path/to/BMI>`` tells the compiler to load the specified BMI directly.; The option ``-fmodule-file=<module-name>=<path/to/BMI>`` tells the compiler to load the specified BMI; for the module specified by ``<module-name>`` when necessary. The main difference is that; ``-fmodule-file=<path/to/BMI>`` will load the BMI eagerly, whereas; ``-fmodule-file=<module-name>=<path/to/BMI>`` will only load the BMI lazily, which is similar; with ``-fprebuilt-module-path``. The option ``-fmodule-file=<path/to/BMI>`` for named modules is deprecated; and is planning to be removed in future versions. In case all ``-fprebuilt-module-path=<path/to/directory>``, ``-fmodule-file=<path/to/BMI>`` and; ``-fmodule-file=<module-name>=<path/to/BMI>`` exist, the ``-fmodule-file=<path/to/BMI>`` option; takes highest precedence and ``-fmodule-file=<module-name>=<path/to/BMI>`` will take the second; highest precedence. We need to specify all the dependent (directly and indirectly) BMIs.; See https://github.com/llvm/llvm-project/issues/6270",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:11636,Performance,load,load,11636,"erved-module-identifier`` to suppress the warning. How to specify the dependent BMIs; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. There are 3 methods to specify the dependent BMIs:. * (1) ``-fprebuilt-module-path=<path/to/directory>``.; * (2) ``-fmodule-file=<path/to/BMI>`` (Deprecated).; * (3) ``-fmodule-file=<module-name>=<path/to/BMI>``. The option ``-fprebuilt-module-path`` tells the compiler the path where to search for dependent BMIs.; It may be used multiple times just like ``-I`` for specifying paths for header files. The look up rule here is:. * (1) When we import module M. The compiler would look up M.pcm in the directories specified; by ``-fprebuilt-module-path``.; * (2) When we import partition module unit M:P. The compiler would look up M-P.pcm in the; directories specified by ``-fprebuilt-module-path``. The option ``-fmodule-file=<path/to/BMI>`` tells the compiler to load the specified BMI directly.; The option ``-fmodule-file=<module-name>=<path/to/BMI>`` tells the compiler to load the specified BMI; for the module specified by ``<module-name>`` when necessary. The main difference is that; ``-fmodule-file=<path/to/BMI>`` will load the BMI eagerly, whereas; ``-fmodule-file=<module-name>=<path/to/BMI>`` will only load the BMI lazily, which is similar; with ``-fprebuilt-module-path``. The option ``-fmodule-file=<path/to/BMI>`` for named modules is deprecated; and is planning to be removed in future versions. In case all ``-fprebuilt-module-path=<path/to/directory>``, ``-fmodule-file=<path/to/BMI>`` and; ``-fmodule-file=<module-name>=<path/to/BMI>`` exist, the ``-fmodule-file=<path/to/BMI>`` option; takes highest precedence and ``-fmodule-file=<module-name>=<path/to/BMI>`` will take the second; highest precedence. We need to specify all the dependent (directly and indirectly) BMIs.; See https://github.com/llvm/llvm-project/issues/62707 for detail. When we compile a ``module implementation unit``, we must specify the BMI of the corresponding; ``primary module inter",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:11788,Performance,load,load,11788,"ule-path=<path/to/directory>``.; * (2) ``-fmodule-file=<path/to/BMI>`` (Deprecated).; * (3) ``-fmodule-file=<module-name>=<path/to/BMI>``. The option ``-fprebuilt-module-path`` tells the compiler the path where to search for dependent BMIs.; It may be used multiple times just like ``-I`` for specifying paths for header files. The look up rule here is:. * (1) When we import module M. The compiler would look up M.pcm in the directories specified; by ``-fprebuilt-module-path``.; * (2) When we import partition module unit M:P. The compiler would look up M-P.pcm in the; directories specified by ``-fprebuilt-module-path``. The option ``-fmodule-file=<path/to/BMI>`` tells the compiler to load the specified BMI directly.; The option ``-fmodule-file=<module-name>=<path/to/BMI>`` tells the compiler to load the specified BMI; for the module specified by ``<module-name>`` when necessary. The main difference is that; ``-fmodule-file=<path/to/BMI>`` will load the BMI eagerly, whereas; ``-fmodule-file=<module-name>=<path/to/BMI>`` will only load the BMI lazily, which is similar; with ``-fprebuilt-module-path``. The option ``-fmodule-file=<path/to/BMI>`` for named modules is deprecated; and is planning to be removed in future versions. In case all ``-fprebuilt-module-path=<path/to/directory>``, ``-fmodule-file=<path/to/BMI>`` and; ``-fmodule-file=<module-name>=<path/to/BMI>`` exist, the ``-fmodule-file=<path/to/BMI>`` option; takes highest precedence and ``-fmodule-file=<module-name>=<path/to/BMI>`` will take the second; highest precedence. We need to specify all the dependent (directly and indirectly) BMIs.; See https://github.com/llvm/llvm-project/issues/62707 for detail. When we compile a ``module implementation unit``, we must specify the BMI of the corresponding; ``primary module interface unit``.; Since the language specification says a module implementation unit implicitly imports; the primary module interface unit. [module.unit]p8. A module-declaration that contains neither ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:11875,Performance,load,load,11875,"ule-path=<path/to/directory>``.; * (2) ``-fmodule-file=<path/to/BMI>`` (Deprecated).; * (3) ``-fmodule-file=<module-name>=<path/to/BMI>``. The option ``-fprebuilt-module-path`` tells the compiler the path where to search for dependent BMIs.; It may be used multiple times just like ``-I`` for specifying paths for header files. The look up rule here is:. * (1) When we import module M. The compiler would look up M.pcm in the directories specified; by ``-fprebuilt-module-path``.; * (2) When we import partition module unit M:P. The compiler would look up M-P.pcm in the; directories specified by ``-fprebuilt-module-path``. The option ``-fmodule-file=<path/to/BMI>`` tells the compiler to load the specified BMI directly.; The option ``-fmodule-file=<module-name>=<path/to/BMI>`` tells the compiler to load the specified BMI; for the module specified by ``<module-name>`` when necessary. The main difference is that; ``-fmodule-file=<path/to/BMI>`` will load the BMI eagerly, whereas; ``-fmodule-file=<module-name>=<path/to/BMI>`` will only load the BMI lazily, which is similar; with ``-fprebuilt-module-path``. The option ``-fmodule-file=<path/to/BMI>`` for named modules is deprecated; and is planning to be removed in future versions. In case all ``-fprebuilt-module-path=<path/to/directory>``, ``-fmodule-file=<path/to/BMI>`` and; ``-fmodule-file=<module-name>=<path/to/BMI>`` exist, the ``-fmodule-file=<path/to/BMI>`` option; takes highest precedence and ``-fmodule-file=<module-name>=<path/to/BMI>`` will take the second; highest precedence. We need to specify all the dependent (directly and indirectly) BMIs.; See https://github.com/llvm/llvm-project/issues/62707 for detail. When we compile a ``module implementation unit``, we must specify the BMI of the corresponding; ``primary module interface unit``.; Since the language specification says a module implementation unit implicitly imports; the primary module interface unit. [module.unit]p8. A module-declaration that contains neither ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:15364,Performance,cache,cache,15364,"--'. And the compilation process for module units are like:. .. code-block:: text. src1.cpp ----------------------------------------+> clang++ src1.cpp -------> src1.o -,; (header unit) hdr1.h -> clang++ hdr1.h ... -> hdr1.pcm --' +-> clang++ src1.o mod1.o src2.o -> executable; mod1.cppm -> clang++ mod1.cppm ... -> mod1.pcm --,--> clang++ mod1.pcm ... -> mod1.o -+; src2.cpp ----------------------------------------+> clang++ src2.cpp -------> src2.o -'. As the diagrams show, we need to compile the BMI from module units to object files and link the object files.; (But we can't do this for the BMI from header units. See the later section for the definition of header units). If we want to create a module library, we can't just ship the BMIs in an archive.; We must compile these BMIs(``*.pcm``) into object files(``*.o``) and add those object files to the archive instead. Consistency Requirement; ~~~~~~~~~~~~~~~~~~~~~~~. If we envision modules as a cache to speed up compilation, then - as with other caching techniques -; it is important to keep cache consistency.; So **currently** Clang will do very strict check for consistency. Options consistency; ^^^^^^^^^^^^^^^^^^^. The language option of module units and their non-module-unit users should be consistent.; The following example is not allowed:. .. code-block:: c++. // M.cppm; export module M;. // Use.cpp; import M;. .. code-block:: console. $ clang++ -std=c++20 M.cppm --precompile -o M.pcm; $ clang++ -std=c++23 Use.cpp -fprebuilt-module-path=. The compiler would reject the example due to the inconsistent language options.; Not all options are language options.; For example, the following example is allowed:. .. code-block:: console. $ clang++ -std=c++20 M.cppm --precompile -o M.pcm; # Inconsistent optimization level.; $ clang++ -std=c++20 -O3 Use.cpp -fprebuilt-module-path=.; # Inconsistent debugging level.; $ clang++ -std=c++20 -g Use.cpp -fprebuilt-module-path=. Although the two examples have inconsistent optimization",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:15462,Performance,cache,cache,15462,"--'. And the compilation process for module units are like:. .. code-block:: text. src1.cpp ----------------------------------------+> clang++ src1.cpp -------> src1.o -,; (header unit) hdr1.h -> clang++ hdr1.h ... -> hdr1.pcm --' +-> clang++ src1.o mod1.o src2.o -> executable; mod1.cppm -> clang++ mod1.cppm ... -> mod1.pcm --,--> clang++ mod1.pcm ... -> mod1.o -+; src2.cpp ----------------------------------------+> clang++ src2.cpp -------> src2.o -'. As the diagrams show, we need to compile the BMI from module units to object files and link the object files.; (But we can't do this for the BMI from header units. See the later section for the definition of header units). If we want to create a module library, we can't just ship the BMIs in an archive.; We must compile these BMIs(``*.pcm``) into object files(``*.o``) and add those object files to the archive instead. Consistency Requirement; ~~~~~~~~~~~~~~~~~~~~~~~. If we envision modules as a cache to speed up compilation, then - as with other caching techniques -; it is important to keep cache consistency.; So **currently** Clang will do very strict check for consistency. Options consistency; ^^^^^^^^^^^^^^^^^^^. The language option of module units and their non-module-unit users should be consistent.; The following example is not allowed:. .. code-block:: c++. // M.cppm; export module M;. // Use.cpp; import M;. .. code-block:: console. $ clang++ -std=c++20 M.cppm --precompile -o M.pcm; $ clang++ -std=c++23 Use.cpp -fprebuilt-module-path=. The compiler would reject the example due to the inconsistent language options.; Not all options are language options.; For example, the following example is allowed:. .. code-block:: console. $ clang++ -std=c++20 M.cppm --precompile -o M.pcm; # Inconsistent optimization level.; $ clang++ -std=c++20 -O3 Use.cpp -fprebuilt-module-path=.; # Inconsistent debugging level.; $ clang++ -std=c++20 -g Use.cpp -fprebuilt-module-path=. Although the two examples have inconsistent optimization",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:16182,Performance,optimiz,optimization,16182,"pile these BMIs(``*.pcm``) into object files(``*.o``) and add those object files to the archive instead. Consistency Requirement; ~~~~~~~~~~~~~~~~~~~~~~~. If we envision modules as a cache to speed up compilation, then - as with other caching techniques -; it is important to keep cache consistency.; So **currently** Clang will do very strict check for consistency. Options consistency; ^^^^^^^^^^^^^^^^^^^. The language option of module units and their non-module-unit users should be consistent.; The following example is not allowed:. .. code-block:: c++. // M.cppm; export module M;. // Use.cpp; import M;. .. code-block:: console. $ clang++ -std=c++20 M.cppm --precompile -o M.pcm; $ clang++ -std=c++23 Use.cpp -fprebuilt-module-path=. The compiler would reject the example due to the inconsistent language options.; Not all options are language options.; For example, the following example is allowed:. .. code-block:: console. $ clang++ -std=c++20 M.cppm --precompile -o M.pcm; # Inconsistent optimization level.; $ clang++ -std=c++20 -O3 Use.cpp -fprebuilt-module-path=.; # Inconsistent debugging level.; $ clang++ -std=c++20 -g Use.cpp -fprebuilt-module-path=. Although the two examples have inconsistent optimization and debugging level, both of them are accepted. Note that **currently** the compiler doesn't consider inconsistent macro definition a problem. For example:. .. code-block:: console. $ clang++ -std=c++20 M.cppm --precompile -o M.pcm; # Inconsistent optimization level.; $ clang++ -std=c++20 -O3 -DNDEBUG Use.cpp -fprebuilt-module-path=. Currently Clang would accept the above example. But it may produce surprising results if the; debugging code depends on consistent use of ``NDEBUG`` also in other translation units. Definitions consistency; ^^^^^^^^^^^^^^^^^^^^^^^. The C++ language defines that same declarations in different translation units should have; the same definition, as known as ODR (One Definition Rule). Prior to modules, the translation; units don't depend",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:16396,Performance,optimiz,optimization,16396,"s with other caching techniques -; it is important to keep cache consistency.; So **currently** Clang will do very strict check for consistency. Options consistency; ^^^^^^^^^^^^^^^^^^^. The language option of module units and their non-module-unit users should be consistent.; The following example is not allowed:. .. code-block:: c++. // M.cppm; export module M;. // Use.cpp; import M;. .. code-block:: console. $ clang++ -std=c++20 M.cppm --precompile -o M.pcm; $ clang++ -std=c++23 Use.cpp -fprebuilt-module-path=. The compiler would reject the example due to the inconsistent language options.; Not all options are language options.; For example, the following example is allowed:. .. code-block:: console. $ clang++ -std=c++20 M.cppm --precompile -o M.pcm; # Inconsistent optimization level.; $ clang++ -std=c++20 -O3 Use.cpp -fprebuilt-module-path=.; # Inconsistent debugging level.; $ clang++ -std=c++20 -g Use.cpp -fprebuilt-module-path=. Although the two examples have inconsistent optimization and debugging level, both of them are accepted. Note that **currently** the compiler doesn't consider inconsistent macro definition a problem. For example:. .. code-block:: console. $ clang++ -std=c++20 M.cppm --precompile -o M.pcm; # Inconsistent optimization level.; $ clang++ -std=c++20 -O3 -DNDEBUG Use.cpp -fprebuilt-module-path=. Currently Clang would accept the above example. But it may produce surprising results if the; debugging code depends on consistent use of ``NDEBUG`` also in other translation units. Definitions consistency; ^^^^^^^^^^^^^^^^^^^^^^^. The C++ language defines that same declarations in different translation units should have; the same definition, as known as ODR (One Definition Rule). Prior to modules, the translation; units don't dependent on each other and the compiler itself can't perform a strong; ODR violation check. With the introduction of modules, now the compiler have; the chance to perform ODR violations with language semantics across translatio",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:16657,Performance,optimiz,optimization,16657,"s should be consistent.; The following example is not allowed:. .. code-block:: c++. // M.cppm; export module M;. // Use.cpp; import M;. .. code-block:: console. $ clang++ -std=c++20 M.cppm --precompile -o M.pcm; $ clang++ -std=c++23 Use.cpp -fprebuilt-module-path=. The compiler would reject the example due to the inconsistent language options.; Not all options are language options.; For example, the following example is allowed:. .. code-block:: console. $ clang++ -std=c++20 M.cppm --precompile -o M.pcm; # Inconsistent optimization level.; $ clang++ -std=c++20 -O3 Use.cpp -fprebuilt-module-path=.; # Inconsistent debugging level.; $ clang++ -std=c++20 -g Use.cpp -fprebuilt-module-path=. Although the two examples have inconsistent optimization and debugging level, both of them are accepted. Note that **currently** the compiler doesn't consider inconsistent macro definition a problem. For example:. .. code-block:: console. $ clang++ -std=c++20 M.cppm --precompile -o M.pcm; # Inconsistent optimization level.; $ clang++ -std=c++20 -O3 -DNDEBUG Use.cpp -fprebuilt-module-path=. Currently Clang would accept the above example. But it may produce surprising results if the; debugging code depends on consistent use of ``NDEBUG`` also in other translation units. Definitions consistency; ^^^^^^^^^^^^^^^^^^^^^^^. The C++ language defines that same declarations in different translation units should have; the same definition, as known as ODR (One Definition Rule). Prior to modules, the translation; units don't dependent on each other and the compiler itself can't perform a strong; ODR violation check. With the introduction of modules, now the compiler have; the chance to perform ODR violations with language semantics across translation units. However, in the practice, we found the existing ODR checking mechanism is not stable; enough. Many people suffers from the false positive ODR violation diagnostics, AKA,; the compiler are complaining two identical declarations have different de",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:17230,Performance,perform,perform,17230,"el.; $ clang++ -std=c++20 -O3 Use.cpp -fprebuilt-module-path=.; # Inconsistent debugging level.; $ clang++ -std=c++20 -g Use.cpp -fprebuilt-module-path=. Although the two examples have inconsistent optimization and debugging level, both of them are accepted. Note that **currently** the compiler doesn't consider inconsistent macro definition a problem. For example:. .. code-block:: console. $ clang++ -std=c++20 M.cppm --precompile -o M.pcm; # Inconsistent optimization level.; $ clang++ -std=c++20 -O3 -DNDEBUG Use.cpp -fprebuilt-module-path=. Currently Clang would accept the above example. But it may produce surprising results if the; debugging code depends on consistent use of ``NDEBUG`` also in other translation units. Definitions consistency; ^^^^^^^^^^^^^^^^^^^^^^^. The C++ language defines that same declarations in different translation units should have; the same definition, as known as ODR (One Definition Rule). Prior to modules, the translation; units don't dependent on each other and the compiler itself can't perform a strong; ODR violation check. With the introduction of modules, now the compiler have; the chance to perform ODR violations with language semantics across translation units. However, in the practice, we found the existing ODR checking mechanism is not stable; enough. Many people suffers from the false positive ODR violation diagnostics, AKA,; the compiler are complaining two identical declarations have different definitions; incorrectly. Also the true positive ODR violations are rarely reported.; Also we learned that MSVC don't perform ODR check for declarations in the global module; fragment. So in order to get better user experience, save the time checking ODR and keep consistent; behavior with MSVC, we disabled the ODR check for the declarations in the global module; fragment by default. Users who want more strict check can still use the; ``-Xclang -fno-skip-odr-check-in-gmf`` flag to get the ODR check enabled. It is also; encouraged to repor",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:17340,Performance,perform,perform,17340,"dule-path=. Although the two examples have inconsistent optimization and debugging level, both of them are accepted. Note that **currently** the compiler doesn't consider inconsistent macro definition a problem. For example:. .. code-block:: console. $ clang++ -std=c++20 M.cppm --precompile -o M.pcm; # Inconsistent optimization level.; $ clang++ -std=c++20 -O3 -DNDEBUG Use.cpp -fprebuilt-module-path=. Currently Clang would accept the above example. But it may produce surprising results if the; debugging code depends on consistent use of ``NDEBUG`` also in other translation units. Definitions consistency; ^^^^^^^^^^^^^^^^^^^^^^^. The C++ language defines that same declarations in different translation units should have; the same definition, as known as ODR (One Definition Rule). Prior to modules, the translation; units don't dependent on each other and the compiler itself can't perform a strong; ODR violation check. With the introduction of modules, now the compiler have; the chance to perform ODR violations with language semantics across translation units. However, in the practice, we found the existing ODR checking mechanism is not stable; enough. Many people suffers from the false positive ODR violation diagnostics, AKA,; the compiler are complaining two identical declarations have different definitions; incorrectly. Also the true positive ODR violations are rarely reported.; Also we learned that MSVC don't perform ODR check for declarations in the global module; fragment. So in order to get better user experience, save the time checking ODR and keep consistent; behavior with MSVC, we disabled the ODR check for the declarations in the global module; fragment by default. Users who want more strict check can still use the; ``-Xclang -fno-skip-odr-check-in-gmf`` flag to get the ODR check enabled. It is also; encouraged to report issues if users find false positive ODR violations or false negative ODR; violations with the flag enabled. ABI Impacts; -----------. The de",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:17773,Performance,perform,perform,17773,"le. But it may produce surprising results if the; debugging code depends on consistent use of ``NDEBUG`` also in other translation units. Definitions consistency; ^^^^^^^^^^^^^^^^^^^^^^^. The C++ language defines that same declarations in different translation units should have; the same definition, as known as ODR (One Definition Rule). Prior to modules, the translation; units don't dependent on each other and the compiler itself can't perform a strong; ODR violation check. With the introduction of modules, now the compiler have; the chance to perform ODR violations with language semantics across translation units. However, in the practice, we found the existing ODR checking mechanism is not stable; enough. Many people suffers from the false positive ODR violation diagnostics, AKA,; the compiler are complaining two identical declarations have different definitions; incorrectly. Also the true positive ODR violations are rarely reported.; Also we learned that MSVC don't perform ODR check for declarations in the global module; fragment. So in order to get better user experience, save the time checking ODR and keep consistent; behavior with MSVC, we disabled the ODR check for the declarations in the global module; fragment by default. Users who want more strict check can still use the; ``-Xclang -fno-skip-odr-check-in-gmf`` flag to get the ODR check enabled. It is also; encouraged to report issues if users find false positive ODR violations or false negative ODR; violations with the flag enabled. ABI Impacts; -----------. The declarations in a module unit which are not in the global module fragment have new linkage names. For example,. .. code-block:: c++. export module M;; namespace NS {; export int foo();; }. The linkage name of ``NS::foo()`` would be ``_ZN2NSW1M3fooEv``.; This couldn't be demangled by previous versions of the debugger or demangler.; As of LLVM 15.x, users can utilize ``llvm-cxxfilt`` to demangle this:. .. code-block:: console. $ llvm-cxxfilt _ZN2NSW",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:39243,Performance,cache,cache,39243,"tead a real binary. There are 4 potential solutions to the problem:. * (1) End users can resolve the issue by pointing the specified compiler executable to; the real binary instead of the symlink.; * (2) End users can invoke ``<path-to-compiler-executable>/clang++ -print-resource-dir``; to get the corresponding resource directory for your compiler and add that directory; to the include search paths manually in the build scripts.; * (3) Build systems that use a compilation database as the input for clang-scan-deps; scanner, the build system can add the flag ``--resource-dir-recipe invoke-compiler`` to; the clang-scan-deps scanner to calculate the resources directory dynamically.; The calculation happens only once for a unique ``<path-to-compiler-executable>/clang++``.; * (4) For build systems that invokes the clang-scan-deps scanner per file, repeatedly; calculating the resource directory may be inefficient. In such cases, the build; system can cache the resource directory by itself and pass ``-resource-dir <resource-dir>``; explicitly in the command line options:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 -resource-dir <resource-dir> mod.cppm -c -o mod.o. Possible Questions; ==================. How modules speed up compilation; --------------------------------. A classic theory for the reason why modules speed up the compilation is:; if there are ``n`` headers and ``m`` source files and each header is included by each source file,; then the complexity of the compilation is ``O(n*m)``;; But if there are ``n`` module interfaces and ``m`` source files, the complexity of the compilation is; ``O(n+m)``. So, using modules would be a big win when scaling.; In a simpler word, we could get rid of many redundant compilations by using modules. Roughly, this theory is correct. But the problem is that it is too rough.; The behavior depends on the optimization level, as we will illustrate below. First is ``O0``. T",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:40218,Performance,optimiz,optimization,40218,"ild; system can cache the resource directory by itself and pass ``-resource-dir <resource-dir>``; explicitly in the command line options:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 -resource-dir <resource-dir> mod.cppm -c -o mod.o. Possible Questions; ==================. How modules speed up compilation; --------------------------------. A classic theory for the reason why modules speed up the compilation is:; if there are ``n`` headers and ``m`` source files and each header is included by each source file,; then the complexity of the compilation is ``O(n*m)``;; But if there are ``n`` module interfaces and ``m`` source files, the complexity of the compilation is; ``O(n+m)``. So, using modules would be a big win when scaling.; In a simpler word, we could get rid of many redundant compilations by using modules. Roughly, this theory is correct. But the problem is that it is too rough.; The behavior depends on the optimization level, as we will illustrate below. First is ``O0``. The compilation process is described in the following graph. .. code-block:: none. ├-------------frontend----------┼-------------middle end----------------┼----backend----┤; │ │ │ │; └---parsing----sema----codegen--┴----- transformations ---- codegen ----┴---- codegen --┘. ┌---------------------------------------------------------------------------------------┐; | │; | source file │; | │; └---------------------------------------------------------------------------------------┘. ┌--------┐; │ │; │imported│; │ │; │ code │; │ │; └--------┘. Here we can see that the source file (could be a non-module unit or a module unit) would get processed by the; whole pipeline.; But the imported code would only get involved in semantic analysis, which is mainly about name lookup,; overload resolution and template instantiation.; All of these processes are fast relative to the whole compilation process.; More importantly, the imported code only n",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:41396,Performance,optimiz,optimizations,41396,"----middle end----------------┼----backend----┤; │ │ │ │; └---parsing----sema----codegen--┴----- transformations ---- codegen ----┴---- codegen --┘. ┌---------------------------------------------------------------------------------------┐; | │; | source file │; | │; └---------------------------------------------------------------------------------------┘. ┌--------┐; │ │; │imported│; │ │; │ code │; │ │; └--------┘. Here we can see that the source file (could be a non-module unit or a module unit) would get processed by the; whole pipeline.; But the imported code would only get involved in semantic analysis, which is mainly about name lookup,; overload resolution and template instantiation.; All of these processes are fast relative to the whole compilation process.; More importantly, the imported code only needs to be processed once in frontend code generation,; as well as the whole middle end and backend.; So we could get a big win for the compilation time in O0. But with optimizations, things are different:. (we omit ``code generation`` part for each end due to the limited space). .. code-block:: none. ├-------- frontend ---------┼--------------- middle end --------------------┼------ backend ----┤; │ │ │ │; └--- parsing ---- sema -----┴--- optimizations --- IPO ---- optimizations---┴--- optimizations -┘. ┌-----------------------------------------------------------------------------------------------┐; │ │; │ source file │; │ │; └-----------------------------------------------------------------------------------------------┘; ┌---------------------------------------┐; │ │; │ │; │ imported code │; │ │; │ │; └---------------------------------------┘. It would be very unfortunate if we end up with worse performance after using modules.; The main concern is that when we compile a source file, the compiler needs to see the function body; of imported module units so that it can perform IPO (InterProcedural Optimization, primarily inlining; in practice) to optimize functio",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:41671,Performance,optimiz,optimizations,41671,"--------------┐; | │; | source file │; | │; └---------------------------------------------------------------------------------------┘. ┌--------┐; │ │; │imported│; │ │; │ code │; │ │; └--------┘. Here we can see that the source file (could be a non-module unit or a module unit) would get processed by the; whole pipeline.; But the imported code would only get involved in semantic analysis, which is mainly about name lookup,; overload resolution and template instantiation.; All of these processes are fast relative to the whole compilation process.; More importantly, the imported code only needs to be processed once in frontend code generation,; as well as the whole middle end and backend.; So we could get a big win for the compilation time in O0. But with optimizations, things are different:. (we omit ``code generation`` part for each end due to the limited space). .. code-block:: none. ├-------- frontend ---------┼--------------- middle end --------------------┼------ backend ----┤; │ │ │ │; └--- parsing ---- sema -----┴--- optimizations --- IPO ---- optimizations---┴--- optimizations -┘. ┌-----------------------------------------------------------------------------------------------┐; │ │; │ source file │; │ │; └-----------------------------------------------------------------------------------------------┘; ┌---------------------------------------┐; │ │; │ │; │ imported code │; │ │; │ │; └---------------------------------------┘. It would be very unfortunate if we end up with worse performance after using modules.; The main concern is that when we compile a source file, the compiler needs to see the function body; of imported module units so that it can perform IPO (InterProcedural Optimization, primarily inlining; in practice) to optimize functions in current source file with the help of the information provided by; the imported module units.; In other words, the imported code would be processed again and again in importee units; by optimizations (including IPO its",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:41698,Performance,optimiz,optimizations,41698,"--------------┐; | │; | source file │; | │; └---------------------------------------------------------------------------------------┘. ┌--------┐; │ │; │imported│; │ │; │ code │; │ │; └--------┘. Here we can see that the source file (could be a non-module unit or a module unit) would get processed by the; whole pipeline.; But the imported code would only get involved in semantic analysis, which is mainly about name lookup,; overload resolution and template instantiation.; All of these processes are fast relative to the whole compilation process.; More importantly, the imported code only needs to be processed once in frontend code generation,; as well as the whole middle end and backend.; So we could get a big win for the compilation time in O0. But with optimizations, things are different:. (we omit ``code generation`` part for each end due to the limited space). .. code-block:: none. ├-------- frontend ---------┼--------------- middle end --------------------┼------ backend ----┤; │ │ │ │; └--- parsing ---- sema -----┴--- optimizations --- IPO ---- optimizations---┴--- optimizations -┘. ┌-----------------------------------------------------------------------------------------------┐; │ │; │ source file │; │ │; └-----------------------------------------------------------------------------------------------┘; ┌---------------------------------------┐; │ │; │ │; │ imported code │; │ │; │ │; └---------------------------------------┘. It would be very unfortunate if we end up with worse performance after using modules.; The main concern is that when we compile a source file, the compiler needs to see the function body; of imported module units so that it can perform IPO (InterProcedural Optimization, primarily inlining; in practice) to optimize functions in current source file with the help of the information provided by; the imported module units.; In other words, the imported code would be processed again and again in importee units; by optimizations (including IPO its",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:41719,Performance,optimiz,optimizations,41719,"--------------┐; | │; | source file │; | │; └---------------------------------------------------------------------------------------┘. ┌--------┐; │ │; │imported│; │ │; │ code │; │ │; └--------┘. Here we can see that the source file (could be a non-module unit or a module unit) would get processed by the; whole pipeline.; But the imported code would only get involved in semantic analysis, which is mainly about name lookup,; overload resolution and template instantiation.; All of these processes are fast relative to the whole compilation process.; More importantly, the imported code only needs to be processed once in frontend code generation,; as well as the whole middle end and backend.; So we could get a big win for the compilation time in O0. But with optimizations, things are different:. (we omit ``code generation`` part for each end due to the limited space). .. code-block:: none. ├-------- frontend ---------┼--------------- middle end --------------------┼------ backend ----┤; │ │ │ │; └--- parsing ---- sema -----┴--- optimizations --- IPO ---- optimizations---┴--- optimizations -┘. ┌-----------------------------------------------------------------------------------------------┐; │ │; │ source file │; │ │; └-----------------------------------------------------------------------------------------------┘; ┌---------------------------------------┐; │ │; │ │; │ imported code │; │ │; │ │; └---------------------------------------┘. It would be very unfortunate if we end up with worse performance after using modules.; The main concern is that when we compile a source file, the compiler needs to see the function body; of imported module units so that it can perform IPO (InterProcedural Optimization, primarily inlining; in practice) to optimize functions in current source file with the help of the information provided by; the imported module units.; In other words, the imported code would be processed again and again in importee units; by optimizations (including IPO its",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:42140,Performance,perform,performance,42140,"es are fast relative to the whole compilation process.; More importantly, the imported code only needs to be processed once in frontend code generation,; as well as the whole middle end and backend.; So we could get a big win for the compilation time in O0. But with optimizations, things are different:. (we omit ``code generation`` part for each end due to the limited space). .. code-block:: none. ├-------- frontend ---------┼--------------- middle end --------------------┼------ backend ----┤; │ │ │ │; └--- parsing ---- sema -----┴--- optimizations --- IPO ---- optimizations---┴--- optimizations -┘. ┌-----------------------------------------------------------------------------------------------┐; │ │; │ source file │; │ │; └-----------------------------------------------------------------------------------------------┘; ┌---------------------------------------┐; │ │; │ │; │ imported code │; │ │; │ │; └---------------------------------------┘. It would be very unfortunate if we end up with worse performance after using modules.; The main concern is that when we compile a source file, the compiler needs to see the function body; of imported module units so that it can perform IPO (InterProcedural Optimization, primarily inlining; in practice) to optimize functions in current source file with the help of the information provided by; the imported module units.; In other words, the imported code would be processed again and again in importee units; by optimizations (including IPO itself).; The optimizations before IPO and the IPO itself are the most time-consuming part in whole compilation process.; So from this perspective, we might not be able to get the improvements described in the theory.; But we could still save the time for optimizations after IPO and the whole backend. Overall, at ``O0`` the implementations of functions defined in a module will not impact module users,; but at higher optimization levels the definitions of such functions are provided to user comp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:42315,Performance,perform,perform,42315," get a big win for the compilation time in O0. But with optimizations, things are different:. (we omit ``code generation`` part for each end due to the limited space). .. code-block:: none. ├-------- frontend ---------┼--------------- middle end --------------------┼------ backend ----┤; │ │ │ │; └--- parsing ---- sema -----┴--- optimizations --- IPO ---- optimizations---┴--- optimizations -┘. ┌-----------------------------------------------------------------------------------------------┐; │ │; │ source file │; │ │; └-----------------------------------------------------------------------------------------------┘; ┌---------------------------------------┐; │ │; │ │; │ imported code │; │ │; │ │; └---------------------------------------┘. It would be very unfortunate if we end up with worse performance after using modules.; The main concern is that when we compile a source file, the compiler needs to see the function body; of imported module units so that it can perform IPO (InterProcedural Optimization, primarily inlining; in practice) to optimize functions in current source file with the help of the information provided by; the imported module units.; In other words, the imported code would be processed again and again in importee units; by optimizations (including IPO itself).; The optimizations before IPO and the IPO itself are the most time-consuming part in whole compilation process.; So from this perspective, we might not be able to get the improvements described in the theory.; But we could still save the time for optimizations after IPO and the whole backend. Overall, at ``O0`` the implementations of functions defined in a module will not impact module users,; but at higher optimization levels the definitions of such functions are provided to user compilations for the; purposes of optimization (but definitions of these functions are still not included in the use's object file)-; this means the build speedup at higher optimization levels may be lower than expe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:42394,Performance,optimiz,optimize,42394," get a big win for the compilation time in O0. But with optimizations, things are different:. (we omit ``code generation`` part for each end due to the limited space). .. code-block:: none. ├-------- frontend ---------┼--------------- middle end --------------------┼------ backend ----┤; │ │ │ │; └--- parsing ---- sema -----┴--- optimizations --- IPO ---- optimizations---┴--- optimizations -┘. ┌-----------------------------------------------------------------------------------------------┐; │ │; │ source file │; │ │; └-----------------------------------------------------------------------------------------------┘; ┌---------------------------------------┐; │ │; │ │; │ imported code │; │ │; │ │; └---------------------------------------┘. It would be very unfortunate if we end up with worse performance after using modules.; The main concern is that when we compile a source file, the compiler needs to see the function body; of imported module units so that it can perform IPO (InterProcedural Optimization, primarily inlining; in practice) to optimize functions in current source file with the help of the information provided by; the imported module units.; In other words, the imported code would be processed again and again in importee units; by optimizations (including IPO itself).; The optimizations before IPO and the IPO itself are the most time-consuming part in whole compilation process.; So from this perspective, we might not be able to get the improvements described in the theory.; But we could still save the time for optimizations after IPO and the whole backend. Overall, at ``O0`` the implementations of functions defined in a module will not impact module users,; but at higher optimization levels the definitions of such functions are provided to user compilations for the; purposes of optimization (but definitions of these functions are still not included in the use's object file)-; this means the build speedup at higher optimization levels may be lower than expe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:42601,Performance,optimiz,optimizations,42601,"- middle end --------------------┼------ backend ----┤; │ │ │ │; └--- parsing ---- sema -----┴--- optimizations --- IPO ---- optimizations---┴--- optimizations -┘. ┌-----------------------------------------------------------------------------------------------┐; │ │; │ source file │; │ │; └-----------------------------------------------------------------------------------------------┘; ┌---------------------------------------┐; │ │; │ │; │ imported code │; │ │; │ │; └---------------------------------------┘. It would be very unfortunate if we end up with worse performance after using modules.; The main concern is that when we compile a source file, the compiler needs to see the function body; of imported module units so that it can perform IPO (InterProcedural Optimization, primarily inlining; in practice) to optimize functions in current source file with the help of the information provided by; the imported module units.; In other words, the imported code would be processed again and again in importee units; by optimizations (including IPO itself).; The optimizations before IPO and the IPO itself are the most time-consuming part in whole compilation process.; So from this perspective, we might not be able to get the improvements described in the theory.; But we could still save the time for optimizations after IPO and the whole backend. Overall, at ``O0`` the implementations of functions defined in a module will not impact module users,; but at higher optimization levels the definitions of such functions are provided to user compilations for the; purposes of optimization (but definitions of these functions are still not included in the use's object file)-; this means the build speedup at higher optimization levels may be lower than expected given ``O0`` experience,; but does provide by more optimization opportunities. Interoperability with Clang Modules; -----------------------------------. We **wish** to support clang modules and standard c++ modules at the same t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:42644,Performance,optimiz,optimizations,42644,"--- optimizations---┴--- optimizations -┘. ┌-----------------------------------------------------------------------------------------------┐; │ │; │ source file │; │ │; └-----------------------------------------------------------------------------------------------┘; ┌---------------------------------------┐; │ │; │ │; │ imported code │; │ │; │ │; └---------------------------------------┘. It would be very unfortunate if we end up with worse performance after using modules.; The main concern is that when we compile a source file, the compiler needs to see the function body; of imported module units so that it can perform IPO (InterProcedural Optimization, primarily inlining; in practice) to optimize functions in current source file with the help of the information provided by; the imported module units.; In other words, the imported code would be processed again and again in importee units; by optimizations (including IPO itself).; The optimizations before IPO and the IPO itself are the most time-consuming part in whole compilation process.; So from this perspective, we might not be able to get the improvements described in the theory.; But we could still save the time for optimizations after IPO and the whole backend. Overall, at ``O0`` the implementations of functions defined in a module will not impact module users,; but at higher optimization levels the definitions of such functions are provided to user compilations for the; purposes of optimization (but definitions of these functions are still not included in the use's object file)-; this means the build speedup at higher optimization levels may be lower than expected given ``O0`` experience,; but does provide by more optimization opportunities. Interoperability with Clang Modules; -----------------------------------. We **wish** to support clang modules and standard c++ modules at the same time,; but the mixed using form is not well used/tested yet. Please file new github issues as you find interoperability pr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:42886,Performance,optimiz,optimizations,42886,"izations---┴--- optimizations -┘. ┌-----------------------------------------------------------------------------------------------┐; │ │; │ source file │; │ │; └-----------------------------------------------------------------------------------------------┘; ┌---------------------------------------┐; │ │; │ │; │ imported code │; │ │; │ │; └---------------------------------------┘. It would be very unfortunate if we end up with worse performance after using modules.; The main concern is that when we compile a source file, the compiler needs to see the function body; of imported module units so that it can perform IPO (InterProcedural Optimization, primarily inlining; in practice) to optimize functions in current source file with the help of the information provided by; the imported module units.; In other words, the imported code would be processed again and again in importee units; by optimizations (including IPO itself).; The optimizations before IPO and the IPO itself are the most time-consuming part in whole compilation process.; So from this perspective, we might not be able to get the improvements described in the theory.; But we could still save the time for optimizations after IPO and the whole backend. Overall, at ``O0`` the implementations of functions defined in a module will not impact module users,; but at higher optimization levels the definitions of such functions are provided to user compilations for the; purposes of optimization (but definitions of these functions are still not included in the use's object file)-; this means the build speedup at higher optimization levels may be lower than expected given ``O0`` experience,; but does provide by more optimization opportunities. Interoperability with Clang Modules; -----------------------------------. We **wish** to support clang modules and standard c++ modules at the same time,; but the mixed using form is not well used/tested yet. Please file new github issues as you find interoperability problems.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:43050,Performance,optimiz,optimization,43050,"izations---┴--- optimizations -┘. ┌-----------------------------------------------------------------------------------------------┐; │ │; │ source file │; │ │; └-----------------------------------------------------------------------------------------------┘; ┌---------------------------------------┐; │ │; │ │; │ imported code │; │ │; │ │; └---------------------------------------┘. It would be very unfortunate if we end up with worse performance after using modules.; The main concern is that when we compile a source file, the compiler needs to see the function body; of imported module units so that it can perform IPO (InterProcedural Optimization, primarily inlining; in practice) to optimize functions in current source file with the help of the information provided by; the imported module units.; In other words, the imported code would be processed again and again in importee units; by optimizations (including IPO itself).; The optimizations before IPO and the IPO itself are the most time-consuming part in whole compilation process.; So from this perspective, we might not be able to get the improvements described in the theory.; But we could still save the time for optimizations after IPO and the whole backend. Overall, at ``O0`` the implementations of functions defined in a module will not impact module users,; but at higher optimization levels the definitions of such functions are provided to user compilations for the; purposes of optimization (but definitions of these functions are still not included in the use's object file)-; this means the build speedup at higher optimization levels may be lower than expected given ``O0`` experience,; but does provide by more optimization opportunities. Interoperability with Clang Modules; -----------------------------------. We **wish** to support clang modules and standard c++ modules at the same time,; but the mixed using form is not well used/tested yet. Please file new github issues as you find interoperability problems.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:43159,Performance,optimiz,optimization,43159,"izations---┴--- optimizations -┘. ┌-----------------------------------------------------------------------------------------------┐; │ │; │ source file │; │ │; └-----------------------------------------------------------------------------------------------┘; ┌---------------------------------------┐; │ │; │ │; │ imported code │; │ │; │ │; └---------------------------------------┘. It would be very unfortunate if we end up with worse performance after using modules.; The main concern is that when we compile a source file, the compiler needs to see the function body; of imported module units so that it can perform IPO (InterProcedural Optimization, primarily inlining; in practice) to optimize functions in current source file with the help of the information provided by; the imported module units.; In other words, the imported code would be processed again and again in importee units; by optimizations (including IPO itself).; The optimizations before IPO and the IPO itself are the most time-consuming part in whole compilation process.; So from this perspective, we might not be able to get the improvements described in the theory.; But we could still save the time for optimizations after IPO and the whole backend. Overall, at ``O0`` the implementations of functions defined in a module will not impact module users,; but at higher optimization levels the definitions of such functions are provided to user compilations for the; purposes of optimization (but definitions of these functions are still not included in the use's object file)-; this means the build speedup at higher optimization levels may be lower than expected given ``O0`` experience,; but does provide by more optimization opportunities. Interoperability with Clang Modules; -----------------------------------. We **wish** to support clang modules and standard c++ modules at the same time,; but the mixed using form is not well used/tested yet. Please file new github issues as you find interoperability problems.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:43298,Performance,optimiz,optimization,43298,"izations---┴--- optimizations -┘. ┌-----------------------------------------------------------------------------------------------┐; │ │; │ source file │; │ │; └-----------------------------------------------------------------------------------------------┘; ┌---------------------------------------┐; │ │; │ │; │ imported code │; │ │; │ │; └---------------------------------------┘. It would be very unfortunate if we end up with worse performance after using modules.; The main concern is that when we compile a source file, the compiler needs to see the function body; of imported module units so that it can perform IPO (InterProcedural Optimization, primarily inlining; in practice) to optimize functions in current source file with the help of the information provided by; the imported module units.; In other words, the imported code would be processed again and again in importee units; by optimizations (including IPO itself).; The optimizations before IPO and the IPO itself are the most time-consuming part in whole compilation process.; So from this perspective, we might not be able to get the improvements described in the theory.; But we could still save the time for optimizations after IPO and the whole backend. Overall, at ``O0`` the implementations of functions defined in a module will not impact module users,; but at higher optimization levels the definitions of such functions are provided to user compilations for the; purposes of optimization (but definitions of these functions are still not included in the use's object file)-; this means the build speedup at higher optimization levels may be lower than expected given ``O0`` experience,; but does provide by more optimization opportunities. Interoperability with Clang Modules; -----------------------------------. We **wish** to support clang modules and standard c++ modules at the same time,; but the mixed using form is not well used/tested yet. Please file new github issues as you find interoperability problems.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:43396,Performance,optimiz,optimization,43396,"izations---┴--- optimizations -┘. ┌-----------------------------------------------------------------------------------------------┐; │ │; │ source file │; │ │; └-----------------------------------------------------------------------------------------------┘; ┌---------------------------------------┐; │ │; │ │; │ imported code │; │ │; │ │; └---------------------------------------┘. It would be very unfortunate if we end up with worse performance after using modules.; The main concern is that when we compile a source file, the compiler needs to see the function body; of imported module units so that it can perform IPO (InterProcedural Optimization, primarily inlining; in practice) to optimize functions in current source file with the help of the information provided by; the imported module units.; In other words, the imported code would be processed again and again in importee units; by optimizations (including IPO itself).; The optimizations before IPO and the IPO itself are the most time-consuming part in whole compilation process.; So from this perspective, we might not be able to get the improvements described in the theory.; But we could still save the time for optimizations after IPO and the whole backend. Overall, at ``O0`` the implementations of functions defined in a module will not impact module users,; but at higher optimization levels the definitions of such functions are provided to user compilations for the; purposes of optimization (but definitions of these functions are still not included in the use's object file)-; this means the build speedup at higher optimization levels may be lower than expected given ``O0`` experience,; but does provide by more optimization opportunities. Interoperability with Clang Modules; -----------------------------------. We **wish** to support clang modules and standard c++ modules at the same time,; but the mixed using form is not well used/tested yet. Please file new github issues as you find interoperability problems.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:31999,Safety,avoid,avoid,31999," have pretty similar semantics with Clang modules.; The semantics of both of them are like headers. In fact, we could even ""mimic"" the sytle of header units by Clang modules:. .. code-block:: c++. module ""iostream"" {; export *; header ""/path/to/libstdcxx/iostream""; }. .. code-block:: console. $ clang++ -std=c++20 -fimplicit-modules -fmodule-map-file=.modulemap main.cpp. It would be simpler if we are using libcxx:. .. code-block:: console. $ clang++ -std=c++20 main.cpp -fimplicit-modules -fimplicit-module-maps. Since there is already one; `module map <https://github.com/llvm/llvm-project/blob/main/libcxx/include/module.modulemap.in>`_; in the source of libcxx. Then immediately leads to the question: why don't we implement header units through Clang header modules?. The main reason for this is that Clang modules have more semantics like hierarchy or; wrapping multiple headers together as a big module.; However, these things are not part of Standard C++ Header units,; and we want to avoid the impression that these additional semantics get interpreted as Standard C++ behavior. Another reason is that there are proposals to introduce module mappers to the C++ standard; (for example, https://wg21.link/p1184r2).; If we decide to reuse Clang's modulemap, we may get in trouble once we need to introduce another module mapper. So the final answer for why we don't reuse the interface of Clang modules for header units is that; there are some differences between header units and Clang modules and that ignoring those; differences now would likely become a problem in the future. Discover Dependencies; =====================. Prior to modules, all the translation units can be compiled parallelly.; But it is not true for the module units. The presence of module units requires; us to compile the translation units in a (topological) order. The clang-scan-deps scanner implemented; `P1689 paper <https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1689r5.html>`_; to describe the order.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:37883,Safety,detect,detects,37883,"g; ``clang++`` simply. The users may want the scanner to get the transitional dependency information for headers.; Otherwise, the users have to scan twice for the project, once for headers and once for modules.; To address the requirement, clang-scan-deps will recognize the specified preprocessor options; in the given command line and generate the corresponding dependency information. For example,. .. code-block:: console. $ clang-scan-deps -format=p1689 -- ../bin/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o -MD -MT impl_part.ddi -MF impl_part.dep; $ cat impl_part.dep. We will get:. .. code-block:: text. impl_part.ddi: \; /usr/include/bits/wchar.h /usr/include/bits/types/wint_t.h \; /usr/include/bits/types/mbstate_t.h \; /usr/include/bits/types/__mbstate_t.h /usr/include/bits/types/__FILE.h \; /usr/include/bits/types/FILE.h /usr/include/bits/types/locale_t.h \; /usr/include/bits/types/__locale_t.h \; ... When clang-scan-deps detects ``-MF`` option, clang-scan-deps will try to write the; dependency information for headers to the file specified by ``-MF``. Possible Issues: Failed to find system headers; ----------------------------------------------. In case the users encounter errors like ``fatal error: 'stddef.h' file not found``,; probably the specified ``<path-to-compiler-executable>/clang++`` refers to a symlink; instead a real binary. There are 4 potential solutions to the problem:. * (1) End users can resolve the issue by pointing the specified compiler executable to; the real binary instead of the symlink.; * (2) End users can invoke ``<path-to-compiler-executable>/clang++ -print-resource-dir``; to get the corresponding resource directory for your compiler and add that directory; to the include search paths manually in the build scripts.; * (3) Build systems that use a compilation database as the input for clang-scan-deps; scanner, the build system can add the flag ``--resource-dir-recipe invoke-compiler`` to; the clang-scan-deps scanner to calculate the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:40074,Safety,redund,redundant,40074,"or build systems that invokes the clang-scan-deps scanner per file, repeatedly; calculating the resource directory may be inefficient. In such cases, the build; system can cache the resource directory by itself and pass ``-resource-dir <resource-dir>``; explicitly in the command line options:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 -resource-dir <resource-dir> mod.cppm -c -o mod.o. Possible Questions; ==================. How modules speed up compilation; --------------------------------. A classic theory for the reason why modules speed up the compilation is:; if there are ``n`` headers and ``m`` source files and each header is included by each source file,; then the complexity of the compilation is ``O(n*m)``;; But if there are ``n`` module interfaces and ``m`` source files, the complexity of the compilation is; ``O(n+m)``. So, using modules would be a big win when scaling.; In a simpler word, we could get rid of many redundant compilations by using modules. Roughly, this theory is correct. But the problem is that it is too rough.; The behavior depends on the optimization level, as we will illustrate below. First is ``O0``. The compilation process is described in the following graph. .. code-block:: none. ├-------------frontend----------┼-------------middle end----------------┼----backend----┤; │ │ │ │; └---parsing----sema----codegen--┴----- transformations ---- codegen ----┴---- codegen --┘. ┌---------------------------------------------------------------------------------------┐; | │; | source file │; | │; └---------------------------------------------------------------------------------------┘. ┌--------┐; │ │; │imported│; │ │; │ code │; │ │; └--------┘. Here we can see that the source file (could be a non-module unit or a module unit) would get processed by the; whole pipeline.; But the imported code would only get involved in semantic analysis, which is mainly about name lookup,; overload re",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:35072,Testability,log,logical-name,35072,"file"": ""M.cppm"",; ""output"": ""M.o""; },; {; ""directory"": ""."",; ""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 Impl.cpp -c -o Impl.o"",; ""file"": ""Impl.cpp"",; ""output"": ""Impl.o""; },; {; ""directory"": ""."",; ""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o"",; ""file"": ""impl_part.cppm"",; ""output"": ""impl_part.o""; },; {; ""directory"": ""."",; ""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 interface_part.cppm -c -o interface_part.o"",; ""file"": ""interface_part.cppm"",; ""output"": ""interface_part.o""; },; {; ""directory"": ""."",; ""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 User.cpp -c -o User.o"",; ""file"": ""User.cpp"",; ""output"": ""User.o""; }; ]. And we can get the dependency information in P1689 format by:. .. code-block:: console. $ clang-scan-deps -format=p1689 -compilation-database P1689.json. And we will get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""Impl.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ]; },; {; ""primary-output"": ""M.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; },; {; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ]; },; {; ""primary-output"": ""User.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; },; {; ""logical-name"": ""third_party_module""; }; ]; },; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; },; {; ""primary-output"": ""interface_part.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; }; ],; ""version"": 1; }. See the P1689 paper for the meaning of the fields. And if t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:35199,Testability,log,logical-name,35199,"c++20 Impl.cpp -c -o Impl.o"",; ""file"": ""Impl.cpp"",; ""output"": ""Impl.o""; },; {; ""directory"": ""."",; ""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o"",; ""file"": ""impl_part.cppm"",; ""output"": ""impl_part.o""; },; {; ""directory"": ""."",; ""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 interface_part.cppm -c -o interface_part.o"",; ""file"": ""interface_part.cppm"",; ""output"": ""interface_part.o""; },; {; ""directory"": ""."",; ""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 User.cpp -c -o User.o"",; ""file"": ""User.cpp"",; ""output"": ""User.o""; }; ]. And we can get the dependency information in P1689 format by:. .. code-block:: console. $ clang-scan-deps -format=p1689 -compilation-database P1689.json. And we will get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""Impl.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ]; },; {; ""primary-output"": ""M.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; },; {; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ]; },; {; ""primary-output"": ""User.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; },; {; ""logical-name"": ""third_party_module""; }; ]; },; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; },; {; ""primary-output"": ""interface_part.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; }; ],; ""version"": 1; }. See the P1689 paper for the meaning of the fields. And if the user want a finer-grained control for any reason, e.g., to scan the generated source files,; the user can choose",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:35271,Testability,log,logical-name,35271,"."",; ""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o"",; ""file"": ""impl_part.cppm"",; ""output"": ""impl_part.o""; },; {; ""directory"": ""."",; ""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 interface_part.cppm -c -o interface_part.o"",; ""file"": ""interface_part.cppm"",; ""output"": ""interface_part.o""; },; {; ""directory"": ""."",; ""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 User.cpp -c -o User.o"",; ""file"": ""User.cpp"",; ""output"": ""User.o""; }; ]. And we can get the dependency information in P1689 format by:. .. code-block:: console. $ clang-scan-deps -format=p1689 -compilation-database P1689.json. And we will get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""Impl.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ]; },; {; ""primary-output"": ""M.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; },; {; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ]; },; {; ""primary-output"": ""User.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; },; {; ""logical-name"": ""third_party_module""; }; ]; },; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; },; {; ""primary-output"": ""interface_part.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; }; ],; ""version"": 1; }. See the P1689 paper for the meaning of the fields. And if the user want a finer-grained control for any reason, e.g., to scan the generated source files,; the user can choose to get the dependency information per file. For example:. .. code-block:: console. $ clang-s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:35353,Testability,log,logical-name,35353," impl_part.o"",; ""file"": ""impl_part.cppm"",; ""output"": ""impl_part.o""; },; {; ""directory"": ""."",; ""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 interface_part.cppm -c -o interface_part.o"",; ""file"": ""interface_part.cppm"",; ""output"": ""interface_part.o""; },; {; ""directory"": ""."",; ""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 User.cpp -c -o User.o"",; ""file"": ""User.cpp"",; ""output"": ""User.o""; }; ]. And we can get the dependency information in P1689 format by:. .. code-block:: console. $ clang-scan-deps -format=p1689 -compilation-database P1689.json. And we will get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""Impl.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ]; },; {; ""primary-output"": ""M.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; },; {; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ]; },; {; ""primary-output"": ""User.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; },; {; ""logical-name"": ""third_party_module""; }; ]; },; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; },; {; ""primary-output"": ""interface_part.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; }; ],; ""version"": 1; }. See the P1689 paper for the meaning of the fields. And if the user want a finer-grained control for any reason, e.g., to scan the generated source files,; the user can choose to get the dependency information per file. For example:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 impl_part.c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:35478,Testability,log,logical-name,35478,"-to-compiler-executable>/clang++ -std=c++20 interface_part.cppm -c -o interface_part.o"",; ""file"": ""interface_part.cppm"",; ""output"": ""interface_part.o""; },; {; ""directory"": ""."",; ""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 User.cpp -c -o User.o"",; ""file"": ""User.cpp"",; ""output"": ""User.o""; }; ]. And we can get the dependency information in P1689 format by:. .. code-block:: console. $ clang-scan-deps -format=p1689 -compilation-database P1689.json. And we will get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""Impl.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ]; },; {; ""primary-output"": ""M.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; },; {; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ]; },; {; ""primary-output"": ""User.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; },; {; ""logical-name"": ""third_party_module""; }; ]; },; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; },; {; ""primary-output"": ""interface_part.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; }; ],; ""version"": 1; }. See the P1689 paper for the meaning of the fields. And if the user want a finer-grained control for any reason, e.g., to scan the generated source files,; the user can choose to get the dependency information per file. For example:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o. And we'll get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"":",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:35532,Testability,log,logical-name,35532,"_part.o"",; ""file"": ""interface_part.cppm"",; ""output"": ""interface_part.o""; },; {; ""directory"": ""."",; ""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 User.cpp -c -o User.o"",; ""file"": ""User.cpp"",; ""output"": ""User.o""; }; ]. And we can get the dependency information in P1689 format by:. .. code-block:: console. $ clang-scan-deps -format=p1689 -compilation-database P1689.json. And we will get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""Impl.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ]; },; {; ""primary-output"": ""M.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; },; {; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ]; },; {; ""primary-output"": ""User.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; },; {; ""logical-name"": ""third_party_module""; }; ]; },; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; },; {; ""primary-output"": ""interface_part.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; }; ],; ""version"": 1; }. See the P1689 paper for the meaning of the fields. And if the user want a finer-grained control for any reason, e.g., to scan the generated source files,; the user can choose to get the dependency information per file. For example:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o. And we'll get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:35659,Testability,log,logical-name,35659,"""command"": ""<path-to-compiler-executable>/clang++ -std=c++20 User.cpp -c -o User.o"",; ""file"": ""User.cpp"",; ""output"": ""User.o""; }; ]. And we can get the dependency information in P1689 format by:. .. code-block:: console. $ clang-scan-deps -format=p1689 -compilation-database P1689.json. And we will get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""Impl.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ]; },; {; ""primary-output"": ""M.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; },; {; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ]; },; {; ""primary-output"": ""User.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; },; {; ""logical-name"": ""third_party_module""; }; ]; },; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; },; {; ""primary-output"": ""interface_part.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; }; ],; ""version"": 1; }. See the P1689 paper for the meaning of the fields. And if the user want a finer-grained control for any reason, e.g., to scan the generated source files,; the user can choose to get the dependency information per file. For example:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o. And we'll get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:35749,Testability,log,logical-name,35749,""",; ""output"": ""User.o""; }; ]. And we can get the dependency information in P1689 format by:. .. code-block:: console. $ clang-scan-deps -format=p1689 -compilation-database P1689.json. And we will get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""Impl.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ]; },; {; ""primary-output"": ""M.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; },; {; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ]; },; {; ""primary-output"": ""User.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; },; {; ""logical-name"": ""third_party_module""; }; ]; },; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; },; {; ""primary-output"": ""interface_part.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; }; ],; ""version"": 1; }. See the P1689 paper for the meaning of the fields. And if the user want a finer-grained control for any reason, e.g., to scan the generated source files,; the user can choose to get the dependency information per file. For example:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o. And we'll get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part""; }; ]; }; ],; ""version"": 1; }. In this way, we can pass the single command line options after th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:35917,Testability,log,logical-name,35917,"n-database P1689.json. And we will get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""Impl.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ]; },; {; ""primary-output"": ""M.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; },; {; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ]; },; {; ""primary-output"": ""User.o"",; ""requires"": [; {; ""logical-name"": ""M"",; ""source-path"": ""M.cppm""; },; {; ""logical-name"": ""third_party_module""; }; ]; },; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; },; {; ""primary-output"": ""interface_part.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; }; ],; ""version"": 1; }. See the P1689 paper for the meaning of the fields. And if the user want a finer-grained control for any reason, e.g., to scan the generated source files,; the user can choose to get the dependency information per file. For example:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o. And we'll get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part""; }; ]; }; ],; ""version"": 1; }. In this way, we can pass the single command line options after the ``--``.; Then clang-scan-deps will extract the necessary information from the options.; Note that we need to specify the path to the compiler executable instea",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:36546,Testability,log,logical-name,36546,"ird_party_module""; }; ]; },; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; },; {; ""primary-output"": ""interface_part.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; }; ],; ""version"": 1; }. See the P1689 paper for the meaning of the fields. And if the user want a finer-grained control for any reason, e.g., to scan the generated source files,; the user can choose to get the dependency information per file. For example:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o. And we'll get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part""; }; ]; }; ],; ""version"": 1; }. In this way, we can pass the single command line options after the ``--``.; Then clang-scan-deps will extract the necessary information from the options.; Note that we need to specify the path to the compiler executable instead of saying; ``clang++`` simply. The users may want the scanner to get the transitional dependency information for headers.; Otherwise, the users have to scan twice for the project, once for headers and once for modules.; To address the requirement, clang-scan-deps will recognize the specified preprocessor options; in the given command line and generate the corresponding dependency information. For example,. .. code-block:: console. $ clang-scan-deps -format=p1689 -- ../bin/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o -MD -MT impl_part.ddi -MF impl_part.dep; $ cat impl_part.dep. We will get:. .. code-block:: t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:36636,Testability,log,logical-name,36636,"alse,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; },; {; ""primary-output"": ""interface_part.o"",; ""provides"": [; {; ""is-interface"": true,; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; }; ],; ""version"": 1; }. See the P1689 paper for the meaning of the fields. And if the user want a finer-grained control for any reason, e.g., to scan the generated source files,; the user can choose to get the dependency information per file. For example:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o. And we'll get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part""; }; ]; }; ],; ""version"": 1; }. In this way, we can pass the single command line options after the ``--``.; Then clang-scan-deps will extract the necessary information from the options.; Note that we need to specify the path to the compiler executable instead of saying; ``clang++`` simply. The users may want the scanner to get the transitional dependency information for headers.; Otherwise, the users have to scan twice for the project, once for headers and once for modules.; To address the requirement, clang-scan-deps will recognize the specified preprocessor options; in the given command line and generate the corresponding dependency information. For example,. .. code-block:: console. $ clang-scan-deps -format=p1689 -- ../bin/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o -MD -MT impl_part.ddi -MF impl_part.dep; $ cat impl_part.dep. We will get:. .. code-block:: text. impl_part.ddi: \; /usr/include/bits/wchar.h /usr/include/bits/types/wint_t.h \; /usr/include/bit",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:43621,Testability,test,tested,43621,"izations---┴--- optimizations -┘. ┌-----------------------------------------------------------------------------------------------┐; │ │; │ source file │; │ │; └-----------------------------------------------------------------------------------------------┘; ┌---------------------------------------┐; │ │; │ │; │ imported code │; │ │; │ │; └---------------------------------------┘. It would be very unfortunate if we end up with worse performance after using modules.; The main concern is that when we compile a source file, the compiler needs to see the function body; of imported module units so that it can perform IPO (InterProcedural Optimization, primarily inlining; in practice) to optimize functions in current source file with the help of the information provided by; the imported module units.; In other words, the imported code would be processed again and again in importee units; by optimizations (including IPO itself).; The optimizations before IPO and the IPO itself are the most time-consuming part in whole compilation process.; So from this perspective, we might not be able to get the improvements described in the theory.; But we could still save the time for optimizations after IPO and the whole backend. Overall, at ``O0`` the implementations of functions defined in a module will not impact module users,; but at higher optimization levels the definitions of such functions are provided to user compilations for the; purposes of optimization (but definitions of these functions are still not included in the use's object file)-; this means the build speedup at higher optimization levels may be lower than expected given ``O0`` experience,; but does provide by more optimization opportunities. Interoperability with Clang Modules; -----------------------------------. We **wish** to support clang modules and standard c++ modules at the same time,; but the mixed using form is not well used/tested yet. Please file new github issues as you find interoperability problems.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:4916,Usability,simpl,simple,4916," Built Module Interface file; ~~~~~~~~~~~~~~~~~~~~~~~~~~~. A ``Built Module Interface file`` stands for the precompiled result of an importable module unit.; It is also called the acronym ``BMI`` generally. Global module fragment; ~~~~~~~~~~~~~~~~~~~~~~. In a module unit, the section from ``module;`` to the module declaration is called the global module fragment. How to build projects using modules; -----------------------------------. Quick Start; ~~~~~~~~~~~. Let's see a ""hello world"" example that uses modules. .. code-block:: c++. // Hello.cppm; module;; #include <iostream>; export module Hello;; export void hello() {; std::cout << ""Hello World!\n"";; }. // use.cpp; import Hello;; int main() {; hello();; return 0;; }. Then we type:. .. code-block:: console. $ clang++ -std=c++20 Hello.cppm --precompile -o Hello.pcm; $ clang++ -std=c++20 use.cpp -fmodule-file=Hello=Hello.pcm Hello.pcm -o Hello.out; $ ./Hello.out; Hello World!. In this example, we make and use a simple module ``Hello`` which contains only a; primary module interface unit ``Hello.cppm``. Then let's see a little bit more complex ""hello world"" example which uses the 4 kinds of module units. .. code-block:: c++. // M.cppm; export module M;; export import :interface_part;; import :impl_part;; export void Hello();. // interface_part.cppm; export module M:interface_part;; export void World();. // impl_part.cppm; module;; #include <iostream>; #include <string>; module M:impl_part;; import :interface_part;. std::string W = ""World."";; void World() {; std::cout << W << std::endl;; }. // Impl.cpp; module;; #include <iostream>; module M;; void Hello() {; std::cout << ""Hello "";; }. // User.cpp; import M;; int main() {; Hello();; World();; return 0;; }. Then we are able to compile the example by the following command:. .. code-block:: console. # Precompiling the module; $ clang++ -std=c++20 interface_part.cppm --precompile -o M-interface_part.pcm; $ clang++ -std=c++20 impl_part.cppm --precompile -fprebuilt-module-pa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:7849,Usability,simpl,simpler,7849,"er ``--precompile``; or ``-fmodule-output`` flags. The ``--precompile`` option generates the BMI as the output of the compilation and the output path; can be specified using the ``-o`` option. The ``-fmodule-output`` option generates the BMI as a by-product of the compilation.; If ``-fmodule-output=`` is specified, the BMI will be emitted the specified location. Then if; ``-fmodule-output`` and ``-c`` are specified, the BMI will be emitted in the directory of the; output file with the name of the input file with the new extension ``.pcm``. Otherwise, the BMI; will be emitted in the working directory with the name of the input file with the new extension; ``.pcm``. The style to generate BMIs by ``--precompile`` is called two-phase compilation since it takes; 2 steps to compile a source file to an object file. The style to generate BMIs by ``-fmodule-output``; is called one-phase compilation respectively. The one-phase compilation model is simpler; for build systems to implement and the two-phase compilation has the potential to compile faster due; to higher parallelism. As an example, if there are two module units A and B, and B depends on A, the; one-phase compilation model would need to compile them serially, whereas the two-phase compilation; model may be able to compile them simultaneously if the compilation from A.pcm to A.o takes a long; time. File name requirement; ~~~~~~~~~~~~~~~~~~~~~. The file name of an ``importable module unit`` should end with ``.cppm``; (or ``.ccm``, ``.cxxm``, ``.c++m``). The file name of a ``module implementation unit``; should end with ``.cpp`` (or ``.cc``, ``.cxx``, ``.c++``). The file name of BMIs should end with ``.pcm``.; The file name of the BMI of a ``primary module interface unit`` should be ``module_name.pcm``.; The file name of BMIs of ``module partition unit`` should be ``module_name-partition_name.pcm``. If the file names use different extensions, Clang may fail to build the module.; For example, if the filename of an ``imp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:17749,Usability,learn,learned,17749,"le. But it may produce surprising results if the; debugging code depends on consistent use of ``NDEBUG`` also in other translation units. Definitions consistency; ^^^^^^^^^^^^^^^^^^^^^^^. The C++ language defines that same declarations in different translation units should have; the same definition, as known as ODR (One Definition Rule). Prior to modules, the translation; units don't dependent on each other and the compiler itself can't perform a strong; ODR violation check. With the introduction of modules, now the compiler have; the chance to perform ODR violations with language semantics across translation units. However, in the practice, we found the existing ODR checking mechanism is not stable; enough. Many people suffers from the false positive ODR violation diagnostics, AKA,; the compiler are complaining two identical declarations have different definitions; incorrectly. Also the true positive ODR violations are rarely reported.; Also we learned that MSVC don't perform ODR check for declarations in the global module; fragment. So in order to get better user experience, save the time checking ODR and keep consistent; behavior with MSVC, we disabled the ODR check for the declarations in the global module; fragment by default. Users who want more strict check can still use the; ``-Xclang -fno-skip-odr-check-in-gmf`` flag to get the ODR check enabled. It is also; encouraged to report issues if users find false positive ODR violations or false negative ODR; violations with the flag enabled. ABI Impacts; -----------. The declarations in a module unit which are not in the global module fragment have new linkage names. For example,. .. code-block:: c++. export module M;; namespace NS {; export int foo();; }. The linkage name of ``NS::foo()`` would be ``_ZN2NSW1M3fooEv``.; This couldn't be demangled by previous versions of the debugger or demangler.; As of LLVM 15.x, users can utilize ``llvm-cxxfilt`` to demangle this:. .. code-block:: console. $ llvm-cxxfilt _ZN2NSW",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:17866,Usability,user experience,user experience,17866,"consistency; ^^^^^^^^^^^^^^^^^^^^^^^. The C++ language defines that same declarations in different translation units should have; the same definition, as known as ODR (One Definition Rule). Prior to modules, the translation; units don't dependent on each other and the compiler itself can't perform a strong; ODR violation check. With the introduction of modules, now the compiler have; the chance to perform ODR violations with language semantics across translation units. However, in the practice, we found the existing ODR checking mechanism is not stable; enough. Many people suffers from the false positive ODR violation diagnostics, AKA,; the compiler are complaining two identical declarations have different definitions; incorrectly. Also the true positive ODR violations are rarely reported.; Also we learned that MSVC don't perform ODR check for declarations in the global module; fragment. So in order to get better user experience, save the time checking ODR and keep consistent; behavior with MSVC, we disabled the ODR check for the declarations in the global module; fragment by default. Users who want more strict check can still use the; ``-Xclang -fno-skip-odr-check-in-gmf`` flag to get the ODR check enabled. It is also; encouraged to report issues if users find false positive ODR violations or false negative ODR; violations with the flag enabled. ABI Impacts; -----------. The declarations in a module unit which are not in the global module fragment have new linkage names. For example,. .. code-block:: c++. export module M;; namespace NS {; export int foo();; }. The linkage name of ``NS::foo()`` would be ``_ZN2NSW1M3fooEv``.; This couldn't be demangled by previous versions of the debugger or demangler.; As of LLVM 15.x, users can utilize ``llvm-cxxfilt`` to demangle this:. .. code-block:: console. $ llvm-cxxfilt _ZN2NSW1M3fooEv. The result would be ``NS::foo@M()``, which reads as ``NS::foo()`` in module ``M``. The ABI implies that we can't declare something in a modul",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:24128,Usability,simpl,simple,24128,"he ``preferred_name`` attribute, if any.; This implies that the ``preferred_name`` wouldn't show in debugger or dumping. This is tracked in: https://github.com/llvm/llvm-project/issues/56490. Don't emit macros about module declaration; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. This is covered by P1857R3. We mention it again here since users may abuse it before we implement it. Someone may want to write code which could be compiled both by modules or non-modules.; A direct idea would be use macros like:. .. code-block:: c++. MODULE; IMPORT header_name; EXPORT_MODULE MODULE_NAME;; IMPORT header_name; EXPORT ... So this file could be triggered like a module unit or a non-module unit depending on the definition; of some macros.; However, this kind of usage is forbidden by P1857R3 but we haven't implemented P1857R3 yet.; This means that is possible to write illegal modules code now, and obviously this will stop working; once P1857R3 is implemented.; A simple suggestion would be ""Don't play macro tricks with module declarations"". This is tracked in: https://github.com/llvm/llvm-project/issues/56917. In consistent filename suffix requirement for importable module units; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Currently, clang requires the file name of an ``importable module unit`` should end with ``.cppm``; (or ``.ccm``, ``.cxxm``, ``.c++m``). However, the behavior is inconsistent with other compilers. This is tracked in: https://github.com/llvm/llvm-project/issues/57416. clang-cl is not compatible with the standard C++ modules; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. Now we can't use the `/clang:-fmodule-file` or `/clang:-fprebuilt-module-path` to specify; the BMI within ``clang-cl.exe``. This is tracked in: https://github.com/llvm/llvm-project/issues/64118. false positive ODR violation diagnostic due to using inconsistent qualified but the same type; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:31389,Usability,simpl,simpler,31389,"<< ""Hello.\n"";; }. with the following one:. .. code-block:: c++. module;; #include <iostream>; export module M;; export void Hello() {; std::cout << ""Hello.\n"";; }. .. code-block:: console. $ clang++ -std=c++20 -xc++-system-header --precompile iostream -o iostream.pcm; $ clang++ -std=c++20 -fmodule-file=iostream.pcm --precompile M.cppm -o M.cpp. In the latter example, the Clang could find the BMI for the ``<iostream>``; so it would try to replace the ``#include <iostream>`` to ``import <iostream>;`` automatically. Relationships between Clang modules; -----------------------------------. Header units have pretty similar semantics with Clang modules.; The semantics of both of them are like headers. In fact, we could even ""mimic"" the sytle of header units by Clang modules:. .. code-block:: c++. module ""iostream"" {; export *; header ""/path/to/libstdcxx/iostream""; }. .. code-block:: console. $ clang++ -std=c++20 -fimplicit-modules -fmodule-map-file=.modulemap main.cpp. It would be simpler if we are using libcxx:. .. code-block:: console. $ clang++ -std=c++20 main.cpp -fimplicit-modules -fimplicit-module-maps. Since there is already one; `module map <https://github.com/llvm/llvm-project/blob/main/libcxx/include/module.modulemap.in>`_; in the source of libcxx. Then immediately leads to the question: why don't we implement header units through Clang header modules?. The main reason for this is that Clang modules have more semantics like hierarchy or; wrapping multiple headers together as a big module.; However, these things are not part of Standard C++ Header units,; and we want to avoid the impression that these additional semantics get interpreted as Standard C++ behavior. Another reason is that there are proposals to introduce module mappers to the C++ standard; (for example, https://wg21.link/p1184r2).; If we decide to reuse Clang's modulemap, we may get in trouble once we need to introduce another module mapper. So the final answer for why we don't reuse the interface o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:36952,Usability,simpl,simply,36952,""": true,; ""logical-name"": ""M:interface_part"",; ""source-path"": ""interface_part.cppm""; }; ]; }; ],; ""version"": 1; }. See the P1689 paper for the meaning of the fields. And if the user want a finer-grained control for any reason, e.g., to scan the generated source files,; the user can choose to get the dependency information per file. For example:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o. And we'll get:. .. code-block:: text. {; ""revision"": 0,; ""rules"": [; {; ""primary-output"": ""impl_part.o"",; ""provides"": [; {; ""is-interface"": false,; ""logical-name"": ""M:impl_part"",; ""source-path"": ""impl_part.cppm""; }; ],; ""requires"": [; {; ""logical-name"": ""M:interface_part""; }; ]; }; ],; ""version"": 1; }. In this way, we can pass the single command line options after the ``--``.; Then clang-scan-deps will extract the necessary information from the options.; Note that we need to specify the path to the compiler executable instead of saying; ``clang++`` simply. The users may want the scanner to get the transitional dependency information for headers.; Otherwise, the users have to scan twice for the project, once for headers and once for modules.; To address the requirement, clang-scan-deps will recognize the specified preprocessor options; in the given command line and generate the corresponding dependency information. For example,. .. code-block:: console. $ clang-scan-deps -format=p1689 -- ../bin/clang++ -std=c++20 impl_part.cppm -c -o impl_part.o -MD -MT impl_part.ddi -MF impl_part.dep; $ cat impl_part.dep. We will get:. .. code-block:: text. impl_part.ddi: \; /usr/include/bits/wchar.h /usr/include/bits/types/wint_t.h \; /usr/include/bits/types/mbstate_t.h \; /usr/include/bits/types/__mbstate_t.h /usr/include/bits/types/__FILE.h \; /usr/include/bits/types/FILE.h /usr/include/bits/types/locale_t.h \; /usr/include/bits/types/__locale_t.h \; ... When clang-scan-deps detects ``-MF`` option, ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst:40035,Usability,simpl,simpler,40035,"or build systems that invokes the clang-scan-deps scanner per file, repeatedly; calculating the resource directory may be inefficient. In such cases, the build; system can cache the resource directory by itself and pass ``-resource-dir <resource-dir>``; explicitly in the command line options:. .. code-block:: console. $ clang-scan-deps -format=p1689 -- <path-to-compiler-executable>/clang++ -std=c++20 -resource-dir <resource-dir> mod.cppm -c -o mod.o. Possible Questions; ==================. How modules speed up compilation; --------------------------------. A classic theory for the reason why modules speed up the compilation is:; if there are ``n`` headers and ``m`` source files and each header is included by each source file,; then the complexity of the compilation is ``O(n*m)``;; But if there are ``n`` module interfaces and ``m`` source files, the complexity of the compilation is; ``O(n+m)``. So, using modules would be a big win when scaling.; In a simpler word, we could get rid of many redundant compilations by using modules. Roughly, this theory is correct. But the problem is that it is too rough.; The behavior depends on the optimization level, as we will illustrate below. First is ``O0``. The compilation process is described in the following graph. .. code-block:: none. ├-------------frontend----------┼-------------middle end----------------┼----backend----┤; │ │ │ │; └---parsing----sema----codegen--┴----- transformations ---- codegen ----┴---- codegen --┘. ┌---------------------------------------------------------------------------------------┐; | │; | source file │; | │; └---------------------------------------------------------------------------------------┘. ┌--------┐; │ │; │imported│; │ │; │ code │; │ │; └--------┘. Here we can see that the source file (could be a non-module unit or a module unit) would get processed by the; whole pipeline.; But the imported code would only get involved in semantic analysis, which is mainly about name lookup,; overload re",MatchSource.DOCS,interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/StandardCPlusPlusModules.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SYCLSupport.rst:2539,Energy Efficiency,allocate,allocates,2539,"detailed in; `OpenCL C v3.0 6.7.8 <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_C.html#addr-spaces-inference>`_. The default address space is ""generic-memory"", which is a virtual address space; that overlaps the global, local, and private address spaces. SYCL mode enables; following conversions:. - explicit conversions to/from the default address space from/to the address; space-attributed type; - implicit conversions from the address space-attributed type to the default; address space; - explicit conversions to/from the global address space from/to the; ``__attribute__((opencl_global_device))`` or; ``__attribute__((opencl_global_host))`` address space-attributed type; - implicit conversions from the ``__attribute__((opencl_global_device))`` or; ``__attribute__((opencl_global_host))`` address space-attributed type to the; global address space. All named address spaces are disjoint and sub-sets of default address space. The SPIR target allocates SYCL namespace scope variables in the global address; space. Pointers to default address space should get lowered into a pointer to a generic; address space (or flat to reuse more general terminology). But depending on the; allocation context, the default address space of a non-pointer type is assigned; to a specific address space. This is described in; `common address space deduction rules <https://www.khronos.org/registry/SYCL/specs/sycl-2020/html/sycl-2020.html#subsec:commonAddressSpace>`_; section. This is also in line with the behaviour of CUDA (`small example; <https://godbolt.org/z/veqTfo9PK>`_). ``multi_ptr`` class implementation example:. .. code-block:: C++. // check that SYCL mode is ON and we can use non-standard decorations; #if defined(__SYCL_DEVICE_ONLY__); // GPU/accelerator implementation; template <typename T, address_space AS> class multi_ptr {; // DecoratedType applies corresponding address space attribute to the type T; // DecoratedType<T, global_space>::type == ""__attribute__((ope",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SYCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SYCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SYCLSupport.rst:613,Integrability,wrap,wrapper,613,"=============================================; SYCL Compiler and Runtime architecture design; =============================================. .. contents::; :local:. Introduction; ============. This document describes the architecture of the SYCL compiler and runtime; library. More details are provided in; `external document <https://github.com/intel/llvm/blob/sycl/sycl/doc/design/CompilerAndRuntimeDesign.md>`_\ ,; which are going to be added to clang documentation in the future. Address space handling; ======================. The SYCL specification represents pointers to disjoint memory regions using C++; wrapper classes on an accelerator to enable compilation with a standard C++; toolchain and a SYCL compiler toolchain. Section 3.8.2 of SYCL 2020; specification defines; `memory model <https://www.khronos.org/registry/SYCL/specs/sycl-2020/html/sycl-2020.html#_sycl_device_memory_model>`_\ ,; section 4.7.7 - `address space classes <https://www.khronos.org/registry/SYCL/specs/sycl-2020/html/sycl-2020.html#_address_space_classes>`_; and section 5.9 covers `address space deduction <https://www.khronos.org/registry/SYCL/specs/sycl-2020/html/sycl-2020.html#_address_space_deduction>`_.; The SYCL specification allows two modes of address space deduction: ""generic as; default address space"" (see section 5.9.3) and ""inferred address space"" (see; section 5.9.4). Current implementation supports only ""generic as default address; space"" mode. SYCL borrows its memory model from OpenCL however SYCL doesn't perform; the address space qualifier inference as detailed in; `OpenCL C v3.0 6.7.8 <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_C.html#addr-spaces-inference>`_. The default address space is ""generic-memory"", which is a virtual address space; that overlaps the global, local, and private address spaces. SYCL mode enables; following conversions:. - explicit conversions to/from the default address space from/to the address; space-attributed type; - implicit c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SYCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SYCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SYCLSupport.rst:2755,Integrability,depend,depending,2755," and private address spaces. SYCL mode enables; following conversions:. - explicit conversions to/from the default address space from/to the address; space-attributed type; - implicit conversions from the address space-attributed type to the default; address space; - explicit conversions to/from the global address space from/to the; ``__attribute__((opencl_global_device))`` or; ``__attribute__((opencl_global_host))`` address space-attributed type; - implicit conversions from the ``__attribute__((opencl_global_device))`` or; ``__attribute__((opencl_global_host))`` address space-attributed type to the; global address space. All named address spaces are disjoint and sub-sets of default address space. The SPIR target allocates SYCL namespace scope variables in the global address; space. Pointers to default address space should get lowered into a pointer to a generic; address space (or flat to reuse more general terminology). But depending on the; allocation context, the default address space of a non-pointer type is assigned; to a specific address space. This is described in; `common address space deduction rules <https://www.khronos.org/registry/SYCL/specs/sycl-2020/html/sycl-2020.html#subsec:commonAddressSpace>`_; section. This is also in line with the behaviour of CUDA (`small example; <https://godbolt.org/z/veqTfo9PK>`_). ``multi_ptr`` class implementation example:. .. code-block:: C++. // check that SYCL mode is ON and we can use non-standard decorations; #if defined(__SYCL_DEVICE_ONLY__); // GPU/accelerator implementation; template <typename T, address_space AS> class multi_ptr {; // DecoratedType applies corresponding address space attribute to the type T; // DecoratedType<T, global_space>::type == ""__attribute__((opencl_global)) T""; // See sycl/include/CL/sycl/access/access.hpp for more details; using pointer_t = typename DecoratedType<T, AS>::type *;. pointer_t m_Pointer;; public:; pointer_t get() { return m_Pointer; }; T& operator* () { return *reinterpret_cas",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SYCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SYCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SYCLSupport.rst:2570,Modifiability,variab,variables,2570,"detailed in; `OpenCL C v3.0 6.7.8 <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_C.html#addr-spaces-inference>`_. The default address space is ""generic-memory"", which is a virtual address space; that overlaps the global, local, and private address spaces. SYCL mode enables; following conversions:. - explicit conversions to/from the default address space from/to the address; space-attributed type; - implicit conversions from the address space-attributed type to the default; address space; - explicit conversions to/from the global address space from/to the; ``__attribute__((opencl_global_device))`` or; ``__attribute__((opencl_global_host))`` address space-attributed type; - implicit conversions from the ``__attribute__((opencl_global_device))`` or; ``__attribute__((opencl_global_host))`` address space-attributed type to the; global address space. All named address spaces are disjoint and sub-sets of default address space. The SPIR target allocates SYCL namespace scope variables in the global address; space. Pointers to default address space should get lowered into a pointer to a generic; address space (or flat to reuse more general terminology). But depending on the; allocation context, the default address space of a non-pointer type is assigned; to a specific address space. This is described in; `common address space deduction rules <https://www.khronos.org/registry/SYCL/specs/sycl-2020/html/sycl-2020.html#subsec:commonAddressSpace>`_; section. This is also in line with the behaviour of CUDA (`small example; <https://godbolt.org/z/veqTfo9PK>`_). ``multi_ptr`` class implementation example:. .. code-block:: C++. // check that SYCL mode is ON and we can use non-standard decorations; #if defined(__SYCL_DEVICE_ONLY__); // GPU/accelerator implementation; template <typename T, address_space AS> class multi_ptr {; // DecoratedType applies corresponding address space attribute to the type T; // DecoratedType<T, global_space>::type == ""__attribute__((ope",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SYCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SYCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SYCLSupport.rst:1515,Performance,perform,perform,1515,"=========. The SYCL specification represents pointers to disjoint memory regions using C++; wrapper classes on an accelerator to enable compilation with a standard C++; toolchain and a SYCL compiler toolchain. Section 3.8.2 of SYCL 2020; specification defines; `memory model <https://www.khronos.org/registry/SYCL/specs/sycl-2020/html/sycl-2020.html#_sycl_device_memory_model>`_\ ,; section 4.7.7 - `address space classes <https://www.khronos.org/registry/SYCL/specs/sycl-2020/html/sycl-2020.html#_address_space_classes>`_; and section 5.9 covers `address space deduction <https://www.khronos.org/registry/SYCL/specs/sycl-2020/html/sycl-2020.html#_address_space_deduction>`_.; The SYCL specification allows two modes of address space deduction: ""generic as; default address space"" (see section 5.9.3) and ""inferred address space"" (see; section 5.9.4). Current implementation supports only ""generic as default address; space"" mode. SYCL borrows its memory model from OpenCL however SYCL doesn't perform; the address space qualifier inference as detailed in; `OpenCL C v3.0 6.7.8 <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_C.html#addr-spaces-inference>`_. The default address space is ""generic-memory"", which is a virtual address space; that overlaps the global, local, and private address spaces. SYCL mode enables; following conversions:. - explicit conversions to/from the default address space from/to the address; space-attributed type; - implicit conversions from the address space-attributed type to the default; address space; - explicit conversions to/from the global address space from/to the; ``__attribute__((opencl_global_device))`` or; ``__attribute__((opencl_global_host))`` address space-attributed type; - implicit conversions from the ``__attribute__((opencl_global_device))`` or; ``__attribute__((opencl_global_host))`` address space-attributed type to the; global address space. All named address spaces are disjoint and sub-sets of default address space",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SYCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SYCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SYCLSupport.rst:3611,Security,access,access,3611,"lobal address space. All named address spaces are disjoint and sub-sets of default address space. The SPIR target allocates SYCL namespace scope variables in the global address; space. Pointers to default address space should get lowered into a pointer to a generic; address space (or flat to reuse more general terminology). But depending on the; allocation context, the default address space of a non-pointer type is assigned; to a specific address space. This is described in; `common address space deduction rules <https://www.khronos.org/registry/SYCL/specs/sycl-2020/html/sycl-2020.html#subsec:commonAddressSpace>`_; section. This is also in line with the behaviour of CUDA (`small example; <https://godbolt.org/z/veqTfo9PK>`_). ``multi_ptr`` class implementation example:. .. code-block:: C++. // check that SYCL mode is ON and we can use non-standard decorations; #if defined(__SYCL_DEVICE_ONLY__); // GPU/accelerator implementation; template <typename T, address_space AS> class multi_ptr {; // DecoratedType applies corresponding address space attribute to the type T; // DecoratedType<T, global_space>::type == ""__attribute__((opencl_global)) T""; // See sycl/include/CL/sycl/access/access.hpp for more details; using pointer_t = typename DecoratedType<T, AS>::type *;. pointer_t m_Pointer;; public:; pointer_t get() { return m_Pointer; }; T& operator* () { return *reinterpret_cast<T*>(m_Pointer); }; }; #else; // CPU/host implementation; template <typename T, address_space AS> class multi_ptr {; T *m_Pointer; // regular undecorated pointer; public:; T *get() { return m_Pointer; }; T& operator* () { return *m_Pointer; }; }; #endif. Depending on the compiler mode, ``multi_ptr`` will either decorate its internal; data with the address space attribute or not. To utilize clang's existing functionality, we reuse the following OpenCL address; space attributes for pointers:. .. list-table::; :header-rows: 1. * - Address space attribute; - SYCL address_space enumeration; * - ``__attribu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SYCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SYCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SYCLSupport.rst:3618,Security,access,access,3618,"lobal address space. All named address spaces are disjoint and sub-sets of default address space. The SPIR target allocates SYCL namespace scope variables in the global address; space. Pointers to default address space should get lowered into a pointer to a generic; address space (or flat to reuse more general terminology). But depending on the; allocation context, the default address space of a non-pointer type is assigned; to a specific address space. This is described in; `common address space deduction rules <https://www.khronos.org/registry/SYCL/specs/sycl-2020/html/sycl-2020.html#subsec:commonAddressSpace>`_; section. This is also in line with the behaviour of CUDA (`small example; <https://godbolt.org/z/veqTfo9PK>`_). ``multi_ptr`` class implementation example:. .. code-block:: C++. // check that SYCL mode is ON and we can use non-standard decorations; #if defined(__SYCL_DEVICE_ONLY__); // GPU/accelerator implementation; template <typename T, address_space AS> class multi_ptr {; // DecoratedType applies corresponding address space attribute to the type T; // DecoratedType<T, global_space>::type == ""__attribute__((opencl_global)) T""; // See sycl/include/CL/sycl/access/access.hpp for more details; using pointer_t = typename DecoratedType<T, AS>::type *;. pointer_t m_Pointer;; public:; pointer_t get() { return m_Pointer; }; T& operator* () { return *reinterpret_cast<T*>(m_Pointer); }; }; #else; // CPU/host implementation; template <typename T, address_space AS> class multi_ptr {; T *m_Pointer; // regular undecorated pointer; public:; T *get() { return m_Pointer; }; T& operator* () { return *m_Pointer; }; }; #endif. Depending on the compiler mode, ``multi_ptr`` will either decorate its internal; data with the address space attribute or not. To utilize clang's existing functionality, we reuse the following OpenCL address; space attributes for pointers:. .. list-table::; :header-rows: 1. * - Address space attribute; - SYCL address_space enumeration; * - ``__attribu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/SYCLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/SYCLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:3113,Availability,error,error,3113,":. - **gold (via the gold-plugin)**:; Similar to monolithic LTO, this requires using; a `gold linker configured with plugins enabled; <https://llvm.org/docs/GoldPlugin.html>`_.; - **ld64**:; Starting with `Xcode 8 <https://developer.apple.com/xcode/>`_.; - **lld**:; Starting with r284050 for ELF, r298942 for COFF. Usage; =====. Basic; -----. To utilize ThinLTO, simply add the -flto=thin option to compile and link. E.g. .. code-block:: console. % clang -flto=thin -O2 file1.c file2.c -c; % clang -flto=thin -O2 file1.o file2.o -o a.out. When using lld-link, the -flto option need only be added to the compile step:. .. code-block:: console. % clang-cl -flto=thin -O2 -c file1.c file2.c; % lld-link /out:a.exe file1.obj file2.obj. As mentioned earlier, by default the linkers will launch the ThinLTO backend; threads in parallel, passing the resulting native object files back to the; linker for the final native link. As such, the usage model is the same as; non-LTO. With gold, if you see an error during the link of the form:. .. code-block:: console. /usr/bin/ld: error: /path/to/clang/bin/../lib/LLVMgold.so: could not load plugin library: /path/to/clang/bin/../lib/LLVMgold.so: cannot open shared object file: No such file or directory. Then either gold was not configured with plugins enabled, or clang; was not built with ``-DLLVM_BINUTILS_INCDIR`` set properly. See; the instructions for the; `LLVM gold plugin <https://llvm.org/docs/GoldPlugin.html#how-to-build-it>`_. Controlling Backend Parallelism; -------------------------------; .. _parallelism:. By default, the ThinLTO link step will launch as many; threads in parallel as there are cores. If the number of; cores can't be computed for the architecture, then it will launch; ``std::thread::hardware_concurrency`` number of threads in parallel.; For machines with hyper-threading, this is the total number of; virtual cores. For some applications and machine configurations this; may be too aggressive, in which case the amount of p",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:3187,Availability,error,error,3187,"es using; a `gold linker configured with plugins enabled; <https://llvm.org/docs/GoldPlugin.html>`_.; - **ld64**:; Starting with `Xcode 8 <https://developer.apple.com/xcode/>`_.; - **lld**:; Starting with r284050 for ELF, r298942 for COFF. Usage; =====. Basic; -----. To utilize ThinLTO, simply add the -flto=thin option to compile and link. E.g. .. code-block:: console. % clang -flto=thin -O2 file1.c file2.c -c; % clang -flto=thin -O2 file1.o file2.o -o a.out. When using lld-link, the -flto option need only be added to the compile step:. .. code-block:: console. % clang-cl -flto=thin -O2 -c file1.c file2.c; % lld-link /out:a.exe file1.obj file2.obj. As mentioned earlier, by default the linkers will launch the ThinLTO backend; threads in parallel, passing the resulting native object files back to the; linker for the final native link. As such, the usage model is the same as; non-LTO. With gold, if you see an error during the link of the form:. .. code-block:: console. /usr/bin/ld: error: /path/to/clang/bin/../lib/LLVMgold.so: could not load plugin library: /path/to/clang/bin/../lib/LLVMgold.so: cannot open shared object file: No such file or directory. Then either gold was not configured with plugins enabled, or clang; was not built with ``-DLLVM_BINUTILS_INCDIR`` set properly. See; the instructions for the; `LLVM gold plugin <https://llvm.org/docs/GoldPlugin.html#how-to-build-it>`_. Controlling Backend Parallelism; -------------------------------; .. _parallelism:. By default, the ThinLTO link step will launch as many; threads in parallel as there are cores. If the number of; cores can't be computed for the architecture, then it will launch; ``std::thread::hardware_concurrency`` number of threads in parallel.; For machines with hyper-threading, this is the total number of; virtual cores. For some applications and machine configurations this; may be too aggressive, in which case the amount of parallelism can; be reduced to ``N`` via:. - gold:; ``-Wl,-plugin-opt,jobs=N`",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:5790,Availability,avail,available,5790,"o/cache``; - ld64 (supported since clang 3.9 and Xcode 8) and Mach-O ld64.lld (as of LLVM; 15.0):; ``-Wl,-cache_path_lto,/path/to/cache``; - ELF ld.lld (as of LLVM 5.0):; ``-Wl,--thinlto-cache-dir=/path/to/cache``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocache:/path/to/cache``. Cache Pruning; -------------. To help keep the size of the cache under control, ThinLTO supports cache; pruning. Cache pruning is supported with gold, ld64, and lld, but currently only; gold and lld allow you to control the policy with a policy string. The cache; policy must be specified with a linker option. - gold (as of LLVM 6.0):; ``-Wl,-plugin-opt,cache-policy=POLICY``; - ELF ld.lld (as of LLVM 5.0), Mach-O ld64.lld (as of LLVM 15.0):; ``-Wl,--thinlto-cache-policy=POLICY``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocachepolicy:POLICY``. A policy string is a series of key-value pairs separated by ``:`` characters.; Possible key-value pairs are:. - ``cache_size=X%``: The maximum size for the cache directory is ``X`` percent; of the available space on the disk. Set to 100 to indicate no limit,; 50 to indicate that the cache size will not be left over half the available; disk space. A value over 100 is invalid. A value of 0 disables the percentage; size-based pruning. The default is 75%. - ``cache_size_bytes=X``, ``cache_size_bytes=Xk``, ``cache_size_bytes=Xm``,; ``cache_size_bytes=Xg``:; Sets the maximum size for the cache directory to ``X`` bytes (or KB, MB,; GB respectively). A value over the amount of available space on the disk; will be reduced to the amount of available space. A value of 0 disables; the byte size-based pruning. The default is no byte size-based pruning. Note that ThinLTO will apply both size-based pruning policies simultaneously,; and changing one does not affect the other. For example, a policy of; ``cache_size_bytes=1g`` on its own will cause both the 1GB and default 75%; policies to be applied unless the default ``cache_size`` is overridden. - ``cache_size_fil",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:5919,Availability,avail,available,5919,"o,/path/to/cache``; - ELF ld.lld (as of LLVM 5.0):; ``-Wl,--thinlto-cache-dir=/path/to/cache``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocache:/path/to/cache``. Cache Pruning; -------------. To help keep the size of the cache under control, ThinLTO supports cache; pruning. Cache pruning is supported with gold, ld64, and lld, but currently only; gold and lld allow you to control the policy with a policy string. The cache; policy must be specified with a linker option. - gold (as of LLVM 6.0):; ``-Wl,-plugin-opt,cache-policy=POLICY``; - ELF ld.lld (as of LLVM 5.0), Mach-O ld64.lld (as of LLVM 15.0):; ``-Wl,--thinlto-cache-policy=POLICY``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocachepolicy:POLICY``. A policy string is a series of key-value pairs separated by ``:`` characters.; Possible key-value pairs are:. - ``cache_size=X%``: The maximum size for the cache directory is ``X`` percent; of the available space on the disk. Set to 100 to indicate no limit,; 50 to indicate that the cache size will not be left over half the available; disk space. A value over 100 is invalid. A value of 0 disables the percentage; size-based pruning. The default is 75%. - ``cache_size_bytes=X``, ``cache_size_bytes=Xk``, ``cache_size_bytes=Xm``,; ``cache_size_bytes=Xg``:; Sets the maximum size for the cache directory to ``X`` bytes (or KB, MB,; GB respectively). A value over the amount of available space on the disk; will be reduced to the amount of available space. A value of 0 disables; the byte size-based pruning. The default is no byte size-based pruning. Note that ThinLTO will apply both size-based pruning policies simultaneously,; and changing one does not affect the other. For example, a policy of; ``cache_size_bytes=1g`` on its own will cause both the 1GB and default 75%; policies to be applied unless the default ``cache_size`` is overridden. - ``cache_size_files=X``:; Set the maximum number of files in the cache directory. Set to 0 to indicate; no limit. The default is 1000000 ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:6271,Availability,avail,available,6271,"The cache; policy must be specified with a linker option. - gold (as of LLVM 6.0):; ``-Wl,-plugin-opt,cache-policy=POLICY``; - ELF ld.lld (as of LLVM 5.0), Mach-O ld64.lld (as of LLVM 15.0):; ``-Wl,--thinlto-cache-policy=POLICY``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocachepolicy:POLICY``. A policy string is a series of key-value pairs separated by ``:`` characters.; Possible key-value pairs are:. - ``cache_size=X%``: The maximum size for the cache directory is ``X`` percent; of the available space on the disk. Set to 100 to indicate no limit,; 50 to indicate that the cache size will not be left over half the available; disk space. A value over 100 is invalid. A value of 0 disables the percentage; size-based pruning. The default is 75%. - ``cache_size_bytes=X``, ``cache_size_bytes=Xk``, ``cache_size_bytes=Xm``,; ``cache_size_bytes=Xg``:; Sets the maximum size for the cache directory to ``X`` bytes (or KB, MB,; GB respectively). A value over the amount of available space on the disk; will be reduced to the amount of available space. A value of 0 disables; the byte size-based pruning. The default is no byte size-based pruning. Note that ThinLTO will apply both size-based pruning policies simultaneously,; and changing one does not affect the other. For example, a policy of; ``cache_size_bytes=1g`` on its own will cause both the 1GB and default 75%; policies to be applied unless the default ``cache_size`` is overridden. - ``cache_size_files=X``:; Set the maximum number of files in the cache directory. Set to 0 to indicate; no limit. The default is 1000000 files. - ``prune_after=Xs``, ``prune_after=Xm``, ``prune_after=Xh``: Sets the; expiration time for cache files to ``X`` seconds (or minutes, hours; respectively). When a file hasn't been accessed for ``prune_after`` seconds,; it is removed from the cache. A value of 0 disables the expiration-based; pruning. The default is 1 week. - ``prune_interval=Xs``, ``prune_interval=Xm``, ``prune_interval=Xh``:; Sets the pru",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:6333,Availability,avail,available,6333,"The cache; policy must be specified with a linker option. - gold (as of LLVM 6.0):; ``-Wl,-plugin-opt,cache-policy=POLICY``; - ELF ld.lld (as of LLVM 5.0), Mach-O ld64.lld (as of LLVM 15.0):; ``-Wl,--thinlto-cache-policy=POLICY``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocachepolicy:POLICY``. A policy string is a series of key-value pairs separated by ``:`` characters.; Possible key-value pairs are:. - ``cache_size=X%``: The maximum size for the cache directory is ``X`` percent; of the available space on the disk. Set to 100 to indicate no limit,; 50 to indicate that the cache size will not be left over half the available; disk space. A value over 100 is invalid. A value of 0 disables the percentage; size-based pruning. The default is 75%. - ``cache_size_bytes=X``, ``cache_size_bytes=Xk``, ``cache_size_bytes=Xm``,; ``cache_size_bytes=Xg``:; Sets the maximum size for the cache directory to ``X`` bytes (or KB, MB,; GB respectively). A value over the amount of available space on the disk; will be reduced to the amount of available space. A value of 0 disables; the byte size-based pruning. The default is no byte size-based pruning. Note that ThinLTO will apply both size-based pruning policies simultaneously,; and changing one does not affect the other. For example, a policy of; ``cache_size_bytes=1g`` on its own will cause both the 1GB and default 75%; policies to be applied unless the default ``cache_size`` is overridden. - ``cache_size_files=X``:; Set the maximum number of files in the cache directory. Set to 0 to indicate; no limit. The default is 1000000 files. - ``prune_after=Xs``, ``prune_after=Xm``, ``prune_after=Xh``: Sets the; expiration time for cache files to ``X`` seconds (or minutes, hours; respectively). When a file hasn't been accessed for ``prune_after`` seconds,; it is removed from the cache. A value of 0 disables the expiration-based; pruning. The default is 1 week. - ``prune_interval=Xs``, ``prune_interval=Xm``, ``prune_interval=Xh``:; Sets the pru",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:1729,Deployability,release,release,1729,"tion; locations for later cross-module function importing. Fast and efficient; whole-program analysis is then performed on the combined summary index. However, all transformations, including function importing, occur; later when the modules are optimized in fully parallel backends.; By default, linkers_ that support ThinLTO are set up to launch; the ThinLTO backends in threads. So the usage model is not affected; as the distinction between the fast serial thin link step and the backends; is transparent to the user. For more information on the ThinLTO design and current performance,; see the LLVM blog post `ThinLTO: Scalable and Incremental LTO; <http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html>`_.; While tuning is still in progress, results in the blog post show that; ThinLTO already performs well compared to LTO, in many cases matching; the performance improvement. Current Status; ==============. Clang/LLVM; ----------; .. _compiler:. The 3.9 release of clang includes ThinLTO support. However, ThinLTO; is under active development, and new features, improvements and bugfixes; are being added for the next release. For the latest ThinLTO support,; `build a recent version of clang and LLVM; <https://llvm.org/docs/CMake.html>`_. Linkers; -------; .. _linkers:; .. _linker:. ThinLTO is currently supported for the following linkers:. - **gold (via the gold-plugin)**:; Similar to monolithic LTO, this requires using; a `gold linker configured with plugins enabled; <https://llvm.org/docs/GoldPlugin.html>`_.; - **ld64**:; Starting with `Xcode 8 <https://developer.apple.com/xcode/>`_.; - **lld**:; Starting with r284050 for ELF, r298942 for COFF. Usage; =====. Basic; -----. To utilize ThinLTO, simply add the -flto=thin option to compile and link. E.g. .. code-block:: console. % clang -flto=thin -O2 file1.c file2.c -c; % clang -flto=thin -O2 file1.o file2.o -o a.out. When using lld-link, the -flto option need only be added to the compile step:. .. code-block",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:1893,Deployability,release,release,1893,"ogram analysis is then performed on the combined summary index. However, all transformations, including function importing, occur; later when the modules are optimized in fully parallel backends.; By default, linkers_ that support ThinLTO are set up to launch; the ThinLTO backends in threads. So the usage model is not affected; as the distinction between the fast serial thin link step and the backends; is transparent to the user. For more information on the ThinLTO design and current performance,; see the LLVM blog post `ThinLTO: Scalable and Incremental LTO; <http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html>`_.; While tuning is still in progress, results in the blog post show that; ThinLTO already performs well compared to LTO, in many cases matching; the performance improvement. Current Status; ==============. Clang/LLVM; ----------; .. _compiler:. The 3.9 release of clang includes ThinLTO support. However, ThinLTO; is under active development, and new features, improvements and bugfixes; are being added for the next release. For the latest ThinLTO support,; `build a recent version of clang and LLVM; <https://llvm.org/docs/CMake.html>`_. Linkers; -------; .. _linkers:; .. _linker:. ThinLTO is currently supported for the following linkers:. - **gold (via the gold-plugin)**:; Similar to monolithic LTO, this requires using; a `gold linker configured with plugins enabled; <https://llvm.org/docs/GoldPlugin.html>`_.; - **ld64**:; Starting with `Xcode 8 <https://developer.apple.com/xcode/>`_.; - **lld**:; Starting with r284050 for ELF, r298942 for COFF. Usage; =====. Basic; -----. To utilize ThinLTO, simply add the -flto=thin option to compile and link. E.g. .. code-block:: console. % clang -flto=thin -O2 file1.c file2.c -c; % clang -flto=thin -O2 file1.o file2.o -o a.out. When using lld-link, the -flto option need only be added to the compile step:. .. code-block:: console. % clang-cl -flto=thin -O2 -c file1.c file2.c; % lld-link /out:a.exe file1.o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:4045,Deployability,configurat,configurations,4045,"TO. With gold, if you see an error during the link of the form:. .. code-block:: console. /usr/bin/ld: error: /path/to/clang/bin/../lib/LLVMgold.so: could not load plugin library: /path/to/clang/bin/../lib/LLVMgold.so: cannot open shared object file: No such file or directory. Then either gold was not configured with plugins enabled, or clang; was not built with ``-DLLVM_BINUTILS_INCDIR`` set properly. See; the instructions for the; `LLVM gold plugin <https://llvm.org/docs/GoldPlugin.html#how-to-build-it>`_. Controlling Backend Parallelism; -------------------------------; .. _parallelism:. By default, the ThinLTO link step will launch as many; threads in parallel as there are cores. If the number of; cores can't be computed for the architecture, then it will launch; ``std::thread::hardware_concurrency`` number of threads in parallel.; For machines with hyper-threading, this is the total number of; virtual cores. For some applications and machine configurations this; may be too aggressive, in which case the amount of parallelism can; be reduced to ``N`` via:. - gold:; ``-Wl,-plugin-opt,jobs=N``; - ld64:; ``-Wl,-mllvm,-threads=N``; - ld.lld, ld64.lld:; ``-Wl,--thinlto-jobs=N``; - lld-link:; ``/opt:lldltojobs=N``. Other possible values for ``N`` are:. - 0:; Use one thread per physical core (default); - 1:; Use a single thread only (disable multi-threading); - all:; Use one thread per logical core (uses all hyper-threads). Incremental; -----------; .. _incremental:. ThinLTO supports fast incremental builds through the use of a cache,; which currently must be enabled through a linker option. - gold (as of LLVM 4.0):; ``-Wl,-plugin-opt,cache-dir=/path/to/cache``; - ld64 (supported since clang 3.9 and Xcode 8) and Mach-O ld64.lld (as of LLVM; 15.0):; ``-Wl,-cache_path_lto,/path/to/cache``; - ELF ld.lld (as of LLVM 5.0):; ``-Wl,--thinlto-cache-dir=/path/to/cache``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocache:/path/to/cache``. Cache Pruning; -------------. To help keep",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:817,Energy Efficiency,efficient,efficient,817,"=======; ThinLTO; =======. .. contents::; :local:. Introduction; ============. *ThinLTO* compilation is a new type of LTO that is both scalable and; incremental. *LTO* (Link Time Optimization) achieves better; runtime performance through whole-program analysis and cross-module; optimization. However, monolithic LTO implements this by merging all; input into a single module, which is not scalable; in time or memory, and also prevents fast incremental compiles. In ThinLTO mode, as with regular LTO, clang emits LLVM bitcode after the; compile phase. The ThinLTO bitcode is augmented with a compact summary; of the module. During the link step, only the summaries are read and; merged into a combined summary index, which includes an index of function; locations for later cross-module function importing. Fast and efficient; whole-program analysis is then performed on the combined summary index. However, all transformations, including function importing, occur; later when the modules are optimized in fully parallel backends.; By default, linkers_ that support ThinLTO are set up to launch; the ThinLTO backends in threads. So the usage model is not affected; as the distinction between the fast serial thin link step and the backends; is transparent to the user. For more information on the ThinLTO design and current performance,; see the LLVM blog post `ThinLTO: Scalable and Incremental LTO; <http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html>`_.; While tuning is still in progress, results in the blog post show that; ThinLTO already performs well compared to LTO, in many cases matching; the performance improvement. Current Status; ==============. Clang/LLVM; ----------; .. _compiler:. The 3.9 release of clang includes ThinLTO support. However, ThinLTO; is under active development, and new features, improvements and bugfixes; are being added for the next release. For the latest ThinLTO support,; `build a recent version of clang and LLVM; <https://llvm.org/docs/",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:4137,Energy Efficiency,reduce,reduced,4137,"TO. With gold, if you see an error during the link of the form:. .. code-block:: console. /usr/bin/ld: error: /path/to/clang/bin/../lib/LLVMgold.so: could not load plugin library: /path/to/clang/bin/../lib/LLVMgold.so: cannot open shared object file: No such file or directory. Then either gold was not configured with plugins enabled, or clang; was not built with ``-DLLVM_BINUTILS_INCDIR`` set properly. See; the instructions for the; `LLVM gold plugin <https://llvm.org/docs/GoldPlugin.html#how-to-build-it>`_. Controlling Backend Parallelism; -------------------------------; .. _parallelism:. By default, the ThinLTO link step will launch as many; threads in parallel as there are cores. If the number of; cores can't be computed for the architecture, then it will launch; ``std::thread::hardware_concurrency`` number of threads in parallel.; For machines with hyper-threading, this is the total number of; virtual cores. For some applications and machine configurations this; may be too aggressive, in which case the amount of parallelism can; be reduced to ``N`` via:. - gold:; ``-Wl,-plugin-opt,jobs=N``; - ld64:; ``-Wl,-mllvm,-threads=N``; - ld.lld, ld64.lld:; ``-Wl,--thinlto-jobs=N``; - lld-link:; ``/opt:lldltojobs=N``. Other possible values for ``N`` are:. - 0:; Use one thread per physical core (default); - 1:; Use a single thread only (disable multi-threading); - all:; Use one thread per logical core (uses all hyper-threads). Incremental; -----------; .. _incremental:. ThinLTO supports fast incremental builds through the use of a cache,; which currently must be enabled through a linker option. - gold (as of LLVM 4.0):; ``-Wl,-plugin-opt,cache-dir=/path/to/cache``; - ld64 (supported since clang 3.9 and Xcode 8) and Mach-O ld64.lld (as of LLVM; 15.0):; ``-Wl,-cache_path_lto,/path/to/cache``; - ELF ld.lld (as of LLVM 5.0):; ``-Wl,--thinlto-cache-dir=/path/to/cache``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocache:/path/to/cache``. Cache Pruning; -------------. To help keep",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:6308,Energy Efficiency,reduce,reduced,6308,"The cache; policy must be specified with a linker option. - gold (as of LLVM 6.0):; ``-Wl,-plugin-opt,cache-policy=POLICY``; - ELF ld.lld (as of LLVM 5.0), Mach-O ld64.lld (as of LLVM 15.0):; ``-Wl,--thinlto-cache-policy=POLICY``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocachepolicy:POLICY``. A policy string is a series of key-value pairs separated by ``:`` characters.; Possible key-value pairs are:. - ``cache_size=X%``: The maximum size for the cache directory is ``X`` percent; of the available space on the disk. Set to 100 to indicate no limit,; 50 to indicate that the cache size will not be left over half the available; disk space. A value over 100 is invalid. A value of 0 disables the percentage; size-based pruning. The default is 75%. - ``cache_size_bytes=X``, ``cache_size_bytes=Xk``, ``cache_size_bytes=Xm``,; ``cache_size_bytes=Xg``:; Sets the maximum size for the cache directory to ``X`` bytes (or KB, MB,; GB respectively). A value over the amount of available space on the disk; will be reduced to the amount of available space. A value of 0 disables; the byte size-based pruning. The default is no byte size-based pruning. Note that ThinLTO will apply both size-based pruning policies simultaneously,; and changing one does not affect the other. For example, a policy of; ``cache_size_bytes=1g`` on its own will cause both the 1GB and default 75%; policies to be applied unless the default ``cache_size`` is overridden. - ``cache_size_files=X``:; Set the maximum number of files in the cache directory. Set to 0 to indicate; no limit. The default is 1000000 files. - ``prune_after=Xs``, ``prune_after=Xm``, ``prune_after=Xh``: Sets the; expiration time for cache files to ``X`` seconds (or minutes, hours; respectively). When a file hasn't been accessed for ``prune_after`` seconds,; it is removed from the cache. A value of 0 disables the expiration-based; pruning. The default is 1 week. - ``prune_interval=Xs``, ``prune_interval=Xm``, ``prune_interval=Xh``:; Sets the pru",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:2143,Modifiability,plugin,plugin,2143," the fast serial thin link step and the backends; is transparent to the user. For more information on the ThinLTO design and current performance,; see the LLVM blog post `ThinLTO: Scalable and Incremental LTO; <http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html>`_.; While tuning is still in progress, results in the blog post show that; ThinLTO already performs well compared to LTO, in many cases matching; the performance improvement. Current Status; ==============. Clang/LLVM; ----------; .. _compiler:. The 3.9 release of clang includes ThinLTO support. However, ThinLTO; is under active development, and new features, improvements and bugfixes; are being added for the next release. For the latest ThinLTO support,; `build a recent version of clang and LLVM; <https://llvm.org/docs/CMake.html>`_. Linkers; -------; .. _linkers:; .. _linker:. ThinLTO is currently supported for the following linkers:. - **gold (via the gold-plugin)**:; Similar to monolithic LTO, this requires using; a `gold linker configured with plugins enabled; <https://llvm.org/docs/GoldPlugin.html>`_.; - **ld64**:; Starting with `Xcode 8 <https://developer.apple.com/xcode/>`_.; - **lld**:; Starting with r284050 for ELF, r298942 for COFF. Usage; =====. Basic; -----. To utilize ThinLTO, simply add the -flto=thin option to compile and link. E.g. .. code-block:: console. % clang -flto=thin -O2 file1.c file2.c -c; % clang -flto=thin -O2 file1.o file2.o -o a.out. When using lld-link, the -flto option need only be added to the compile step:. .. code-block:: console. % clang-cl -flto=thin -O2 -c file1.c file2.c; % lld-link /out:a.exe file1.obj file2.obj. As mentioned earlier, by default the linkers will launch the ThinLTO backend; threads in parallel, passing the resulting native object files back to the; linker for the final native link. As such, the usage model is the same as; non-LTO. With gold, if you see an error during the link of the form:. .. code-block:: console. /usr/bin/ld: error",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:2218,Modifiability,config,configured,2218," the fast serial thin link step and the backends; is transparent to the user. For more information on the ThinLTO design and current performance,; see the LLVM blog post `ThinLTO: Scalable and Incremental LTO; <http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html>`_.; While tuning is still in progress, results in the blog post show that; ThinLTO already performs well compared to LTO, in many cases matching; the performance improvement. Current Status; ==============. Clang/LLVM; ----------; .. _compiler:. The 3.9 release of clang includes ThinLTO support. However, ThinLTO; is under active development, and new features, improvements and bugfixes; are being added for the next release. For the latest ThinLTO support,; `build a recent version of clang and LLVM; <https://llvm.org/docs/CMake.html>`_. Linkers; -------; .. _linkers:; .. _linker:. ThinLTO is currently supported for the following linkers:. - **gold (via the gold-plugin)**:; Similar to monolithic LTO, this requires using; a `gold linker configured with plugins enabled; <https://llvm.org/docs/GoldPlugin.html>`_.; - **ld64**:; Starting with `Xcode 8 <https://developer.apple.com/xcode/>`_.; - **lld**:; Starting with r284050 for ELF, r298942 for COFF. Usage; =====. Basic; -----. To utilize ThinLTO, simply add the -flto=thin option to compile and link. E.g. .. code-block:: console. % clang -flto=thin -O2 file1.c file2.c -c; % clang -flto=thin -O2 file1.o file2.o -o a.out. When using lld-link, the -flto option need only be added to the compile step:. .. code-block:: console. % clang-cl -flto=thin -O2 -c file1.c file2.c; % lld-link /out:a.exe file1.obj file2.obj. As mentioned earlier, by default the linkers will launch the ThinLTO backend; threads in parallel, passing the resulting native object files back to the; linker for the final native link. As such, the usage model is the same as; non-LTO. With gold, if you see an error during the link of the form:. .. code-block:: console. /usr/bin/ld: error",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:2234,Modifiability,plugin,plugins,2234," the fast serial thin link step and the backends; is transparent to the user. For more information on the ThinLTO design and current performance,; see the LLVM blog post `ThinLTO: Scalable and Incremental LTO; <http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html>`_.; While tuning is still in progress, results in the blog post show that; ThinLTO already performs well compared to LTO, in many cases matching; the performance improvement. Current Status; ==============. Clang/LLVM; ----------; .. _compiler:. The 3.9 release of clang includes ThinLTO support. However, ThinLTO; is under active development, and new features, improvements and bugfixes; are being added for the next release. For the latest ThinLTO support,; `build a recent version of clang and LLVM; <https://llvm.org/docs/CMake.html>`_. Linkers; -------; .. _linkers:; .. _linker:. ThinLTO is currently supported for the following linkers:. - **gold (via the gold-plugin)**:; Similar to monolithic LTO, this requires using; a `gold linker configured with plugins enabled; <https://llvm.org/docs/GoldPlugin.html>`_.; - **ld64**:; Starting with `Xcode 8 <https://developer.apple.com/xcode/>`_.; - **lld**:; Starting with r284050 for ELF, r298942 for COFF. Usage; =====. Basic; -----. To utilize ThinLTO, simply add the -flto=thin option to compile and link. E.g. .. code-block:: console. % clang -flto=thin -O2 file1.c file2.c -c; % clang -flto=thin -O2 file1.o file2.o -o a.out. When using lld-link, the -flto option need only be added to the compile step:. .. code-block:: console. % clang-cl -flto=thin -O2 -c file1.c file2.c; % lld-link /out:a.exe file1.obj file2.obj. As mentioned earlier, by default the linkers will launch the ThinLTO backend; threads in parallel, passing the resulting native object files back to the; linker for the final native link. As such, the usage model is the same as; non-LTO. With gold, if you see an error during the link of the form:. .. code-block:: console. /usr/bin/ld: error",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:3248,Modifiability,plugin,plugin,3248,"s://llvm.org/docs/GoldPlugin.html>`_.; - **ld64**:; Starting with `Xcode 8 <https://developer.apple.com/xcode/>`_.; - **lld**:; Starting with r284050 for ELF, r298942 for COFF. Usage; =====. Basic; -----. To utilize ThinLTO, simply add the -flto=thin option to compile and link. E.g. .. code-block:: console. % clang -flto=thin -O2 file1.c file2.c -c; % clang -flto=thin -O2 file1.o file2.o -o a.out. When using lld-link, the -flto option need only be added to the compile step:. .. code-block:: console. % clang-cl -flto=thin -O2 -c file1.c file2.c; % lld-link /out:a.exe file1.obj file2.obj. As mentioned earlier, by default the linkers will launch the ThinLTO backend; threads in parallel, passing the resulting native object files back to the; linker for the final native link. As such, the usage model is the same as; non-LTO. With gold, if you see an error during the link of the form:. .. code-block:: console. /usr/bin/ld: error: /path/to/clang/bin/../lib/LLVMgold.so: could not load plugin library: /path/to/clang/bin/../lib/LLVMgold.so: cannot open shared object file: No such file or directory. Then either gold was not configured with plugins enabled, or clang; was not built with ``-DLLVM_BINUTILS_INCDIR`` set properly. See; the instructions for the; `LLVM gold plugin <https://llvm.org/docs/GoldPlugin.html#how-to-build-it>`_. Controlling Backend Parallelism; -------------------------------; .. _parallelism:. By default, the ThinLTO link step will launch as many; threads in parallel as there are cores. If the number of; cores can't be computed for the architecture, then it will launch; ``std::thread::hardware_concurrency`` number of threads in parallel.; For machines with hyper-threading, this is the total number of; virtual cores. For some applications and machine configurations this; may be too aggressive, in which case the amount of parallelism can; be reduced to ``N`` via:. - gold:; ``-Wl,-plugin-opt,jobs=N``; - ld64:; ``-Wl,-mllvm,-threads=N``; - ld.lld, ld64.lld:; ``-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:3387,Modifiability,config,configured,3387,"r COFF. Usage; =====. Basic; -----. To utilize ThinLTO, simply add the -flto=thin option to compile and link. E.g. .. code-block:: console. % clang -flto=thin -O2 file1.c file2.c -c; % clang -flto=thin -O2 file1.o file2.o -o a.out. When using lld-link, the -flto option need only be added to the compile step:. .. code-block:: console. % clang-cl -flto=thin -O2 -c file1.c file2.c; % lld-link /out:a.exe file1.obj file2.obj. As mentioned earlier, by default the linkers will launch the ThinLTO backend; threads in parallel, passing the resulting native object files back to the; linker for the final native link. As such, the usage model is the same as; non-LTO. With gold, if you see an error during the link of the form:. .. code-block:: console. /usr/bin/ld: error: /path/to/clang/bin/../lib/LLVMgold.so: could not load plugin library: /path/to/clang/bin/../lib/LLVMgold.so: cannot open shared object file: No such file or directory. Then either gold was not configured with plugins enabled, or clang; was not built with ``-DLLVM_BINUTILS_INCDIR`` set properly. See; the instructions for the; `LLVM gold plugin <https://llvm.org/docs/GoldPlugin.html#how-to-build-it>`_. Controlling Backend Parallelism; -------------------------------; .. _parallelism:. By default, the ThinLTO link step will launch as many; threads in parallel as there are cores. If the number of; cores can't be computed for the architecture, then it will launch; ``std::thread::hardware_concurrency`` number of threads in parallel.; For machines with hyper-threading, this is the total number of; virtual cores. For some applications and machine configurations this; may be too aggressive, in which case the amount of parallelism can; be reduced to ``N`` via:. - gold:; ``-Wl,-plugin-opt,jobs=N``; - ld64:; ``-Wl,-mllvm,-threads=N``; - ld.lld, ld64.lld:; ``-Wl,--thinlto-jobs=N``; - lld-link:; ``/opt:lldltojobs=N``. Other possible values for ``N`` are:. - 0:; Use one thread per physical core (default); - 1:; Use a single th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:3403,Modifiability,plugin,plugins,3403,"r COFF. Usage; =====. Basic; -----. To utilize ThinLTO, simply add the -flto=thin option to compile and link. E.g. .. code-block:: console. % clang -flto=thin -O2 file1.c file2.c -c; % clang -flto=thin -O2 file1.o file2.o -o a.out. When using lld-link, the -flto option need only be added to the compile step:. .. code-block:: console. % clang-cl -flto=thin -O2 -c file1.c file2.c; % lld-link /out:a.exe file1.obj file2.obj. As mentioned earlier, by default the linkers will launch the ThinLTO backend; threads in parallel, passing the resulting native object files back to the; linker for the final native link. As such, the usage model is the same as; non-LTO. With gold, if you see an error during the link of the form:. .. code-block:: console. /usr/bin/ld: error: /path/to/clang/bin/../lib/LLVMgold.so: could not load plugin library: /path/to/clang/bin/../lib/LLVMgold.so: cannot open shared object file: No such file or directory. Then either gold was not configured with plugins enabled, or clang; was not built with ``-DLLVM_BINUTILS_INCDIR`` set properly. See; the instructions for the; `LLVM gold plugin <https://llvm.org/docs/GoldPlugin.html#how-to-build-it>`_. Controlling Backend Parallelism; -------------------------------; .. _parallelism:. By default, the ThinLTO link step will launch as many; threads in parallel as there are cores. If the number of; cores can't be computed for the architecture, then it will launch; ``std::thread::hardware_concurrency`` number of threads in parallel.; For machines with hyper-threading, this is the total number of; virtual cores. For some applications and machine configurations this; may be too aggressive, in which case the amount of parallelism can; be reduced to ``N`` via:. - gold:; ``-Wl,-plugin-opt,jobs=N``; - ld64:; ``-Wl,-mllvm,-threads=N``; - ld.lld, ld64.lld:; ``-Wl,--thinlto-jobs=N``; - lld-link:; ``/opt:lldltojobs=N``. Other possible values for ``N`` are:. - 0:; Use one thread per physical core (default); - 1:; Use a single th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:3532,Modifiability,plugin,plugin,3532,"ile and link. E.g. .. code-block:: console. % clang -flto=thin -O2 file1.c file2.c -c; % clang -flto=thin -O2 file1.o file2.o -o a.out. When using lld-link, the -flto option need only be added to the compile step:. .. code-block:: console. % clang-cl -flto=thin -O2 -c file1.c file2.c; % lld-link /out:a.exe file1.obj file2.obj. As mentioned earlier, by default the linkers will launch the ThinLTO backend; threads in parallel, passing the resulting native object files back to the; linker for the final native link. As such, the usage model is the same as; non-LTO. With gold, if you see an error during the link of the form:. .. code-block:: console. /usr/bin/ld: error: /path/to/clang/bin/../lib/LLVMgold.so: could not load plugin library: /path/to/clang/bin/../lib/LLVMgold.so: cannot open shared object file: No such file or directory. Then either gold was not configured with plugins enabled, or clang; was not built with ``-DLLVM_BINUTILS_INCDIR`` set properly. See; the instructions for the; `LLVM gold plugin <https://llvm.org/docs/GoldPlugin.html#how-to-build-it>`_. Controlling Backend Parallelism; -------------------------------; .. _parallelism:. By default, the ThinLTO link step will launch as many; threads in parallel as there are cores. If the number of; cores can't be computed for the architecture, then it will launch; ``std::thread::hardware_concurrency`` number of threads in parallel.; For machines with hyper-threading, this is the total number of; virtual cores. For some applications and machine configurations this; may be too aggressive, in which case the amount of parallelism can; be reduced to ``N`` via:. - gold:; ``-Wl,-plugin-opt,jobs=N``; - ld64:; ``-Wl,-mllvm,-threads=N``; - ld.lld, ld64.lld:; ``-Wl,--thinlto-jobs=N``; - lld-link:; ``/opt:lldltojobs=N``. Other possible values for ``N`` are:. - 0:; Use one thread per physical core (default); - 1:; Use a single thread only (disable multi-threading); - all:; Use one thread per logical core (uses all hyper-thr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:4045,Modifiability,config,configurations,4045,"TO. With gold, if you see an error during the link of the form:. .. code-block:: console. /usr/bin/ld: error: /path/to/clang/bin/../lib/LLVMgold.so: could not load plugin library: /path/to/clang/bin/../lib/LLVMgold.so: cannot open shared object file: No such file or directory. Then either gold was not configured with plugins enabled, or clang; was not built with ``-DLLVM_BINUTILS_INCDIR`` set properly. See; the instructions for the; `LLVM gold plugin <https://llvm.org/docs/GoldPlugin.html#how-to-build-it>`_. Controlling Backend Parallelism; -------------------------------; .. _parallelism:. By default, the ThinLTO link step will launch as many; threads in parallel as there are cores. If the number of; cores can't be computed for the architecture, then it will launch; ``std::thread::hardware_concurrency`` number of threads in parallel.; For machines with hyper-threading, this is the total number of; virtual cores. For some applications and machine configurations this; may be too aggressive, in which case the amount of parallelism can; be reduced to ``N`` via:. - gold:; ``-Wl,-plugin-opt,jobs=N``; - ld64:; ``-Wl,-mllvm,-threads=N``; - ld.lld, ld64.lld:; ``-Wl,--thinlto-jobs=N``; - lld-link:; ``/opt:lldltojobs=N``. Other possible values for ``N`` are:. - 0:; Use one thread per physical core (default); - 1:; Use a single thread only (disable multi-threading); - all:; Use one thread per logical core (uses all hyper-threads). Incremental; -----------; .. _incremental:. ThinLTO supports fast incremental builds through the use of a cache,; which currently must be enabled through a linker option. - gold (as of LLVM 4.0):; ``-Wl,-plugin-opt,cache-dir=/path/to/cache``; - ld64 (supported since clang 3.9 and Xcode 8) and Mach-O ld64.lld (as of LLVM; 15.0):; ``-Wl,-cache_path_lto,/path/to/cache``; - ELF ld.lld (as of LLVM 5.0):; ``-Wl,--thinlto-cache-dir=/path/to/cache``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocache:/path/to/cache``. Cache Pruning; -------------. To help keep",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:4176,Modifiability,plugin,plugin-opt,4176,"h/to/clang/bin/../lib/LLVMgold.so: could not load plugin library: /path/to/clang/bin/../lib/LLVMgold.so: cannot open shared object file: No such file or directory. Then either gold was not configured with plugins enabled, or clang; was not built with ``-DLLVM_BINUTILS_INCDIR`` set properly. See; the instructions for the; `LLVM gold plugin <https://llvm.org/docs/GoldPlugin.html#how-to-build-it>`_. Controlling Backend Parallelism; -------------------------------; .. _parallelism:. By default, the ThinLTO link step will launch as many; threads in parallel as there are cores. If the number of; cores can't be computed for the architecture, then it will launch; ``std::thread::hardware_concurrency`` number of threads in parallel.; For machines with hyper-threading, this is the total number of; virtual cores. For some applications and machine configurations this; may be too aggressive, in which case the amount of parallelism can; be reduced to ``N`` via:. - gold:; ``-Wl,-plugin-opt,jobs=N``; - ld64:; ``-Wl,-mllvm,-threads=N``; - ld.lld, ld64.lld:; ``-Wl,--thinlto-jobs=N``; - lld-link:; ``/opt:lldltojobs=N``. Other possible values for ``N`` are:. - 0:; Use one thread per physical core (default); - 1:; Use a single thread only (disable multi-threading); - all:; Use one thread per logical core (uses all hyper-threads). Incremental; -----------; .. _incremental:. ThinLTO supports fast incremental builds through the use of a cache,; which currently must be enabled through a linker option. - gold (as of LLVM 4.0):; ``-Wl,-plugin-opt,cache-dir=/path/to/cache``; - ld64 (supported since clang 3.9 and Xcode 8) and Mach-O ld64.lld (as of LLVM; 15.0):; ``-Wl,-cache_path_lto,/path/to/cache``; - ELF ld.lld (as of LLVM 5.0):; ``-Wl,--thinlto-cache-dir=/path/to/cache``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocache:/path/to/cache``. Cache Pruning; -------------. To help keep the size of the cache under control, ThinLTO supports cache; pruning. Cache pruning is supported with gold, ld64,",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:4732,Modifiability,plugin,plugin-opt,4732,"here are cores. If the number of; cores can't be computed for the architecture, then it will launch; ``std::thread::hardware_concurrency`` number of threads in parallel.; For machines with hyper-threading, this is the total number of; virtual cores. For some applications and machine configurations this; may be too aggressive, in which case the amount of parallelism can; be reduced to ``N`` via:. - gold:; ``-Wl,-plugin-opt,jobs=N``; - ld64:; ``-Wl,-mllvm,-threads=N``; - ld.lld, ld64.lld:; ``-Wl,--thinlto-jobs=N``; - lld-link:; ``/opt:lldltojobs=N``. Other possible values for ``N`` are:. - 0:; Use one thread per physical core (default); - 1:; Use a single thread only (disable multi-threading); - all:; Use one thread per logical core (uses all hyper-threads). Incremental; -----------; .. _incremental:. ThinLTO supports fast incremental builds through the use of a cache,; which currently must be enabled through a linker option. - gold (as of LLVM 4.0):; ``-Wl,-plugin-opt,cache-dir=/path/to/cache``; - ld64 (supported since clang 3.9 and Xcode 8) and Mach-O ld64.lld (as of LLVM; 15.0):; ``-Wl,-cache_path_lto,/path/to/cache``; - ELF ld.lld (as of LLVM 5.0):; ``-Wl,--thinlto-cache-dir=/path/to/cache``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocache:/path/to/cache``. Cache Pruning; -------------. To help keep the size of the cache under control, ThinLTO supports cache; pruning. Cache pruning is supported with gold, ld64, and lld, but currently only; gold and lld allow you to control the policy with a policy string. The cache; policy must be specified with a linker option. - gold (as of LLVM 6.0):; ``-Wl,-plugin-opt,cache-policy=POLICY``; - ELF ld.lld (as of LLVM 5.0), Mach-O ld64.lld (as of LLVM 15.0):; ``-Wl,--thinlto-cache-policy=POLICY``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocachepolicy:POLICY``. A policy string is a series of key-value pairs separated by ``:`` characters.; Possible key-value pairs are:. - ``cache_size=X%``: The maximum size for the cache directo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:5387,Modifiability,plugin,plugin-opt,5387,"; - 1:; Use a single thread only (disable multi-threading); - all:; Use one thread per logical core (uses all hyper-threads). Incremental; -----------; .. _incremental:. ThinLTO supports fast incremental builds through the use of a cache,; which currently must be enabled through a linker option. - gold (as of LLVM 4.0):; ``-Wl,-plugin-opt,cache-dir=/path/to/cache``; - ld64 (supported since clang 3.9 and Xcode 8) and Mach-O ld64.lld (as of LLVM; 15.0):; ``-Wl,-cache_path_lto,/path/to/cache``; - ELF ld.lld (as of LLVM 5.0):; ``-Wl,--thinlto-cache-dir=/path/to/cache``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocache:/path/to/cache``. Cache Pruning; -------------. To help keep the size of the cache under control, ThinLTO supports cache; pruning. Cache pruning is supported with gold, ld64, and lld, but currently only; gold and lld allow you to control the policy with a policy string. The cache; policy must be specified with a linker option. - gold (as of LLVM 6.0):; ``-Wl,-plugin-opt,cache-policy=POLICY``; - ELF ld.lld (as of LLVM 5.0), Mach-O ld64.lld (as of LLVM 15.0):; ``-Wl,--thinlto-cache-policy=POLICY``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocachepolicy:POLICY``. A policy string is a series of key-value pairs separated by ``:`` characters.; Possible key-value pairs are:. - ``cache_size=X%``: The maximum size for the cache directory is ``X`` percent; of the available space on the disk. Set to 100 to indicate no limit,; 50 to indicate that the cache size will not be left over half the available; disk space. A value over 100 is invalid. A value of 0 disables the percentage; size-based pruning. The default is 75%. - ``cache_size_bytes=X``, ``cache_size_bytes=Xk``, ``cache_size_bytes=Xm``,; ``cache_size_bytes=Xg``:; Sets the maximum size for the cache directory to ``X`` bytes (or KB, MB,; GB respectively). A value over the amount of available space on the disk; will be reduced to the amount of available space. A value of 0 disables; the byte size-based pruning. T",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:7872,Modifiability,config,configured,7872,"The default is 1000000 files. - ``prune_after=Xs``, ``prune_after=Xm``, ``prune_after=Xh``: Sets the; expiration time for cache files to ``X`` seconds (or minutes, hours; respectively). When a file hasn't been accessed for ``prune_after`` seconds,; it is removed from the cache. A value of 0 disables the expiration-based; pruning. The default is 1 week. - ``prune_interval=Xs``, ``prune_interval=Xm``, ``prune_interval=Xh``:; Sets the pruning interval to ``X`` seconds (or minutes, hours; respectively). This is intended to be used to avoid scanning the directory; too often. It does not impact the decision of which files to prune. A; value of 0 forces the scan to occur. The default is every 20 minutes. Clang Bootstrap; ---------------. To `bootstrap clang/LLVM <https://llvm.org/docs/AdvancedBuilds.html#bootstrap-builds>`_; with ThinLTO, follow these steps:. 1. The host compiler_ must be a version of clang that supports ThinLTO.; #. The host linker_ must support ThinLTO (and in the case of gold, must be; `configured with plugins enabled <https://llvm.org/docs/GoldPlugin.html>`_).; #. Use the following additional `CMake variables; <https://llvm.org/docs/CMake.html#options-and-variables>`_; when configuring the bootstrap compiler build:. * ``-DLLVM_ENABLE_LTO=Thin``; * ``-DCMAKE_C_COMPILER=/path/to/host/clang``; * ``-DCMAKE_CXX_COMPILER=/path/to/host/clang++``; * ``-DCMAKE_RANLIB=/path/to/host/llvm-ranlib``; * ``-DCMAKE_AR=/path/to/host/llvm-ar``. Or, on Windows:. * ``-DLLVM_ENABLE_LTO=Thin``; * ``-DCMAKE_C_COMPILER=/path/to/host/clang-cl.exe``; * ``-DCMAKE_CXX_COMPILER=/path/to/host/clang-cl.exe``; * ``-DCMAKE_LINKER=/path/to/host/lld-link.exe``; * ``-DCMAKE_RANLIB=/path/to/host/llvm-ranlib.exe``; * ``-DCMAKE_AR=/path/to/host/llvm-ar.exe``. #. To use additional linker arguments for controlling the backend; parallelism_ or enabling incremental_ builds of the bootstrap compiler,; after configuring the build, modify the resulting CMakeCache.txt file in the; build directory. Sp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:7888,Modifiability,plugin,plugins,7888,"The default is 1000000 files. - ``prune_after=Xs``, ``prune_after=Xm``, ``prune_after=Xh``: Sets the; expiration time for cache files to ``X`` seconds (or minutes, hours; respectively). When a file hasn't been accessed for ``prune_after`` seconds,; it is removed from the cache. A value of 0 disables the expiration-based; pruning. The default is 1 week. - ``prune_interval=Xs``, ``prune_interval=Xm``, ``prune_interval=Xh``:; Sets the pruning interval to ``X`` seconds (or minutes, hours; respectively). This is intended to be used to avoid scanning the directory; too often. It does not impact the decision of which files to prune. A; value of 0 forces the scan to occur. The default is every 20 minutes. Clang Bootstrap; ---------------. To `bootstrap clang/LLVM <https://llvm.org/docs/AdvancedBuilds.html#bootstrap-builds>`_; with ThinLTO, follow these steps:. 1. The host compiler_ must be a version of clang that supports ThinLTO.; #. The host linker_ must support ThinLTO (and in the case of gold, must be; `configured with plugins enabled <https://llvm.org/docs/GoldPlugin.html>`_).; #. Use the following additional `CMake variables; <https://llvm.org/docs/CMake.html#options-and-variables>`_; when configuring the bootstrap compiler build:. * ``-DLLVM_ENABLE_LTO=Thin``; * ``-DCMAKE_C_COMPILER=/path/to/host/clang``; * ``-DCMAKE_CXX_COMPILER=/path/to/host/clang++``; * ``-DCMAKE_RANLIB=/path/to/host/llvm-ranlib``; * ``-DCMAKE_AR=/path/to/host/llvm-ar``. Or, on Windows:. * ``-DLLVM_ENABLE_LTO=Thin``; * ``-DCMAKE_C_COMPILER=/path/to/host/clang-cl.exe``; * ``-DCMAKE_CXX_COMPILER=/path/to/host/clang-cl.exe``; * ``-DCMAKE_LINKER=/path/to/host/lld-link.exe``; * ``-DCMAKE_RANLIB=/path/to/host/llvm-ranlib.exe``; * ``-DCMAKE_AR=/path/to/host/llvm-ar.exe``. #. To use additional linker arguments for controlling the backend; parallelism_ or enabling incremental_ builds of the bootstrap compiler,; after configuring the build, modify the resulting CMakeCache.txt file in the; build directory. Sp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:7988,Modifiability,variab,variables,7988,"he files to ``X`` seconds (or minutes, hours; respectively). When a file hasn't been accessed for ``prune_after`` seconds,; it is removed from the cache. A value of 0 disables the expiration-based; pruning. The default is 1 week. - ``prune_interval=Xs``, ``prune_interval=Xm``, ``prune_interval=Xh``:; Sets the pruning interval to ``X`` seconds (or minutes, hours; respectively). This is intended to be used to avoid scanning the directory; too often. It does not impact the decision of which files to prune. A; value of 0 forces the scan to occur. The default is every 20 minutes. Clang Bootstrap; ---------------. To `bootstrap clang/LLVM <https://llvm.org/docs/AdvancedBuilds.html#bootstrap-builds>`_; with ThinLTO, follow these steps:. 1. The host compiler_ must be a version of clang that supports ThinLTO.; #. The host linker_ must support ThinLTO (and in the case of gold, must be; `configured with plugins enabled <https://llvm.org/docs/GoldPlugin.html>`_).; #. Use the following additional `CMake variables; <https://llvm.org/docs/CMake.html#options-and-variables>`_; when configuring the bootstrap compiler build:. * ``-DLLVM_ENABLE_LTO=Thin``; * ``-DCMAKE_C_COMPILER=/path/to/host/clang``; * ``-DCMAKE_CXX_COMPILER=/path/to/host/clang++``; * ``-DCMAKE_RANLIB=/path/to/host/llvm-ranlib``; * ``-DCMAKE_AR=/path/to/host/llvm-ar``. Or, on Windows:. * ``-DLLVM_ENABLE_LTO=Thin``; * ``-DCMAKE_C_COMPILER=/path/to/host/clang-cl.exe``; * ``-DCMAKE_CXX_COMPILER=/path/to/host/clang-cl.exe``; * ``-DCMAKE_LINKER=/path/to/host/lld-link.exe``; * ``-DCMAKE_RANLIB=/path/to/host/llvm-ranlib.exe``; * ``-DCMAKE_AR=/path/to/host/llvm-ar.exe``. #. To use additional linker arguments for controlling the backend; parallelism_ or enabling incremental_ builds of the bootstrap compiler,; after configuring the build, modify the resulting CMakeCache.txt file in the; build directory. Specify any additional linker options after; ``CMAKE_EXE_LINKER_FLAGS:STRING=``. Note the configure may fail if; linker plugin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:8045,Modifiability,variab,variables,8045,"accessed for ``prune_after`` seconds,; it is removed from the cache. A value of 0 disables the expiration-based; pruning. The default is 1 week. - ``prune_interval=Xs``, ``prune_interval=Xm``, ``prune_interval=Xh``:; Sets the pruning interval to ``X`` seconds (or minutes, hours; respectively). This is intended to be used to avoid scanning the directory; too often. It does not impact the decision of which files to prune. A; value of 0 forces the scan to occur. The default is every 20 minutes. Clang Bootstrap; ---------------. To `bootstrap clang/LLVM <https://llvm.org/docs/AdvancedBuilds.html#bootstrap-builds>`_; with ThinLTO, follow these steps:. 1. The host compiler_ must be a version of clang that supports ThinLTO.; #. The host linker_ must support ThinLTO (and in the case of gold, must be; `configured with plugins enabled <https://llvm.org/docs/GoldPlugin.html>`_).; #. Use the following additional `CMake variables; <https://llvm.org/docs/CMake.html#options-and-variables>`_; when configuring the bootstrap compiler build:. * ``-DLLVM_ENABLE_LTO=Thin``; * ``-DCMAKE_C_COMPILER=/path/to/host/clang``; * ``-DCMAKE_CXX_COMPILER=/path/to/host/clang++``; * ``-DCMAKE_RANLIB=/path/to/host/llvm-ranlib``; * ``-DCMAKE_AR=/path/to/host/llvm-ar``. Or, on Windows:. * ``-DLLVM_ENABLE_LTO=Thin``; * ``-DCMAKE_C_COMPILER=/path/to/host/clang-cl.exe``; * ``-DCMAKE_CXX_COMPILER=/path/to/host/clang-cl.exe``; * ``-DCMAKE_LINKER=/path/to/host/lld-link.exe``; * ``-DCMAKE_RANLIB=/path/to/host/llvm-ranlib.exe``; * ``-DCMAKE_AR=/path/to/host/llvm-ar.exe``. #. To use additional linker arguments for controlling the backend; parallelism_ or enabling incremental_ builds of the bootstrap compiler,; after configuring the build, modify the resulting CMakeCache.txt file in the; build directory. Specify any additional linker options after; ``CMAKE_EXE_LINKER_FLAGS:STRING=``. Note the configure may fail if; linker plugin options are instead specified directly in the previous step. The ``BOOTSTRAP_LLVM_EN",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:8064,Modifiability,config,configuring,8064,"accessed for ``prune_after`` seconds,; it is removed from the cache. A value of 0 disables the expiration-based; pruning. The default is 1 week. - ``prune_interval=Xs``, ``prune_interval=Xm``, ``prune_interval=Xh``:; Sets the pruning interval to ``X`` seconds (or minutes, hours; respectively). This is intended to be used to avoid scanning the directory; too often. It does not impact the decision of which files to prune. A; value of 0 forces the scan to occur. The default is every 20 minutes. Clang Bootstrap; ---------------. To `bootstrap clang/LLVM <https://llvm.org/docs/AdvancedBuilds.html#bootstrap-builds>`_; with ThinLTO, follow these steps:. 1. The host compiler_ must be a version of clang that supports ThinLTO.; #. The host linker_ must support ThinLTO (and in the case of gold, must be; `configured with plugins enabled <https://llvm.org/docs/GoldPlugin.html>`_).; #. Use the following additional `CMake variables; <https://llvm.org/docs/CMake.html#options-and-variables>`_; when configuring the bootstrap compiler build:. * ``-DLLVM_ENABLE_LTO=Thin``; * ``-DCMAKE_C_COMPILER=/path/to/host/clang``; * ``-DCMAKE_CXX_COMPILER=/path/to/host/clang++``; * ``-DCMAKE_RANLIB=/path/to/host/llvm-ranlib``; * ``-DCMAKE_AR=/path/to/host/llvm-ar``. Or, on Windows:. * ``-DLLVM_ENABLE_LTO=Thin``; * ``-DCMAKE_C_COMPILER=/path/to/host/clang-cl.exe``; * ``-DCMAKE_CXX_COMPILER=/path/to/host/clang-cl.exe``; * ``-DCMAKE_LINKER=/path/to/host/lld-link.exe``; * ``-DCMAKE_RANLIB=/path/to/host/llvm-ranlib.exe``; * ``-DCMAKE_AR=/path/to/host/llvm-ar.exe``. #. To use additional linker arguments for controlling the backend; parallelism_ or enabling incremental_ builds of the bootstrap compiler,; after configuring the build, modify the resulting CMakeCache.txt file in the; build directory. Specify any additional linker options after; ``CMAKE_EXE_LINKER_FLAGS:STRING=``. Note the configure may fail if; linker plugin options are instead specified directly in the previous step. The ``BOOTSTRAP_LLVM_EN",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:8767,Modifiability,config,configuring,8767,"e used to avoid scanning the directory; too often. It does not impact the decision of which files to prune. A; value of 0 forces the scan to occur. The default is every 20 minutes. Clang Bootstrap; ---------------. To `bootstrap clang/LLVM <https://llvm.org/docs/AdvancedBuilds.html#bootstrap-builds>`_; with ThinLTO, follow these steps:. 1. The host compiler_ must be a version of clang that supports ThinLTO.; #. The host linker_ must support ThinLTO (and in the case of gold, must be; `configured with plugins enabled <https://llvm.org/docs/GoldPlugin.html>`_).; #. Use the following additional `CMake variables; <https://llvm.org/docs/CMake.html#options-and-variables>`_; when configuring the bootstrap compiler build:. * ``-DLLVM_ENABLE_LTO=Thin``; * ``-DCMAKE_C_COMPILER=/path/to/host/clang``; * ``-DCMAKE_CXX_COMPILER=/path/to/host/clang++``; * ``-DCMAKE_RANLIB=/path/to/host/llvm-ranlib``; * ``-DCMAKE_AR=/path/to/host/llvm-ar``. Or, on Windows:. * ``-DLLVM_ENABLE_LTO=Thin``; * ``-DCMAKE_C_COMPILER=/path/to/host/clang-cl.exe``; * ``-DCMAKE_CXX_COMPILER=/path/to/host/clang-cl.exe``; * ``-DCMAKE_LINKER=/path/to/host/lld-link.exe``; * ``-DCMAKE_RANLIB=/path/to/host/llvm-ranlib.exe``; * ``-DCMAKE_AR=/path/to/host/llvm-ar.exe``. #. To use additional linker arguments for controlling the backend; parallelism_ or enabling incremental_ builds of the bootstrap compiler,; after configuring the build, modify the resulting CMakeCache.txt file in the; build directory. Specify any additional linker options after; ``CMAKE_EXE_LINKER_FLAGS:STRING=``. Note the configure may fail if; linker plugin options are instead specified directly in the previous step. The ``BOOTSTRAP_LLVM_ENABLE_LTO=Thin`` will enable ThinLTO for stage 2 and; stage 3 in case the compiler used for stage 1 does not support the ThinLTO; option. More Information; ================. * From LLVM project blog:; `ThinLTO: Scalable and Incremental LTO; <http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html>`_; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:8946,Modifiability,config,configure,8946,"e used to avoid scanning the directory; too often. It does not impact the decision of which files to prune. A; value of 0 forces the scan to occur. The default is every 20 minutes. Clang Bootstrap; ---------------. To `bootstrap clang/LLVM <https://llvm.org/docs/AdvancedBuilds.html#bootstrap-builds>`_; with ThinLTO, follow these steps:. 1. The host compiler_ must be a version of clang that supports ThinLTO.; #. The host linker_ must support ThinLTO (and in the case of gold, must be; `configured with plugins enabled <https://llvm.org/docs/GoldPlugin.html>`_).; #. Use the following additional `CMake variables; <https://llvm.org/docs/CMake.html#options-and-variables>`_; when configuring the bootstrap compiler build:. * ``-DLLVM_ENABLE_LTO=Thin``; * ``-DCMAKE_C_COMPILER=/path/to/host/clang``; * ``-DCMAKE_CXX_COMPILER=/path/to/host/clang++``; * ``-DCMAKE_RANLIB=/path/to/host/llvm-ranlib``; * ``-DCMAKE_AR=/path/to/host/llvm-ar``. Or, on Windows:. * ``-DLLVM_ENABLE_LTO=Thin``; * ``-DCMAKE_C_COMPILER=/path/to/host/clang-cl.exe``; * ``-DCMAKE_CXX_COMPILER=/path/to/host/clang-cl.exe``; * ``-DCMAKE_LINKER=/path/to/host/lld-link.exe``; * ``-DCMAKE_RANLIB=/path/to/host/llvm-ranlib.exe``; * ``-DCMAKE_AR=/path/to/host/llvm-ar.exe``. #. To use additional linker arguments for controlling the backend; parallelism_ or enabling incremental_ builds of the bootstrap compiler,; after configuring the build, modify the resulting CMakeCache.txt file in the; build directory. Specify any additional linker options after; ``CMAKE_EXE_LINKER_FLAGS:STRING=``. Note the configure may fail if; linker plugin options are instead specified directly in the previous step. The ``BOOTSTRAP_LLVM_ENABLE_LTO=Thin`` will enable ThinLTO for stage 2 and; stage 3 in case the compiler used for stage 1 does not support the ThinLTO; option. More Information; ================. * From LLVM project blog:; `ThinLTO: Scalable and Incremental LTO; <http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html>`_; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:8976,Modifiability,plugin,plugin,8976,"e used to avoid scanning the directory; too often. It does not impact the decision of which files to prune. A; value of 0 forces the scan to occur. The default is every 20 minutes. Clang Bootstrap; ---------------. To `bootstrap clang/LLVM <https://llvm.org/docs/AdvancedBuilds.html#bootstrap-builds>`_; with ThinLTO, follow these steps:. 1. The host compiler_ must be a version of clang that supports ThinLTO.; #. The host linker_ must support ThinLTO (and in the case of gold, must be; `configured with plugins enabled <https://llvm.org/docs/GoldPlugin.html>`_).; #. Use the following additional `CMake variables; <https://llvm.org/docs/CMake.html#options-and-variables>`_; when configuring the bootstrap compiler build:. * ``-DLLVM_ENABLE_LTO=Thin``; * ``-DCMAKE_C_COMPILER=/path/to/host/clang``; * ``-DCMAKE_CXX_COMPILER=/path/to/host/clang++``; * ``-DCMAKE_RANLIB=/path/to/host/llvm-ranlib``; * ``-DCMAKE_AR=/path/to/host/llvm-ar``. Or, on Windows:. * ``-DLLVM_ENABLE_LTO=Thin``; * ``-DCMAKE_C_COMPILER=/path/to/host/clang-cl.exe``; * ``-DCMAKE_CXX_COMPILER=/path/to/host/clang-cl.exe``; * ``-DCMAKE_LINKER=/path/to/host/lld-link.exe``; * ``-DCMAKE_RANLIB=/path/to/host/llvm-ranlib.exe``; * ``-DCMAKE_AR=/path/to/host/llvm-ar.exe``. #. To use additional linker arguments for controlling the backend; parallelism_ or enabling incremental_ builds of the bootstrap compiler,; after configuring the build, modify the resulting CMakeCache.txt file in the; build directory. Specify any additional linker options after; ``CMAKE_EXE_LINKER_FLAGS:STRING=``. Note the configure may fail if; linker plugin options are instead specified directly in the previous step. The ``BOOTSTRAP_LLVM_ENABLE_LTO=Thin`` will enable ThinLTO for stage 2 and; stage 3 in case the compiler used for stage 1 does not support the ThinLTO; option. More Information; ================. * From LLVM project blog:; `ThinLTO: Scalable and Incremental LTO; <http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html>`_; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:135,Performance,scalab,scalable,135,"=======; ThinLTO; =======. .. contents::; :local:. Introduction; ============. *ThinLTO* compilation is a new type of LTO that is both scalable and; incremental. *LTO* (Link Time Optimization) achieves better; runtime performance through whole-program analysis and cross-module; optimization. However, monolithic LTO implements this by merging all; input into a single module, which is not scalable; in time or memory, and also prevents fast incremental compiles. In ThinLTO mode, as with regular LTO, clang emits LLVM bitcode after the; compile phase. The ThinLTO bitcode is augmented with a compact summary; of the module. During the link step, only the summaries are read and; merged into a combined summary index, which includes an index of function; locations for later cross-module function importing. Fast and efficient; whole-program analysis is then performed on the combined summary index. However, all transformations, including function importing, occur; later when the modules are optimized in fully parallel backends.; By default, linkers_ that support ThinLTO are set up to launch; the ThinLTO backends in threads. So the usage model is not affected; as the distinction between the fast serial thin link step and the backends; is transparent to the user. For more information on the ThinLTO design and current performance,; see the LLVM blog post `ThinLTO: Scalable and Incremental LTO; <http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html>`_.; While tuning is still in progress, results in the blog post show that; ThinLTO already performs well compared to LTO, in many cases matching; the performance improvement. Current Status; ==============. Clang/LLVM; ----------; .. _compiler:. The 3.9 release of clang includes ThinLTO support. However, ThinLTO; is under active development, and new features, improvements and bugfixes; are being added for the next release. For the latest ThinLTO support,; `build a recent version of clang and LLVM; <https://llvm.org/docs/",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:218,Performance,perform,performance,218,"=======; ThinLTO; =======. .. contents::; :local:. Introduction; ============. *ThinLTO* compilation is a new type of LTO that is both scalable and; incremental. *LTO* (Link Time Optimization) achieves better; runtime performance through whole-program analysis and cross-module; optimization. However, monolithic LTO implements this by merging all; input into a single module, which is not scalable; in time or memory, and also prevents fast incremental compiles. In ThinLTO mode, as with regular LTO, clang emits LLVM bitcode after the; compile phase. The ThinLTO bitcode is augmented with a compact summary; of the module. During the link step, only the summaries are read and; merged into a combined summary index, which includes an index of function; locations for later cross-module function importing. Fast and efficient; whole-program analysis is then performed on the combined summary index. However, all transformations, including function importing, occur; later when the modules are optimized in fully parallel backends.; By default, linkers_ that support ThinLTO are set up to launch; the ThinLTO backends in threads. So the usage model is not affected; as the distinction between the fast serial thin link step and the backends; is transparent to the user. For more information on the ThinLTO design and current performance,; see the LLVM blog post `ThinLTO: Scalable and Incremental LTO; <http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html>`_.; While tuning is still in progress, results in the blog post show that; ThinLTO already performs well compared to LTO, in many cases matching; the performance improvement. Current Status; ==============. Clang/LLVM; ----------; .. _compiler:. The 3.9 release of clang includes ThinLTO support. However, ThinLTO; is under active development, and new features, improvements and bugfixes; are being added for the next release. For the latest ThinLTO support,; `build a recent version of clang and LLVM; <https://llvm.org/docs/",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:279,Performance,optimiz,optimization,279,"=======; ThinLTO; =======. .. contents::; :local:. Introduction; ============. *ThinLTO* compilation is a new type of LTO that is both scalable and; incremental. *LTO* (Link Time Optimization) achieves better; runtime performance through whole-program analysis and cross-module; optimization. However, monolithic LTO implements this by merging all; input into a single module, which is not scalable; in time or memory, and also prevents fast incremental compiles. In ThinLTO mode, as with regular LTO, clang emits LLVM bitcode after the; compile phase. The ThinLTO bitcode is augmented with a compact summary; of the module. During the link step, only the summaries are read and; merged into a combined summary index, which includes an index of function; locations for later cross-module function importing. Fast and efficient; whole-program analysis is then performed on the combined summary index. However, all transformations, including function importing, occur; later when the modules are optimized in fully parallel backends.; By default, linkers_ that support ThinLTO are set up to launch; the ThinLTO backends in threads. So the usage model is not affected; as the distinction between the fast serial thin link step and the backends; is transparent to the user. For more information on the ThinLTO design and current performance,; see the LLVM blog post `ThinLTO: Scalable and Incremental LTO; <http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html>`_.; While tuning is still in progress, results in the blog post show that; ThinLTO already performs well compared to LTO, in many cases matching; the performance improvement. Current Status; ==============. Clang/LLVM; ----------; .. _compiler:. The 3.9 release of clang includes ThinLTO support. However, ThinLTO; is under active development, and new features, improvements and bugfixes; are being added for the next release. For the latest ThinLTO support,; `build a recent version of clang and LLVM; <https://llvm.org/docs/",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:390,Performance,scalab,scalable,390,"=======; ThinLTO; =======. .. contents::; :local:. Introduction; ============. *ThinLTO* compilation is a new type of LTO that is both scalable and; incremental. *LTO* (Link Time Optimization) achieves better; runtime performance through whole-program analysis and cross-module; optimization. However, monolithic LTO implements this by merging all; input into a single module, which is not scalable; in time or memory, and also prevents fast incremental compiles. In ThinLTO mode, as with regular LTO, clang emits LLVM bitcode after the; compile phase. The ThinLTO bitcode is augmented with a compact summary; of the module. During the link step, only the summaries are read and; merged into a combined summary index, which includes an index of function; locations for later cross-module function importing. Fast and efficient; whole-program analysis is then performed on the combined summary index. However, all transformations, including function importing, occur; later when the modules are optimized in fully parallel backends.; By default, linkers_ that support ThinLTO are set up to launch; the ThinLTO backends in threads. So the usage model is not affected; as the distinction between the fast serial thin link step and the backends; is transparent to the user. For more information on the ThinLTO design and current performance,; see the LLVM blog post `ThinLTO: Scalable and Incremental LTO; <http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html>`_.; While tuning is still in progress, results in the blog post show that; ThinLTO already performs well compared to LTO, in many cases matching; the performance improvement. Current Status; ==============. Clang/LLVM; ----------; .. _compiler:. The 3.9 release of clang includes ThinLTO support. However, ThinLTO; is under active development, and new features, improvements and bugfixes; are being added for the next release. For the latest ThinLTO support,; `build a recent version of clang and LLVM; <https://llvm.org/docs/",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:859,Performance,perform,performed,859,"=======; ThinLTO; =======. .. contents::; :local:. Introduction; ============. *ThinLTO* compilation is a new type of LTO that is both scalable and; incremental. *LTO* (Link Time Optimization) achieves better; runtime performance through whole-program analysis and cross-module; optimization. However, monolithic LTO implements this by merging all; input into a single module, which is not scalable; in time or memory, and also prevents fast incremental compiles. In ThinLTO mode, as with regular LTO, clang emits LLVM bitcode after the; compile phase. The ThinLTO bitcode is augmented with a compact summary; of the module. During the link step, only the summaries are read and; merged into a combined summary index, which includes an index of function; locations for later cross-module function importing. Fast and efficient; whole-program analysis is then performed on the combined summary index. However, all transformations, including function importing, occur; later when the modules are optimized in fully parallel backends.; By default, linkers_ that support ThinLTO are set up to launch; the ThinLTO backends in threads. So the usage model is not affected; as the distinction between the fast serial thin link step and the backends; is transparent to the user. For more information on the ThinLTO design and current performance,; see the LLVM blog post `ThinLTO: Scalable and Incremental LTO; <http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html>`_.; While tuning is still in progress, results in the blog post show that; ThinLTO already performs well compared to LTO, in many cases matching; the performance improvement. Current Status; ==============. Clang/LLVM; ----------; .. _compiler:. The 3.9 release of clang includes ThinLTO support. However, ThinLTO; is under active development, and new features, improvements and bugfixes; are being added for the next release. For the latest ThinLTO support,; `build a recent version of clang and LLVM; <https://llvm.org/docs/",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:994,Performance,optimiz,optimized,994,"=======; ThinLTO; =======. .. contents::; :local:. Introduction; ============. *ThinLTO* compilation is a new type of LTO that is both scalable and; incremental. *LTO* (Link Time Optimization) achieves better; runtime performance through whole-program analysis and cross-module; optimization. However, monolithic LTO implements this by merging all; input into a single module, which is not scalable; in time or memory, and also prevents fast incremental compiles. In ThinLTO mode, as with regular LTO, clang emits LLVM bitcode after the; compile phase. The ThinLTO bitcode is augmented with a compact summary; of the module. During the link step, only the summaries are read and; merged into a combined summary index, which includes an index of function; locations for later cross-module function importing. Fast and efficient; whole-program analysis is then performed on the combined summary index. However, all transformations, including function importing, occur; later when the modules are optimized in fully parallel backends.; By default, linkers_ that support ThinLTO are set up to launch; the ThinLTO backends in threads. So the usage model is not affected; as the distinction between the fast serial thin link step and the backends; is transparent to the user. For more information on the ThinLTO design and current performance,; see the LLVM blog post `ThinLTO: Scalable and Incremental LTO; <http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html>`_.; While tuning is still in progress, results in the blog post show that; ThinLTO already performs well compared to LTO, in many cases matching; the performance improvement. Current Status; ==============. Clang/LLVM; ----------; .. _compiler:. The 3.9 release of clang includes ThinLTO support. However, ThinLTO; is under active development, and new features, improvements and bugfixes; are being added for the next release. For the latest ThinLTO support,; `build a recent version of clang and LLVM; <https://llvm.org/docs/",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:1325,Performance,perform,performance,1325,"g all; input into a single module, which is not scalable; in time or memory, and also prevents fast incremental compiles. In ThinLTO mode, as with regular LTO, clang emits LLVM bitcode after the; compile phase. The ThinLTO bitcode is augmented with a compact summary; of the module. During the link step, only the summaries are read and; merged into a combined summary index, which includes an index of function; locations for later cross-module function importing. Fast and efficient; whole-program analysis is then performed on the combined summary index. However, all transformations, including function importing, occur; later when the modules are optimized in fully parallel backends.; By default, linkers_ that support ThinLTO are set up to launch; the ThinLTO backends in threads. So the usage model is not affected; as the distinction between the fast serial thin link step and the backends; is transparent to the user. For more information on the ThinLTO design and current performance,; see the LLVM blog post `ThinLTO: Scalable and Incremental LTO; <http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html>`_.; While tuning is still in progress, results in the blog post show that; ThinLTO already performs well compared to LTO, in many cases matching; the performance improvement. Current Status; ==============. Clang/LLVM; ----------; .. _compiler:. The 3.9 release of clang includes ThinLTO support. However, ThinLTO; is under active development, and new features, improvements and bugfixes; are being added for the next release. For the latest ThinLTO support,; `build a recent version of clang and LLVM; <https://llvm.org/docs/CMake.html>`_. Linkers; -------; .. _linkers:; .. _linker:. ThinLTO is currently supported for the following linkers:. - **gold (via the gold-plugin)**:; Similar to monolithic LTO, this requires using; a `gold linker configured with plugins enabled; <https://llvm.org/docs/GoldPlugin.html>`_.; - **ld64**:; Starting with `Xcode 8 <https://de",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:1440,Performance,scalab,scalable-and-incremental-lto,1440,"cremental compiles. In ThinLTO mode, as with regular LTO, clang emits LLVM bitcode after the; compile phase. The ThinLTO bitcode is augmented with a compact summary; of the module. During the link step, only the summaries are read and; merged into a combined summary index, which includes an index of function; locations for later cross-module function importing. Fast and efficient; whole-program analysis is then performed on the combined summary index. However, all transformations, including function importing, occur; later when the modules are optimized in fully parallel backends.; By default, linkers_ that support ThinLTO are set up to launch; the ThinLTO backends in threads. So the usage model is not affected; as the distinction between the fast serial thin link step and the backends; is transparent to the user. For more information on the ThinLTO design and current performance,; see the LLVM blog post `ThinLTO: Scalable and Incremental LTO; <http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html>`_.; While tuning is still in progress, results in the blog post show that; ThinLTO already performs well compared to LTO, in many cases matching; the performance improvement. Current Status; ==============. Clang/LLVM; ----------; .. _compiler:. The 3.9 release of clang includes ThinLTO support. However, ThinLTO; is under active development, and new features, improvements and bugfixes; are being added for the next release. For the latest ThinLTO support,; `build a recent version of clang and LLVM; <https://llvm.org/docs/CMake.html>`_. Linkers; -------; .. _linkers:; .. _linker:. ThinLTO is currently supported for the following linkers:. - **gold (via the gold-plugin)**:; Similar to monolithic LTO, this requires using; a `gold linker configured with plugins enabled; <https://llvm.org/docs/GoldPlugin.html>`_.; - **ld64**:; Starting with `Xcode 8 <https://developer.apple.com/xcode/>`_.; - **lld**:; Starting with r284050 for ELF, r298942 for COFF. Usage; =====",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:1566,Performance,perform,performs,1566,"O bitcode is augmented with a compact summary; of the module. During the link step, only the summaries are read and; merged into a combined summary index, which includes an index of function; locations for later cross-module function importing. Fast and efficient; whole-program analysis is then performed on the combined summary index. However, all transformations, including function importing, occur; later when the modules are optimized in fully parallel backends.; By default, linkers_ that support ThinLTO are set up to launch; the ThinLTO backends in threads. So the usage model is not affected; as the distinction between the fast serial thin link step and the backends; is transparent to the user. For more information on the ThinLTO design and current performance,; see the LLVM blog post `ThinLTO: Scalable and Incremental LTO; <http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html>`_.; While tuning is still in progress, results in the blog post show that; ThinLTO already performs well compared to LTO, in many cases matching; the performance improvement. Current Status; ==============. Clang/LLVM; ----------; .. _compiler:. The 3.9 release of clang includes ThinLTO support. However, ThinLTO; is under active development, and new features, improvements and bugfixes; are being added for the next release. For the latest ThinLTO support,; `build a recent version of clang and LLVM; <https://llvm.org/docs/CMake.html>`_. Linkers; -------; .. _linkers:; .. _linker:. ThinLTO is currently supported for the following linkers:. - **gold (via the gold-plugin)**:; Similar to monolithic LTO, this requires using; a `gold linker configured with plugins enabled; <https://llvm.org/docs/GoldPlugin.html>`_.; - **ld64**:; Starting with `Xcode 8 <https://developer.apple.com/xcode/>`_.; - **lld**:; Starting with r284050 for ELF, r298942 for COFF. Usage; =====. Basic; -----. To utilize ThinLTO, simply add the -flto=thin option to compile and link. E.g. .. code-block:: console",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:1625,Performance,perform,performance,1625,"O bitcode is augmented with a compact summary; of the module. During the link step, only the summaries are read and; merged into a combined summary index, which includes an index of function; locations for later cross-module function importing. Fast and efficient; whole-program analysis is then performed on the combined summary index. However, all transformations, including function importing, occur; later when the modules are optimized in fully parallel backends.; By default, linkers_ that support ThinLTO are set up to launch; the ThinLTO backends in threads. So the usage model is not affected; as the distinction between the fast serial thin link step and the backends; is transparent to the user. For more information on the ThinLTO design and current performance,; see the LLVM blog post `ThinLTO: Scalable and Incremental LTO; <http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html>`_.; While tuning is still in progress, results in the blog post show that; ThinLTO already performs well compared to LTO, in many cases matching; the performance improvement. Current Status; ==============. Clang/LLVM; ----------; .. _compiler:. The 3.9 release of clang includes ThinLTO support. However, ThinLTO; is under active development, and new features, improvements and bugfixes; are being added for the next release. For the latest ThinLTO support,; `build a recent version of clang and LLVM; <https://llvm.org/docs/CMake.html>`_. Linkers; -------; .. _linkers:; .. _linker:. ThinLTO is currently supported for the following linkers:. - **gold (via the gold-plugin)**:; Similar to monolithic LTO, this requires using; a `gold linker configured with plugins enabled; <https://llvm.org/docs/GoldPlugin.html>`_.; - **ld64**:; Starting with `Xcode 8 <https://developer.apple.com/xcode/>`_.; - **lld**:; Starting with r284050 for ELF, r298942 for COFF. Usage; =====. Basic; -----. To utilize ThinLTO, simply add the -flto=thin option to compile and link. E.g. .. code-block:: console",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:3243,Performance,load,load,3243,"s://llvm.org/docs/GoldPlugin.html>`_.; - **ld64**:; Starting with `Xcode 8 <https://developer.apple.com/xcode/>`_.; - **lld**:; Starting with r284050 for ELF, r298942 for COFF. Usage; =====. Basic; -----. To utilize ThinLTO, simply add the -flto=thin option to compile and link. E.g. .. code-block:: console. % clang -flto=thin -O2 file1.c file2.c -c; % clang -flto=thin -O2 file1.o file2.o -o a.out. When using lld-link, the -flto option need only be added to the compile step:. .. code-block:: console. % clang-cl -flto=thin -O2 -c file1.c file2.c; % lld-link /out:a.exe file1.obj file2.obj. As mentioned earlier, by default the linkers will launch the ThinLTO backend; threads in parallel, passing the resulting native object files back to the; linker for the final native link. As such, the usage model is the same as; non-LTO. With gold, if you see an error during the link of the form:. .. code-block:: console. /usr/bin/ld: error: /path/to/clang/bin/../lib/LLVMgold.so: could not load plugin library: /path/to/clang/bin/../lib/LLVMgold.so: cannot open shared object file: No such file or directory. Then either gold was not configured with plugins enabled, or clang; was not built with ``-DLLVM_BINUTILS_INCDIR`` set properly. See; the instructions for the; `LLVM gold plugin <https://llvm.org/docs/GoldPlugin.html#how-to-build-it>`_. Controlling Backend Parallelism; -------------------------------; .. _parallelism:. By default, the ThinLTO link step will launch as many; threads in parallel as there are cores. If the number of; cores can't be computed for the architecture, then it will launch; ``std::thread::hardware_concurrency`` number of threads in parallel.; For machines with hyper-threading, this is the total number of; virtual cores. For some applications and machine configurations this; may be too aggressive, in which case the amount of parallelism can; be reduced to ``N`` via:. - gold:; ``-Wl,-plugin-opt,jobs=N``; - ld64:; ``-Wl,-mllvm,-threads=N``; - ld.lld, ld64.lld:; ``-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:4444,Performance,multi-thread,multi-threading,4444,"ilt with ``-DLLVM_BINUTILS_INCDIR`` set properly. See; the instructions for the; `LLVM gold plugin <https://llvm.org/docs/GoldPlugin.html#how-to-build-it>`_. Controlling Backend Parallelism; -------------------------------; .. _parallelism:. By default, the ThinLTO link step will launch as many; threads in parallel as there are cores. If the number of; cores can't be computed for the architecture, then it will launch; ``std::thread::hardware_concurrency`` number of threads in parallel.; For machines with hyper-threading, this is the total number of; virtual cores. For some applications and machine configurations this; may be too aggressive, in which case the amount of parallelism can; be reduced to ``N`` via:. - gold:; ``-Wl,-plugin-opt,jobs=N``; - ld64:; ``-Wl,-mllvm,-threads=N``; - ld.lld, ld64.lld:; ``-Wl,--thinlto-jobs=N``; - lld-link:; ``/opt:lldltojobs=N``. Other possible values for ``N`` are:. - 0:; Use one thread per physical core (default); - 1:; Use a single thread only (disable multi-threading); - all:; Use one thread per logical core (uses all hyper-threads). Incremental; -----------; .. _incremental:. ThinLTO supports fast incremental builds through the use of a cache,; which currently must be enabled through a linker option. - gold (as of LLVM 4.0):; ``-Wl,-plugin-opt,cache-dir=/path/to/cache``; - ld64 (supported since clang 3.9 and Xcode 8) and Mach-O ld64.lld (as of LLVM; 15.0):; ``-Wl,-cache_path_lto,/path/to/cache``; - ELF ld.lld (as of LLVM 5.0):; ``-Wl,--thinlto-cache-dir=/path/to/cache``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocache:/path/to/cache``. Cache Pruning; -------------. To help keep the size of the cache under control, ThinLTO supports cache; pruning. Cache pruning is supported with gold, ld64, and lld, but currently only; gold and lld allow you to control the policy with a policy string. The cache; policy must be specified with a linker option. - gold (as of LLVM 6.0):; ``-Wl,-plugin-opt,cache-policy=POLICY``; - ELF ld.lld (as of",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:4634,Performance,cache,cache,4634,"----------------------------; .. _parallelism:. By default, the ThinLTO link step will launch as many; threads in parallel as there are cores. If the number of; cores can't be computed for the architecture, then it will launch; ``std::thread::hardware_concurrency`` number of threads in parallel.; For machines with hyper-threading, this is the total number of; virtual cores. For some applications and machine configurations this; may be too aggressive, in which case the amount of parallelism can; be reduced to ``N`` via:. - gold:; ``-Wl,-plugin-opt,jobs=N``; - ld64:; ``-Wl,-mllvm,-threads=N``; - ld.lld, ld64.lld:; ``-Wl,--thinlto-jobs=N``; - lld-link:; ``/opt:lldltojobs=N``. Other possible values for ``N`` are:. - 0:; Use one thread per physical core (default); - 1:; Use a single thread only (disable multi-threading); - all:; Use one thread per logical core (uses all hyper-threads). Incremental; -----------; .. _incremental:. ThinLTO supports fast incremental builds through the use of a cache,; which currently must be enabled through a linker option. - gold (as of LLVM 4.0):; ``-Wl,-plugin-opt,cache-dir=/path/to/cache``; - ld64 (supported since clang 3.9 and Xcode 8) and Mach-O ld64.lld (as of LLVM; 15.0):; ``-Wl,-cache_path_lto,/path/to/cache``; - ELF ld.lld (as of LLVM 5.0):; ``-Wl,--thinlto-cache-dir=/path/to/cache``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocache:/path/to/cache``. Cache Pruning; -------------. To help keep the size of the cache under control, ThinLTO supports cache; pruning. Cache pruning is supported with gold, ld64, and lld, but currently only; gold and lld allow you to control the policy with a policy string. The cache; policy must be specified with a linker option. - gold (as of LLVM 6.0):; ``-Wl,-plugin-opt,cache-policy=POLICY``; - ELF ld.lld (as of LLVM 5.0), Mach-O ld64.lld (as of LLVM 15.0):; ``-Wl,--thinlto-cache-policy=POLICY``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocachepolicy:POLICY``. A policy string is a series of key-value p",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:4743,Performance,cache,cache-dir,4743,"here are cores. If the number of; cores can't be computed for the architecture, then it will launch; ``std::thread::hardware_concurrency`` number of threads in parallel.; For machines with hyper-threading, this is the total number of; virtual cores. For some applications and machine configurations this; may be too aggressive, in which case the amount of parallelism can; be reduced to ``N`` via:. - gold:; ``-Wl,-plugin-opt,jobs=N``; - ld64:; ``-Wl,-mllvm,-threads=N``; - ld.lld, ld64.lld:; ``-Wl,--thinlto-jobs=N``; - lld-link:; ``/opt:lldltojobs=N``. Other possible values for ``N`` are:. - 0:; Use one thread per physical core (default); - 1:; Use a single thread only (disable multi-threading); - all:; Use one thread per logical core (uses all hyper-threads). Incremental; -----------; .. _incremental:. ThinLTO supports fast incremental builds through the use of a cache,; which currently must be enabled through a linker option. - gold (as of LLVM 4.0):; ``-Wl,-plugin-opt,cache-dir=/path/to/cache``; - ld64 (supported since clang 3.9 and Xcode 8) and Mach-O ld64.lld (as of LLVM; 15.0):; ``-Wl,-cache_path_lto,/path/to/cache``; - ELF ld.lld (as of LLVM 5.0):; ``-Wl,--thinlto-cache-dir=/path/to/cache``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocache:/path/to/cache``. Cache Pruning; -------------. To help keep the size of the cache under control, ThinLTO supports cache; pruning. Cache pruning is supported with gold, ld64, and lld, but currently only; gold and lld allow you to control the policy with a policy string. The cache; policy must be specified with a linker option. - gold (as of LLVM 6.0):; ``-Wl,-plugin-opt,cache-policy=POLICY``; - ELF ld.lld (as of LLVM 5.0), Mach-O ld64.lld (as of LLVM 15.0):; ``-Wl,--thinlto-cache-policy=POLICY``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocachepolicy:POLICY``. A policy string is a series of key-value pairs separated by ``:`` characters.; Possible key-value pairs are:. - ``cache_size=X%``: The maximum size for the cache directo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:4762,Performance,cache,cache,4762,"here are cores. If the number of; cores can't be computed for the architecture, then it will launch; ``std::thread::hardware_concurrency`` number of threads in parallel.; For machines with hyper-threading, this is the total number of; virtual cores. For some applications and machine configurations this; may be too aggressive, in which case the amount of parallelism can; be reduced to ``N`` via:. - gold:; ``-Wl,-plugin-opt,jobs=N``; - ld64:; ``-Wl,-mllvm,-threads=N``; - ld.lld, ld64.lld:; ``-Wl,--thinlto-jobs=N``; - lld-link:; ``/opt:lldltojobs=N``. Other possible values for ``N`` are:. - 0:; Use one thread per physical core (default); - 1:; Use a single thread only (disable multi-threading); - all:; Use one thread per logical core (uses all hyper-threads). Incremental; -----------; .. _incremental:. ThinLTO supports fast incremental builds through the use of a cache,; which currently must be enabled through a linker option. - gold (as of LLVM 4.0):; ``-Wl,-plugin-opt,cache-dir=/path/to/cache``; - ld64 (supported since clang 3.9 and Xcode 8) and Mach-O ld64.lld (as of LLVM; 15.0):; ``-Wl,-cache_path_lto,/path/to/cache``; - ELF ld.lld (as of LLVM 5.0):; ``-Wl,--thinlto-cache-dir=/path/to/cache``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocache:/path/to/cache``. Cache Pruning; -------------. To help keep the size of the cache under control, ThinLTO supports cache; pruning. Cache pruning is supported with gold, ld64, and lld, but currently only; gold and lld allow you to control the policy with a policy string. The cache; policy must be specified with a linker option. - gold (as of LLVM 6.0):; ``-Wl,-plugin-opt,cache-policy=POLICY``; - ELF ld.lld (as of LLVM 5.0), Mach-O ld64.lld (as of LLVM 15.0):; ``-Wl,--thinlto-cache-policy=POLICY``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocachepolicy:POLICY``. A policy string is a series of key-value pairs separated by ``:`` characters.; Possible key-value pairs are:. - ``cache_size=X%``: The maximum size for the cache directo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:4890,Performance,cache,cache,4890,"ware_concurrency`` number of threads in parallel.; For machines with hyper-threading, this is the total number of; virtual cores. For some applications and machine configurations this; may be too aggressive, in which case the amount of parallelism can; be reduced to ``N`` via:. - gold:; ``-Wl,-plugin-opt,jobs=N``; - ld64:; ``-Wl,-mllvm,-threads=N``; - ld.lld, ld64.lld:; ``-Wl,--thinlto-jobs=N``; - lld-link:; ``/opt:lldltojobs=N``. Other possible values for ``N`` are:. - 0:; Use one thread per physical core (default); - 1:; Use a single thread only (disable multi-threading); - all:; Use one thread per logical core (uses all hyper-threads). Incremental; -----------; .. _incremental:. ThinLTO supports fast incremental builds through the use of a cache,; which currently must be enabled through a linker option. - gold (as of LLVM 4.0):; ``-Wl,-plugin-opt,cache-dir=/path/to/cache``; - ld64 (supported since clang 3.9 and Xcode 8) and Mach-O ld64.lld (as of LLVM; 15.0):; ``-Wl,-cache_path_lto,/path/to/cache``; - ELF ld.lld (as of LLVM 5.0):; ``-Wl,--thinlto-cache-dir=/path/to/cache``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocache:/path/to/cache``. Cache Pruning; -------------. To help keep the size of the cache under control, ThinLTO supports cache; pruning. Cache pruning is supported with gold, ld64, and lld, but currently only; gold and lld allow you to control the policy with a policy string. The cache; policy must be specified with a linker option. - gold (as of LLVM 6.0):; ``-Wl,-plugin-opt,cache-policy=POLICY``; - ELF ld.lld (as of LLVM 5.0), Mach-O ld64.lld (as of LLVM 15.0):; ``-Wl,--thinlto-cache-policy=POLICY``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocachepolicy:POLICY``. A policy string is a series of key-value pairs separated by ``:`` characters.; Possible key-value pairs are:. - ``cache_size=X%``: The maximum size for the cache directory is ``X`` percent; of the available space on the disk. Set to 100 to indicate no limit,; 50 to indicate that the cach",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:4947,Performance,cache,cache-dir,4947,", this is the total number of; virtual cores. For some applications and machine configurations this; may be too aggressive, in which case the amount of parallelism can; be reduced to ``N`` via:. - gold:; ``-Wl,-plugin-opt,jobs=N``; - ld64:; ``-Wl,-mllvm,-threads=N``; - ld.lld, ld64.lld:; ``-Wl,--thinlto-jobs=N``; - lld-link:; ``/opt:lldltojobs=N``. Other possible values for ``N`` are:. - 0:; Use one thread per physical core (default); - 1:; Use a single thread only (disable multi-threading); - all:; Use one thread per logical core (uses all hyper-threads). Incremental; -----------; .. _incremental:. ThinLTO supports fast incremental builds through the use of a cache,; which currently must be enabled through a linker option. - gold (as of LLVM 4.0):; ``-Wl,-plugin-opt,cache-dir=/path/to/cache``; - ld64 (supported since clang 3.9 and Xcode 8) and Mach-O ld64.lld (as of LLVM; 15.0):; ``-Wl,-cache_path_lto,/path/to/cache``; - ELF ld.lld (as of LLVM 5.0):; ``-Wl,--thinlto-cache-dir=/path/to/cache``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocache:/path/to/cache``. Cache Pruning; -------------. To help keep the size of the cache under control, ThinLTO supports cache; pruning. Cache pruning is supported with gold, ld64, and lld, but currently only; gold and lld allow you to control the policy with a policy string. The cache; policy must be specified with a linker option. - gold (as of LLVM 6.0):; ``-Wl,-plugin-opt,cache-policy=POLICY``; - ELF ld.lld (as of LLVM 5.0), Mach-O ld64.lld (as of LLVM 15.0):; ``-Wl,--thinlto-cache-policy=POLICY``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocachepolicy:POLICY``. A policy string is a series of key-value pairs separated by ``:`` characters.; Possible key-value pairs are:. - ``cache_size=X%``: The maximum size for the cache directory is ``X`` percent; of the available space on the disk. Set to 100 to indicate no limit,; 50 to indicate that the cache size will not be left over half the available; disk space. A value over 100 is inva",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:4966,Performance,cache,cache,4966,", this is the total number of; virtual cores. For some applications and machine configurations this; may be too aggressive, in which case the amount of parallelism can; be reduced to ``N`` via:. - gold:; ``-Wl,-plugin-opt,jobs=N``; - ld64:; ``-Wl,-mllvm,-threads=N``; - ld.lld, ld64.lld:; ``-Wl,--thinlto-jobs=N``; - lld-link:; ``/opt:lldltojobs=N``. Other possible values for ``N`` are:. - 0:; Use one thread per physical core (default); - 1:; Use a single thread only (disable multi-threading); - all:; Use one thread per logical core (uses all hyper-threads). Incremental; -----------; .. _incremental:. ThinLTO supports fast incremental builds through the use of a cache,; which currently must be enabled through a linker option. - gold (as of LLVM 4.0):; ``-Wl,-plugin-opt,cache-dir=/path/to/cache``; - ld64 (supported since clang 3.9 and Xcode 8) and Mach-O ld64.lld (as of LLVM; 15.0):; ``-Wl,-cache_path_lto,/path/to/cache``; - ELF ld.lld (as of LLVM 5.0):; ``-Wl,--thinlto-cache-dir=/path/to/cache``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocache:/path/to/cache``. Cache Pruning; -------------. To help keep the size of the cache under control, ThinLTO supports cache; pruning. Cache pruning is supported with gold, ld64, and lld, but currently only; gold and lld allow you to control the policy with a policy string. The cache; policy must be specified with a linker option. - gold (as of LLVM 6.0):; ``-Wl,-plugin-opt,cache-policy=POLICY``; - ELF ld.lld (as of LLVM 5.0), Mach-O ld64.lld (as of LLVM 15.0):; ``-Wl,--thinlto-cache-policy=POLICY``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocachepolicy:POLICY``. A policy string is a series of key-value pairs separated by ``:`` characters.; Possible key-value pairs are:. - ``cache_size=X%``: The maximum size for the cache directory is ``X`` percent; of the available space on the disk. Set to 100 to indicate no limit,; 50 to indicate that the cache size will not be left over half the available; disk space. A value over 100 is inva",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:5034,Performance,cache,cache,5034,"lications and machine configurations this; may be too aggressive, in which case the amount of parallelism can; be reduced to ``N`` via:. - gold:; ``-Wl,-plugin-opt,jobs=N``; - ld64:; ``-Wl,-mllvm,-threads=N``; - ld.lld, ld64.lld:; ``-Wl,--thinlto-jobs=N``; - lld-link:; ``/opt:lldltojobs=N``. Other possible values for ``N`` are:. - 0:; Use one thread per physical core (default); - 1:; Use a single thread only (disable multi-threading); - all:; Use one thread per logical core (uses all hyper-threads). Incremental; -----------; .. _incremental:. ThinLTO supports fast incremental builds through the use of a cache,; which currently must be enabled through a linker option. - gold (as of LLVM 4.0):; ``-Wl,-plugin-opt,cache-dir=/path/to/cache``; - ld64 (supported since clang 3.9 and Xcode 8) and Mach-O ld64.lld (as of LLVM; 15.0):; ``-Wl,-cache_path_lto,/path/to/cache``; - ELF ld.lld (as of LLVM 5.0):; ``-Wl,--thinlto-cache-dir=/path/to/cache``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocache:/path/to/cache``. Cache Pruning; -------------. To help keep the size of the cache under control, ThinLTO supports cache; pruning. Cache pruning is supported with gold, ld64, and lld, but currently only; gold and lld allow you to control the policy with a policy string. The cache; policy must be specified with a linker option. - gold (as of LLVM 6.0):; ``-Wl,-plugin-opt,cache-policy=POLICY``; - ELF ld.lld (as of LLVM 5.0), Mach-O ld64.lld (as of LLVM 15.0):; ``-Wl,--thinlto-cache-policy=POLICY``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocachepolicy:POLICY``. A policy string is a series of key-value pairs separated by ``:`` characters.; Possible key-value pairs are:. - ``cache_size=X%``: The maximum size for the cache directory is ``X`` percent; of the available space on the disk. Set to 100 to indicate no limit,; 50 to indicate that the cache size will not be left over half the available; disk space. A value over 100 is invalid. A value of 0 disables the percentage; size-based prun",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:5102,Performance,cache,cache,5102," of parallelism can; be reduced to ``N`` via:. - gold:; ``-Wl,-plugin-opt,jobs=N``; - ld64:; ``-Wl,-mllvm,-threads=N``; - ld.lld, ld64.lld:; ``-Wl,--thinlto-jobs=N``; - lld-link:; ``/opt:lldltojobs=N``. Other possible values for ``N`` are:. - 0:; Use one thread per physical core (default); - 1:; Use a single thread only (disable multi-threading); - all:; Use one thread per logical core (uses all hyper-threads). Incremental; -----------; .. _incremental:. ThinLTO supports fast incremental builds through the use of a cache,; which currently must be enabled through a linker option. - gold (as of LLVM 4.0):; ``-Wl,-plugin-opt,cache-dir=/path/to/cache``; - ld64 (supported since clang 3.9 and Xcode 8) and Mach-O ld64.lld (as of LLVM; 15.0):; ``-Wl,-cache_path_lto,/path/to/cache``; - ELF ld.lld (as of LLVM 5.0):; ``-Wl,--thinlto-cache-dir=/path/to/cache``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocache:/path/to/cache``. Cache Pruning; -------------. To help keep the size of the cache under control, ThinLTO supports cache; pruning. Cache pruning is supported with gold, ld64, and lld, but currently only; gold and lld allow you to control the policy with a policy string. The cache; policy must be specified with a linker option. - gold (as of LLVM 6.0):; ``-Wl,-plugin-opt,cache-policy=POLICY``; - ELF ld.lld (as of LLVM 5.0), Mach-O ld64.lld (as of LLVM 15.0):; ``-Wl,--thinlto-cache-policy=POLICY``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocachepolicy:POLICY``. A policy string is a series of key-value pairs separated by ``:`` characters.; Possible key-value pairs are:. - ``cache_size=X%``: The maximum size for the cache directory is ``X`` percent; of the available space on the disk. Set to 100 to indicate no limit,; 50 to indicate that the cache size will not be left over half the available; disk space. A value over 100 is invalid. A value of 0 disables the percentage; size-based pruning. The default is 75%. - ``cache_size_bytes=X``, ``cache_size_bytes=Xk``, ``cache_size_b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:5140,Performance,cache,cache,5140," of parallelism can; be reduced to ``N`` via:. - gold:; ``-Wl,-plugin-opt,jobs=N``; - ld64:; ``-Wl,-mllvm,-threads=N``; - ld.lld, ld64.lld:; ``-Wl,--thinlto-jobs=N``; - lld-link:; ``/opt:lldltojobs=N``. Other possible values for ``N`` are:. - 0:; Use one thread per physical core (default); - 1:; Use a single thread only (disable multi-threading); - all:; Use one thread per logical core (uses all hyper-threads). Incremental; -----------; .. _incremental:. ThinLTO supports fast incremental builds through the use of a cache,; which currently must be enabled through a linker option. - gold (as of LLVM 4.0):; ``-Wl,-plugin-opt,cache-dir=/path/to/cache``; - ld64 (supported since clang 3.9 and Xcode 8) and Mach-O ld64.lld (as of LLVM; 15.0):; ``-Wl,-cache_path_lto,/path/to/cache``; - ELF ld.lld (as of LLVM 5.0):; ``-Wl,--thinlto-cache-dir=/path/to/cache``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocache:/path/to/cache``. Cache Pruning; -------------. To help keep the size of the cache under control, ThinLTO supports cache; pruning. Cache pruning is supported with gold, ld64, and lld, but currently only; gold and lld allow you to control the policy with a policy string. The cache; policy must be specified with a linker option. - gold (as of LLVM 6.0):; ``-Wl,-plugin-opt,cache-policy=POLICY``; - ELF ld.lld (as of LLVM 5.0), Mach-O ld64.lld (as of LLVM 15.0):; ``-Wl,--thinlto-cache-policy=POLICY``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocachepolicy:POLICY``. A policy string is a series of key-value pairs separated by ``:`` characters.; Possible key-value pairs are:. - ``cache_size=X%``: The maximum size for the cache directory is ``X`` percent; of the available space on the disk. Set to 100 to indicate no limit,; 50 to indicate that the cache size will not be left over half the available; disk space. A value over 100 is invalid. A value of 0 disables the percentage; size-based pruning. The default is 75%. - ``cache_size_bytes=X``, ``cache_size_bytes=Xk``, ``cache_size_b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:5300,Performance,cache,cache,5300,"ssible values for ``N`` are:. - 0:; Use one thread per physical core (default); - 1:; Use a single thread only (disable multi-threading); - all:; Use one thread per logical core (uses all hyper-threads). Incremental; -----------; .. _incremental:. ThinLTO supports fast incremental builds through the use of a cache,; which currently must be enabled through a linker option. - gold (as of LLVM 4.0):; ``-Wl,-plugin-opt,cache-dir=/path/to/cache``; - ld64 (supported since clang 3.9 and Xcode 8) and Mach-O ld64.lld (as of LLVM; 15.0):; ``-Wl,-cache_path_lto,/path/to/cache``; - ELF ld.lld (as of LLVM 5.0):; ``-Wl,--thinlto-cache-dir=/path/to/cache``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocache:/path/to/cache``. Cache Pruning; -------------. To help keep the size of the cache under control, ThinLTO supports cache; pruning. Cache pruning is supported with gold, ld64, and lld, but currently only; gold and lld allow you to control the policy with a policy string. The cache; policy must be specified with a linker option. - gold (as of LLVM 6.0):; ``-Wl,-plugin-opt,cache-policy=POLICY``; - ELF ld.lld (as of LLVM 5.0), Mach-O ld64.lld (as of LLVM 15.0):; ``-Wl,--thinlto-cache-policy=POLICY``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocachepolicy:POLICY``. A policy string is a series of key-value pairs separated by ``:`` characters.; Possible key-value pairs are:. - ``cache_size=X%``: The maximum size for the cache directory is ``X`` percent; of the available space on the disk. Set to 100 to indicate no limit,; 50 to indicate that the cache size will not be left over half the available; disk space. A value over 100 is invalid. A value of 0 disables the percentage; size-based pruning. The default is 75%. - ``cache_size_bytes=X``, ``cache_size_bytes=Xk``, ``cache_size_bytes=Xm``,; ``cache_size_bytes=Xg``:; Sets the maximum size for the cache directory to ``X`` bytes (or KB, MB,; GB respectively). A value over the amount of available space on the disk; will be reduced to the a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:5398,Performance,cache,cache-policy,5398,"; - 1:; Use a single thread only (disable multi-threading); - all:; Use one thread per logical core (uses all hyper-threads). Incremental; -----------; .. _incremental:. ThinLTO supports fast incremental builds through the use of a cache,; which currently must be enabled through a linker option. - gold (as of LLVM 4.0):; ``-Wl,-plugin-opt,cache-dir=/path/to/cache``; - ld64 (supported since clang 3.9 and Xcode 8) and Mach-O ld64.lld (as of LLVM; 15.0):; ``-Wl,-cache_path_lto,/path/to/cache``; - ELF ld.lld (as of LLVM 5.0):; ``-Wl,--thinlto-cache-dir=/path/to/cache``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocache:/path/to/cache``. Cache Pruning; -------------. To help keep the size of the cache under control, ThinLTO supports cache; pruning. Cache pruning is supported with gold, ld64, and lld, but currently only; gold and lld allow you to control the policy with a policy string. The cache; policy must be specified with a linker option. - gold (as of LLVM 6.0):; ``-Wl,-plugin-opt,cache-policy=POLICY``; - ELF ld.lld (as of LLVM 5.0), Mach-O ld64.lld (as of LLVM 15.0):; ``-Wl,--thinlto-cache-policy=POLICY``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocachepolicy:POLICY``. A policy string is a series of key-value pairs separated by ``:`` characters.; Possible key-value pairs are:. - ``cache_size=X%``: The maximum size for the cache directory is ``X`` percent; of the available space on the disk. Set to 100 to indicate no limit,; 50 to indicate that the cache size will not be left over half the available; disk space. A value over 100 is invalid. A value of 0 disables the percentage; size-based pruning. The default is 75%. - ``cache_size_bytes=X``, ``cache_size_bytes=Xk``, ``cache_size_bytes=Xm``,; ``cache_size_bytes=Xg``:; Sets the maximum size for the cache directory to ``X`` bytes (or KB, MB,; GB respectively). A value over the amount of available space on the disk; will be reduced to the amount of available space. A value of 0 disables; the byte size-based pruning. T",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:5504,Performance,cache,cache-policy,5504,"reads). Incremental; -----------; .. _incremental:. ThinLTO supports fast incremental builds through the use of a cache,; which currently must be enabled through a linker option. - gold (as of LLVM 4.0):; ``-Wl,-plugin-opt,cache-dir=/path/to/cache``; - ld64 (supported since clang 3.9 and Xcode 8) and Mach-O ld64.lld (as of LLVM; 15.0):; ``-Wl,-cache_path_lto,/path/to/cache``; - ELF ld.lld (as of LLVM 5.0):; ``-Wl,--thinlto-cache-dir=/path/to/cache``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocache:/path/to/cache``. Cache Pruning; -------------. To help keep the size of the cache under control, ThinLTO supports cache; pruning. Cache pruning is supported with gold, ld64, and lld, but currently only; gold and lld allow you to control the policy with a policy string. The cache; policy must be specified with a linker option. - gold (as of LLVM 6.0):; ``-Wl,-plugin-opt,cache-policy=POLICY``; - ELF ld.lld (as of LLVM 5.0), Mach-O ld64.lld (as of LLVM 15.0):; ``-Wl,--thinlto-cache-policy=POLICY``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocachepolicy:POLICY``. A policy string is a series of key-value pairs separated by ``:`` characters.; Possible key-value pairs are:. - ``cache_size=X%``: The maximum size for the cache directory is ``X`` percent; of the available space on the disk. Set to 100 to indicate no limit,; 50 to indicate that the cache size will not be left over half the available; disk space. A value over 100 is invalid. A value of 0 disables the percentage; size-based pruning. The default is 75%. - ``cache_size_bytes=X``, ``cache_size_bytes=Xk``, ``cache_size_bytes=Xm``,; ``cache_size_bytes=Xg``:; Sets the maximum size for the cache directory to ``X`` bytes (or KB, MB,; GB respectively). A value over the amount of available space on the disk; will be reduced to the amount of available space. A value of 0 disables; the byte size-based pruning. The default is no byte size-based pruning. Note that ThinLTO will apply both size-based pruning policies simultaneousl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:5749,Performance,cache,cache,5749,"o/cache``; - ld64 (supported since clang 3.9 and Xcode 8) and Mach-O ld64.lld (as of LLVM; 15.0):; ``-Wl,-cache_path_lto,/path/to/cache``; - ELF ld.lld (as of LLVM 5.0):; ``-Wl,--thinlto-cache-dir=/path/to/cache``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocache:/path/to/cache``. Cache Pruning; -------------. To help keep the size of the cache under control, ThinLTO supports cache; pruning. Cache pruning is supported with gold, ld64, and lld, but currently only; gold and lld allow you to control the policy with a policy string. The cache; policy must be specified with a linker option. - gold (as of LLVM 6.0):; ``-Wl,-plugin-opt,cache-policy=POLICY``; - ELF ld.lld (as of LLVM 5.0), Mach-O ld64.lld (as of LLVM 15.0):; ``-Wl,--thinlto-cache-policy=POLICY``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocachepolicy:POLICY``. A policy string is a series of key-value pairs separated by ``:`` characters.; Possible key-value pairs are:. - ``cache_size=X%``: The maximum size for the cache directory is ``X`` percent; of the available space on the disk. Set to 100 to indicate no limit,; 50 to indicate that the cache size will not be left over half the available; disk space. A value over 100 is invalid. A value of 0 disables the percentage; size-based pruning. The default is 75%. - ``cache_size_bytes=X``, ``cache_size_bytes=Xk``, ``cache_size_bytes=Xm``,; ``cache_size_bytes=Xg``:; Sets the maximum size for the cache directory to ``X`` bytes (or KB, MB,; GB respectively). A value over the amount of available space on the disk; will be reduced to the amount of available space. A value of 0 disables; the byte size-based pruning. The default is no byte size-based pruning. Note that ThinLTO will apply both size-based pruning policies simultaneously,; and changing one does not affect the other. For example, a policy of; ``cache_size_bytes=1g`` on its own will cause both the 1GB and default 75%; policies to be applied unless the default ``cache_size`` is overridden. - ``cache_size_fil",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:5877,Performance,cache,cache,5877,"o,/path/to/cache``; - ELF ld.lld (as of LLVM 5.0):; ``-Wl,--thinlto-cache-dir=/path/to/cache``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocache:/path/to/cache``. Cache Pruning; -------------. To help keep the size of the cache under control, ThinLTO supports cache; pruning. Cache pruning is supported with gold, ld64, and lld, but currently only; gold and lld allow you to control the policy with a policy string. The cache; policy must be specified with a linker option. - gold (as of LLVM 6.0):; ``-Wl,-plugin-opt,cache-policy=POLICY``; - ELF ld.lld (as of LLVM 5.0), Mach-O ld64.lld (as of LLVM 15.0):; ``-Wl,--thinlto-cache-policy=POLICY``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocachepolicy:POLICY``. A policy string is a series of key-value pairs separated by ``:`` characters.; Possible key-value pairs are:. - ``cache_size=X%``: The maximum size for the cache directory is ``X`` percent; of the available space on the disk. Set to 100 to indicate no limit,; 50 to indicate that the cache size will not be left over half the available; disk space. A value over 100 is invalid. A value of 0 disables the percentage; size-based pruning. The default is 75%. - ``cache_size_bytes=X``, ``cache_size_bytes=Xk``, ``cache_size_bytes=Xm``,; ``cache_size_bytes=Xg``:; Sets the maximum size for the cache directory to ``X`` bytes (or KB, MB,; GB respectively). A value over the amount of available space on the disk; will be reduced to the amount of available space. A value of 0 disables; the byte size-based pruning. The default is no byte size-based pruning. Note that ThinLTO will apply both size-based pruning policies simultaneously,; and changing one does not affect the other. For example, a policy of; ``cache_size_bytes=1g`` on its own will cause both the 1GB and default 75%; policies to be applied unless the default ``cache_size`` is overridden. - ``cache_size_files=X``:; Set the maximum number of files in the cache directory. Set to 0 to indicate; no limit. The default is 1000000 ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:6182,Performance,cache,cache,6182,"; pruning. Cache pruning is supported with gold, ld64, and lld, but currently only; gold and lld allow you to control the policy with a policy string. The cache; policy must be specified with a linker option. - gold (as of LLVM 6.0):; ``-Wl,-plugin-opt,cache-policy=POLICY``; - ELF ld.lld (as of LLVM 5.0), Mach-O ld64.lld (as of LLVM 15.0):; ``-Wl,--thinlto-cache-policy=POLICY``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocachepolicy:POLICY``. A policy string is a series of key-value pairs separated by ``:`` characters.; Possible key-value pairs are:. - ``cache_size=X%``: The maximum size for the cache directory is ``X`` percent; of the available space on the disk. Set to 100 to indicate no limit,; 50 to indicate that the cache size will not be left over half the available; disk space. A value over 100 is invalid. A value of 0 disables the percentage; size-based pruning. The default is 75%. - ``cache_size_bytes=X``, ``cache_size_bytes=Xk``, ``cache_size_bytes=Xm``,; ``cache_size_bytes=Xg``:; Sets the maximum size for the cache directory to ``X`` bytes (or KB, MB,; GB respectively). A value over the amount of available space on the disk; will be reduced to the amount of available space. A value of 0 disables; the byte size-based pruning. The default is no byte size-based pruning. Note that ThinLTO will apply both size-based pruning policies simultaneously,; and changing one does not affect the other. For example, a policy of; ``cache_size_bytes=1g`` on its own will cause both the 1GB and default 75%; policies to be applied unless the default ``cache_size`` is overridden. - ``cache_size_files=X``:; Set the maximum number of files in the cache directory. Set to 0 to indicate; no limit. The default is 1000000 files. - ``prune_after=Xs``, ``prune_after=Xm``, ``prune_after=Xh``: Sets the; expiration time for cache files to ``X`` seconds (or minutes, hours; respectively). When a file hasn't been accessed for ``prune_after`` seconds,; it is removed from the cache. A value of",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:6808,Performance,cache,cache,6808," of the available space on the disk. Set to 100 to indicate no limit,; 50 to indicate that the cache size will not be left over half the available; disk space. A value over 100 is invalid. A value of 0 disables the percentage; size-based pruning. The default is 75%. - ``cache_size_bytes=X``, ``cache_size_bytes=Xk``, ``cache_size_bytes=Xm``,; ``cache_size_bytes=Xg``:; Sets the maximum size for the cache directory to ``X`` bytes (or KB, MB,; GB respectively). A value over the amount of available space on the disk; will be reduced to the amount of available space. A value of 0 disables; the byte size-based pruning. The default is no byte size-based pruning. Note that ThinLTO will apply both size-based pruning policies simultaneously,; and changing one does not affect the other. For example, a policy of; ``cache_size_bytes=1g`` on its own will cause both the 1GB and default 75%; policies to be applied unless the default ``cache_size`` is overridden. - ``cache_size_files=X``:; Set the maximum number of files in the cache directory. Set to 0 to indicate; no limit. The default is 1000000 files. - ``prune_after=Xs``, ``prune_after=Xm``, ``prune_after=Xh``: Sets the; expiration time for cache files to ``X`` seconds (or minutes, hours; respectively). When a file hasn't been accessed for ``prune_after`` seconds,; it is removed from the cache. A value of 0 disables the expiration-based; pruning. The default is 1 week. - ``prune_interval=Xs``, ``prune_interval=Xm``, ``prune_interval=Xh``:; Sets the pruning interval to ``X`` seconds (or minutes, hours; respectively). This is intended to be used to avoid scanning the directory; too often. It does not impact the decision of which files to prune. A; value of 0 forces the scan to occur. The default is every 20 minutes. Clang Bootstrap; ---------------. To `bootstrap clang/LLVM <https://llvm.org/docs/AdvancedBuilds.html#bootstrap-builds>`_; with ThinLTO, follow these steps:. 1. The host compiler_ must be a version of clang that support",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:6979,Performance,cache,cache,6979,"valid. A value of 0 disables the percentage; size-based pruning. The default is 75%. - ``cache_size_bytes=X``, ``cache_size_bytes=Xk``, ``cache_size_bytes=Xm``,; ``cache_size_bytes=Xg``:; Sets the maximum size for the cache directory to ``X`` bytes (or KB, MB,; GB respectively). A value over the amount of available space on the disk; will be reduced to the amount of available space. A value of 0 disables; the byte size-based pruning. The default is no byte size-based pruning. Note that ThinLTO will apply both size-based pruning policies simultaneously,; and changing one does not affect the other. For example, a policy of; ``cache_size_bytes=1g`` on its own will cause both the 1GB and default 75%; policies to be applied unless the default ``cache_size`` is overridden. - ``cache_size_files=X``:; Set the maximum number of files in the cache directory. Set to 0 to indicate; no limit. The default is 1000000 files. - ``prune_after=Xs``, ``prune_after=Xm``, ``prune_after=Xh``: Sets the; expiration time for cache files to ``X`` seconds (or minutes, hours; respectively). When a file hasn't been accessed for ``prune_after`` seconds,; it is removed from the cache. A value of 0 disables the expiration-based; pruning. The default is 1 week. - ``prune_interval=Xs``, ``prune_interval=Xm``, ``prune_interval=Xh``:; Sets the pruning interval to ``X`` seconds (or minutes, hours; respectively). This is intended to be used to avoid scanning the directory; too often. It does not impact the decision of which files to prune. A; value of 0 forces the scan to occur. The default is every 20 minutes. Clang Bootstrap; ---------------. To `bootstrap clang/LLVM <https://llvm.org/docs/AdvancedBuilds.html#bootstrap-builds>`_; with ThinLTO, follow these steps:. 1. The host compiler_ must be a version of clang that supports ThinLTO.; #. The host linker_ must support ThinLTO (and in the case of gold, must be; `configured with plugins enabled <https://llvm.org/docs/GoldPlugin.html>`_).; #. Use the foll",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:7129,Performance,cache,cache,7129,"bytes=Xk``, ``cache_size_bytes=Xm``,; ``cache_size_bytes=Xg``:; Sets the maximum size for the cache directory to ``X`` bytes (or KB, MB,; GB respectively). A value over the amount of available space on the disk; will be reduced to the amount of available space. A value of 0 disables; the byte size-based pruning. The default is no byte size-based pruning. Note that ThinLTO will apply both size-based pruning policies simultaneously,; and changing one does not affect the other. For example, a policy of; ``cache_size_bytes=1g`` on its own will cause both the 1GB and default 75%; policies to be applied unless the default ``cache_size`` is overridden. - ``cache_size_files=X``:; Set the maximum number of files in the cache directory. Set to 0 to indicate; no limit. The default is 1000000 files. - ``prune_after=Xs``, ``prune_after=Xm``, ``prune_after=Xh``: Sets the; expiration time for cache files to ``X`` seconds (or minutes, hours; respectively). When a file hasn't been accessed for ``prune_after`` seconds,; it is removed from the cache. A value of 0 disables the expiration-based; pruning. The default is 1 week. - ``prune_interval=Xs``, ``prune_interval=Xm``, ``prune_interval=Xh``:; Sets the pruning interval to ``X`` seconds (or minutes, hours; respectively). This is intended to be used to avoid scanning the directory; too often. It does not impact the decision of which files to prune. A; value of 0 forces the scan to occur. The default is every 20 minutes. Clang Bootstrap; ---------------. To `bootstrap clang/LLVM <https://llvm.org/docs/AdvancedBuilds.html#bootstrap-builds>`_; with ThinLTO, follow these steps:. 1. The host compiler_ must be a version of clang that supports ThinLTO.; #. The host linker_ must support ThinLTO (and in the case of gold, must be; `configured with plugins enabled <https://llvm.org/docs/GoldPlugin.html>`_).; #. Use the following additional `CMake variables; <https://llvm.org/docs/CMake.html#options-and-variables>`_; when configuring the bootstrap",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:9345,Performance,scalab,scalable-and-incremental-lto,9345,"e used to avoid scanning the directory; too often. It does not impact the decision of which files to prune. A; value of 0 forces the scan to occur. The default is every 20 minutes. Clang Bootstrap; ---------------. To `bootstrap clang/LLVM <https://llvm.org/docs/AdvancedBuilds.html#bootstrap-builds>`_; with ThinLTO, follow these steps:. 1. The host compiler_ must be a version of clang that supports ThinLTO.; #. The host linker_ must support ThinLTO (and in the case of gold, must be; `configured with plugins enabled <https://llvm.org/docs/GoldPlugin.html>`_).; #. Use the following additional `CMake variables; <https://llvm.org/docs/CMake.html#options-and-variables>`_; when configuring the bootstrap compiler build:. * ``-DLLVM_ENABLE_LTO=Thin``; * ``-DCMAKE_C_COMPILER=/path/to/host/clang``; * ``-DCMAKE_CXX_COMPILER=/path/to/host/clang++``; * ``-DCMAKE_RANLIB=/path/to/host/llvm-ranlib``; * ``-DCMAKE_AR=/path/to/host/llvm-ar``. Or, on Windows:. * ``-DLLVM_ENABLE_LTO=Thin``; * ``-DCMAKE_C_COMPILER=/path/to/host/clang-cl.exe``; * ``-DCMAKE_CXX_COMPILER=/path/to/host/clang-cl.exe``; * ``-DCMAKE_LINKER=/path/to/host/lld-link.exe``; * ``-DCMAKE_RANLIB=/path/to/host/llvm-ranlib.exe``; * ``-DCMAKE_AR=/path/to/host/llvm-ar.exe``. #. To use additional linker arguments for controlling the backend; parallelism_ or enabling incremental_ builds of the bootstrap compiler,; after configuring the build, modify the resulting CMakeCache.txt file in the; build directory. Specify any additional linker options after; ``CMAKE_EXE_LINKER_FLAGS:STRING=``. Note the configure may fail if; linker plugin options are instead specified directly in the previous step. The ``BOOTSTRAP_LLVM_ENABLE_LTO=Thin`` will enable ThinLTO for stage 2 and; stage 3 in case the compiler used for stage 1 does not support the ThinLTO; option. More Information; ================. * From LLVM project blog:; `ThinLTO: Scalable and Incremental LTO; <http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html>`_; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:7393,Safety,avoid,avoid,7393,"ing. The default is no byte size-based pruning. Note that ThinLTO will apply both size-based pruning policies simultaneously,; and changing one does not affect the other. For example, a policy of; ``cache_size_bytes=1g`` on its own will cause both the 1GB and default 75%; policies to be applied unless the default ``cache_size`` is overridden. - ``cache_size_files=X``:; Set the maximum number of files in the cache directory. Set to 0 to indicate; no limit. The default is 1000000 files. - ``prune_after=Xs``, ``prune_after=Xm``, ``prune_after=Xh``: Sets the; expiration time for cache files to ``X`` seconds (or minutes, hours; respectively). When a file hasn't been accessed for ``prune_after`` seconds,; it is removed from the cache. A value of 0 disables the expiration-based; pruning. The default is 1 week. - ``prune_interval=Xs``, ``prune_interval=Xm``, ``prune_interval=Xh``:; Sets the pruning interval to ``X`` seconds (or minutes, hours; respectively). This is intended to be used to avoid scanning the directory; too often. It does not impact the decision of which files to prune. A; value of 0 forces the scan to occur. The default is every 20 minutes. Clang Bootstrap; ---------------. To `bootstrap clang/LLVM <https://llvm.org/docs/AdvancedBuilds.html#bootstrap-builds>`_; with ThinLTO, follow these steps:. 1. The host compiler_ must be a version of clang that supports ThinLTO.; #. The host linker_ must support ThinLTO (and in the case of gold, must be; `configured with plugins enabled <https://llvm.org/docs/GoldPlugin.html>`_).; #. Use the following additional `CMake variables; <https://llvm.org/docs/CMake.html#options-and-variables>`_; when configuring the bootstrap compiler build:. * ``-DLLVM_ENABLE_LTO=Thin``; * ``-DCMAKE_C_COMPILER=/path/to/host/clang``; * ``-DCMAKE_CXX_COMPILER=/path/to/host/clang++``; * ``-DCMAKE_RANLIB=/path/to/host/llvm-ranlib``; * ``-DCMAKE_AR=/path/to/host/llvm-ar``. Or, on Windows:. * ``-DLLVM_ENABLE_LTO=Thin``; * ``-DCMAKE_C_COMPILER=/path/",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:7067,Security,access,accessed,7067,"bytes=Xk``, ``cache_size_bytes=Xm``,; ``cache_size_bytes=Xg``:; Sets the maximum size for the cache directory to ``X`` bytes (or KB, MB,; GB respectively). A value over the amount of available space on the disk; will be reduced to the amount of available space. A value of 0 disables; the byte size-based pruning. The default is no byte size-based pruning. Note that ThinLTO will apply both size-based pruning policies simultaneously,; and changing one does not affect the other. For example, a policy of; ``cache_size_bytes=1g`` on its own will cause both the 1GB and default 75%; policies to be applied unless the default ``cache_size`` is overridden. - ``cache_size_files=X``:; Set the maximum number of files in the cache directory. Set to 0 to indicate; no limit. The default is 1000000 files. - ``prune_after=Xs``, ``prune_after=Xm``, ``prune_after=Xh``: Sets the; expiration time for cache files to ``X`` seconds (or minutes, hours; respectively). When a file hasn't been accessed for ``prune_after`` seconds,; it is removed from the cache. A value of 0 disables the expiration-based; pruning. The default is 1 week. - ``prune_interval=Xs``, ``prune_interval=Xm``, ``prune_interval=Xh``:; Sets the pruning interval to ``X`` seconds (or minutes, hours; respectively). This is intended to be used to avoid scanning the directory; too often. It does not impact the decision of which files to prune. A; value of 0 forces the scan to occur. The default is every 20 minutes. Clang Bootstrap; ---------------. To `bootstrap clang/LLVM <https://llvm.org/docs/AdvancedBuilds.html#bootstrap-builds>`_; with ThinLTO, follow these steps:. 1. The host compiler_ must be a version of clang that supports ThinLTO.; #. The host linker_ must support ThinLTO (and in the case of gold, must be; `configured with plugins enabled <https://llvm.org/docs/GoldPlugin.html>`_).; #. Use the following additional `CMake variables; <https://llvm.org/docs/CMake.html#options-and-variables>`_; when configuring the bootstrap",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:4489,Testability,log,logical,4489,"ilt with ``-DLLVM_BINUTILS_INCDIR`` set properly. See; the instructions for the; `LLVM gold plugin <https://llvm.org/docs/GoldPlugin.html#how-to-build-it>`_. Controlling Backend Parallelism; -------------------------------; .. _parallelism:. By default, the ThinLTO link step will launch as many; threads in parallel as there are cores. If the number of; cores can't be computed for the architecture, then it will launch; ``std::thread::hardware_concurrency`` number of threads in parallel.; For machines with hyper-threading, this is the total number of; virtual cores. For some applications and machine configurations this; may be too aggressive, in which case the amount of parallelism can; be reduced to ``N`` via:. - gold:; ``-Wl,-plugin-opt,jobs=N``; - ld64:; ``-Wl,-mllvm,-threads=N``; - ld.lld, ld64.lld:; ``-Wl,--thinlto-jobs=N``; - lld-link:; ``/opt:lldltojobs=N``. Other possible values for ``N`` are:. - 0:; Use one thread per physical core (default); - 1:; Use a single thread only (disable multi-threading); - all:; Use one thread per logical core (uses all hyper-threads). Incremental; -----------; .. _incremental:. ThinLTO supports fast incremental builds through the use of a cache,; which currently must be enabled through a linker option. - gold (as of LLVM 4.0):; ``-Wl,-plugin-opt,cache-dir=/path/to/cache``; - ld64 (supported since clang 3.9 and Xcode 8) and Mach-O ld64.lld (as of LLVM; 15.0):; ``-Wl,-cache_path_lto,/path/to/cache``; - ELF ld.lld (as of LLVM 5.0):; ``-Wl,--thinlto-cache-dir=/path/to/cache``; - COFF lld-link (as of LLVM 6.0):; ``/lldltocache:/path/to/cache``. Cache Pruning; -------------. To help keep the size of the cache under control, ThinLTO supports cache; pruning. Cache pruning is supported with gold, ld64, and lld, but currently only; gold and lld allow you to control the policy with a policy string. The cache; policy must be specified with a linker option. - gold (as of LLVM 6.0):; ``-Wl,-plugin-opt,cache-policy=POLICY``; - ELF ld.lld (as of",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst:2481,Usability,simpl,simply,2481,"ill in progress, results in the blog post show that; ThinLTO already performs well compared to LTO, in many cases matching; the performance improvement. Current Status; ==============. Clang/LLVM; ----------; .. _compiler:. The 3.9 release of clang includes ThinLTO support. However, ThinLTO; is under active development, and new features, improvements and bugfixes; are being added for the next release. For the latest ThinLTO support,; `build a recent version of clang and LLVM; <https://llvm.org/docs/CMake.html>`_. Linkers; -------; .. _linkers:; .. _linker:. ThinLTO is currently supported for the following linkers:. - **gold (via the gold-plugin)**:; Similar to monolithic LTO, this requires using; a `gold linker configured with plugins enabled; <https://llvm.org/docs/GoldPlugin.html>`_.; - **ld64**:; Starting with `Xcode 8 <https://developer.apple.com/xcode/>`_.; - **lld**:; Starting with r284050 for ELF, r298942 for COFF. Usage; =====. Basic; -----. To utilize ThinLTO, simply add the -flto=thin option to compile and link. E.g. .. code-block:: console. % clang -flto=thin -O2 file1.c file2.c -c; % clang -flto=thin -O2 file1.o file2.o -o a.out. When using lld-link, the -flto option need only be added to the compile step:. .. code-block:: console. % clang-cl -flto=thin -O2 -c file1.c file2.c; % lld-link /out:a.exe file1.obj file2.obj. As mentioned earlier, by default the linkers will launch the ThinLTO backend; threads in parallel, passing the resulting native object files back to the; linker for the final native link. As such, the usage model is the same as; non-LTO. With gold, if you see an error during the link of the form:. .. code-block:: console. /usr/bin/ld: error: /path/to/clang/bin/../lib/LLVMgold.so: could not load plugin library: /path/to/clang/bin/../lib/LLVMgold.so: cannot open shared object file: No such file or directory. Then either gold was not configured with plugins enabled, or clang; was not built with ``-DLLVM_BINUTILS_INCDIR`` set properly. See; th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThinLTO.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThinLTO.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:13012,Availability,error,error,13012,"utex mu;; int a GUARDED_BY(mu);. public:; Mutex* getMu() RETURN_CAPABILITY(mu) { return &mu; }. // analysis knows that getMu() == mu; void clear() REQUIRES(getMu()) { a = 0; }; };. ACQUIRED_BEFORE(...), ACQUIRED_AFTER(...); -----------------------------------------. ``ACQUIRED_BEFORE`` and ``ACQUIRED_AFTER`` are attributes on member; declarations, specifically declarations of mutexes or other capabilities.; These declarations enforce a particular order in which the mutexes must be; acquired, in order to prevent deadlock. .. code-block:: c++. Mutex m1;; Mutex m2 ACQUIRED_AFTER(m1);. // Alternative declaration; // Mutex m2;; // Mutex m1 ACQUIRED_BEFORE(m2);. void foo() {; m2.Lock();; m1.Lock(); // Warning! m2 must be acquired after m1.; m1.Unlock();; m2.Unlock();; }. CAPABILITY(<string>); --------------------. *Previously*: ``LOCKABLE``. ``CAPABILITY`` is an attribute on classes, which specifies that objects of the; class can be used as a capability. The string argument specifies the kind of; capability in error messages, e.g. ``""mutex""``. See the ``Container`` example; given above, or the ``Mutex`` class in :ref:`mutexheader`. SCOPED_CAPABILITY; -----------------. *Previously*: ``SCOPED_LOCKABLE``. ``SCOPED_CAPABILITY`` is an attribute on classes that implement RAII-style; locking, in which a capability is acquired in the constructor, and released in; the destructor. Such classes require special handling because the constructor; and destructor refer to the capability via different names; see the; ``MutexLocker`` class in :ref:`mutexheader`, below. Scoped capabilities are treated as capabilities that are implicitly acquired; on construction and released on destruction. They are associated with; the set of (regular) capabilities named in thread safety attributes on the; constructor or function returning them by value (using C++17 guaranteed copy; elision). Acquire-type attributes on other member functions are treated as; applying to that set of associated capabilities,",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:14437,Availability,failure,failure,14437,"estructor. Such classes require special handling because the constructor; and destructor refer to the capability via different names; see the; ``MutexLocker`` class in :ref:`mutexheader`, below. Scoped capabilities are treated as capabilities that are implicitly acquired; on construction and released on destruction. They are associated with; the set of (regular) capabilities named in thread safety attributes on the; constructor or function returning them by value (using C++17 guaranteed copy; elision). Acquire-type attributes on other member functions are treated as; applying to that set of associated capabilities, while ``RELEASE`` implies that; a function releases all associated capabilities in whatever mode they're held. TRY_ACQUIRE(<bool>, ...), TRY_ACQUIRE_SHARED(<bool>, ...); ---------------------------------------------------------. *Previously:* ``EXCLUSIVE_TRYLOCK_FUNCTION``, ``SHARED_TRYLOCK_FUNCTION``. These are attributes on a function or method that tries to acquire the given; capability, and returns a boolean value indicating success or failure.; The first argument must be ``true`` or ``false``, to specify which return value; indicates success, and the remaining arguments are interpreted in the same way; as ``ACQUIRE``. See :ref:`mutexheader`, below, for example uses. Because the analysis doesn't support conditional locking, a capability is; treated as acquired after the first branch on the return value of a try-acquire; function. .. code-block:: c++. Mutex mu;; int a GUARDED_BY(mu);. void foo() {; bool success = mu.TryLock();; a = 0; // Warning, mu is not locked.; if (success) {; a = 0; // Ok.; mu.Unlock();; } else {; a = 0; // Warning, mu is not locked.; }; }. ASSERT_CAPABILITY(...) and ASSERT_SHARED_CAPABILITY(...); --------------------------------------------------------. *Previously:* ``ASSERT_EXCLUSIVE_LOCK``, ``ASSERT_SHARED_LOCK``. These are attributes on a function or method which asserts the calling thread; already holds the given capability, ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:20295,Availability,error,error,20295,"fety attributes contain ordinary C++ expressions, and thus follow; ordinary C++ scoping rules. In particular, this means that mutexes and other; capabilities must be declared before they can be used in an attribute.; Use-before-declaration is okay within a single class, because attributes are; parsed at the same time as method bodies. (C++ delays parsing of method bodies; until the end of the class.) However, use-before-declaration is not allowed; between classes, as illustrated below. .. code-block:: c++. class Foo;. class Bar {; void bar(Foo* f) REQUIRES(f->mu); // Error: mu undeclared.; };. class Foo {; Mutex mu;; };. Private Mutexes; ---------------. Good software engineering practice dictates that mutexes should be private; members, because the locking mechanism used by a thread-safe class is part of; its internal implementation. However, private mutexes can sometimes leak into; the public interface of a class.; Thread safety attributes follow normal C++ access restrictions, so if ``mu``; is a private member of ``c``, then it is an error to write ``c.mu`` in an; attribute. One workaround is to (ab)use the ``RETURN_CAPABILITY`` attribute to provide a; public *name* for a private mutex, without actually exposing the underlying; mutex. For example:. .. code-block:: c++. class MyClass {; private:; Mutex mu;. public:; // For thread safety analysis only. Does not need to be defined.; Mutex* getMu() RETURN_CAPABILITY(mu);. void doSomething() REQUIRES(mu);; };. void doSomethingTwice(MyClass& c) REQUIRES(c.getMu()) {; // The analysis thinks that c.getMu() == c.mu; c.doSomething();; c.doSomething();; }. In the above example, ``doSomethingTwice()`` is an external routine that; requires ``c.mu`` to be locked, which cannot be declared directly because ``mu``; is private. This pattern is discouraged because it; violates encapsulation, but it is sometimes necessary, especially when adding; annotations to an existing code base. The workaround is to define ``getMu()``; as a fake",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:28300,Availability,failure,failure,28300,"n annotated interface for mutexes.; // These methods can be implemented to use any internal mutex implementation.; class CAPABILITY(""mutex"") Mutex {; public:; // Acquire/lock this mutex exclusively. Only one thread can have exclusive; // access at any one time. Write operations to guarded data require an; // exclusive lock.; void Lock() ACQUIRE();. // Acquire/lock this mutex for read operations, which require only a shared; // lock. This assumes a multiple-reader, single writer semantics. Multiple; // threads may acquire the mutex simultaneously as readers, but a writer; // must wait for all of them to release the mutex before it can acquire it; // exclusively.; void ReaderLock() ACQUIRE_SHARED();. // Release/unlock an exclusive mutex.; void Unlock() RELEASE();. // Release/unlock a shared mutex.; void ReaderUnlock() RELEASE_SHARED();. // Generic unlock, can unlock exclusive and shared mutexes.; void GenericUnlock() RELEASE_GENERIC();. // Try to acquire the mutex. Returns true on success, and false on failure.; bool TryLock() TRY_ACQUIRE(true);. // Try to acquire the mutex for read operations.; bool ReaderTryLock() TRY_ACQUIRE_SHARED(true);. // Assert that this mutex is currently held by the calling thread.; void AssertHeld() ASSERT_CAPABILITY(this);. // Assert that is mutex is currently held for read operations.; void AssertReaderHeld() ASSERT_SHARED_CAPABILITY(this);. // For negative capabilities.; const Mutex& operator!() const { return *this; }; };. // Tag types for selecting a constructor.; struct adopt_lock_t {} inline constexpr adopt_lock = {};; struct defer_lock_t {} inline constexpr defer_lock = {};; struct shared_lock_t {} inline constexpr shared_lock = {};. // MutexLocker is an RAII class that acquires a mutex in its constructor, and; // releases it in its destructor.; class SCOPED_CAPABILITY MutexLocker {; private:; Mutex* mut;; bool locked;. public:; // Acquire mu, implicitly acquire *this and associate it with mu.; MutexLocker(Mutex *mu) ACQUIRE(mu) : mu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:379,Deployability,deploy,deployed,379,"; ======================; Thread Safety Analysis; ======================. Introduction; ============. Clang Thread Safety Analysis is a C++ language extension which warns about; potential race conditions in code. The analysis is completely static (i.e.; compile-time); there is no run-time overhead. The analysis is still; under active development, but it is mature enough to be deployed in an; industrial setting. It is being developed by Google, in collaboration with; CERT/SEI, and is used extensively in Google's internal code base. Thread safety analysis works very much like a type system for multi-threaded; programs. In addition to declaring the *type* of data (e.g. ``int``, ``float``,; etc.), the programmer can (optionally) declare how access to that data is; controlled in a multi-threaded environment. For example, if ``foo`` is; *guarded by* the mutex ``mu``, then the analysis will issue a warning whenever; a piece of code reads or writes to ``foo`` without first locking ``mu``.; Similarly, if there are particular routines that should only be called by; the GUI thread, then the analysis will warn if other threads call those; routines. Getting Started; ----------------. .. code-block:: c++. #include ""mutex.h"". class BankAccount {; private:; Mutex mu;; int balance GUARDED_BY(mu);. void depositImpl(int amount) {; balance += amount; // WARNING! Cannot write balance without locking mu.; }. void withdrawImpl(int amount) REQUIRES(mu) {; balance -= amount; // OK. Caller must have locked mu.; }. public:; void withdraw(int amount) {; mu.Lock();; withdrawImpl(amount); // OK. We've locked mu.; } // WARNING! Failed to unlock mu. void transferFrom(BankAccount& b, int amount) {; mu.Lock();; b.withdrawImpl(amount); // WARNING! Calling withdrawImpl() requires locking b.mu.; depositImpl(amount); // OK. depositImpl() has no requirements.; mu.Unlock();; }; };. This example demonstrates the basic concepts behind the analysis. The; ``GUARDED_BY`` attribute declares that a thread must lo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:3969,Deployability,release,release,3969,"th double locks, and double unlocks. A function is allowed to; acquire a lock without releasing it, (or vice versa), but it must be annotated; as such (using ``ACQUIRE``/``RELEASE``). Running The Analysis; --------------------. To run the analysis, simply compile with the ``-Wthread-safety`` flag, e.g. .. code-block:: bash. clang -c -Wthread-safety example.cpp. Note that this example assumes the presence of a suitably annotated; :ref:`mutexheader` that declares which methods perform locking,; unlocking, and so on. Basic Concepts: Capabilities; ============================. Thread safety analysis provides a way of protecting *resources* with; *capabilities*. A resource is either a data member, or a function/method; that provides access to some underlying resource. The analysis ensures that; the calling thread cannot access the *resource* (i.e. call the function, or; read/write the data) unless it has the *capability* to do so. Capabilities are associated with named C++ objects which declare specific; methods to acquire and release the capability. The name of the object serves; to identify the capability. The most common example is a mutex. For example,; if ``mu`` is a mutex, then calling ``mu.Lock()`` causes the calling thread; to acquire the capability to access data that is protected by ``mu``. Similarly,; calling ``mu.Unlock()`` releases that capability. A thread may hold a capability either *exclusively* or *shared*. An exclusive; capability can be held by only one thread at a time, while a shared capability; can be held by many threads at the same time. This mechanism enforces a; multiple-reader, single-writer pattern. Write operations to protected data; require exclusive access, while read operations require only shared access. At any given moment during program execution, a thread holds a specific set of; capabilities (e.g. the set of mutexes that it has locked.) These act like keys; or tokens that allow the thread to access a given resource. Just like physica",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:4284,Deployability,release,releases,4284,"pp. Note that this example assumes the presence of a suitably annotated; :ref:`mutexheader` that declares which methods perform locking,; unlocking, and so on. Basic Concepts: Capabilities; ============================. Thread safety analysis provides a way of protecting *resources* with; *capabilities*. A resource is either a data member, or a function/method; that provides access to some underlying resource. The analysis ensures that; the calling thread cannot access the *resource* (i.e. call the function, or; read/write the data) unless it has the *capability* to do so. Capabilities are associated with named C++ objects which declare specific; methods to acquire and release the capability. The name of the object serves; to identify the capability. The most common example is a mutex. For example,; if ``mu`` is a mutex, then calling ``mu.Lock()`` causes the calling thread; to acquire the capability to access data that is protected by ``mu``. Similarly,; calling ``mu.Unlock()`` releases that capability. A thread may hold a capability either *exclusively* or *shared*. An exclusive; capability can be held by only one thread at a time, while a shared capability; can be held by many threads at the same time. This mechanism enforces a; multiple-reader, single-writer pattern. Write operations to protected data; require exclusive access, while read operations require only shared access. At any given moment during program execution, a thread holds a specific set of; capabilities (e.g. the set of mutexes that it has locked.) These act like keys; or tokens that allow the thread to access a given resource. Just like physical; security keys, a thread cannot make copy of a capability, nor can it destroy; one. A thread can only release a capability to another thread, or acquire one; from another thread. The annotations are deliberately agnostic about the; exact mechanism used to acquire and release capabilities; it assumes that the; underlying implementation (e.g. the Mutex imple",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:5035,Deployability,release,release,5035,"mmon example is a mutex. For example,; if ``mu`` is a mutex, then calling ``mu.Lock()`` causes the calling thread; to acquire the capability to access data that is protected by ``mu``. Similarly,; calling ``mu.Unlock()`` releases that capability. A thread may hold a capability either *exclusively* or *shared*. An exclusive; capability can be held by only one thread at a time, while a shared capability; can be held by many threads at the same time. This mechanism enforces a; multiple-reader, single-writer pattern. Write operations to protected data; require exclusive access, while read operations require only shared access. At any given moment during program execution, a thread holds a specific set of; capabilities (e.g. the set of mutexes that it has locked.) These act like keys; or tokens that allow the thread to access a given resource. Just like physical; security keys, a thread cannot make copy of a capability, nor can it destroy; one. A thread can only release a capability to another thread, or acquire one; from another thread. The annotations are deliberately agnostic about the; exact mechanism used to acquire and release capabilities; it assumes that the; underlying implementation (e.g. the Mutex implementation) does the handoff in; an appropriate manner. The set of capabilities that are actually held by a given thread at a given; point in program execution is a run-time concept. The static analysis works; by calculating an approximation of that set, called the *capability; environment*. The capability environment is calculated for every program point,; and describes the set of capabilities that are statically known to be held, or; not held, at that particular point. This environment is a conservative; approximation of the full set of capabilities that will actually held by a; thread at run-time. Reference Guide; ===============. The thread safety analysis uses attributes to declare threading constraints.; Attributes must be attached to named declarations, suc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:5201,Deployability,release,release,5201," capability to access data that is protected by ``mu``. Similarly,; calling ``mu.Unlock()`` releases that capability. A thread may hold a capability either *exclusively* or *shared*. An exclusive; capability can be held by only one thread at a time, while a shared capability; can be held by many threads at the same time. This mechanism enforces a; multiple-reader, single-writer pattern. Write operations to protected data; require exclusive access, while read operations require only shared access. At any given moment during program execution, a thread holds a specific set of; capabilities (e.g. the set of mutexes that it has locked.) These act like keys; or tokens that allow the thread to access a given resource. Just like physical; security keys, a thread cannot make copy of a capability, nor can it destroy; one. A thread can only release a capability to another thread, or acquire one; from another thread. The annotations are deliberately agnostic about the; exact mechanism used to acquire and release capabilities; it assumes that the; underlying implementation (e.g. the Mutex implementation) does the handoff in; an appropriate manner. The set of capabilities that are actually held by a given thread at a given; point in program execution is a run-time concept. The static analysis works; by calculating an approximation of that set, called the *capability; environment*. The capability environment is calculated for every program point,; and describes the set of capabilities that are statically known to be held, or; not held, at that particular point. This environment is a conservative; approximation of the full set of capabilities that will actually held by a; thread at run-time. Reference Guide; ===============. The thread safety analysis uses attributes to declare threading constraints.; Attributes must be attached to named declarations, such as classes, methods,; and data members. Users are *strongly advised* to define macros for the various; attributes; example def",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:8629,Deployability,release,release,8629,"------------. *Previously*: ``EXCLUSIVE_LOCKS_REQUIRED``, ``SHARED_LOCKS_REQUIRED``. ``REQUIRES`` is an attribute on functions or methods, which; declares that the calling thread must have exclusive access to the given; capabilities. More than one capability may be specified. The capabilities; must be held on entry to the function, *and must still be held on exit*. ``REQUIRES_SHARED`` is similar, but requires only shared access. .. code-block:: c++. Mutex mu1, mu2;; int a GUARDED_BY(mu1);; int b GUARDED_BY(mu2);. void foo() REQUIRES(mu1, mu2) {; a = 0;; b = 0;; }. void test() {; mu1.Lock();; foo(); // Warning! Requires mu2.; mu1.Unlock();; }. ACQUIRE(...), ACQUIRE_SHARED(...), RELEASE(...), RELEASE_SHARED(...), RELEASE_GENERIC(...); ------------------------------------------------------------------------------------------. *Previously*: ``EXCLUSIVE_LOCK_FUNCTION``, ``SHARED_LOCK_FUNCTION``,; ``UNLOCK_FUNCTION``. ``ACQUIRE`` and ``ACQUIRE_SHARED`` are attributes on functions or methods; declaring that the function acquires a capability, but does not release it.; The given capability must not be held on entry, and will be held on exit; (exclusively for ``ACQUIRE``, shared for ``ACQUIRE_SHARED``). ``RELEASE``, ``RELEASE_SHARED``, and ``RELEASE_GENERIC`` declare that the; function releases the given capability. The capability must be held on entry; (exclusively for ``RELEASE``, shared for ``RELEASE_SHARED``, exclusively or; shared for ``RELEASE_GENERIC``), and will no longer be held on exit. .. code-block:: c++. Mutex mu;; MyClass myObject GUARDED_BY(mu);. void lockAndInit() ACQUIRE(mu) {; mu.Lock();; myObject.init();; }. void cleanupAndUnlock() RELEASE(mu) {; myObject.cleanup();; } // Warning! Need to unlock mu. void test() {; lockAndInit();; myObject.doSomething();; cleanupAndUnlock();; myObject.doSomething(); // Warning, mu is not locked.; }. If no argument is passed to ``ACQUIRE`` or ``RELEASE``, then the argument is; assumed to be ``this``, and the analysis will not",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:8862,Deployability,release,releases,8862,"ified. The capabilities; must be held on entry to the function, *and must still be held on exit*. ``REQUIRES_SHARED`` is similar, but requires only shared access. .. code-block:: c++. Mutex mu1, mu2;; int a GUARDED_BY(mu1);; int b GUARDED_BY(mu2);. void foo() REQUIRES(mu1, mu2) {; a = 0;; b = 0;; }. void test() {; mu1.Lock();; foo(); // Warning! Requires mu2.; mu1.Unlock();; }. ACQUIRE(...), ACQUIRE_SHARED(...), RELEASE(...), RELEASE_SHARED(...), RELEASE_GENERIC(...); ------------------------------------------------------------------------------------------. *Previously*: ``EXCLUSIVE_LOCK_FUNCTION``, ``SHARED_LOCK_FUNCTION``,; ``UNLOCK_FUNCTION``. ``ACQUIRE`` and ``ACQUIRE_SHARED`` are attributes on functions or methods; declaring that the function acquires a capability, but does not release it.; The given capability must not be held on entry, and will be held on exit; (exclusively for ``ACQUIRE``, shared for ``ACQUIRE_SHARED``). ``RELEASE``, ``RELEASE_SHARED``, and ``RELEASE_GENERIC`` declare that the; function releases the given capability. The capability must be held on entry; (exclusively for ``RELEASE``, shared for ``RELEASE_SHARED``, exclusively or; shared for ``RELEASE_GENERIC``), and will no longer be held on exit. .. code-block:: c++. Mutex mu;; MyClass myObject GUARDED_BY(mu);. void lockAndInit() ACQUIRE(mu) {; mu.Lock();; myObject.init();; }. void cleanupAndUnlock() RELEASE(mu) {; myObject.cleanup();; } // Warning! Need to unlock mu. void test() {; lockAndInit();; myObject.doSomething();; cleanupAndUnlock();; myObject.doSomething(); // Warning, mu is not locked.; }. If no argument is passed to ``ACQUIRE`` or ``RELEASE``, then the argument is; assumed to be ``this``, and the analysis will not check the body of the; function. This pattern is intended for use by classes which hide locking; details behind an abstract interface. For example:. .. code-block:: c++. template <class T>; class CAPABILITY(""mutex"") Container {; private:; Mutex mu;; T* data;. public:; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:13352,Deployability,release,released,13352,"AFTER`` are attributes on member; declarations, specifically declarations of mutexes or other capabilities.; These declarations enforce a particular order in which the mutexes must be; acquired, in order to prevent deadlock. .. code-block:: c++. Mutex m1;; Mutex m2 ACQUIRED_AFTER(m1);. // Alternative declaration; // Mutex m2;; // Mutex m1 ACQUIRED_BEFORE(m2);. void foo() {; m2.Lock();; m1.Lock(); // Warning! m2 must be acquired after m1.; m1.Unlock();; m2.Unlock();; }. CAPABILITY(<string>); --------------------. *Previously*: ``LOCKABLE``. ``CAPABILITY`` is an attribute on classes, which specifies that objects of the; class can be used as a capability. The string argument specifies the kind of; capability in error messages, e.g. ``""mutex""``. See the ``Container`` example; given above, or the ``Mutex`` class in :ref:`mutexheader`. SCOPED_CAPABILITY; -----------------. *Previously*: ``SCOPED_LOCKABLE``. ``SCOPED_CAPABILITY`` is an attribute on classes that implement RAII-style; locking, in which a capability is acquired in the constructor, and released in; the destructor. Such classes require special handling because the constructor; and destructor refer to the capability via different names; see the; ``MutexLocker`` class in :ref:`mutexheader`, below. Scoped capabilities are treated as capabilities that are implicitly acquired; on construction and released on destruction. They are associated with; the set of (regular) capabilities named in thread safety attributes on the; constructor or function returning them by value (using C++17 guaranteed copy; elision). Acquire-type attributes on other member functions are treated as; applying to that set of associated capabilities, while ``RELEASE`` implies that; a function releases all associated capabilities in whatever mode they're held. TRY_ACQUIRE(<bool>, ...), TRY_ACQUIRE_SHARED(<bool>, ...); ---------------------------------------------------------. *Previously:* ``EXCLUSIVE_TRYLOCK_FUNCTION``, ``SHARED_TRYLOCK_FUNCTION`",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:13663,Deployability,release,released,13663," Mutex m1 ACQUIRED_BEFORE(m2);. void foo() {; m2.Lock();; m1.Lock(); // Warning! m2 must be acquired after m1.; m1.Unlock();; m2.Unlock();; }. CAPABILITY(<string>); --------------------. *Previously*: ``LOCKABLE``. ``CAPABILITY`` is an attribute on classes, which specifies that objects of the; class can be used as a capability. The string argument specifies the kind of; capability in error messages, e.g. ``""mutex""``. See the ``Container`` example; given above, or the ``Mutex`` class in :ref:`mutexheader`. SCOPED_CAPABILITY; -----------------. *Previously*: ``SCOPED_LOCKABLE``. ``SCOPED_CAPABILITY`` is an attribute on classes that implement RAII-style; locking, in which a capability is acquired in the constructor, and released in; the destructor. Such classes require special handling because the constructor; and destructor refer to the capability via different names; see the; ``MutexLocker`` class in :ref:`mutexheader`, below. Scoped capabilities are treated as capabilities that are implicitly acquired; on construction and released on destruction. They are associated with; the set of (regular) capabilities named in thread safety attributes on the; constructor or function returning them by value (using C++17 guaranteed copy; elision). Acquire-type attributes on other member functions are treated as; applying to that set of associated capabilities, while ``RELEASE`` implies that; a function releases all associated capabilities in whatever mode they're held. TRY_ACQUIRE(<bool>, ...), TRY_ACQUIRE_SHARED(<bool>, ...); ---------------------------------------------------------. *Previously:* ``EXCLUSIVE_TRYLOCK_FUNCTION``, ``SHARED_TRYLOCK_FUNCTION``. These are attributes on a function or method that tries to acquire the given; capability, and returns a boolean value indicating success or failure.; The first argument must be ``true`` or ``false``, to specify which return value; indicates success, and the remaining arguments are interpreted in the same way; as ``ACQUIRE``. Se",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:14036,Deployability,release,releases,14036,"ind of; capability in error messages, e.g. ``""mutex""``. See the ``Container`` example; given above, or the ``Mutex`` class in :ref:`mutexheader`. SCOPED_CAPABILITY; -----------------. *Previously*: ``SCOPED_LOCKABLE``. ``SCOPED_CAPABILITY`` is an attribute on classes that implement RAII-style; locking, in which a capability is acquired in the constructor, and released in; the destructor. Such classes require special handling because the constructor; and destructor refer to the capability via different names; see the; ``MutexLocker`` class in :ref:`mutexheader`, below. Scoped capabilities are treated as capabilities that are implicitly acquired; on construction and released on destruction. They are associated with; the set of (regular) capabilities named in thread safety attributes on the; constructor or function returning them by value (using C++17 guaranteed copy; elision). Acquire-type attributes on other member functions are treated as; applying to that set of associated capabilities, while ``RELEASE`` implies that; a function releases all associated capabilities in whatever mode they're held. TRY_ACQUIRE(<bool>, ...), TRY_ACQUIRE_SHARED(<bool>, ...); ---------------------------------------------------------. *Previously:* ``EXCLUSIVE_TRYLOCK_FUNCTION``, ``SHARED_TRYLOCK_FUNCTION``. These are attributes on a function or method that tries to acquire the given; capability, and returns a boolean value indicating success or failure.; The first argument must be ``true`` or ``false``, to specify which return value; indicates success, and the remaining arguments are interpreted in the same way; as ``ACQUIRE``. See :ref:`mutexheader`, below, for example uses. Because the analysis doesn't support conditional locking, a capability is; treated as acquired after the first branch on the return value of a try-acquire; function. .. code-block:: c++. Mutex mu;; int a GUARDED_BY(mu);. void foo() {; bool success = mu.TryLock();; a = 0; // Warning, mu is not locked.; if (success) {",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:16479,Deployability,release,released,16479,"e the capability is held after calls to the; annotated function. See :ref:`mutexheader`, below, for example uses. GUARDED_VAR and PT_GUARDED_VAR; ------------------------------. Use of these attributes has been deprecated. Warning flags; -------------. * ``-Wthread-safety``: Umbrella flag which turns on the following:. + ``-Wthread-safety-attributes``: Semantic checks for thread safety attributes.; + ``-Wthread-safety-analysis``: The core analysis.; + ``-Wthread-safety-precise``: Requires that mutex expressions match precisely.; This warning can be disabled for code which has a lot of aliases.; + ``-Wthread-safety-reference``: Checks when guarded members are passed by reference. :ref:`negative` are an experimental feature, which are enabled with:. * ``-Wthread-safety-negative``: Negative capabilities. Off by default. When new features and checks are added to the analysis, they can often introduce; additional warnings. Those warnings are initially released as *beta* warnings; for a period of time, after which they are migrated into the standard analysis. * ``-Wthread-safety-beta``: New features. Off by default. .. _negative:. Negative Capabilities; =====================. Thread Safety Analysis is designed to prevent both race conditions and; deadlock. The GUARDED_BY and REQUIRES attributes prevent race conditions, by; ensuring that a capability is held before reading or writing to guarded data,; and the EXCLUDES attribute prevents deadlock, by making sure that a mutex is; *not* held. However, EXCLUDES is an optional attribute, and does not provide the same; safety guarantee as REQUIRES. In particular:. * A function which acquires a capability does not have to exclude it.; * A function which calls a function that excludes a capability does not; have transitively exclude that capability. As a result, EXCLUDES can easily produce false negatives:. .. code-block:: c++. class Foo {; Mutex mu;. void foo() {; mu.Lock();; bar(); // No warning.; baz(); // No warning.; mu.Unloc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:24693,Deployability,update,update,24693,"his pattern is simply not supported. No alias analysis.; ------------------. The analysis currently does not track pointer aliases. Thus, there can be; false positives if two pointers both point to the same mutex. .. code-block:: c++. class MutexUnlocker {; Mutex* mu;. public:; MutexUnlocker(Mutex* m) RELEASE(m) : mu(m) { mu->Unlock(); }; ~MutexUnlocker() ACQUIRE(mu) { mu->Lock(); }; };. Mutex mutex;; void test() REQUIRES(mutex) {; {; MutexUnlocker munl(&mutex); // unlocks mutex; doSomeIO();; } // Warning: locks munl.mu; }. The MutexUnlocker class is intended to be the dual of the MutexLocker class,; defined in :ref:`mutexheader`. However, it doesn't work because the analysis; doesn't know that munl.mu == mutex. The SCOPED_CAPABILITY attribute handles; aliasing for MutexLocker, but does so only for that particular pattern. ACQUIRED_BEFORE(...) and ACQUIRED_AFTER(...) are currently unimplemented.; -------------------------------------------------------------------------. To be fixed in a future update. .. _mutexheader:. mutex.h; =======. Thread safety analysis can be used with any threading library, but it does; require that the threading API be wrapped in classes and methods which have the; appropriate annotations. The following code provides ``mutex.h`` as an example;; these methods should be filled in to call the appropriate underlying; implementation. .. code-block:: c++. #ifndef THREAD_SAFETY_ANALYSIS_MUTEX_H; #define THREAD_SAFETY_ANALYSIS_MUTEX_H. // Enable thread safety attributes only with clang.; // The attributes can be safely erased when compiling with other compilers.; #if defined(__clang__) && (!defined(SWIG)); #define THREAD_ANNOTATION_ATTRIBUTE__(x) __attribute__((x)); #else; #define THREAD_ANNOTATION_ATTRIBUTE__(x) // no-op; #endif. #define CAPABILITY(x) \; THREAD_ANNOTATION_ATTRIBUTE__(capability(x)). #define SCOPED_CAPABILITY \; THREAD_ANNOTATION_ATTRIBUTE__(scoped_lockable). #define GUARDED_BY(x) \; THREAD_ANNOTATION_ATTRIBUTE__(guarded_by(x)). #d",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:27894,Deployability,release,release,27894,"TION_ATTRIBUTE__(locks_excluded(__VA_ARGS__)). #define ASSERT_CAPABILITY(x) \; THREAD_ANNOTATION_ATTRIBUTE__(assert_capability(x)). #define ASSERT_SHARED_CAPABILITY(x) \; THREAD_ANNOTATION_ATTRIBUTE__(assert_shared_capability(x)). #define RETURN_CAPABILITY(x) \; THREAD_ANNOTATION_ATTRIBUTE__(lock_returned(x)). #define NO_THREAD_SAFETY_ANALYSIS \; THREAD_ANNOTATION_ATTRIBUTE__(no_thread_safety_analysis). // Defines an annotated interface for mutexes.; // These methods can be implemented to use any internal mutex implementation.; class CAPABILITY(""mutex"") Mutex {; public:; // Acquire/lock this mutex exclusively. Only one thread can have exclusive; // access at any one time. Write operations to guarded data require an; // exclusive lock.; void Lock() ACQUIRE();. // Acquire/lock this mutex for read operations, which require only a shared; // lock. This assumes a multiple-reader, single writer semantics. Multiple; // threads may acquire the mutex simultaneously as readers, but a writer; // must wait for all of them to release the mutex before it can acquire it; // exclusively.; void ReaderLock() ACQUIRE_SHARED();. // Release/unlock an exclusive mutex.; void Unlock() RELEASE();. // Release/unlock a shared mutex.; void ReaderUnlock() RELEASE_SHARED();. // Generic unlock, can unlock exclusive and shared mutexes.; void GenericUnlock() RELEASE_GENERIC();. // Try to acquire the mutex. Returns true on success, and false on failure.; bool TryLock() TRY_ACQUIRE(true);. // Try to acquire the mutex for read operations.; bool ReaderTryLock() TRY_ACQUIRE_SHARED(true);. // Assert that this mutex is currently held by the calling thread.; void AssertHeld() ASSERT_CAPABILITY(this);. // Assert that is mutex is currently held for read operations.; void AssertReaderHeld() ASSERT_SHARED_CAPABILITY(this);. // For negative capabilities.; const Mutex& operator!() const { return *this; }; };. // Tag types for selecting a constructor.; struct adopt_lock_t {} inline constexpr adopt_lock = {};; str",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:29062,Deployability,release,releases,29062," Unlock() RELEASE();. // Release/unlock a shared mutex.; void ReaderUnlock() RELEASE_SHARED();. // Generic unlock, can unlock exclusive and shared mutexes.; void GenericUnlock() RELEASE_GENERIC();. // Try to acquire the mutex. Returns true on success, and false on failure.; bool TryLock() TRY_ACQUIRE(true);. // Try to acquire the mutex for read operations.; bool ReaderTryLock() TRY_ACQUIRE_SHARED(true);. // Assert that this mutex is currently held by the calling thread.; void AssertHeld() ASSERT_CAPABILITY(this);. // Assert that is mutex is currently held for read operations.; void AssertReaderHeld() ASSERT_SHARED_CAPABILITY(this);. // For negative capabilities.; const Mutex& operator!() const { return *this; }; };. // Tag types for selecting a constructor.; struct adopt_lock_t {} inline constexpr adopt_lock = {};; struct defer_lock_t {} inline constexpr defer_lock = {};; struct shared_lock_t {} inline constexpr shared_lock = {};. // MutexLocker is an RAII class that acquires a mutex in its constructor, and; // releases it in its destructor.; class SCOPED_CAPABILITY MutexLocker {; private:; Mutex* mut;; bool locked;. public:; // Acquire mu, implicitly acquire *this and associate it with mu.; MutexLocker(Mutex *mu) ACQUIRE(mu) : mut(mu), locked(true) {; mu->Lock();; }. // Assume mu is held, implicitly acquire *this and associate it with mu.; MutexLocker(Mutex *mu, adopt_lock_t) REQUIRES(mu) : mut(mu), locked(true) {}. // Acquire mu in shared mode, implicitly acquire *this and associate it with mu.; MutexLocker(Mutex *mu, shared_lock_t) ACQUIRE_SHARED(mu) : mut(mu), locked(true) {; mu->ReaderLock();; }. // Assume mu is held in shared mode, implicitly acquire *this and associate it with mu.; MutexLocker(Mutex *mu, adopt_lock_t, shared_lock_t) REQUIRES_SHARED(mu); : mut(mu), locked(true) {}. // Assume mu is not held, implicitly acquire *this and associate it with mu.; MutexLocker(Mutex *mu, defer_lock_t) EXCLUDES(mu) : mut(mu), locked(false) {}. // Same as constructors, ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:1032,Integrability,rout,routines,1032,"Introduction; ============. Clang Thread Safety Analysis is a C++ language extension which warns about; potential race conditions in code. The analysis is completely static (i.e.; compile-time); there is no run-time overhead. The analysis is still; under active development, but it is mature enough to be deployed in an; industrial setting. It is being developed by Google, in collaboration with; CERT/SEI, and is used extensively in Google's internal code base. Thread safety analysis works very much like a type system for multi-threaded; programs. In addition to declaring the *type* of data (e.g. ``int``, ``float``,; etc.), the programmer can (optionally) declare how access to that data is; controlled in a multi-threaded environment. For example, if ``foo`` is; *guarded by* the mutex ``mu``, then the analysis will issue a warning whenever; a piece of code reads or writes to ``foo`` without first locking ``mu``.; Similarly, if there are particular routines that should only be called by; the GUI thread, then the analysis will warn if other threads call those; routines. Getting Started; ----------------. .. code-block:: c++. #include ""mutex.h"". class BankAccount {; private:; Mutex mu;; int balance GUARDED_BY(mu);. void depositImpl(int amount) {; balance += amount; // WARNING! Cannot write balance without locking mu.; }. void withdrawImpl(int amount) REQUIRES(mu) {; balance -= amount; // OK. Caller must have locked mu.; }. public:; void withdraw(int amount) {; mu.Lock();; withdrawImpl(amount); // OK. We've locked mu.; } // WARNING! Failed to unlock mu. void transferFrom(BankAccount& b, int amount) {; mu.Lock();; b.withdrawImpl(amount); // WARNING! Calling withdrawImpl() requires locking b.mu.; depositImpl(amount); // OK. depositImpl() has no requirements.; mu.Unlock();; }; };. This example demonstrates the basic concepts behind the analysis. The; ``GUARDED_BY`` attribute declares that a thread must lock ``mu`` before it can; read or write to ``balance``, thus ensuring that ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:1145,Integrability,rout,routines,1145,"Introduction; ============. Clang Thread Safety Analysis is a C++ language extension which warns about; potential race conditions in code. The analysis is completely static (i.e.; compile-time); there is no run-time overhead. The analysis is still; under active development, but it is mature enough to be deployed in an; industrial setting. It is being developed by Google, in collaboration with; CERT/SEI, and is used extensively in Google's internal code base. Thread safety analysis works very much like a type system for multi-threaded; programs. In addition to declaring the *type* of data (e.g. ``int``, ``float``,; etc.), the programmer can (optionally) declare how access to that data is; controlled in a multi-threaded environment. For example, if ``foo`` is; *guarded by* the mutex ``mu``, then the analysis will issue a warning whenever; a piece of code reads or writes to ``foo`` without first locking ``mu``.; Similarly, if there are particular routines that should only be called by; the GUI thread, then the analysis will warn if other threads call those; routines. Getting Started; ----------------. .. code-block:: c++. #include ""mutex.h"". class BankAccount {; private:; Mutex mu;; int balance GUARDED_BY(mu);. void depositImpl(int amount) {; balance += amount; // WARNING! Cannot write balance without locking mu.; }. void withdrawImpl(int amount) REQUIRES(mu) {; balance -= amount; // OK. Caller must have locked mu.; }. public:; void withdraw(int amount) {; mu.Lock();; withdrawImpl(amount); // OK. We've locked mu.; } // WARNING! Failed to unlock mu. void transferFrom(BankAccount& b, int amount) {; mu.Lock();; b.withdrawImpl(amount); // WARNING! Calling withdrawImpl() requires locking b.mu.; depositImpl(amount); // OK. depositImpl() has no requirements.; mu.Unlock();; }; };. This example demonstrates the basic concepts behind the analysis. The; ``GUARDED_BY`` attribute declares that a thread must lock ``mu`` before it can; read or write to ``balance``, thus ensuring that ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:9690,Integrability,interface,interface,9690,"en capability must not be held on entry, and will be held on exit; (exclusively for ``ACQUIRE``, shared for ``ACQUIRE_SHARED``). ``RELEASE``, ``RELEASE_SHARED``, and ``RELEASE_GENERIC`` declare that the; function releases the given capability. The capability must be held on entry; (exclusively for ``RELEASE``, shared for ``RELEASE_SHARED``, exclusively or; shared for ``RELEASE_GENERIC``), and will no longer be held on exit. .. code-block:: c++. Mutex mu;; MyClass myObject GUARDED_BY(mu);. void lockAndInit() ACQUIRE(mu) {; mu.Lock();; myObject.init();; }. void cleanupAndUnlock() RELEASE(mu) {; myObject.cleanup();; } // Warning! Need to unlock mu. void test() {; lockAndInit();; myObject.doSomething();; cleanupAndUnlock();; myObject.doSomething(); // Warning, mu is not locked.; }. If no argument is passed to ``ACQUIRE`` or ``RELEASE``, then the argument is; assumed to be ``this``, and the analysis will not check the body of the; function. This pattern is intended for use by classes which hide locking; details behind an abstract interface. For example:. .. code-block:: c++. template <class T>; class CAPABILITY(""mutex"") Container {; private:; Mutex mu;; T* data;. public:; // Hide mu from public interface.; void Lock() ACQUIRE() { mu.Lock(); }; void Unlock() RELEASE() { mu.Unlock(); }. T& getElem(int i) { return data[i]; }; };. void test() {; Container<int> c;; c.Lock();; int i = c.getElem(0);; c.Unlock();; }. EXCLUDES(...); -------------. *Previously*: ``LOCKS_EXCLUDED``. ``EXCLUDES`` is an attribute on functions or methods, which declares that; the caller must *not* hold the given capabilities. This annotation is; used to prevent deadlock. Many mutex implementations are not re-entrant, so; deadlock can occur if the function acquires the mutex a second time. .. code-block:: c++. Mutex mu;; int a GUARDED_BY(mu);. void clear() EXCLUDES(mu) {; mu.Lock();; a = 0;; mu.Unlock();; }. void reset() {; mu.Lock();; clear(); // Warning! Caller cannot hold 'mu'.; mu.Unlock();; }. Unl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:9858,Integrability,interface,interface,9858,"t the; function releases the given capability. The capability must be held on entry; (exclusively for ``RELEASE``, shared for ``RELEASE_SHARED``, exclusively or; shared for ``RELEASE_GENERIC``), and will no longer be held on exit. .. code-block:: c++. Mutex mu;; MyClass myObject GUARDED_BY(mu);. void lockAndInit() ACQUIRE(mu) {; mu.Lock();; myObject.init();; }. void cleanupAndUnlock() RELEASE(mu) {; myObject.cleanup();; } // Warning! Need to unlock mu. void test() {; lockAndInit();; myObject.doSomething();; cleanupAndUnlock();; myObject.doSomething(); // Warning, mu is not locked.; }. If no argument is passed to ``ACQUIRE`` or ``RELEASE``, then the argument is; assumed to be ``this``, and the analysis will not check the body of the; function. This pattern is intended for use by classes which hide locking; details behind an abstract interface. For example:. .. code-block:: c++. template <class T>; class CAPABILITY(""mutex"") Container {; private:; Mutex mu;; T* data;. public:; // Hide mu from public interface.; void Lock() ACQUIRE() { mu.Lock(); }; void Unlock() RELEASE() { mu.Unlock(); }. T& getElem(int i) { return data[i]; }; };. void test() {; Container<int> c;; c.Lock();; int i = c.getElem(0);; c.Unlock();; }. EXCLUDES(...); -------------. *Previously*: ``LOCKS_EXCLUDED``. ``EXCLUDES`` is an attribute on functions or methods, which declares that; the caller must *not* hold the given capabilities. This annotation is; used to prevent deadlock. Many mutex implementations are not re-entrant, so; deadlock can occur if the function acquires the mutex a second time. .. code-block:: c++. Mutex mu;; int a GUARDED_BY(mu);. void clear() EXCLUDES(mu) {; mu.Lock();; a = 0;; mu.Unlock();; }. void reset() {; mu.Lock();; clear(); // Warning! Caller cannot hold 'mu'.; mu.Unlock();; }. Unlike ``REQUIRES``, ``EXCLUDES`` is optional. The analysis will not issue a; warning if the attribute is missing, which can lead to false negatives in some; cases. This issue is discussed further in :",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:11493,Integrability,interface,interface,11493," EXCLUDES(mu) {; mu.Lock();; a = 0;; mu.Unlock();; }. void reset() {; mu.Lock();; clear(); // Warning! Caller cannot hold 'mu'.; mu.Unlock();; }. Unlike ``REQUIRES``, ``EXCLUDES`` is optional. The analysis will not issue a; warning if the attribute is missing, which can lead to false negatives in some; cases. This issue is discussed further in :ref:`negative`. NO_THREAD_SAFETY_ANALYSIS; -------------------------. ``NO_THREAD_SAFETY_ANALYSIS`` is an attribute on functions or methods, which; turns off thread safety checking for that method. It provides an escape hatch; for functions which are either (1) deliberately thread-unsafe, or (2) are; thread-safe, but too complicated for the analysis to understand. Reasons for; (2) will be described in the :ref:`limitations`, below. .. code-block:: c++. class Counter {; Mutex mu;; int a GUARDED_BY(mu);. void unsafeIncrement() NO_THREAD_SAFETY_ANALYSIS { a++; }; };. Unlike the other attributes, NO_THREAD_SAFETY_ANALYSIS is not part of the; interface of a function, and should thus be placed on the function definition; (in the ``.cc`` or ``.cpp`` file) rather than on the function declaration; (in the header). RETURN_CAPABILITY(c); --------------------. *Previously*: ``LOCK_RETURNED``. ``RETURN_CAPABILITY`` is an attribute on functions or methods, which declares; that the function returns a reference to the given capability. It is used to; annotate getter methods that return mutexes. .. code-block:: c++. class MyClass {; private:; Mutex mu;; int a GUARDED_BY(mu);. public:; Mutex* getMu() RETURN_CAPABILITY(mu) { return &mu; }. // analysis knows that getMu() == mu; void clear() REQUIRES(getMu()) { a = 0; }; };. ACQUIRED_BEFORE(...), ACQUIRED_AFTER(...); -----------------------------------------. ``ACQUIRED_BEFORE`` and ``ACQUIRED_AFTER`` are attributes on member; declarations, specifically declarations of mutexes or other capabilities.; These declarations enforce a particular order in which the mutexes must be; acquired, in order to",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:13018,Integrability,message,messages,13018,"utex mu;; int a GUARDED_BY(mu);. public:; Mutex* getMu() RETURN_CAPABILITY(mu) { return &mu; }. // analysis knows that getMu() == mu; void clear() REQUIRES(getMu()) { a = 0; }; };. ACQUIRED_BEFORE(...), ACQUIRED_AFTER(...); -----------------------------------------. ``ACQUIRED_BEFORE`` and ``ACQUIRED_AFTER`` are attributes on member; declarations, specifically declarations of mutexes or other capabilities.; These declarations enforce a particular order in which the mutexes must be; acquired, in order to prevent deadlock. .. code-block:: c++. Mutex m1;; Mutex m2 ACQUIRED_AFTER(m1);. // Alternative declaration; // Mutex m2;; // Mutex m1 ACQUIRED_BEFORE(m2);. void foo() {; m2.Lock();; m1.Lock(); // Warning! m2 must be acquired after m1.; m1.Unlock();; m2.Unlock();; }. CAPABILITY(<string>); --------------------. *Previously*: ``LOCKABLE``. ``CAPABILITY`` is an attribute on classes, which specifies that objects of the; class can be used as a capability. The string argument specifies the kind of; capability in error messages, e.g. ``""mutex""``. See the ``Container`` example; given above, or the ``Mutex`` class in :ref:`mutexheader`. SCOPED_CAPABILITY; -----------------. *Previously*: ``SCOPED_LOCKABLE``. ``SCOPED_CAPABILITY`` is an attribute on classes that implement RAII-style; locking, in which a capability is acquired in the constructor, and released in; the destructor. Such classes require special handling because the constructor; and destructor refer to the capability via different names; see the; ``MutexLocker`` class in :ref:`mutexheader`, below. Scoped capabilities are treated as capabilities that are implicitly acquired; on construction and released on destruction. They are associated with; the set of (regular) capabilities named in thread safety attributes on the; constructor or function returning them by value (using C++17 guaranteed copy; elision). Acquire-type attributes on other member functions are treated as; applying to that set of associated capabilities,",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:18764,Integrability,interface,interface,18764,"ntee. A negative requirement uses the REQUIRES; attribute, in conjunction with the ``!`` operator, to indicate that a capability; should *not* be held. For example, using ``REQUIRES(!mu)`` instead of ``EXCLUDES(mu)`` will produce; the appropriate warnings:. .. code-block:: c++. class FooNeg {; Mutex mu;. void foo() REQUIRES(!mu) { // foo() now requires !mu.; mu.Lock();; bar();; baz();; mu.Unlock();; }. void bar() {; mu.Lock(); // WARNING! Missing REQUIRES(!mu).; // ...; mu.Unlock();; }. void baz() {; bif(); // WARNING! Missing REQUIRES(!mu).; }. void bif() REQUIRES(!mu);; };. Negative requirements are an experimental feature which is off by default,; because it will produce many warnings in existing code. It can be enabled; by passing ``-Wthread-safety-negative``. .. _faq:. Frequently Asked Questions; ==========================. (Q) Should I put attributes in the header file, or in the .cc/.cpp/.cxx file?. (A) Attributes are part of the formal interface of a function, and should; always go in the header, where they are visible to anything that includes; the header. Attributes in the .cpp file are not visible outside of the; immediate translation unit, which leads to false negatives and false positives. (Q) ""*Mutex is not locked on every path through here?*"" What does that mean?. (A) See :ref:`conditional_locks`, below. .. _limitations:. Known Limitations; =================. Lexical scope; -------------. Thread safety attributes contain ordinary C++ expressions, and thus follow; ordinary C++ scoping rules. In particular, this means that mutexes and other; capabilities must be declared before they can be used in an attribute.; Use-before-declaration is okay within a single class, because attributes are; parsed at the same time as method bodies. (C++ delays parsing of method bodies; until the end of the class.) However, use-before-declaration is not allowed; between classes, as illustrated below. .. code-block:: c++. class Foo;. class Bar {; void bar(Foo* f) REQUIRES(f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:20150,Integrability,interface,interface,20150,"al_locks`, below. .. _limitations:. Known Limitations; =================. Lexical scope; -------------. Thread safety attributes contain ordinary C++ expressions, and thus follow; ordinary C++ scoping rules. In particular, this means that mutexes and other; capabilities must be declared before they can be used in an attribute.; Use-before-declaration is okay within a single class, because attributes are; parsed at the same time as method bodies. (C++ delays parsing of method bodies; until the end of the class.) However, use-before-declaration is not allowed; between classes, as illustrated below. .. code-block:: c++. class Foo;. class Bar {; void bar(Foo* f) REQUIRES(f->mu); // Error: mu undeclared.; };. class Foo {; Mutex mu;; };. Private Mutexes; ---------------. Good software engineering practice dictates that mutexes should be private; members, because the locking mechanism used by a thread-safe class is part of; its internal implementation. However, private mutexes can sometimes leak into; the public interface of a class.; Thread safety attributes follow normal C++ access restrictions, so if ``mu``; is a private member of ``c``, then it is an error to write ``c.mu`` in an; attribute. One workaround is to (ab)use the ``RETURN_CAPABILITY`` attribute to provide a; public *name* for a private mutex, without actually exposing the underlying; mutex. For example:. .. code-block:: c++. class MyClass {; private:; Mutex mu;. public:; // For thread safety analysis only. Does not need to be defined.; Mutex* getMu() RETURN_CAPABILITY(mu);. void doSomething() REQUIRES(mu);; };. void doSomethingTwice(MyClass& c) REQUIRES(c.getMu()) {; // The analysis thinks that c.getMu() == c.mu; c.doSomething();; c.doSomething();; }. In the above example, ``doSomethingTwice()`` is an external routine that; requires ``c.mu`` to be locked, which cannot be declared directly because ``mu``; is private. This pattern is discouraged because it; violates encapsulation, but it is sometimes necessary,",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:20928,Integrability,rout,routine,20928,"oftware engineering practice dictates that mutexes should be private; members, because the locking mechanism used by a thread-safe class is part of; its internal implementation. However, private mutexes can sometimes leak into; the public interface of a class.; Thread safety attributes follow normal C++ access restrictions, so if ``mu``; is a private member of ``c``, then it is an error to write ``c.mu`` in an; attribute. One workaround is to (ab)use the ``RETURN_CAPABILITY`` attribute to provide a; public *name* for a private mutex, without actually exposing the underlying; mutex. For example:. .. code-block:: c++. class MyClass {; private:; Mutex mu;. public:; // For thread safety analysis only. Does not need to be defined.; Mutex* getMu() RETURN_CAPABILITY(mu);. void doSomething() REQUIRES(mu);; };. void doSomethingTwice(MyClass& c) REQUIRES(c.getMu()) {; // The analysis thinks that c.getMu() == c.mu; c.doSomething();; c.doSomething();; }. In the above example, ``doSomethingTwice()`` is an external routine that; requires ``c.mu`` to be locked, which cannot be declared directly because ``mu``; is private. This pattern is discouraged because it; violates encapsulation, but it is sometimes necessary, especially when adding; annotations to an existing code base. The workaround is to define ``getMu()``; as a fake getter method, which is provided only for the benefit of thread; safety analysis. .. _conditional_locks:. No conditionally held locks.; ----------------------------. The analysis must be able to determine whether a lock is held, or not held, at; every program point. Thus, sections of code where a lock *might be held* will; generate spurious warnings (false positives). For example:. .. code-block:: c++. void foo() {; bool b = needsToLock();; if (b) mu.Lock();; ... // Warning! Mutex 'mu' is not held on every path through here.; if (b) mu.Unlock();; }. No checking inside constructors and destructors.; ------------------------------------------------. The analysi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:24847,Integrability,wrap,wrapped,24847," can be; false positives if two pointers both point to the same mutex. .. code-block:: c++. class MutexUnlocker {; Mutex* mu;. public:; MutexUnlocker(Mutex* m) RELEASE(m) : mu(m) { mu->Unlock(); }; ~MutexUnlocker() ACQUIRE(mu) { mu->Lock(); }; };. Mutex mutex;; void test() REQUIRES(mutex) {; {; MutexUnlocker munl(&mutex); // unlocks mutex; doSomeIO();; } // Warning: locks munl.mu; }. The MutexUnlocker class is intended to be the dual of the MutexLocker class,; defined in :ref:`mutexheader`. However, it doesn't work because the analysis; doesn't know that munl.mu == mutex. The SCOPED_CAPABILITY attribute handles; aliasing for MutexLocker, but does so only for that particular pattern. ACQUIRED_BEFORE(...) and ACQUIRED_AFTER(...) are currently unimplemented.; -------------------------------------------------------------------------. To be fixed in a future update. .. _mutexheader:. mutex.h; =======. Thread safety analysis can be used with any threading library, but it does; require that the threading API be wrapped in classes and methods which have the; appropriate annotations. The following code provides ``mutex.h`` as an example;; these methods should be filled in to call the appropriate underlying; implementation. .. code-block:: c++. #ifndef THREAD_SAFETY_ANALYSIS_MUTEX_H; #define THREAD_SAFETY_ANALYSIS_MUTEX_H. // Enable thread safety attributes only with clang.; // The attributes can be safely erased when compiling with other compilers.; #if defined(__clang__) && (!defined(SWIG)); #define THREAD_ANNOTATION_ATTRIBUTE__(x) __attribute__((x)); #else; #define THREAD_ANNOTATION_ATTRIBUTE__(x) // no-op; #endif. #define CAPABILITY(x) \; THREAD_ANNOTATION_ATTRIBUTE__(capability(x)). #define SCOPED_CAPABILITY \; THREAD_ANNOTATION_ATTRIBUTE__(scoped_lockable). #define GUARDED_BY(x) \; THREAD_ANNOTATION_ATTRIBUTE__(guarded_by(x)). #define PT_GUARDED_BY(x) \; THREAD_ANNOTATION_ATTRIBUTE__(pt_guarded_by(x)). #define ACQUIRED_BEFORE(...) \; THREAD_ANNOTATION_ATTRIBUTE__(acquir",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:27296,Integrability,interface,interface,27296,"shared_capability(__VA_ARGS__)). #define RELEASE(...) \; THREAD_ANNOTATION_ATTRIBUTE__(release_capability(__VA_ARGS__)). #define RELEASE_SHARED(...) \; THREAD_ANNOTATION_ATTRIBUTE__(release_shared_capability(__VA_ARGS__)). #define RELEASE_GENERIC(...) \; THREAD_ANNOTATION_ATTRIBUTE__(release_generic_capability(__VA_ARGS__)). #define TRY_ACQUIRE(...) \; THREAD_ANNOTATION_ATTRIBUTE__(try_acquire_capability(__VA_ARGS__)). #define TRY_ACQUIRE_SHARED(...) \; THREAD_ANNOTATION_ATTRIBUTE__(try_acquire_shared_capability(__VA_ARGS__)). #define EXCLUDES(...) \; THREAD_ANNOTATION_ATTRIBUTE__(locks_excluded(__VA_ARGS__)). #define ASSERT_CAPABILITY(x) \; THREAD_ANNOTATION_ATTRIBUTE__(assert_capability(x)). #define ASSERT_SHARED_CAPABILITY(x) \; THREAD_ANNOTATION_ATTRIBUTE__(assert_shared_capability(x)). #define RETURN_CAPABILITY(x) \; THREAD_ANNOTATION_ATTRIBUTE__(lock_returned(x)). #define NO_THREAD_SAFETY_ANALYSIS \; THREAD_ANNOTATION_ATTRIBUTE__(no_thread_safety_analysis). // Defines an annotated interface for mutexes.; // These methods can be implemented to use any internal mutex implementation.; class CAPABILITY(""mutex"") Mutex {; public:; // Acquire/lock this mutex exclusively. Only one thread can have exclusive; // access at any one time. Write operations to guarded data require an; // exclusive lock.; void Lock() ACQUIRE();. // Acquire/lock this mutex for read operations, which require only a shared; // lock. This assumes a multiple-reader, single writer semantics. Multiple; // threads may acquire the mutex simultaneously as readers, but a writer; // must wait for all of them to release the mutex before it can acquire it; // exclusively.; void ReaderLock() ACQUIRE_SHARED();. // Release/unlock an exclusive mutex.; void Unlock() RELEASE();. // Release/unlock a shared mutex.; void ReaderUnlock() RELEASE_SHARED();. // Generic unlock, can unlock exclusive and shared mutexes.; void GenericUnlock() RELEASE_GENERIC();. // Try to acquire the mutex. Returns true on success, and fals",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:188,Performance,race condition,race conditions,188,"; ======================; Thread Safety Analysis; ======================. Introduction; ============. Clang Thread Safety Analysis is a C++ language extension which warns about; potential race conditions in code. The analysis is completely static (i.e.; compile-time); there is no run-time overhead. The analysis is still; under active development, but it is mature enough to be deployed in an; industrial setting. It is being developed by Google, in collaboration with; CERT/SEI, and is used extensively in Google's internal code base. Thread safety analysis works very much like a type system for multi-threaded; programs. In addition to declaring the *type* of data (e.g. ``int``, ``float``,; etc.), the programmer can (optionally) declare how access to that data is; controlled in a multi-threaded environment. For example, if ``foo`` is; *guarded by* the mutex ``mu``, then the analysis will issue a warning whenever; a piece of code reads or writes to ``foo`` without first locking ``mu``.; Similarly, if there are particular routines that should only be called by; the GUI thread, then the analysis will warn if other threads call those; routines. Getting Started; ----------------. .. code-block:: c++. #include ""mutex.h"". class BankAccount {; private:; Mutex mu;; int balance GUARDED_BY(mu);. void depositImpl(int amount) {; balance += amount; // WARNING! Cannot write balance without locking mu.; }. void withdrawImpl(int amount) REQUIRES(mu) {; balance -= amount; // OK. Caller must have locked mu.; }. public:; void withdraw(int amount) {; mu.Lock();; withdrawImpl(amount); // OK. We've locked mu.; } // WARNING! Failed to unlock mu. void transferFrom(BankAccount& b, int amount) {; mu.Lock();; b.withdrawImpl(amount); // WARNING! Calling withdrawImpl() requires locking b.mu.; depositImpl(amount); // OK. depositImpl() has no requirements.; mu.Unlock();; }; };. This example demonstrates the basic concepts behind the analysis. The; ``GUARDED_BY`` attribute declares that a thread must lo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:599,Performance,multi-thread,multi-threaded,599,"; ======================; Thread Safety Analysis; ======================. Introduction; ============. Clang Thread Safety Analysis is a C++ language extension which warns about; potential race conditions in code. The analysis is completely static (i.e.; compile-time); there is no run-time overhead. The analysis is still; under active development, but it is mature enough to be deployed in an; industrial setting. It is being developed by Google, in collaboration with; CERT/SEI, and is used extensively in Google's internal code base. Thread safety analysis works very much like a type system for multi-threaded; programs. In addition to declaring the *type* of data (e.g. ``int``, ``float``,; etc.), the programmer can (optionally) declare how access to that data is; controlled in a multi-threaded environment. For example, if ``foo`` is; *guarded by* the mutex ``mu``, then the analysis will issue a warning whenever; a piece of code reads or writes to ``foo`` without first locking ``mu``.; Similarly, if there are particular routines that should only be called by; the GUI thread, then the analysis will warn if other threads call those; routines. Getting Started; ----------------. .. code-block:: c++. #include ""mutex.h"". class BankAccount {; private:; Mutex mu;; int balance GUARDED_BY(mu);. void depositImpl(int amount) {; balance += amount; // WARNING! Cannot write balance without locking mu.; }. void withdrawImpl(int amount) REQUIRES(mu) {; balance -= amount; // OK. Caller must have locked mu.; }. public:; void withdraw(int amount) {; mu.Lock();; withdrawImpl(amount); // OK. We've locked mu.; } // WARNING! Failed to unlock mu. void transferFrom(BankAccount& b, int amount) {; mu.Lock();; b.withdrawImpl(amount); // WARNING! Calling withdrawImpl() requires locking b.mu.; depositImpl(amount); // OK. depositImpl() has no requirements.; mu.Unlock();; }; };. This example demonstrates the basic concepts behind the analysis. The; ``GUARDED_BY`` attribute declares that a thread must lo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:787,Performance,multi-thread,multi-threaded,787,"; ======================; Thread Safety Analysis; ======================. Introduction; ============. Clang Thread Safety Analysis is a C++ language extension which warns about; potential race conditions in code. The analysis is completely static (i.e.; compile-time); there is no run-time overhead. The analysis is still; under active development, but it is mature enough to be deployed in an; industrial setting. It is being developed by Google, in collaboration with; CERT/SEI, and is used extensively in Google's internal code base. Thread safety analysis works very much like a type system for multi-threaded; programs. In addition to declaring the *type* of data (e.g. ``int``, ``float``,; etc.), the programmer can (optionally) declare how access to that data is; controlled in a multi-threaded environment. For example, if ``foo`` is; *guarded by* the mutex ``mu``, then the analysis will issue a warning whenever; a piece of code reads or writes to ``foo`` without first locking ``mu``.; Similarly, if there are particular routines that should only be called by; the GUI thread, then the analysis will warn if other threads call those; routines. Getting Started; ----------------. .. code-block:: c++. #include ""mutex.h"". class BankAccount {; private:; Mutex mu;; int balance GUARDED_BY(mu);. void depositImpl(int amount) {; balance += amount; // WARNING! Cannot write balance without locking mu.; }. void withdrawImpl(int amount) REQUIRES(mu) {; balance -= amount; // OK. Caller must have locked mu.; }. public:; void withdraw(int amount) {; mu.Lock();; withdrawImpl(amount); // OK. We've locked mu.; } // WARNING! Failed to unlock mu. void transferFrom(BankAccount& b, int amount) {; mu.Lock();; b.withdrawImpl(amount); // WARNING! Calling withdrawImpl() requires locking b.mu.; depositImpl(amount); // OK. depositImpl() has no requirements.; mu.Unlock();; }; };. This example demonstrates the basic concepts behind the analysis. The; ``GUARDED_BY`` attribute declares that a thread must lo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:3411,Performance,perform,perform,3411,")`` method does not have ``REQUIRES``, so the; analysis issues a warning. Thread safety analysis is not inter-procedural, so; caller requirements must be explicitly declared.; There is also a warning in ``transferFrom()``, because although the method; locks ``this->mu``, it does not lock ``b.mu``. The analysis understands; that these are two separate mutexes, in two different objects. Finally, there is a warning in the ``withdraw()`` method, because it fails to; unlock ``mu``. Every lock must have a corresponding unlock, and the analysis; will detect both double locks, and double unlocks. A function is allowed to; acquire a lock without releasing it, (or vice versa), but it must be annotated; as such (using ``ACQUIRE``/``RELEASE``). Running The Analysis; --------------------. To run the analysis, simply compile with the ``-Wthread-safety`` flag, e.g. .. code-block:: bash. clang -c -Wthread-safety example.cpp. Note that this example assumes the presence of a suitably annotated; :ref:`mutexheader` that declares which methods perform locking,; unlocking, and so on. Basic Concepts: Capabilities; ============================. Thread safety analysis provides a way of protecting *resources* with; *capabilities*. A resource is either a data member, or a function/method; that provides access to some underlying resource. The analysis ensures that; the calling thread cannot access the *resource* (i.e. call the function, or; read/write the data) unless it has the *capability* to do so. Capabilities are associated with named C++ objects which declare specific; methods to acquire and release the capability. The name of the object serves; to identify the capability. The most common example is a mutex. For example,; if ``mu`` is a mutex, then calling ``mu.Lock()`` causes the calling thread; to acquire the capability to access data that is protected by ``mu``. Similarly,; calling ``mu.Unlock()`` releases that capability. A thread may hold a capability either *exclusively* or *shared",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:15386,Performance,perform,performing,15386,"cquire the given; capability, and returns a boolean value indicating success or failure.; The first argument must be ``true`` or ``false``, to specify which return value; indicates success, and the remaining arguments are interpreted in the same way; as ``ACQUIRE``. See :ref:`mutexheader`, below, for example uses. Because the analysis doesn't support conditional locking, a capability is; treated as acquired after the first branch on the return value of a try-acquire; function. .. code-block:: c++. Mutex mu;; int a GUARDED_BY(mu);. void foo() {; bool success = mu.TryLock();; a = 0; // Warning, mu is not locked.; if (success) {; a = 0; // Ok.; mu.Unlock();; } else {; a = 0; // Warning, mu is not locked.; }; }. ASSERT_CAPABILITY(...) and ASSERT_SHARED_CAPABILITY(...); --------------------------------------------------------. *Previously:* ``ASSERT_EXCLUSIVE_LOCK``, ``ASSERT_SHARED_LOCK``. These are attributes on a function or method which asserts the calling thread; already holds the given capability, for example by performing a run-time test; and terminating if the capability is not held. Presence of this annotation; causes the analysis to assume the capability is held after calls to the; annotated function. See :ref:`mutexheader`, below, for example uses. GUARDED_VAR and PT_GUARDED_VAR; ------------------------------. Use of these attributes has been deprecated. Warning flags; -------------. * ``-Wthread-safety``: Umbrella flag which turns on the following:. + ``-Wthread-safety-attributes``: Semantic checks for thread safety attributes.; + ``-Wthread-safety-analysis``: The core analysis.; + ``-Wthread-safety-precise``: Requires that mutex expressions match precisely.; This warning can be disabled for code which has a lot of aliases.; + ``-Wthread-safety-reference``: Checks when guarded members are passed by reference. :ref:`negative` are an experimental feature, which are enabled with:. * ``-Wthread-safety-negative``: Negative capabilities. Off by default. When new fe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:16758,Performance,race condition,race conditions,16758,"g flags; -------------. * ``-Wthread-safety``: Umbrella flag which turns on the following:. + ``-Wthread-safety-attributes``: Semantic checks for thread safety attributes.; + ``-Wthread-safety-analysis``: The core analysis.; + ``-Wthread-safety-precise``: Requires that mutex expressions match precisely.; This warning can be disabled for code which has a lot of aliases.; + ``-Wthread-safety-reference``: Checks when guarded members are passed by reference. :ref:`negative` are an experimental feature, which are enabled with:. * ``-Wthread-safety-negative``: Negative capabilities. Off by default. When new features and checks are added to the analysis, they can often introduce; additional warnings. Those warnings are initially released as *beta* warnings; for a period of time, after which they are migrated into the standard analysis. * ``-Wthread-safety-beta``: New features. Off by default. .. _negative:. Negative Capabilities; =====================. Thread Safety Analysis is designed to prevent both race conditions and; deadlock. The GUARDED_BY and REQUIRES attributes prevent race conditions, by; ensuring that a capability is held before reading or writing to guarded data,; and the EXCLUDES attribute prevents deadlock, by making sure that a mutex is; *not* held. However, EXCLUDES is an optional attribute, and does not provide the same; safety guarantee as REQUIRES. In particular:. * A function which acquires a capability does not have to exclude it.; * A function which calls a function that excludes a capability does not; have transitively exclude that capability. As a result, EXCLUDES can easily produce false negatives:. .. code-block:: c++. class Foo {; Mutex mu;. void foo() {; mu.Lock();; bar(); // No warning.; baz(); // No warning.; mu.Unlock();; }. void bar() { // No warning. (Should have EXCLUDES(mu)).; mu.Lock();; // ...; mu.Unlock();; }. void baz() {; bif(); // No warning. (Should have EXCLUDES(mu)).; }. void bif() EXCLUDES(mu);; };. Negative requirements are an",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:16836,Performance,race condition,race conditions,16836," attributes.; + ``-Wthread-safety-analysis``: The core analysis.; + ``-Wthread-safety-precise``: Requires that mutex expressions match precisely.; This warning can be disabled for code which has a lot of aliases.; + ``-Wthread-safety-reference``: Checks when guarded members are passed by reference. :ref:`negative` are an experimental feature, which are enabled with:. * ``-Wthread-safety-negative``: Negative capabilities. Off by default. When new features and checks are added to the analysis, they can often introduce; additional warnings. Those warnings are initially released as *beta* warnings; for a period of time, after which they are migrated into the standard analysis. * ``-Wthread-safety-beta``: New features. Off by default. .. _negative:. Negative Capabilities; =====================. Thread Safety Analysis is designed to prevent both race conditions and; deadlock. The GUARDED_BY and REQUIRES attributes prevent race conditions, by; ensuring that a capability is held before reading or writing to guarded data,; and the EXCLUDES attribute prevents deadlock, by making sure that a mutex is; *not* held. However, EXCLUDES is an optional attribute, and does not provide the same; safety guarantee as REQUIRES. In particular:. * A function which acquires a capability does not have to exclude it.; * A function which calls a function that excludes a capability does not; have transitively exclude that capability. As a result, EXCLUDES can easily produce false negatives:. .. code-block:: c++. class Foo {; Mutex mu;. void foo() {; mu.Lock();; bar(); // No warning.; baz(); // No warning.; mu.Unlock();; }. void bar() { // No warning. (Should have EXCLUDES(mu)).; mu.Lock();; // ...; mu.Unlock();; }. void baz() {; bif(); // No warning. (Should have EXCLUDES(mu)).; }. void bif() EXCLUDES(mu);; };. Negative requirements are an alternative EXCLUDES that provide; a stronger safety guarantee. A negative requirement uses the REQUIRES; attribute, in conjunction with the ``!`` operator, to",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:544,Safety,safe,safety,544,"; ======================; Thread Safety Analysis; ======================. Introduction; ============. Clang Thread Safety Analysis is a C++ language extension which warns about; potential race conditions in code. The analysis is completely static (i.e.; compile-time); there is no run-time overhead. The analysis is still; under active development, but it is mature enough to be deployed in an; industrial setting. It is being developed by Google, in collaboration with; CERT/SEI, and is used extensively in Google's internal code base. Thread safety analysis works very much like a type system for multi-threaded; programs. In addition to declaring the *type* of data (e.g. ``int``, ``float``,; etc.), the programmer can (optionally) declare how access to that data is; controlled in a multi-threaded environment. For example, if ``foo`` is; *guarded by* the mutex ``mu``, then the analysis will issue a warning whenever; a piece of code reads or writes to ``foo`` without first locking ``mu``.; Similarly, if there are particular routines that should only be called by; the GUI thread, then the analysis will warn if other threads call those; routines. Getting Started; ----------------. .. code-block:: c++. #include ""mutex.h"". class BankAccount {; private:; Mutex mu;; int balance GUARDED_BY(mu);. void depositImpl(int amount) {; balance += amount; // WARNING! Cannot write balance without locking mu.; }. void withdrawImpl(int amount) REQUIRES(mu) {; balance -= amount; // OK. Caller must have locked mu.; }. public:; void withdraw(int amount) {; mu.Lock();; withdrawImpl(amount); // OK. We've locked mu.; } // WARNING! Failed to unlock mu. void transferFrom(BankAccount& b, int amount) {; mu.Lock();; b.withdrawImpl(amount); // WARNING! Calling withdrawImpl() requires locking b.mu.; depositImpl(amount); // OK. depositImpl() has no requirements.; mu.Unlock();; }; };. This example demonstrates the basic concepts behind the analysis. The; ``GUARDED_BY`` attribute declares that a thread must lo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:2295,Safety,safe,safe,2295,"BY(mu);. void depositImpl(int amount) {; balance += amount; // WARNING! Cannot write balance without locking mu.; }. void withdrawImpl(int amount) REQUIRES(mu) {; balance -= amount; // OK. Caller must have locked mu.; }. public:; void withdraw(int amount) {; mu.Lock();; withdrawImpl(amount); // OK. We've locked mu.; } // WARNING! Failed to unlock mu. void transferFrom(BankAccount& b, int amount) {; mu.Lock();; b.withdrawImpl(amount); // WARNING! Calling withdrawImpl() requires locking b.mu.; depositImpl(amount); // OK. depositImpl() has no requirements.; mu.Unlock();; }; };. This example demonstrates the basic concepts behind the analysis. The; ``GUARDED_BY`` attribute declares that a thread must lock ``mu`` before it can; read or write to ``balance``, thus ensuring that the increment and decrement; operations are atomic. Similarly, ``REQUIRES`` declares that; the calling thread must lock ``mu`` before calling ``withdrawImpl``.; Because the caller is assumed to have locked ``mu``, it is safe to modify; ``balance`` within the body of the method. The ``depositImpl()`` method does not have ``REQUIRES``, so the; analysis issues a warning. Thread safety analysis is not inter-procedural, so; caller requirements must be explicitly declared.; There is also a warning in ``transferFrom()``, because although the method; locks ``this->mu``, it does not lock ``b.mu``. The analysis understands; that these are two separate mutexes, in two different objects. Finally, there is a warning in the ``withdraw()`` method, because it fails to; unlock ``mu``. Every lock must have a corresponding unlock, and the analysis; will detect both double locks, and double unlocks. A function is allowed to; acquire a lock without releasing it, (or vice versa), but it must be annotated; as such (using ``ACQUIRE``/``RELEASE``). Running The Analysis; --------------------. To run the analysis, simply compile with the ``-Wthread-safety`` flag, e.g. .. code-block:: bash. clang -c -Wthread-safety example.cpp.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:2453,Safety,safe,safety,2453,"ave locked mu.; }. public:; void withdraw(int amount) {; mu.Lock();; withdrawImpl(amount); // OK. We've locked mu.; } // WARNING! Failed to unlock mu. void transferFrom(BankAccount& b, int amount) {; mu.Lock();; b.withdrawImpl(amount); // WARNING! Calling withdrawImpl() requires locking b.mu.; depositImpl(amount); // OK. depositImpl() has no requirements.; mu.Unlock();; }; };. This example demonstrates the basic concepts behind the analysis. The; ``GUARDED_BY`` attribute declares that a thread must lock ``mu`` before it can; read or write to ``balance``, thus ensuring that the increment and decrement; operations are atomic. Similarly, ``REQUIRES`` declares that; the calling thread must lock ``mu`` before calling ``withdrawImpl``.; Because the caller is assumed to have locked ``mu``, it is safe to modify; ``balance`` within the body of the method. The ``depositImpl()`` method does not have ``REQUIRES``, so the; analysis issues a warning. Thread safety analysis is not inter-procedural, so; caller requirements must be explicitly declared.; There is also a warning in ``transferFrom()``, because although the method; locks ``this->mu``, it does not lock ``b.mu``. The analysis understands; that these are two separate mutexes, in two different objects. Finally, there is a warning in the ``withdraw()`` method, because it fails to; unlock ``mu``. Every lock must have a corresponding unlock, and the analysis; will detect both double locks, and double unlocks. A function is allowed to; acquire a lock without releasing it, (or vice versa), but it must be annotated; as such (using ``ACQUIRE``/``RELEASE``). Running The Analysis; --------------------. To run the analysis, simply compile with the ``-Wthread-safety`` flag, e.g. .. code-block:: bash. clang -c -Wthread-safety example.cpp. Note that this example assumes the presence of a suitably annotated; :ref:`mutexheader` that declares which methods perform locking,; unlocking, and so on. Basic Concepts: Capabilities; ===============",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:2922,Safety,detect,detect,2922," concepts behind the analysis. The; ``GUARDED_BY`` attribute declares that a thread must lock ``mu`` before it can; read or write to ``balance``, thus ensuring that the increment and decrement; operations are atomic. Similarly, ``REQUIRES`` declares that; the calling thread must lock ``mu`` before calling ``withdrawImpl``.; Because the caller is assumed to have locked ``mu``, it is safe to modify; ``balance`` within the body of the method. The ``depositImpl()`` method does not have ``REQUIRES``, so the; analysis issues a warning. Thread safety analysis is not inter-procedural, so; caller requirements must be explicitly declared.; There is also a warning in ``transferFrom()``, because although the method; locks ``this->mu``, it does not lock ``b.mu``. The analysis understands; that these are two separate mutexes, in two different objects. Finally, there is a warning in the ``withdraw()`` method, because it fails to; unlock ``mu``. Every lock must have a corresponding unlock, and the analysis; will detect both double locks, and double unlocks. A function is allowed to; acquire a lock without releasing it, (or vice versa), but it must be annotated; as such (using ``ACQUIRE``/``RELEASE``). Running The Analysis; --------------------. To run the analysis, simply compile with the ``-Wthread-safety`` flag, e.g. .. code-block:: bash. clang -c -Wthread-safety example.cpp. Note that this example assumes the presence of a suitably annotated; :ref:`mutexheader` that declares which methods perform locking,; unlocking, and so on. Basic Concepts: Capabilities; ============================. Thread safety analysis provides a way of protecting *resources* with; *capabilities*. A resource is either a data member, or a function/method; that provides access to some underlying resource. The analysis ensures that; the calling thread cannot access the *resource* (i.e. call the function, or; read/write the data) unless it has the *capability* to do so. Capabilities are associated with named ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:3215,Safety,safe,safety,3215,"``mu`` before calling ``withdrawImpl``.; Because the caller is assumed to have locked ``mu``, it is safe to modify; ``balance`` within the body of the method. The ``depositImpl()`` method does not have ``REQUIRES``, so the; analysis issues a warning. Thread safety analysis is not inter-procedural, so; caller requirements must be explicitly declared.; There is also a warning in ``transferFrom()``, because although the method; locks ``this->mu``, it does not lock ``b.mu``. The analysis understands; that these are two separate mutexes, in two different objects. Finally, there is a warning in the ``withdraw()`` method, because it fails to; unlock ``mu``. Every lock must have a corresponding unlock, and the analysis; will detect both double locks, and double unlocks. A function is allowed to; acquire a lock without releasing it, (or vice versa), but it must be annotated; as such (using ``ACQUIRE``/``RELEASE``). Running The Analysis; --------------------. To run the analysis, simply compile with the ``-Wthread-safety`` flag, e.g. .. code-block:: bash. clang -c -Wthread-safety example.cpp. Note that this example assumes the presence of a suitably annotated; :ref:`mutexheader` that declares which methods perform locking,; unlocking, and so on. Basic Concepts: Capabilities; ============================. Thread safety analysis provides a way of protecting *resources* with; *capabilities*. A resource is either a data member, or a function/method; that provides access to some underlying resource. The analysis ensures that; the calling thread cannot access the *resource* (i.e. call the function, or; read/write the data) unless it has the *capability* to do so. Capabilities are associated with named C++ objects which declare specific; methods to acquire and release the capability. The name of the object serves; to identify the capability. The most common example is a mutex. For example,; if ``mu`` is a mutex, then calling ``mu.Lock()`` causes the calling thread; to acquire the ca",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:3275,Safety,safe,safety,3275," locked ``mu``, it is safe to modify; ``balance`` within the body of the method. The ``depositImpl()`` method does not have ``REQUIRES``, so the; analysis issues a warning. Thread safety analysis is not inter-procedural, so; caller requirements must be explicitly declared.; There is also a warning in ``transferFrom()``, because although the method; locks ``this->mu``, it does not lock ``b.mu``. The analysis understands; that these are two separate mutexes, in two different objects. Finally, there is a warning in the ``withdraw()`` method, because it fails to; unlock ``mu``. Every lock must have a corresponding unlock, and the analysis; will detect both double locks, and double unlocks. A function is allowed to; acquire a lock without releasing it, (or vice versa), but it must be annotated; as such (using ``ACQUIRE``/``RELEASE``). Running The Analysis; --------------------. To run the analysis, simply compile with the ``-Wthread-safety`` flag, e.g. .. code-block:: bash. clang -c -Wthread-safety example.cpp. Note that this example assumes the presence of a suitably annotated; :ref:`mutexheader` that declares which methods perform locking,; unlocking, and so on. Basic Concepts: Capabilities; ============================. Thread safety analysis provides a way of protecting *resources* with; *capabilities*. A resource is either a data member, or a function/method; that provides access to some underlying resource. The analysis ensures that; the calling thread cannot access the *resource* (i.e. call the function, or; read/write the data) unless it has the *capability* to do so. Capabilities are associated with named C++ objects which declare specific; methods to acquire and release the capability. The name of the object serves; to identify the capability. The most common example is a mutex. For example,; if ``mu`` is a mutex, then calling ``mu.Lock()`` causes the calling thread; to acquire the capability to access data that is protected by ``mu``. Similarly,; calling ``mu.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:3518,Safety,safe,safety,3518," is also a warning in ``transferFrom()``, because although the method; locks ``this->mu``, it does not lock ``b.mu``. The analysis understands; that these are two separate mutexes, in two different objects. Finally, there is a warning in the ``withdraw()`` method, because it fails to; unlock ``mu``. Every lock must have a corresponding unlock, and the analysis; will detect both double locks, and double unlocks. A function is allowed to; acquire a lock without releasing it, (or vice versa), but it must be annotated; as such (using ``ACQUIRE``/``RELEASE``). Running The Analysis; --------------------. To run the analysis, simply compile with the ``-Wthread-safety`` flag, e.g. .. code-block:: bash. clang -c -Wthread-safety example.cpp. Note that this example assumes the presence of a suitably annotated; :ref:`mutexheader` that declares which methods perform locking,; unlocking, and so on. Basic Concepts: Capabilities; ============================. Thread safety analysis provides a way of protecting *resources* with; *capabilities*. A resource is either a data member, or a function/method; that provides access to some underlying resource. The analysis ensures that; the calling thread cannot access the *resource* (i.e. call the function, or; read/write the data) unless it has the *capability* to do so. Capabilities are associated with named C++ objects which declare specific; methods to acquire and release the capability. The name of the object serves; to identify the capability. The most common example is a mutex. For example,; if ``mu`` is a mutex, then calling ``mu.Lock()`` causes the calling thread; to acquire the capability to access data that is protected by ``mu``. Similarly,; calling ``mu.Unlock()`` releases that capability. A thread may hold a capability either *exclusively* or *shared*. An exclusive; capability can be held by only one thread at a time, while a shared capability; can be held by many threads at the same time. This mechanism enforces a; multiple-re",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:5943,Safety,safe,safety,5943," copy of a capability, nor can it destroy; one. A thread can only release a capability to another thread, or acquire one; from another thread. The annotations are deliberately agnostic about the; exact mechanism used to acquire and release capabilities; it assumes that the; underlying implementation (e.g. the Mutex implementation) does the handoff in; an appropriate manner. The set of capabilities that are actually held by a given thread at a given; point in program execution is a run-time concept. The static analysis works; by calculating an approximation of that set, called the *capability; environment*. The capability environment is calculated for every program point,; and describes the set of capabilities that are statically known to be held, or; not held, at that particular point. This environment is a conservative; approximation of the full set of capabilities that will actually held by a; thread at run-time. Reference Guide; ===============. The thread safety analysis uses attributes to declare threading constraints.; Attributes must be attached to named declarations, such as classes, methods,; and data members. Users are *strongly advised* to define macros for the various; attributes; example definitions can be found in :ref:`mutexheader`, below.; The following documentation assumes the use of macros. The attributes only control assumptions made by thread safety analysis and the; warnings it issues. They don't affect generated code or behavior at run-time. For historical reasons, prior versions of thread safety used macro names that; were very lock-centric. These macros have since been renamed to fit a more; general capability model. The prior names are still in use, and will be; mentioned under the tag *previously* where appropriate. GUARDED_BY(c) and PT_GUARDED_BY(c); ----------------------------------. ``GUARDED_BY`` is an attribute on data members, which declares that the data; member is protected by the given capability. Read operations on the data; requ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:6355,Safety,safe,safety,6355," set of capabilities that are actually held by a given thread at a given; point in program execution is a run-time concept. The static analysis works; by calculating an approximation of that set, called the *capability; environment*. The capability environment is calculated for every program point,; and describes the set of capabilities that are statically known to be held, or; not held, at that particular point. This environment is a conservative; approximation of the full set of capabilities that will actually held by a; thread at run-time. Reference Guide; ===============. The thread safety analysis uses attributes to declare threading constraints.; Attributes must be attached to named declarations, such as classes, methods,; and data members. Users are *strongly advised* to define macros for the various; attributes; example definitions can be found in :ref:`mutexheader`, below.; The following documentation assumes the use of macros. The attributes only control assumptions made by thread safety analysis and the; warnings it issues. They don't affect generated code or behavior at run-time. For historical reasons, prior versions of thread safety used macro names that; were very lock-centric. These macros have since been renamed to fit a more; general capability model. The prior names are still in use, and will be; mentioned under the tag *previously* where appropriate. GUARDED_BY(c) and PT_GUARDED_BY(c); ----------------------------------. ``GUARDED_BY`` is an attribute on data members, which declares that the data; member is protected by the given capability. Read operations on the data; require shared access, while write operations require exclusive access. ``PT_GUARDED_BY`` is similar, but is intended for use on pointers and smart; pointers. There is no constraint on the data member itself, but the *data that; it points to* is protected by the given capability. .. code-block:: c++. Mutex mu;; int *p1 GUARDED_BY(mu);; int *p2 PT_GUARDED_BY(mu);; unique_ptr<int> p",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:6507,Safety,safe,safety,6507,"lating an approximation of that set, called the *capability; environment*. The capability environment is calculated for every program point,; and describes the set of capabilities that are statically known to be held, or; not held, at that particular point. This environment is a conservative; approximation of the full set of capabilities that will actually held by a; thread at run-time. Reference Guide; ===============. The thread safety analysis uses attributes to declare threading constraints.; Attributes must be attached to named declarations, such as classes, methods,; and data members. Users are *strongly advised* to define macros for the various; attributes; example definitions can be found in :ref:`mutexheader`, below.; The following documentation assumes the use of macros. The attributes only control assumptions made by thread safety analysis and the; warnings it issues. They don't affect generated code or behavior at run-time. For historical reasons, prior versions of thread safety used macro names that; were very lock-centric. These macros have since been renamed to fit a more; general capability model. The prior names are still in use, and will be; mentioned under the tag *previously* where appropriate. GUARDED_BY(c) and PT_GUARDED_BY(c); ----------------------------------. ``GUARDED_BY`` is an attribute on data members, which declares that the data; member is protected by the given capability. Read operations on the data; require shared access, while write operations require exclusive access. ``PT_GUARDED_BY`` is similar, but is intended for use on pointers and smart; pointers. There is no constraint on the data member itself, but the *data that; it points to* is protected by the given capability. .. code-block:: c++. Mutex mu;; int *p1 GUARDED_BY(mu);; int *p2 PT_GUARDED_BY(mu);; unique_ptr<int> p3 PT_GUARDED_BY(mu);. void test() {; p1 = 0; // Warning!. *p2 = 42; // Warning!; p2 = new int; // OK. *p3 = 42; // Warning!; p3.reset(new int); // OK.; }. REQUI",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:11012,Safety,safe,safety,11012,"a[i]; }; };. void test() {; Container<int> c;; c.Lock();; int i = c.getElem(0);; c.Unlock();; }. EXCLUDES(...); -------------. *Previously*: ``LOCKS_EXCLUDED``. ``EXCLUDES`` is an attribute on functions or methods, which declares that; the caller must *not* hold the given capabilities. This annotation is; used to prevent deadlock. Many mutex implementations are not re-entrant, so; deadlock can occur if the function acquires the mutex a second time. .. code-block:: c++. Mutex mu;; int a GUARDED_BY(mu);. void clear() EXCLUDES(mu) {; mu.Lock();; a = 0;; mu.Unlock();; }. void reset() {; mu.Lock();; clear(); // Warning! Caller cannot hold 'mu'.; mu.Unlock();; }. Unlike ``REQUIRES``, ``EXCLUDES`` is optional. The analysis will not issue a; warning if the attribute is missing, which can lead to false negatives in some; cases. This issue is discussed further in :ref:`negative`. NO_THREAD_SAFETY_ANALYSIS; -------------------------. ``NO_THREAD_SAFETY_ANALYSIS`` is an attribute on functions or methods, which; turns off thread safety checking for that method. It provides an escape hatch; for functions which are either (1) deliberately thread-unsafe, or (2) are; thread-safe, but too complicated for the analysis to understand. Reasons for; (2) will be described in the :ref:`limitations`, below. .. code-block:: c++. class Counter {; Mutex mu;; int a GUARDED_BY(mu);. void unsafeIncrement() NO_THREAD_SAFETY_ANALYSIS { a++; }; };. Unlike the other attributes, NO_THREAD_SAFETY_ANALYSIS is not part of the; interface of a function, and should thus be placed on the function definition; (in the ``.cc`` or ``.cpp`` file) rather than on the function declaration; (in the header). RETURN_CAPABILITY(c); --------------------. *Previously*: ``LOCK_RETURNED``. ``RETURN_CAPABILITY`` is an attribute on functions or methods, which declares; that the function returns a reference to the given capability. It is used to; annotate getter methods that return mutexes. .. code-block:: c++. class MyClass {;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:11129,Safety,unsafe,unsafe,11129,"_EXCLUDED``. ``EXCLUDES`` is an attribute on functions or methods, which declares that; the caller must *not* hold the given capabilities. This annotation is; used to prevent deadlock. Many mutex implementations are not re-entrant, so; deadlock can occur if the function acquires the mutex a second time. .. code-block:: c++. Mutex mu;; int a GUARDED_BY(mu);. void clear() EXCLUDES(mu) {; mu.Lock();; a = 0;; mu.Unlock();; }. void reset() {; mu.Lock();; clear(); // Warning! Caller cannot hold 'mu'.; mu.Unlock();; }. Unlike ``REQUIRES``, ``EXCLUDES`` is optional. The analysis will not issue a; warning if the attribute is missing, which can lead to false negatives in some; cases. This issue is discussed further in :ref:`negative`. NO_THREAD_SAFETY_ANALYSIS; -------------------------. ``NO_THREAD_SAFETY_ANALYSIS`` is an attribute on functions or methods, which; turns off thread safety checking for that method. It provides an escape hatch; for functions which are either (1) deliberately thread-unsafe, or (2) are; thread-safe, but too complicated for the analysis to understand. Reasons for; (2) will be described in the :ref:`limitations`, below. .. code-block:: c++. class Counter {; Mutex mu;; int a GUARDED_BY(mu);. void unsafeIncrement() NO_THREAD_SAFETY_ANALYSIS { a++; }; };. Unlike the other attributes, NO_THREAD_SAFETY_ANALYSIS is not part of the; interface of a function, and should thus be placed on the function definition; (in the ``.cc`` or ``.cpp`` file) rather than on the function declaration; (in the header). RETURN_CAPABILITY(c); --------------------. *Previously*: ``LOCK_RETURNED``. ``RETURN_CAPABILITY`` is an attribute on functions or methods, which declares; that the function returns a reference to the given capability. It is used to; annotate getter methods that return mutexes. .. code-block:: c++. class MyClass {; private:; Mutex mu;; int a GUARDED_BY(mu);. public:; Mutex* getMu() RETURN_CAPABILITY(mu) { return &mu; }. // analysis knows that getMu() == mu; voi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:11156,Safety,safe,safe,11156,"_EXCLUDED``. ``EXCLUDES`` is an attribute on functions or methods, which declares that; the caller must *not* hold the given capabilities. This annotation is; used to prevent deadlock. Many mutex implementations are not re-entrant, so; deadlock can occur if the function acquires the mutex a second time. .. code-block:: c++. Mutex mu;; int a GUARDED_BY(mu);. void clear() EXCLUDES(mu) {; mu.Lock();; a = 0;; mu.Unlock();; }. void reset() {; mu.Lock();; clear(); // Warning! Caller cannot hold 'mu'.; mu.Unlock();; }. Unlike ``REQUIRES``, ``EXCLUDES`` is optional. The analysis will not issue a; warning if the attribute is missing, which can lead to false negatives in some; cases. This issue is discussed further in :ref:`negative`. NO_THREAD_SAFETY_ANALYSIS; -------------------------. ``NO_THREAD_SAFETY_ANALYSIS`` is an attribute on functions or methods, which; turns off thread safety checking for that method. It provides an escape hatch; for functions which are either (1) deliberately thread-unsafe, or (2) are; thread-safe, but too complicated for the analysis to understand. Reasons for; (2) will be described in the :ref:`limitations`, below. .. code-block:: c++. class Counter {; Mutex mu;; int a GUARDED_BY(mu);. void unsafeIncrement() NO_THREAD_SAFETY_ANALYSIS { a++; }; };. Unlike the other attributes, NO_THREAD_SAFETY_ANALYSIS is not part of the; interface of a function, and should thus be placed on the function definition; (in the ``.cc`` or ``.cpp`` file) rather than on the function declaration; (in the header). RETURN_CAPABILITY(c); --------------------. *Previously*: ``LOCK_RETURNED``. ``RETURN_CAPABILITY`` is an attribute on functions or methods, which declares; that the function returns a reference to the given capability. It is used to; annotate getter methods that return mutexes. .. code-block:: c++. class MyClass {; private:; Mutex mu;; int a GUARDED_BY(mu);. public:; Mutex* getMu() RETURN_CAPABILITY(mu) { return &mu; }. // analysis knows that getMu() == mu; voi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:11360,Safety,unsafe,unsafeIncrement,11360," the function acquires the mutex a second time. .. code-block:: c++. Mutex mu;; int a GUARDED_BY(mu);. void clear() EXCLUDES(mu) {; mu.Lock();; a = 0;; mu.Unlock();; }. void reset() {; mu.Lock();; clear(); // Warning! Caller cannot hold 'mu'.; mu.Unlock();; }. Unlike ``REQUIRES``, ``EXCLUDES`` is optional. The analysis will not issue a; warning if the attribute is missing, which can lead to false negatives in some; cases. This issue is discussed further in :ref:`negative`. NO_THREAD_SAFETY_ANALYSIS; -------------------------. ``NO_THREAD_SAFETY_ANALYSIS`` is an attribute on functions or methods, which; turns off thread safety checking for that method. It provides an escape hatch; for functions which are either (1) deliberately thread-unsafe, or (2) are; thread-safe, but too complicated for the analysis to understand. Reasons for; (2) will be described in the :ref:`limitations`, below. .. code-block:: c++. class Counter {; Mutex mu;; int a GUARDED_BY(mu);. void unsafeIncrement() NO_THREAD_SAFETY_ANALYSIS { a++; }; };. Unlike the other attributes, NO_THREAD_SAFETY_ANALYSIS is not part of the; interface of a function, and should thus be placed on the function definition; (in the ``.cc`` or ``.cpp`` file) rather than on the function declaration; (in the header). RETURN_CAPABILITY(c); --------------------. *Previously*: ``LOCK_RETURNED``. ``RETURN_CAPABILITY`` is an attribute on functions or methods, which declares; that the function returns a reference to the given capability. It is used to; annotate getter methods that return mutexes. .. code-block:: c++. class MyClass {; private:; Mutex mu;; int a GUARDED_BY(mu);. public:; Mutex* getMu() RETURN_CAPABILITY(mu) { return &mu; }. // analysis knows that getMu() == mu; void clear() REQUIRES(getMu()) { a = 0; }; };. ACQUIRED_BEFORE(...), ACQUIRED_AFTER(...); -----------------------------------------. ``ACQUIRED_BEFORE`` and ``ACQUIRED_AFTER`` are attributes on member; declarations, specifically declarations of mutexes or othe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:13764,Safety,safe,safety,13764,"ring>); --------------------. *Previously*: ``LOCKABLE``. ``CAPABILITY`` is an attribute on classes, which specifies that objects of the; class can be used as a capability. The string argument specifies the kind of; capability in error messages, e.g. ``""mutex""``. See the ``Container`` example; given above, or the ``Mutex`` class in :ref:`mutexheader`. SCOPED_CAPABILITY; -----------------. *Previously*: ``SCOPED_LOCKABLE``. ``SCOPED_CAPABILITY`` is an attribute on classes that implement RAII-style; locking, in which a capability is acquired in the constructor, and released in; the destructor. Such classes require special handling because the constructor; and destructor refer to the capability via different names; see the; ``MutexLocker`` class in :ref:`mutexheader`, below. Scoped capabilities are treated as capabilities that are implicitly acquired; on construction and released on destruction. They are associated with; the set of (regular) capabilities named in thread safety attributes on the; constructor or function returning them by value (using C++17 guaranteed copy; elision). Acquire-type attributes on other member functions are treated as; applying to that set of associated capabilities, while ``RELEASE`` implies that; a function releases all associated capabilities in whatever mode they're held. TRY_ACQUIRE(<bool>, ...), TRY_ACQUIRE_SHARED(<bool>, ...); ---------------------------------------------------------. *Previously:* ``EXCLUSIVE_TRYLOCK_FUNCTION``, ``SHARED_TRYLOCK_FUNCTION``. These are attributes on a function or method that tries to acquire the given; capability, and returns a boolean value indicating success or failure.; The first argument must be ``true`` or ``false``, to specify which return value; indicates success, and the remaining arguments are interpreted in the same way; as ``ACQUIRE``. See :ref:`mutexheader`, below, for example uses. Because the analysis doesn't support conditional locking, a capability is; treated as acquired after the firs",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:15784,Safety,safe,safety,15784," value of a try-acquire; function. .. code-block:: c++. Mutex mu;; int a GUARDED_BY(mu);. void foo() {; bool success = mu.TryLock();; a = 0; // Warning, mu is not locked.; if (success) {; a = 0; // Ok.; mu.Unlock();; } else {; a = 0; // Warning, mu is not locked.; }; }. ASSERT_CAPABILITY(...) and ASSERT_SHARED_CAPABILITY(...); --------------------------------------------------------. *Previously:* ``ASSERT_EXCLUSIVE_LOCK``, ``ASSERT_SHARED_LOCK``. These are attributes on a function or method which asserts the calling thread; already holds the given capability, for example by performing a run-time test; and terminating if the capability is not held. Presence of this annotation; causes the analysis to assume the capability is held after calls to the; annotated function. See :ref:`mutexheader`, below, for example uses. GUARDED_VAR and PT_GUARDED_VAR; ------------------------------. Use of these attributes has been deprecated. Warning flags; -------------. * ``-Wthread-safety``: Umbrella flag which turns on the following:. + ``-Wthread-safety-attributes``: Semantic checks for thread safety attributes.; + ``-Wthread-safety-analysis``: The core analysis.; + ``-Wthread-safety-precise``: Requires that mutex expressions match precisely.; This warning can be disabled for code which has a lot of aliases.; + ``-Wthread-safety-reference``: Checks when guarded members are passed by reference. :ref:`negative` are an experimental feature, which are enabled with:. * ``-Wthread-safety-negative``: Negative capabilities. Off by default. When new features and checks are added to the analysis, they can often introduce; additional warnings. Those warnings are initially released as *beta* warnings; for a period of time, after which they are migrated into the standard analysis. * ``-Wthread-safety-beta``: New features. Off by default. .. _negative:. Negative Capabilities; =====================. Thread Safety Analysis is designed to prevent both race conditions and; deadlock. The GUARDED_BY ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:15852,Safety,safe,safety-attributes,15852,"UARDED_BY(mu);. void foo() {; bool success = mu.TryLock();; a = 0; // Warning, mu is not locked.; if (success) {; a = 0; // Ok.; mu.Unlock();; } else {; a = 0; // Warning, mu is not locked.; }; }. ASSERT_CAPABILITY(...) and ASSERT_SHARED_CAPABILITY(...); --------------------------------------------------------. *Previously:* ``ASSERT_EXCLUSIVE_LOCK``, ``ASSERT_SHARED_LOCK``. These are attributes on a function or method which asserts the calling thread; already holds the given capability, for example by performing a run-time test; and terminating if the capability is not held. Presence of this annotation; causes the analysis to assume the capability is held after calls to the; annotated function. See :ref:`mutexheader`, below, for example uses. GUARDED_VAR and PT_GUARDED_VAR; ------------------------------. Use of these attributes has been deprecated. Warning flags; -------------. * ``-Wthread-safety``: Umbrella flag which turns on the following:. + ``-Wthread-safety-attributes``: Semantic checks for thread safety attributes.; + ``-Wthread-safety-analysis``: The core analysis.; + ``-Wthread-safety-precise``: Requires that mutex expressions match precisely.; This warning can be disabled for code which has a lot of aliases.; + ``-Wthread-safety-reference``: Checks when guarded members are passed by reference. :ref:`negative` are an experimental feature, which are enabled with:. * ``-Wthread-safety-negative``: Negative capabilities. Off by default. When new features and checks are added to the analysis, they can often introduce; additional warnings. Those warnings are initially released as *beta* warnings; for a period of time, after which they are migrated into the standard analysis. * ``-Wthread-safety-beta``: New features. Off by default. .. _negative:. Negative Capabilities; =====================. Thread Safety Analysis is designed to prevent both race conditions and; deadlock. The GUARDED_BY and REQUIRES attributes prevent race conditions, by; ensuring that a capab",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:15900,Safety,safe,safety,15900,"UARDED_BY(mu);. void foo() {; bool success = mu.TryLock();; a = 0; // Warning, mu is not locked.; if (success) {; a = 0; // Ok.; mu.Unlock();; } else {; a = 0; // Warning, mu is not locked.; }; }. ASSERT_CAPABILITY(...) and ASSERT_SHARED_CAPABILITY(...); --------------------------------------------------------. *Previously:* ``ASSERT_EXCLUSIVE_LOCK``, ``ASSERT_SHARED_LOCK``. These are attributes on a function or method which asserts the calling thread; already holds the given capability, for example by performing a run-time test; and terminating if the capability is not held. Presence of this annotation; causes the analysis to assume the capability is held after calls to the; annotated function. See :ref:`mutexheader`, below, for example uses. GUARDED_VAR and PT_GUARDED_VAR; ------------------------------. Use of these attributes has been deprecated. Warning flags; -------------. * ``-Wthread-safety``: Umbrella flag which turns on the following:. + ``-Wthread-safety-attributes``: Semantic checks for thread safety attributes.; + ``-Wthread-safety-analysis``: The core analysis.; + ``-Wthread-safety-precise``: Requires that mutex expressions match precisely.; This warning can be disabled for code which has a lot of aliases.; + ``-Wthread-safety-reference``: Checks when guarded members are passed by reference. :ref:`negative` are an experimental feature, which are enabled with:. * ``-Wthread-safety-negative``: Negative capabilities. Off by default. When new features and checks are added to the analysis, they can often introduce; additional warnings. Those warnings are initially released as *beta* warnings; for a period of time, after which they are migrated into the standard analysis. * ``-Wthread-safety-beta``: New features. Off by default. .. _negative:. Negative Capabilities; =====================. Thread Safety Analysis is designed to prevent both race conditions and; deadlock. The GUARDED_BY and REQUIRES attributes prevent race conditions, by; ensuring that a capab",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:15933,Safety,safe,safety-analysis,15933," // Warning, mu is not locked.; if (success) {; a = 0; // Ok.; mu.Unlock();; } else {; a = 0; // Warning, mu is not locked.; }; }. ASSERT_CAPABILITY(...) and ASSERT_SHARED_CAPABILITY(...); --------------------------------------------------------. *Previously:* ``ASSERT_EXCLUSIVE_LOCK``, ``ASSERT_SHARED_LOCK``. These are attributes on a function or method which asserts the calling thread; already holds the given capability, for example by performing a run-time test; and terminating if the capability is not held. Presence of this annotation; causes the analysis to assume the capability is held after calls to the; annotated function. See :ref:`mutexheader`, below, for example uses. GUARDED_VAR and PT_GUARDED_VAR; ------------------------------. Use of these attributes has been deprecated. Warning flags; -------------. * ``-Wthread-safety``: Umbrella flag which turns on the following:. + ``-Wthread-safety-attributes``: Semantic checks for thread safety attributes.; + ``-Wthread-safety-analysis``: The core analysis.; + ``-Wthread-safety-precise``: Requires that mutex expressions match precisely.; This warning can be disabled for code which has a lot of aliases.; + ``-Wthread-safety-reference``: Checks when guarded members are passed by reference. :ref:`negative` are an experimental feature, which are enabled with:. * ``-Wthread-safety-negative``: Negative capabilities. Off by default. When new features and checks are added to the analysis, they can often introduce; additional warnings. Those warnings are initially released as *beta* warnings; for a period of time, after which they are migrated into the standard analysis. * ``-Wthread-safety-beta``: New features. Off by default. .. _negative:. Negative Capabilities; =====================. Thread Safety Analysis is designed to prevent both race conditions and; deadlock. The GUARDED_BY and REQUIRES attributes prevent race conditions, by; ensuring that a capability is held before reading or writing to guarded data,; and the ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:15985,Safety,safe,safety-precise,15985,"Unlock();; } else {; a = 0; // Warning, mu is not locked.; }; }. ASSERT_CAPABILITY(...) and ASSERT_SHARED_CAPABILITY(...); --------------------------------------------------------. *Previously:* ``ASSERT_EXCLUSIVE_LOCK``, ``ASSERT_SHARED_LOCK``. These are attributes on a function or method which asserts the calling thread; already holds the given capability, for example by performing a run-time test; and terminating if the capability is not held. Presence of this annotation; causes the analysis to assume the capability is held after calls to the; annotated function. See :ref:`mutexheader`, below, for example uses. GUARDED_VAR and PT_GUARDED_VAR; ------------------------------. Use of these attributes has been deprecated. Warning flags; -------------. * ``-Wthread-safety``: Umbrella flag which turns on the following:. + ``-Wthread-safety-attributes``: Semantic checks for thread safety attributes.; + ``-Wthread-safety-analysis``: The core analysis.; + ``-Wthread-safety-precise``: Requires that mutex expressions match precisely.; This warning can be disabled for code which has a lot of aliases.; + ``-Wthread-safety-reference``: Checks when guarded members are passed by reference. :ref:`negative` are an experimental feature, which are enabled with:. * ``-Wthread-safety-negative``: Negative capabilities. Off by default. When new features and checks are added to the analysis, they can often introduce; additional warnings. Those warnings are initially released as *beta* warnings; for a period of time, after which they are migrated into the standard analysis. * ``-Wthread-safety-beta``: New features. Off by default. .. _negative:. Negative Capabilities; =====================. Thread Safety Analysis is designed to prevent both race conditions and; deadlock. The GUARDED_BY and REQUIRES attributes prevent race conditions, by; ensuring that a capability is held before reading or writing to guarded data,; and the EXCLUDES attribute prevents deadlock, by making sure that a mutex i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:16133,Safety,safe,safety-reference,16133,"----------------------------. *Previously:* ``ASSERT_EXCLUSIVE_LOCK``, ``ASSERT_SHARED_LOCK``. These are attributes on a function or method which asserts the calling thread; already holds the given capability, for example by performing a run-time test; and terminating if the capability is not held. Presence of this annotation; causes the analysis to assume the capability is held after calls to the; annotated function. See :ref:`mutexheader`, below, for example uses. GUARDED_VAR and PT_GUARDED_VAR; ------------------------------. Use of these attributes has been deprecated. Warning flags; -------------. * ``-Wthread-safety``: Umbrella flag which turns on the following:. + ``-Wthread-safety-attributes``: Semantic checks for thread safety attributes.; + ``-Wthread-safety-analysis``: The core analysis.; + ``-Wthread-safety-precise``: Requires that mutex expressions match precisely.; This warning can be disabled for code which has a lot of aliases.; + ``-Wthread-safety-reference``: Checks when guarded members are passed by reference. :ref:`negative` are an experimental feature, which are enabled with:. * ``-Wthread-safety-negative``: Negative capabilities. Off by default. When new features and checks are added to the analysis, they can often introduce; additional warnings. Those warnings are initially released as *beta* warnings; for a period of time, after which they are migrated into the standard analysis. * ``-Wthread-safety-beta``: New features. Off by default. .. _negative:. Negative Capabilities; =====================. Thread Safety Analysis is designed to prevent both race conditions and; deadlock. The GUARDED_BY and REQUIRES attributes prevent race conditions, by; ensuring that a capability is held before reading or writing to guarded data,; and the EXCLUDES attribute prevents deadlock, by making sure that a mutex is; *not* held. However, EXCLUDES is an optional attribute, and does not provide the same; safety guarantee as REQUIRES. In particular:. * A function wh",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:16289,Safety,safe,safety-negative,16289,"hich asserts the calling thread; already holds the given capability, for example by performing a run-time test; and terminating if the capability is not held. Presence of this annotation; causes the analysis to assume the capability is held after calls to the; annotated function. See :ref:`mutexheader`, below, for example uses. GUARDED_VAR and PT_GUARDED_VAR; ------------------------------. Use of these attributes has been deprecated. Warning flags; -------------. * ``-Wthread-safety``: Umbrella flag which turns on the following:. + ``-Wthread-safety-attributes``: Semantic checks for thread safety attributes.; + ``-Wthread-safety-analysis``: The core analysis.; + ``-Wthread-safety-precise``: Requires that mutex expressions match precisely.; This warning can be disabled for code which has a lot of aliases.; + ``-Wthread-safety-reference``: Checks when guarded members are passed by reference. :ref:`negative` are an experimental feature, which are enabled with:. * ``-Wthread-safety-negative``: Negative capabilities. Off by default. When new features and checks are added to the analysis, they can often introduce; additional warnings. Those warnings are initially released as *beta* warnings; for a period of time, after which they are migrated into the standard analysis. * ``-Wthread-safety-beta``: New features. Off by default. .. _negative:. Negative Capabilities; =====================. Thread Safety Analysis is designed to prevent both race conditions and; deadlock. The GUARDED_BY and REQUIRES attributes prevent race conditions, by; ensuring that a capability is held before reading or writing to guarded data,; and the EXCLUDES attribute prevents deadlock, by making sure that a mutex is; *not* held. However, EXCLUDES is an optional attribute, and does not provide the same; safety guarantee as REQUIRES. In particular:. * A function which acquires a capability does not have to exclude it.; * A function which calls a function that excludes a capability does not; have transit",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:16601,Safety,safe,safety-beta,16601,"elow, for example uses. GUARDED_VAR and PT_GUARDED_VAR; ------------------------------. Use of these attributes has been deprecated. Warning flags; -------------. * ``-Wthread-safety``: Umbrella flag which turns on the following:. + ``-Wthread-safety-attributes``: Semantic checks for thread safety attributes.; + ``-Wthread-safety-analysis``: The core analysis.; + ``-Wthread-safety-precise``: Requires that mutex expressions match precisely.; This warning can be disabled for code which has a lot of aliases.; + ``-Wthread-safety-reference``: Checks when guarded members are passed by reference. :ref:`negative` are an experimental feature, which are enabled with:. * ``-Wthread-safety-negative``: Negative capabilities. Off by default. When new features and checks are added to the analysis, they can often introduce; additional warnings. Those warnings are initially released as *beta* warnings; for a period of time, after which they are migrated into the standard analysis. * ``-Wthread-safety-beta``: New features. Off by default. .. _negative:. Negative Capabilities; =====================. Thread Safety Analysis is designed to prevent both race conditions and; deadlock. The GUARDED_BY and REQUIRES attributes prevent race conditions, by; ensuring that a capability is held before reading or writing to guarded data,; and the EXCLUDES attribute prevents deadlock, by making sure that a mutex is; *not* held. However, EXCLUDES is an optional attribute, and does not provide the same; safety guarantee as REQUIRES. In particular:. * A function which acquires a capability does not have to exclude it.; * A function which calls a function that excludes a capability does not; have transitively exclude that capability. As a result, EXCLUDES can easily produce false negatives:. .. code-block:: c++. class Foo {; Mutex mu;. void foo() {; mu.Lock();; bar(); // No warning.; baz(); // No warning.; mu.Unlock();; }. void bar() { // No warning. (Should have EXCLUDES(mu)).; mu.Lock();; // ...; mu.U",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:17101,Safety,safe,safety,17101,"bled for code which has a lot of aliases.; + ``-Wthread-safety-reference``: Checks when guarded members are passed by reference. :ref:`negative` are an experimental feature, which are enabled with:. * ``-Wthread-safety-negative``: Negative capabilities. Off by default. When new features and checks are added to the analysis, they can often introduce; additional warnings. Those warnings are initially released as *beta* warnings; for a period of time, after which they are migrated into the standard analysis. * ``-Wthread-safety-beta``: New features. Off by default. .. _negative:. Negative Capabilities; =====================. Thread Safety Analysis is designed to prevent both race conditions and; deadlock. The GUARDED_BY and REQUIRES attributes prevent race conditions, by; ensuring that a capability is held before reading or writing to guarded data,; and the EXCLUDES attribute prevents deadlock, by making sure that a mutex is; *not* held. However, EXCLUDES is an optional attribute, and does not provide the same; safety guarantee as REQUIRES. In particular:. * A function which acquires a capability does not have to exclude it.; * A function which calls a function that excludes a capability does not; have transitively exclude that capability. As a result, EXCLUDES can easily produce false negatives:. .. code-block:: c++. class Foo {; Mutex mu;. void foo() {; mu.Lock();; bar(); // No warning.; baz(); // No warning.; mu.Unlock();; }. void bar() { // No warning. (Should have EXCLUDES(mu)).; mu.Lock();; // ...; mu.Unlock();; }. void baz() {; bif(); // No warning. (Should have EXCLUDES(mu)).; }. void bif() EXCLUDES(mu);; };. Negative requirements are an alternative EXCLUDES that provide; a stronger safety guarantee. A negative requirement uses the REQUIRES; attribute, in conjunction with the ``!`` operator, to indicate that a capability; should *not* be held. For example, using ``REQUIRES(!mu)`` instead of ``EXCLUDES(mu)`` will produce; the appropriate warnings:. .. code-block:",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:17794,Safety,safe,safety,17794,"onditions and; deadlock. The GUARDED_BY and REQUIRES attributes prevent race conditions, by; ensuring that a capability is held before reading or writing to guarded data,; and the EXCLUDES attribute prevents deadlock, by making sure that a mutex is; *not* held. However, EXCLUDES is an optional attribute, and does not provide the same; safety guarantee as REQUIRES. In particular:. * A function which acquires a capability does not have to exclude it.; * A function which calls a function that excludes a capability does not; have transitively exclude that capability. As a result, EXCLUDES can easily produce false negatives:. .. code-block:: c++. class Foo {; Mutex mu;. void foo() {; mu.Lock();; bar(); // No warning.; baz(); // No warning.; mu.Unlock();; }. void bar() { // No warning. (Should have EXCLUDES(mu)).; mu.Lock();; // ...; mu.Unlock();; }. void baz() {; bif(); // No warning. (Should have EXCLUDES(mu)).; }. void bif() EXCLUDES(mu);; };. Negative requirements are an alternative EXCLUDES that provide; a stronger safety guarantee. A negative requirement uses the REQUIRES; attribute, in conjunction with the ``!`` operator, to indicate that a capability; should *not* be held. For example, using ``REQUIRES(!mu)`` instead of ``EXCLUDES(mu)`` will produce; the appropriate warnings:. .. code-block:: c++. class FooNeg {; Mutex mu;. void foo() REQUIRES(!mu) { // foo() now requires !mu.; mu.Lock();; bar();; baz();; mu.Unlock();; }. void bar() {; mu.Lock(); // WARNING! Missing REQUIRES(!mu).; // ...; mu.Unlock();; }. void baz() {; bif(); // WARNING! Missing REQUIRES(!mu).; }. void bif() REQUIRES(!mu);; };. Negative requirements are an experimental feature which is off by default,; because it will produce many warnings in existing code. It can be enabled; by passing ``-Wthread-safety-negative``. .. _faq:. Frequently Asked Questions; ==========================. (Q) Should I put attributes in the header file, or in the .cc/.cpp/.cxx file?. (A) Attributes are part of the formal i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:18562,Safety,safe,safety-negative,18562,"ing. (Should have EXCLUDES(mu)).; mu.Lock();; // ...; mu.Unlock();; }. void baz() {; bif(); // No warning. (Should have EXCLUDES(mu)).; }. void bif() EXCLUDES(mu);; };. Negative requirements are an alternative EXCLUDES that provide; a stronger safety guarantee. A negative requirement uses the REQUIRES; attribute, in conjunction with the ``!`` operator, to indicate that a capability; should *not* be held. For example, using ``REQUIRES(!mu)`` instead of ``EXCLUDES(mu)`` will produce; the appropriate warnings:. .. code-block:: c++. class FooNeg {; Mutex mu;. void foo() REQUIRES(!mu) { // foo() now requires !mu.; mu.Lock();; bar();; baz();; mu.Unlock();; }. void bar() {; mu.Lock(); // WARNING! Missing REQUIRES(!mu).; // ...; mu.Unlock();; }. void baz() {; bif(); // WARNING! Missing REQUIRES(!mu).; }. void bif() REQUIRES(!mu);; };. Negative requirements are an experimental feature which is off by default,; because it will produce many warnings in existing code. It can be enabled; by passing ``-Wthread-safety-negative``. .. _faq:. Frequently Asked Questions; ==========================. (Q) Should I put attributes in the header file, or in the .cc/.cpp/.cxx file?. (A) Attributes are part of the formal interface of a function, and should; always go in the header, where they are visible to anything that includes; the header. Attributes in the .cpp file are not visible outside of the; immediate translation unit, which leads to false negatives and false positives. (Q) ""*Mutex is not locked on every path through here?*"" What does that mean?. (A) See :ref:`conditional_locks`, below. .. _limitations:. Known Limitations; =================. Lexical scope; -------------. Thread safety attributes contain ordinary C++ expressions, and thus follow; ordinary C++ scoping rules. In particular, this means that mutexes and other; capabilities must be declared before they can be used in an attribute.; Use-before-declaration is okay within a single class, because attributes are; parsed at the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:19240,Safety,safe,safety,19240,"Unlock();; }. void baz() {; bif(); // WARNING! Missing REQUIRES(!mu).; }. void bif() REQUIRES(!mu);; };. Negative requirements are an experimental feature which is off by default,; because it will produce many warnings in existing code. It can be enabled; by passing ``-Wthread-safety-negative``. .. _faq:. Frequently Asked Questions; ==========================. (Q) Should I put attributes in the header file, or in the .cc/.cpp/.cxx file?. (A) Attributes are part of the formal interface of a function, and should; always go in the header, where they are visible to anything that includes; the header. Attributes in the .cpp file are not visible outside of the; immediate translation unit, which leads to false negatives and false positives. (Q) ""*Mutex is not locked on every path through here?*"" What does that mean?. (A) See :ref:`conditional_locks`, below. .. _limitations:. Known Limitations; =================. Lexical scope; -------------. Thread safety attributes contain ordinary C++ expressions, and thus follow; ordinary C++ scoping rules. In particular, this means that mutexes and other; capabilities must be declared before they can be used in an attribute.; Use-before-declaration is okay within a single class, because attributes are; parsed at the same time as method bodies. (C++ delays parsing of method bodies; until the end of the class.) However, use-before-declaration is not allowed; between classes, as illustrated below. .. code-block:: c++. class Foo;. class Bar {; void bar(Foo* f) REQUIRES(f->mu); // Error: mu undeclared.; };. class Foo {; Mutex mu;; };. Private Mutexes; ---------------. Good software engineering practice dictates that mutexes should be private; members, because the locking mechanism used by a thread-safe class is part of; its internal implementation. However, private mutexes can sometimes leak into; the public interface of a class.; Thread safety attributes follow normal C++ access restrictions, so if ``mu``; is a private member of ``c``, the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:20037,Safety,safe,safe,20037," negatives and false positives. (Q) ""*Mutex is not locked on every path through here?*"" What does that mean?. (A) See :ref:`conditional_locks`, below. .. _limitations:. Known Limitations; =================. Lexical scope; -------------. Thread safety attributes contain ordinary C++ expressions, and thus follow; ordinary C++ scoping rules. In particular, this means that mutexes and other; capabilities must be declared before they can be used in an attribute.; Use-before-declaration is okay within a single class, because attributes are; parsed at the same time as method bodies. (C++ delays parsing of method bodies; until the end of the class.) However, use-before-declaration is not allowed; between classes, as illustrated below. .. code-block:: c++. class Foo;. class Bar {; void bar(Foo* f) REQUIRES(f->mu); // Error: mu undeclared.; };. class Foo {; Mutex mu;; };. Private Mutexes; ---------------. Good software engineering practice dictates that mutexes should be private; members, because the locking mechanism used by a thread-safe class is part of; its internal implementation. However, private mutexes can sometimes leak into; the public interface of a class.; Thread safety attributes follow normal C++ access restrictions, so if ``mu``; is a private member of ``c``, then it is an error to write ``c.mu`` in an; attribute. One workaround is to (ab)use the ``RETURN_CAPABILITY`` attribute to provide a; public *name* for a private mutex, without actually exposing the underlying; mutex. For example:. .. code-block:: c++. class MyClass {; private:; Mutex mu;. public:; // For thread safety analysis only. Does not need to be defined.; Mutex* getMu() RETURN_CAPABILITY(mu);. void doSomething() REQUIRES(mu);; };. void doSomethingTwice(MyClass& c) REQUIRES(c.getMu()) {; // The analysis thinks that c.getMu() == c.mu; c.doSomething();; c.doSomething();; }. In the above example, ``doSomethingTwice()`` is an external routine that; requires ``c.mu`` to be locked, which cannot be declar",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:20180,Safety,safe,safety,20180,"fety attributes contain ordinary C++ expressions, and thus follow; ordinary C++ scoping rules. In particular, this means that mutexes and other; capabilities must be declared before they can be used in an attribute.; Use-before-declaration is okay within a single class, because attributes are; parsed at the same time as method bodies. (C++ delays parsing of method bodies; until the end of the class.) However, use-before-declaration is not allowed; between classes, as illustrated below. .. code-block:: c++. class Foo;. class Bar {; void bar(Foo* f) REQUIRES(f->mu); // Error: mu undeclared.; };. class Foo {; Mutex mu;; };. Private Mutexes; ---------------. Good software engineering practice dictates that mutexes should be private; members, because the locking mechanism used by a thread-safe class is part of; its internal implementation. However, private mutexes can sometimes leak into; the public interface of a class.; Thread safety attributes follow normal C++ access restrictions, so if ``mu``; is a private member of ``c``, then it is an error to write ``c.mu`` in an; attribute. One workaround is to (ab)use the ``RETURN_CAPABILITY`` attribute to provide a; public *name* for a private mutex, without actually exposing the underlying; mutex. For example:. .. code-block:: c++. class MyClass {; private:; Mutex mu;. public:; // For thread safety analysis only. Does not need to be defined.; Mutex* getMu() RETURN_CAPABILITY(mu);. void doSomething() REQUIRES(mu);; };. void doSomethingTwice(MyClass& c) REQUIRES(c.getMu()) {; // The analysis thinks that c.getMu() == c.mu; c.doSomething();; c.doSomething();; }. In the above example, ``doSomethingTwice()`` is an external routine that; requires ``c.mu`` to be locked, which cannot be declared directly because ``mu``; is private. This pattern is discouraged because it; violates encapsulation, but it is sometimes necessary, especially when adding; annotations to an existing code base. The workaround is to define ``getMu()``; as a fake",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:20596,Safety,safe,safety,20596,"sing of method bodies; until the end of the class.) However, use-before-declaration is not allowed; between classes, as illustrated below. .. code-block:: c++. class Foo;. class Bar {; void bar(Foo* f) REQUIRES(f->mu); // Error: mu undeclared.; };. class Foo {; Mutex mu;; };. Private Mutexes; ---------------. Good software engineering practice dictates that mutexes should be private; members, because the locking mechanism used by a thread-safe class is part of; its internal implementation. However, private mutexes can sometimes leak into; the public interface of a class.; Thread safety attributes follow normal C++ access restrictions, so if ``mu``; is a private member of ``c``, then it is an error to write ``c.mu`` in an; attribute. One workaround is to (ab)use the ``RETURN_CAPABILITY`` attribute to provide a; public *name* for a private mutex, without actually exposing the underlying; mutex. For example:. .. code-block:: c++. class MyClass {; private:; Mutex mu;. public:; // For thread safety analysis only. Does not need to be defined.; Mutex* getMu() RETURN_CAPABILITY(mu);. void doSomething() REQUIRES(mu);; };. void doSomethingTwice(MyClass& c) REQUIRES(c.getMu()) {; // The analysis thinks that c.getMu() == c.mu; c.doSomething();; c.doSomething();; }. In the above example, ``doSomethingTwice()`` is an external routine that; requires ``c.mu`` to be locked, which cannot be declared directly because ``mu``; is private. This pattern is discouraged because it; violates encapsulation, but it is sometimes necessary, especially when adding; annotations to an existing code base. The workaround is to define ``getMu()``; as a fake getter method, which is provided only for the benefit of thread; safety analysis. .. _conditional_locks:. No conditionally held locks.; ----------------------------. The analysis must be able to determine whether a lock is held, or not held, at; every program point. Thus, sections of code where a lock *might be held* will; generate spurious warnings",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:21309,Safety,safe,safety,21309,"ivate member of ``c``, then it is an error to write ``c.mu`` in an; attribute. One workaround is to (ab)use the ``RETURN_CAPABILITY`` attribute to provide a; public *name* for a private mutex, without actually exposing the underlying; mutex. For example:. .. code-block:: c++. class MyClass {; private:; Mutex mu;. public:; // For thread safety analysis only. Does not need to be defined.; Mutex* getMu() RETURN_CAPABILITY(mu);. void doSomething() REQUIRES(mu);; };. void doSomethingTwice(MyClass& c) REQUIRES(c.getMu()) {; // The analysis thinks that c.getMu() == c.mu; c.doSomething();; c.doSomething();; }. In the above example, ``doSomethingTwice()`` is an external routine that; requires ``c.mu`` to be locked, which cannot be declared directly because ``mu``; is private. This pattern is discouraged because it; violates encapsulation, but it is sometimes necessary, especially when adding; annotations to an existing code base. The workaround is to define ``getMu()``; as a fake getter method, which is provided only for the benefit of thread; safety analysis. .. _conditional_locks:. No conditionally held locks.; ----------------------------. The analysis must be able to determine whether a lock is held, or not held, at; every program point. Thus, sections of code where a lock *might be held* will; generate spurious warnings (false positives). For example:. .. code-block:: c++. void foo() {; bool b = needsToLock();; if (b) mu.Lock();; ... // Warning! Mutex 'mu' is not held on every path through here.; if (b) mu.Unlock();; }. No checking inside constructors and destructors.; ------------------------------------------------. The analysis currently does not do any checking inside constructors or; destructors. In other words, every constructor and destructor is treated as; if it was annotated with ``NO_THREAD_SAFETY_ANALYSIS``.; The reason for this is that during initialization, only one thread typically; has access to the object which is being initialized, and it is thus safe (a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:22252,Safety,safe,safe,22252,"``getMu()``; as a fake getter method, which is provided only for the benefit of thread; safety analysis. .. _conditional_locks:. No conditionally held locks.; ----------------------------. The analysis must be able to determine whether a lock is held, or not held, at; every program point. Thus, sections of code where a lock *might be held* will; generate spurious warnings (false positives). For example:. .. code-block:: c++. void foo() {; bool b = needsToLock();; if (b) mu.Lock();; ... // Warning! Mutex 'mu' is not held on every path through here.; if (b) mu.Unlock();; }. No checking inside constructors and destructors.; ------------------------------------------------. The analysis currently does not do any checking inside constructors or; destructors. In other words, every constructor and destructor is treated as; if it was annotated with ``NO_THREAD_SAFETY_ANALYSIS``.; The reason for this is that during initialization, only one thread typically; has access to the object which is being initialized, and it is thus safe (and; common practice) to initialize guarded members without acquiring any locks.; The same is true of destructors. Ideally, the analysis would allow initialization of guarded members inside the; object being initialized or destroyed, while still enforcing the usual access; restrictions on everything else. However, this is difficult to enforce in; practice, because in complex pointer-based data structures, it is hard to; determine what data is owned by the enclosing object. No inlining.; ------------. Thread safety analysis is strictly intra-procedural, just like ordinary type; checking. It relies only on the declared attributes of a function, and will; not attempt to inline any method calls. As a result, code such as the; following will not work:. .. code-block:: c++. template<class T>; class AutoCleanup {; T* object;; void (T::*mp)();. public:; AutoCleanup(T* obj, void (T::*imp)()) : object(obj), mp(imp) { }; ~AutoCleanup() { (object->*mp)(); }; };",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:22771,Safety,safe,safety,22771,"king inside constructors and destructors.; ------------------------------------------------. The analysis currently does not do any checking inside constructors or; destructors. In other words, every constructor and destructor is treated as; if it was annotated with ``NO_THREAD_SAFETY_ANALYSIS``.; The reason for this is that during initialization, only one thread typically; has access to the object which is being initialized, and it is thus safe (and; common practice) to initialize guarded members without acquiring any locks.; The same is true of destructors. Ideally, the analysis would allow initialization of guarded members inside the; object being initialized or destroyed, while still enforcing the usual access; restrictions on everything else. However, this is difficult to enforce in; practice, because in complex pointer-based data structures, it is hard to; determine what data is owned by the enclosing object. No inlining.; ------------. Thread safety analysis is strictly intra-procedural, just like ordinary type; checking. It relies only on the declared attributes of a function, and will; not attempt to inline any method calls. As a result, code such as the; following will not work:. .. code-block:: c++. template<class T>; class AutoCleanup {; T* object;; void (T::*mp)();. public:; AutoCleanup(T* obj, void (T::*imp)()) : object(obj), mp(imp) { }; ~AutoCleanup() { (object->*mp)(); }; };. Mutex mu;; void foo() {; mu.Lock();; AutoCleanup<Mutex>(&mu, &Mutex::Unlock);; // ...; } // Warning, mu is not unlocked. In this case, the destructor of ``Autocleanup`` calls ``mu.Unlock()``, so; the warning is bogus. However,; thread safety analysis cannot see the unlock, because it does not attempt to; inline the destructor. Moreover, there is no way to annotate the destructor,; because the destructor is calling a function that is not statically known.; This pattern is simply not supported. No alias analysis.; ------------------. The analysis currently does not track pointer ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:23458,Safety,safe,safety,23458,"le still enforcing the usual access; restrictions on everything else. However, this is difficult to enforce in; practice, because in complex pointer-based data structures, it is hard to; determine what data is owned by the enclosing object. No inlining.; ------------. Thread safety analysis is strictly intra-procedural, just like ordinary type; checking. It relies only on the declared attributes of a function, and will; not attempt to inline any method calls. As a result, code such as the; following will not work:. .. code-block:: c++. template<class T>; class AutoCleanup {; T* object;; void (T::*mp)();. public:; AutoCleanup(T* obj, void (T::*imp)()) : object(obj), mp(imp) { }; ~AutoCleanup() { (object->*mp)(); }; };. Mutex mu;; void foo() {; mu.Lock();; AutoCleanup<Mutex>(&mu, &Mutex::Unlock);; // ...; } // Warning, mu is not unlocked. In this case, the destructor of ``Autocleanup`` calls ``mu.Unlock()``, so; the warning is bogus. However,; thread safety analysis cannot see the unlock, because it does not attempt to; inline the destructor. Moreover, there is no way to annotate the destructor,; because the destructor is calling a function that is not statically known.; This pattern is simply not supported. No alias analysis.; ------------------. The analysis currently does not track pointer aliases. Thus, there can be; false positives if two pointers both point to the same mutex. .. code-block:: c++. class MutexUnlocker {; Mutex* mu;. public:; MutexUnlocker(Mutex* m) RELEASE(m) : mu(m) { mu->Unlock(); }; ~MutexUnlocker() ACQUIRE(mu) { mu->Lock(); }; };. Mutex mutex;; void test() REQUIRES(mutex) {; {; MutexUnlocker munl(&mutex); // unlocks mutex; doSomeIO();; } // Warning: locks munl.mu; }. The MutexUnlocker class is intended to be the dual of the MutexLocker class,; defined in :ref:`mutexheader`. However, it doesn't work because the analysis; doesn't know that munl.mu == mutex. The SCOPED_CAPABILITY attribute handles; aliasing for MutexLocker, but does so only for th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:24744,Safety,safe,safety,24744," can be; false positives if two pointers both point to the same mutex. .. code-block:: c++. class MutexUnlocker {; Mutex* mu;. public:; MutexUnlocker(Mutex* m) RELEASE(m) : mu(m) { mu->Unlock(); }; ~MutexUnlocker() ACQUIRE(mu) { mu->Lock(); }; };. Mutex mutex;; void test() REQUIRES(mutex) {; {; MutexUnlocker munl(&mutex); // unlocks mutex; doSomeIO();; } // Warning: locks munl.mu; }. The MutexUnlocker class is intended to be the dual of the MutexLocker class,; defined in :ref:`mutexheader`. However, it doesn't work because the analysis; doesn't know that munl.mu == mutex. The SCOPED_CAPABILITY attribute handles; aliasing for MutexLocker, but does so only for that particular pattern. ACQUIRED_BEFORE(...) and ACQUIRED_AFTER(...) are currently unimplemented.; -------------------------------------------------------------------------. To be fixed in a future update. .. _mutexheader:. mutex.h; =======. Thread safety analysis can be used with any threading library, but it does; require that the threading API be wrapped in classes and methods which have the; appropriate annotations. The following code provides ``mutex.h`` as an example;; these methods should be filled in to call the appropriate underlying; implementation. .. code-block:: c++. #ifndef THREAD_SAFETY_ANALYSIS_MUTEX_H; #define THREAD_SAFETY_ANALYSIS_MUTEX_H. // Enable thread safety attributes only with clang.; // The attributes can be safely erased when compiling with other compilers.; #if defined(__clang__) && (!defined(SWIG)); #define THREAD_ANNOTATION_ATTRIBUTE__(x) __attribute__((x)); #else; #define THREAD_ANNOTATION_ATTRIBUTE__(x) // no-op; #endif. #define CAPABILITY(x) \; THREAD_ANNOTATION_ATTRIBUTE__(capability(x)). #define SCOPED_CAPABILITY \; THREAD_ANNOTATION_ATTRIBUTE__(scoped_lockable). #define GUARDED_BY(x) \; THREAD_ANNOTATION_ATTRIBUTE__(guarded_by(x)). #define PT_GUARDED_BY(x) \; THREAD_ANNOTATION_ATTRIBUTE__(pt_guarded_by(x)). #define ACQUIRED_BEFORE(...) \; THREAD_ANNOTATION_ATTRIBUTE__(acquir",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:25179,Safety,safe,safety,25179,"Warning: locks munl.mu; }. The MutexUnlocker class is intended to be the dual of the MutexLocker class,; defined in :ref:`mutexheader`. However, it doesn't work because the analysis; doesn't know that munl.mu == mutex. The SCOPED_CAPABILITY attribute handles; aliasing for MutexLocker, but does so only for that particular pattern. ACQUIRED_BEFORE(...) and ACQUIRED_AFTER(...) are currently unimplemented.; -------------------------------------------------------------------------. To be fixed in a future update. .. _mutexheader:. mutex.h; =======. Thread safety analysis can be used with any threading library, but it does; require that the threading API be wrapped in classes and methods which have the; appropriate annotations. The following code provides ``mutex.h`` as an example;; these methods should be filled in to call the appropriate underlying; implementation. .. code-block:: c++. #ifndef THREAD_SAFETY_ANALYSIS_MUTEX_H; #define THREAD_SAFETY_ANALYSIS_MUTEX_H. // Enable thread safety attributes only with clang.; // The attributes can be safely erased when compiling with other compilers.; #if defined(__clang__) && (!defined(SWIG)); #define THREAD_ANNOTATION_ATTRIBUTE__(x) __attribute__((x)); #else; #define THREAD_ANNOTATION_ATTRIBUTE__(x) // no-op; #endif. #define CAPABILITY(x) \; THREAD_ANNOTATION_ATTRIBUTE__(capability(x)). #define SCOPED_CAPABILITY \; THREAD_ANNOTATION_ATTRIBUTE__(scoped_lockable). #define GUARDED_BY(x) \; THREAD_ANNOTATION_ATTRIBUTE__(guarded_by(x)). #define PT_GUARDED_BY(x) \; THREAD_ANNOTATION_ATTRIBUTE__(pt_guarded_by(x)). #define ACQUIRED_BEFORE(...) \; THREAD_ANNOTATION_ATTRIBUTE__(acquired_before(__VA_ARGS__)). #define ACQUIRED_AFTER(...) \; THREAD_ANNOTATION_ATTRIBUTE__(acquired_after(__VA_ARGS__)). #define REQUIRES(...) \; THREAD_ANNOTATION_ATTRIBUTE__(requires_capability(__VA_ARGS__)). #define REQUIRES_SHARED(...) \; THREAD_ANNOTATION_ATTRIBUTE__(requires_shared_capability(__VA_ARGS__)). #define ACQUIRE(...) \; THREAD_ANNOTATION_ATTRIBUT",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:25240,Safety,safe,safely,25240,"o be the dual of the MutexLocker class,; defined in :ref:`mutexheader`. However, it doesn't work because the analysis; doesn't know that munl.mu == mutex. The SCOPED_CAPABILITY attribute handles; aliasing for MutexLocker, but does so only for that particular pattern. ACQUIRED_BEFORE(...) and ACQUIRED_AFTER(...) are currently unimplemented.; -------------------------------------------------------------------------. To be fixed in a future update. .. _mutexheader:. mutex.h; =======. Thread safety analysis can be used with any threading library, but it does; require that the threading API be wrapped in classes and methods which have the; appropriate annotations. The following code provides ``mutex.h`` as an example;; these methods should be filled in to call the appropriate underlying; implementation. .. code-block:: c++. #ifndef THREAD_SAFETY_ANALYSIS_MUTEX_H; #define THREAD_SAFETY_ANALYSIS_MUTEX_H. // Enable thread safety attributes only with clang.; // The attributes can be safely erased when compiling with other compilers.; #if defined(__clang__) && (!defined(SWIG)); #define THREAD_ANNOTATION_ATTRIBUTE__(x) __attribute__((x)); #else; #define THREAD_ANNOTATION_ATTRIBUTE__(x) // no-op; #endif. #define CAPABILITY(x) \; THREAD_ANNOTATION_ATTRIBUTE__(capability(x)). #define SCOPED_CAPABILITY \; THREAD_ANNOTATION_ATTRIBUTE__(scoped_lockable). #define GUARDED_BY(x) \; THREAD_ANNOTATION_ATTRIBUTE__(guarded_by(x)). #define PT_GUARDED_BY(x) \; THREAD_ANNOTATION_ATTRIBUTE__(pt_guarded_by(x)). #define ACQUIRED_BEFORE(...) \; THREAD_ANNOTATION_ATTRIBUTE__(acquired_before(__VA_ARGS__)). #define ACQUIRED_AFTER(...) \; THREAD_ANNOTATION_ATTRIBUTE__(acquired_after(__VA_ARGS__)). #define REQUIRES(...) \; THREAD_ANNOTATION_ATTRIBUTE__(requires_capability(__VA_ARGS__)). #define REQUIRES_SHARED(...) \; THREAD_ANNOTATION_ATTRIBUTE__(requires_shared_capability(__VA_ARGS__)). #define ACQUIRE(...) \; THREAD_ANNOTATION_ATTRIBUTE__(acquire_capability(__VA_ARGS__)). #define ACQUIRE_SHARED(...)",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:31431,Safety,safe,safety,31431,"es, if they are still held.; // There is no warning if the scope was already unlocked before.; ~MutexLocker() RELEASE() {; if (locked); mut->GenericUnlock();; }. // Acquire all associated mutexes exclusively.; void Lock() ACQUIRE() {; mut->Lock();; locked = true;; }. // Try to acquire all associated mutexes exclusively.; bool TryLock() TRY_ACQUIRE(true) {; return locked = mut->TryLock();; }. // Acquire all associated mutexes in shared mode.; void ReaderLock() ACQUIRE_SHARED() {; mut->ReaderLock();; locked = true;; }. // Try to acquire all associated mutexes in shared mode.; bool ReaderTryLock() TRY_ACQUIRE_SHARED(true) {; return locked = mut->ReaderTryLock();; }. // Release all associated mutexes. Warn on double unlock.; void Unlock() RELEASE() {; mut->Unlock();; locked = false;; }. // Release all associated mutexes. Warn on double unlock.; void ReaderUnlock() RELEASE() {; mut->ReaderUnlock();; locked = false;; }; };. #ifdef USE_LOCK_STYLE_THREAD_SAFETY_ATTRIBUTES; // The original version of thread safety analysis the following attribute; // definitions. These use a lock-based terminology. They are still in use; // by existing thread safety code, and will continue to be supported. // Deprecated.; #define PT_GUARDED_VAR \; THREAD_ANNOTATION_ATTRIBUTE__(pt_guarded_var). // Deprecated.; #define GUARDED_VAR \; THREAD_ANNOTATION_ATTRIBUTE__(guarded_var). // Replaced by REQUIRES; #define EXCLUSIVE_LOCKS_REQUIRED(...) \; THREAD_ANNOTATION_ATTRIBUTE__(exclusive_locks_required(__VA_ARGS__)). // Replaced by REQUIRES_SHARED; #define SHARED_LOCKS_REQUIRED(...) \; THREAD_ANNOTATION_ATTRIBUTE__(shared_locks_required(__VA_ARGS__)). // Replaced by CAPABILITY; #define LOCKABLE \; THREAD_ANNOTATION_ATTRIBUTE__(lockable). // Replaced by SCOPED_CAPABILITY; #define SCOPED_LOCKABLE \; THREAD_ANNOTATION_ATTRIBUTE__(scoped_lockable). // Replaced by ACQUIRE; #define EXCLUSIVE_LOCK_FUNCTION(...) \; THREAD_ANNOTATION_ATTRIBUTE__(exclusive_lock_function(__VA_ARGS__)). // Replaced by ACQUIRE_SHA",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:31569,Safety,safe,safety,31569,"ck();; }. // Acquire all associated mutexes exclusively.; void Lock() ACQUIRE() {; mut->Lock();; locked = true;; }. // Try to acquire all associated mutexes exclusively.; bool TryLock() TRY_ACQUIRE(true) {; return locked = mut->TryLock();; }. // Acquire all associated mutexes in shared mode.; void ReaderLock() ACQUIRE_SHARED() {; mut->ReaderLock();; locked = true;; }. // Try to acquire all associated mutexes in shared mode.; bool ReaderTryLock() TRY_ACQUIRE_SHARED(true) {; return locked = mut->ReaderTryLock();; }. // Release all associated mutexes. Warn on double unlock.; void Unlock() RELEASE() {; mut->Unlock();; locked = false;; }. // Release all associated mutexes. Warn on double unlock.; void ReaderUnlock() RELEASE() {; mut->ReaderUnlock();; locked = false;; }; };. #ifdef USE_LOCK_STYLE_THREAD_SAFETY_ATTRIBUTES; // The original version of thread safety analysis the following attribute; // definitions. These use a lock-based terminology. They are still in use; // by existing thread safety code, and will continue to be supported. // Deprecated.; #define PT_GUARDED_VAR \; THREAD_ANNOTATION_ATTRIBUTE__(pt_guarded_var). // Deprecated.; #define GUARDED_VAR \; THREAD_ANNOTATION_ATTRIBUTE__(guarded_var). // Replaced by REQUIRES; #define EXCLUSIVE_LOCKS_REQUIRED(...) \; THREAD_ANNOTATION_ATTRIBUTE__(exclusive_locks_required(__VA_ARGS__)). // Replaced by REQUIRES_SHARED; #define SHARED_LOCKS_REQUIRED(...) \; THREAD_ANNOTATION_ATTRIBUTE__(shared_locks_required(__VA_ARGS__)). // Replaced by CAPABILITY; #define LOCKABLE \; THREAD_ANNOTATION_ATTRIBUTE__(lockable). // Replaced by SCOPED_CAPABILITY; #define SCOPED_LOCKABLE \; THREAD_ANNOTATION_ATTRIBUTE__(scoped_lockable). // Replaced by ACQUIRE; #define EXCLUSIVE_LOCK_FUNCTION(...) \; THREAD_ANNOTATION_ATTRIBUTE__(exclusive_lock_function(__VA_ARGS__)). // Replaced by ACQUIRE_SHARED; #define SHARED_LOCK_FUNCTION(...) \; THREAD_ANNOTATION_ATTRIBUTE__(shared_lock_function(__VA_ARGS__)). // Replaced by RELEASE and RELEASE_SHARED; #",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:747,Security,access,access,747,"; ======================; Thread Safety Analysis; ======================. Introduction; ============. Clang Thread Safety Analysis is a C++ language extension which warns about; potential race conditions in code. The analysis is completely static (i.e.; compile-time); there is no run-time overhead. The analysis is still; under active development, but it is mature enough to be deployed in an; industrial setting. It is being developed by Google, in collaboration with; CERT/SEI, and is used extensively in Google's internal code base. Thread safety analysis works very much like a type system for multi-threaded; programs. In addition to declaring the *type* of data (e.g. ``int``, ``float``,; etc.), the programmer can (optionally) declare how access to that data is; controlled in a multi-threaded environment. For example, if ``foo`` is; *guarded by* the mutex ``mu``, then the analysis will issue a warning whenever; a piece of code reads or writes to ``foo`` without first locking ``mu``.; Similarly, if there are particular routines that should only be called by; the GUI thread, then the analysis will warn if other threads call those; routines. Getting Started; ----------------. .. code-block:: c++. #include ""mutex.h"". class BankAccount {; private:; Mutex mu;; int balance GUARDED_BY(mu);. void depositImpl(int amount) {; balance += amount; // WARNING! Cannot write balance without locking mu.; }. void withdrawImpl(int amount) REQUIRES(mu) {; balance -= amount; // OK. Caller must have locked mu.; }. public:; void withdraw(int amount) {; mu.Lock();; withdrawImpl(amount); // OK. We've locked mu.; } // WARNING! Failed to unlock mu. void transferFrom(BankAccount& b, int amount) {; mu.Lock();; b.withdrawImpl(amount); // WARNING! Calling withdrawImpl() requires locking b.mu.; depositImpl(amount); // OK. depositImpl() has no requirements.; mu.Unlock();; }; };. This example demonstrates the basic concepts behind the analysis. The; ``GUARDED_BY`` attribute declares that a thread must lo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:3669,Security,access,access,3669,"s not lock ``b.mu``. The analysis understands; that these are two separate mutexes, in two different objects. Finally, there is a warning in the ``withdraw()`` method, because it fails to; unlock ``mu``. Every lock must have a corresponding unlock, and the analysis; will detect both double locks, and double unlocks. A function is allowed to; acquire a lock without releasing it, (or vice versa), but it must be annotated; as such (using ``ACQUIRE``/``RELEASE``). Running The Analysis; --------------------. To run the analysis, simply compile with the ``-Wthread-safety`` flag, e.g. .. code-block:: bash. clang -c -Wthread-safety example.cpp. Note that this example assumes the presence of a suitably annotated; :ref:`mutexheader` that declares which methods perform locking,; unlocking, and so on. Basic Concepts: Capabilities; ============================. Thread safety analysis provides a way of protecting *resources* with; *capabilities*. A resource is either a data member, or a function/method; that provides access to some underlying resource. The analysis ensures that; the calling thread cannot access the *resource* (i.e. call the function, or; read/write the data) unless it has the *capability* to do so. Capabilities are associated with named C++ objects which declare specific; methods to acquire and release the capability. The name of the object serves; to identify the capability. The most common example is a mutex. For example,; if ``mu`` is a mutex, then calling ``mu.Lock()`` causes the calling thread; to acquire the capability to access data that is protected by ``mu``. Similarly,; calling ``mu.Unlock()`` releases that capability. A thread may hold a capability either *exclusively* or *shared*. An exclusive; capability can be held by only one thread at a time, while a shared capability; can be held by many threads at the same time. This mechanism enforces a; multiple-reader, single-writer pattern. Write operations to protected data; require exclusive access, while ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:3758,Security,access,access,3758,"fferent objects. Finally, there is a warning in the ``withdraw()`` method, because it fails to; unlock ``mu``. Every lock must have a corresponding unlock, and the analysis; will detect both double locks, and double unlocks. A function is allowed to; acquire a lock without releasing it, (or vice versa), but it must be annotated; as such (using ``ACQUIRE``/``RELEASE``). Running The Analysis; --------------------. To run the analysis, simply compile with the ``-Wthread-safety`` flag, e.g. .. code-block:: bash. clang -c -Wthread-safety example.cpp. Note that this example assumes the presence of a suitably annotated; :ref:`mutexheader` that declares which methods perform locking,; unlocking, and so on. Basic Concepts: Capabilities; ============================. Thread safety analysis provides a way of protecting *resources* with; *capabilities*. A resource is either a data member, or a function/method; that provides access to some underlying resource. The analysis ensures that; the calling thread cannot access the *resource* (i.e. call the function, or; read/write the data) unless it has the *capability* to do so. Capabilities are associated with named C++ objects which declare specific; methods to acquire and release the capability. The name of the object serves; to identify the capability. The most common example is a mutex. For example,; if ``mu`` is a mutex, then calling ``mu.Lock()`` causes the calling thread; to acquire the capability to access data that is protected by ``mu``. Similarly,; calling ``mu.Unlock()`` releases that capability. A thread may hold a capability either *exclusively* or *shared*. An exclusive; capability can be held by only one thread at a time, while a shared capability; can be held by many threads at the same time. This mechanism enforces a; multiple-reader, single-writer pattern. Write operations to protected data; require exclusive access, while read operations require only shared access. At any given moment during program execution, a th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:4207,Security,access,access,4207," with the ``-Wthread-safety`` flag, e.g. .. code-block:: bash. clang -c -Wthread-safety example.cpp. Note that this example assumes the presence of a suitably annotated; :ref:`mutexheader` that declares which methods perform locking,; unlocking, and so on. Basic Concepts: Capabilities; ============================. Thread safety analysis provides a way of protecting *resources* with; *capabilities*. A resource is either a data member, or a function/method; that provides access to some underlying resource. The analysis ensures that; the calling thread cannot access the *resource* (i.e. call the function, or; read/write the data) unless it has the *capability* to do so. Capabilities are associated with named C++ objects which declare specific; methods to acquire and release the capability. The name of the object serves; to identify the capability. The most common example is a mutex. For example,; if ``mu`` is a mutex, then calling ``mu.Lock()`` causes the calling thread; to acquire the capability to access data that is protected by ``mu``. Similarly,; calling ``mu.Unlock()`` releases that capability. A thread may hold a capability either *exclusively* or *shared*. An exclusive; capability can be held by only one thread at a time, while a shared capability; can be held by many threads at the same time. This mechanism enforces a; multiple-reader, single-writer pattern. Write operations to protected data; require exclusive access, while read operations require only shared access. At any given moment during program execution, a thread holds a specific set of; capabilities (e.g. the set of mutexes that it has locked.) These act like keys; or tokens that allow the thread to access a given resource. Just like physical; security keys, a thread cannot make copy of a capability, nor can it destroy; one. A thread can only release a capability to another thread, or acquire one; from another thread. The annotations are deliberately agnostic about the; exact mechanism used to acquir",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:4636,Security,access,access,4636," function/method; that provides access to some underlying resource. The analysis ensures that; the calling thread cannot access the *resource* (i.e. call the function, or; read/write the data) unless it has the *capability* to do so. Capabilities are associated with named C++ objects which declare specific; methods to acquire and release the capability. The name of the object serves; to identify the capability. The most common example is a mutex. For example,; if ``mu`` is a mutex, then calling ``mu.Lock()`` causes the calling thread; to acquire the capability to access data that is protected by ``mu``. Similarly,; calling ``mu.Unlock()`` releases that capability. A thread may hold a capability either *exclusively* or *shared*. An exclusive; capability can be held by only one thread at a time, while a shared capability; can be held by many threads at the same time. This mechanism enforces a; multiple-reader, single-writer pattern. Write operations to protected data; require exclusive access, while read operations require only shared access. At any given moment during program execution, a thread holds a specific set of; capabilities (e.g. the set of mutexes that it has locked.) These act like keys; or tokens that allow the thread to access a given resource. Just like physical; security keys, a thread cannot make copy of a capability, nor can it destroy; one. A thread can only release a capability to another thread, or acquire one; from another thread. The annotations are deliberately agnostic about the; exact mechanism used to acquire and release capabilities; it assumes that the; underlying implementation (e.g. the Mutex implementation) does the handoff in; an appropriate manner. The set of capabilities that are actually held by a given thread at a given; point in program execution is a run-time concept. The static analysis works; by calculating an approximation of that set, called the *capability; environment*. The capability environment is calculated for every pro",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:4686,Security,access,access,4686," function/method; that provides access to some underlying resource. The analysis ensures that; the calling thread cannot access the *resource* (i.e. call the function, or; read/write the data) unless it has the *capability* to do so. Capabilities are associated with named C++ objects which declare specific; methods to acquire and release the capability. The name of the object serves; to identify the capability. The most common example is a mutex. For example,; if ``mu`` is a mutex, then calling ``mu.Lock()`` causes the calling thread; to acquire the capability to access data that is protected by ``mu``. Similarly,; calling ``mu.Unlock()`` releases that capability. A thread may hold a capability either *exclusively* or *shared*. An exclusive; capability can be held by only one thread at a time, while a shared capability; can be held by many threads at the same time. This mechanism enforces a; multiple-reader, single-writer pattern. Write operations to protected data; require exclusive access, while read operations require only shared access. At any given moment during program execution, a thread holds a specific set of; capabilities (e.g. the set of mutexes that it has locked.) These act like keys; or tokens that allow the thread to access a given resource. Just like physical; security keys, a thread cannot make copy of a capability, nor can it destroy; one. A thread can only release a capability to another thread, or acquire one; from another thread. The annotations are deliberately agnostic about the; exact mechanism used to acquire and release capabilities; it assumes that the; underlying implementation (e.g. the Mutex implementation) does the handoff in; an appropriate manner. The set of capabilities that are actually held by a given thread at a given; point in program execution is a run-time concept. The static analysis works; by calculating an approximation of that set, called the *capability; environment*. The capability environment is calculated for every pro",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:4889,Security,access,access,4889,"apabilities are associated with named C++ objects which declare specific; methods to acquire and release the capability. The name of the object serves; to identify the capability. The most common example is a mutex. For example,; if ``mu`` is a mutex, then calling ``mu.Lock()`` causes the calling thread; to acquire the capability to access data that is protected by ``mu``. Similarly,; calling ``mu.Unlock()`` releases that capability. A thread may hold a capability either *exclusively* or *shared*. An exclusive; capability can be held by only one thread at a time, while a shared capability; can be held by many threads at the same time. This mechanism enforces a; multiple-reader, single-writer pattern. Write operations to protected data; require exclusive access, while read operations require only shared access. At any given moment during program execution, a thread holds a specific set of; capabilities (e.g. the set of mutexes that it has locked.) These act like keys; or tokens that allow the thread to access a given resource. Just like physical; security keys, a thread cannot make copy of a capability, nor can it destroy; one. A thread can only release a capability to another thread, or acquire one; from another thread. The annotations are deliberately agnostic about the; exact mechanism used to acquire and release capabilities; it assumes that the; underlying implementation (e.g. the Mutex implementation) does the handoff in; an appropriate manner. The set of capabilities that are actually held by a given thread at a given; point in program execution is a run-time concept. The static analysis works; by calculating an approximation of that set, called the *capability; environment*. The capability environment is calculated for every program point,; and describes the set of capabilities that are statically known to be held, or; not held, at that particular point. This environment is a conservative; approximation of the full set of capabilities that will actually held ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:4934,Security,secur,security,4934," and release the capability. The name of the object serves; to identify the capability. The most common example is a mutex. For example,; if ``mu`` is a mutex, then calling ``mu.Lock()`` causes the calling thread; to acquire the capability to access data that is protected by ``mu``. Similarly,; calling ``mu.Unlock()`` releases that capability. A thread may hold a capability either *exclusively* or *shared*. An exclusive; capability can be held by only one thread at a time, while a shared capability; can be held by many threads at the same time. This mechanism enforces a; multiple-reader, single-writer pattern. Write operations to protected data; require exclusive access, while read operations require only shared access. At any given moment during program execution, a thread holds a specific set of; capabilities (e.g. the set of mutexes that it has locked.) These act like keys; or tokens that allow the thread to access a given resource. Just like physical; security keys, a thread cannot make copy of a capability, nor can it destroy; one. A thread can only release a capability to another thread, or acquire one; from another thread. The annotations are deliberately agnostic about the; exact mechanism used to acquire and release capabilities; it assumes that the; underlying implementation (e.g. the Mutex implementation) does the handoff in; an appropriate manner. The set of capabilities that are actually held by a given thread at a given; point in program execution is a run-time concept. The static analysis works; by calculating an approximation of that set, called the *capability; environment*. The capability environment is calculated for every program point,; and describes the set of capabilities that are statically known to be held, or; not held, at that particular point. This environment is a conservative; approximation of the full set of capabilities that will actually held by a; thread at run-time. Reference Guide; ===============. The thread safety analysis uses a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:6981,Security,access,access,6981,"threading constraints.; Attributes must be attached to named declarations, such as classes, methods,; and data members. Users are *strongly advised* to define macros for the various; attributes; example definitions can be found in :ref:`mutexheader`, below.; The following documentation assumes the use of macros. The attributes only control assumptions made by thread safety analysis and the; warnings it issues. They don't affect generated code or behavior at run-time. For historical reasons, prior versions of thread safety used macro names that; were very lock-centric. These macros have since been renamed to fit a more; general capability model. The prior names are still in use, and will be; mentioned under the tag *previously* where appropriate. GUARDED_BY(c) and PT_GUARDED_BY(c); ----------------------------------. ``GUARDED_BY`` is an attribute on data members, which declares that the data; member is protected by the given capability. Read operations on the data; require shared access, while write operations require exclusive access. ``PT_GUARDED_BY`` is similar, but is intended for use on pointers and smart; pointers. There is no constraint on the data member itself, but the *data that; it points to* is protected by the given capability. .. code-block:: c++. Mutex mu;; int *p1 GUARDED_BY(mu);; int *p2 PT_GUARDED_BY(mu);; unique_ptr<int> p3 PT_GUARDED_BY(mu);. void test() {; p1 = 0; // Warning!. *p2 = 42; // Warning!; p2 = new int; // OK. *p3 = 42; // Warning!; p3.reset(new int); // OK.; }. REQUIRES(...), REQUIRES_SHARED(...); -----------------------------------. *Previously*: ``EXCLUSIVE_LOCKS_REQUIRED``, ``SHARED_LOCKS_REQUIRED``. ``REQUIRES`` is an attribute on functions or methods, which; declares that the calling thread must have exclusive access to the given; capabilities. More than one capability may be specified. The capabilities; must be held on entry to the function, *and must still be held on exit*. ``REQUIRES_SHARED`` is similar, but requires only share",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:7030,Security,access,access,7030,"threading constraints.; Attributes must be attached to named declarations, such as classes, methods,; and data members. Users are *strongly advised* to define macros for the various; attributes; example definitions can be found in :ref:`mutexheader`, below.; The following documentation assumes the use of macros. The attributes only control assumptions made by thread safety analysis and the; warnings it issues. They don't affect generated code or behavior at run-time. For historical reasons, prior versions of thread safety used macro names that; were very lock-centric. These macros have since been renamed to fit a more; general capability model. The prior names are still in use, and will be; mentioned under the tag *previously* where appropriate. GUARDED_BY(c) and PT_GUARDED_BY(c); ----------------------------------. ``GUARDED_BY`` is an attribute on data members, which declares that the data; member is protected by the given capability. Read operations on the data; require shared access, while write operations require exclusive access. ``PT_GUARDED_BY`` is similar, but is intended for use on pointers and smart; pointers. There is no constraint on the data member itself, but the *data that; it points to* is protected by the given capability. .. code-block:: c++. Mutex mu;; int *p1 GUARDED_BY(mu);; int *p2 PT_GUARDED_BY(mu);; unique_ptr<int> p3 PT_GUARDED_BY(mu);. void test() {; p1 = 0; // Warning!. *p2 = 42; // Warning!; p2 = new int; // OK. *p3 = 42; // Warning!; p3.reset(new int); // OK.; }. REQUIRES(...), REQUIRES_SHARED(...); -----------------------------------. *Previously*: ``EXCLUSIVE_LOCKS_REQUIRED``, ``SHARED_LOCKS_REQUIRED``. ``REQUIRES`` is an attribute on functions or methods, which; declares that the calling thread must have exclusive access to the given; capabilities. More than one capability may be specified. The capabilities; must be held on entry to the function, *and must still be held on exit*. ``REQUIRES_SHARED`` is similar, but requires only share",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:7763,Security,access,access,7763," where appropriate. GUARDED_BY(c) and PT_GUARDED_BY(c); ----------------------------------. ``GUARDED_BY`` is an attribute on data members, which declares that the data; member is protected by the given capability. Read operations on the data; require shared access, while write operations require exclusive access. ``PT_GUARDED_BY`` is similar, but is intended for use on pointers and smart; pointers. There is no constraint on the data member itself, but the *data that; it points to* is protected by the given capability. .. code-block:: c++. Mutex mu;; int *p1 GUARDED_BY(mu);; int *p2 PT_GUARDED_BY(mu);; unique_ptr<int> p3 PT_GUARDED_BY(mu);. void test() {; p1 = 0; // Warning!. *p2 = 42; // Warning!; p2 = new int; // OK. *p3 = 42; // Warning!; p3.reset(new int); // OK.; }. REQUIRES(...), REQUIRES_SHARED(...); -----------------------------------. *Previously*: ``EXCLUSIVE_LOCKS_REQUIRED``, ``SHARED_LOCKS_REQUIRED``. ``REQUIRES`` is an attribute on functions or methods, which; declares that the calling thread must have exclusive access to the given; capabilities. More than one capability may be specified. The capabilities; must be held on entry to the function, *and must still be held on exit*. ``REQUIRES_SHARED`` is similar, but requires only shared access. .. code-block:: c++. Mutex mu1, mu2;; int a GUARDED_BY(mu1);; int b GUARDED_BY(mu2);. void foo() REQUIRES(mu1, mu2) {; a = 0;; b = 0;; }. void test() {; mu1.Lock();; foo(); // Warning! Requires mu2.; mu1.Unlock();; }. ACQUIRE(...), ACQUIRE_SHARED(...), RELEASE(...), RELEASE_SHARED(...), RELEASE_GENERIC(...); ------------------------------------------------------------------------------------------. *Previously*: ``EXCLUSIVE_LOCK_FUNCTION``, ``SHARED_LOCK_FUNCTION``,; ``UNLOCK_FUNCTION``. ``ACQUIRE`` and ``ACQUIRE_SHARED`` are attributes on functions or methods; declaring that the function acquires a capability, but does not release it.; The given capability must not be held on entry, and will be held on exit; (exclus",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:7989,Security,access,access,7989,"a; require shared access, while write operations require exclusive access. ``PT_GUARDED_BY`` is similar, but is intended for use on pointers and smart; pointers. There is no constraint on the data member itself, but the *data that; it points to* is protected by the given capability. .. code-block:: c++. Mutex mu;; int *p1 GUARDED_BY(mu);; int *p2 PT_GUARDED_BY(mu);; unique_ptr<int> p3 PT_GUARDED_BY(mu);. void test() {; p1 = 0; // Warning!. *p2 = 42; // Warning!; p2 = new int; // OK. *p3 = 42; // Warning!; p3.reset(new int); // OK.; }. REQUIRES(...), REQUIRES_SHARED(...); -----------------------------------. *Previously*: ``EXCLUSIVE_LOCKS_REQUIRED``, ``SHARED_LOCKS_REQUIRED``. ``REQUIRES`` is an attribute on functions or methods, which; declares that the calling thread must have exclusive access to the given; capabilities. More than one capability may be specified. The capabilities; must be held on entry to the function, *and must still be held on exit*. ``REQUIRES_SHARED`` is similar, but requires only shared access. .. code-block:: c++. Mutex mu1, mu2;; int a GUARDED_BY(mu1);; int b GUARDED_BY(mu2);. void foo() REQUIRES(mu1, mu2) {; a = 0;; b = 0;; }. void test() {; mu1.Lock();; foo(); // Warning! Requires mu2.; mu1.Unlock();; }. ACQUIRE(...), ACQUIRE_SHARED(...), RELEASE(...), RELEASE_SHARED(...), RELEASE_GENERIC(...); ------------------------------------------------------------------------------------------. *Previously*: ``EXCLUSIVE_LOCK_FUNCTION``, ``SHARED_LOCK_FUNCTION``,; ``UNLOCK_FUNCTION``. ``ACQUIRE`` and ``ACQUIRE_SHARED`` are attributes on functions or methods; declaring that the function acquires a capability, but does not release it.; The given capability must not be held on entry, and will be held on exit; (exclusively for ``ACQUIRE``, shared for ``ACQUIRE_SHARED``). ``RELEASE``, ``RELEASE_SHARED``, and ``RELEASE_GENERIC`` declare that the; function releases the given capability. The capability must be held on entry; (exclusively for ``RELEASE``, sha",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:20216,Security,access,access,20216,"fety attributes contain ordinary C++ expressions, and thus follow; ordinary C++ scoping rules. In particular, this means that mutexes and other; capabilities must be declared before they can be used in an attribute.; Use-before-declaration is okay within a single class, because attributes are; parsed at the same time as method bodies. (C++ delays parsing of method bodies; until the end of the class.) However, use-before-declaration is not allowed; between classes, as illustrated below. .. code-block:: c++. class Foo;. class Bar {; void bar(Foo* f) REQUIRES(f->mu); // Error: mu undeclared.; };. class Foo {; Mutex mu;; };. Private Mutexes; ---------------. Good software engineering practice dictates that mutexes should be private; members, because the locking mechanism used by a thread-safe class is part of; its internal implementation. However, private mutexes can sometimes leak into; the public interface of a class.; Thread safety attributes follow normal C++ access restrictions, so if ``mu``; is a private member of ``c``, then it is an error to write ``c.mu`` in an; attribute. One workaround is to (ab)use the ``RETURN_CAPABILITY`` attribute to provide a; public *name* for a private mutex, without actually exposing the underlying; mutex. For example:. .. code-block:: c++. class MyClass {; private:; Mutex mu;. public:; // For thread safety analysis only. Does not need to be defined.; Mutex* getMu() RETURN_CAPABILITY(mu);. void doSomething() REQUIRES(mu);; };. void doSomethingTwice(MyClass& c) REQUIRES(c.getMu()) {; // The analysis thinks that c.getMu() == c.mu; c.doSomething();; c.doSomething();; }. In the above example, ``doSomethingTwice()`` is an external routine that; requires ``c.mu`` to be locked, which cannot be declared directly because ``mu``; is private. This pattern is discouraged because it; violates encapsulation, but it is sometimes necessary, especially when adding; annotations to an existing code base. The workaround is to define ``getMu()``; as a fake",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:22188,Security,access,access,22188,"``getMu()``; as a fake getter method, which is provided only for the benefit of thread; safety analysis. .. _conditional_locks:. No conditionally held locks.; ----------------------------. The analysis must be able to determine whether a lock is held, or not held, at; every program point. Thus, sections of code where a lock *might be held* will; generate spurious warnings (false positives). For example:. .. code-block:: c++. void foo() {; bool b = needsToLock();; if (b) mu.Lock();; ... // Warning! Mutex 'mu' is not held on every path through here.; if (b) mu.Unlock();; }. No checking inside constructors and destructors.; ------------------------------------------------. The analysis currently does not do any checking inside constructors or; destructors. In other words, every constructor and destructor is treated as; if it was annotated with ``NO_THREAD_SAFETY_ANALYSIS``.; The reason for this is that during initialization, only one thread typically; has access to the object which is being initialized, and it is thus safe (and; common practice) to initialize guarded members without acquiring any locks.; The same is true of destructors. Ideally, the analysis would allow initialization of guarded members inside the; object being initialized or destroyed, while still enforcing the usual access; restrictions on everything else. However, this is difficult to enforce in; practice, because in complex pointer-based data structures, it is hard to; determine what data is owned by the enclosing object. No inlining.; ------------. Thread safety analysis is strictly intra-procedural, just like ordinary type; checking. It relies only on the declared attributes of a function, and will; not attempt to inline any method calls. As a result, code such as the; following will not work:. .. code-block:: c++. template<class T>; class AutoCleanup {; T* object;; void (T::*mp)();. public:; AutoCleanup(T* obj, void (T::*imp)()) : object(obj), mp(imp) { }; ~AutoCleanup() { (object->*mp)(); }; };",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:22524,Security,access,access,22524,"eld, or not held, at; every program point. Thus, sections of code where a lock *might be held* will; generate spurious warnings (false positives). For example:. .. code-block:: c++. void foo() {; bool b = needsToLock();; if (b) mu.Lock();; ... // Warning! Mutex 'mu' is not held on every path through here.; if (b) mu.Unlock();; }. No checking inside constructors and destructors.; ------------------------------------------------. The analysis currently does not do any checking inside constructors or; destructors. In other words, every constructor and destructor is treated as; if it was annotated with ``NO_THREAD_SAFETY_ANALYSIS``.; The reason for this is that during initialization, only one thread typically; has access to the object which is being initialized, and it is thus safe (and; common practice) to initialize guarded members without acquiring any locks.; The same is true of destructors. Ideally, the analysis would allow initialization of guarded members inside the; object being initialized or destroyed, while still enforcing the usual access; restrictions on everything else. However, this is difficult to enforce in; practice, because in complex pointer-based data structures, it is hard to; determine what data is owned by the enclosing object. No inlining.; ------------. Thread safety analysis is strictly intra-procedural, just like ordinary type; checking. It relies only on the declared attributes of a function, and will; not attempt to inline any method calls. As a result, code such as the; following will not work:. .. code-block:: c++. template<class T>; class AutoCleanup {; T* object;; void (T::*mp)();. public:; AutoCleanup(T* obj, void (T::*imp)()) : object(obj), mp(imp) { }; ~AutoCleanup() { (object->*mp)(); }; };. Mutex mu;; void foo() {; mu.Lock();; AutoCleanup<Mutex>(&mu, &Mutex::Unlock);; // ...; } // Warning, mu is not unlocked. In this case, the destructor of ``Autocleanup`` calls ``mu.Unlock()``, so; the warning is bogus. However,; thread safety ana",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:27522,Security,access,access,27522,")). #define RELEASE_GENERIC(...) \; THREAD_ANNOTATION_ATTRIBUTE__(release_generic_capability(__VA_ARGS__)). #define TRY_ACQUIRE(...) \; THREAD_ANNOTATION_ATTRIBUTE__(try_acquire_capability(__VA_ARGS__)). #define TRY_ACQUIRE_SHARED(...) \; THREAD_ANNOTATION_ATTRIBUTE__(try_acquire_shared_capability(__VA_ARGS__)). #define EXCLUDES(...) \; THREAD_ANNOTATION_ATTRIBUTE__(locks_excluded(__VA_ARGS__)). #define ASSERT_CAPABILITY(x) \; THREAD_ANNOTATION_ATTRIBUTE__(assert_capability(x)). #define ASSERT_SHARED_CAPABILITY(x) \; THREAD_ANNOTATION_ATTRIBUTE__(assert_shared_capability(x)). #define RETURN_CAPABILITY(x) \; THREAD_ANNOTATION_ATTRIBUTE__(lock_returned(x)). #define NO_THREAD_SAFETY_ANALYSIS \; THREAD_ANNOTATION_ATTRIBUTE__(no_thread_safety_analysis). // Defines an annotated interface for mutexes.; // These methods can be implemented to use any internal mutex implementation.; class CAPABILITY(""mutex"") Mutex {; public:; // Acquire/lock this mutex exclusively. Only one thread can have exclusive; // access at any one time. Write operations to guarded data require an; // exclusive lock.; void Lock() ACQUIRE();. // Acquire/lock this mutex for read operations, which require only a shared; // lock. This assumes a multiple-reader, single writer semantics. Multiple; // threads may acquire the mutex simultaneously as readers, but a writer; // must wait for all of them to release the mutex before it can acquire it; // exclusively.; void ReaderLock() ACQUIRE_SHARED();. // Release/unlock an exclusive mutex.; void Unlock() RELEASE();. // Release/unlock a shared mutex.; void ReaderUnlock() RELEASE_SHARED();. // Generic unlock, can unlock exclusive and shared mutexes.; void GenericUnlock() RELEASE_GENERIC();. // Try to acquire the mutex. Returns true on success, and false on failure.; bool TryLock() TRY_ACQUIRE(true);. // Try to acquire the mutex for read operations.; bool ReaderTryLock() TRY_ACQUIRE_SHARED(true);. // Assert that this mutex is currently held by the calling thread.; voi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:7376,Testability,test,test,7376," it issues. They don't affect generated code or behavior at run-time. For historical reasons, prior versions of thread safety used macro names that; were very lock-centric. These macros have since been renamed to fit a more; general capability model. The prior names are still in use, and will be; mentioned under the tag *previously* where appropriate. GUARDED_BY(c) and PT_GUARDED_BY(c); ----------------------------------. ``GUARDED_BY`` is an attribute on data members, which declares that the data; member is protected by the given capability. Read operations on the data; require shared access, while write operations require exclusive access. ``PT_GUARDED_BY`` is similar, but is intended for use on pointers and smart; pointers. There is no constraint on the data member itself, but the *data that; it points to* is protected by the given capability. .. code-block:: c++. Mutex mu;; int *p1 GUARDED_BY(mu);; int *p2 PT_GUARDED_BY(mu);; unique_ptr<int> p3 PT_GUARDED_BY(mu);. void test() {; p1 = 0; // Warning!. *p2 = 42; // Warning!; p2 = new int; // OK. *p3 = 42; // Warning!; p3.reset(new int); // OK.; }. REQUIRES(...), REQUIRES_SHARED(...); -----------------------------------. *Previously*: ``EXCLUSIVE_LOCKS_REQUIRED``, ``SHARED_LOCKS_REQUIRED``. ``REQUIRES`` is an attribute on functions or methods, which; declares that the calling thread must have exclusive access to the given; capabilities. More than one capability may be specified. The capabilities; must be held on entry to the function, *and must still be held on exit*. ``REQUIRES_SHARED`` is similar, but requires only shared access. .. code-block:: c++. Mutex mu1, mu2;; int a GUARDED_BY(mu1);; int b GUARDED_BY(mu2);. void foo() REQUIRES(mu1, mu2) {; a = 0;; b = 0;; }. void test() {; mu1.Lock();; foo(); // Warning! Requires mu2.; mu1.Unlock();; }. ACQUIRE(...), ACQUIRE_SHARED(...), RELEASE(...), RELEASE_SHARED(...), RELEASE_GENERIC(...); ---------------------------------------------------------------------------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:8140,Testability,test,test,8140,"int on the data member itself, but the *data that; it points to* is protected by the given capability. .. code-block:: c++. Mutex mu;; int *p1 GUARDED_BY(mu);; int *p2 PT_GUARDED_BY(mu);; unique_ptr<int> p3 PT_GUARDED_BY(mu);. void test() {; p1 = 0; // Warning!. *p2 = 42; // Warning!; p2 = new int; // OK. *p3 = 42; // Warning!; p3.reset(new int); // OK.; }. REQUIRES(...), REQUIRES_SHARED(...); -----------------------------------. *Previously*: ``EXCLUSIVE_LOCKS_REQUIRED``, ``SHARED_LOCKS_REQUIRED``. ``REQUIRES`` is an attribute on functions or methods, which; declares that the calling thread must have exclusive access to the given; capabilities. More than one capability may be specified. The capabilities; must be held on entry to the function, *and must still be held on exit*. ``REQUIRES_SHARED`` is similar, but requires only shared access. .. code-block:: c++. Mutex mu1, mu2;; int a GUARDED_BY(mu1);; int b GUARDED_BY(mu2);. void foo() REQUIRES(mu1, mu2) {; a = 0;; b = 0;; }. void test() {; mu1.Lock();; foo(); // Warning! Requires mu2.; mu1.Unlock();; }. ACQUIRE(...), ACQUIRE_SHARED(...), RELEASE(...), RELEASE_SHARED(...), RELEASE_GENERIC(...); ------------------------------------------------------------------------------------------. *Previously*: ``EXCLUSIVE_LOCK_FUNCTION``, ``SHARED_LOCK_FUNCTION``,; ``UNLOCK_FUNCTION``. ``ACQUIRE`` and ``ACQUIRE_SHARED`` are attributes on functions or methods; declaring that the function acquires a capability, but does not release it.; The given capability must not be held on entry, and will be held on exit; (exclusively for ``ACQUIRE``, shared for ``ACQUIRE_SHARED``). ``RELEASE``, ``RELEASE_SHARED``, and ``RELEASE_GENERIC`` declare that the; function releases the given capability. The capability must be held on entry; (exclusively for ``RELEASE``, shared for ``RELEASE_SHARED``, exclusively or; shared for ``RELEASE_GENERIC``), and will no longer be held on exit. .. code-block:: c++. Mutex mu;; MyClass myObject GUARDED_BY(mu);. v",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:9308,Testability,test,test,9308,"---------------------------------------------------------------------------. *Previously*: ``EXCLUSIVE_LOCK_FUNCTION``, ``SHARED_LOCK_FUNCTION``,; ``UNLOCK_FUNCTION``. ``ACQUIRE`` and ``ACQUIRE_SHARED`` are attributes on functions or methods; declaring that the function acquires a capability, but does not release it.; The given capability must not be held on entry, and will be held on exit; (exclusively for ``ACQUIRE``, shared for ``ACQUIRE_SHARED``). ``RELEASE``, ``RELEASE_SHARED``, and ``RELEASE_GENERIC`` declare that the; function releases the given capability. The capability must be held on entry; (exclusively for ``RELEASE``, shared for ``RELEASE_SHARED``, exclusively or; shared for ``RELEASE_GENERIC``), and will no longer be held on exit. .. code-block:: c++. Mutex mu;; MyClass myObject GUARDED_BY(mu);. void lockAndInit() ACQUIRE(mu) {; mu.Lock();; myObject.init();; }. void cleanupAndUnlock() RELEASE(mu) {; myObject.cleanup();; } // Warning! Need to unlock mu. void test() {; lockAndInit();; myObject.doSomething();; cleanupAndUnlock();; myObject.doSomething(); // Warning, mu is not locked.; }. If no argument is passed to ``ACQUIRE`` or ``RELEASE``, then the argument is; assumed to be ``this``, and the analysis will not check the body of the; function. This pattern is intended for use by classes which hide locking; details behind an abstract interface. For example:. .. code-block:: c++. template <class T>; class CAPABILITY(""mutex"") Container {; private:; Mutex mu;; T* data;. public:; // Hide mu from public interface.; void Lock() ACQUIRE() { mu.Lock(); }; void Unlock() RELEASE() { mu.Unlock(); }. T& getElem(int i) { return data[i]; }; };. void test() {; Container<int> c;; c.Lock();; int i = c.getElem(0);; c.Unlock();; }. EXCLUDES(...); -------------. *Previously*: ``LOCKS_EXCLUDED``. ``EXCLUDES`` is an attribute on functions or methods, which declares that; the caller must *not* hold the given capabilities. This annotation is; used to prevent deadlock. Many mutex",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:9998,Testability,test,test,9998,"ared for ``RELEASE_GENERIC``), and will no longer be held on exit. .. code-block:: c++. Mutex mu;; MyClass myObject GUARDED_BY(mu);. void lockAndInit() ACQUIRE(mu) {; mu.Lock();; myObject.init();; }. void cleanupAndUnlock() RELEASE(mu) {; myObject.cleanup();; } // Warning! Need to unlock mu. void test() {; lockAndInit();; myObject.doSomething();; cleanupAndUnlock();; myObject.doSomething(); // Warning, mu is not locked.; }. If no argument is passed to ``ACQUIRE`` or ``RELEASE``, then the argument is; assumed to be ``this``, and the analysis will not check the body of the; function. This pattern is intended for use by classes which hide locking; details behind an abstract interface. For example:. .. code-block:: c++. template <class T>; class CAPABILITY(""mutex"") Container {; private:; Mutex mu;; T* data;. public:; // Hide mu from public interface.; void Lock() ACQUIRE() { mu.Lock(); }; void Unlock() RELEASE() { mu.Unlock(); }. T& getElem(int i) { return data[i]; }; };. void test() {; Container<int> c;; c.Lock();; int i = c.getElem(0);; c.Unlock();; }. EXCLUDES(...); -------------. *Previously*: ``LOCKS_EXCLUDED``. ``EXCLUDES`` is an attribute on functions or methods, which declares that; the caller must *not* hold the given capabilities. This annotation is; used to prevent deadlock. Many mutex implementations are not re-entrant, so; deadlock can occur if the function acquires the mutex a second time. .. code-block:: c++. Mutex mu;; int a GUARDED_BY(mu);. void clear() EXCLUDES(mu) {; mu.Lock();; a = 0;; mu.Unlock();; }. void reset() {; mu.Lock();; clear(); // Warning! Caller cannot hold 'mu'.; mu.Unlock();; }. Unlike ``REQUIRES``, ``EXCLUDES`` is optional. The analysis will not issue a; warning if the attribute is missing, which can lead to false negatives in some; cases. This issue is discussed further in :ref:`negative`. NO_THREAD_SAFETY_ANALYSIS; -------------------------. ``NO_THREAD_SAFETY_ANALYSIS`` is an attribute on functions or methods, which; turns off thread",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:15307,Testability,assert,asserts,15307,"cquire the given; capability, and returns a boolean value indicating success or failure.; The first argument must be ``true`` or ``false``, to specify which return value; indicates success, and the remaining arguments are interpreted in the same way; as ``ACQUIRE``. See :ref:`mutexheader`, below, for example uses. Because the analysis doesn't support conditional locking, a capability is; treated as acquired after the first branch on the return value of a try-acquire; function. .. code-block:: c++. Mutex mu;; int a GUARDED_BY(mu);. void foo() {; bool success = mu.TryLock();; a = 0; // Warning, mu is not locked.; if (success) {; a = 0; // Ok.; mu.Unlock();; } else {; a = 0; // Warning, mu is not locked.; }; }. ASSERT_CAPABILITY(...) and ASSERT_SHARED_CAPABILITY(...); --------------------------------------------------------. *Previously:* ``ASSERT_EXCLUSIVE_LOCK``, ``ASSERT_SHARED_LOCK``. These are attributes on a function or method which asserts the calling thread; already holds the given capability, for example by performing a run-time test; and terminating if the capability is not held. Presence of this annotation; causes the analysis to assume the capability is held after calls to the; annotated function. See :ref:`mutexheader`, below, for example uses. GUARDED_VAR and PT_GUARDED_VAR; ------------------------------. Use of these attributes has been deprecated. Warning flags; -------------. * ``-Wthread-safety``: Umbrella flag which turns on the following:. + ``-Wthread-safety-attributes``: Semantic checks for thread safety attributes.; + ``-Wthread-safety-analysis``: The core analysis.; + ``-Wthread-safety-precise``: Requires that mutex expressions match precisely.; This warning can be disabled for code which has a lot of aliases.; + ``-Wthread-safety-reference``: Checks when guarded members are passed by reference. :ref:`negative` are an experimental feature, which are enabled with:. * ``-Wthread-safety-negative``: Negative capabilities. Off by default. When new fe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:15408,Testability,test,test,15408,"cquire the given; capability, and returns a boolean value indicating success or failure.; The first argument must be ``true`` or ``false``, to specify which return value; indicates success, and the remaining arguments are interpreted in the same way; as ``ACQUIRE``. See :ref:`mutexheader`, below, for example uses. Because the analysis doesn't support conditional locking, a capability is; treated as acquired after the first branch on the return value of a try-acquire; function. .. code-block:: c++. Mutex mu;; int a GUARDED_BY(mu);. void foo() {; bool success = mu.TryLock();; a = 0; // Warning, mu is not locked.; if (success) {; a = 0; // Ok.; mu.Unlock();; } else {; a = 0; // Warning, mu is not locked.; }; }. ASSERT_CAPABILITY(...) and ASSERT_SHARED_CAPABILITY(...); --------------------------------------------------------. *Previously:* ``ASSERT_EXCLUSIVE_LOCK``, ``ASSERT_SHARED_LOCK``. These are attributes on a function or method which asserts the calling thread; already holds the given capability, for example by performing a run-time test; and terminating if the capability is not held. Presence of this annotation; causes the analysis to assume the capability is held after calls to the; annotated function. See :ref:`mutexheader`, below, for example uses. GUARDED_VAR and PT_GUARDED_VAR; ------------------------------. Use of these attributes has been deprecated. Warning flags; -------------. * ``-Wthread-safety``: Umbrella flag which turns on the following:. + ``-Wthread-safety-attributes``: Semantic checks for thread safety attributes.; + ``-Wthread-safety-analysis``: The core analysis.; + ``-Wthread-safety-precise``: Requires that mutex expressions match precisely.; This warning can be disabled for code which has a lot of aliases.; + ``-Wthread-safety-reference``: Checks when guarded members are passed by reference. :ref:`negative` are an experimental feature, which are enabled with:. * ``-Wthread-safety-negative``: Negative capabilities. Off by default. When new fe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:24094,Testability,test,test,24094," (T::*imp)()) : object(obj), mp(imp) { }; ~AutoCleanup() { (object->*mp)(); }; };. Mutex mu;; void foo() {; mu.Lock();; AutoCleanup<Mutex>(&mu, &Mutex::Unlock);; // ...; } // Warning, mu is not unlocked. In this case, the destructor of ``Autocleanup`` calls ``mu.Unlock()``, so; the warning is bogus. However,; thread safety analysis cannot see the unlock, because it does not attempt to; inline the destructor. Moreover, there is no way to annotate the destructor,; because the destructor is calling a function that is not statically known.; This pattern is simply not supported. No alias analysis.; ------------------. The analysis currently does not track pointer aliases. Thus, there can be; false positives if two pointers both point to the same mutex. .. code-block:: c++. class MutexUnlocker {; Mutex* mu;. public:; MutexUnlocker(Mutex* m) RELEASE(m) : mu(m) { mu->Unlock(); }; ~MutexUnlocker() ACQUIRE(mu) { mu->Lock(); }; };. Mutex mutex;; void test() REQUIRES(mutex) {; {; MutexUnlocker munl(&mutex); // unlocks mutex; doSomeIO();; } // Warning: locks munl.mu; }. The MutexUnlocker class is intended to be the dual of the MutexLocker class,; defined in :ref:`mutexheader`. However, it doesn't work because the analysis; doesn't know that munl.mu == mutex. The SCOPED_CAPABILITY attribute handles; aliasing for MutexLocker, but does so only for that particular pattern. ACQUIRED_BEFORE(...) and ACQUIRED_AFTER(...) are currently unimplemented.; -------------------------------------------------------------------------. To be fixed in a future update. .. _mutexheader:. mutex.h; =======. Thread safety analysis can be used with any threading library, but it does; require that the threading API be wrapped in classes and methods which have the; appropriate annotations. The following code provides ``mutex.h`` as an example;; these methods should be filled in to call the appropriate underlying; implementation. .. code-block:: c++. #ifndef THREAD_SAFETY_ANALYSIS_MUTEX_H; #define THREAD_SAFE",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:3180,Usability,simpl,simply,3180,"``mu`` before calling ``withdrawImpl``.; Because the caller is assumed to have locked ``mu``, it is safe to modify; ``balance`` within the body of the method. The ``depositImpl()`` method does not have ``REQUIRES``, so the; analysis issues a warning. Thread safety analysis is not inter-procedural, so; caller requirements must be explicitly declared.; There is also a warning in ``transferFrom()``, because although the method; locks ``this->mu``, it does not lock ``b.mu``. The analysis understands; that these are two separate mutexes, in two different objects. Finally, there is a warning in the ``withdraw()`` method, because it fails to; unlock ``mu``. Every lock must have a corresponding unlock, and the analysis; will detect both double locks, and double unlocks. A function is allowed to; acquire a lock without releasing it, (or vice versa), but it must be annotated; as such (using ``ACQUIRE``/``RELEASE``). Running The Analysis; --------------------. To run the analysis, simply compile with the ``-Wthread-safety`` flag, e.g. .. code-block:: bash. clang -c -Wthread-safety example.cpp. Note that this example assumes the presence of a suitably annotated; :ref:`mutexheader` that declares which methods perform locking,; unlocking, and so on. Basic Concepts: Capabilities; ============================. Thread safety analysis provides a way of protecting *resources* with; *capabilities*. A resource is either a data member, or a function/method; that provides access to some underlying resource. The analysis ensures that; the calling thread cannot access the *resource* (i.e. call the function, or; read/write the data) unless it has the *capability* to do so. Capabilities are associated with named C++ objects which declare specific; methods to acquire and release the capability. The name of the object serves; to identify the capability. The most common example is a mutex. For example,; if ``mu`` is a mutex, then calling ``mu.Lock()`` causes the calling thread; to acquire the ca",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:10493,Usability,clear,clear,10493,"argument is; assumed to be ``this``, and the analysis will not check the body of the; function. This pattern is intended for use by classes which hide locking; details behind an abstract interface. For example:. .. code-block:: c++. template <class T>; class CAPABILITY(""mutex"") Container {; private:; Mutex mu;; T* data;. public:; // Hide mu from public interface.; void Lock() ACQUIRE() { mu.Lock(); }; void Unlock() RELEASE() { mu.Unlock(); }. T& getElem(int i) { return data[i]; }; };. void test() {; Container<int> c;; c.Lock();; int i = c.getElem(0);; c.Unlock();; }. EXCLUDES(...); -------------. *Previously*: ``LOCKS_EXCLUDED``. ``EXCLUDES`` is an attribute on functions or methods, which declares that; the caller must *not* hold the given capabilities. This annotation is; used to prevent deadlock. Many mutex implementations are not re-entrant, so; deadlock can occur if the function acquires the mutex a second time. .. code-block:: c++. Mutex mu;; int a GUARDED_BY(mu);. void clear() EXCLUDES(mu) {; mu.Lock();; a = 0;; mu.Unlock();; }. void reset() {; mu.Lock();; clear(); // Warning! Caller cannot hold 'mu'.; mu.Unlock();; }. Unlike ``REQUIRES``, ``EXCLUDES`` is optional. The analysis will not issue a; warning if the attribute is missing, which can lead to false negatives in some; cases. This issue is discussed further in :ref:`negative`. NO_THREAD_SAFETY_ANALYSIS; -------------------------. ``NO_THREAD_SAFETY_ANALYSIS`` is an attribute on functions or methods, which; turns off thread safety checking for that method. It provides an escape hatch; for functions which are either (1) deliberately thread-unsafe, or (2) are; thread-safe, but too complicated for the analysis to understand. Reasons for; (2) will be described in the :ref:`limitations`, below. .. code-block:: c++. class Counter {; Mutex mu;; int a GUARDED_BY(mu);. void unsafeIncrement() NO_THREAD_SAFETY_ANALYSIS { a++; }; };. Unlike the other attributes, NO_THREAD_SAFETY_ANALYSIS is not part of the; interface o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:10582,Usability,clear,clear,10582,"his pattern is intended for use by classes which hide locking; details behind an abstract interface. For example:. .. code-block:: c++. template <class T>; class CAPABILITY(""mutex"") Container {; private:; Mutex mu;; T* data;. public:; // Hide mu from public interface.; void Lock() ACQUIRE() { mu.Lock(); }; void Unlock() RELEASE() { mu.Unlock(); }. T& getElem(int i) { return data[i]; }; };. void test() {; Container<int> c;; c.Lock();; int i = c.getElem(0);; c.Unlock();; }. EXCLUDES(...); -------------. *Previously*: ``LOCKS_EXCLUDED``. ``EXCLUDES`` is an attribute on functions or methods, which declares that; the caller must *not* hold the given capabilities. This annotation is; used to prevent deadlock. Many mutex implementations are not re-entrant, so; deadlock can occur if the function acquires the mutex a second time. .. code-block:: c++. Mutex mu;; int a GUARDED_BY(mu);. void clear() EXCLUDES(mu) {; mu.Lock();; a = 0;; mu.Unlock();; }. void reset() {; mu.Lock();; clear(); // Warning! Caller cannot hold 'mu'.; mu.Unlock();; }. Unlike ``REQUIRES``, ``EXCLUDES`` is optional. The analysis will not issue a; warning if the attribute is missing, which can lead to false negatives in some; cases. This issue is discussed further in :ref:`negative`. NO_THREAD_SAFETY_ANALYSIS; -------------------------. ``NO_THREAD_SAFETY_ANALYSIS`` is an attribute on functions or methods, which; turns off thread safety checking for that method. It provides an escape hatch; for functions which are either (1) deliberately thread-unsafe, or (2) are; thread-safe, but too complicated for the analysis to understand. Reasons for; (2) will be described in the :ref:`limitations`, below. .. code-block:: c++. class Counter {; Mutex mu;; int a GUARDED_BY(mu);. void unsafeIncrement() NO_THREAD_SAFETY_ANALYSIS { a++; }; };. Unlike the other attributes, NO_THREAD_SAFETY_ANALYSIS is not part of the; interface of a function, and should thus be placed on the function definition; (in the ``.cc`` or ``.cpp`` ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:12131,Usability,clear,clear,12131,"unsafe, or (2) are; thread-safe, but too complicated for the analysis to understand. Reasons for; (2) will be described in the :ref:`limitations`, below. .. code-block:: c++. class Counter {; Mutex mu;; int a GUARDED_BY(mu);. void unsafeIncrement() NO_THREAD_SAFETY_ANALYSIS { a++; }; };. Unlike the other attributes, NO_THREAD_SAFETY_ANALYSIS is not part of the; interface of a function, and should thus be placed on the function definition; (in the ``.cc`` or ``.cpp`` file) rather than on the function declaration; (in the header). RETURN_CAPABILITY(c); --------------------. *Previously*: ``LOCK_RETURNED``. ``RETURN_CAPABILITY`` is an attribute on functions or methods, which declares; that the function returns a reference to the given capability. It is used to; annotate getter methods that return mutexes. .. code-block:: c++. class MyClass {; private:; Mutex mu;; int a GUARDED_BY(mu);. public:; Mutex* getMu() RETURN_CAPABILITY(mu) { return &mu; }. // analysis knows that getMu() == mu; void clear() REQUIRES(getMu()) { a = 0; }; };. ACQUIRED_BEFORE(...), ACQUIRED_AFTER(...); -----------------------------------------. ``ACQUIRED_BEFORE`` and ``ACQUIRED_AFTER`` are attributes on member; declarations, specifically declarations of mutexes or other capabilities.; These declarations enforce a particular order in which the mutexes must be; acquired, in order to prevent deadlock. .. code-block:: c++. Mutex m1;; Mutex m2 ACQUIRED_AFTER(m1);. // Alternative declaration; // Mutex m2;; // Mutex m1 ACQUIRED_BEFORE(m2);. void foo() {; m2.Lock();; m1.Lock(); // Warning! m2 must be acquired after m1.; m1.Unlock();; m2.Unlock();; }. CAPABILITY(<string>); --------------------. *Previously*: ``LOCKABLE``. ``CAPABILITY`` is an attribute on classes, which specifies that objects of the; class can be used as a capability. The string argument specifies the kind of; capability in error messages, e.g. ``""mutex""``. See the ``Container`` example; given above, or the ``Mutex`` class in :ref:`mutexhea",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst:23699,Usability,simpl,simply,23699,"a is owned by the enclosing object. No inlining.; ------------. Thread safety analysis is strictly intra-procedural, just like ordinary type; checking. It relies only on the declared attributes of a function, and will; not attempt to inline any method calls. As a result, code such as the; following will not work:. .. code-block:: c++. template<class T>; class AutoCleanup {; T* object;; void (T::*mp)();. public:; AutoCleanup(T* obj, void (T::*imp)()) : object(obj), mp(imp) { }; ~AutoCleanup() { (object->*mp)(); }; };. Mutex mu;; void foo() {; mu.Lock();; AutoCleanup<Mutex>(&mu, &Mutex::Unlock);; // ...; } // Warning, mu is not unlocked. In this case, the destructor of ``Autocleanup`` calls ``mu.Unlock()``, so; the warning is bogus. However,; thread safety analysis cannot see the unlock, because it does not attempt to; inline the destructor. Moreover, there is no way to annotate the destructor,; because the destructor is calling a function that is not statically known.; This pattern is simply not supported. No alias analysis.; ------------------. The analysis currently does not track pointer aliases. Thus, there can be; false positives if two pointers both point to the same mutex. .. code-block:: c++. class MutexUnlocker {; Mutex* mu;. public:; MutexUnlocker(Mutex* m) RELEASE(m) : mu(m) { mu->Unlock(); }; ~MutexUnlocker() ACQUIRE(mu) { mu->Lock(); }; };. Mutex mutex;; void test() REQUIRES(mutex) {; {; MutexUnlocker munl(&mutex); // unlocks mutex; doSomeIO();; } // Warning: locks munl.mu; }. The MutexUnlocker class is intended to be the dual of the MutexLocker class,; defined in :ref:`mutexheader`. However, it doesn't work because the analysis; doesn't know that munl.mu == mutex. The SCOPED_CAPABILITY attribute handles; aliasing for MutexLocker, but does so only for that particular pattern. ACQUIRED_BEFORE(...) and ACQUIRED_AFTER(...) are currently unimplemented.; -------------------------------------------------------------------------. To be fixed in a future update. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSafetyAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst:1396,Availability,error,error,1396,"CMake <https://llvm.org/docs/CMake.html>`_. Supported Platforms; -------------------. ThreadSanitizer is supported on the following OS:. * Android aarch64, x86_64; * Darwin arm64, x86_64; * FreeBSD; * Linux aarch64, x86_64, powerpc64, powerpc64le; * NetBSD. Support for other 64-bit architectures is possible, contributions are welcome.; Support for 32-bit platforms is problematic and is not planned. Usage; -----. Simply compile and link your program with ``-fsanitize=thread``. To get a; reasonable performance add ``-O1`` or higher. Use ``-g`` to get file names; and line numbers in the warning messages. Example:. .. code-block:: console. % cat projects/compiler-rt/lib/tsan/lit_tests/tiny_race.c; #include <pthread.h>; int Global;; void *Thread1(void *x) {; Global = 42;; return x;; }; int main() {; pthread_t t;; pthread_create(&t, NULL, Thread1, NULL);; Global = 43;; pthread_join(t, NULL);; return Global;; }. $ clang -fsanitize=thread -g -O1 tiny_race.c. If a bug is detected, the program will print an error message to stderr.; Currently, ThreadSanitizer symbolizes its output using an external; ``addr2line`` process (this will be fixed in future). .. code-block:: bash. % ./a.out; WARNING: ThreadSanitizer: data race (pid=19219); Write of size 4 at 0x7fcf47b21bc0 by thread T1:; #0 Thread1 tiny_race.c:4 (exe+0x00000000a360). Previous write of size 4 at 0x7fcf47b21bc0 by main thread:; #0 main tiny_race.c:10 (exe+0x00000000a3b4). Thread T1 (running) created at:; #0 pthread_create tsan_interceptors.cc:705 (exe+0x00000000c790); #1 main tiny_race.c:9 (exe+0x00000000a3a4). ``__has_feature(thread_sanitizer)``; ------------------------------------. In some cases one may need to execute different code depending on whether; ThreadSanitizer is enabled.; :ref:`\_\_has\_feature <langext-__has_feature-__has_extension>` can be used for; this purpose. .. code-block:: c. #if defined(__has_feature); # if __has_feature(thread_sanitizer); // code that builds only under ThreadSanitizer; # endif;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst:3366,Availability,toler,tolerate,3366," that builds only under ThreadSanitizer; # endif; #endif. ``__attribute__((no_sanitize(""thread"")))``; -----------------------------------------------. Some code should not be instrumented by ThreadSanitizer. One may use the; function attribute ``no_sanitize(""thread"")`` to disable instrumentation of plain; (non-atomic) loads/stores in a particular function. ThreadSanitizer still; instruments such functions to avoid false positives and provide meaningful stack; traces. This attribute may not be supported by other compilers, so we suggest; to use it together with ``__has_feature(thread_sanitizer)``. ``__attribute__((disable_sanitizer_instrumentation))``; --------------------------------------------------------. The ``disable_sanitizer_instrumentation`` attribute can be applied to functions; to prevent all kinds of instrumentation. As a result, it may introduce false; positives and incorrect stack traces. Therefore, it should be used with care,; and only if absolutely required; for example for certain code that cannot; tolerate any instrumentation and resulting side-effects. This attribute; overrides ``no_sanitize(""thread"")``. Ignorelist; ----------. ThreadSanitizer supports ``src`` and ``fun`` entity types in; :doc:`SanitizerSpecialCaseList`, that can be used to suppress data race reports; in the specified source files or functions. Unlike functions marked with; ``no_sanitize(""thread"")`` attribute, ignored functions are not instrumented; at all. This can lead to false positives due to missed synchronization via; atomic operations and missed stack frames in reports. Limitations; -----------. * ThreadSanitizer uses more real memory than a native run. At the default; settings the memory overhead is 5x plus 1Mb per each thread. Settings with 3x; (less accurate analysis) and 9x (more accurate analysis) overhead are also; available.; * ThreadSanitizer maps (but does not reserve) a lot of virtual address space.; This means that tools like ``ulimit`` may not work as usually exp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst:4180,Availability,avail,available,4180,"prevent all kinds of instrumentation. As a result, it may introduce false; positives and incorrect stack traces. Therefore, it should be used with care,; and only if absolutely required; for example for certain code that cannot; tolerate any instrumentation and resulting side-effects. This attribute; overrides ``no_sanitize(""thread"")``. Ignorelist; ----------. ThreadSanitizer supports ``src`` and ``fun`` entity types in; :doc:`SanitizerSpecialCaseList`, that can be used to suppress data race reports; in the specified source files or functions. Unlike functions marked with; ``no_sanitize(""thread"")`` attribute, ignored functions are not instrumented; at all. This can lead to false positives due to missed synchronization via; atomic operations and missed stack frames in reports. Limitations; -----------. * ThreadSanitizer uses more real memory than a native run. At the default; settings the memory overhead is 5x plus 1Mb per each thread. Settings with 3x; (less accurate analysis) and 9x (more accurate analysis) overhead are also; available.; * ThreadSanitizer maps (but does not reserve) a lot of virtual address space.; This means that tools like ``ulimit`` may not work as usually expected.; * Libc/libstdc++ static linking is not supported.; * Non-position-independent executables are not supported. Therefore, the; ``fsanitize=thread`` flag will cause Clang to act as though the ``-fPIE``; flag had been supplied if compiling without ``-fPIC``, and as though the; ``-pie`` flag had been supplied if linking an executable. Current Status; --------------. ThreadSanitizer is in beta stage. It is known to work on large C++ programs; using pthreads, but we do not promise anything (yet). C++11 threading is; supported with llvm libc++. The test suite is integrated into CMake build; and can be run with ``make check-tsan`` command. We are actively working on enhancing the tool --- stay tuned. Any help,; especially in the form of minimized standalone tests is more than welcome. More In",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst:4905,Deployability,integrat,integrated,4905,"k traces. Therefore, it should be used with care,; and only if absolutely required; for example for certain code that cannot; tolerate any instrumentation and resulting side-effects. This attribute; overrides ``no_sanitize(""thread"")``. Ignorelist; ----------. ThreadSanitizer supports ``src`` and ``fun`` entity types in; :doc:`SanitizerSpecialCaseList`, that can be used to suppress data race reports; in the specified source files or functions. Unlike functions marked with; ``no_sanitize(""thread"")`` attribute, ignored functions are not instrumented; at all. This can lead to false positives due to missed synchronization via; atomic operations and missed stack frames in reports. Limitations; -----------. * ThreadSanitizer uses more real memory than a native run. At the default; settings the memory overhead is 5x plus 1Mb per each thread. Settings with 3x; (less accurate analysis) and 9x (more accurate analysis) overhead are also; available.; * ThreadSanitizer maps (but does not reserve) a lot of virtual address space.; This means that tools like ``ulimit`` may not work as usually expected.; * Libc/libstdc++ static linking is not supported.; * Non-position-independent executables are not supported. Therefore, the; ``fsanitize=thread`` flag will cause Clang to act as though the ``-fPIE``; flag had been supplied if compiling without ``-fPIC``, and as though the; ``-pie`` flag had been supplied if linking an executable. Current Status; --------------. ThreadSanitizer is in beta stage. It is known to work on large C++ programs; using pthreads, but we do not promise anything (yet). C++11 threading is; supported with llvm libc++. The test suite is integrated into CMake build; and can be run with ``make check-tsan`` command. We are actively working on enhancing the tool --- stay tuned. Any help,; especially in the form of minimized standalone tests is more than welcome. More Information; ----------------; `<https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual>`_; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst:982,Integrability,message,messages,982,"ThreadSanitizer; ===============. Introduction; ------------. ThreadSanitizer is a tool that detects data races. It consists of a compiler; instrumentation module and a run-time library. Typical slowdown introduced by; ThreadSanitizer is about **5x-15x**. Typical memory overhead introduced by; ThreadSanitizer is about **5x-10x**. How to build; ------------. Build LLVM/Clang with `CMake <https://llvm.org/docs/CMake.html>`_. Supported Platforms; -------------------. ThreadSanitizer is supported on the following OS:. * Android aarch64, x86_64; * Darwin arm64, x86_64; * FreeBSD; * Linux aarch64, x86_64, powerpc64, powerpc64le; * NetBSD. Support for other 64-bit architectures is possible, contributions are welcome.; Support for 32-bit platforms is problematic and is not planned. Usage; -----. Simply compile and link your program with ``-fsanitize=thread``. To get a; reasonable performance add ``-O1`` or higher. Use ``-g`` to get file names; and line numbers in the warning messages. Example:. .. code-block:: console. % cat projects/compiler-rt/lib/tsan/lit_tests/tiny_race.c; #include <pthread.h>; int Global;; void *Thread1(void *x) {; Global = 42;; return x;; }; int main() {; pthread_t t;; pthread_create(&t, NULL, Thread1, NULL);; Global = 43;; pthread_join(t, NULL);; return Global;; }. $ clang -fsanitize=thread -g -O1 tiny_race.c. If a bug is detected, the program will print an error message to stderr.; Currently, ThreadSanitizer symbolizes its output using an external; ``addr2line`` process (this will be fixed in future). .. code-block:: bash. % ./a.out; WARNING: ThreadSanitizer: data race (pid=19219); Write of size 4 at 0x7fcf47b21bc0 by thread T1:; #0 Thread1 tiny_race.c:4 (exe+0x00000000a360). Previous write of size 4 at 0x7fcf47b21bc0 by main thread:; #0 main tiny_race.c:10 (exe+0x00000000a3b4). Thread T1 (running) created at:; #0 pthread_create tsan_interceptors.cc:705 (exe+0x00000000c790); #1 main tiny_race.c:9 (exe+0x00000000a3a4). ``__has_feature(thread_sanitizer",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst:1402,Integrability,message,message,1402,"CMake <https://llvm.org/docs/CMake.html>`_. Supported Platforms; -------------------. ThreadSanitizer is supported on the following OS:. * Android aarch64, x86_64; * Darwin arm64, x86_64; * FreeBSD; * Linux aarch64, x86_64, powerpc64, powerpc64le; * NetBSD. Support for other 64-bit architectures is possible, contributions are welcome.; Support for 32-bit platforms is problematic and is not planned. Usage; -----. Simply compile and link your program with ``-fsanitize=thread``. To get a; reasonable performance add ``-O1`` or higher. Use ``-g`` to get file names; and line numbers in the warning messages. Example:. .. code-block:: console. % cat projects/compiler-rt/lib/tsan/lit_tests/tiny_race.c; #include <pthread.h>; int Global;; void *Thread1(void *x) {; Global = 42;; return x;; }; int main() {; pthread_t t;; pthread_create(&t, NULL, Thread1, NULL);; Global = 43;; pthread_join(t, NULL);; return Global;; }. $ clang -fsanitize=thread -g -O1 tiny_race.c. If a bug is detected, the program will print an error message to stderr.; Currently, ThreadSanitizer symbolizes its output using an external; ``addr2line`` process (this will be fixed in future). .. code-block:: bash. % ./a.out; WARNING: ThreadSanitizer: data race (pid=19219); Write of size 4 at 0x7fcf47b21bc0 by thread T1:; #0 Thread1 tiny_race.c:4 (exe+0x00000000a360). Previous write of size 4 at 0x7fcf47b21bc0 by main thread:; #0 main tiny_race.c:10 (exe+0x00000000a3b4). Thread T1 (running) created at:; #0 pthread_create tsan_interceptors.cc:705 (exe+0x00000000c790); #1 main tiny_race.c:9 (exe+0x00000000a3a4). ``__has_feature(thread_sanitizer)``; ------------------------------------. In some cases one may need to execute different code depending on whether; ThreadSanitizer is enabled.; :ref:`\_\_has\_feature <langext-__has_feature-__has_extension>` can be used for; this purpose. .. code-block:: c. #if defined(__has_feature); # if __has_feature(thread_sanitizer); // code that builds only under ThreadSanitizer; # endif;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst:2097,Integrability,depend,depending,2097," <pthread.h>; int Global;; void *Thread1(void *x) {; Global = 42;; return x;; }; int main() {; pthread_t t;; pthread_create(&t, NULL, Thread1, NULL);; Global = 43;; pthread_join(t, NULL);; return Global;; }. $ clang -fsanitize=thread -g -O1 tiny_race.c. If a bug is detected, the program will print an error message to stderr.; Currently, ThreadSanitizer symbolizes its output using an external; ``addr2line`` process (this will be fixed in future). .. code-block:: bash. % ./a.out; WARNING: ThreadSanitizer: data race (pid=19219); Write of size 4 at 0x7fcf47b21bc0 by thread T1:; #0 Thread1 tiny_race.c:4 (exe+0x00000000a360). Previous write of size 4 at 0x7fcf47b21bc0 by main thread:; #0 main tiny_race.c:10 (exe+0x00000000a3b4). Thread T1 (running) created at:; #0 pthread_create tsan_interceptors.cc:705 (exe+0x00000000c790); #1 main tiny_race.c:9 (exe+0x00000000a3a4). ``__has_feature(thread_sanitizer)``; ------------------------------------. In some cases one may need to execute different code depending on whether; ThreadSanitizer is enabled.; :ref:`\_\_has\_feature <langext-__has_feature-__has_extension>` can be used for; this purpose. .. code-block:: c. #if defined(__has_feature); # if __has_feature(thread_sanitizer); // code that builds only under ThreadSanitizer; # endif; #endif. ``__attribute__((no_sanitize(""thread"")))``; -----------------------------------------------. Some code should not be instrumented by ThreadSanitizer. One may use the; function attribute ``no_sanitize(""thread"")`` to disable instrumentation of plain; (non-atomic) loads/stores in a particular function. ThreadSanitizer still; instruments such functions to avoid false positives and provide meaningful stack; traces. This attribute may not be supported by other compilers, so we suggest; to use it together with ``__has_feature(thread_sanitizer)``. ``__attribute__((disable_sanitizer_instrumentation))``; --------------------------------------------------------. The ``disable_sanitizer_instrumentation`` ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst:3849,Integrability,synchroniz,synchronization,3849," so we suggest; to use it together with ``__has_feature(thread_sanitizer)``. ``__attribute__((disable_sanitizer_instrumentation))``; --------------------------------------------------------. The ``disable_sanitizer_instrumentation`` attribute can be applied to functions; to prevent all kinds of instrumentation. As a result, it may introduce false; positives and incorrect stack traces. Therefore, it should be used with care,; and only if absolutely required; for example for certain code that cannot; tolerate any instrumentation and resulting side-effects. This attribute; overrides ``no_sanitize(""thread"")``. Ignorelist; ----------. ThreadSanitizer supports ``src`` and ``fun`` entity types in; :doc:`SanitizerSpecialCaseList`, that can be used to suppress data race reports; in the specified source files or functions. Unlike functions marked with; ``no_sanitize(""thread"")`` attribute, ignored functions are not instrumented; at all. This can lead to false positives due to missed synchronization via; atomic operations and missed stack frames in reports. Limitations; -----------. * ThreadSanitizer uses more real memory than a native run. At the default; settings the memory overhead is 5x plus 1Mb per each thread. Settings with 3x; (less accurate analysis) and 9x (more accurate analysis) overhead are also; available.; * ThreadSanitizer maps (but does not reserve) a lot of virtual address space.; This means that tools like ``ulimit`` may not work as usually expected.; * Libc/libstdc++ static linking is not supported.; * Non-position-independent executables are not supported. Therefore, the; ``fsanitize=thread`` flag will cause Clang to act as though the ``-fPIE``; flag had been supplied if compiling without ``-fPIC``, and as though the; ``-pie`` flag had been supplied if linking an executable. Current Status; --------------. ThreadSanitizer is in beta stage. It is known to work on large C++ programs; using pthreads, but we do not promise anything (yet). C++11 threading is; sup",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst:4905,Integrability,integrat,integrated,4905,"k traces. Therefore, it should be used with care,; and only if absolutely required; for example for certain code that cannot; tolerate any instrumentation and resulting side-effects. This attribute; overrides ``no_sanitize(""thread"")``. Ignorelist; ----------. ThreadSanitizer supports ``src`` and ``fun`` entity types in; :doc:`SanitizerSpecialCaseList`, that can be used to suppress data race reports; in the specified source files or functions. Unlike functions marked with; ``no_sanitize(""thread"")`` attribute, ignored functions are not instrumented; at all. This can lead to false positives due to missed synchronization via; atomic operations and missed stack frames in reports. Limitations; -----------. * ThreadSanitizer uses more real memory than a native run. At the default; settings the memory overhead is 5x plus 1Mb per each thread. Settings with 3x; (less accurate analysis) and 9x (more accurate analysis) overhead are also; available.; * ThreadSanitizer maps (but does not reserve) a lot of virtual address space.; This means that tools like ``ulimit`` may not work as usually expected.; * Libc/libstdc++ static linking is not supported.; * Non-position-independent executables are not supported. Therefore, the; ``fsanitize=thread`` flag will cause Clang to act as though the ``-fPIE``; flag had been supplied if compiling without ``-fPIC``, and as though the; ``-pie`` flag had been supplied if linking an executable. Current Status; --------------. ThreadSanitizer is in beta stage. It is known to work on large C++ programs; using pthreads, but we do not promise anything (yet). C++11 threading is; supported with llvm libc++. The test suite is integrated into CMake build; and can be run with ``make check-tsan`` command. We are actively working on enhancing the tool --- stay tuned. Any help,; especially in the form of minimized standalone tests is more than welcome. More Information; ----------------; `<https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual>`_; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst:885,Performance,perform,performance,885,"ThreadSanitizer; ===============. Introduction; ------------. ThreadSanitizer is a tool that detects data races. It consists of a compiler; instrumentation module and a run-time library. Typical slowdown introduced by; ThreadSanitizer is about **5x-15x**. Typical memory overhead introduced by; ThreadSanitizer is about **5x-10x**. How to build; ------------. Build LLVM/Clang with `CMake <https://llvm.org/docs/CMake.html>`_. Supported Platforms; -------------------. ThreadSanitizer is supported on the following OS:. * Android aarch64, x86_64; * Darwin arm64, x86_64; * FreeBSD; * Linux aarch64, x86_64, powerpc64, powerpc64le; * NetBSD. Support for other 64-bit architectures is possible, contributions are welcome.; Support for 32-bit platforms is problematic and is not planned. Usage; -----. Simply compile and link your program with ``-fsanitize=thread``. To get a; reasonable performance add ``-O1`` or higher. Use ``-g`` to get file names; and line numbers in the warning messages. Example:. .. code-block:: console. % cat projects/compiler-rt/lib/tsan/lit_tests/tiny_race.c; #include <pthread.h>; int Global;; void *Thread1(void *x) {; Global = 42;; return x;; }; int main() {; pthread_t t;; pthread_create(&t, NULL, Thread1, NULL);; Global = 43;; pthread_join(t, NULL);; return Global;; }. $ clang -fsanitize=thread -g -O1 tiny_race.c. If a bug is detected, the program will print an error message to stderr.; Currently, ThreadSanitizer symbolizes its output using an external; ``addr2line`` process (this will be fixed in future). .. code-block:: bash. % ./a.out; WARNING: ThreadSanitizer: data race (pid=19219); Write of size 4 at 0x7fcf47b21bc0 by thread T1:; #0 Thread1 tiny_race.c:4 (exe+0x00000000a360). Previous write of size 4 at 0x7fcf47b21bc0 by main thread:; #0 main tiny_race.c:10 (exe+0x00000000a3b4). Thread T1 (running) created at:; #0 pthread_create tsan_interceptors.cc:705 (exe+0x00000000c790); #1 main tiny_race.c:9 (exe+0x00000000a3a4). ``__has_feature(thread_sanitizer",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst:2655,Performance,load,loads,2655,"=19219); Write of size 4 at 0x7fcf47b21bc0 by thread T1:; #0 Thread1 tiny_race.c:4 (exe+0x00000000a360). Previous write of size 4 at 0x7fcf47b21bc0 by main thread:; #0 main tiny_race.c:10 (exe+0x00000000a3b4). Thread T1 (running) created at:; #0 pthread_create tsan_interceptors.cc:705 (exe+0x00000000c790); #1 main tiny_race.c:9 (exe+0x00000000a3a4). ``__has_feature(thread_sanitizer)``; ------------------------------------. In some cases one may need to execute different code depending on whether; ThreadSanitizer is enabled.; :ref:`\_\_has\_feature <langext-__has_feature-__has_extension>` can be used for; this purpose. .. code-block:: c. #if defined(__has_feature); # if __has_feature(thread_sanitizer); // code that builds only under ThreadSanitizer; # endif; #endif. ``__attribute__((no_sanitize(""thread"")))``; -----------------------------------------------. Some code should not be instrumented by ThreadSanitizer. One may use the; function attribute ``no_sanitize(""thread"")`` to disable instrumentation of plain; (non-atomic) loads/stores in a particular function. ThreadSanitizer still; instruments such functions to avoid false positives and provide meaningful stack; traces. This attribute may not be supported by other compilers, so we suggest; to use it together with ``__has_feature(thread_sanitizer)``. ``__attribute__((disable_sanitizer_instrumentation))``; --------------------------------------------------------. The ``disable_sanitizer_instrumentation`` attribute can be applied to functions; to prevent all kinds of instrumentation. As a result, it may introduce false; positives and incorrect stack traces. Therefore, it should be used with care,; and only if absolutely required; for example for certain code that cannot; tolerate any instrumentation and resulting side-effects. This attribute; overrides ``no_sanitize(""thread"")``. Ignorelist; ----------. ThreadSanitizer supports ``src`` and ``fun`` entity types in; :doc:`SanitizerSpecialCaseList`, that can be used to sup",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst:5038,Performance,tune,tuned,5038,"k traces. Therefore, it should be used with care,; and only if absolutely required; for example for certain code that cannot; tolerate any instrumentation and resulting side-effects. This attribute; overrides ``no_sanitize(""thread"")``. Ignorelist; ----------. ThreadSanitizer supports ``src`` and ``fun`` entity types in; :doc:`SanitizerSpecialCaseList`, that can be used to suppress data race reports; in the specified source files or functions. Unlike functions marked with; ``no_sanitize(""thread"")`` attribute, ignored functions are not instrumented; at all. This can lead to false positives due to missed synchronization via; atomic operations and missed stack frames in reports. Limitations; -----------. * ThreadSanitizer uses more real memory than a native run. At the default; settings the memory overhead is 5x plus 1Mb per each thread. Settings with 3x; (less accurate analysis) and 9x (more accurate analysis) overhead are also; available.; * ThreadSanitizer maps (but does not reserve) a lot of virtual address space.; This means that tools like ``ulimit`` may not work as usually expected.; * Libc/libstdc++ static linking is not supported.; * Non-position-independent executables are not supported. Therefore, the; ``fsanitize=thread`` flag will cause Clang to act as though the ``-fPIE``; flag had been supplied if compiling without ``-fPIC``, and as though the; ``-pie`` flag had been supplied if linking an executable. Current Status; --------------. ThreadSanitizer is in beta stage. It is known to work on large C++ programs; using pthreads, but we do not promise anything (yet). C++11 threading is; supported with llvm libc++. The test suite is integrated into CMake build; and can be run with ``make check-tsan`` command. We are actively working on enhancing the tool --- stay tuned. Any help,; especially in the form of minimized standalone tests is more than welcome. More Information; ----------------; `<https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual>`_; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst:93,Safety,detect,detects,93,"ThreadSanitizer; ===============. Introduction; ------------. ThreadSanitizer is a tool that detects data races. It consists of a compiler; instrumentation module and a run-time library. Typical slowdown introduced by; ThreadSanitizer is about **5x-15x**. Typical memory overhead introduced by; ThreadSanitizer is about **5x-10x**. How to build; ------------. Build LLVM/Clang with `CMake <https://llvm.org/docs/CMake.html>`_. Supported Platforms; -------------------. ThreadSanitizer is supported on the following OS:. * Android aarch64, x86_64; * Darwin arm64, x86_64; * FreeBSD; * Linux aarch64, x86_64, powerpc64, powerpc64le; * NetBSD. Support for other 64-bit architectures is possible, contributions are welcome.; Support for 32-bit platforms is problematic and is not planned. Usage; -----. Simply compile and link your program with ``-fsanitize=thread``. To get a; reasonable performance add ``-O1`` or higher. Use ``-g`` to get file names; and line numbers in the warning messages. Example:. .. code-block:: console. % cat projects/compiler-rt/lib/tsan/lit_tests/tiny_race.c; #include <pthread.h>; int Global;; void *Thread1(void *x) {; Global = 42;; return x;; }; int main() {; pthread_t t;; pthread_create(&t, NULL, Thread1, NULL);; Global = 43;; pthread_join(t, NULL);; return Global;; }. $ clang -fsanitize=thread -g -O1 tiny_race.c. If a bug is detected, the program will print an error message to stderr.; Currently, ThreadSanitizer symbolizes its output using an external; ``addr2line`` process (this will be fixed in future). .. code-block:: bash. % ./a.out; WARNING: ThreadSanitizer: data race (pid=19219); Write of size 4 at 0x7fcf47b21bc0 by thread T1:; #0 Thread1 tiny_race.c:4 (exe+0x00000000a360). Previous write of size 4 at 0x7fcf47b21bc0 by main thread:; #0 main tiny_race.c:10 (exe+0x00000000a3b4). Thread T1 (running) created at:; #0 pthread_create tsan_interceptors.cc:705 (exe+0x00000000c790); #1 main tiny_race.c:9 (exe+0x00000000a3a4). ``__has_feature(thread_sanitizer",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst:1360,Safety,detect,detected,1360,"CMake <https://llvm.org/docs/CMake.html>`_. Supported Platforms; -------------------. ThreadSanitizer is supported on the following OS:. * Android aarch64, x86_64; * Darwin arm64, x86_64; * FreeBSD; * Linux aarch64, x86_64, powerpc64, powerpc64le; * NetBSD. Support for other 64-bit architectures is possible, contributions are welcome.; Support for 32-bit platforms is problematic and is not planned. Usage; -----. Simply compile and link your program with ``-fsanitize=thread``. To get a; reasonable performance add ``-O1`` or higher. Use ``-g`` to get file names; and line numbers in the warning messages. Example:. .. code-block:: console. % cat projects/compiler-rt/lib/tsan/lit_tests/tiny_race.c; #include <pthread.h>; int Global;; void *Thread1(void *x) {; Global = 42;; return x;; }; int main() {; pthread_t t;; pthread_create(&t, NULL, Thread1, NULL);; Global = 43;; pthread_join(t, NULL);; return Global;; }. $ clang -fsanitize=thread -g -O1 tiny_race.c. If a bug is detected, the program will print an error message to stderr.; Currently, ThreadSanitizer symbolizes its output using an external; ``addr2line`` process (this will be fixed in future). .. code-block:: bash. % ./a.out; WARNING: ThreadSanitizer: data race (pid=19219); Write of size 4 at 0x7fcf47b21bc0 by thread T1:; #0 Thread1 tiny_race.c:4 (exe+0x00000000a360). Previous write of size 4 at 0x7fcf47b21bc0 by main thread:; #0 main tiny_race.c:10 (exe+0x00000000a3b4). Thread T1 (running) created at:; #0 pthread_create tsan_interceptors.cc:705 (exe+0x00000000c790); #1 main tiny_race.c:9 (exe+0x00000000a3a4). ``__has_feature(thread_sanitizer)``; ------------------------------------. In some cases one may need to execute different code depending on whether; ThreadSanitizer is enabled.; :ref:`\_\_has\_feature <langext-__has_feature-__has_extension>` can be used for; this purpose. .. code-block:: c. #if defined(__has_feature); # if __has_feature(thread_sanitizer); // code that builds only under ThreadSanitizer; # endif;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst:2747,Safety,avoid,avoid,2747," 0x7fcf47b21bc0 by main thread:; #0 main tiny_race.c:10 (exe+0x00000000a3b4). Thread T1 (running) created at:; #0 pthread_create tsan_interceptors.cc:705 (exe+0x00000000c790); #1 main tiny_race.c:9 (exe+0x00000000a3a4). ``__has_feature(thread_sanitizer)``; ------------------------------------. In some cases one may need to execute different code depending on whether; ThreadSanitizer is enabled.; :ref:`\_\_has\_feature <langext-__has_feature-__has_extension>` can be used for; this purpose. .. code-block:: c. #if defined(__has_feature); # if __has_feature(thread_sanitizer); // code that builds only under ThreadSanitizer; # endif; #endif. ``__attribute__((no_sanitize(""thread"")))``; -----------------------------------------------. Some code should not be instrumented by ThreadSanitizer. One may use the; function attribute ``no_sanitize(""thread"")`` to disable instrumentation of plain; (non-atomic) loads/stores in a particular function. ThreadSanitizer still; instruments such functions to avoid false positives and provide meaningful stack; traces. This attribute may not be supported by other compilers, so we suggest; to use it together with ``__has_feature(thread_sanitizer)``. ``__attribute__((disable_sanitizer_instrumentation))``; --------------------------------------------------------. The ``disable_sanitizer_instrumentation`` attribute can be applied to functions; to prevent all kinds of instrumentation. As a result, it may introduce false; positives and incorrect stack traces. Therefore, it should be used with care,; and only if absolutely required; for example for certain code that cannot; tolerate any instrumentation and resulting side-effects. This attribute; overrides ``no_sanitize(""thread"")``. Ignorelist; ----------. ThreadSanitizer supports ``src`` and ``fun`` entity types in; :doc:`SanitizerSpecialCaseList`, that can be used to suppress data race reports; in the specified source files or functions. Unlike functions marked with; ``no_sanitize(""thread"")`` attribu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst:5195,Security,sanitiz,sanitizers,5195,"k traces. Therefore, it should be used with care,; and only if absolutely required; for example for certain code that cannot; tolerate any instrumentation and resulting side-effects. This attribute; overrides ``no_sanitize(""thread"")``. Ignorelist; ----------. ThreadSanitizer supports ``src`` and ``fun`` entity types in; :doc:`SanitizerSpecialCaseList`, that can be used to suppress data race reports; in the specified source files or functions. Unlike functions marked with; ``no_sanitize(""thread"")`` attribute, ignored functions are not instrumented; at all. This can lead to false positives due to missed synchronization via; atomic operations and missed stack frames in reports. Limitations; -----------. * ThreadSanitizer uses more real memory than a native run. At the default; settings the memory overhead is 5x plus 1Mb per each thread. Settings with 3x; (less accurate analysis) and 9x (more accurate analysis) overhead are also; available.; * ThreadSanitizer maps (but does not reserve) a lot of virtual address space.; This means that tools like ``ulimit`` may not work as usually expected.; * Libc/libstdc++ static linking is not supported.; * Non-position-independent executables are not supported. Therefore, the; ``fsanitize=thread`` flag will cause Clang to act as though the ``-fPIE``; flag had been supplied if compiling without ``-fPIC``, and as though the; ``-pie`` flag had been supplied if linking an executable. Current Status; --------------. ThreadSanitizer is in beta stage. It is known to work on large C++ programs; using pthreads, but we do not promise anything (yet). C++11 threading is; supported with llvm libc++. The test suite is integrated into CMake build; and can be run with ``make check-tsan`` command. We are actively working on enhancing the tool --- stay tuned. Any help,; especially in the form of minimized standalone tests is more than welcome. More Information; ----------------; `<https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual>`_; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst:4891,Testability,test,test,4891,"k traces. Therefore, it should be used with care,; and only if absolutely required; for example for certain code that cannot; tolerate any instrumentation and resulting side-effects. This attribute; overrides ``no_sanitize(""thread"")``. Ignorelist; ----------. ThreadSanitizer supports ``src`` and ``fun`` entity types in; :doc:`SanitizerSpecialCaseList`, that can be used to suppress data race reports; in the specified source files or functions. Unlike functions marked with; ``no_sanitize(""thread"")`` attribute, ignored functions are not instrumented; at all. This can lead to false positives due to missed synchronization via; atomic operations and missed stack frames in reports. Limitations; -----------. * ThreadSanitizer uses more real memory than a native run. At the default; settings the memory overhead is 5x plus 1Mb per each thread. Settings with 3x; (less accurate analysis) and 9x (more accurate analysis) overhead are also; available.; * ThreadSanitizer maps (but does not reserve) a lot of virtual address space.; This means that tools like ``ulimit`` may not work as usually expected.; * Libc/libstdc++ static linking is not supported.; * Non-position-independent executables are not supported. Therefore, the; ``fsanitize=thread`` flag will cause Clang to act as though the ``-fPIE``; flag had been supplied if compiling without ``-fPIC``, and as though the; ``-pie`` flag had been supplied if linking an executable. Current Status; --------------. ThreadSanitizer is in beta stage. It is known to work on large C++ programs; using pthreads, but we do not promise anything (yet). C++11 threading is; supported with llvm libc++. The test suite is integrated into CMake build; and can be run with ``make check-tsan`` command. We are actively working on enhancing the tool --- stay tuned. Any help,; especially in the form of minimized standalone tests is more than welcome. More Information; ----------------; `<https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual>`_; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst:5103,Testability,test,tests,5103,"k traces. Therefore, it should be used with care,; and only if absolutely required; for example for certain code that cannot; tolerate any instrumentation and resulting side-effects. This attribute; overrides ``no_sanitize(""thread"")``. Ignorelist; ----------. ThreadSanitizer supports ``src`` and ``fun`` entity types in; :doc:`SanitizerSpecialCaseList`, that can be used to suppress data race reports; in the specified source files or functions. Unlike functions marked with; ``no_sanitize(""thread"")`` attribute, ignored functions are not instrumented; at all. This can lead to false positives due to missed synchronization via; atomic operations and missed stack frames in reports. Limitations; -----------. * ThreadSanitizer uses more real memory than a native run. At the default; settings the memory overhead is 5x plus 1Mb per each thread. Settings with 3x; (less accurate analysis) and 9x (more accurate analysis) overhead are also; available.; * ThreadSanitizer maps (but does not reserve) a lot of virtual address space.; This means that tools like ``ulimit`` may not work as usually expected.; * Libc/libstdc++ static linking is not supported.; * Non-position-independent executables are not supported. Therefore, the; ``fsanitize=thread`` flag will cause Clang to act as though the ``-fPIE``; flag had been supplied if compiling without ``-fPIC``, and as though the; ``-pie`` flag had been supplied if linking an executable. Current Status; --------------. ThreadSanitizer is in beta stage. It is known to work on large C++ programs; using pthreads, but we do not promise anything (yet). C++11 threading is; supported with llvm libc++. The test suite is integrated into CMake build; and can be run with ``make check-tsan`` command. We are actively working on enhancing the tool --- stay tuned. Any help,; especially in the form of minimized standalone tests is more than welcome. More Information; ----------------; `<https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual>`_; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/ThreadSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/ThreadSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:8217,Availability,error,errors,8217," flag.; This is not supported on every platform. Atomics library; ---------------. If your program makes use of atomic operations and the compiler is not able; to lower them all directly to machine instructions (because there either is; no known suitable machine instruction or the operand is not known to be; suitably aligned), a call to a runtime library ``__atomic_*`` function; will be generated. A runtime library containing these atomics functions is; necessary for such programs. compiler-rt (LLVM); ^^^^^^^^^^^^^^^^^^. compiler-rt contains an implementation of an atomics library. libatomic (GNU); ^^^^^^^^^^^^^^^. libgcc_s does not provide an implementation of an atomics library. Instead,; `GCC's libatomic library <https://gcc.gnu.org/wiki/Atomic/GCCMM>`_ can be; used to supply these when using libgcc_s. .. note::. Clang does not currently automatically link against libatomic when using; libgcc_s. You may need to manually add ``-latomic`` to support this; configuration when using non-native atomic operations (if you see link errors; referring to ``__atomic_*`` functions). Unwind library; --------------. The unwind library provides a family of ``_Unwind_*`` functions implementing; the language-neutral stack unwinding portion of the Itanium C++ ABI; (`Level I <https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html#base-abi>`_).; It is a dependency of the C++ ABI library, and sometimes is a dependency; of other runtimes. libunwind (LLVM); ^^^^^^^^^^^^^^^^. LLVM's unwinder library is part of the llvm-project git repository. To; build it, pass ``-DLLVM_ENABLE_RUNTIMES=libunwind`` to the cmake invocation. If using libc++abi, you may need to configure it to use libunwind; rather than libgcc_s by passing ``-DLIBCXXABI_USE_LLVM_UNWINDER=YES``; to ``cmake``. If libc++abi is configured to use some version of; libunwind, that library will be implicitly linked into binaries that; link to libc++abi. libgcc_s (GNU); ^^^^^^^^^^^^^^. libgcc_s has an integrated unwinder, and does not",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:11187,Availability,avail,available,11187," of; `C standard library <https://en.cppreference.com/w/c>`_; implementations. C++ ABI library; ---------------. The C++ ABI library provides an implementation of the library portion of; the Itanium C++ ABI, covering both the; `support functionality in the main Itanium C++ ABI document; <https://itanium-cxx-abi.github.io/cxx-abi/abi.html>`_ and; `Level II of the exception handling support; <https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html#cxx-abi>`_.; References to the functions and objects in this library are implicitly; generated by Clang when compiling C++ code. While it is possible to link C++ code using libstdc++ and code using libc++; together into the same program (so long as you do not attempt to pass C++; standard library objects across the boundary), it is not generally possible; to have more than one C++ ABI library in a program. The version of the C++ ABI library used by Clang will be the one that the; chosen C++ standard library was linked against. Several implementations are; available:. libc++abi (LLVM); ^^^^^^^^^^^^^^^^. `libc++abi <https://libcxxabi.llvm.org/>`_ is LLVM's implementation of this; specification. libsupc++ (GNU); ^^^^^^^^^^^^^^^. libsupc++ is GCC's implementation of this specification. However, this; library is only used when libstdc++ is linked statically. The dynamic; library version of libstdc++ contains a copy of libsupc++. .. note::. Clang does not currently automatically link against libsupc++ when statically; linking libstdc++. You may need to manually add ``-lsupc++`` to support this; configuration when using ``-static`` or ``-static-libstdc++``. libcxxrt (PathScale); ^^^^^^^^^^^^^^^^^^^^. This is another implementation of the Itanium C++ ABI specification.; See `libcxxrt <https://github.com/pathscale/libcxxrt>`_. C++ standard library; --------------------. Clang supports use of either LLVM's libc++ or GCC's libstdc++ implementation; of the `C++ standard library <https://en.cppreference.com/w/cpp>`_. libc++ (LLVM); ^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:744,Deployability,configurat,configurations,744,"===============================; Assembling a Complete Toolchain; ===============================. .. contents::; :local:; :depth: 2. Introduction; ============. Clang is only one component in a complete tool chain for C family; programming languages. In order to assemble a complete toolchain,; additional tools and runtime libraries are required. Clang is designed; to interoperate with existing tools and libraries for its target; platforms, and the LLVM project provides alternatives for a number; of these components. This document describes the required and optional components in a; complete toolchain, where to find them, and the supported versions; and limitations of each option. .. warning::. This document currently describes Clang configurations on POSIX-like; operating systems with the GCC-compatible ``clang`` driver. When; targeting Windows with the MSVC-compatible ``clang-cl`` driver, some; of the details are different. Tools; =====. .. FIXME: Describe DWARF-related tools. A complete compilation of C family programming languages typically; involves the following pipeline of tools, some of which are omitted; in some compilations:. * **Preprocessor**: This performs the actions of the C preprocessor:; expanding #includes and #defines.; The ``-E`` flag instructs Clang to stop after this step. * **Parsing**: This parses and semantically analyzes the source language and; builds a source-level intermediate representation (""AST""), producing a; :ref:`precompiled header (PCH) <usersmanual-precompiled-headers>`,; preamble, or; :doc:`precompiled module file (PCM) <Modules>`,; depending on the input.; The ``-precompile`` flag instructs Clang to stop after this step. This is; the default when the input is a header file. * **IR generation**: This converts the source-level intermediate representation; into an optimizer-specific intermediate representation (IR); for Clang, this; is LLVM IR.; The ``-emit-llvm`` flag instructs Clang to stop after this step. If combined; with ``-S",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:1085,Deployability,pipeline,pipeline,1085,"========================. .. contents::; :local:; :depth: 2. Introduction; ============. Clang is only one component in a complete tool chain for C family; programming languages. In order to assemble a complete toolchain,; additional tools and runtime libraries are required. Clang is designed; to interoperate with existing tools and libraries for its target; platforms, and the LLVM project provides alternatives for a number; of these components. This document describes the required and optional components in a; complete toolchain, where to find them, and the supported versions; and limitations of each option. .. warning::. This document currently describes Clang configurations on POSIX-like; operating systems with the GCC-compatible ``clang`` driver. When; targeting Windows with the MSVC-compatible ``clang-cl`` driver, some; of the details are different. Tools; =====. .. FIXME: Describe DWARF-related tools. A complete compilation of C family programming languages typically; involves the following pipeline of tools, some of which are omitted; in some compilations:. * **Preprocessor**: This performs the actions of the C preprocessor:; expanding #includes and #defines.; The ``-E`` flag instructs Clang to stop after this step. * **Parsing**: This parses and semantically analyzes the source language and; builds a source-level intermediate representation (""AST""), producing a; :ref:`precompiled header (PCH) <usersmanual-precompiled-headers>`,; preamble, or; :doc:`precompiled module file (PCM) <Modules>`,; depending on the input.; The ``-precompile`` flag instructs Clang to stop after this step. This is; the default when the input is a header file. * **IR generation**: This converts the source-level intermediate representation; into an optimizer-specific intermediate representation (IR); for Clang, this; is LLVM IR.; The ``-emit-llvm`` flag instructs Clang to stop after this step. If combined; with ``-S``, Clang will produce textual LLVM IR; otherwise, it will produce; LLVM",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:3944,Deployability,integrat,integrated,3944,"see which commands it would run for the; above steps, without running them. The ``-v`` (verbose) flag will print the; commands in addition to running them. Clang frontend; --------------. The Clang frontend (``clang -cc1``) is used to compile C family languages. The; command-line interface of the frontend is considered to be an implementation; detail, intentionally has no external documentation, and is subject to change; without notice. Language frontends for other languages; --------------------------------------. Clang can be provided with inputs written in non-C-family languages. In such; cases, an external tool will be used to compile the input. The; currently-supported languages are:. * Ada (``-x ada``, ``.ad[bs]``); * Fortran (``-x f95``, ``.f``, ``.f9[05]``, ``.for``, ``.fpp``, case-insensitive); * Java (``-x java``). In each case, GCC will be invoked to compile the input. Assembler; ---------. Clang can either use LLVM's integrated assembler or an external system-specific; tool (for instance, the GNU Assembler on GNU OSes) to produce machine code from; assembly.; By default, Clang uses LLVM's integrated assembler on all targets where it is; supported. If you wish to use the system assembler instead, use the; ``-fno-integrated-as`` option. Linker; ------. Clang can be configured to use one of several different linkers:. * GNU ld; * GNU gold; * LLVM's `lld <https://lld.llvm.org>`_; * MSVC's link.exe. Link-time optimization is natively supported by lld, and supported via; a `linker plugin <https://llvm.org/docs/GoldPlugin.html>`_ when using gold. The default linker varies between targets, and can be overridden via the; ``-fuse-ld=<linker name>`` flag. Runtime libraries; =================. A number of different runtime libraries are required to provide different; layers of support for C family programs. Clang will implicitly link an; appropriate implementation of each runtime library, selected based on; target defaults or explicitly selected by the ``--rtlib=`` ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:4119,Deployability,integrat,integrated,4119,"ddition to running them. Clang frontend; --------------. The Clang frontend (``clang -cc1``) is used to compile C family languages. The; command-line interface of the frontend is considered to be an implementation; detail, intentionally has no external documentation, and is subject to change; without notice. Language frontends for other languages; --------------------------------------. Clang can be provided with inputs written in non-C-family languages. In such; cases, an external tool will be used to compile the input. The; currently-supported languages are:. * Ada (``-x ada``, ``.ad[bs]``); * Fortran (``-x f95``, ``.f``, ``.f9[05]``, ``.for``, ``.fpp``, case-insensitive); * Java (``-x java``). In each case, GCC will be invoked to compile the input. Assembler; ---------. Clang can either use LLVM's integrated assembler or an external system-specific; tool (for instance, the GNU Assembler on GNU OSes) to produce machine code from; assembly.; By default, Clang uses LLVM's integrated assembler on all targets where it is; supported. If you wish to use the system assembler instead, use the; ``-fno-integrated-as`` option. Linker; ------. Clang can be configured to use one of several different linkers:. * GNU ld; * GNU gold; * LLVM's `lld <https://lld.llvm.org>`_; * MSVC's link.exe. Link-time optimization is natively supported by lld, and supported via; a `linker plugin <https://llvm.org/docs/GoldPlugin.html>`_ when using gold. The default linker varies between targets, and can be overridden via the; ``-fuse-ld=<linker name>`` flag. Runtime libraries; =================. A number of different runtime libraries are required to provide different; layers of support for C family programs. Clang will implicitly link an; appropriate implementation of each runtime library, selected based on; target defaults or explicitly selected by the ``--rtlib=`` and ``--stdlib=``; flags. The set of implicitly-linked libraries depend on the language mode. As a; consequence, you should use ``cl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:4244,Deployability,integrat,integrated-as,4244,"`) is used to compile C family languages. The; command-line interface of the frontend is considered to be an implementation; detail, intentionally has no external documentation, and is subject to change; without notice. Language frontends for other languages; --------------------------------------. Clang can be provided with inputs written in non-C-family languages. In such; cases, an external tool will be used to compile the input. The; currently-supported languages are:. * Ada (``-x ada``, ``.ad[bs]``); * Fortran (``-x f95``, ``.f``, ``.f9[05]``, ``.for``, ``.fpp``, case-insensitive); * Java (``-x java``). In each case, GCC will be invoked to compile the input. Assembler; ---------. Clang can either use LLVM's integrated assembler or an external system-specific; tool (for instance, the GNU Assembler on GNU OSes) to produce machine code from; assembly.; By default, Clang uses LLVM's integrated assembler on all targets where it is; supported. If you wish to use the system assembler instead, use the; ``-fno-integrated-as`` option. Linker; ------. Clang can be configured to use one of several different linkers:. * GNU ld; * GNU gold; * LLVM's `lld <https://lld.llvm.org>`_; * MSVC's link.exe. Link-time optimization is natively supported by lld, and supported via; a `linker plugin <https://llvm.org/docs/GoldPlugin.html>`_ when using gold. The default linker varies between targets, and can be overridden via the; ``-fuse-ld=<linker name>`` flag. Runtime libraries; =================. A number of different runtime libraries are required to provide different; layers of support for C family programs. Clang will implicitly link an; appropriate implementation of each runtime library, selected based on; target defaults or explicitly selected by the ``--rtlib=`` and ``--stdlib=``; flags. The set of implicitly-linked libraries depend on the language mode. As a; consequence, you should use ``clang++`` when linking C++ programs in order; to ensure the C++ runtimes are provided. .. no",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:8146,Deployability,configurat,configuration,8146," flag.; This is not supported on every platform. Atomics library; ---------------. If your program makes use of atomic operations and the compiler is not able; to lower them all directly to machine instructions (because there either is; no known suitable machine instruction or the operand is not known to be; suitably aligned), a call to a runtime library ``__atomic_*`` function; will be generated. A runtime library containing these atomics functions is; necessary for such programs. compiler-rt (LLVM); ^^^^^^^^^^^^^^^^^^. compiler-rt contains an implementation of an atomics library. libatomic (GNU); ^^^^^^^^^^^^^^^. libgcc_s does not provide an implementation of an atomics library. Instead,; `GCC's libatomic library <https://gcc.gnu.org/wiki/Atomic/GCCMM>`_ can be; used to supply these when using libgcc_s. .. note::. Clang does not currently automatically link against libatomic when using; libgcc_s. You may need to manually add ``-latomic`` to support this; configuration when using non-native atomic operations (if you see link errors; referring to ``__atomic_*`` functions). Unwind library; --------------. The unwind library provides a family of ``_Unwind_*`` functions implementing; the language-neutral stack unwinding portion of the Itanium C++ ABI; (`Level I <https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html#base-abi>`_).; It is a dependency of the C++ ABI library, and sometimes is a dependency; of other runtimes. libunwind (LLVM); ^^^^^^^^^^^^^^^^. LLVM's unwinder library is part of the llvm-project git repository. To; build it, pass ``-DLLVM_ENABLE_RUNTIMES=libunwind`` to the cmake invocation. If using libc++abi, you may need to configure it to use libunwind; rather than libgcc_s by passing ``-DLIBCXXABI_USE_LLVM_UNWINDER=YES``; to ``cmake``. If libc++abi is configured to use some version of; libunwind, that library will be implicitly linked into binaries that; link to libc++abi. libgcc_s (GNU); ^^^^^^^^^^^^^^. libgcc_s has an integrated unwinder, and does not",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:9142,Deployability,integrat,integrated,9142,"-native atomic operations (if you see link errors; referring to ``__atomic_*`` functions). Unwind library; --------------. The unwind library provides a family of ``_Unwind_*`` functions implementing; the language-neutral stack unwinding portion of the Itanium C++ ABI; (`Level I <https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html#base-abi>`_).; It is a dependency of the C++ ABI library, and sometimes is a dependency; of other runtimes. libunwind (LLVM); ^^^^^^^^^^^^^^^^. LLVM's unwinder library is part of the llvm-project git repository. To; build it, pass ``-DLLVM_ENABLE_RUNTIMES=libunwind`` to the cmake invocation. If using libc++abi, you may need to configure it to use libunwind; rather than libgcc_s by passing ``-DLIBCXXABI_USE_LLVM_UNWINDER=YES``; to ``cmake``. If libc++abi is configured to use some version of; libunwind, that library will be implicitly linked into binaries that; link to libc++abi. libgcc_s (GNU); ^^^^^^^^^^^^^^. libgcc_s has an integrated unwinder, and does not need an external unwind; library to be provided. libunwind (nongnu.org); ^^^^^^^^^^^^^^^^^^^^^^. This is another implementation of the libunwind specification.; See `libunwind (nongnu.org) <https://www.nongnu.org/libunwind>`_. libunwind (PathScale); ^^^^^^^^^^^^^^^^^^^^^. This is another implementation of the libunwind specification.; See `libunwind (pathscale) <https://github.com/pathscale/libunwind>`_. Sanitizer runtime; -----------------. The instrumentation added by Clang's sanitizers (``-fsanitize=...``) implicitly; makes calls to a runtime library, in order to maintain side state about the; execution of the program and to issue diagnostic messages when a problem is; detected. The only supported implementation of these runtimes is provided by LLVM's; compiler-rt, and the relevant portion of that library; (``libclang_rt.<sanitizer>.<arch>.a``); will be implicitly linked when linking with a ``-fsanitize=...`` flag. C standard library; ------------------. Clang supports a wide varie",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:11731,Deployability,configurat,configuration,11731,"n compiling C++ code. While it is possible to link C++ code using libstdc++ and code using libc++; together into the same program (so long as you do not attempt to pass C++; standard library objects across the boundary), it is not generally possible; to have more than one C++ ABI library in a program. The version of the C++ ABI library used by Clang will be the one that the; chosen C++ standard library was linked against. Several implementations are; available:. libc++abi (LLVM); ^^^^^^^^^^^^^^^^. `libc++abi <https://libcxxabi.llvm.org/>`_ is LLVM's implementation of this; specification. libsupc++ (GNU); ^^^^^^^^^^^^^^^. libsupc++ is GCC's implementation of this specification. However, this; library is only used when libstdc++ is linked statically. The dynamic; library version of libstdc++ contains a copy of libsupc++. .. note::. Clang does not currently automatically link against libsupc++ when statically; linking libstdc++. You may need to manually add ``-lsupc++`` to support this; configuration when using ``-static`` or ``-static-libstdc++``. libcxxrt (PathScale); ^^^^^^^^^^^^^^^^^^^^. This is another implementation of the Itanium C++ ABI specification.; See `libcxxrt <https://github.com/pathscale/libcxxrt>`_. C++ standard library; --------------------. Clang supports use of either LLVM's libc++ or GCC's libstdc++ implementation; of the `C++ standard library <https://en.cppreference.com/w/cpp>`_. libc++ (LLVM); ^^^^^^^^^^^^^. `libc++ <https://libcxx.llvm.org/>`_ is LLVM's implementation of the C++; standard library, aimed at being a complete implementation of the C++; standards from C++11 onwards. You can instruct Clang to use libc++ with the ``-stdlib=libc++`` flag. libstdc++ (GNU); ^^^^^^^^^^^^^^^. `libstdc++ <https://gcc.gnu.org/onlinedocs/libstdc++/>`_ is GCC's; implementation of the C++ standard library. Clang supports libstdc++; 4.8.3 (released 2014-05-22) and later. Historically Clang implemented; workarounds for issues discovered in libstdc++, and these a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:12609,Deployability,release,released,12609,"ong as you do not attempt to pass C++; standard library objects across the boundary), it is not generally possible; to have more than one C++ ABI library in a program. The version of the C++ ABI library used by Clang will be the one that the; chosen C++ standard library was linked against. Several implementations are; available:. libc++abi (LLVM); ^^^^^^^^^^^^^^^^. `libc++abi <https://libcxxabi.llvm.org/>`_ is LLVM's implementation of this; specification. libsupc++ (GNU); ^^^^^^^^^^^^^^^. libsupc++ is GCC's implementation of this specification. However, this; library is only used when libstdc++ is linked statically. The dynamic; library version of libstdc++ contains a copy of libsupc++. .. note::. Clang does not currently automatically link against libsupc++ when statically; linking libstdc++. You may need to manually add ``-lsupc++`` to support this; configuration when using ``-static`` or ``-static-libstdc++``. libcxxrt (PathScale); ^^^^^^^^^^^^^^^^^^^^. This is another implementation of the Itanium C++ ABI specification.; See `libcxxrt <https://github.com/pathscale/libcxxrt>`_. C++ standard library; --------------------. Clang supports use of either LLVM's libc++ or GCC's libstdc++ implementation; of the `C++ standard library <https://en.cppreference.com/w/cpp>`_. libc++ (LLVM); ^^^^^^^^^^^^^. `libc++ <https://libcxx.llvm.org/>`_ is LLVM's implementation of the C++; standard library, aimed at being a complete implementation of the C++; standards from C++11 onwards. You can instruct Clang to use libc++ with the ``-stdlib=libc++`` flag. libstdc++ (GNU); ^^^^^^^^^^^^^^^. `libstdc++ <https://gcc.gnu.org/onlinedocs/libstdc++/>`_ is GCC's; implementation of the C++ standard library. Clang supports libstdc++; 4.8.3 (released 2014-05-22) and later. Historically Clang implemented; workarounds for issues discovered in libstdc++, and these are removed; as fixed libstdc++ becomes sufficiently old. You can instruct Clang to use libstdc++ with the ``-stdlib=libstdc++`` flag.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:1597,Integrability,depend,depending,1597,"rovides alternatives for a number; of these components. This document describes the required and optional components in a; complete toolchain, where to find them, and the supported versions; and limitations of each option. .. warning::. This document currently describes Clang configurations on POSIX-like; operating systems with the GCC-compatible ``clang`` driver. When; targeting Windows with the MSVC-compatible ``clang-cl`` driver, some; of the details are different. Tools; =====. .. FIXME: Describe DWARF-related tools. A complete compilation of C family programming languages typically; involves the following pipeline of tools, some of which are omitted; in some compilations:. * **Preprocessor**: This performs the actions of the C preprocessor:; expanding #includes and #defines.; The ``-E`` flag instructs Clang to stop after this step. * **Parsing**: This parses and semantically analyzes the source language and; builds a source-level intermediate representation (""AST""), producing a; :ref:`precompiled header (PCH) <usersmanual-precompiled-headers>`,; preamble, or; :doc:`precompiled module file (PCM) <Modules>`,; depending on the input.; The ``-precompile`` flag instructs Clang to stop after this step. This is; the default when the input is a header file. * **IR generation**: This converts the source-level intermediate representation; into an optimizer-specific intermediate representation (IR); for Clang, this; is LLVM IR.; The ``-emit-llvm`` flag instructs Clang to stop after this step. If combined; with ``-S``, Clang will produce textual LLVM IR; otherwise, it will produce; LLVM IR bitcode. * **Compiler backend**: This converts the intermediate representation; into target-specific assembly code.; The ``-S`` flag instructs Clang to stop after this step. * **Assembler**: This converts target-specific assembly code into; target-specific machine code object files.; The ``-c`` flag instructs Clang to stop after this step. * **Linker**: This combines multiple object files",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:3282,Integrability,interface,interface,3282,"t files.; The ``-c`` flag instructs Clang to stop after this step. * **Linker**: This combines multiple object files into a single image; (either a shared object or an executable). Clang provides all of these pieces other than the linker. When multiple; steps are performed by the same tool, it is common for the steps to be; fused together to avoid creating intermediate files. When given an output of one of the above steps as an input, earlier steps; are skipped (for instance, a ``.s`` file input will be assembled and linked). The Clang driver can be invoked with the ``-###`` flag (this argument will need; to be escaped under most shells) to see which commands it would run for the; above steps, without running them. The ``-v`` (verbose) flag will print the; commands in addition to running them. Clang frontend; --------------. The Clang frontend (``clang -cc1``) is used to compile C family languages. The; command-line interface of the frontend is considered to be an implementation; detail, intentionally has no external documentation, and is subject to change; without notice. Language frontends for other languages; --------------------------------------. Clang can be provided with inputs written in non-C-family languages. In such; cases, an external tool will be used to compile the input. The; currently-supported languages are:. * Ada (``-x ada``, ``.ad[bs]``); * Fortran (``-x f95``, ``.f``, ``.f9[05]``, ``.for``, ``.fpp``, case-insensitive); * Java (``-x java``). In each case, GCC will be invoked to compile the input. Assembler; ---------. Clang can either use LLVM's integrated assembler or an external system-specific; tool (for instance, the GNU Assembler on GNU OSes) to produce machine code from; assembly.; By default, Clang uses LLVM's integrated assembler on all targets where it is; supported. If you wish to use the system assembler instead, use the; ``-fno-integrated-as`` option. Linker; ------. Clang can be configured to use one of several different linkers:. * ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:3944,Integrability,integrat,integrated,3944,"see which commands it would run for the; above steps, without running them. The ``-v`` (verbose) flag will print the; commands in addition to running them. Clang frontend; --------------. The Clang frontend (``clang -cc1``) is used to compile C family languages. The; command-line interface of the frontend is considered to be an implementation; detail, intentionally has no external documentation, and is subject to change; without notice. Language frontends for other languages; --------------------------------------. Clang can be provided with inputs written in non-C-family languages. In such; cases, an external tool will be used to compile the input. The; currently-supported languages are:. * Ada (``-x ada``, ``.ad[bs]``); * Fortran (``-x f95``, ``.f``, ``.f9[05]``, ``.for``, ``.fpp``, case-insensitive); * Java (``-x java``). In each case, GCC will be invoked to compile the input. Assembler; ---------. Clang can either use LLVM's integrated assembler or an external system-specific; tool (for instance, the GNU Assembler on GNU OSes) to produce machine code from; assembly.; By default, Clang uses LLVM's integrated assembler on all targets where it is; supported. If you wish to use the system assembler instead, use the; ``-fno-integrated-as`` option. Linker; ------. Clang can be configured to use one of several different linkers:. * GNU ld; * GNU gold; * LLVM's `lld <https://lld.llvm.org>`_; * MSVC's link.exe. Link-time optimization is natively supported by lld, and supported via; a `linker plugin <https://llvm.org/docs/GoldPlugin.html>`_ when using gold. The default linker varies between targets, and can be overridden via the; ``-fuse-ld=<linker name>`` flag. Runtime libraries; =================. A number of different runtime libraries are required to provide different; layers of support for C family programs. Clang will implicitly link an; appropriate implementation of each runtime library, selected based on; target defaults or explicitly selected by the ``--rtlib=`` ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:4119,Integrability,integrat,integrated,4119,"ddition to running them. Clang frontend; --------------. The Clang frontend (``clang -cc1``) is used to compile C family languages. The; command-line interface of the frontend is considered to be an implementation; detail, intentionally has no external documentation, and is subject to change; without notice. Language frontends for other languages; --------------------------------------. Clang can be provided with inputs written in non-C-family languages. In such; cases, an external tool will be used to compile the input. The; currently-supported languages are:. * Ada (``-x ada``, ``.ad[bs]``); * Fortran (``-x f95``, ``.f``, ``.f9[05]``, ``.for``, ``.fpp``, case-insensitive); * Java (``-x java``). In each case, GCC will be invoked to compile the input. Assembler; ---------. Clang can either use LLVM's integrated assembler or an external system-specific; tool (for instance, the GNU Assembler on GNU OSes) to produce machine code from; assembly.; By default, Clang uses LLVM's integrated assembler on all targets where it is; supported. If you wish to use the system assembler instead, use the; ``-fno-integrated-as`` option. Linker; ------. Clang can be configured to use one of several different linkers:. * GNU ld; * GNU gold; * LLVM's `lld <https://lld.llvm.org>`_; * MSVC's link.exe. Link-time optimization is natively supported by lld, and supported via; a `linker plugin <https://llvm.org/docs/GoldPlugin.html>`_ when using gold. The default linker varies between targets, and can be overridden via the; ``-fuse-ld=<linker name>`` flag. Runtime libraries; =================. A number of different runtime libraries are required to provide different; layers of support for C family programs. Clang will implicitly link an; appropriate implementation of each runtime library, selected based on; target defaults or explicitly selected by the ``--rtlib=`` and ``--stdlib=``; flags. The set of implicitly-linked libraries depend on the language mode. As a; consequence, you should use ``cl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:4244,Integrability,integrat,integrated-as,4244,"`) is used to compile C family languages. The; command-line interface of the frontend is considered to be an implementation; detail, intentionally has no external documentation, and is subject to change; without notice. Language frontends for other languages; --------------------------------------. Clang can be provided with inputs written in non-C-family languages. In such; cases, an external tool will be used to compile the input. The; currently-supported languages are:. * Ada (``-x ada``, ``.ad[bs]``); * Fortran (``-x f95``, ``.f``, ``.f9[05]``, ``.for``, ``.fpp``, case-insensitive); * Java (``-x java``). In each case, GCC will be invoked to compile the input. Assembler; ---------. Clang can either use LLVM's integrated assembler or an external system-specific; tool (for instance, the GNU Assembler on GNU OSes) to produce machine code from; assembly.; By default, Clang uses LLVM's integrated assembler on all targets where it is; supported. If you wish to use the system assembler instead, use the; ``-fno-integrated-as`` option. Linker; ------. Clang can be configured to use one of several different linkers:. * GNU ld; * GNU gold; * LLVM's `lld <https://lld.llvm.org>`_; * MSVC's link.exe. Link-time optimization is natively supported by lld, and supported via; a `linker plugin <https://llvm.org/docs/GoldPlugin.html>`_ when using gold. The default linker varies between targets, and can be overridden via the; ``-fuse-ld=<linker name>`` flag. Runtime libraries; =================. A number of different runtime libraries are required to provide different; layers of support for C family programs. Clang will implicitly link an; appropriate implementation of each runtime library, selected based on; target defaults or explicitly selected by the ``--rtlib=`` and ``--stdlib=``; flags. The set of implicitly-linked libraries depend on the language mode. As a; consequence, you should use ``clang++`` when linking C++ programs in order; to ensure the C++ runtimes are provided. .. no",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:5066,Integrability,depend,depend,5066,"achine code from; assembly.; By default, Clang uses LLVM's integrated assembler on all targets where it is; supported. If you wish to use the system assembler instead, use the; ``-fno-integrated-as`` option. Linker; ------. Clang can be configured to use one of several different linkers:. * GNU ld; * GNU gold; * LLVM's `lld <https://lld.llvm.org>`_; * MSVC's link.exe. Link-time optimization is natively supported by lld, and supported via; a `linker plugin <https://llvm.org/docs/GoldPlugin.html>`_ when using gold. The default linker varies between targets, and can be overridden via the; ``-fuse-ld=<linker name>`` flag. Runtime libraries; =================. A number of different runtime libraries are required to provide different; layers of support for C family programs. Clang will implicitly link an; appropriate implementation of each runtime library, selected based on; target defaults or explicitly selected by the ``--rtlib=`` and ``--stdlib=``; flags. The set of implicitly-linked libraries depend on the language mode. As a; consequence, you should use ``clang++`` when linking C++ programs in order; to ensure the C++ runtimes are provided. .. note::. There may exist other implementations for these components not described; below. Please let us know how well those other implementations work with; Clang so they can be added to this list!. .. FIXME: Describe Objective-C runtime libraries; .. FIXME: Describe profiling runtime library; .. FIXME: Describe cuda/openmp/opencl/... runtime libraries. Compiler runtime; ----------------. The compiler runtime library provides definitions of functions implicitly; invoked by the compiler to support operations not natively supported by; the underlying hardware (for instance, 128-bit integer multiplications),; and where inline expansion of the operation is deemed unsuitable. The default runtime library is target-specific. For targets where GCC is; the dominant compiler, Clang currently defaults to using libgcc_s. On most; other targ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:8532,Integrability,depend,dependency,8532,"rated. A runtime library containing these atomics functions is; necessary for such programs. compiler-rt (LLVM); ^^^^^^^^^^^^^^^^^^. compiler-rt contains an implementation of an atomics library. libatomic (GNU); ^^^^^^^^^^^^^^^. libgcc_s does not provide an implementation of an atomics library. Instead,; `GCC's libatomic library <https://gcc.gnu.org/wiki/Atomic/GCCMM>`_ can be; used to supply these when using libgcc_s. .. note::. Clang does not currently automatically link against libatomic when using; libgcc_s. You may need to manually add ``-latomic`` to support this; configuration when using non-native atomic operations (if you see link errors; referring to ``__atomic_*`` functions). Unwind library; --------------. The unwind library provides a family of ``_Unwind_*`` functions implementing; the language-neutral stack unwinding portion of the Itanium C++ ABI; (`Level I <https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html#base-abi>`_).; It is a dependency of the C++ ABI library, and sometimes is a dependency; of other runtimes. libunwind (LLVM); ^^^^^^^^^^^^^^^^. LLVM's unwinder library is part of the llvm-project git repository. To; build it, pass ``-DLLVM_ENABLE_RUNTIMES=libunwind`` to the cmake invocation. If using libc++abi, you may need to configure it to use libunwind; rather than libgcc_s by passing ``-DLIBCXXABI_USE_LLVM_UNWINDER=YES``; to ``cmake``. If libc++abi is configured to use some version of; libunwind, that library will be implicitly linked into binaries that; link to libc++abi. libgcc_s (GNU); ^^^^^^^^^^^^^^. libgcc_s has an integrated unwinder, and does not need an external unwind; library to be provided. libunwind (nongnu.org); ^^^^^^^^^^^^^^^^^^^^^^. This is another implementation of the libunwind specification.; See `libunwind (nongnu.org) <https://www.nongnu.org/libunwind>`_. libunwind (PathScale); ^^^^^^^^^^^^^^^^^^^^^. This is another implementation of the libunwind specification.; See `libunwind (pathscale) <https://github.com/pathscale",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:8586,Integrability,depend,dependency,8586,"rated. A runtime library containing these atomics functions is; necessary for such programs. compiler-rt (LLVM); ^^^^^^^^^^^^^^^^^^. compiler-rt contains an implementation of an atomics library. libatomic (GNU); ^^^^^^^^^^^^^^^. libgcc_s does not provide an implementation of an atomics library. Instead,; `GCC's libatomic library <https://gcc.gnu.org/wiki/Atomic/GCCMM>`_ can be; used to supply these when using libgcc_s. .. note::. Clang does not currently automatically link against libatomic when using; libgcc_s. You may need to manually add ``-latomic`` to support this; configuration when using non-native atomic operations (if you see link errors; referring to ``__atomic_*`` functions). Unwind library; --------------. The unwind library provides a family of ``_Unwind_*`` functions implementing; the language-neutral stack unwinding portion of the Itanium C++ ABI; (`Level I <https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html#base-abi>`_).; It is a dependency of the C++ ABI library, and sometimes is a dependency; of other runtimes. libunwind (LLVM); ^^^^^^^^^^^^^^^^. LLVM's unwinder library is part of the llvm-project git repository. To; build it, pass ``-DLLVM_ENABLE_RUNTIMES=libunwind`` to the cmake invocation. If using libc++abi, you may need to configure it to use libunwind; rather than libgcc_s by passing ``-DLIBCXXABI_USE_LLVM_UNWINDER=YES``; to ``cmake``. If libc++abi is configured to use some version of; libunwind, that library will be implicitly linked into binaries that; link to libc++abi. libgcc_s (GNU); ^^^^^^^^^^^^^^. libgcc_s has an integrated unwinder, and does not need an external unwind; library to be provided. libunwind (nongnu.org); ^^^^^^^^^^^^^^^^^^^^^^. This is another implementation of the libunwind specification.; See `libunwind (nongnu.org) <https://www.nongnu.org/libunwind>`_. libunwind (PathScale); ^^^^^^^^^^^^^^^^^^^^^. This is another implementation of the libunwind specification.; See `libunwind (pathscale) <https://github.com/pathscale",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:9142,Integrability,integrat,integrated,9142,"-native atomic operations (if you see link errors; referring to ``__atomic_*`` functions). Unwind library; --------------. The unwind library provides a family of ``_Unwind_*`` functions implementing; the language-neutral stack unwinding portion of the Itanium C++ ABI; (`Level I <https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html#base-abi>`_).; It is a dependency of the C++ ABI library, and sometimes is a dependency; of other runtimes. libunwind (LLVM); ^^^^^^^^^^^^^^^^. LLVM's unwinder library is part of the llvm-project git repository. To; build it, pass ``-DLLVM_ENABLE_RUNTIMES=libunwind`` to the cmake invocation. If using libc++abi, you may need to configure it to use libunwind; rather than libgcc_s by passing ``-DLIBCXXABI_USE_LLVM_UNWINDER=YES``; to ``cmake``. If libc++abi is configured to use some version of; libunwind, that library will be implicitly linked into binaries that; link to libc++abi. libgcc_s (GNU); ^^^^^^^^^^^^^^. libgcc_s has an integrated unwinder, and does not need an external unwind; library to be provided. libunwind (nongnu.org); ^^^^^^^^^^^^^^^^^^^^^^. This is another implementation of the libunwind specification.; See `libunwind (nongnu.org) <https://www.nongnu.org/libunwind>`_. libunwind (PathScale); ^^^^^^^^^^^^^^^^^^^^^. This is another implementation of the libunwind specification.; See `libunwind (pathscale) <https://github.com/pathscale/libunwind>`_. Sanitizer runtime; -----------------. The instrumentation added by Clang's sanitizers (``-fsanitize=...``) implicitly; makes calls to a runtime library, in order to maintain side state about the; execution of the program and to issue diagnostic messages when a problem is; detected. The only supported implementation of these runtimes is provided by LLVM's; compiler-rt, and the relevant portion of that library; (``libclang_rt.<sanitizer>.<arch>.a``); will be implicitly linked when linking with a ``-fsanitize=...`` flag. C standard library; ------------------. Clang supports a wide varie",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:9829,Integrability,message,messages,9829," to the cmake invocation. If using libc++abi, you may need to configure it to use libunwind; rather than libgcc_s by passing ``-DLIBCXXABI_USE_LLVM_UNWINDER=YES``; to ``cmake``. If libc++abi is configured to use some version of; libunwind, that library will be implicitly linked into binaries that; link to libc++abi. libgcc_s (GNU); ^^^^^^^^^^^^^^. libgcc_s has an integrated unwinder, and does not need an external unwind; library to be provided. libunwind (nongnu.org); ^^^^^^^^^^^^^^^^^^^^^^. This is another implementation of the libunwind specification.; See `libunwind (nongnu.org) <https://www.nongnu.org/libunwind>`_. libunwind (PathScale); ^^^^^^^^^^^^^^^^^^^^^. This is another implementation of the libunwind specification.; See `libunwind (pathscale) <https://github.com/pathscale/libunwind>`_. Sanitizer runtime; -----------------. The instrumentation added by Clang's sanitizers (``-fsanitize=...``) implicitly; makes calls to a runtime library, in order to maintain side state about the; execution of the program and to issue diagnostic messages when a problem is; detected. The only supported implementation of these runtimes is provided by LLVM's; compiler-rt, and the relevant portion of that library; (``libclang_rt.<sanitizer>.<arch>.a``); will be implicitly linked when linking with a ``-fsanitize=...`` flag. C standard library; ------------------. Clang supports a wide variety of; `C standard library <https://en.cppreference.com/w/c>`_; implementations. C++ ABI library; ---------------. The C++ ABI library provides an implementation of the library portion of; the Itanium C++ ABI, covering both the; `support functionality in the main Itanium C++ ABI document; <https://itanium-cxx-abi.github.io/cxx-abi/abi.html>`_ and; `Level II of the exception handling support; <https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html#cxx-abi>`_.; References to the functions and objects in this library are implicitly; generated by Clang when compiling C++ code. While it is possible to",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:744,Modifiability,config,configurations,744,"===============================; Assembling a Complete Toolchain; ===============================. .. contents::; :local:; :depth: 2. Introduction; ============. Clang is only one component in a complete tool chain for C family; programming languages. In order to assemble a complete toolchain,; additional tools and runtime libraries are required. Clang is designed; to interoperate with existing tools and libraries for its target; platforms, and the LLVM project provides alternatives for a number; of these components. This document describes the required and optional components in a; complete toolchain, where to find them, and the supported versions; and limitations of each option. .. warning::. This document currently describes Clang configurations on POSIX-like; operating systems with the GCC-compatible ``clang`` driver. When; targeting Windows with the MSVC-compatible ``clang-cl`` driver, some; of the details are different. Tools; =====. .. FIXME: Describe DWARF-related tools. A complete compilation of C family programming languages typically; involves the following pipeline of tools, some of which are omitted; in some compilations:. * **Preprocessor**: This performs the actions of the C preprocessor:; expanding #includes and #defines.; The ``-E`` flag instructs Clang to stop after this step. * **Parsing**: This parses and semantically analyzes the source language and; builds a source-level intermediate representation (""AST""), producing a; :ref:`precompiled header (PCH) <usersmanual-precompiled-headers>`,; preamble, or; :doc:`precompiled module file (PCM) <Modules>`,; depending on the input.; The ``-precompile`` flag instructs Clang to stop after this step. This is; the default when the input is a header file. * **IR generation**: This converts the source-level intermediate representation; into an optimizer-specific intermediate representation (IR); for Clang, this; is LLVM IR.; The ``-emit-llvm`` flag instructs Clang to stop after this step. If combined; with ``-S",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:4297,Modifiability,config,configured,4297,"dered to be an implementation; detail, intentionally has no external documentation, and is subject to change; without notice. Language frontends for other languages; --------------------------------------. Clang can be provided with inputs written in non-C-family languages. In such; cases, an external tool will be used to compile the input. The; currently-supported languages are:. * Ada (``-x ada``, ``.ad[bs]``); * Fortran (``-x f95``, ``.f``, ``.f9[05]``, ``.for``, ``.fpp``, case-insensitive); * Java (``-x java``). In each case, GCC will be invoked to compile the input. Assembler; ---------. Clang can either use LLVM's integrated assembler or an external system-specific; tool (for instance, the GNU Assembler on GNU OSes) to produce machine code from; assembly.; By default, Clang uses LLVM's integrated assembler on all targets where it is; supported. If you wish to use the system assembler instead, use the; ``-fno-integrated-as`` option. Linker; ------. Clang can be configured to use one of several different linkers:. * GNU ld; * GNU gold; * LLVM's `lld <https://lld.llvm.org>`_; * MSVC's link.exe. Link-time optimization is natively supported by lld, and supported via; a `linker plugin <https://llvm.org/docs/GoldPlugin.html>`_ when using gold. The default linker varies between targets, and can be overridden via the; ``-fuse-ld=<linker name>`` flag. Runtime libraries; =================. A number of different runtime libraries are required to provide different; layers of support for C family programs. Clang will implicitly link an; appropriate implementation of each runtime library, selected based on; target defaults or explicitly selected by the ``--rtlib=`` and ``--stdlib=``; flags. The set of implicitly-linked libraries depend on the language mode. As a; consequence, you should use ``clang++`` when linking C++ programs in order; to ensure the C++ runtimes are provided. .. note::. There may exist other implementations for these components not described; below. Please",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:4513,Modifiability,plugin,plugin,4513,"--------------------------------------. Clang can be provided with inputs written in non-C-family languages. In such; cases, an external tool will be used to compile the input. The; currently-supported languages are:. * Ada (``-x ada``, ``.ad[bs]``); * Fortran (``-x f95``, ``.f``, ``.f9[05]``, ``.for``, ``.fpp``, case-insensitive); * Java (``-x java``). In each case, GCC will be invoked to compile the input. Assembler; ---------. Clang can either use LLVM's integrated assembler or an external system-specific; tool (for instance, the GNU Assembler on GNU OSes) to produce machine code from; assembly.; By default, Clang uses LLVM's integrated assembler on all targets where it is; supported. If you wish to use the system assembler instead, use the; ``-fno-integrated-as`` option. Linker; ------. Clang can be configured to use one of several different linkers:. * GNU ld; * GNU gold; * LLVM's `lld <https://lld.llvm.org>`_; * MSVC's link.exe. Link-time optimization is natively supported by lld, and supported via; a `linker plugin <https://llvm.org/docs/GoldPlugin.html>`_ when using gold. The default linker varies between targets, and can be overridden via the; ``-fuse-ld=<linker name>`` flag. Runtime libraries; =================. A number of different runtime libraries are required to provide different; layers of support for C family programs. Clang will implicitly link an; appropriate implementation of each runtime library, selected based on; target defaults or explicitly selected by the ``--rtlib=`` and ``--stdlib=``; flags. The set of implicitly-linked libraries depend on the language mode. As a; consequence, you should use ``clang++`` when linking C++ programs in order; to ensure the C++ runtimes are provided. .. note::. There may exist other implementations for these components not described; below. Please let us know how well those other implementations work with; Clang so they can be added to this list!. .. FIXME: Describe Objective-C runtime libraries; .. FIXME: Des",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:4799,Modifiability,layers,layers,4799,"or``, ``.fpp``, case-insensitive); * Java (``-x java``). In each case, GCC will be invoked to compile the input. Assembler; ---------. Clang can either use LLVM's integrated assembler or an external system-specific; tool (for instance, the GNU Assembler on GNU OSes) to produce machine code from; assembly.; By default, Clang uses LLVM's integrated assembler on all targets where it is; supported. If you wish to use the system assembler instead, use the; ``-fno-integrated-as`` option. Linker; ------. Clang can be configured to use one of several different linkers:. * GNU ld; * GNU gold; * LLVM's `lld <https://lld.llvm.org>`_; * MSVC's link.exe. Link-time optimization is natively supported by lld, and supported via; a `linker plugin <https://llvm.org/docs/GoldPlugin.html>`_ when using gold. The default linker varies between targets, and can be overridden via the; ``-fuse-ld=<linker name>`` flag. Runtime libraries; =================. A number of different runtime libraries are required to provide different; layers of support for C family programs. Clang will implicitly link an; appropriate implementation of each runtime library, selected based on; target defaults or explicitly selected by the ``--rtlib=`` and ``--stdlib=``; flags. The set of implicitly-linked libraries depend on the language mode. As a; consequence, you should use ``clang++`` when linking C++ programs in order; to ensure the C++ runtimes are provided. .. note::. There may exist other implementations for these components not described; below. Please let us know how well those other implementations work with; Clang so they can be added to this list!. .. FIXME: Describe Objective-C runtime libraries; .. FIXME: Describe profiling runtime library; .. FIXME: Describe cuda/openmp/opencl/... runtime libraries. Compiler runtime; ----------------. The compiler runtime library provides definitions of functions implicitly; invoked by the compiler to support operations not natively supported by; the underlying hardwa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:6528,Modifiability,config,configure,6528,"ler runtime; ----------------. The compiler runtime library provides definitions of functions implicitly; invoked by the compiler to support operations not natively supported by; the underlying hardware (for instance, 128-bit integer multiplications),; and where inline expansion of the operation is deemed unsuitable. The default runtime library is target-specific. For targets where GCC is; the dominant compiler, Clang currently defaults to using libgcc_s. On most; other targets, compiler-rt is used by default. compiler-rt (LLVM); ^^^^^^^^^^^^^^^^^^. `LLVM's compiler runtime library <https://compiler-rt.llvm.org/>`_ provides a; complete set of runtime library functions containing all functions that; Clang will implicitly call, in ``libclang_rt.builtins.<arch>.a``. You can instruct Clang to use compiler-rt with the ``--rtlib=compiler-rt`` flag.; This is not supported on every platform. If using libc++ and/or libc++abi, you may need to configure them to use; compiler-rt rather than libgcc_s by passing ``-DLIBCXX_USE_COMPILER_RT=YES``; and/or ``-DLIBCXXABI_USE_COMPILER_RT=YES`` to ``cmake``. Otherwise, you; may end up with both runtime libraries linked into your program (this is; typically harmless, but wasteful). libgcc_s (GNU); ^^^^^^^^^^^^^^. `GCC's runtime library <https://gcc.gnu.org/onlinedocs/gccint/Libgcc.html>`_; can be used in place of compiler-rt. However, it lacks several functions; that LLVM may emit references to, particularly when using Clang's; ``__builtin_*_overflow`` family of intrinsics. You can instruct Clang to use libgcc_s with the ``--rtlib=libgcc`` flag.; This is not supported on every platform. Atomics library; ---------------. If your program makes use of atomic operations and the compiler is not able; to lower them all directly to machine instructions (because there either is; no known suitable machine instruction or the operand is not known to be; suitably aligned), a call to a runtime library ``__atomic_*`` function; will be generated. A run",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:8146,Modifiability,config,configuration,8146," flag.; This is not supported on every platform. Atomics library; ---------------. If your program makes use of atomic operations and the compiler is not able; to lower them all directly to machine instructions (because there either is; no known suitable machine instruction or the operand is not known to be; suitably aligned), a call to a runtime library ``__atomic_*`` function; will be generated. A runtime library containing these atomics functions is; necessary for such programs. compiler-rt (LLVM); ^^^^^^^^^^^^^^^^^^. compiler-rt contains an implementation of an atomics library. libatomic (GNU); ^^^^^^^^^^^^^^^. libgcc_s does not provide an implementation of an atomics library. Instead,; `GCC's libatomic library <https://gcc.gnu.org/wiki/Atomic/GCCMM>`_ can be; used to supply these when using libgcc_s. .. note::. Clang does not currently automatically link against libatomic when using; libgcc_s. You may need to manually add ``-latomic`` to support this; configuration when using non-native atomic operations (if you see link errors; referring to ``__atomic_*`` functions). Unwind library; --------------. The unwind library provides a family of ``_Unwind_*`` functions implementing; the language-neutral stack unwinding portion of the Itanium C++ ABI; (`Level I <https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html#base-abi>`_).; It is a dependency of the C++ ABI library, and sometimes is a dependency; of other runtimes. libunwind (LLVM); ^^^^^^^^^^^^^^^^. LLVM's unwinder library is part of the llvm-project git repository. To; build it, pass ``-DLLVM_ENABLE_RUNTIMES=libunwind`` to the cmake invocation. If using libc++abi, you may need to configure it to use libunwind; rather than libgcc_s by passing ``-DLIBCXXABI_USE_LLVM_UNWINDER=YES``; to ``cmake``. If libc++abi is configured to use some version of; libunwind, that library will be implicitly linked into binaries that; link to libc++abi. libgcc_s (GNU); ^^^^^^^^^^^^^^. libgcc_s has an integrated unwinder, and does not",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:8838,Modifiability,config,configure,8838,"CC's libatomic library <https://gcc.gnu.org/wiki/Atomic/GCCMM>`_ can be; used to supply these when using libgcc_s. .. note::. Clang does not currently automatically link against libatomic when using; libgcc_s. You may need to manually add ``-latomic`` to support this; configuration when using non-native atomic operations (if you see link errors; referring to ``__atomic_*`` functions). Unwind library; --------------. The unwind library provides a family of ``_Unwind_*`` functions implementing; the language-neutral stack unwinding portion of the Itanium C++ ABI; (`Level I <https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html#base-abi>`_).; It is a dependency of the C++ ABI library, and sometimes is a dependency; of other runtimes. libunwind (LLVM); ^^^^^^^^^^^^^^^^. LLVM's unwinder library is part of the llvm-project git repository. To; build it, pass ``-DLLVM_ENABLE_RUNTIMES=libunwind`` to the cmake invocation. If using libc++abi, you may need to configure it to use libunwind; rather than libgcc_s by passing ``-DLIBCXXABI_USE_LLVM_UNWINDER=YES``; to ``cmake``. If libc++abi is configured to use some version of; libunwind, that library will be implicitly linked into binaries that; link to libc++abi. libgcc_s (GNU); ^^^^^^^^^^^^^^. libgcc_s has an integrated unwinder, and does not need an external unwind; library to be provided. libunwind (nongnu.org); ^^^^^^^^^^^^^^^^^^^^^^. This is another implementation of the libunwind specification.; See `libunwind (nongnu.org) <https://www.nongnu.org/libunwind>`_. libunwind (PathScale); ^^^^^^^^^^^^^^^^^^^^^. This is another implementation of the libunwind specification.; See `libunwind (pathscale) <https://github.com/pathscale/libunwind>`_. Sanitizer runtime; -----------------. The instrumentation added by Clang's sanitizers (``-fsanitize=...``) implicitly; makes calls to a runtime library, in order to maintain side state about the; execution of the program and to issue diagnostic messages when a problem is; detected. The only s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:8970,Modifiability,config,configured,8970,"ntly automatically link against libatomic when using; libgcc_s. You may need to manually add ``-latomic`` to support this; configuration when using non-native atomic operations (if you see link errors; referring to ``__atomic_*`` functions). Unwind library; --------------. The unwind library provides a family of ``_Unwind_*`` functions implementing; the language-neutral stack unwinding portion of the Itanium C++ ABI; (`Level I <https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html#base-abi>`_).; It is a dependency of the C++ ABI library, and sometimes is a dependency; of other runtimes. libunwind (LLVM); ^^^^^^^^^^^^^^^^. LLVM's unwinder library is part of the llvm-project git repository. To; build it, pass ``-DLLVM_ENABLE_RUNTIMES=libunwind`` to the cmake invocation. If using libc++abi, you may need to configure it to use libunwind; rather than libgcc_s by passing ``-DLIBCXXABI_USE_LLVM_UNWINDER=YES``; to ``cmake``. If libc++abi is configured to use some version of; libunwind, that library will be implicitly linked into binaries that; link to libc++abi. libgcc_s (GNU); ^^^^^^^^^^^^^^. libgcc_s has an integrated unwinder, and does not need an external unwind; library to be provided. libunwind (nongnu.org); ^^^^^^^^^^^^^^^^^^^^^^. This is another implementation of the libunwind specification.; See `libunwind (nongnu.org) <https://www.nongnu.org/libunwind>`_. libunwind (PathScale); ^^^^^^^^^^^^^^^^^^^^^. This is another implementation of the libunwind specification.; See `libunwind (pathscale) <https://github.com/pathscale/libunwind>`_. Sanitizer runtime; -----------------. The instrumentation added by Clang's sanitizers (``-fsanitize=...``) implicitly; makes calls to a runtime library, in order to maintain side state about the; execution of the program and to issue diagnostic messages when a problem is; detected. The only supported implementation of these runtimes is provided by LLVM's; compiler-rt, and the relevant portion of that library; (``libclang_rt.<sanitizer>",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:11731,Modifiability,config,configuration,11731,"n compiling C++ code. While it is possible to link C++ code using libstdc++ and code using libc++; together into the same program (so long as you do not attempt to pass C++; standard library objects across the boundary), it is not generally possible; to have more than one C++ ABI library in a program. The version of the C++ ABI library used by Clang will be the one that the; chosen C++ standard library was linked against. Several implementations are; available:. libc++abi (LLVM); ^^^^^^^^^^^^^^^^. `libc++abi <https://libcxxabi.llvm.org/>`_ is LLVM's implementation of this; specification. libsupc++ (GNU); ^^^^^^^^^^^^^^^. libsupc++ is GCC's implementation of this specification. However, this; library is only used when libstdc++ is linked statically. The dynamic; library version of libstdc++ contains a copy of libsupc++. .. note::. Clang does not currently automatically link against libsupc++ when statically; linking libstdc++. You may need to manually add ``-lsupc++`` to support this; configuration when using ``-static`` or ``-static-libstdc++``. libcxxrt (PathScale); ^^^^^^^^^^^^^^^^^^^^. This is another implementation of the Itanium C++ ABI specification.; See `libcxxrt <https://github.com/pathscale/libcxxrt>`_. C++ standard library; --------------------. Clang supports use of either LLVM's libc++ or GCC's libstdc++ implementation; of the `C++ standard library <https://en.cppreference.com/w/cpp>`_. libc++ (LLVM); ^^^^^^^^^^^^^. `libc++ <https://libcxx.llvm.org/>`_ is LLVM's implementation of the C++; standard library, aimed at being a complete implementation of the C++; standards from C++11 onwards. You can instruct Clang to use libc++ with the ``-stdlib=libc++`` flag. libstdc++ (GNU); ^^^^^^^^^^^^^^^. `libstdc++ <https://gcc.gnu.org/onlinedocs/libstdc++/>`_ is GCC's; implementation of the C++ standard library. Clang supports libstdc++; 4.8.3 (released 2014-05-22) and later. Historically Clang implemented; workarounds for issues discovered in libstdc++, and these a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:1179,Performance,perform,performs,1179,"ool chain for C family; programming languages. In order to assemble a complete toolchain,; additional tools and runtime libraries are required. Clang is designed; to interoperate with existing tools and libraries for its target; platforms, and the LLVM project provides alternatives for a number; of these components. This document describes the required and optional components in a; complete toolchain, where to find them, and the supported versions; and limitations of each option. .. warning::. This document currently describes Clang configurations on POSIX-like; operating systems with the GCC-compatible ``clang`` driver. When; targeting Windows with the MSVC-compatible ``clang-cl`` driver, some; of the details are different. Tools; =====. .. FIXME: Describe DWARF-related tools. A complete compilation of C family programming languages typically; involves the following pipeline of tools, some of which are omitted; in some compilations:. * **Preprocessor**: This performs the actions of the C preprocessor:; expanding #includes and #defines.; The ``-E`` flag instructs Clang to stop after this step. * **Parsing**: This parses and semantically analyzes the source language and; builds a source-level intermediate representation (""AST""), producing a; :ref:`precompiled header (PCH) <usersmanual-precompiled-headers>`,; preamble, or; :doc:`precompiled module file (PCM) <Modules>`,; depending on the input.; The ``-precompile`` flag instructs Clang to stop after this step. This is; the default when the input is a header file. * **IR generation**: This converts the source-level intermediate representation; into an optimizer-specific intermediate representation (IR); for Clang, this; is LLVM IR.; The ``-emit-llvm`` flag instructs Clang to stop after this step. If combined; with ``-S``, Clang will produce textual LLVM IR; otherwise, it will produce; LLVM IR bitcode. * **Compiler backend**: This converts the intermediate representation; into target-specific assembly code.; The ``-S`` ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:1831,Performance,optimiz,optimizer-specific,1831,"driver. When; targeting Windows with the MSVC-compatible ``clang-cl`` driver, some; of the details are different. Tools; =====. .. FIXME: Describe DWARF-related tools. A complete compilation of C family programming languages typically; involves the following pipeline of tools, some of which are omitted; in some compilations:. * **Preprocessor**: This performs the actions of the C preprocessor:; expanding #includes and #defines.; The ``-E`` flag instructs Clang to stop after this step. * **Parsing**: This parses and semantically analyzes the source language and; builds a source-level intermediate representation (""AST""), producing a; :ref:`precompiled header (PCH) <usersmanual-precompiled-headers>`,; preamble, or; :doc:`precompiled module file (PCM) <Modules>`,; depending on the input.; The ``-precompile`` flag instructs Clang to stop after this step. This is; the default when the input is a header file. * **IR generation**: This converts the source-level intermediate representation; into an optimizer-specific intermediate representation (IR); for Clang, this; is LLVM IR.; The ``-emit-llvm`` flag instructs Clang to stop after this step. If combined; with ``-S``, Clang will produce textual LLVM IR; otherwise, it will produce; LLVM IR bitcode. * **Compiler backend**: This converts the intermediate representation; into target-specific assembly code.; The ``-S`` flag instructs Clang to stop after this step. * **Assembler**: This converts target-specific assembly code into; target-specific machine code object files.; The ``-c`` flag instructs Clang to stop after this step. * **Linker**: This combines multiple object files into a single image; (either a shared object or an executable). Clang provides all of these pieces other than the linker. When multiple; steps are performed by the same tool, it is common for the steps to be; fused together to avoid creating intermediate files. When given an output of one of the above steps as an input, earlier steps; are skipped (for inst",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:2616,Performance,perform,performed,2616,"ng to stop after this step. This is; the default when the input is a header file. * **IR generation**: This converts the source-level intermediate representation; into an optimizer-specific intermediate representation (IR); for Clang, this; is LLVM IR.; The ``-emit-llvm`` flag instructs Clang to stop after this step. If combined; with ``-S``, Clang will produce textual LLVM IR; otherwise, it will produce; LLVM IR bitcode. * **Compiler backend**: This converts the intermediate representation; into target-specific assembly code.; The ``-S`` flag instructs Clang to stop after this step. * **Assembler**: This converts target-specific assembly code into; target-specific machine code object files.; The ``-c`` flag instructs Clang to stop after this step. * **Linker**: This combines multiple object files into a single image; (either a shared object or an executable). Clang provides all of these pieces other than the linker. When multiple; steps are performed by the same tool, it is common for the steps to be; fused together to avoid creating intermediate files. When given an output of one of the above steps as an input, earlier steps; are skipped (for instance, a ``.s`` file input will be assembled and linked). The Clang driver can be invoked with the ``-###`` flag (this argument will need; to be escaped under most shells) to see which commands it would run for the; above steps, without running them. The ``-v`` (verbose) flag will print the; commands in addition to running them. Clang frontend; --------------. The Clang frontend (``clang -cc1``) is used to compile C family languages. The; command-line interface of the frontend is considered to be an implementation; detail, intentionally has no external documentation, and is subject to change; without notice. Language frontends for other languages; --------------------------------------. Clang can be provided with inputs written in non-C-family languages. In such; cases, an external tool will be used to compile the input. T",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:4441,Performance,optimiz,optimization,4441,"--------------------------------------. Clang can be provided with inputs written in non-C-family languages. In such; cases, an external tool will be used to compile the input. The; currently-supported languages are:. * Ada (``-x ada``, ``.ad[bs]``); * Fortran (``-x f95``, ``.f``, ``.f9[05]``, ``.for``, ``.fpp``, case-insensitive); * Java (``-x java``). In each case, GCC will be invoked to compile the input. Assembler; ---------. Clang can either use LLVM's integrated assembler or an external system-specific; tool (for instance, the GNU Assembler on GNU OSes) to produce machine code from; assembly.; By default, Clang uses LLVM's integrated assembler on all targets where it is; supported. If you wish to use the system assembler instead, use the; ``-fno-integrated-as`` option. Linker; ------. Clang can be configured to use one of several different linkers:. * GNU ld; * GNU gold; * LLVM's `lld <https://lld.llvm.org>`_; * MSVC's link.exe. Link-time optimization is natively supported by lld, and supported via; a `linker plugin <https://llvm.org/docs/GoldPlugin.html>`_ when using gold. The default linker varies between targets, and can be overridden via the; ``-fuse-ld=<linker name>`` flag. Runtime libraries; =================. A number of different runtime libraries are required to provide different; layers of support for C family programs. Clang will implicitly link an; appropriate implementation of each runtime library, selected based on; target defaults or explicitly selected by the ``--rtlib=`` and ``--stdlib=``; flags. The set of implicitly-linked libraries depend on the language mode. As a; consequence, you should use ``clang++`` when linking C++ programs in order; to ensure the C++ runtimes are provided. .. note::. There may exist other implementations for these components not described; below. Please let us know how well those other implementations work with; Clang so they can be added to this list!. .. FIXME: Describe Objective-C runtime libraries; .. FIXME: Des",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:2696,Safety,avoid,avoid,2696,"ng to stop after this step. This is; the default when the input is a header file. * **IR generation**: This converts the source-level intermediate representation; into an optimizer-specific intermediate representation (IR); for Clang, this; is LLVM IR.; The ``-emit-llvm`` flag instructs Clang to stop after this step. If combined; with ``-S``, Clang will produce textual LLVM IR; otherwise, it will produce; LLVM IR bitcode. * **Compiler backend**: This converts the intermediate representation; into target-specific assembly code.; The ``-S`` flag instructs Clang to stop after this step. * **Assembler**: This converts target-specific assembly code into; target-specific machine code object files.; The ``-c`` flag instructs Clang to stop after this step. * **Linker**: This combines multiple object files into a single image; (either a shared object or an executable). Clang provides all of these pieces other than the linker. When multiple; steps are performed by the same tool, it is common for the steps to be; fused together to avoid creating intermediate files. When given an output of one of the above steps as an input, earlier steps; are skipped (for instance, a ``.s`` file input will be assembled and linked). The Clang driver can be invoked with the ``-###`` flag (this argument will need; to be escaped under most shells) to see which commands it would run for the; above steps, without running them. The ``-v`` (verbose) flag will print the; commands in addition to running them. Clang frontend; --------------. The Clang frontend (``clang -cc1``) is used to compile C family languages. The; command-line interface of the frontend is considered to be an implementation; detail, intentionally has no external documentation, and is subject to change; without notice. Language frontends for other languages; --------------------------------------. Clang can be provided with inputs written in non-C-family languages. In such; cases, an external tool will be used to compile the input. T",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:9857,Safety,detect,detected,9857," to the cmake invocation. If using libc++abi, you may need to configure it to use libunwind; rather than libgcc_s by passing ``-DLIBCXXABI_USE_LLVM_UNWINDER=YES``; to ``cmake``. If libc++abi is configured to use some version of; libunwind, that library will be implicitly linked into binaries that; link to libc++abi. libgcc_s (GNU); ^^^^^^^^^^^^^^. libgcc_s has an integrated unwinder, and does not need an external unwind; library to be provided. libunwind (nongnu.org); ^^^^^^^^^^^^^^^^^^^^^^. This is another implementation of the libunwind specification.; See `libunwind (nongnu.org) <https://www.nongnu.org/libunwind>`_. libunwind (PathScale); ^^^^^^^^^^^^^^^^^^^^^. This is another implementation of the libunwind specification.; See `libunwind (pathscale) <https://github.com/pathscale/libunwind>`_. Sanitizer runtime; -----------------. The instrumentation added by Clang's sanitizers (``-fsanitize=...``) implicitly; makes calls to a runtime library, in order to maintain side state about the; execution of the program and to issue diagnostic messages when a problem is; detected. The only supported implementation of these runtimes is provided by LLVM's; compiler-rt, and the relevant portion of that library; (``libclang_rt.<sanitizer>.<arch>.a``); will be implicitly linked when linking with a ``-fsanitize=...`` flag. C standard library; ------------------. Clang supports a wide variety of; `C standard library <https://en.cppreference.com/w/c>`_; implementations. C++ ABI library; ---------------. The C++ ABI library provides an implementation of the library portion of; the Itanium C++ ABI, covering both the; `support functionality in the main Itanium C++ ABI document; <https://itanium-cxx-abi.github.io/cxx-abi/abi.html>`_ and; `Level II of the exception handling support; <https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html#cxx-abi>`_.; References to the functions and objects in this library are implicitly; generated by Clang when compiling C++ code. While it is possible to",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:9659,Security,sanitiz,sanitizers,9659,"LLVM's unwinder library is part of the llvm-project git repository. To; build it, pass ``-DLLVM_ENABLE_RUNTIMES=libunwind`` to the cmake invocation. If using libc++abi, you may need to configure it to use libunwind; rather than libgcc_s by passing ``-DLIBCXXABI_USE_LLVM_UNWINDER=YES``; to ``cmake``. If libc++abi is configured to use some version of; libunwind, that library will be implicitly linked into binaries that; link to libc++abi. libgcc_s (GNU); ^^^^^^^^^^^^^^. libgcc_s has an integrated unwinder, and does not need an external unwind; library to be provided. libunwind (nongnu.org); ^^^^^^^^^^^^^^^^^^^^^^. This is another implementation of the libunwind specification.; See `libunwind (nongnu.org) <https://www.nongnu.org/libunwind>`_. libunwind (PathScale); ^^^^^^^^^^^^^^^^^^^^^. This is another implementation of the libunwind specification.; See `libunwind (pathscale) <https://github.com/pathscale/libunwind>`_. Sanitizer runtime; -----------------. The instrumentation added by Clang's sanitizers (``-fsanitize=...``) implicitly; makes calls to a runtime library, in order to maintain side state about the; execution of the program and to issue diagnostic messages when a problem is; detected. The only supported implementation of these runtimes is provided by LLVM's; compiler-rt, and the relevant portion of that library; (``libclang_rt.<sanitizer>.<arch>.a``); will be implicitly linked when linking with a ``-fsanitize=...`` flag. C standard library; ------------------. Clang supports a wide variety of; `C standard library <https://en.cppreference.com/w/c>`_; implementations. C++ ABI library; ---------------. The C++ ABI library provides an implementation of the library portion of; the Itanium C++ ABI, covering both the; `support functionality in the main Itanium C++ ABI document; <https://itanium-cxx-abi.github.io/cxx-abi/abi.html>`_ and; `Level II of the exception handling support; <https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html#cxx-abi>`_.; References to t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst:10013,Security,sanitiz,sanitizer,10013,"at library will be implicitly linked into binaries that; link to libc++abi. libgcc_s (GNU); ^^^^^^^^^^^^^^. libgcc_s has an integrated unwinder, and does not need an external unwind; library to be provided. libunwind (nongnu.org); ^^^^^^^^^^^^^^^^^^^^^^. This is another implementation of the libunwind specification.; See `libunwind (nongnu.org) <https://www.nongnu.org/libunwind>`_. libunwind (PathScale); ^^^^^^^^^^^^^^^^^^^^^. This is another implementation of the libunwind specification.; See `libunwind (pathscale) <https://github.com/pathscale/libunwind>`_. Sanitizer runtime; -----------------. The instrumentation added by Clang's sanitizers (``-fsanitize=...``) implicitly; makes calls to a runtime library, in order to maintain side state about the; execution of the program and to issue diagnostic messages when a problem is; detected. The only supported implementation of these runtimes is provided by LLVM's; compiler-rt, and the relevant portion of that library; (``libclang_rt.<sanitizer>.<arch>.a``); will be implicitly linked when linking with a ``-fsanitize=...`` flag. C standard library; ------------------. Clang supports a wide variety of; `C standard library <https://en.cppreference.com/w/c>`_; implementations. C++ ABI library; ---------------. The C++ ABI library provides an implementation of the library portion of; the Itanium C++ ABI, covering both the; `support functionality in the main Itanium C++ ABI document; <https://itanium-cxx-abi.github.io/cxx-abi/abi.html>`_ and; `Level II of the exception handling support; <https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html#cxx-abi>`_.; References to the functions and objects in this library are implicitly; generated by Clang when compiling C++ code. While it is possible to link C++ code using libstdc++ and code using libc++; together into the same program (so long as you do not attempt to pass C++; standard library objects across the boundary), it is not generally possible; to have more than one C++ ABI libra",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Toolchain.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Toolchain.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst:1484,Availability,error,errors,1484,"n doubt LibClang is probably the interface; you want to use. Consider the other interfaces only when you have a good; reason not to use LibClang. Canonical examples of when to use LibClang:. * Xcode; * Clang Python Bindings. Use LibClang when you...:. * want to interface with clang from other languages than C++; * need a stable interface that takes care to be backwards compatible; * want powerful high-level abstractions, like iterating through an AST with a; cursor, and don't want to learn all the nitty gritty details of Clang's AST. Do not use LibClang when you...:. * want full control over the Clang AST. Clang Plugins; -------------. :doc:`Clang Plugins <ClangPlugins>` allow you to run additional actions on the; AST as part of a compilation. Plugins are dynamic libraries that are loaded at; runtime by the compiler, and they're easy to integrate into your build; environment. Canonical examples of when to use Clang Plugins:. * special lint-style warnings or errors for your project; * creating additional build artifacts from a single compile step. Use Clang Plugins when you...:. * need your tool to rerun if any of the dependencies change; * want your tool to make or break a build; * need full control over the Clang AST. Do not use Clang Plugins when you...:. * want to run tools outside of your build environment; * want full control on how Clang is set up, including mapping of in-memory; virtual files; * need to run over a specific subset of files in your project which is not; necessarily related to any changes which would trigger rebuilds. LibTooling; ----------. :doc:`LibTooling <LibTooling>` is a C++ interface aimed at writing standalone; tools, as well as integrating into services that run clang tools. Canonical; examples of when to use LibTooling:. * a simple syntax checker; * refactoring tools. Use LibTooling when you...:. * want to run tools over a single file, or a specific subset of files,; independently of the build system; * want full control over the Clang",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Tooling.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst:3278,Availability,error,errors,3278,"pecial lint-style warnings or errors for your project; * creating additional build artifacts from a single compile step. Use Clang Plugins when you...:. * need your tool to rerun if any of the dependencies change; * want your tool to make or break a build; * need full control over the Clang AST. Do not use Clang Plugins when you...:. * want to run tools outside of your build environment; * want full control on how Clang is set up, including mapping of in-memory; virtual files; * need to run over a specific subset of files in your project which is not; necessarily related to any changes which would trigger rebuilds. LibTooling; ----------. :doc:`LibTooling <LibTooling>` is a C++ interface aimed at writing standalone; tools, as well as integrating into services that run clang tools. Canonical; examples of when to use LibTooling:. * a simple syntax checker; * refactoring tools. Use LibTooling when you...:. * want to run tools over a single file, or a specific subset of files,; independently of the build system; * want full control over the Clang AST; * want to share code with Clang Plugins. Do not use LibTooling when you...:. * want to run as part of the build triggered by dependency changes; * want a stable interface so you don't need to change your code when the AST API; changes; * want high level abstractions like cursors and code completion out of the box; * do not want to write your tools in C++. :doc:`Clang tools <ClangTools>` are a collection of specific developer tools; built on top of the LibTooling infrastructure as part of the Clang project.; They are targeted at automating and improving core development activities of; C/C++ developers. Examples of tools we are building or planning as part of the Clang project:. * Syntax checking (:program:`clang-check`); * Automatic fixing of compile errors (:program:`clang-fixit`); * Automatic code formatting (:program:`clang-format`); * Migration tools for new features in new language standards; * Core refactoring tools. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Tooling.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst:1361,Deployability,integrat,integrate,1361,"write clang tools, and their pros and cons. LibClang; --------. `LibClang <https://clang.llvm.org/doxygen/group__CINDEX.html>`_ is a stable high; level C interface to clang. When in doubt LibClang is probably the interface; you want to use. Consider the other interfaces only when you have a good; reason not to use LibClang. Canonical examples of when to use LibClang:. * Xcode; * Clang Python Bindings. Use LibClang when you...:. * want to interface with clang from other languages than C++; * need a stable interface that takes care to be backwards compatible; * want powerful high-level abstractions, like iterating through an AST with a; cursor, and don't want to learn all the nitty gritty details of Clang's AST. Do not use LibClang when you...:. * want full control over the Clang AST. Clang Plugins; -------------. :doc:`Clang Plugins <ClangPlugins>` allow you to run additional actions on the; AST as part of a compilation. Plugins are dynamic libraries that are loaded at; runtime by the compiler, and they're easy to integrate into your build; environment. Canonical examples of when to use Clang Plugins:. * special lint-style warnings or errors for your project; * creating additional build artifacts from a single compile step. Use Clang Plugins when you...:. * need your tool to rerun if any of the dependencies change; * want your tool to make or break a build; * need full control over the Clang AST. Do not use Clang Plugins when you...:. * want to run tools outside of your build environment; * want full control on how Clang is set up, including mapping of in-memory; virtual files; * need to run over a specific subset of files in your project which is not; necessarily related to any changes which would trigger rebuilds. LibTooling; ----------. :doc:`LibTooling <LibTooling>` is a C++ interface aimed at writing standalone; tools, as well as integrating into services that run clang tools. Canonical; examples of when to use LibTooling:. * a simple syntax checker; * refactorin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Tooling.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst:2198,Deployability,integrat,integrating,2198,"ins <ClangPlugins>` allow you to run additional actions on the; AST as part of a compilation. Plugins are dynamic libraries that are loaded at; runtime by the compiler, and they're easy to integrate into your build; environment. Canonical examples of when to use Clang Plugins:. * special lint-style warnings or errors for your project; * creating additional build artifacts from a single compile step. Use Clang Plugins when you...:. * need your tool to rerun if any of the dependencies change; * want your tool to make or break a build; * need full control over the Clang AST. Do not use Clang Plugins when you...:. * want to run tools outside of your build environment; * want full control on how Clang is set up, including mapping of in-memory; virtual files; * need to run over a specific subset of files in your project which is not; necessarily related to any changes which would trigger rebuilds. LibTooling; ----------. :doc:`LibTooling <LibTooling>` is a C++ interface aimed at writing standalone; tools, as well as integrating into services that run clang tools. Canonical; examples of when to use LibTooling:. * a simple syntax checker; * refactoring tools. Use LibTooling when you...:. * want to run tools over a single file, or a specific subset of files,; independently of the build system; * want full control over the Clang AST; * want to share code with Clang Plugins. Do not use LibTooling when you...:. * want to run as part of the build triggered by dependency changes; * want a stable interface so you don't need to change your code when the AST API; changes; * want high level abstractions like cursors and code completion out of the box; * do not want to write your tools in C++. :doc:`Clang tools <ClangTools>` are a collection of specific developer tools; built on top of the LibTooling infrastructure as part of the Clang project.; They are targeted at automating and improving core development activities of; C/C++ developers. Examples of tools we are building or planning ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Tooling.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst:903,Energy Efficiency,power,powerful,903,"=================================================; Choosing the Right Interface for Your Application; =================================================. Clang provides infrastructure to write tools that need syntactic and semantic; information about a program. This document will give a short introduction of; the different ways to write clang tools, and their pros and cons. LibClang; --------. `LibClang <https://clang.llvm.org/doxygen/group__CINDEX.html>`_ is a stable high; level C interface to clang. When in doubt LibClang is probably the interface; you want to use. Consider the other interfaces only when you have a good; reason not to use LibClang. Canonical examples of when to use LibClang:. * Xcode; * Clang Python Bindings. Use LibClang when you...:. * want to interface with clang from other languages than C++; * need a stable interface that takes care to be backwards compatible; * want powerful high-level abstractions, like iterating through an AST with a; cursor, and don't want to learn all the nitty gritty details of Clang's AST. Do not use LibClang when you...:. * want full control over the Clang AST. Clang Plugins; -------------. :doc:`Clang Plugins <ClangPlugins>` allow you to run additional actions on the; AST as part of a compilation. Plugins are dynamic libraries that are loaded at; runtime by the compiler, and they're easy to integrate into your build; environment. Canonical examples of when to use Clang Plugins:. * special lint-style warnings or errors for your project; * creating additional build artifacts from a single compile step. Use Clang Plugins when you...:. * need your tool to rerun if any of the dependencies change; * want your tool to make or break a build; * need full control over the Clang AST. Do not use Clang Plugins when you...:. * want to run tools outside of your build environment; * want full control on how Clang is set up, including mapping of in-memory; virtual files; * need to run over a specific subset of files in your project whi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Tooling.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst:486,Integrability,interface,interface,486,"=================================================; Choosing the Right Interface for Your Application; =================================================. Clang provides infrastructure to write tools that need syntactic and semantic; information about a program. This document will give a short introduction of; the different ways to write clang tools, and their pros and cons. LibClang; --------. `LibClang <https://clang.llvm.org/doxygen/group__CINDEX.html>`_ is a stable high; level C interface to clang. When in doubt LibClang is probably the interface; you want to use. Consider the other interfaces only when you have a good; reason not to use LibClang. Canonical examples of when to use LibClang:. * Xcode; * Clang Python Bindings. Use LibClang when you...:. * want to interface with clang from other languages than C++; * need a stable interface that takes care to be backwards compatible; * want powerful high-level abstractions, like iterating through an AST with a; cursor, and don't want to learn all the nitty gritty details of Clang's AST. Do not use LibClang when you...:. * want full control over the Clang AST. Clang Plugins; -------------. :doc:`Clang Plugins <ClangPlugins>` allow you to run additional actions on the; AST as part of a compilation. Plugins are dynamic libraries that are loaded at; runtime by the compiler, and they're easy to integrate into your build; environment. Canonical examples of when to use Clang Plugins:. * special lint-style warnings or errors for your project; * creating additional build artifacts from a single compile step. Use Clang Plugins when you...:. * need your tool to rerun if any of the dependencies change; * want your tool to make or break a build; * need full control over the Clang AST. Do not use Clang Plugins when you...:. * want to run tools outside of your build environment; * want full control on how Clang is set up, including mapping of in-memory; virtual files; * need to run over a specific subset of files in your project whi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Tooling.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst:545,Integrability,interface,interface,545,"=================================================; Choosing the Right Interface for Your Application; =================================================. Clang provides infrastructure to write tools that need syntactic and semantic; information about a program. This document will give a short introduction of; the different ways to write clang tools, and their pros and cons. LibClang; --------. `LibClang <https://clang.llvm.org/doxygen/group__CINDEX.html>`_ is a stable high; level C interface to clang. When in doubt LibClang is probably the interface; you want to use. Consider the other interfaces only when you have a good; reason not to use LibClang. Canonical examples of when to use LibClang:. * Xcode; * Clang Python Bindings. Use LibClang when you...:. * want to interface with clang from other languages than C++; * need a stable interface that takes care to be backwards compatible; * want powerful high-level abstractions, like iterating through an AST with a; cursor, and don't want to learn all the nitty gritty details of Clang's AST. Do not use LibClang when you...:. * want full control over the Clang AST. Clang Plugins; -------------. :doc:`Clang Plugins <ClangPlugins>` allow you to run additional actions on the; AST as part of a compilation. Plugins are dynamic libraries that are loaded at; runtime by the compiler, and they're easy to integrate into your build; environment. Canonical examples of when to use Clang Plugins:. * special lint-style warnings or errors for your project; * creating additional build artifacts from a single compile step. Use Clang Plugins when you...:. * need your tool to rerun if any of the dependencies change; * want your tool to make or break a build; * need full control over the Clang AST. Do not use Clang Plugins when you...:. * want to run tools outside of your build environment; * want full control on how Clang is set up, including mapping of in-memory; virtual files; * need to run over a specific subset of files in your project whi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Tooling.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst:592,Integrability,interface,interfaces,592,"=================================================; Choosing the Right Interface for Your Application; =================================================. Clang provides infrastructure to write tools that need syntactic and semantic; information about a program. This document will give a short introduction of; the different ways to write clang tools, and their pros and cons. LibClang; --------. `LibClang <https://clang.llvm.org/doxygen/group__CINDEX.html>`_ is a stable high; level C interface to clang. When in doubt LibClang is probably the interface; you want to use. Consider the other interfaces only when you have a good; reason not to use LibClang. Canonical examples of when to use LibClang:. * Xcode; * Clang Python Bindings. Use LibClang when you...:. * want to interface with clang from other languages than C++; * need a stable interface that takes care to be backwards compatible; * want powerful high-level abstractions, like iterating through an AST with a; cursor, and don't want to learn all the nitty gritty details of Clang's AST. Do not use LibClang when you...:. * want full control over the Clang AST. Clang Plugins; -------------. :doc:`Clang Plugins <ClangPlugins>` allow you to run additional actions on the; AST as part of a compilation. Plugins are dynamic libraries that are loaded at; runtime by the compiler, and they're easy to integrate into your build; environment. Canonical examples of when to use Clang Plugins:. * special lint-style warnings or errors for your project; * creating additional build artifacts from a single compile step. Use Clang Plugins when you...:. * need your tool to rerun if any of the dependencies change; * want your tool to make or break a build; * need full control over the Clang AST. Do not use Clang Plugins when you...:. * want to run tools outside of your build environment; * want full control on how Clang is set up, including mapping of in-memory; virtual files; * need to run over a specific subset of files in your project whi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Tooling.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst:774,Integrability,interface,interface,774,"=================================================; Choosing the Right Interface for Your Application; =================================================. Clang provides infrastructure to write tools that need syntactic and semantic; information about a program. This document will give a short introduction of; the different ways to write clang tools, and their pros and cons. LibClang; --------. `LibClang <https://clang.llvm.org/doxygen/group__CINDEX.html>`_ is a stable high; level C interface to clang. When in doubt LibClang is probably the interface; you want to use. Consider the other interfaces only when you have a good; reason not to use LibClang. Canonical examples of when to use LibClang:. * Xcode; * Clang Python Bindings. Use LibClang when you...:. * want to interface with clang from other languages than C++; * need a stable interface that takes care to be backwards compatible; * want powerful high-level abstractions, like iterating through an AST with a; cursor, and don't want to learn all the nitty gritty details of Clang's AST. Do not use LibClang when you...:. * want full control over the Clang AST. Clang Plugins; -------------. :doc:`Clang Plugins <ClangPlugins>` allow you to run additional actions on the; AST as part of a compilation. Plugins are dynamic libraries that are loaded at; runtime by the compiler, and they're easy to integrate into your build; environment. Canonical examples of when to use Clang Plugins:. * special lint-style warnings or errors for your project; * creating additional build artifacts from a single compile step. Use Clang Plugins when you...:. * need your tool to rerun if any of the dependencies change; * want your tool to make or break a build; * need full control over the Clang AST. Do not use Clang Plugins when you...:. * want to run tools outside of your build environment; * want full control on how Clang is set up, including mapping of in-memory; virtual files; * need to run over a specific subset of files in your project whi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Tooling.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst:842,Integrability,interface,interface,842,"=================================================; Choosing the Right Interface for Your Application; =================================================. Clang provides infrastructure to write tools that need syntactic and semantic; information about a program. This document will give a short introduction of; the different ways to write clang tools, and their pros and cons. LibClang; --------. `LibClang <https://clang.llvm.org/doxygen/group__CINDEX.html>`_ is a stable high; level C interface to clang. When in doubt LibClang is probably the interface; you want to use. Consider the other interfaces only when you have a good; reason not to use LibClang. Canonical examples of when to use LibClang:. * Xcode; * Clang Python Bindings. Use LibClang when you...:. * want to interface with clang from other languages than C++; * need a stable interface that takes care to be backwards compatible; * want powerful high-level abstractions, like iterating through an AST with a; cursor, and don't want to learn all the nitty gritty details of Clang's AST. Do not use LibClang when you...:. * want full control over the Clang AST. Clang Plugins; -------------. :doc:`Clang Plugins <ClangPlugins>` allow you to run additional actions on the; AST as part of a compilation. Plugins are dynamic libraries that are loaded at; runtime by the compiler, and they're easy to integrate into your build; environment. Canonical examples of when to use Clang Plugins:. * special lint-style warnings or errors for your project; * creating additional build artifacts from a single compile step. Use Clang Plugins when you...:. * need your tool to rerun if any of the dependencies change; * want your tool to make or break a build; * need full control over the Clang AST. Do not use Clang Plugins when you...:. * want to run tools outside of your build environment; * want full control on how Clang is set up, including mapping of in-memory; virtual files; * need to run over a specific subset of files in your project whi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Tooling.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst:1361,Integrability,integrat,integrate,1361,"write clang tools, and their pros and cons. LibClang; --------. `LibClang <https://clang.llvm.org/doxygen/group__CINDEX.html>`_ is a stable high; level C interface to clang. When in doubt LibClang is probably the interface; you want to use. Consider the other interfaces only when you have a good; reason not to use LibClang. Canonical examples of when to use LibClang:. * Xcode; * Clang Python Bindings. Use LibClang when you...:. * want to interface with clang from other languages than C++; * need a stable interface that takes care to be backwards compatible; * want powerful high-level abstractions, like iterating through an AST with a; cursor, and don't want to learn all the nitty gritty details of Clang's AST. Do not use LibClang when you...:. * want full control over the Clang AST. Clang Plugins; -------------. :doc:`Clang Plugins <ClangPlugins>` allow you to run additional actions on the; AST as part of a compilation. Plugins are dynamic libraries that are loaded at; runtime by the compiler, and they're easy to integrate into your build; environment. Canonical examples of when to use Clang Plugins:. * special lint-style warnings or errors for your project; * creating additional build artifacts from a single compile step. Use Clang Plugins when you...:. * need your tool to rerun if any of the dependencies change; * want your tool to make or break a build; * need full control over the Clang AST. Do not use Clang Plugins when you...:. * want to run tools outside of your build environment; * want full control on how Clang is set up, including mapping of in-memory; virtual files; * need to run over a specific subset of files in your project which is not; necessarily related to any changes which would trigger rebuilds. LibTooling; ----------. :doc:`LibTooling <LibTooling>` is a C++ interface aimed at writing standalone; tools, as well as integrating into services that run clang tools. Canonical; examples of when to use LibTooling:. * a simple syntax checker; * refactorin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Tooling.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst:1647,Integrability,depend,dependencies,1647,"f when to use LibClang:. * Xcode; * Clang Python Bindings. Use LibClang when you...:. * want to interface with clang from other languages than C++; * need a stable interface that takes care to be backwards compatible; * want powerful high-level abstractions, like iterating through an AST with a; cursor, and don't want to learn all the nitty gritty details of Clang's AST. Do not use LibClang when you...:. * want full control over the Clang AST. Clang Plugins; -------------. :doc:`Clang Plugins <ClangPlugins>` allow you to run additional actions on the; AST as part of a compilation. Plugins are dynamic libraries that are loaded at; runtime by the compiler, and they're easy to integrate into your build; environment. Canonical examples of when to use Clang Plugins:. * special lint-style warnings or errors for your project; * creating additional build artifacts from a single compile step. Use Clang Plugins when you...:. * need your tool to rerun if any of the dependencies change; * want your tool to make or break a build; * need full control over the Clang AST. Do not use Clang Plugins when you...:. * want to run tools outside of your build environment; * want full control on how Clang is set up, including mapping of in-memory; virtual files; * need to run over a specific subset of files in your project which is not; necessarily related to any changes which would trigger rebuilds. LibTooling; ----------. :doc:`LibTooling <LibTooling>` is a C++ interface aimed at writing standalone; tools, as well as integrating into services that run clang tools. Canonical; examples of when to use LibTooling:. * a simple syntax checker; * refactoring tools. Use LibTooling when you...:. * want to run tools over a single file, or a specific subset of files,; independently of the build system; * want full control over the Clang AST; * want to share code with Clang Plugins. Do not use LibTooling when you...:. * want to run as part of the build triggered by dependency changes; * want a stable",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Tooling.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst:2141,Integrability,interface,interface,2141,"ins <ClangPlugins>` allow you to run additional actions on the; AST as part of a compilation. Plugins are dynamic libraries that are loaded at; runtime by the compiler, and they're easy to integrate into your build; environment. Canonical examples of when to use Clang Plugins:. * special lint-style warnings or errors for your project; * creating additional build artifacts from a single compile step. Use Clang Plugins when you...:. * need your tool to rerun if any of the dependencies change; * want your tool to make or break a build; * need full control over the Clang AST. Do not use Clang Plugins when you...:. * want to run tools outside of your build environment; * want full control on how Clang is set up, including mapping of in-memory; virtual files; * need to run over a specific subset of files in your project which is not; necessarily related to any changes which would trigger rebuilds. LibTooling; ----------. :doc:`LibTooling <LibTooling>` is a C++ interface aimed at writing standalone; tools, as well as integrating into services that run clang tools. Canonical; examples of when to use LibTooling:. * a simple syntax checker; * refactoring tools. Use LibTooling when you...:. * want to run tools over a single file, or a specific subset of files,; independently of the build system; * want full control over the Clang AST; * want to share code with Clang Plugins. Do not use LibTooling when you...:. * want to run as part of the build triggered by dependency changes; * want a stable interface so you don't need to change your code when the AST API; changes; * want high level abstractions like cursors and code completion out of the box; * do not want to write your tools in C++. :doc:`Clang tools <ClangTools>` are a collection of specific developer tools; built on top of the LibTooling infrastructure as part of the Clang project.; They are targeted at automating and improving core development activities of; C/C++ developers. Examples of tools we are building or planning ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Tooling.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst:2198,Integrability,integrat,integrating,2198,"ins <ClangPlugins>` allow you to run additional actions on the; AST as part of a compilation. Plugins are dynamic libraries that are loaded at; runtime by the compiler, and they're easy to integrate into your build; environment. Canonical examples of when to use Clang Plugins:. * special lint-style warnings or errors for your project; * creating additional build artifacts from a single compile step. Use Clang Plugins when you...:. * need your tool to rerun if any of the dependencies change; * want your tool to make or break a build; * need full control over the Clang AST. Do not use Clang Plugins when you...:. * want to run tools outside of your build environment; * want full control on how Clang is set up, including mapping of in-memory; virtual files; * need to run over a specific subset of files in your project which is not; necessarily related to any changes which would trigger rebuilds. LibTooling; ----------. :doc:`LibTooling <LibTooling>` is a C++ interface aimed at writing standalone; tools, as well as integrating into services that run clang tools. Canonical; examples of when to use LibTooling:. * a simple syntax checker; * refactoring tools. Use LibTooling when you...:. * want to run tools over a single file, or a specific subset of files,; independently of the build system; * want full control over the Clang AST; * want to share code with Clang Plugins. Do not use LibTooling when you...:. * want to run as part of the build triggered by dependency changes; * want a stable interface so you don't need to change your code when the AST API; changes; * want high level abstractions like cursors and code completion out of the box; * do not want to write your tools in C++. :doc:`Clang tools <ClangTools>` are a collection of specific developer tools; built on top of the LibTooling infrastructure as part of the Clang project.; They are targeted at automating and improving core development activities of; C/C++ developers. Examples of tools we are building or planning ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Tooling.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst:2643,Integrability,depend,dependency,2643,"pecial lint-style warnings or errors for your project; * creating additional build artifacts from a single compile step. Use Clang Plugins when you...:. * need your tool to rerun if any of the dependencies change; * want your tool to make or break a build; * need full control over the Clang AST. Do not use Clang Plugins when you...:. * want to run tools outside of your build environment; * want full control on how Clang is set up, including mapping of in-memory; virtual files; * need to run over a specific subset of files in your project which is not; necessarily related to any changes which would trigger rebuilds. LibTooling; ----------. :doc:`LibTooling <LibTooling>` is a C++ interface aimed at writing standalone; tools, as well as integrating into services that run clang tools. Canonical; examples of when to use LibTooling:. * a simple syntax checker; * refactoring tools. Use LibTooling when you...:. * want to run tools over a single file, or a specific subset of files,; independently of the build system; * want full control over the Clang AST; * want to share code with Clang Plugins. Do not use LibTooling when you...:. * want to run as part of the build triggered by dependency changes; * want a stable interface so you don't need to change your code when the AST API; changes; * want high level abstractions like cursors and code completion out of the box; * do not want to write your tools in C++. :doc:`Clang tools <ClangTools>` are a collection of specific developer tools; built on top of the LibTooling infrastructure as part of the Clang project.; They are targeted at automating and improving core development activities of; C/C++ developers. Examples of tools we are building or planning as part of the Clang project:. * Syntax checking (:program:`clang-check`); * Automatic fixing of compile errors (:program:`clang-fixit`); * Automatic code formatting (:program:`clang-format`); * Migration tools for new features in new language standards; * Core refactoring tools. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Tooling.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst:2679,Integrability,interface,interface,2679,"pecial lint-style warnings or errors for your project; * creating additional build artifacts from a single compile step. Use Clang Plugins when you...:. * need your tool to rerun if any of the dependencies change; * want your tool to make or break a build; * need full control over the Clang AST. Do not use Clang Plugins when you...:. * want to run tools outside of your build environment; * want full control on how Clang is set up, including mapping of in-memory; virtual files; * need to run over a specific subset of files in your project which is not; necessarily related to any changes which would trigger rebuilds. LibTooling; ----------. :doc:`LibTooling <LibTooling>` is a C++ interface aimed at writing standalone; tools, as well as integrating into services that run clang tools. Canonical; examples of when to use LibTooling:. * a simple syntax checker; * refactoring tools. Use LibTooling when you...:. * want to run tools over a single file, or a specific subset of files,; independently of the build system; * want full control over the Clang AST; * want to share code with Clang Plugins. Do not use LibTooling when you...:. * want to run as part of the build triggered by dependency changes; * want a stable interface so you don't need to change your code when the AST API; changes; * want high level abstractions like cursors and code completion out of the box; * do not want to write your tools in C++. :doc:`Clang tools <ClangTools>` are a collection of specific developer tools; built on top of the LibTooling infrastructure as part of the Clang project.; They are targeted at automating and improving core development activities of; C/C++ developers. Examples of tools we are building or planning as part of the Clang project:. * Syntax checking (:program:`clang-check`); * Automatic fixing of compile errors (:program:`clang-fixit`); * Automatic code formatting (:program:`clang-format`); * Migration tools for new features in new language standards; * Core refactoring tools. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Tooling.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst:2323,Modifiability,refactor,refactoring,2323,"untime by the compiler, and they're easy to integrate into your build; environment. Canonical examples of when to use Clang Plugins:. * special lint-style warnings or errors for your project; * creating additional build artifacts from a single compile step. Use Clang Plugins when you...:. * need your tool to rerun if any of the dependencies change; * want your tool to make or break a build; * need full control over the Clang AST. Do not use Clang Plugins when you...:. * want to run tools outside of your build environment; * want full control on how Clang is set up, including mapping of in-memory; virtual files; * need to run over a specific subset of files in your project which is not; necessarily related to any changes which would trigger rebuilds. LibTooling; ----------. :doc:`LibTooling <LibTooling>` is a C++ interface aimed at writing standalone; tools, as well as integrating into services that run clang tools. Canonical; examples of when to use LibTooling:. * a simple syntax checker; * refactoring tools. Use LibTooling when you...:. * want to run tools over a single file, or a specific subset of files,; independently of the build system; * want full control over the Clang AST; * want to share code with Clang Plugins. Do not use LibTooling when you...:. * want to run as part of the build triggered by dependency changes; * want a stable interface so you don't need to change your code when the AST API; changes; * want high level abstractions like cursors and code completion out of the box; * do not want to write your tools in C++. :doc:`Clang tools <ClangTools>` are a collection of specific developer tools; built on top of the LibTooling infrastructure as part of the Clang project.; They are targeted at automating and improving core development activities of; C/C++ developers. Examples of tools we are building or planning as part of the Clang project:. * Syntax checking (:program:`clang-check`); * Automatic fixing of compile errors (:program:`clang-fixit`); * Auto",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Tooling.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst:3435,Modifiability,refactor,refactoring,3435,"pecial lint-style warnings or errors for your project; * creating additional build artifacts from a single compile step. Use Clang Plugins when you...:. * need your tool to rerun if any of the dependencies change; * want your tool to make or break a build; * need full control over the Clang AST. Do not use Clang Plugins when you...:. * want to run tools outside of your build environment; * want full control on how Clang is set up, including mapping of in-memory; virtual files; * need to run over a specific subset of files in your project which is not; necessarily related to any changes which would trigger rebuilds. LibTooling; ----------. :doc:`LibTooling <LibTooling>` is a C++ interface aimed at writing standalone; tools, as well as integrating into services that run clang tools. Canonical; examples of when to use LibTooling:. * a simple syntax checker; * refactoring tools. Use LibTooling when you...:. * want to run tools over a single file, or a specific subset of files,; independently of the build system; * want full control over the Clang AST; * want to share code with Clang Plugins. Do not use LibTooling when you...:. * want to run as part of the build triggered by dependency changes; * want a stable interface so you don't need to change your code when the AST API; changes; * want high level abstractions like cursors and code completion out of the box; * do not want to write your tools in C++. :doc:`Clang tools <ClangTools>` are a collection of specific developer tools; built on top of the LibTooling infrastructure as part of the Clang project.; They are targeted at automating and improving core development activities of; C/C++ developers. Examples of tools we are building or planning as part of the Clang project:. * Syntax checking (:program:`clang-check`); * Automatic fixing of compile errors (:program:`clang-fixit`); * Automatic code formatting (:program:`clang-format`); * Migration tools for new features in new language standards; * Core refactoring tools. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Tooling.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst:1305,Performance,load,loaded,1305,"write clang tools, and their pros and cons. LibClang; --------. `LibClang <https://clang.llvm.org/doxygen/group__CINDEX.html>`_ is a stable high; level C interface to clang. When in doubt LibClang is probably the interface; you want to use. Consider the other interfaces only when you have a good; reason not to use LibClang. Canonical examples of when to use LibClang:. * Xcode; * Clang Python Bindings. Use LibClang when you...:. * want to interface with clang from other languages than C++; * need a stable interface that takes care to be backwards compatible; * want powerful high-level abstractions, like iterating through an AST with a; cursor, and don't want to learn all the nitty gritty details of Clang's AST. Do not use LibClang when you...:. * want full control over the Clang AST. Clang Plugins; -------------. :doc:`Clang Plugins <ClangPlugins>` allow you to run additional actions on the; AST as part of a compilation. Plugins are dynamic libraries that are loaded at; runtime by the compiler, and they're easy to integrate into your build; environment. Canonical examples of when to use Clang Plugins:. * special lint-style warnings or errors for your project; * creating additional build artifacts from a single compile step. Use Clang Plugins when you...:. * need your tool to rerun if any of the dependencies change; * want your tool to make or break a build; * need full control over the Clang AST. Do not use Clang Plugins when you...:. * want to run tools outside of your build environment; * want full control on how Clang is set up, including mapping of in-memory; virtual files; * need to run over a specific subset of files in your project which is not; necessarily related to any changes which would trigger rebuilds. LibTooling; ----------. :doc:`LibTooling <LibTooling>` is a C++ interface aimed at writing standalone; tools, as well as integrating into services that run clang tools. Canonical; examples of when to use LibTooling:. * a simple syntax checker; * refactorin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Tooling.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst:1001,Usability,learn,learn,1001,"=================================================; Choosing the Right Interface for Your Application; =================================================. Clang provides infrastructure to write tools that need syntactic and semantic; information about a program. This document will give a short introduction of; the different ways to write clang tools, and their pros and cons. LibClang; --------. `LibClang <https://clang.llvm.org/doxygen/group__CINDEX.html>`_ is a stable high; level C interface to clang. When in doubt LibClang is probably the interface; you want to use. Consider the other interfaces only when you have a good; reason not to use LibClang. Canonical examples of when to use LibClang:. * Xcode; * Clang Python Bindings. Use LibClang when you...:. * want to interface with clang from other languages than C++; * need a stable interface that takes care to be backwards compatible; * want powerful high-level abstractions, like iterating through an AST with a; cursor, and don't want to learn all the nitty gritty details of Clang's AST. Do not use LibClang when you...:. * want full control over the Clang AST. Clang Plugins; -------------. :doc:`Clang Plugins <ClangPlugins>` allow you to run additional actions on the; AST as part of a compilation. Plugins are dynamic libraries that are loaded at; runtime by the compiler, and they're easy to integrate into your build; environment. Canonical examples of when to use Clang Plugins:. * special lint-style warnings or errors for your project; * creating additional build artifacts from a single compile step. Use Clang Plugins when you...:. * need your tool to rerun if any of the dependencies change; * want your tool to make or break a build; * need full control over the Clang AST. Do not use Clang Plugins when you...:. * want to run tools outside of your build environment; * want full control on how Clang is set up, including mapping of in-memory; virtual files; * need to run over a specific subset of files in your project whi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Tooling.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst:2298,Usability,simpl,simple,2298,"untime by the compiler, and they're easy to integrate into your build; environment. Canonical examples of when to use Clang Plugins:. * special lint-style warnings or errors for your project; * creating additional build artifacts from a single compile step. Use Clang Plugins when you...:. * need your tool to rerun if any of the dependencies change; * want your tool to make or break a build; * need full control over the Clang AST. Do not use Clang Plugins when you...:. * want to run tools outside of your build environment; * want full control on how Clang is set up, including mapping of in-memory; virtual files; * need to run over a specific subset of files in your project which is not; necessarily related to any changes which would trigger rebuilds. LibTooling; ----------. :doc:`LibTooling <LibTooling>` is a C++ interface aimed at writing standalone; tools, as well as integrating into services that run clang tools. Canonical; examples of when to use LibTooling:. * a simple syntax checker; * refactoring tools. Use LibTooling when you...:. * want to run tools over a single file, or a specific subset of files,; independently of the build system; * want full control over the Clang AST; * want to share code with Clang Plugins. Do not use LibTooling when you...:. * want to run as part of the build triggered by dependency changes; * want a stable interface so you don't need to change your code when the AST API; changes; * want high level abstractions like cursors and code completion out of the box; * do not want to write your tools in C++. :doc:`Clang tools <ClangTools>` are a collection of specific developer tools; built on top of the LibTooling infrastructure as part of the Clang project.; They are targeted at automating and improving core development activities of; C/C++ developers. Examples of tools we are building or planning as part of the Clang project:. * Syntax checking (:program:`clang-check`); * Automatic fixing of compile errors (:program:`clang-fixit`); * Auto",MatchSource.DOCS,interpreter/llvm-project/clang/docs/Tooling.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/Tooling.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:668,Availability,avail,available,668,"==========================; UndefinedBehaviorSanitizer; ==========================. .. contents::; :local:. Introduction; ============. UndefinedBehaviorSanitizer (UBSan) is a fast undefined behavior detector.; UBSan modifies the program at compile-time to catch various kinds of undefined; behavior during program execution, for example:. * Array subscript out of bounds, where the bounds can be statically determined; * Bitwise shifts that are out of bounds for their data type; * Dereferencing misaligned or null pointers; * Signed integer overflow; * Conversion to, from, or between floating-point types which would; overflow the destination. See the full list of available :ref:`checks <ubsan-checks>` below. UBSan has an optional run-time library which provides better error reporting.; The checks have small runtime cost and no impact on address space layout or ABI. How to build; ============. Build LLVM/Clang with `CMake <https://llvm.org/docs/CMake.html>`_. Usage; =====. Use ``clang++`` to compile and link your program with the ``-fsanitize=undefined``; option. Make sure to use ``clang++`` (not ``ld``) as a linker, so that your; executable is linked with proper UBSan runtime libraries, unless all enabled; checks use trap mode. You can use ``clang`` instead of ``clang++`` if you're; compiling/linking C code. .. code-block:: console. % cat test.cc; int main(int argc, char **argv) {; int k = 0x7fffffff;; k += argc;; return 0;; }; % clang++ -fsanitize=undefined test.cc; % ./a.out; test.cc:3:5: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type 'int'. You can use ``-fsanitize=...`` and ``-fno-sanitize=`` to enable and disable one; check or one check group. For an individual check, the last option that enabling; or disabling it wins. .. code-block:: console. # Enable all checks in the ""undefined"" group, but disable ""alignment"".; % clang -fsanitize=undefined -fno-sanitize=alignment a.c. # Enable just ""alignment"".; % clang -fsanitize=alignment ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:775,Availability,error,error,775,"==========================; UndefinedBehaviorSanitizer; ==========================. .. contents::; :local:. Introduction; ============. UndefinedBehaviorSanitizer (UBSan) is a fast undefined behavior detector.; UBSan modifies the program at compile-time to catch various kinds of undefined; behavior during program execution, for example:. * Array subscript out of bounds, where the bounds can be statically determined; * Bitwise shifts that are out of bounds for their data type; * Dereferencing misaligned or null pointers; * Signed integer overflow; * Conversion to, from, or between floating-point types which would; overflow the destination. See the full list of available :ref:`checks <ubsan-checks>` below. UBSan has an optional run-time library which provides better error reporting.; The checks have small runtime cost and no impact on address space layout or ABI. How to build; ============. Build LLVM/Clang with `CMake <https://llvm.org/docs/CMake.html>`_. Usage; =====. Use ``clang++`` to compile and link your program with the ``-fsanitize=undefined``; option. Make sure to use ``clang++`` (not ``ld``) as a linker, so that your; executable is linked with proper UBSan runtime libraries, unless all enabled; checks use trap mode. You can use ``clang`` instead of ``clang++`` if you're; compiling/linking C code. .. code-block:: console. % cat test.cc; int main(int argc, char **argv) {; int k = 0x7fffffff;; k += argc;; return 0;; }; % clang++ -fsanitize=undefined test.cc; % ./a.out; test.cc:3:5: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type 'int'. You can use ``-fsanitize=...`` and ``-fno-sanitize=`` to enable and disable one; check or one check group. For an individual check, the last option that enabling; or disabling it wins. .. code-block:: console. # Enable all checks in the ""undefined"" group, but disable ""alignment"".; % clang -fsanitize=undefined -fno-sanitize=alignment a.c. # Enable just ""alignment"".; % clang -fsanitize=alignment ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:1520,Availability,error,error,1520,"* Conversion to, from, or between floating-point types which would; overflow the destination. See the full list of available :ref:`checks <ubsan-checks>` below. UBSan has an optional run-time library which provides better error reporting.; The checks have small runtime cost and no impact on address space layout or ABI. How to build; ============. Build LLVM/Clang with `CMake <https://llvm.org/docs/CMake.html>`_. Usage; =====. Use ``clang++`` to compile and link your program with the ``-fsanitize=undefined``; option. Make sure to use ``clang++`` (not ``ld``) as a linker, so that your; executable is linked with proper UBSan runtime libraries, unless all enabled; checks use trap mode. You can use ``clang`` instead of ``clang++`` if you're; compiling/linking C code. .. code-block:: console. % cat test.cc; int main(int argc, char **argv) {; int k = 0x7fffffff;; k += argc;; return 0;; }; % clang++ -fsanitize=undefined test.cc; % ./a.out; test.cc:3:5: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type 'int'. You can use ``-fsanitize=...`` and ``-fno-sanitize=`` to enable and disable one; check or one check group. For an individual check, the last option that enabling; or disabling it wins. .. code-block:: console. # Enable all checks in the ""undefined"" group, but disable ""alignment"".; % clang -fsanitize=undefined -fno-sanitize=alignment a.c. # Enable just ""alignment"".; % clang -fsanitize=alignment a.c. # The same. -fno-sanitize=undefined nullifies the previous -fsanitize=undefined.; % clang -fsanitize=undefined -fno-sanitize=undefined -fsanitize=alignment a.c. For most checks (:ref:`checks <ubsan-checks>`), the instrumented program prints; a verbose error report and continues execution upon a failed check.; You can use the following options to change the error reporting behavior:. * ``-fno-sanitize-recover=...``: print a verbose error report and exit the program;; * ``-fsanitize-trap=...``: execute a trap instruction (doesn't require UBSan;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:2258,Availability,error,error,2258,"de. You can use ``clang`` instead of ``clang++`` if you're; compiling/linking C code. .. code-block:: console. % cat test.cc; int main(int argc, char **argv) {; int k = 0x7fffffff;; k += argc;; return 0;; }; % clang++ -fsanitize=undefined test.cc; % ./a.out; test.cc:3:5: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type 'int'. You can use ``-fsanitize=...`` and ``-fno-sanitize=`` to enable and disable one; check or one check group. For an individual check, the last option that enabling; or disabling it wins. .. code-block:: console. # Enable all checks in the ""undefined"" group, but disable ""alignment"".; % clang -fsanitize=undefined -fno-sanitize=alignment a.c. # Enable just ""alignment"".; % clang -fsanitize=alignment a.c. # The same. -fno-sanitize=undefined nullifies the previous -fsanitize=undefined.; % clang -fsanitize=undefined -fno-sanitize=undefined -fsanitize=alignment a.c. For most checks (:ref:`checks <ubsan-checks>`), the instrumented program prints; a verbose error report and continues execution upon a failed check.; You can use the following options to change the error reporting behavior:. * ``-fno-sanitize-recover=...``: print a verbose error report and exit the program;; * ``-fsanitize-trap=...``: execute a trap instruction (doesn't require UBSan; run-time support). If the signal is not caught, the program will typically; terminate due to a ``SIGILL`` or ``SIGTRAP`` signal. For example:. .. code-block:: console. % clang++ -fsanitize=signed-integer-overflow,null,alignment -fno-sanitize-recover=null -fsanitize-trap=alignment a.cc. The program will continue execution after signed integer overflows, exit after; the first invalid use of a null pointer, and trap after the first use of misaligned; pointer. .. code-block:: console. % clang++ -fsanitize=undefined -fsanitize-trap=all a.cc. All checks in the ""undefined"" group are put into trap mode. Since no check; needs run-time support, the UBSan run-time library it not linked. N",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:2365,Availability,error,error,2365,"cat test.cc; int main(int argc, char **argv) {; int k = 0x7fffffff;; k += argc;; return 0;; }; % clang++ -fsanitize=undefined test.cc; % ./a.out; test.cc:3:5: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type 'int'. You can use ``-fsanitize=...`` and ``-fno-sanitize=`` to enable and disable one; check or one check group. For an individual check, the last option that enabling; or disabling it wins. .. code-block:: console. # Enable all checks in the ""undefined"" group, but disable ""alignment"".; % clang -fsanitize=undefined -fno-sanitize=alignment a.c. # Enable just ""alignment"".; % clang -fsanitize=alignment a.c. # The same. -fno-sanitize=undefined nullifies the previous -fsanitize=undefined.; % clang -fsanitize=undefined -fno-sanitize=undefined -fsanitize=alignment a.c. For most checks (:ref:`checks <ubsan-checks>`), the instrumented program prints; a verbose error report and continues execution upon a failed check.; You can use the following options to change the error reporting behavior:. * ``-fno-sanitize-recover=...``: print a verbose error report and exit the program;; * ``-fsanitize-trap=...``: execute a trap instruction (doesn't require UBSan; run-time support). If the signal is not caught, the program will typically; terminate due to a ``SIGILL`` or ``SIGTRAP`` signal. For example:. .. code-block:: console. % clang++ -fsanitize=signed-integer-overflow,null,alignment -fno-sanitize-recover=null -fsanitize-trap=alignment a.cc. The program will continue execution after signed integer overflows, exit after; the first invalid use of a null pointer, and trap after the first use of misaligned; pointer. .. code-block:: console. % clang++ -fsanitize=undefined -fsanitize-trap=all a.cc. All checks in the ""undefined"" group are put into trap mode. Since no check; needs run-time support, the UBSan run-time library it not linked. Note that; some other sanitizers also support trap mode and ``-fsanitize-trap=all``; enables trap mode for them. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:2410,Availability,recover,recover,2410,"k = 0x7fffffff;; k += argc;; return 0;; }; % clang++ -fsanitize=undefined test.cc; % ./a.out; test.cc:3:5: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type 'int'. You can use ``-fsanitize=...`` and ``-fno-sanitize=`` to enable and disable one; check or one check group. For an individual check, the last option that enabling; or disabling it wins. .. code-block:: console. # Enable all checks in the ""undefined"" group, but disable ""alignment"".; % clang -fsanitize=undefined -fno-sanitize=alignment a.c. # Enable just ""alignment"".; % clang -fsanitize=alignment a.c. # The same. -fno-sanitize=undefined nullifies the previous -fsanitize=undefined.; % clang -fsanitize=undefined -fno-sanitize=undefined -fsanitize=alignment a.c. For most checks (:ref:`checks <ubsan-checks>`), the instrumented program prints; a verbose error report and continues execution upon a failed check.; You can use the following options to change the error reporting behavior:. * ``-fno-sanitize-recover=...``: print a verbose error report and exit the program;; * ``-fsanitize-trap=...``: execute a trap instruction (doesn't require UBSan; run-time support). If the signal is not caught, the program will typically; terminate due to a ``SIGILL`` or ``SIGTRAP`` signal. For example:. .. code-block:: console. % clang++ -fsanitize=signed-integer-overflow,null,alignment -fno-sanitize-recover=null -fsanitize-trap=alignment a.cc. The program will continue execution after signed integer overflows, exit after; the first invalid use of a null pointer, and trap after the first use of misaligned; pointer. .. code-block:: console. % clang++ -fsanitize=undefined -fsanitize-trap=all a.cc. All checks in the ""undefined"" group are put into trap mode. Since no check; needs run-time support, the UBSan run-time library it not linked. Note that; some other sanitizers also support trap mode and ``-fsanitize-trap=all``; enables trap mode for them. .. code-block:: console. % clang -fsanitize-trap=und",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:2441,Availability,error,error,2441,"fsanitize=undefined test.cc; % ./a.out; test.cc:3:5: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type 'int'. You can use ``-fsanitize=...`` and ``-fno-sanitize=`` to enable and disable one; check or one check group. For an individual check, the last option that enabling; or disabling it wins. .. code-block:: console. # Enable all checks in the ""undefined"" group, but disable ""alignment"".; % clang -fsanitize=undefined -fno-sanitize=alignment a.c. # Enable just ""alignment"".; % clang -fsanitize=alignment a.c. # The same. -fno-sanitize=undefined nullifies the previous -fsanitize=undefined.; % clang -fsanitize=undefined -fno-sanitize=undefined -fsanitize=alignment a.c. For most checks (:ref:`checks <ubsan-checks>`), the instrumented program prints; a verbose error report and continues execution upon a failed check.; You can use the following options to change the error reporting behavior:. * ``-fno-sanitize-recover=...``: print a verbose error report and exit the program;; * ``-fsanitize-trap=...``: execute a trap instruction (doesn't require UBSan; run-time support). If the signal is not caught, the program will typically; terminate due to a ``SIGILL`` or ``SIGTRAP`` signal. For example:. .. code-block:: console. % clang++ -fsanitize=signed-integer-overflow,null,alignment -fno-sanitize-recover=null -fsanitize-trap=alignment a.cc. The program will continue execution after signed integer overflows, exit after; the first invalid use of a null pointer, and trap after the first use of misaligned; pointer. .. code-block:: console. % clang++ -fsanitize=undefined -fsanitize-trap=all a.cc. All checks in the ""undefined"" group are put into trap mode. Since no check; needs run-time support, the UBSan run-time library it not linked. Note that; some other sanitizers also support trap mode and ``-fsanitize-trap=all``; enables trap mode for them. .. code-block:: console. % clang -fsanitize-trap=undefined -fsanitize-recover=all a.c. ``-fsanitize-trap=``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:2797,Availability,recover,recover,2797,"it wins. .. code-block:: console. # Enable all checks in the ""undefined"" group, but disable ""alignment"".; % clang -fsanitize=undefined -fno-sanitize=alignment a.c. # Enable just ""alignment"".; % clang -fsanitize=alignment a.c. # The same. -fno-sanitize=undefined nullifies the previous -fsanitize=undefined.; % clang -fsanitize=undefined -fno-sanitize=undefined -fsanitize=alignment a.c. For most checks (:ref:`checks <ubsan-checks>`), the instrumented program prints; a verbose error report and continues execution upon a failed check.; You can use the following options to change the error reporting behavior:. * ``-fno-sanitize-recover=...``: print a verbose error report and exit the program;; * ``-fsanitize-trap=...``: execute a trap instruction (doesn't require UBSan; run-time support). If the signal is not caught, the program will typically; terminate due to a ``SIGILL`` or ``SIGTRAP`` signal. For example:. .. code-block:: console. % clang++ -fsanitize=signed-integer-overflow,null,alignment -fno-sanitize-recover=null -fsanitize-trap=alignment a.cc. The program will continue execution after signed integer overflows, exit after; the first invalid use of a null pointer, and trap after the first use of misaligned; pointer. .. code-block:: console. % clang++ -fsanitize=undefined -fsanitize-trap=all a.cc. All checks in the ""undefined"" group are put into trap mode. Since no check; needs run-time support, the UBSan run-time library it not linked. Note that; some other sanitizers also support trap mode and ``-fsanitize-trap=all``; enables trap mode for them. .. code-block:: console. % clang -fsanitize-trap=undefined -fsanitize-recover=all a.c. ``-fsanitize-trap=`` and ``-fsanitize-recover=`` are a no-op in the absence of; a ``-fsanitize=`` option. There is no unused command line option warning. .. _ubsan-checks:. Available checks; ================. Available checks are:. - ``-fsanitize=alignment``: Use of a misaligned pointer or creation; of a misaligned reference. Also sanitiz",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:3423,Availability,recover,recover,3423,"ze-recover=...``: print a verbose error report and exit the program;; * ``-fsanitize-trap=...``: execute a trap instruction (doesn't require UBSan; run-time support). If the signal is not caught, the program will typically; terminate due to a ``SIGILL`` or ``SIGTRAP`` signal. For example:. .. code-block:: console. % clang++ -fsanitize=signed-integer-overflow,null,alignment -fno-sanitize-recover=null -fsanitize-trap=alignment a.cc. The program will continue execution after signed integer overflows, exit after; the first invalid use of a null pointer, and trap after the first use of misaligned; pointer. .. code-block:: console. % clang++ -fsanitize=undefined -fsanitize-trap=all a.cc. All checks in the ""undefined"" group are put into trap mode. Since no check; needs run-time support, the UBSan run-time library it not linked. Note that; some other sanitizers also support trap mode and ``-fsanitize-trap=all``; enables trap mode for them. .. code-block:: console. % clang -fsanitize-trap=undefined -fsanitize-recover=all a.c. ``-fsanitize-trap=`` and ``-fsanitize-recover=`` are a no-op in the absence of; a ``-fsanitize=`` option. There is no unused command line option warning. .. _ubsan-checks:. Available checks; ================. Available checks are:. - ``-fsanitize=alignment``: Use of a misaligned pointer or creation; of a misaligned reference. Also sanitizes assume_aligned-like attributes.; - ``-fsanitize=bool``: Load of a ``bool`` value which is neither; ``true`` nor ``false``.; - ``-fsanitize=builtin``: Passing invalid values to compiler builtins.; - ``-fsanitize=bounds``: Out of bounds array indexing, in cases; where the array bound can be statically determined. The check includes; ``-fsanitize=array-bounds`` and ``-fsanitize=local-bounds``. Note that; ``-fsanitize=local-bounds`` is not included in ``-fsanitize=undefined``.; - ``-fsanitize=enum``: Load of a value of an enumerated type which; is not in the range of representable values for that enumerated; type.; - ``-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:3478,Availability,recover,recover,3478,"trap=...``: execute a trap instruction (doesn't require UBSan; run-time support). If the signal is not caught, the program will typically; terminate due to a ``SIGILL`` or ``SIGTRAP`` signal. For example:. .. code-block:: console. % clang++ -fsanitize=signed-integer-overflow,null,alignment -fno-sanitize-recover=null -fsanitize-trap=alignment a.cc. The program will continue execution after signed integer overflows, exit after; the first invalid use of a null pointer, and trap after the first use of misaligned; pointer. .. code-block:: console. % clang++ -fsanitize=undefined -fsanitize-trap=all a.cc. All checks in the ""undefined"" group are put into trap mode. Since no check; needs run-time support, the UBSan run-time library it not linked. Note that; some other sanitizers also support trap mode and ``-fsanitize-trap=all``; enables trap mode for them. .. code-block:: console. % clang -fsanitize-trap=undefined -fsanitize-recover=all a.c. ``-fsanitize-trap=`` and ``-fsanitize-recover=`` are a no-op in the absence of; a ``-fsanitize=`` option. There is no unused command line option warning. .. _ubsan-checks:. Available checks; ================. Available checks are:. - ``-fsanitize=alignment``: Use of a misaligned pointer or creation; of a misaligned reference. Also sanitizes assume_aligned-like attributes.; - ``-fsanitize=bool``: Load of a ``bool`` value which is neither; ``true`` nor ``false``.; - ``-fsanitize=builtin``: Passing invalid values to compiler builtins.; - ``-fsanitize=bounds``: Out of bounds array indexing, in cases; where the array bound can be statically determined. The check includes; ``-fsanitize=array-bounds`` and ``-fsanitize=local-bounds``. Note that; ``-fsanitize=local-bounds`` is not included in ``-fsanitize=undefined``.; - ``-fsanitize=enum``: Load of a value of an enumerated type which; is not in the range of representable values for that enumerated; type.; - ``-fsanitize=float-cast-overflow``: Conversion to, from, or; between floating-point type",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:5438,Availability,down,downcast,5438," enumerated; type.; - ``-fsanitize=float-cast-overflow``: Conversion to, from, or; between floating-point types which would overflow the; destination. Because the range of representable values for all; floating-point types supported by Clang is [-inf, +inf], the only; cases detected are conversions from floating point to integer types.; - ``-fsanitize=float-divide-by-zero``: Floating point division by; zero. This is undefined per the C and C++ standards, but is defined; by Clang (and by ISO/IEC/IEEE 60559 / IEEE 754) as producing either an; infinity or NaN value, so is not included in ``-fsanitize=undefined``.; - ``-fsanitize=function``: Indirect call of a function through a; function pointer of the wrong type.; - ``-fsanitize=implicit-unsigned-integer-truncation``,; ``-fsanitize=implicit-signed-integer-truncation``: Implicit conversion from; integer of larger bit width to smaller bit width, if that results in data; loss. That is, if the demoted value, after casting back to the original; width, is not equal to the original value before the downcast.; The ``-fsanitize=implicit-unsigned-integer-truncation`` handles conversions; between two ``unsigned`` types, while; ``-fsanitize=implicit-signed-integer-truncation`` handles the rest of the; conversions - when either one, or both of the types are signed.; Issues caught by these sanitizers are not undefined behavior,; but are often unintentional.; - ``-fsanitize=implicit-integer-sign-change``: Implicit conversion between; integer types, if that changes the sign of the value. That is, if the; original value was negative and the new value is positive (or zero),; or the original value was positive, and the new value is negative.; Issues caught by this sanitizer are not undefined behavior,; but are often unintentional.; - ``-fsanitize=integer-divide-by-zero``: Integer division by zero.; - ``-fsanitize=nonnull-attribute``: Passing null pointer as a function; parameter which is declared to never be null.; - ``-fsanitize=null``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:7360,Availability,down,downcasts,7360,"er as a function; parameter which is declared to never be null.; - ``-fsanitize=null``: Use of a null pointer or creation of a null; reference.; - ``-fsanitize=nullability-arg``: Passing null as a function parameter; which is annotated with ``_Nonnull``.; - ``-fsanitize=nullability-assign``: Assigning null to an lvalue which; is annotated with ``_Nonnull``.; - ``-fsanitize=nullability-return``: Returning null from a function with; a return type annotated with ``_Nonnull``.; - ``-fsanitize=objc-cast``: Invalid implicit cast of an ObjC object pointer; to an incompatible type. This is often unintentional, but is not undefined; behavior, therefore the check is not a part of the ``undefined`` group.; Currently only supported on Darwin.; - ``-fsanitize=object-size``: An attempt to potentially use bytes which; the optimizer can determine are not part of the object being accessed.; This will also detect some types of undefined behavior that may not; directly access memory, but are provably incorrect given the size of; the objects involved, such as invalid downcasts and calling methods on; invalid pointers. These checks are made in terms of; ``__builtin_object_size``, and consequently may be able to detect more; problems at higher optimization levels.; - ``-fsanitize=pointer-overflow``: Performing pointer arithmetic which; overflows, or where either the old or new pointer value is a null pointer; (or in C, when they both are).; - ``-fsanitize=return``: In C++, reaching the end of a; value-returning function without returning a value.; - ``-fsanitize=returns-nonnull-attribute``: Returning null pointer; from a function which is declared to never return null.; - ``-fsanitize=shift``: Shift operators where the amount shifted is; greater or equal to the promoted bit-width of the left hand side; or less than zero, or where the left hand side is negative. For a; signed left shift, also checks for signed overflow in C, and for; unsigned overflow in C++. You can use ``-fsanitize=shif",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:11837,Availability,avail,available,11837,"cious; behavior of implicit conversions. Enables; ``implicit-unsigned-integer-truncation``,; ``implicit-signed-integer-truncation``, and; ``implicit-integer-sign-change``.; - ``-fsanitize=integer``: Checks for undefined or suspicious integer; behavior (e.g. unsigned integer overflow).; Enables ``signed-integer-overflow``, ``unsigned-integer-overflow``,; ``shift``, ``integer-divide-by-zero``,; ``implicit-unsigned-integer-truncation``,; ``implicit-signed-integer-truncation``, and; ``implicit-integer-sign-change``.; - ``-fsanitize=nullability``: Enables ``nullability-arg``,; ``nullability-assign``, and ``nullability-return``. While violating; nullability does not have undefined behavior, it is often unintentional,; so UBSan offers to catch it. Volatile; --------. The ``null``, ``alignment``, ``object-size``, ``local-bounds``, and ``vptr`` checks do not apply; to pointers to types with the ``volatile`` qualifier. Minimal Runtime; ===============. There is a minimal UBSan runtime available suitable for use in production; environments. This runtime has a small attack surface. It only provides very; basic issue logging and deduplication, and does not support ``-fsanitize=vptr``; checking. To use the minimal runtime, add ``-fsanitize-minimal-runtime`` to the clang; command line options. For example, if you're used to compiling with; ``-fsanitize=undefined``, you could enable the minimal runtime with; ``-fsanitize=undefined -fsanitize-minimal-runtime``. Stack traces and report symbolization; =====================================; If you want UBSan to print symbolized stack trace for each error report, you; will need to:. #. Compile with ``-g`` and ``-fno-omit-frame-pointer`` to get proper debug; information in your binary.; #. Run your program with environment variable; ``UBSAN_OPTIONS=print_stacktrace=1``.; #. Make sure ``llvm-symbolizer`` binary is in ``PATH``. Logging; =======. The default log file for diagnostics is ""stderr"". To log diagnostics to another; file, you can s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:12453,Availability,error,error,12453,"les ``nullability-arg``,; ``nullability-assign``, and ``nullability-return``. While violating; nullability does not have undefined behavior, it is often unintentional,; so UBSan offers to catch it. Volatile; --------. The ``null``, ``alignment``, ``object-size``, ``local-bounds``, and ``vptr`` checks do not apply; to pointers to types with the ``volatile`` qualifier. Minimal Runtime; ===============. There is a minimal UBSan runtime available suitable for use in production; environments. This runtime has a small attack surface. It only provides very; basic issue logging and deduplication, and does not support ``-fsanitize=vptr``; checking. To use the minimal runtime, add ``-fsanitize-minimal-runtime`` to the clang; command line options. For example, if you're used to compiling with; ``-fsanitize=undefined``, you could enable the minimal runtime with; ``-fsanitize=undefined -fsanitize-minimal-runtime``. Stack traces and report symbolization; =====================================; If you want UBSan to print symbolized stack trace for each error report, you; will need to:. #. Compile with ``-g`` and ``-fno-omit-frame-pointer`` to get proper debug; information in your binary.; #. Run your program with environment variable; ``UBSAN_OPTIONS=print_stacktrace=1``.; #. Make sure ``llvm-symbolizer`` binary is in ``PATH``. Logging; =======. The default log file for diagnostics is ""stderr"". To log diagnostics to another; file, you can set ``UBSAN_OPTIONS=log_path=...``. Silencing Unsigned Integer Overflow; ===================================; To silence reports from unsigned integer overflow, you can set; ``UBSAN_OPTIONS=silence_unsigned_overflow=1``. This feature, combined with; ``-fsanitize-recover=unsigned-integer-overflow``, is particularly useful for; providing fuzzing signal without blowing up logs. Issue Suppression; =================. UndefinedBehaviorSanitizer is not expected to produce false positives.; If you see one, look again; most likely it is a true positive!. Di",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:13110,Availability,recover,recover,13110,". For example, if you're used to compiling with; ``-fsanitize=undefined``, you could enable the minimal runtime with; ``-fsanitize=undefined -fsanitize-minimal-runtime``. Stack traces and report symbolization; =====================================; If you want UBSan to print symbolized stack trace for each error report, you; will need to:. #. Compile with ``-g`` and ``-fno-omit-frame-pointer`` to get proper debug; information in your binary.; #. Run your program with environment variable; ``UBSAN_OPTIONS=print_stacktrace=1``.; #. Make sure ``llvm-symbolizer`` binary is in ``PATH``. Logging; =======. The default log file for diagnostics is ""stderr"". To log diagnostics to another; file, you can set ``UBSAN_OPTIONS=log_path=...``. Silencing Unsigned Integer Overflow; ===================================; To silence reports from unsigned integer overflow, you can set; ``UBSAN_OPTIONS=silence_unsigned_overflow=1``. This feature, combined with; ``-fsanitize-recover=unsigned-integer-overflow``, is particularly useful for; providing fuzzing signal without blowing up logs. Issue Suppression; =================. UndefinedBehaviorSanitizer is not expected to produce false positives.; If you see one, look again; most likely it is a true positive!. Disabling Instrumentation with ``__attribute__((no_sanitize(""undefined"")))``; ----------------------------------------------------------------------------. You disable UBSan checks for particular functions with; ``__attribute__((no_sanitize(""undefined"")))``. You can use all values of; ``-fsanitize=`` flag in this attribute, e.g. if your function deliberately; contains possible signed integer overflow, you can use; ``__attribute__((no_sanitize(""signed-integer-overflow"")))``. This attribute may not be; supported by other compilers, so consider using it together with; ``#if defined(__clang__)``. Suppressing Errors in Recompiled Code (Ignorelist); --------------------------------------------------. UndefinedBehaviorSanitizer supports ``src``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:14238,Availability,error,error,14238," without blowing up logs. Issue Suppression; =================. UndefinedBehaviorSanitizer is not expected to produce false positives.; If you see one, look again; most likely it is a true positive!. Disabling Instrumentation with ``__attribute__((no_sanitize(""undefined"")))``; ----------------------------------------------------------------------------. You disable UBSan checks for particular functions with; ``__attribute__((no_sanitize(""undefined"")))``. You can use all values of; ``-fsanitize=`` flag in this attribute, e.g. if your function deliberately; contains possible signed integer overflow, you can use; ``__attribute__((no_sanitize(""signed-integer-overflow"")))``. This attribute may not be; supported by other compilers, so consider using it together with; ``#if defined(__clang__)``. Suppressing Errors in Recompiled Code (Ignorelist); --------------------------------------------------. UndefinedBehaviorSanitizer supports ``src`` and ``fun`` entity types in; :doc:`SanitizerSpecialCaseList`, that can be used to suppress error reports; in the specified source files or functions. Runtime suppressions; --------------------. Sometimes you can suppress UBSan error reports for specific files, functions,; or libraries without recompiling the code. You need to pass a path to; suppression file in a ``UBSAN_OPTIONS`` environment variable. .. code-block:: bash. UBSAN_OPTIONS=suppressions=MyUBSan.supp. You need to specify a :ref:`check <ubsan-checks>` you are suppressing and the; bug location. For example:. .. code-block:: bash. signed-integer-overflow:file-with-known-overflow.cpp; alignment:function_doing_unaligned_access; vptr:shared_object_with_vptr_failures.so. There are several limitations:. * Sometimes your binary must have enough debug info and/or symbol table, so; that the runtime could figure out source file or function name to match; against the suppression.; * It is only possible to suppress recoverable checks. For the example above,; you can additionally pass; ``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:14374,Availability,error,error,14374,"sabling Instrumentation with ``__attribute__((no_sanitize(""undefined"")))``; ----------------------------------------------------------------------------. You disable UBSan checks for particular functions with; ``__attribute__((no_sanitize(""undefined"")))``. You can use all values of; ``-fsanitize=`` flag in this attribute, e.g. if your function deliberately; contains possible signed integer overflow, you can use; ``__attribute__((no_sanitize(""signed-integer-overflow"")))``. This attribute may not be; supported by other compilers, so consider using it together with; ``#if defined(__clang__)``. Suppressing Errors in Recompiled Code (Ignorelist); --------------------------------------------------. UndefinedBehaviorSanitizer supports ``src`` and ``fun`` entity types in; :doc:`SanitizerSpecialCaseList`, that can be used to suppress error reports; in the specified source files or functions. Runtime suppressions; --------------------. Sometimes you can suppress UBSan error reports for specific files, functions,; or libraries without recompiling the code. You need to pass a path to; suppression file in a ``UBSAN_OPTIONS`` environment variable. .. code-block:: bash. UBSAN_OPTIONS=suppressions=MyUBSan.supp. You need to specify a :ref:`check <ubsan-checks>` you are suppressing and the; bug location. For example:. .. code-block:: bash. signed-integer-overflow:file-with-known-overflow.cpp; alignment:function_doing_unaligned_access; vptr:shared_object_with_vptr_failures.so. There are several limitations:. * Sometimes your binary must have enough debug info and/or symbol table, so; that the runtime could figure out source file or function name to match; against the suppression.; * It is only possible to suppress recoverable checks. For the example above,; you can additionally pass; ``-fsanitize-recover=signed-integer-overflow,alignment,vptr``, although; most of UBSan checks are recoverable by default.; * Check groups (like ``undefined``) can't be used in suppressions file, only; fin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:15126,Availability,recover,recoverable,15126,"iorSanitizer supports ``src`` and ``fun`` entity types in; :doc:`SanitizerSpecialCaseList`, that can be used to suppress error reports; in the specified source files or functions. Runtime suppressions; --------------------. Sometimes you can suppress UBSan error reports for specific files, functions,; or libraries without recompiling the code. You need to pass a path to; suppression file in a ``UBSAN_OPTIONS`` environment variable. .. code-block:: bash. UBSAN_OPTIONS=suppressions=MyUBSan.supp. You need to specify a :ref:`check <ubsan-checks>` you are suppressing and the; bug location. For example:. .. code-block:: bash. signed-integer-overflow:file-with-known-overflow.cpp; alignment:function_doing_unaligned_access; vptr:shared_object_with_vptr_failures.so. There are several limitations:. * Sometimes your binary must have enough debug info and/or symbol table, so; that the runtime could figure out source file or function name to match; against the suppression.; * It is only possible to suppress recoverable checks. For the example above,; you can additionally pass; ``-fsanitize-recover=signed-integer-overflow,alignment,vptr``, although; most of UBSan checks are recoverable by default.; * Check groups (like ``undefined``) can't be used in suppressions file, only; fine-grained checks are supported. Supported Platforms; ===================. UndefinedBehaviorSanitizer is supported on the following operating systems:. * Android; * Linux; * NetBSD; * FreeBSD; * OpenBSD; * macOS; * Windows. The runtime library is relatively portable and platform independent. If the OS; you need is not listed above, UndefinedBehaviorSanitizer may already work for; it, or could be made to work with a minor porting effort. Current Status; ==============. UndefinedBehaviorSanitizer is available on selected platforms starting from LLVM; 3.3. The test suite is integrated into the CMake build and can be run with; ``check-ubsan`` command. Additional Configuration; ========================. UndefinedB",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:15210,Availability,recover,recover,15210,"ppress error reports; in the specified source files or functions. Runtime suppressions; --------------------. Sometimes you can suppress UBSan error reports for specific files, functions,; or libraries without recompiling the code. You need to pass a path to; suppression file in a ``UBSAN_OPTIONS`` environment variable. .. code-block:: bash. UBSAN_OPTIONS=suppressions=MyUBSan.supp. You need to specify a :ref:`check <ubsan-checks>` you are suppressing and the; bug location. For example:. .. code-block:: bash. signed-integer-overflow:file-with-known-overflow.cpp; alignment:function_doing_unaligned_access; vptr:shared_object_with_vptr_failures.so. There are several limitations:. * Sometimes your binary must have enough debug info and/or symbol table, so; that the runtime could figure out source file or function name to match; against the suppression.; * It is only possible to suppress recoverable checks. For the example above,; you can additionally pass; ``-fsanitize-recover=signed-integer-overflow,alignment,vptr``, although; most of UBSan checks are recoverable by default.; * Check groups (like ``undefined``) can't be used in suppressions file, only; fine-grained checks are supported. Supported Platforms; ===================. UndefinedBehaviorSanitizer is supported on the following operating systems:. * Android; * Linux; * NetBSD; * FreeBSD; * OpenBSD; * macOS; * Windows. The runtime library is relatively portable and platform independent. If the OS; you need is not listed above, UndefinedBehaviorSanitizer may already work for; it, or could be made to work with a minor porting effort. Current Status; ==============. UndefinedBehaviorSanitizer is available on selected platforms starting from LLVM; 3.3. The test suite is integrated into the CMake build and can be run with; ``check-ubsan`` command. Additional Configuration; ========================. UndefinedBehaviorSanitizer adds static check data for each check unless it is; in trap mode. This check data includes the fu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:15295,Availability,recover,recoverable,15295,"ppress error reports; in the specified source files or functions. Runtime suppressions; --------------------. Sometimes you can suppress UBSan error reports for specific files, functions,; or libraries without recompiling the code. You need to pass a path to; suppression file in a ``UBSAN_OPTIONS`` environment variable. .. code-block:: bash. UBSAN_OPTIONS=suppressions=MyUBSan.supp. You need to specify a :ref:`check <ubsan-checks>` you are suppressing and the; bug location. For example:. .. code-block:: bash. signed-integer-overflow:file-with-known-overflow.cpp; alignment:function_doing_unaligned_access; vptr:shared_object_with_vptr_failures.so. There are several limitations:. * Sometimes your binary must have enough debug info and/or symbol table, so; that the runtime could figure out source file or function name to match; against the suppression.; * It is only possible to suppress recoverable checks. For the example above,; you can additionally pass; ``-fsanitize-recover=signed-integer-overflow,alignment,vptr``, although; most of UBSan checks are recoverable by default.; * Check groups (like ``undefined``) can't be used in suppressions file, only; fine-grained checks are supported. Supported Platforms; ===================. UndefinedBehaviorSanitizer is supported on the following operating systems:. * Android; * Linux; * NetBSD; * FreeBSD; * OpenBSD; * macOS; * Windows. The runtime library is relatively portable and platform independent. If the OS; you need is not listed above, UndefinedBehaviorSanitizer may already work for; it, or could be made to work with a minor porting effort. Current Status; ==============. UndefinedBehaviorSanitizer is available on selected platforms starting from LLVM; 3.3. The test suite is integrated into the CMake build and can be run with; ``check-ubsan`` command. Additional Configuration; ========================. UndefinedBehaviorSanitizer adds static check data for each check unless it is; in trap mode. This check data includes the fu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:15903,Availability,avail,available,15903,". * Sometimes your binary must have enough debug info and/or symbol table, so; that the runtime could figure out source file or function name to match; against the suppression.; * It is only possible to suppress recoverable checks. For the example above,; you can additionally pass; ``-fsanitize-recover=signed-integer-overflow,alignment,vptr``, although; most of UBSan checks are recoverable by default.; * Check groups (like ``undefined``) can't be used in suppressions file, only; fine-grained checks are supported. Supported Platforms; ===================. UndefinedBehaviorSanitizer is supported on the following operating systems:. * Android; * Linux; * NetBSD; * FreeBSD; * OpenBSD; * macOS; * Windows. The runtime library is relatively portable and platform independent. If the OS; you need is not listed above, UndefinedBehaviorSanitizer may already work for; it, or could be made to work with a minor porting effort. Current Status; ==============. UndefinedBehaviorSanitizer is available on selected platforms starting from LLVM; 3.3. The test suite is integrated into the CMake build and can be run with; ``check-ubsan`` command. Additional Configuration; ========================. UndefinedBehaviorSanitizer adds static check data for each check unless it is; in trap mode. This check data includes the full file name. The option; ``-fsanitize-undefined-strip-path-components=N`` can be used to trim this; information. If ``N`` is positive, file information emitted by; UndefinedBehaviorSanitizer will drop the first ``N`` components from the file; path. If ``N`` is negative, the last ``N`` components will be kept. Example; -------. For a file called ``/code/library/file.cpp``, here is what would be emitted:. * Default (No flag, or ``-fsanitize-undefined-strip-path-components=0``): ``/code/library/file.cpp``; * ``-fsanitize-undefined-strip-path-components=1``: ``code/library/file.cpp``; * ``-fsanitize-undefined-strip-path-components=2``: ``library/file.cpp``; * ``-fsanitize-undef",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:17119,Availability,error,error,17119,"me library is relatively portable and platform independent. If the OS; you need is not listed above, UndefinedBehaviorSanitizer may already work for; it, or could be made to work with a minor porting effort. Current Status; ==============. UndefinedBehaviorSanitizer is available on selected platforms starting from LLVM; 3.3. The test suite is integrated into the CMake build and can be run with; ``check-ubsan`` command. Additional Configuration; ========================. UndefinedBehaviorSanitizer adds static check data for each check unless it is; in trap mode. This check data includes the full file name. The option; ``-fsanitize-undefined-strip-path-components=N`` can be used to trim this; information. If ``N`` is positive, file information emitted by; UndefinedBehaviorSanitizer will drop the first ``N`` components from the file; path. If ``N`` is negative, the last ``N`` components will be kept. Example; -------. For a file called ``/code/library/file.cpp``, here is what would be emitted:. * Default (No flag, or ``-fsanitize-undefined-strip-path-components=0``): ``/code/library/file.cpp``; * ``-fsanitize-undefined-strip-path-components=1``: ``code/library/file.cpp``; * ``-fsanitize-undefined-strip-path-components=2``: ``library/file.cpp``; * ``-fsanitize-undefined-strip-path-components=-1``: ``file.cpp``; * ``-fsanitize-undefined-strip-path-components=-2``: ``library/file.cpp``. More Information; ================. * From Oracle blog, including a discussion of error messages:; `Improving Application Security with UndefinedBehaviorSanitizer (UBSan) and GCC; <https://blogs.oracle.com/linux/improving-application-security-with-undefinedbehaviorsanitizer-ubsan-and-gcc>`_; * From LLVM project blog:; `What Every C Programmer Should Know About Undefined Behavior; <http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html>`_; * From John Regehr's *Embedded in Academia* blog:; `A Guide to Undefined Behavior in C and C++; <https://blog.regehr.org/archives/213>`_; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:15978,Deployability,integrat,integrated,15978,"me could figure out source file or function name to match; against the suppression.; * It is only possible to suppress recoverable checks. For the example above,; you can additionally pass; ``-fsanitize-recover=signed-integer-overflow,alignment,vptr``, although; most of UBSan checks are recoverable by default.; * Check groups (like ``undefined``) can't be used in suppressions file, only; fine-grained checks are supported. Supported Platforms; ===================. UndefinedBehaviorSanitizer is supported on the following operating systems:. * Android; * Linux; * NetBSD; * FreeBSD; * OpenBSD; * macOS; * Windows. The runtime library is relatively portable and platform independent. If the OS; you need is not listed above, UndefinedBehaviorSanitizer may already work for; it, or could be made to work with a minor porting effort. Current Status; ==============. UndefinedBehaviorSanitizer is available on selected platforms starting from LLVM; 3.3. The test suite is integrated into the CMake build and can be run with; ``check-ubsan`` command. Additional Configuration; ========================. UndefinedBehaviorSanitizer adds static check data for each check unless it is; in trap mode. This check data includes the full file name. The option; ``-fsanitize-undefined-strip-path-components=N`` can be used to trim this; information. If ``N`` is positive, file information emitted by; UndefinedBehaviorSanitizer will drop the first ``N`` components from the file; path. If ``N`` is negative, the last ``N`` components will be kept. Example; -------. For a file called ``/code/library/file.cpp``, here is what would be emitted:. * Default (No flag, or ``-fsanitize-undefined-strip-path-components=0``): ``/code/library/file.cpp``; * ``-fsanitize-undefined-strip-path-components=1``: ``code/library/file.cpp``; * ``-fsanitize-undefined-strip-path-components=2``: ``library/file.cpp``; * ``-fsanitize-undefined-strip-path-components=-1``: ``file.cpp``; * ``-fsanitize-undefined-strip-path-component",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:15978,Integrability,integrat,integrated,15978,"me could figure out source file or function name to match; against the suppression.; * It is only possible to suppress recoverable checks. For the example above,; you can additionally pass; ``-fsanitize-recover=signed-integer-overflow,alignment,vptr``, although; most of UBSan checks are recoverable by default.; * Check groups (like ``undefined``) can't be used in suppressions file, only; fine-grained checks are supported. Supported Platforms; ===================. UndefinedBehaviorSanitizer is supported on the following operating systems:. * Android; * Linux; * NetBSD; * FreeBSD; * OpenBSD; * macOS; * Windows. The runtime library is relatively portable and platform independent. If the OS; you need is not listed above, UndefinedBehaviorSanitizer may already work for; it, or could be made to work with a minor porting effort. Current Status; ==============. UndefinedBehaviorSanitizer is available on selected platforms starting from LLVM; 3.3. The test suite is integrated into the CMake build and can be run with; ``check-ubsan`` command. Additional Configuration; ========================. UndefinedBehaviorSanitizer adds static check data for each check unless it is; in trap mode. This check data includes the full file name. The option; ``-fsanitize-undefined-strip-path-components=N`` can be used to trim this; information. If ``N`` is positive, file information emitted by; UndefinedBehaviorSanitizer will drop the first ``N`` components from the file; path. If ``N`` is negative, the last ``N`` components will be kept. Example; -------. For a file called ``/code/library/file.cpp``, here is what would be emitted:. * Default (No flag, or ``-fsanitize-undefined-strip-path-components=0``): ``/code/library/file.cpp``; * ``-fsanitize-undefined-strip-path-components=1``: ``code/library/file.cpp``; * ``-fsanitize-undefined-strip-path-components=2``: ``library/file.cpp``; * ``-fsanitize-undefined-strip-path-components=-1``: ``file.cpp``; * ``-fsanitize-undefined-strip-path-component",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:17125,Integrability,message,messages,17125,"me library is relatively portable and platform independent. If the OS; you need is not listed above, UndefinedBehaviorSanitizer may already work for; it, or could be made to work with a minor porting effort. Current Status; ==============. UndefinedBehaviorSanitizer is available on selected platforms starting from LLVM; 3.3. The test suite is integrated into the CMake build and can be run with; ``check-ubsan`` command. Additional Configuration; ========================. UndefinedBehaviorSanitizer adds static check data for each check unless it is; in trap mode. This check data includes the full file name. The option; ``-fsanitize-undefined-strip-path-components=N`` can be used to trim this; information. If ``N`` is positive, file information emitted by; UndefinedBehaviorSanitizer will drop the first ``N`` components from the file; path. If ``N`` is negative, the last ``N`` components will be kept. Example; -------. For a file called ``/code/library/file.cpp``, here is what would be emitted:. * Default (No flag, or ``-fsanitize-undefined-strip-path-components=0``): ``/code/library/file.cpp``; * ``-fsanitize-undefined-strip-path-components=1``: ``code/library/file.cpp``; * ``-fsanitize-undefined-strip-path-components=2``: ``library/file.cpp``; * ``-fsanitize-undefined-strip-path-components=-1``: ``file.cpp``; * ``-fsanitize-undefined-strip-path-components=-2``: ``library/file.cpp``. More Information; ================. * From Oracle blog, including a discussion of error messages:; `Improving Application Security with UndefinedBehaviorSanitizer (UBSan) and GCC; <https://blogs.oracle.com/linux/improving-application-security-with-undefinedbehaviorsanitizer-ubsan-and-gcc>`_; * From LLVM project blog:; `What Every C Programmer Should Know About Undefined Behavior; <http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html>`_; * From John Regehr's *Embedded in Academia* blog:; `A Guide to Undefined Behavior in C and C++; <https://blog.regehr.org/archives/213>`_; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:9638,Modifiability,variab,variable-length,9638,"nteger-overflow``: Signed integer overflow, where the; result of a signed integer computation cannot be represented in its type.; This includes all the checks covered by ``-ftrapv``, as well as checks for; signed division overflow (``INT_MIN/-1``), but not checks for; lossy implicit conversions performed before the computation; (see ``-fsanitize=implicit-conversion``). Both of these two issues are; handled by ``-fsanitize=implicit-conversion`` group of checks.; - ``-fsanitize=unreachable``: If control flow reaches an unreachable; program point.; - ``-fsanitize=unsigned-integer-overflow``: Unsigned integer overflow, where; the result of an unsigned integer computation cannot be represented in its; type. Unlike signed integer overflow, this is not undefined behavior, but; it is often unintentional. This sanitizer does not check for lossy implicit; conversions performed before such a computation; (see ``-fsanitize=implicit-conversion``).; - ``-fsanitize=vla-bound``: A variable-length array whose bound; does not evaluate to a positive value.; - ``-fsanitize=vptr``: Use of an object whose vptr indicates that it is of; the wrong dynamic type, or that its lifetime has not begun or has ended.; Incompatible with ``-fno-rtti``. Link must be performed by ``clang++``, not; ``clang``, to make sure C++-specific parts of the runtime library and C++; standard libraries are present. You can also use the following check groups:; - ``-fsanitize=undefined``: All of the checks listed above other than; ``float-divide-by-zero``, ``unsigned-integer-overflow``,; ``implicit-conversion``, ``local-bounds`` and the ``nullability-*`` group; of checks.; - ``-fsanitize=undefined-trap``: Deprecated alias of; ``-fsanitize=undefined``.; - ``-fsanitize=implicit-integer-truncation``: Catches lossy integral; conversions. Enables ``implicit-signed-integer-truncation`` and; ``implicit-unsigned-integer-truncation``.; - ``-fsanitize=implicit-integer-arithmetic-value-change``: Catches implicit; conversions th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:12629,Modifiability,variab,variable,12629,"lignment``, ``object-size``, ``local-bounds``, and ``vptr`` checks do not apply; to pointers to types with the ``volatile`` qualifier. Minimal Runtime; ===============. There is a minimal UBSan runtime available suitable for use in production; environments. This runtime has a small attack surface. It only provides very; basic issue logging and deduplication, and does not support ``-fsanitize=vptr``; checking. To use the minimal runtime, add ``-fsanitize-minimal-runtime`` to the clang; command line options. For example, if you're used to compiling with; ``-fsanitize=undefined``, you could enable the minimal runtime with; ``-fsanitize=undefined -fsanitize-minimal-runtime``. Stack traces and report symbolization; =====================================; If you want UBSan to print symbolized stack trace for each error report, you; will need to:. #. Compile with ``-g`` and ``-fno-omit-frame-pointer`` to get proper debug; information in your binary.; #. Run your program with environment variable; ``UBSAN_OPTIONS=print_stacktrace=1``.; #. Make sure ``llvm-symbolizer`` binary is in ``PATH``. Logging; =======. The default log file for diagnostics is ""stderr"". To log diagnostics to another; file, you can set ``UBSAN_OPTIONS=log_path=...``. Silencing Unsigned Integer Overflow; ===================================; To silence reports from unsigned integer overflow, you can set; ``UBSAN_OPTIONS=silence_unsigned_overflow=1``. This feature, combined with; ``-fsanitize-recover=unsigned-integer-overflow``, is particularly useful for; providing fuzzing signal without blowing up logs. Issue Suppression; =================. UndefinedBehaviorSanitizer is not expected to produce false positives.; If you see one, look again; most likely it is a true positive!. Disabling Instrumentation with ``__attribute__((no_sanitize(""undefined"")))``; ----------------------------------------------------------------------------. You disable UBSan checks for particular functions with; ``__attribute__((no_sani",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:14543,Modifiability,variab,variable,14543,"----------------------------------------------. You disable UBSan checks for particular functions with; ``__attribute__((no_sanitize(""undefined"")))``. You can use all values of; ``-fsanitize=`` flag in this attribute, e.g. if your function deliberately; contains possible signed integer overflow, you can use; ``__attribute__((no_sanitize(""signed-integer-overflow"")))``. This attribute may not be; supported by other compilers, so consider using it together with; ``#if defined(__clang__)``. Suppressing Errors in Recompiled Code (Ignorelist); --------------------------------------------------. UndefinedBehaviorSanitizer supports ``src`` and ``fun`` entity types in; :doc:`SanitizerSpecialCaseList`, that can be used to suppress error reports; in the specified source files or functions. Runtime suppressions; --------------------. Sometimes you can suppress UBSan error reports for specific files, functions,; or libraries without recompiling the code. You need to pass a path to; suppression file in a ``UBSAN_OPTIONS`` environment variable. .. code-block:: bash. UBSAN_OPTIONS=suppressions=MyUBSan.supp. You need to specify a :ref:`check <ubsan-checks>` you are suppressing and the; bug location. For example:. .. code-block:: bash. signed-integer-overflow:file-with-known-overflow.cpp; alignment:function_doing_unaligned_access; vptr:shared_object_with_vptr_failures.so. There are several limitations:. * Sometimes your binary must have enough debug info and/or symbol table, so; that the runtime could figure out source file or function name to match; against the suppression.; * It is only possible to suppress recoverable checks. For the example above,; you can additionally pass; ``-fsanitize-recover=signed-integer-overflow,alignment,vptr``, although; most of UBSan checks are recoverable by default.; * Check groups (like ``undefined``) can't be used in suppressions file, only; fine-grained checks are supported. Supported Platforms; ===================. UndefinedBehaviorSanitizer is su",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:15658,Modifiability,portab,portable,15658,"checks>` you are suppressing and the; bug location. For example:. .. code-block:: bash. signed-integer-overflow:file-with-known-overflow.cpp; alignment:function_doing_unaligned_access; vptr:shared_object_with_vptr_failures.so. There are several limitations:. * Sometimes your binary must have enough debug info and/or symbol table, so; that the runtime could figure out source file or function name to match; against the suppression.; * It is only possible to suppress recoverable checks. For the example above,; you can additionally pass; ``-fsanitize-recover=signed-integer-overflow,alignment,vptr``, although; most of UBSan checks are recoverable by default.; * Check groups (like ``undefined``) can't be used in suppressions file, only; fine-grained checks are supported. Supported Platforms; ===================. UndefinedBehaviorSanitizer is supported on the following operating systems:. * Android; * Linux; * NetBSD; * FreeBSD; * OpenBSD; * macOS; * Windows. The runtime library is relatively portable and platform independent. If the OS; you need is not listed above, UndefinedBehaviorSanitizer may already work for; it, or could be made to work with a minor porting effort. Current Status; ==============. UndefinedBehaviorSanitizer is available on selected platforms starting from LLVM; 3.3. The test suite is integrated into the CMake build and can be run with; ``check-ubsan`` command. Additional Configuration; ========================. UndefinedBehaviorSanitizer adds static check data for each check unless it is; in trap mode. This check data includes the full file name. The option; ``-fsanitize-undefined-strip-path-components=N`` can be used to trim this; information. If ``N`` is positive, file information emitted by; UndefinedBehaviorSanitizer will drop the first ``N`` components from the file; path. If ``N`` is negative, the last ``N`` components will be kept. Example; -------. For a file called ``/code/library/file.cpp``, here is what would be emitted:. * Default (No flag",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:7115,Performance,optimiz,optimizer,7115,"itizer are not undefined behavior,; but are often unintentional.; - ``-fsanitize=integer-divide-by-zero``: Integer division by zero.; - ``-fsanitize=nonnull-attribute``: Passing null pointer as a function; parameter which is declared to never be null.; - ``-fsanitize=null``: Use of a null pointer or creation of a null; reference.; - ``-fsanitize=nullability-arg``: Passing null as a function parameter; which is annotated with ``_Nonnull``.; - ``-fsanitize=nullability-assign``: Assigning null to an lvalue which; is annotated with ``_Nonnull``.; - ``-fsanitize=nullability-return``: Returning null from a function with; a return type annotated with ``_Nonnull``.; - ``-fsanitize=objc-cast``: Invalid implicit cast of an ObjC object pointer; to an incompatible type. This is often unintentional, but is not undefined; behavior, therefore the check is not a part of the ``undefined`` group.; Currently only supported on Darwin.; - ``-fsanitize=object-size``: An attempt to potentially use bytes which; the optimizer can determine are not part of the object being accessed.; This will also detect some types of undefined behavior that may not; directly access memory, but are provably incorrect given the size of; the objects involved, such as invalid downcasts and calling methods on; invalid pointers. These checks are made in terms of; ``__builtin_object_size``, and consequently may be able to detect more; problems at higher optimization levels.; - ``-fsanitize=pointer-overflow``: Performing pointer arithmetic which; overflows, or where either the old or new pointer value is a null pointer; (or in C, when they both are).; - ``-fsanitize=return``: In C++, reaching the end of a; value-returning function without returning a value.; - ``-fsanitize=returns-nonnull-attribute``: Returning null pointer; from a function which is declared to never return null.; - ``-fsanitize=shift``: Shift operators where the amount shifted is; greater or equal to the promoted bit-width of the left hand side; o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:7538,Performance,optimiz,optimization,7538,"ull as a function parameter; which is annotated with ``_Nonnull``.; - ``-fsanitize=nullability-assign``: Assigning null to an lvalue which; is annotated with ``_Nonnull``.; - ``-fsanitize=nullability-return``: Returning null from a function with; a return type annotated with ``_Nonnull``.; - ``-fsanitize=objc-cast``: Invalid implicit cast of an ObjC object pointer; to an incompatible type. This is often unintentional, but is not undefined; behavior, therefore the check is not a part of the ``undefined`` group.; Currently only supported on Darwin.; - ``-fsanitize=object-size``: An attempt to potentially use bytes which; the optimizer can determine are not part of the object being accessed.; This will also detect some types of undefined behavior that may not; directly access memory, but are provably incorrect given the size of; the objects involved, such as invalid downcasts and calling methods on; invalid pointers. These checks are made in terms of; ``__builtin_object_size``, and consequently may be able to detect more; problems at higher optimization levels.; - ``-fsanitize=pointer-overflow``: Performing pointer arithmetic which; overflows, or where either the old or new pointer value is a null pointer; (or in C, when they both are).; - ``-fsanitize=return``: In C++, reaching the end of a; value-returning function without returning a value.; - ``-fsanitize=returns-nonnull-attribute``: Returning null pointer; from a function which is declared to never return null.; - ``-fsanitize=shift``: Shift operators where the amount shifted is; greater or equal to the promoted bit-width of the left hand side; or less than zero, or where the left hand side is negative. For a; signed left shift, also checks for signed overflow in C, and for; unsigned overflow in C++. You can use ``-fsanitize=shift-base`` or; ``-fsanitize=shift-exponent`` to check only left-hand side or; right-hand side of shift operation, respectively.; - ``-fsanitize=unsigned-shift-base``: check that an unsigned l",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:8954,Performance,perform,performed,8954,"pointer; from a function which is declared to never return null.; - ``-fsanitize=shift``: Shift operators where the amount shifted is; greater or equal to the promoted bit-width of the left hand side; or less than zero, or where the left hand side is negative. For a; signed left shift, also checks for signed overflow in C, and for; unsigned overflow in C++. You can use ``-fsanitize=shift-base`` or; ``-fsanitize=shift-exponent`` to check only left-hand side or; right-hand side of shift operation, respectively.; - ``-fsanitize=unsigned-shift-base``: check that an unsigned left-hand side of; a left shift operation doesn't overflow. Issues caught by this sanitizer are; not undefined behavior, but are often unintentional.; - ``-fsanitize=signed-integer-overflow``: Signed integer overflow, where the; result of a signed integer computation cannot be represented in its type.; This includes all the checks covered by ``-ftrapv``, as well as checks for; signed division overflow (``INT_MIN/-1``), but not checks for; lossy implicit conversions performed before the computation; (see ``-fsanitize=implicit-conversion``). Both of these two issues are; handled by ``-fsanitize=implicit-conversion`` group of checks.; - ``-fsanitize=unreachable``: If control flow reaches an unreachable; program point.; - ``-fsanitize=unsigned-integer-overflow``: Unsigned integer overflow, where; the result of an unsigned integer computation cannot be represented in its; type. Unlike signed integer overflow, this is not undefined behavior, but; it is often unintentional. This sanitizer does not check for lossy implicit; conversions performed before such a computation; (see ``-fsanitize=implicit-conversion``).; - ``-fsanitize=vla-bound``: A variable-length array whose bound; does not evaluate to a positive value.; - ``-fsanitize=vptr``: Use of an object whose vptr indicates that it is of; the wrong dynamic type, or that its lifetime has not begun or has ended.; Incompatible with ``-fno-rtti``. Link must be",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:9528,Performance,perform,performed,9528,"verflow. Issues caught by this sanitizer are; not undefined behavior, but are often unintentional.; - ``-fsanitize=signed-integer-overflow``: Signed integer overflow, where the; result of a signed integer computation cannot be represented in its type.; This includes all the checks covered by ``-ftrapv``, as well as checks for; signed division overflow (``INT_MIN/-1``), but not checks for; lossy implicit conversions performed before the computation; (see ``-fsanitize=implicit-conversion``). Both of these two issues are; handled by ``-fsanitize=implicit-conversion`` group of checks.; - ``-fsanitize=unreachable``: If control flow reaches an unreachable; program point.; - ``-fsanitize=unsigned-integer-overflow``: Unsigned integer overflow, where; the result of an unsigned integer computation cannot be represented in its; type. Unlike signed integer overflow, this is not undefined behavior, but; it is often unintentional. This sanitizer does not check for lossy implicit; conversions performed before such a computation; (see ``-fsanitize=implicit-conversion``).; - ``-fsanitize=vla-bound``: A variable-length array whose bound; does not evaluate to a positive value.; - ``-fsanitize=vptr``: Use of an object whose vptr indicates that it is of; the wrong dynamic type, or that its lifetime has not begun or has ended.; Incompatible with ``-fno-rtti``. Link must be performed by ``clang++``, not; ``clang``, to make sure C++-specific parts of the runtime library and C++; standard libraries are present. You can also use the following check groups:; - ``-fsanitize=undefined``: All of the checks listed above other than; ``float-divide-by-zero``, ``unsigned-integer-overflow``,; ``implicit-conversion``, ``local-bounds`` and the ``nullability-*`` group; of checks.; - ``-fsanitize=undefined-trap``: Deprecated alias of; ``-fsanitize=undefined``.; - ``-fsanitize=implicit-integer-truncation``: Catches lossy integral; conversions. Enables ``implicit-signed-integer-truncation`` and; ``implicit-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:9909,Performance,perform,performed,9909," the computation; (see ``-fsanitize=implicit-conversion``). Both of these two issues are; handled by ``-fsanitize=implicit-conversion`` group of checks.; - ``-fsanitize=unreachable``: If control flow reaches an unreachable; program point.; - ``-fsanitize=unsigned-integer-overflow``: Unsigned integer overflow, where; the result of an unsigned integer computation cannot be represented in its; type. Unlike signed integer overflow, this is not undefined behavior, but; it is often unintentional. This sanitizer does not check for lossy implicit; conversions performed before such a computation; (see ``-fsanitize=implicit-conversion``).; - ``-fsanitize=vla-bound``: A variable-length array whose bound; does not evaluate to a positive value.; - ``-fsanitize=vptr``: Use of an object whose vptr indicates that it is of; the wrong dynamic type, or that its lifetime has not begun or has ended.; Incompatible with ``-fno-rtti``. Link must be performed by ``clang++``, not; ``clang``, to make sure C++-specific parts of the runtime library and C++; standard libraries are present. You can also use the following check groups:; - ``-fsanitize=undefined``: All of the checks listed above other than; ``float-divide-by-zero``, ``unsigned-integer-overflow``,; ``implicit-conversion``, ``local-bounds`` and the ``nullability-*`` group; of checks.; - ``-fsanitize=undefined-trap``: Deprecated alias of; ``-fsanitize=undefined``.; - ``-fsanitize=implicit-integer-truncation``: Catches lossy integral; conversions. Enables ``implicit-signed-integer-truncation`` and; ``implicit-unsigned-integer-truncation``.; - ``-fsanitize=implicit-integer-arithmetic-value-change``: Catches implicit; conversions that change the arithmetic value of the integer. Enables; ``implicit-signed-integer-truncation`` and ``implicit-integer-sign-change``.; - ``-fsanitize=implicit-conversion``: Checks for suspicious; behavior of implicit conversions. Enables; ``implicit-unsigned-integer-truncation``,; ``implicit-signed-integer-trunc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:200,Safety,detect,detector,200,"==========================; UndefinedBehaviorSanitizer; ==========================. .. contents::; :local:. Introduction; ============. UndefinedBehaviorSanitizer (UBSan) is a fast undefined behavior detector.; UBSan modifies the program at compile-time to catch various kinds of undefined; behavior during program execution, for example:. * Array subscript out of bounds, where the bounds can be statically determined; * Bitwise shifts that are out of bounds for their data type; * Dereferencing misaligned or null pointers; * Signed integer overflow; * Conversion to, from, or between floating-point types which would; overflow the destination. See the full list of available :ref:`checks <ubsan-checks>` below. UBSan has an optional run-time library which provides better error reporting.; The checks have small runtime cost and no impact on address space layout or ABI. How to build; ============. Build LLVM/Clang with `CMake <https://llvm.org/docs/CMake.html>`_. Usage; =====. Use ``clang++`` to compile and link your program with the ``-fsanitize=undefined``; option. Make sure to use ``clang++`` (not ``ld``) as a linker, so that your; executable is linked with proper UBSan runtime libraries, unless all enabled; checks use trap mode. You can use ``clang`` instead of ``clang++`` if you're; compiling/linking C code. .. code-block:: console. % cat test.cc; int main(int argc, char **argv) {; int k = 0x7fffffff;; k += argc;; return 0;; }; % clang++ -fsanitize=undefined test.cc; % ./a.out; test.cc:3:5: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type 'int'. You can use ``-fsanitize=...`` and ``-fno-sanitize=`` to enable and disable one; check or one check group. For an individual check, the last option that enabling; or disabling it wins. .. code-block:: console. # Enable all checks in the ""undefined"" group, but disable ""alignment"".; % clang -fsanitize=undefined -fno-sanitize=alignment a.c. # Enable just ""alignment"".; % clang -fsanitize=alignment ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:2410,Safety,recover,recover,2410,"k = 0x7fffffff;; k += argc;; return 0;; }; % clang++ -fsanitize=undefined test.cc; % ./a.out; test.cc:3:5: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type 'int'. You can use ``-fsanitize=...`` and ``-fno-sanitize=`` to enable and disable one; check or one check group. For an individual check, the last option that enabling; or disabling it wins. .. code-block:: console. # Enable all checks in the ""undefined"" group, but disable ""alignment"".; % clang -fsanitize=undefined -fno-sanitize=alignment a.c. # Enable just ""alignment"".; % clang -fsanitize=alignment a.c. # The same. -fno-sanitize=undefined nullifies the previous -fsanitize=undefined.; % clang -fsanitize=undefined -fno-sanitize=undefined -fsanitize=alignment a.c. For most checks (:ref:`checks <ubsan-checks>`), the instrumented program prints; a verbose error report and continues execution upon a failed check.; You can use the following options to change the error reporting behavior:. * ``-fno-sanitize-recover=...``: print a verbose error report and exit the program;; * ``-fsanitize-trap=...``: execute a trap instruction (doesn't require UBSan; run-time support). If the signal is not caught, the program will typically; terminate due to a ``SIGILL`` or ``SIGTRAP`` signal. For example:. .. code-block:: console. % clang++ -fsanitize=signed-integer-overflow,null,alignment -fno-sanitize-recover=null -fsanitize-trap=alignment a.cc. The program will continue execution after signed integer overflows, exit after; the first invalid use of a null pointer, and trap after the first use of misaligned; pointer. .. code-block:: console. % clang++ -fsanitize=undefined -fsanitize-trap=all a.cc. All checks in the ""undefined"" group are put into trap mode. Since no check; needs run-time support, the UBSan run-time library it not linked. Note that; some other sanitizers also support trap mode and ``-fsanitize-trap=all``; enables trap mode for them. .. code-block:: console. % clang -fsanitize-trap=und",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:2797,Safety,recover,recover,2797,"it wins. .. code-block:: console. # Enable all checks in the ""undefined"" group, but disable ""alignment"".; % clang -fsanitize=undefined -fno-sanitize=alignment a.c. # Enable just ""alignment"".; % clang -fsanitize=alignment a.c. # The same. -fno-sanitize=undefined nullifies the previous -fsanitize=undefined.; % clang -fsanitize=undefined -fno-sanitize=undefined -fsanitize=alignment a.c. For most checks (:ref:`checks <ubsan-checks>`), the instrumented program prints; a verbose error report and continues execution upon a failed check.; You can use the following options to change the error reporting behavior:. * ``-fno-sanitize-recover=...``: print a verbose error report and exit the program;; * ``-fsanitize-trap=...``: execute a trap instruction (doesn't require UBSan; run-time support). If the signal is not caught, the program will typically; terminate due to a ``SIGILL`` or ``SIGTRAP`` signal. For example:. .. code-block:: console. % clang++ -fsanitize=signed-integer-overflow,null,alignment -fno-sanitize-recover=null -fsanitize-trap=alignment a.cc. The program will continue execution after signed integer overflows, exit after; the first invalid use of a null pointer, and trap after the first use of misaligned; pointer. .. code-block:: console. % clang++ -fsanitize=undefined -fsanitize-trap=all a.cc. All checks in the ""undefined"" group are put into trap mode. Since no check; needs run-time support, the UBSan run-time library it not linked. Note that; some other sanitizers also support trap mode and ``-fsanitize-trap=all``; enables trap mode for them. .. code-block:: console. % clang -fsanitize-trap=undefined -fsanitize-recover=all a.c. ``-fsanitize-trap=`` and ``-fsanitize-recover=`` are a no-op in the absence of; a ``-fsanitize=`` option. There is no unused command line option warning. .. _ubsan-checks:. Available checks; ================. Available checks are:. - ``-fsanitize=alignment``: Use of a misaligned pointer or creation; of a misaligned reference. Also sanitiz",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:3423,Safety,recover,recover,3423,"ze-recover=...``: print a verbose error report and exit the program;; * ``-fsanitize-trap=...``: execute a trap instruction (doesn't require UBSan; run-time support). If the signal is not caught, the program will typically; terminate due to a ``SIGILL`` or ``SIGTRAP`` signal. For example:. .. code-block:: console. % clang++ -fsanitize=signed-integer-overflow,null,alignment -fno-sanitize-recover=null -fsanitize-trap=alignment a.cc. The program will continue execution after signed integer overflows, exit after; the first invalid use of a null pointer, and trap after the first use of misaligned; pointer. .. code-block:: console. % clang++ -fsanitize=undefined -fsanitize-trap=all a.cc. All checks in the ""undefined"" group are put into trap mode. Since no check; needs run-time support, the UBSan run-time library it not linked. Note that; some other sanitizers also support trap mode and ``-fsanitize-trap=all``; enables trap mode for them. .. code-block:: console. % clang -fsanitize-trap=undefined -fsanitize-recover=all a.c. ``-fsanitize-trap=`` and ``-fsanitize-recover=`` are a no-op in the absence of; a ``-fsanitize=`` option. There is no unused command line option warning. .. _ubsan-checks:. Available checks; ================. Available checks are:. - ``-fsanitize=alignment``: Use of a misaligned pointer or creation; of a misaligned reference. Also sanitizes assume_aligned-like attributes.; - ``-fsanitize=bool``: Load of a ``bool`` value which is neither; ``true`` nor ``false``.; - ``-fsanitize=builtin``: Passing invalid values to compiler builtins.; - ``-fsanitize=bounds``: Out of bounds array indexing, in cases; where the array bound can be statically determined. The check includes; ``-fsanitize=array-bounds`` and ``-fsanitize=local-bounds``. Note that; ``-fsanitize=local-bounds`` is not included in ``-fsanitize=undefined``.; - ``-fsanitize=enum``: Load of a value of an enumerated type which; is not in the range of representable values for that enumerated; type.; - ``-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:3478,Safety,recover,recover,3478,"trap=...``: execute a trap instruction (doesn't require UBSan; run-time support). If the signal is not caught, the program will typically; terminate due to a ``SIGILL`` or ``SIGTRAP`` signal. For example:. .. code-block:: console. % clang++ -fsanitize=signed-integer-overflow,null,alignment -fno-sanitize-recover=null -fsanitize-trap=alignment a.cc. The program will continue execution after signed integer overflows, exit after; the first invalid use of a null pointer, and trap after the first use of misaligned; pointer. .. code-block:: console. % clang++ -fsanitize=undefined -fsanitize-trap=all a.cc. All checks in the ""undefined"" group are put into trap mode. Since no check; needs run-time support, the UBSan run-time library it not linked. Note that; some other sanitizers also support trap mode and ``-fsanitize-trap=all``; enables trap mode for them. .. code-block:: console. % clang -fsanitize-trap=undefined -fsanitize-recover=all a.c. ``-fsanitize-trap=`` and ``-fsanitize-recover=`` are a no-op in the absence of; a ``-fsanitize=`` option. There is no unused command line option warning. .. _ubsan-checks:. Available checks; ================. Available checks are:. - ``-fsanitize=alignment``: Use of a misaligned pointer or creation; of a misaligned reference. Also sanitizes assume_aligned-like attributes.; - ``-fsanitize=bool``: Load of a ``bool`` value which is neither; ``true`` nor ``false``.; - ``-fsanitize=builtin``: Passing invalid values to compiler builtins.; - ``-fsanitize=bounds``: Out of bounds array indexing, in cases; where the array bound can be statically determined. The check includes; ``-fsanitize=array-bounds`` and ``-fsanitize=local-bounds``. Note that; ``-fsanitize=local-bounds`` is not included in ``-fsanitize=undefined``.; - ``-fsanitize=enum``: Load of a value of an enumerated type which; is not in the range of representable values for that enumerated; type.; - ``-fsanitize=float-cast-overflow``: Conversion to, from, or; between floating-point type",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:4657,Safety,detect,detected,4657,"ecks; ================. Available checks are:. - ``-fsanitize=alignment``: Use of a misaligned pointer or creation; of a misaligned reference. Also sanitizes assume_aligned-like attributes.; - ``-fsanitize=bool``: Load of a ``bool`` value which is neither; ``true`` nor ``false``.; - ``-fsanitize=builtin``: Passing invalid values to compiler builtins.; - ``-fsanitize=bounds``: Out of bounds array indexing, in cases; where the array bound can be statically determined. The check includes; ``-fsanitize=array-bounds`` and ``-fsanitize=local-bounds``. Note that; ``-fsanitize=local-bounds`` is not included in ``-fsanitize=undefined``.; - ``-fsanitize=enum``: Load of a value of an enumerated type which; is not in the range of representable values for that enumerated; type.; - ``-fsanitize=float-cast-overflow``: Conversion to, from, or; between floating-point types which would overflow the; destination. Because the range of representable values for all; floating-point types supported by Clang is [-inf, +inf], the only; cases detected are conversions from floating point to integer types.; - ``-fsanitize=float-divide-by-zero``: Floating point division by; zero. This is undefined per the C and C++ standards, but is defined; by Clang (and by ISO/IEC/IEEE 60559 / IEEE 754) as producing either an; infinity or NaN value, so is not included in ``-fsanitize=undefined``.; - ``-fsanitize=function``: Indirect call of a function through a; function pointer of the wrong type.; - ``-fsanitize=implicit-unsigned-integer-truncation``,; ``-fsanitize=implicit-signed-integer-truncation``: Implicit conversion from; integer of larger bit width to smaller bit width, if that results in data; loss. That is, if the demoted value, after casting back to the original; width, is not equal to the original value before the downcast.; The ``-fsanitize=implicit-unsigned-integer-truncation`` handles conversions; between two ``unsigned`` types, while; ``-fsanitize=implicit-signed-integer-truncation`` handles the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:7198,Safety,detect,detect,7198,"er as a function; parameter which is declared to never be null.; - ``-fsanitize=null``: Use of a null pointer or creation of a null; reference.; - ``-fsanitize=nullability-arg``: Passing null as a function parameter; which is annotated with ``_Nonnull``.; - ``-fsanitize=nullability-assign``: Assigning null to an lvalue which; is annotated with ``_Nonnull``.; - ``-fsanitize=nullability-return``: Returning null from a function with; a return type annotated with ``_Nonnull``.; - ``-fsanitize=objc-cast``: Invalid implicit cast of an ObjC object pointer; to an incompatible type. This is often unintentional, but is not undefined; behavior, therefore the check is not a part of the ``undefined`` group.; Currently only supported on Darwin.; - ``-fsanitize=object-size``: An attempt to potentially use bytes which; the optimizer can determine are not part of the object being accessed.; This will also detect some types of undefined behavior that may not; directly access memory, but are provably incorrect given the size of; the objects involved, such as invalid downcasts and calling methods on; invalid pointers. These checks are made in terms of; ``__builtin_object_size``, and consequently may be able to detect more; problems at higher optimization levels.; - ``-fsanitize=pointer-overflow``: Performing pointer arithmetic which; overflows, or where either the old or new pointer value is a null pointer; (or in C, when they both are).; - ``-fsanitize=return``: In C++, reaching the end of a; value-returning function without returning a value.; - ``-fsanitize=returns-nonnull-attribute``: Returning null pointer; from a function which is declared to never return null.; - ``-fsanitize=shift``: Shift operators where the amount shifted is; greater or equal to the promoted bit-width of the left hand side; or less than zero, or where the left hand side is negative. For a; signed left shift, also checks for signed overflow in C, and for; unsigned overflow in C++. You can use ``-fsanitize=shif",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:7506,Safety,detect,detect,7506,"ull as a function parameter; which is annotated with ``_Nonnull``.; - ``-fsanitize=nullability-assign``: Assigning null to an lvalue which; is annotated with ``_Nonnull``.; - ``-fsanitize=nullability-return``: Returning null from a function with; a return type annotated with ``_Nonnull``.; - ``-fsanitize=objc-cast``: Invalid implicit cast of an ObjC object pointer; to an incompatible type. This is often unintentional, but is not undefined; behavior, therefore the check is not a part of the ``undefined`` group.; Currently only supported on Darwin.; - ``-fsanitize=object-size``: An attempt to potentially use bytes which; the optimizer can determine are not part of the object being accessed.; This will also detect some types of undefined behavior that may not; directly access memory, but are provably incorrect given the size of; the objects involved, such as invalid downcasts and calling methods on; invalid pointers. These checks are made in terms of; ``__builtin_object_size``, and consequently may be able to detect more; problems at higher optimization levels.; - ``-fsanitize=pointer-overflow``: Performing pointer arithmetic which; overflows, or where either the old or new pointer value is a null pointer; (or in C, when they both are).; - ``-fsanitize=return``: In C++, reaching the end of a; value-returning function without returning a value.; - ``-fsanitize=returns-nonnull-attribute``: Returning null pointer; from a function which is declared to never return null.; - ``-fsanitize=shift``: Shift operators where the amount shifted is; greater or equal to the promoted bit-width of the left hand side; or less than zero, or where the left hand side is negative. For a; signed left shift, also checks for signed overflow in C, and for; unsigned overflow in C++. You can use ``-fsanitize=shift-base`` or; ``-fsanitize=shift-exponent`` to check only left-hand side or; right-hand side of shift operation, respectively.; - ``-fsanitize=unsigned-shift-base``: check that an unsigned l",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:13110,Safety,recover,recover,13110,". For example, if you're used to compiling with; ``-fsanitize=undefined``, you could enable the minimal runtime with; ``-fsanitize=undefined -fsanitize-minimal-runtime``. Stack traces and report symbolization; =====================================; If you want UBSan to print symbolized stack trace for each error report, you; will need to:. #. Compile with ``-g`` and ``-fno-omit-frame-pointer`` to get proper debug; information in your binary.; #. Run your program with environment variable; ``UBSAN_OPTIONS=print_stacktrace=1``.; #. Make sure ``llvm-symbolizer`` binary is in ``PATH``. Logging; =======. The default log file for diagnostics is ""stderr"". To log diagnostics to another; file, you can set ``UBSAN_OPTIONS=log_path=...``. Silencing Unsigned Integer Overflow; ===================================; To silence reports from unsigned integer overflow, you can set; ``UBSAN_OPTIONS=silence_unsigned_overflow=1``. This feature, combined with; ``-fsanitize-recover=unsigned-integer-overflow``, is particularly useful for; providing fuzzing signal without blowing up logs. Issue Suppression; =================. UndefinedBehaviorSanitizer is not expected to produce false positives.; If you see one, look again; most likely it is a true positive!. Disabling Instrumentation with ``__attribute__((no_sanitize(""undefined"")))``; ----------------------------------------------------------------------------. You disable UBSan checks for particular functions with; ``__attribute__((no_sanitize(""undefined"")))``. You can use all values of; ``-fsanitize=`` flag in this attribute, e.g. if your function deliberately; contains possible signed integer overflow, you can use; ``__attribute__((no_sanitize(""signed-integer-overflow"")))``. This attribute may not be; supported by other compilers, so consider using it together with; ``#if defined(__clang__)``. Suppressing Errors in Recompiled Code (Ignorelist); --------------------------------------------------. UndefinedBehaviorSanitizer supports ``src``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:15126,Safety,recover,recoverable,15126,"iorSanitizer supports ``src`` and ``fun`` entity types in; :doc:`SanitizerSpecialCaseList`, that can be used to suppress error reports; in the specified source files or functions. Runtime suppressions; --------------------. Sometimes you can suppress UBSan error reports for specific files, functions,; or libraries without recompiling the code. You need to pass a path to; suppression file in a ``UBSAN_OPTIONS`` environment variable. .. code-block:: bash. UBSAN_OPTIONS=suppressions=MyUBSan.supp. You need to specify a :ref:`check <ubsan-checks>` you are suppressing and the; bug location. For example:. .. code-block:: bash. signed-integer-overflow:file-with-known-overflow.cpp; alignment:function_doing_unaligned_access; vptr:shared_object_with_vptr_failures.so. There are several limitations:. * Sometimes your binary must have enough debug info and/or symbol table, so; that the runtime could figure out source file or function name to match; against the suppression.; * It is only possible to suppress recoverable checks. For the example above,; you can additionally pass; ``-fsanitize-recover=signed-integer-overflow,alignment,vptr``, although; most of UBSan checks are recoverable by default.; * Check groups (like ``undefined``) can't be used in suppressions file, only; fine-grained checks are supported. Supported Platforms; ===================. UndefinedBehaviorSanitizer is supported on the following operating systems:. * Android; * Linux; * NetBSD; * FreeBSD; * OpenBSD; * macOS; * Windows. The runtime library is relatively portable and platform independent. If the OS; you need is not listed above, UndefinedBehaviorSanitizer may already work for; it, or could be made to work with a minor porting effort. Current Status; ==============. UndefinedBehaviorSanitizer is available on selected platforms starting from LLVM; 3.3. The test suite is integrated into the CMake build and can be run with; ``check-ubsan`` command. Additional Configuration; ========================. UndefinedB",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:15210,Safety,recover,recover,15210,"ppress error reports; in the specified source files or functions. Runtime suppressions; --------------------. Sometimes you can suppress UBSan error reports for specific files, functions,; or libraries without recompiling the code. You need to pass a path to; suppression file in a ``UBSAN_OPTIONS`` environment variable. .. code-block:: bash. UBSAN_OPTIONS=suppressions=MyUBSan.supp. You need to specify a :ref:`check <ubsan-checks>` you are suppressing and the; bug location. For example:. .. code-block:: bash. signed-integer-overflow:file-with-known-overflow.cpp; alignment:function_doing_unaligned_access; vptr:shared_object_with_vptr_failures.so. There are several limitations:. * Sometimes your binary must have enough debug info and/or symbol table, so; that the runtime could figure out source file or function name to match; against the suppression.; * It is only possible to suppress recoverable checks. For the example above,; you can additionally pass; ``-fsanitize-recover=signed-integer-overflow,alignment,vptr``, although; most of UBSan checks are recoverable by default.; * Check groups (like ``undefined``) can't be used in suppressions file, only; fine-grained checks are supported. Supported Platforms; ===================. UndefinedBehaviorSanitizer is supported on the following operating systems:. * Android; * Linux; * NetBSD; * FreeBSD; * OpenBSD; * macOS; * Windows. The runtime library is relatively portable and platform independent. If the OS; you need is not listed above, UndefinedBehaviorSanitizer may already work for; it, or could be made to work with a minor porting effort. Current Status; ==============. UndefinedBehaviorSanitizer is available on selected platforms starting from LLVM; 3.3. The test suite is integrated into the CMake build and can be run with; ``check-ubsan`` command. Additional Configuration; ========================. UndefinedBehaviorSanitizer adds static check data for each check unless it is; in trap mode. This check data includes the fu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:15295,Safety,recover,recoverable,15295,"ppress error reports; in the specified source files or functions. Runtime suppressions; --------------------. Sometimes you can suppress UBSan error reports for specific files, functions,; or libraries without recompiling the code. You need to pass a path to; suppression file in a ``UBSAN_OPTIONS`` environment variable. .. code-block:: bash. UBSAN_OPTIONS=suppressions=MyUBSan.supp. You need to specify a :ref:`check <ubsan-checks>` you are suppressing and the; bug location. For example:. .. code-block:: bash. signed-integer-overflow:file-with-known-overflow.cpp; alignment:function_doing_unaligned_access; vptr:shared_object_with_vptr_failures.so. There are several limitations:. * Sometimes your binary must have enough debug info and/or symbol table, so; that the runtime could figure out source file or function name to match; against the suppression.; * It is only possible to suppress recoverable checks. For the example above,; you can additionally pass; ``-fsanitize-recover=signed-integer-overflow,alignment,vptr``, although; most of UBSan checks are recoverable by default.; * Check groups (like ``undefined``) can't be used in suppressions file, only; fine-grained checks are supported. Supported Platforms; ===================. UndefinedBehaviorSanitizer is supported on the following operating systems:. * Android; * Linux; * NetBSD; * FreeBSD; * OpenBSD; * macOS; * Windows. The runtime library is relatively portable and platform independent. If the OS; you need is not listed above, UndefinedBehaviorSanitizer may already work for; it, or could be made to work with a minor porting effort. Current Status; ==============. UndefinedBehaviorSanitizer is available on selected platforms starting from LLVM; 3.3. The test suite is integrated into the CMake build and can be run with; ``check-ubsan`` command. Additional Configuration; ========================. UndefinedBehaviorSanitizer adds static check data for each check unless it is; in trap mode. This check data includes the fu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:1646,Security,sanitiz,sanitize,1646,"ilable :ref:`checks <ubsan-checks>` below. UBSan has an optional run-time library which provides better error reporting.; The checks have small runtime cost and no impact on address space layout or ABI. How to build; ============. Build LLVM/Clang with `CMake <https://llvm.org/docs/CMake.html>`_. Usage; =====. Use ``clang++`` to compile and link your program with the ``-fsanitize=undefined``; option. Make sure to use ``clang++`` (not ``ld``) as a linker, so that your; executable is linked with proper UBSan runtime libraries, unless all enabled; checks use trap mode. You can use ``clang`` instead of ``clang++`` if you're; compiling/linking C code. .. code-block:: console. % cat test.cc; int main(int argc, char **argv) {; int k = 0x7fffffff;; k += argc;; return 0;; }; % clang++ -fsanitize=undefined test.cc; % ./a.out; test.cc:3:5: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type 'int'. You can use ``-fsanitize=...`` and ``-fno-sanitize=`` to enable and disable one; check or one check group. For an individual check, the last option that enabling; or disabling it wins. .. code-block:: console. # Enable all checks in the ""undefined"" group, but disable ""alignment"".; % clang -fsanitize=undefined -fno-sanitize=alignment a.c. # Enable just ""alignment"".; % clang -fsanitize=alignment a.c. # The same. -fno-sanitize=undefined nullifies the previous -fsanitize=undefined.; % clang -fsanitize=undefined -fno-sanitize=undefined -fsanitize=alignment a.c. For most checks (:ref:`checks <ubsan-checks>`), the instrumented program prints; a verbose error report and continues execution upon a failed check.; You can use the following options to change the error reporting behavior:. * ``-fno-sanitize-recover=...``: print a verbose error report and exit the program;; * ``-fsanitize-trap=...``: execute a trap instruction (doesn't require UBSan; run-time support). If the signal is not caught, the program will typically; terminate due to a ``SIGILL`` or ``SIGTR",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:1920,Security,sanitiz,sanitize,1920,"/Clang with `CMake <https://llvm.org/docs/CMake.html>`_. Usage; =====. Use ``clang++`` to compile and link your program with the ``-fsanitize=undefined``; option. Make sure to use ``clang++`` (not ``ld``) as a linker, so that your; executable is linked with proper UBSan runtime libraries, unless all enabled; checks use trap mode. You can use ``clang`` instead of ``clang++`` if you're; compiling/linking C code. .. code-block:: console. % cat test.cc; int main(int argc, char **argv) {; int k = 0x7fffffff;; k += argc;; return 0;; }; % clang++ -fsanitize=undefined test.cc; % ./a.out; test.cc:3:5: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type 'int'. You can use ``-fsanitize=...`` and ``-fno-sanitize=`` to enable and disable one; check or one check group. For an individual check, the last option that enabling; or disabling it wins. .. code-block:: console. # Enable all checks in the ""undefined"" group, but disable ""alignment"".; % clang -fsanitize=undefined -fno-sanitize=alignment a.c. # Enable just ""alignment"".; % clang -fsanitize=alignment a.c. # The same. -fno-sanitize=undefined nullifies the previous -fsanitize=undefined.; % clang -fsanitize=undefined -fno-sanitize=undefined -fsanitize=alignment a.c. For most checks (:ref:`checks <ubsan-checks>`), the instrumented program prints; a verbose error report and continues execution upon a failed check.; You can use the following options to change the error reporting behavior:. * ``-fno-sanitize-recover=...``: print a verbose error report and exit the program;; * ``-fsanitize-trap=...``: execute a trap instruction (doesn't require UBSan; run-time support). If the signal is not caught, the program will typically; terminate due to a ``SIGILL`` or ``SIGTRAP`` signal. For example:. .. code-block:: console. % clang++ -fsanitize=signed-integer-overflow,null,alignment -fno-sanitize-recover=null -fsanitize-trap=alignment a.cc. The program will continue execution after signed integer overflows, exi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:2023,Security,sanitiz,sanitize,2023,"ze=undefined``; option. Make sure to use ``clang++`` (not ``ld``) as a linker, so that your; executable is linked with proper UBSan runtime libraries, unless all enabled; checks use trap mode. You can use ``clang`` instead of ``clang++`` if you're; compiling/linking C code. .. code-block:: console. % cat test.cc; int main(int argc, char **argv) {; int k = 0x7fffffff;; k += argc;; return 0;; }; % clang++ -fsanitize=undefined test.cc; % ./a.out; test.cc:3:5: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type 'int'. You can use ``-fsanitize=...`` and ``-fno-sanitize=`` to enable and disable one; check or one check group. For an individual check, the last option that enabling; or disabling it wins. .. code-block:: console. # Enable all checks in the ""undefined"" group, but disable ""alignment"".; % clang -fsanitize=undefined -fno-sanitize=alignment a.c. # Enable just ""alignment"".; % clang -fsanitize=alignment a.c. # The same. -fno-sanitize=undefined nullifies the previous -fsanitize=undefined.; % clang -fsanitize=undefined -fno-sanitize=undefined -fsanitize=alignment a.c. For most checks (:ref:`checks <ubsan-checks>`), the instrumented program prints; a verbose error report and continues execution upon a failed check.; You can use the following options to change the error reporting behavior:. * ``-fno-sanitize-recover=...``: print a verbose error report and exit the program;; * ``-fsanitize-trap=...``: execute a trap instruction (doesn't require UBSan; run-time support). If the signal is not caught, the program will typically; terminate due to a ``SIGILL`` or ``SIGTRAP`` signal. For example:. .. code-block:: console. % clang++ -fsanitize=signed-integer-overflow,null,alignment -fno-sanitize-recover=null -fsanitize-trap=alignment a.cc. The program will continue execution after signed integer overflows, exit after; the first invalid use of a null pointer, and trap after the first use of misaligned; pointer. .. code-block:: console. % clang++ -",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:2122,Security,sanitiz,sanitize,2122,"ker, so that your; executable is linked with proper UBSan runtime libraries, unless all enabled; checks use trap mode. You can use ``clang`` instead of ``clang++`` if you're; compiling/linking C code. .. code-block:: console. % cat test.cc; int main(int argc, char **argv) {; int k = 0x7fffffff;; k += argc;; return 0;; }; % clang++ -fsanitize=undefined test.cc; % ./a.out; test.cc:3:5: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type 'int'. You can use ``-fsanitize=...`` and ``-fno-sanitize=`` to enable and disable one; check or one check group. For an individual check, the last option that enabling; or disabling it wins. .. code-block:: console. # Enable all checks in the ""undefined"" group, but disable ""alignment"".; % clang -fsanitize=undefined -fno-sanitize=alignment a.c. # Enable just ""alignment"".; % clang -fsanitize=alignment a.c. # The same. -fno-sanitize=undefined nullifies the previous -fsanitize=undefined.; % clang -fsanitize=undefined -fno-sanitize=undefined -fsanitize=alignment a.c. For most checks (:ref:`checks <ubsan-checks>`), the instrumented program prints; a verbose error report and continues execution upon a failed check.; You can use the following options to change the error reporting behavior:. * ``-fno-sanitize-recover=...``: print a verbose error report and exit the program;; * ``-fsanitize-trap=...``: execute a trap instruction (doesn't require UBSan; run-time support). If the signal is not caught, the program will typically; terminate due to a ``SIGILL`` or ``SIGTRAP`` signal. For example:. .. code-block:: console. % clang++ -fsanitize=signed-integer-overflow,null,alignment -fno-sanitize-recover=null -fsanitize-trap=alignment a.cc. The program will continue execution after signed integer overflows, exit after; the first invalid use of a null pointer, and trap after the first use of misaligned; pointer. .. code-block:: console. % clang++ -fsanitize=undefined -fsanitize-trap=all a.cc. All checks in the ""undefine",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:2401,Security,sanitiz,sanitize-recover,2401,"k = 0x7fffffff;; k += argc;; return 0;; }; % clang++ -fsanitize=undefined test.cc; % ./a.out; test.cc:3:5: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type 'int'. You can use ``-fsanitize=...`` and ``-fno-sanitize=`` to enable and disable one; check or one check group. For an individual check, the last option that enabling; or disabling it wins. .. code-block:: console. # Enable all checks in the ""undefined"" group, but disable ""alignment"".; % clang -fsanitize=undefined -fno-sanitize=alignment a.c. # Enable just ""alignment"".; % clang -fsanitize=alignment a.c. # The same. -fno-sanitize=undefined nullifies the previous -fsanitize=undefined.; % clang -fsanitize=undefined -fno-sanitize=undefined -fsanitize=alignment a.c. For most checks (:ref:`checks <ubsan-checks>`), the instrumented program prints; a verbose error report and continues execution upon a failed check.; You can use the following options to change the error reporting behavior:. * ``-fno-sanitize-recover=...``: print a verbose error report and exit the program;; * ``-fsanitize-trap=...``: execute a trap instruction (doesn't require UBSan; run-time support). If the signal is not caught, the program will typically; terminate due to a ``SIGILL`` or ``SIGTRAP`` signal. For example:. .. code-block:: console. % clang++ -fsanitize=signed-integer-overflow,null,alignment -fno-sanitize-recover=null -fsanitize-trap=alignment a.cc. The program will continue execution after signed integer overflows, exit after; the first invalid use of a null pointer, and trap after the first use of misaligned; pointer. .. code-block:: console. % clang++ -fsanitize=undefined -fsanitize-trap=all a.cc. All checks in the ""undefined"" group are put into trap mode. Since no check; needs run-time support, the UBSan run-time library it not linked. Note that; some other sanitizers also support trap mode and ``-fsanitize-trap=all``; enables trap mode for them. .. code-block:: console. % clang -fsanitize-trap=und",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:2788,Security,sanitiz,sanitize-recover,2788,"it wins. .. code-block:: console. # Enable all checks in the ""undefined"" group, but disable ""alignment"".; % clang -fsanitize=undefined -fno-sanitize=alignment a.c. # Enable just ""alignment"".; % clang -fsanitize=alignment a.c. # The same. -fno-sanitize=undefined nullifies the previous -fsanitize=undefined.; % clang -fsanitize=undefined -fno-sanitize=undefined -fsanitize=alignment a.c. For most checks (:ref:`checks <ubsan-checks>`), the instrumented program prints; a verbose error report and continues execution upon a failed check.; You can use the following options to change the error reporting behavior:. * ``-fno-sanitize-recover=...``: print a verbose error report and exit the program;; * ``-fsanitize-trap=...``: execute a trap instruction (doesn't require UBSan; run-time support). If the signal is not caught, the program will typically; terminate due to a ``SIGILL`` or ``SIGTRAP`` signal. For example:. .. code-block:: console. % clang++ -fsanitize=signed-integer-overflow,null,alignment -fno-sanitize-recover=null -fsanitize-trap=alignment a.cc. The program will continue execution after signed integer overflows, exit after; the first invalid use of a null pointer, and trap after the first use of misaligned; pointer. .. code-block:: console. % clang++ -fsanitize=undefined -fsanitize-trap=all a.cc. All checks in the ""undefined"" group are put into trap mode. Since no check; needs run-time support, the UBSan run-time library it not linked. Note that; some other sanitizers also support trap mode and ``-fsanitize-trap=all``; enables trap mode for them. .. code-block:: console. % clang -fsanitize-trap=undefined -fsanitize-recover=all a.c. ``-fsanitize-trap=`` and ``-fsanitize-recover=`` are a no-op in the absence of; a ``-fsanitize=`` option. There is no unused command line option warning. .. _ubsan-checks:. Available checks; ================. Available checks are:. - ``-fsanitize=alignment``: Use of a misaligned pointer or creation; of a misaligned reference. Also sanitiz",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:3262,Security,sanitiz,sanitizers,3262,"upon a failed check.; You can use the following options to change the error reporting behavior:. * ``-fno-sanitize-recover=...``: print a verbose error report and exit the program;; * ``-fsanitize-trap=...``: execute a trap instruction (doesn't require UBSan; run-time support). If the signal is not caught, the program will typically; terminate due to a ``SIGILL`` or ``SIGTRAP`` signal. For example:. .. code-block:: console. % clang++ -fsanitize=signed-integer-overflow,null,alignment -fno-sanitize-recover=null -fsanitize-trap=alignment a.cc. The program will continue execution after signed integer overflows, exit after; the first invalid use of a null pointer, and trap after the first use of misaligned; pointer. .. code-block:: console. % clang++ -fsanitize=undefined -fsanitize-trap=all a.cc. All checks in the ""undefined"" group are put into trap mode. Since no check; needs run-time support, the UBSan run-time library it not linked. Note that; some other sanitizers also support trap mode and ``-fsanitize-trap=all``; enables trap mode for them. .. code-block:: console. % clang -fsanitize-trap=undefined -fsanitize-recover=all a.c. ``-fsanitize-trap=`` and ``-fsanitize-recover=`` are a no-op in the absence of; a ``-fsanitize=`` option. There is no unused command line option warning. .. _ubsan-checks:. Available checks; ================. Available checks are:. - ``-fsanitize=alignment``: Use of a misaligned pointer or creation; of a misaligned reference. Also sanitizes assume_aligned-like attributes.; - ``-fsanitize=bool``: Load of a ``bool`` value which is neither; ``true`` nor ``false``.; - ``-fsanitize=builtin``: Passing invalid values to compiler builtins.; - ``-fsanitize=bounds``: Out of bounds array indexing, in cases; where the array bound can be statically determined. The check includes; ``-fsanitize=array-bounds`` and ``-fsanitize=local-bounds``. Note that; ``-fsanitize=local-bounds`` is not included in ``-fsanitize=undefined``.; - ``-fsanitize=enum``: Load of a v",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:3773,Security,sanitiz,sanitizes,3773,"nitize-recover=null -fsanitize-trap=alignment a.cc. The program will continue execution after signed integer overflows, exit after; the first invalid use of a null pointer, and trap after the first use of misaligned; pointer. .. code-block:: console. % clang++ -fsanitize=undefined -fsanitize-trap=all a.cc. All checks in the ""undefined"" group are put into trap mode. Since no check; needs run-time support, the UBSan run-time library it not linked. Note that; some other sanitizers also support trap mode and ``-fsanitize-trap=all``; enables trap mode for them. .. code-block:: console. % clang -fsanitize-trap=undefined -fsanitize-recover=all a.c. ``-fsanitize-trap=`` and ``-fsanitize-recover=`` are a no-op in the absence of; a ``-fsanitize=`` option. There is no unused command line option warning. .. _ubsan-checks:. Available checks; ================. Available checks are:. - ``-fsanitize=alignment``: Use of a misaligned pointer or creation; of a misaligned reference. Also sanitizes assume_aligned-like attributes.; - ``-fsanitize=bool``: Load of a ``bool`` value which is neither; ``true`` nor ``false``.; - ``-fsanitize=builtin``: Passing invalid values to compiler builtins.; - ``-fsanitize=bounds``: Out of bounds array indexing, in cases; where the array bound can be statically determined. The check includes; ``-fsanitize=array-bounds`` and ``-fsanitize=local-bounds``. Note that; ``-fsanitize=local-bounds`` is not included in ``-fsanitize=undefined``.; - ``-fsanitize=enum``: Load of a value of an enumerated type which; is not in the range of representable values for that enumerated; type.; - ``-fsanitize=float-cast-overflow``: Conversion to, from, or; between floating-point types which would overflow the; destination. Because the range of representable values for all; floating-point types supported by Clang is [-inf, +inf], the only; cases detected are conversions from floating point to integer types.; - ``-fsanitize=float-divide-by-zero``: Floating point division by; zer",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:5728,Security,sanitiz,sanitizers,5728,"by-zero``: Floating point division by; zero. This is undefined per the C and C++ standards, but is defined; by Clang (and by ISO/IEC/IEEE 60559 / IEEE 754) as producing either an; infinity or NaN value, so is not included in ``-fsanitize=undefined``.; - ``-fsanitize=function``: Indirect call of a function through a; function pointer of the wrong type.; - ``-fsanitize=implicit-unsigned-integer-truncation``,; ``-fsanitize=implicit-signed-integer-truncation``: Implicit conversion from; integer of larger bit width to smaller bit width, if that results in data; loss. That is, if the demoted value, after casting back to the original; width, is not equal to the original value before the downcast.; The ``-fsanitize=implicit-unsigned-integer-truncation`` handles conversions; between two ``unsigned`` types, while; ``-fsanitize=implicit-signed-integer-truncation`` handles the rest of the; conversions - when either one, or both of the types are signed.; Issues caught by these sanitizers are not undefined behavior,; but are often unintentional.; - ``-fsanitize=implicit-integer-sign-change``: Implicit conversion between; integer types, if that changes the sign of the value. That is, if the; original value was negative and the new value is positive (or zero),; or the original value was positive, and the new value is negative.; Issues caught by this sanitizer are not undefined behavior,; but are often unintentional.; - ``-fsanitize=integer-divide-by-zero``: Integer division by zero.; - ``-fsanitize=nonnull-attribute``: Passing null pointer as a function; parameter which is declared to never be null.; - ``-fsanitize=null``: Use of a null pointer or creation of a null; reference.; - ``-fsanitize=nullability-arg``: Passing null as a function parameter; which is annotated with ``_Nonnull``.; - ``-fsanitize=nullability-assign``: Assigning null to an lvalue which; is annotated with ``_Nonnull``.; - ``-fsanitize=nullability-return``: Returning null from a function with; a return type annot",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:6105,Security,sanitiz,sanitizer,6105,"t-unsigned-integer-truncation``,; ``-fsanitize=implicit-signed-integer-truncation``: Implicit conversion from; integer of larger bit width to smaller bit width, if that results in data; loss. That is, if the demoted value, after casting back to the original; width, is not equal to the original value before the downcast.; The ``-fsanitize=implicit-unsigned-integer-truncation`` handles conversions; between two ``unsigned`` types, while; ``-fsanitize=implicit-signed-integer-truncation`` handles the rest of the; conversions - when either one, or both of the types are signed.; Issues caught by these sanitizers are not undefined behavior,; but are often unintentional.; - ``-fsanitize=implicit-integer-sign-change``: Implicit conversion between; integer types, if that changes the sign of the value. That is, if the; original value was negative and the new value is positive (or zero),; or the original value was positive, and the new value is negative.; Issues caught by this sanitizer are not undefined behavior,; but are often unintentional.; - ``-fsanitize=integer-divide-by-zero``: Integer division by zero.; - ``-fsanitize=nonnull-attribute``: Passing null pointer as a function; parameter which is declared to never be null.; - ``-fsanitize=null``: Use of a null pointer or creation of a null; reference.; - ``-fsanitize=nullability-arg``: Passing null as a function parameter; which is annotated with ``_Nonnull``.; - ``-fsanitize=nullability-assign``: Assigning null to an lvalue which; is annotated with ``_Nonnull``.; - ``-fsanitize=nullability-return``: Returning null from a function with; a return type annotated with ``_Nonnull``.; - ``-fsanitize=objc-cast``: Invalid implicit cast of an ObjC object pointer; to an incompatible type. This is often unintentional, but is not undefined; behavior, therefore the check is not a part of the ``undefined`` group.; Currently only supported on Darwin.; - ``-fsanitize=object-size``: An attempt to potentially use bytes which; the optimizer ca",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:7172,Security,access,accessed,7172,"itizer are not undefined behavior,; but are often unintentional.; - ``-fsanitize=integer-divide-by-zero``: Integer division by zero.; - ``-fsanitize=nonnull-attribute``: Passing null pointer as a function; parameter which is declared to never be null.; - ``-fsanitize=null``: Use of a null pointer or creation of a null; reference.; - ``-fsanitize=nullability-arg``: Passing null as a function parameter; which is annotated with ``_Nonnull``.; - ``-fsanitize=nullability-assign``: Assigning null to an lvalue which; is annotated with ``_Nonnull``.; - ``-fsanitize=nullability-return``: Returning null from a function with; a return type annotated with ``_Nonnull``.; - ``-fsanitize=objc-cast``: Invalid implicit cast of an ObjC object pointer; to an incompatible type. This is often unintentional, but is not undefined; behavior, therefore the check is not a part of the ``undefined`` group.; Currently only supported on Darwin.; - ``-fsanitize=object-size``: An attempt to potentially use bytes which; the optimizer can determine are not part of the object being accessed.; This will also detect some types of undefined behavior that may not; directly access memory, but are provably incorrect given the size of; the objects involved, such as invalid downcasts and calling methods on; invalid pointers. These checks are made in terms of; ``__builtin_object_size``, and consequently may be able to detect more; problems at higher optimization levels.; - ``-fsanitize=pointer-overflow``: Performing pointer arithmetic which; overflows, or where either the old or new pointer value is a null pointer; (or in C, when they both are).; - ``-fsanitize=return``: In C++, reaching the end of a; value-returning function without returning a value.; - ``-fsanitize=returns-nonnull-attribute``: Returning null pointer; from a function which is declared to never return null.; - ``-fsanitize=shift``: Shift operators where the amount shifted is; greater or equal to the promoted bit-width of the left hand side; o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:7261,Security,access,access,7261,"er as a function; parameter which is declared to never be null.; - ``-fsanitize=null``: Use of a null pointer or creation of a null; reference.; - ``-fsanitize=nullability-arg``: Passing null as a function parameter; which is annotated with ``_Nonnull``.; - ``-fsanitize=nullability-assign``: Assigning null to an lvalue which; is annotated with ``_Nonnull``.; - ``-fsanitize=nullability-return``: Returning null from a function with; a return type annotated with ``_Nonnull``.; - ``-fsanitize=objc-cast``: Invalid implicit cast of an ObjC object pointer; to an incompatible type. This is often unintentional, but is not undefined; behavior, therefore the check is not a part of the ``undefined`` group.; Currently only supported on Darwin.; - ``-fsanitize=object-size``: An attempt to potentially use bytes which; the optimizer can determine are not part of the object being accessed.; This will also detect some types of undefined behavior that may not; directly access memory, but are provably incorrect given the size of; the objects involved, such as invalid downcasts and calling methods on; invalid pointers. These checks are made in terms of; ``__builtin_object_size``, and consequently may be able to detect more; problems at higher optimization levels.; - ``-fsanitize=pointer-overflow``: Performing pointer arithmetic which; overflows, or where either the old or new pointer value is a null pointer; (or in C, when they both are).; - ``-fsanitize=return``: In C++, reaching the end of a; value-returning function without returning a value.; - ``-fsanitize=returns-nonnull-attribute``: Returning null pointer; from a function which is declared to never return null.; - ``-fsanitize=shift``: Shift operators where the amount shifted is; greater or equal to the promoted bit-width of the left hand side; or less than zero, or where the left hand side is negative. For a; signed left shift, also checks for signed overflow in C, and for; unsigned overflow in C++. You can use ``-fsanitize=shif",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:8566,Security,sanitiz,sanitizer,8566,"low``: Performing pointer arithmetic which; overflows, or where either the old or new pointer value is a null pointer; (or in C, when they both are).; - ``-fsanitize=return``: In C++, reaching the end of a; value-returning function without returning a value.; - ``-fsanitize=returns-nonnull-attribute``: Returning null pointer; from a function which is declared to never return null.; - ``-fsanitize=shift``: Shift operators where the amount shifted is; greater or equal to the promoted bit-width of the left hand side; or less than zero, or where the left hand side is negative. For a; signed left shift, also checks for signed overflow in C, and for; unsigned overflow in C++. You can use ``-fsanitize=shift-base`` or; ``-fsanitize=shift-exponent`` to check only left-hand side or; right-hand side of shift operation, respectively.; - ``-fsanitize=unsigned-shift-base``: check that an unsigned left-hand side of; a left shift operation doesn't overflow. Issues caught by this sanitizer are; not undefined behavior, but are often unintentional.; - ``-fsanitize=signed-integer-overflow``: Signed integer overflow, where the; result of a signed integer computation cannot be represented in its type.; This includes all the checks covered by ``-ftrapv``, as well as checks for; signed division overflow (``INT_MIN/-1``), but not checks for; lossy implicit conversions performed before the computation; (see ``-fsanitize=implicit-conversion``). Both of these two issues are; handled by ``-fsanitize=implicit-conversion`` group of checks.; - ``-fsanitize=unreachable``: If control flow reaches an unreachable; program point.; - ``-fsanitize=unsigned-integer-overflow``: Unsigned integer overflow, where; the result of an unsigned integer computation cannot be represented in its; type. Unlike signed integer overflow, this is not undefined behavior, but; it is often unintentional. This sanitizer does not check for lossy implicit; conversions performed before such a computation; (see ``-fsanitize=impli",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:9471,Security,sanitiz,sanitizer,9471,"verflow. Issues caught by this sanitizer are; not undefined behavior, but are often unintentional.; - ``-fsanitize=signed-integer-overflow``: Signed integer overflow, where the; result of a signed integer computation cannot be represented in its type.; This includes all the checks covered by ``-ftrapv``, as well as checks for; signed division overflow (``INT_MIN/-1``), but not checks for; lossy implicit conversions performed before the computation; (see ``-fsanitize=implicit-conversion``). Both of these two issues are; handled by ``-fsanitize=implicit-conversion`` group of checks.; - ``-fsanitize=unreachable``: If control flow reaches an unreachable; program point.; - ``-fsanitize=unsigned-integer-overflow``: Unsigned integer overflow, where; the result of an unsigned integer computation cannot be represented in its; type. Unlike signed integer overflow, this is not undefined behavior, but; it is often unintentional. This sanitizer does not check for lossy implicit; conversions performed before such a computation; (see ``-fsanitize=implicit-conversion``).; - ``-fsanitize=vla-bound``: A variable-length array whose bound; does not evaluate to a positive value.; - ``-fsanitize=vptr``: Use of an object whose vptr indicates that it is of; the wrong dynamic type, or that its lifetime has not begun or has ended.; Incompatible with ``-fno-rtti``. Link must be performed by ``clang++``, not; ``clang``, to make sure C++-specific parts of the runtime library and C++; standard libraries are present. You can also use the following check groups:; - ``-fsanitize=undefined``: All of the checks listed above other than; ``float-divide-by-zero``, ``unsigned-integer-overflow``,; ``implicit-conversion``, ``local-bounds`` and the ``nullability-*`` group; of checks.; - ``-fsanitize=undefined-trap``: Deprecated alias of; ``-fsanitize=undefined``.; - ``-fsanitize=implicit-integer-truncation``: Catches lossy integral; conversions. Enables ``implicit-signed-integer-truncation`` and; ``implicit-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:11918,Security,attack,attack,11918,"gned-integer-truncation``,; ``implicit-signed-integer-truncation``, and; ``implicit-integer-sign-change``.; - ``-fsanitize=integer``: Checks for undefined or suspicious integer; behavior (e.g. unsigned integer overflow).; Enables ``signed-integer-overflow``, ``unsigned-integer-overflow``,; ``shift``, ``integer-divide-by-zero``,; ``implicit-unsigned-integer-truncation``,; ``implicit-signed-integer-truncation``, and; ``implicit-integer-sign-change``.; - ``-fsanitize=nullability``: Enables ``nullability-arg``,; ``nullability-assign``, and ``nullability-return``. While violating; nullability does not have undefined behavior, it is often unintentional,; so UBSan offers to catch it. Volatile; --------. The ``null``, ``alignment``, ``object-size``, ``local-bounds``, and ``vptr`` checks do not apply; to pointers to types with the ``volatile`` qualifier. Minimal Runtime; ===============. There is a minimal UBSan runtime available suitable for use in production; environments. This runtime has a small attack surface. It only provides very; basic issue logging and deduplication, and does not support ``-fsanitize=vptr``; checking. To use the minimal runtime, add ``-fsanitize-minimal-runtime`` to the clang; command line options. For example, if you're used to compiling with; ``-fsanitize=undefined``, you could enable the minimal runtime with; ``-fsanitize=undefined -fsanitize-minimal-runtime``. Stack traces and report symbolization; =====================================; If you want UBSan to print symbolized stack trace for each error report, you; will need to:. #. Compile with ``-g`` and ``-fno-omit-frame-pointer`` to get proper debug; information in your binary.; #. Run your program with environment variable; ``UBSAN_OPTIONS=print_stacktrace=1``.; #. Make sure ``llvm-symbolizer`` binary is in ``PATH``. Logging; =======. The default log file for diagnostics is ""stderr"". To log diagnostics to another; file, you can set ``UBSAN_OPTIONS=log_path=...``. Silencing Unsigned Integer Ove",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:17271,Security,secur,security-with-undefinedbehaviorsanitizer-ubsan-and-gcc,17271,"me library is relatively portable and platform independent. If the OS; you need is not listed above, UndefinedBehaviorSanitizer may already work for; it, or could be made to work with a minor porting effort. Current Status; ==============. UndefinedBehaviorSanitizer is available on selected platforms starting from LLVM; 3.3. The test suite is integrated into the CMake build and can be run with; ``check-ubsan`` command. Additional Configuration; ========================. UndefinedBehaviorSanitizer adds static check data for each check unless it is; in trap mode. This check data includes the full file name. The option; ``-fsanitize-undefined-strip-path-components=N`` can be used to trim this; information. If ``N`` is positive, file information emitted by; UndefinedBehaviorSanitizer will drop the first ``N`` components from the file; path. If ``N`` is negative, the last ``N`` components will be kept. Example; -------. For a file called ``/code/library/file.cpp``, here is what would be emitted:. * Default (No flag, or ``-fsanitize-undefined-strip-path-components=0``): ``/code/library/file.cpp``; * ``-fsanitize-undefined-strip-path-components=1``: ``code/library/file.cpp``; * ``-fsanitize-undefined-strip-path-components=2``: ``library/file.cpp``; * ``-fsanitize-undefined-strip-path-components=-1``: ``file.cpp``; * ``-fsanitize-undefined-strip-path-components=-2``: ``library/file.cpp``. More Information; ================. * From Oracle blog, including a discussion of error messages:; `Improving Application Security with UndefinedBehaviorSanitizer (UBSan) and GCC; <https://blogs.oracle.com/linux/improving-application-security-with-undefinedbehaviorsanitizer-ubsan-and-gcc>`_; * From LLVM project blog:; `What Every C Programmer Should Know About Undefined Behavior; <http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html>`_; * From John Regehr's *Embedded in Academia* blog:; `A Guide to Undefined Behavior in C and C++; <https://blog.regehr.org/archives/213>`_; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:1357,Testability,test,test,1357,"t out of bounds, where the bounds can be statically determined; * Bitwise shifts that are out of bounds for their data type; * Dereferencing misaligned or null pointers; * Signed integer overflow; * Conversion to, from, or between floating-point types which would; overflow the destination. See the full list of available :ref:`checks <ubsan-checks>` below. UBSan has an optional run-time library which provides better error reporting.; The checks have small runtime cost and no impact on address space layout or ABI. How to build; ============. Build LLVM/Clang with `CMake <https://llvm.org/docs/CMake.html>`_. Usage; =====. Use ``clang++`` to compile and link your program with the ``-fsanitize=undefined``; option. Make sure to use ``clang++`` (not ``ld``) as a linker, so that your; executable is linked with proper UBSan runtime libraries, unless all enabled; checks use trap mode. You can use ``clang`` instead of ``clang++`` if you're; compiling/linking C code. .. code-block:: console. % cat test.cc; int main(int argc, char **argv) {; int k = 0x7fffffff;; k += argc;; return 0;; }; % clang++ -fsanitize=undefined test.cc; % ./a.out; test.cc:3:5: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type 'int'. You can use ``-fsanitize=...`` and ``-fno-sanitize=`` to enable and disable one; check or one check group. For an individual check, the last option that enabling; or disabling it wins. .. code-block:: console. # Enable all checks in the ""undefined"" group, but disable ""alignment"".; % clang -fsanitize=undefined -fno-sanitize=alignment a.c. # Enable just ""alignment"".; % clang -fsanitize=alignment a.c. # The same. -fno-sanitize=undefined nullifies the previous -fsanitize=undefined.; % clang -fsanitize=undefined -fno-sanitize=undefined -fsanitize=alignment a.c. For most checks (:ref:`checks <ubsan-checks>`), the instrumented program prints; a verbose error report and continues execution upon a failed check.; You can use the following options to ch",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:1479,Testability,test,test,1479,"itwise shifts that are out of bounds for their data type; * Dereferencing misaligned or null pointers; * Signed integer overflow; * Conversion to, from, or between floating-point types which would; overflow the destination. See the full list of available :ref:`checks <ubsan-checks>` below. UBSan has an optional run-time library which provides better error reporting.; The checks have small runtime cost and no impact on address space layout or ABI. How to build; ============. Build LLVM/Clang with `CMake <https://llvm.org/docs/CMake.html>`_. Usage; =====. Use ``clang++`` to compile and link your program with the ``-fsanitize=undefined``; option. Make sure to use ``clang++`` (not ``ld``) as a linker, so that your; executable is linked with proper UBSan runtime libraries, unless all enabled; checks use trap mode. You can use ``clang`` instead of ``clang++`` if you're; compiling/linking C code. .. code-block:: console. % cat test.cc; int main(int argc, char **argv) {; int k = 0x7fffffff;; k += argc;; return 0;; }; % clang++ -fsanitize=undefined test.cc; % ./a.out; test.cc:3:5: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type 'int'. You can use ``-fsanitize=...`` and ``-fno-sanitize=`` to enable and disable one; check or one check group. For an individual check, the last option that enabling; or disabling it wins. .. code-block:: console. # Enable all checks in the ""undefined"" group, but disable ""alignment"".; % clang -fsanitize=undefined -fno-sanitize=alignment a.c. # Enable just ""alignment"".; % clang -fsanitize=alignment a.c. # The same. -fno-sanitize=undefined nullifies the previous -fsanitize=undefined.; % clang -fsanitize=undefined -fno-sanitize=undefined -fsanitize=alignment a.c. For most checks (:ref:`checks <ubsan-checks>`), the instrumented program prints; a verbose error report and continues execution upon a failed check.; You can use the following options to change the error reporting behavior:. * ``-fno-sanitize-recover=...``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:1499,Testability,test,test,1499,"saligned or null pointers; * Signed integer overflow; * Conversion to, from, or between floating-point types which would; overflow the destination. See the full list of available :ref:`checks <ubsan-checks>` below. UBSan has an optional run-time library which provides better error reporting.; The checks have small runtime cost and no impact on address space layout or ABI. How to build; ============. Build LLVM/Clang with `CMake <https://llvm.org/docs/CMake.html>`_. Usage; =====. Use ``clang++`` to compile and link your program with the ``-fsanitize=undefined``; option. Make sure to use ``clang++`` (not ``ld``) as a linker, so that your; executable is linked with proper UBSan runtime libraries, unless all enabled; checks use trap mode. You can use ``clang`` instead of ``clang++`` if you're; compiling/linking C code. .. code-block:: console. % cat test.cc; int main(int argc, char **argv) {; int k = 0x7fffffff;; k += argc;; return 0;; }; % clang++ -fsanitize=undefined test.cc; % ./a.out; test.cc:3:5: runtime error: signed integer overflow: 2147483647 + 1 cannot be represented in type 'int'. You can use ``-fsanitize=...`` and ``-fno-sanitize=`` to enable and disable one; check or one check group. For an individual check, the last option that enabling; or disabling it wins. .. code-block:: console. # Enable all checks in the ""undefined"" group, but disable ""alignment"".; % clang -fsanitize=undefined -fno-sanitize=alignment a.c. # Enable just ""alignment"".; % clang -fsanitize=alignment a.c. # The same. -fno-sanitize=undefined nullifies the previous -fsanitize=undefined.; % clang -fsanitize=undefined -fno-sanitize=undefined -fsanitize=alignment a.c. For most checks (:ref:`checks <ubsan-checks>`), the instrumented program prints; a verbose error report and continues execution upon a failed check.; You can use the following options to change the error reporting behavior:. * ``-fno-sanitize-recover=...``: print a verbose error report and exit the program;; * ``-fsanitize-trap=..",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:11969,Testability,log,logging,11969,"licit-integer-sign-change``.; - ``-fsanitize=integer``: Checks for undefined or suspicious integer; behavior (e.g. unsigned integer overflow).; Enables ``signed-integer-overflow``, ``unsigned-integer-overflow``,; ``shift``, ``integer-divide-by-zero``,; ``implicit-unsigned-integer-truncation``,; ``implicit-signed-integer-truncation``, and; ``implicit-integer-sign-change``.; - ``-fsanitize=nullability``: Enables ``nullability-arg``,; ``nullability-assign``, and ``nullability-return``. While violating; nullability does not have undefined behavior, it is often unintentional,; so UBSan offers to catch it. Volatile; --------. The ``null``, ``alignment``, ``object-size``, ``local-bounds``, and ``vptr`` checks do not apply; to pointers to types with the ``volatile`` qualifier. Minimal Runtime; ===============. There is a minimal UBSan runtime available suitable for use in production; environments. This runtime has a small attack surface. It only provides very; basic issue logging and deduplication, and does not support ``-fsanitize=vptr``; checking. To use the minimal runtime, add ``-fsanitize-minimal-runtime`` to the clang; command line options. For example, if you're used to compiling with; ``-fsanitize=undefined``, you could enable the minimal runtime with; ``-fsanitize=undefined -fsanitize-minimal-runtime``. Stack traces and report symbolization; =====================================; If you want UBSan to print symbolized stack trace for each error report, you; will need to:. #. Compile with ``-g`` and ``-fno-omit-frame-pointer`` to get proper debug; information in your binary.; #. Run your program with environment variable; ``UBSAN_OPTIONS=print_stacktrace=1``.; #. Make sure ``llvm-symbolizer`` binary is in ``PATH``. Logging; =======. The default log file for diagnostics is ""stderr"". To log diagnostics to another; file, you can set ``UBSAN_OPTIONS=log_path=...``. Silencing Unsigned Integer Overflow; ===================================; To silence reports from unsigned ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:12764,Testability,log,log,12764,"l Runtime; ===============. There is a minimal UBSan runtime available suitable for use in production; environments. This runtime has a small attack surface. It only provides very; basic issue logging and deduplication, and does not support ``-fsanitize=vptr``; checking. To use the minimal runtime, add ``-fsanitize-minimal-runtime`` to the clang; command line options. For example, if you're used to compiling with; ``-fsanitize=undefined``, you could enable the minimal runtime with; ``-fsanitize=undefined -fsanitize-minimal-runtime``. Stack traces and report symbolization; =====================================; If you want UBSan to print symbolized stack trace for each error report, you; will need to:. #. Compile with ``-g`` and ``-fno-omit-frame-pointer`` to get proper debug; information in your binary.; #. Run your program with environment variable; ``UBSAN_OPTIONS=print_stacktrace=1``.; #. Make sure ``llvm-symbolizer`` binary is in ``PATH``. Logging; =======. The default log file for diagnostics is ""stderr"". To log diagnostics to another; file, you can set ``UBSAN_OPTIONS=log_path=...``. Silencing Unsigned Integer Overflow; ===================================; To silence reports from unsigned integer overflow, you can set; ``UBSAN_OPTIONS=silence_unsigned_overflow=1``. This feature, combined with; ``-fsanitize-recover=unsigned-integer-overflow``, is particularly useful for; providing fuzzing signal without blowing up logs. Issue Suppression; =================. UndefinedBehaviorSanitizer is not expected to produce false positives.; If you see one, look again; most likely it is a true positive!. Disabling Instrumentation with ``__attribute__((no_sanitize(""undefined"")))``; ----------------------------------------------------------------------------. You disable UBSan checks for particular functions with; ``__attribute__((no_sanitize(""undefined"")))``. You can use all values of; ``-fsanitize=`` flag in this attribute, e.g. if your function deliberately; contains possib",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:12805,Testability,log,log,12805,"ailable suitable for use in production; environments. This runtime has a small attack surface. It only provides very; basic issue logging and deduplication, and does not support ``-fsanitize=vptr``; checking. To use the minimal runtime, add ``-fsanitize-minimal-runtime`` to the clang; command line options. For example, if you're used to compiling with; ``-fsanitize=undefined``, you could enable the minimal runtime with; ``-fsanitize=undefined -fsanitize-minimal-runtime``. Stack traces and report symbolization; =====================================; If you want UBSan to print symbolized stack trace for each error report, you; will need to:. #. Compile with ``-g`` and ``-fno-omit-frame-pointer`` to get proper debug; information in your binary.; #. Run your program with environment variable; ``UBSAN_OPTIONS=print_stacktrace=1``.; #. Make sure ``llvm-symbolizer`` binary is in ``PATH``. Logging; =======. The default log file for diagnostics is ""stderr"". To log diagnostics to another; file, you can set ``UBSAN_OPTIONS=log_path=...``. Silencing Unsigned Integer Overflow; ===================================; To silence reports from unsigned integer overflow, you can set; ``UBSAN_OPTIONS=silence_unsigned_overflow=1``. This feature, combined with; ``-fsanitize-recover=unsigned-integer-overflow``, is particularly useful for; providing fuzzing signal without blowing up logs. Issue Suppression; =================. UndefinedBehaviorSanitizer is not expected to produce false positives.; If you see one, look again; most likely it is a true positive!. Disabling Instrumentation with ``__attribute__((no_sanitize(""undefined"")))``; ----------------------------------------------------------------------------. You disable UBSan checks for particular functions with; ``__attribute__((no_sanitize(""undefined"")))``. You can use all values of; ``-fsanitize=`` flag in this attribute, e.g. if your function deliberately; contains possible signed integer overflow, you can use; ``__attribute__((no_sa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:13219,Testability,log,logs,13219,". For example, if you're used to compiling with; ``-fsanitize=undefined``, you could enable the minimal runtime with; ``-fsanitize=undefined -fsanitize-minimal-runtime``. Stack traces and report symbolization; =====================================; If you want UBSan to print symbolized stack trace for each error report, you; will need to:. #. Compile with ``-g`` and ``-fno-omit-frame-pointer`` to get proper debug; information in your binary.; #. Run your program with environment variable; ``UBSAN_OPTIONS=print_stacktrace=1``.; #. Make sure ``llvm-symbolizer`` binary is in ``PATH``. Logging; =======. The default log file for diagnostics is ""stderr"". To log diagnostics to another; file, you can set ``UBSAN_OPTIONS=log_path=...``. Silencing Unsigned Integer Overflow; ===================================; To silence reports from unsigned integer overflow, you can set; ``UBSAN_OPTIONS=silence_unsigned_overflow=1``. This feature, combined with; ``-fsanitize-recover=unsigned-integer-overflow``, is particularly useful for; providing fuzzing signal without blowing up logs. Issue Suppression; =================. UndefinedBehaviorSanitizer is not expected to produce false positives.; If you see one, look again; most likely it is a true positive!. Disabling Instrumentation with ``__attribute__((no_sanitize(""undefined"")))``; ----------------------------------------------------------------------------. You disable UBSan checks for particular functions with; ``__attribute__((no_sanitize(""undefined"")))``. You can use all values of; ``-fsanitize=`` flag in this attribute, e.g. if your function deliberately; contains possible signed integer overflow, you can use; ``__attribute__((no_sanitize(""signed-integer-overflow"")))``. This attribute may not be; supported by other compilers, so consider using it together with; ``#if defined(__clang__)``. Suppressing Errors in Recompiled Code (Ignorelist); --------------------------------------------------. UndefinedBehaviorSanitizer supports ``src``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst:15964,Testability,test,test,15964,"me could figure out source file or function name to match; against the suppression.; * It is only possible to suppress recoverable checks. For the example above,; you can additionally pass; ``-fsanitize-recover=signed-integer-overflow,alignment,vptr``, although; most of UBSan checks are recoverable by default.; * Check groups (like ``undefined``) can't be used in suppressions file, only; fine-grained checks are supported. Supported Platforms; ===================. UndefinedBehaviorSanitizer is supported on the following operating systems:. * Android; * Linux; * NetBSD; * FreeBSD; * OpenBSD; * macOS; * Windows. The runtime library is relatively portable and platform independent. If the OS; you need is not listed above, UndefinedBehaviorSanitizer may already work for; it, or could be made to work with a minor porting effort. Current Status; ==============. UndefinedBehaviorSanitizer is available on selected platforms starting from LLVM; 3.3. The test suite is integrated into the CMake build and can be run with; ``check-ubsan`` command. Additional Configuration; ========================. UndefinedBehaviorSanitizer adds static check data for each check unless it is; in trap mode. This check data includes the full file name. The option; ``-fsanitize-undefined-strip-path-components=N`` can be used to trim this; information. If ``N`` is positive, file information emitted by; UndefinedBehaviorSanitizer will drop the first ``N`` components from the file; path. If ``N`` is negative, the last ``N`` components will be kept. Example; -------. For a file called ``/code/library/file.cpp``, here is what would be emitted:. * Default (No flag, or ``-fsanitize-undefined-strip-path-components=0``): ``/code/library/file.cpp``; * ``-fsanitize-undefined-strip-path-components=1``: ``code/library/file.cpp``; * ``-fsanitize-undefined-strip-path-components=2``: ``library/file.cpp``; * ``-fsanitize-undefined-strip-path-components=-1``: ``file.cpp``; * ``-fsanitize-undefined-strip-path-component",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UndefinedBehaviorSanitizer.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:3879,Availability,error,errors,3879," :ref:`compiler; terminology <terminology>` that is used throughout this manual and; contains a basic :ref:`introduction to using Clang <basicusage>` as a; command line compiler. .. _terminology:. Terminology; -----------. Front end, parser, backend, preprocessor, undefined behavior,; diagnostic, optimizer. .. _basicusage:. Basic Usage; -----------. Intro to how to use a C compiler for newbies. compile + link compile then link debug info enabling optimizations; picking a language to use, defaults to C17 by default. Autosenses based; on extension. using a makefile. Command Line Options; ====================. This section is generally an index into other sections. It does not go; into depth on the ones that are covered by other sections. However, the; first part introduces the language selection and other high level; options like :option:`-c`, :option:`-g`, etc. Options to Control Error and Warning Messages; ---------------------------------------------. .. option:: -Werror. Turn warnings into errors. .. This is in plain monospaced font because it generates the same label as; .. -Werror, and Sphinx complains. ``-Werror=foo``. Turn warning ""foo"" into an error. .. option:: -Wno-error=foo. Turn warning ""foo"" into a warning even if :option:`-Werror` is specified. .. option:: -Wfoo. Enable warning ""foo"".; See the :doc:`diagnostics reference <DiagnosticsReference>` for a complete; list of the warning flags that can be specified in this way. .. option:: -Wno-foo. Disable warning ""foo"". .. option:: -w. Disable all diagnostics. .. option:: -Weverything. :ref:`Enable all diagnostics. <diagnostics_enable_everything>`. .. option:: -pedantic. Warn on language extensions. .. option:: -pedantic-errors. Error on language extensions. .. option:: -Wsystem-headers. Enable warnings from system headers. .. option:: -ferror-limit=123. Stop emitting diagnostics after 123 errors have been produced. The default is; 20, and the error limit can be disabled with `-ferror-limit=0`. .. option:: -ft",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:4041,Availability,error,error,4041,"mmand line compiler. .. _terminology:. Terminology; -----------. Front end, parser, backend, preprocessor, undefined behavior,; diagnostic, optimizer. .. _basicusage:. Basic Usage; -----------. Intro to how to use a C compiler for newbies. compile + link compile then link debug info enabling optimizations; picking a language to use, defaults to C17 by default. Autosenses based; on extension. using a makefile. Command Line Options; ====================. This section is generally an index into other sections. It does not go; into depth on the ones that are covered by other sections. However, the; first part introduces the language selection and other high level; options like :option:`-c`, :option:`-g`, etc. Options to Control Error and Warning Messages; ---------------------------------------------. .. option:: -Werror. Turn warnings into errors. .. This is in plain monospaced font because it generates the same label as; .. -Werror, and Sphinx complains. ``-Werror=foo``. Turn warning ""foo"" into an error. .. option:: -Wno-error=foo. Turn warning ""foo"" into a warning even if :option:`-Werror` is specified. .. option:: -Wfoo. Enable warning ""foo"".; See the :doc:`diagnostics reference <DiagnosticsReference>` for a complete; list of the warning flags that can be specified in this way. .. option:: -Wno-foo. Disable warning ""foo"". .. option:: -w. Disable all diagnostics. .. option:: -Weverything. :ref:`Enable all diagnostics. <diagnostics_enable_everything>`. .. option:: -pedantic. Warn on language extensions. .. option:: -pedantic-errors. Error on language extensions. .. option:: -Wsystem-headers. Enable warnings from system headers. .. option:: -ferror-limit=123. Stop emitting diagnostics after 123 errors have been produced. The default is; 20, and the error limit can be disabled with `-ferror-limit=0`. .. option:: -ftemplate-backtrace-limit=123. Only emit up to 123 template instantiation notes within the template; instantiation backtrace for a single warning or error. The",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:4065,Availability,error,error,4065,"logy:. Terminology; -----------. Front end, parser, backend, preprocessor, undefined behavior,; diagnostic, optimizer. .. _basicusage:. Basic Usage; -----------. Intro to how to use a C compiler for newbies. compile + link compile then link debug info enabling optimizations; picking a language to use, defaults to C17 by default. Autosenses based; on extension. using a makefile. Command Line Options; ====================. This section is generally an index into other sections. It does not go; into depth on the ones that are covered by other sections. However, the; first part introduces the language selection and other high level; options like :option:`-c`, :option:`-g`, etc. Options to Control Error and Warning Messages; ---------------------------------------------. .. option:: -Werror. Turn warnings into errors. .. This is in plain monospaced font because it generates the same label as; .. -Werror, and Sphinx complains. ``-Werror=foo``. Turn warning ""foo"" into an error. .. option:: -Wno-error=foo. Turn warning ""foo"" into a warning even if :option:`-Werror` is specified. .. option:: -Wfoo. Enable warning ""foo"".; See the :doc:`diagnostics reference <DiagnosticsReference>` for a complete; list of the warning flags that can be specified in this way. .. option:: -Wno-foo. Disable warning ""foo"". .. option:: -w. Disable all diagnostics. .. option:: -Weverything. :ref:`Enable all diagnostics. <diagnostics_enable_everything>`. .. option:: -pedantic. Warn on language extensions. .. option:: -pedantic-errors. Error on language extensions. .. option:: -Wsystem-headers. Enable warnings from system headers. .. option:: -ferror-limit=123. Stop emitting diagnostics after 123 errors have been produced. The default is; 20, and the error limit can be disabled with `-ferror-limit=0`. .. option:: -ftemplate-backtrace-limit=123. Only emit up to 123 template instantiation notes within the template; instantiation backtrace for a single warning or error. The default is 10, and; the limit ca",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:4579,Availability,error,errors,4579," the ones that are covered by other sections. However, the; first part introduces the language selection and other high level; options like :option:`-c`, :option:`-g`, etc. Options to Control Error and Warning Messages; ---------------------------------------------. .. option:: -Werror. Turn warnings into errors. .. This is in plain monospaced font because it generates the same label as; .. -Werror, and Sphinx complains. ``-Werror=foo``. Turn warning ""foo"" into an error. .. option:: -Wno-error=foo. Turn warning ""foo"" into a warning even if :option:`-Werror` is specified. .. option:: -Wfoo. Enable warning ""foo"".; See the :doc:`diagnostics reference <DiagnosticsReference>` for a complete; list of the warning flags that can be specified in this way. .. option:: -Wno-foo. Disable warning ""foo"". .. option:: -w. Disable all diagnostics. .. option:: -Weverything. :ref:`Enable all diagnostics. <diagnostics_enable_everything>`. .. option:: -pedantic. Warn on language extensions. .. option:: -pedantic-errors. Error on language extensions. .. option:: -Wsystem-headers. Enable warnings from system headers. .. option:: -ferror-limit=123. Stop emitting diagnostics after 123 errors have been produced. The default is; 20, and the error limit can be disabled with `-ferror-limit=0`. .. option:: -ftemplate-backtrace-limit=123. Only emit up to 123 template instantiation notes within the template; instantiation backtrace for a single warning or error. The default is 10, and; the limit can be disabled with `-ftemplate-backtrace-limit=0`. .. _cl_diag_formatting:. Formatting of Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^^. Clang aims to produce beautiful diagnostics by default, particularly for; new users that first come to Clang. However, different people have; different preferences, and sometimes Clang is driven not by a human,; but by a program that wants consistent and easily parsable output. For; these cases, Clang provides a wide range of options to control the exact; output format of the d",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:4751,Availability,error,errors,4751,"Options to Control Error and Warning Messages; ---------------------------------------------. .. option:: -Werror. Turn warnings into errors. .. This is in plain monospaced font because it generates the same label as; .. -Werror, and Sphinx complains. ``-Werror=foo``. Turn warning ""foo"" into an error. .. option:: -Wno-error=foo. Turn warning ""foo"" into a warning even if :option:`-Werror` is specified. .. option:: -Wfoo. Enable warning ""foo"".; See the :doc:`diagnostics reference <DiagnosticsReference>` for a complete; list of the warning flags that can be specified in this way. .. option:: -Wno-foo. Disable warning ""foo"". .. option:: -w. Disable all diagnostics. .. option:: -Weverything. :ref:`Enable all diagnostics. <diagnostics_enable_everything>`. .. option:: -pedantic. Warn on language extensions. .. option:: -pedantic-errors. Error on language extensions. .. option:: -Wsystem-headers. Enable warnings from system headers. .. option:: -ferror-limit=123. Stop emitting diagnostics after 123 errors have been produced. The default is; 20, and the error limit can be disabled with `-ferror-limit=0`. .. option:: -ftemplate-backtrace-limit=123. Only emit up to 123 template instantiation notes within the template; instantiation backtrace for a single warning or error. The default is 10, and; the limit can be disabled with `-ftemplate-backtrace-limit=0`. .. _cl_diag_formatting:. Formatting of Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^^. Clang aims to produce beautiful diagnostics by default, particularly for; new users that first come to Clang. However, different people have; different preferences, and sometimes Clang is driven not by a human,; but by a program that wants consistent and easily parsable output. For; these cases, Clang provides a wide range of options to control the exact; output format of the diagnostics that it generates. .. _opt_fshow-column:. .. option:: -f[no-]show-column. Print column number in diagnostic. This option, which defaults to on, controls whether o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:4806,Availability,error,error,4806,"--------------------. .. option:: -Werror. Turn warnings into errors. .. This is in plain monospaced font because it generates the same label as; .. -Werror, and Sphinx complains. ``-Werror=foo``. Turn warning ""foo"" into an error. .. option:: -Wno-error=foo. Turn warning ""foo"" into a warning even if :option:`-Werror` is specified. .. option:: -Wfoo. Enable warning ""foo"".; See the :doc:`diagnostics reference <DiagnosticsReference>` for a complete; list of the warning flags that can be specified in this way. .. option:: -Wno-foo. Disable warning ""foo"". .. option:: -w. Disable all diagnostics. .. option:: -Weverything. :ref:`Enable all diagnostics. <diagnostics_enable_everything>`. .. option:: -pedantic. Warn on language extensions. .. option:: -pedantic-errors. Error on language extensions. .. option:: -Wsystem-headers. Enable warnings from system headers. .. option:: -ferror-limit=123. Stop emitting diagnostics after 123 errors have been produced. The default is; 20, and the error limit can be disabled with `-ferror-limit=0`. .. option:: -ftemplate-backtrace-limit=123. Only emit up to 123 template instantiation notes within the template; instantiation backtrace for a single warning or error. The default is 10, and; the limit can be disabled with `-ftemplate-backtrace-limit=0`. .. _cl_diag_formatting:. Formatting of Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^^. Clang aims to produce beautiful diagnostics by default, particularly for; new users that first come to Clang. However, different people have; different preferences, and sometimes Clang is driven not by a human,; but by a program that wants consistent and easily parsable output. For; these cases, Clang provides a wide range of options to control the exact; output format of the diagnostics that it generates. .. _opt_fshow-column:. .. option:: -f[no-]show-column. Print column number in diagnostic. This option, which defaults to on, controls whether or not Clang; prints the column number of a diagnostic. For example, whe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:5020,Availability,error,error,5020,".. -Werror, and Sphinx complains. ``-Werror=foo``. Turn warning ""foo"" into an error. .. option:: -Wno-error=foo. Turn warning ""foo"" into a warning even if :option:`-Werror` is specified. .. option:: -Wfoo. Enable warning ""foo"".; See the :doc:`diagnostics reference <DiagnosticsReference>` for a complete; list of the warning flags that can be specified in this way. .. option:: -Wno-foo. Disable warning ""foo"". .. option:: -w. Disable all diagnostics. .. option:: -Weverything. :ref:`Enable all diagnostics. <diagnostics_enable_everything>`. .. option:: -pedantic. Warn on language extensions. .. option:: -pedantic-errors. Error on language extensions. .. option:: -Wsystem-headers. Enable warnings from system headers. .. option:: -ferror-limit=123. Stop emitting diagnostics after 123 errors have been produced. The default is; 20, and the error limit can be disabled with `-ferror-limit=0`. .. option:: -ftemplate-backtrace-limit=123. Only emit up to 123 template instantiation notes within the template; instantiation backtrace for a single warning or error. The default is 10, and; the limit can be disabled with `-ftemplate-backtrace-limit=0`. .. _cl_diag_formatting:. Formatting of Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^^. Clang aims to produce beautiful diagnostics by default, particularly for; new users that first come to Clang. However, different people have; different preferences, and sometimes Clang is driven not by a human,; but by a program that wants consistent and easily parsable output. For; these cases, Clang provides a wide range of options to control the exact; output format of the diagnostics that it generates. .. _opt_fshow-column:. .. option:: -f[no-]show-column. Print column number in diagnostic. This option, which defaults to on, controls whether or not Clang; prints the column number of a diagnostic. For example, when this is; enabled, Clang will print something like:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif ba",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:12535,Availability,avail,available,12535,"he absence of an explicit output file, the file is chosen using the; following scheme:. ``<base>.opt.<format>``. where ``<base>`` is based on the output file of the compilation (whether; it's explicitly specified through `-o` or not) when used with `-c` or `-S`.; For example:. * ``clang -fsave-optimization-record -c in.c -o out.o`` will generate; ``out.opt.yaml``. * ``clang -fsave-optimization-record -c in.c`` will generate; ``in.opt.yaml``. When targeting (Thin)LTO, the base is derived from the output filename, and; the extension is not dropped. When targeting ThinLTO, the following scheme is used:. ``<base>.opt.<format>.thin.<num>.<format>``. Darwin-only: when used for generating a linked binary from a source file; (through an intermediate object file), the driver will invoke `cc1` to; generate a temporary object file. The temporary remark file will be emitted; next to the object file, which will then be picked up by `dsymutil` and; emitted in the .dSYM bundle. This is available for all formats except YAML. For example:. ``clang -fsave-optimization-record=bitstream in.c -o out`` will generate. * ``/var/folders/43/9y164hh52tv_2nrdxrj31nyw0000gn/T/a-9be59b.o``. * ``/var/folders/43/9y164hh52tv_2nrdxrj31nyw0000gn/T/a-9be59b.opt.bitstream``. * ``out``. * ``out.dSYM/Contents/Resources/Remarks/out``. Darwin-only: compiling for multiple architectures will use the following; scheme:. ``<base>-<arch>.opt.<format>``. Note that this is incompatible with passing the; :option:`-foptimization-record-file` option. .. option:: -foptimization-record-file. Control the file to which optimization reports are written. This implies; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>`. On Darwin platforms, this is incompatible with passing multiple; ``-arch <arch>`` options. .. option:: -foptimization-record-passes. Only include passes which match a specified regular expression. When optimization reports are being output (see; :ref:`-fsave-optimization-record <opt_fsave-opti",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:16325,Availability,error,error,16325,"ang; prints the information on how to fix a specific diagnostic; underneath it when it knows. For example, in this output:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. Passing **-fno-diagnostics-fixit-info** will prevent Clang from; printing the ""//"" line at the end of the message. This information; is useful for users who may not understand what is wrong, but can be; confusing for machine parsing. .. _opt_fdiagnostics-print-source-range-info:. .. option:: -fdiagnostics-print-source-range-info. Print machine parsable information about source ranges.; This option makes Clang print information about source ranges in a machine; parsable format after the file/line/column number information. The; information is a simple sequence of brace enclosed ranges, where each range; lists the start and end line/column locations. For example, in this output:. ::. exprs.c:47:15:{47:8-47:14}{47:17-47:24}: error: invalid operands to binary expression ('int *' and '_Complex float'); P = (P-42) + Gamma*4;; ~~~~~~ ^ ~~~~~~~. The {}'s are generated by -fdiagnostics-print-source-range-info. The printed column numbers count bytes from the beginning of the; line; take care if your source contains multibyte characters. .. option:: -fdiagnostics-parseable-fixits. Print Fix-Its in a machine parseable form. This option makes Clang print available Fix-Its in a machine; parseable format at the end of diagnostics. The following example; illustrates the format:. ::. fix-it:""t.cpp"":{7:25-7:29}:""Gamma"". The range printed is a half-open range, so in this example the; characters at column 25 up to but not including column 29 on line 7; in t.cpp should be replaced with the string ""Gamma"". Either the; range or the replacement string may be empty (representing strict; insertions and strict erasures, respectively). Both the file name; and the insertion string escape backslash (as ""\\\\""), tabs (as; ""\\t""), newlines (as ""\\n""), double quotes(as ""\\"""")",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:16753,Availability,avail,available,16753,"s wrong, but can be; confusing for machine parsing. .. _opt_fdiagnostics-print-source-range-info:. .. option:: -fdiagnostics-print-source-range-info. Print machine parsable information about source ranges.; This option makes Clang print information about source ranges in a machine; parsable format after the file/line/column number information. The; information is a simple sequence of brace enclosed ranges, where each range; lists the start and end line/column locations. For example, in this output:. ::. exprs.c:47:15:{47:8-47:14}{47:17-47:24}: error: invalid operands to binary expression ('int *' and '_Complex float'); P = (P-42) + Gamma*4;; ~~~~~~ ^ ~~~~~~~. The {}'s are generated by -fdiagnostics-print-source-range-info. The printed column numbers count bytes from the beginning of the; line; take care if your source contains multibyte characters. .. option:: -fdiagnostics-parseable-fixits. Print Fix-Its in a machine parseable form. This option makes Clang print available Fix-Its in a machine; parseable format at the end of diagnostics. The following example; illustrates the format:. ::. fix-it:""t.cpp"":{7:25-7:29}:""Gamma"". The range printed is a half-open range, so in this example the; characters at column 25 up to but not including column 29 on line 7; in t.cpp should be replaced with the string ""Gamma"". Either the; range or the replacement string may be empty (representing strict; insertions and strict erasures, respectively). Both the file name; and the insertion string escape backslash (as ""\\\\""), tabs (as; ""\\t""), newlines (as ""\\n""), double quotes(as ""\\"""") and; non-printable characters (as octal ""\\xxx""). The printed column numbers count bytes from the beginning of the; line; take care if your source contains multibyte characters. .. option:: -fno-elide-type. Turns off elision in template type printing. The default for template type printing is to elide as many template; arguments as possible, removing those which are the same in both; template types, leavi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:19379,Availability,error,error,19379," For diffing large templated types, this option will cause Clang to; display the templates as an indented text tree, one argument per; line, with differences marked inline. This is compatible with; -fno-elide-type. Default:. ::. t.cc:4:5: note: candidate function not viable: no known conversion from 'vector<map<[...], map<float, [...]>>>' to 'vector<map<[...], map<double, [...]>>>' for 1st argument;. With :option:`-fdiagnostics-show-template-tree`:. ::. t.cc:4:5: note: candidate function not viable: no known conversion for 1st argument;; vector<; map<; [...],; map<; [float != double],; [...]>>>. .. option:: -fcaret-diagnostics-max-lines:. Controls how many lines of code clang prints for diagnostics. By default,; clang prints a maximum of 16 lines of code. .. option:: -fdiagnostics-show-line-numbers:. Controls whether clang will print a margin containing the line number on; the left of each line of code it prints for diagnostics. Default:. ::. test.cpp:5:1: error: 'main' must return 'int'; 5 | void main() {}; | ^~~~; | int. With -fno-diagnostics-show-line-numbers:. ::. test.cpp:5:1: error: 'main' must return 'int'; void main() {}; ^~~~; int. .. _cl_diag_warning_groups:. Individual Warning Groups; ^^^^^^^^^^^^^^^^^^^^^^^^^. TODO: Generate this from tblgen. Define one anchor per warning group. .. option:: -Wextra-tokens. Warn about excess tokens at the end of a preprocessor directive. This option, which defaults to on, enables warnings about extra; tokens at the end of preprocessor directives. For example:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^. These extra tokens are not strictly conforming, and are usually best; handled by commenting them out. .. option:: -Wambiguous-member-template. Warn about unqualified uses of a member template whose name resolves to; another template at the location of the use. This option, which defaults to on, enables a warning in the; following code:. ::. template<typename T> struct ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:19507,Availability,error,error,19507,"ument per; line, with differences marked inline. This is compatible with; -fno-elide-type. Default:. ::. t.cc:4:5: note: candidate function not viable: no known conversion from 'vector<map<[...], map<float, [...]>>>' to 'vector<map<[...], map<double, [...]>>>' for 1st argument;. With :option:`-fdiagnostics-show-template-tree`:. ::. t.cc:4:5: note: candidate function not viable: no known conversion for 1st argument;; vector<; map<; [...],; map<; [float != double],; [...]>>>. .. option:: -fcaret-diagnostics-max-lines:. Controls how many lines of code clang prints for diagnostics. By default,; clang prints a maximum of 16 lines of code. .. option:: -fdiagnostics-show-line-numbers:. Controls whether clang will print a margin containing the line number on; the left of each line of code it prints for diagnostics. Default:. ::. test.cpp:5:1: error: 'main' must return 'int'; 5 | void main() {}; | ^~~~; | int. With -fno-diagnostics-show-line-numbers:. ::. test.cpp:5:1: error: 'main' must return 'int'; void main() {}; ^~~~; int. .. _cl_diag_warning_groups:. Individual Warning Groups; ^^^^^^^^^^^^^^^^^^^^^^^^^. TODO: Generate this from tblgen. Define one anchor per warning group. .. option:: -Wextra-tokens. Warn about excess tokens at the end of a preprocessor directive. This option, which defaults to on, enables warnings about extra; tokens at the end of preprocessor directives. For example:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^. These extra tokens are not strictly conforming, and are usually best; handled by commenting them out. .. option:: -Wambiguous-member-template. Warn about unqualified uses of a member template whose name resolves to; another template at the location of the use. This option, which defaults to on, enables a warning in the; following code:. ::. template<typename T> struct set{};; template<typename T> struct trait { typedef const T& type; };; struct Value {; template<typename T> void set(typenam",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:20663,Availability,error,error,20663,"nchor per warning group. .. option:: -Wextra-tokens. Warn about excess tokens at the end of a preprocessor directive. This option, which defaults to on, enables warnings about extra; tokens at the end of preprocessor directives. For example:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^. These extra tokens are not strictly conforming, and are usually best; handled by commenting them out. .. option:: -Wambiguous-member-template. Warn about unqualified uses of a member template whose name resolves to; another template at the location of the use. This option, which defaults to on, enables a warning in the; following code:. ::. template<typename T> struct set{};; template<typename T> struct trait { typedef const T& type; };; struct Value {; template<typename T> void set(typename trait<T>::type value) {}; };; void foo() {; Value v;; v.set<double>(3.2);; }. C++ [basic.lookup.classref] requires this to be an error, but,; because it's hard to work around, Clang downgrades it to a warning; as an extension. .. option:: -Wbind-to-temporary-copy. Warn about an unusable copy constructor when binding a reference to a; temporary. This option enables warnings about binding a; reference to a temporary when the temporary doesn't have a usable; copy constructor. For example:. ::. struct NonCopyable {; NonCopyable();; private:; NonCopyable(const NonCopyable&);; };; void foo(const NonCopyable&);; void bar() {; foo(NonCopyable()); // Disallowed in C++98; allowed in C++11.; }. ::. struct NonCopyable2 {; NonCopyable2();; NonCopyable2(NonCopyable2&);; };; void foo(const NonCopyable2&);; void bar() {; foo(NonCopyable2()); // Disallowed in C++98; allowed in C++11.; }. Note that if ``NonCopyable2::NonCopyable2()`` has a default argument; whose instantiation produces a compile error, that error will still; be a hard error in C++98 mode even if this warning is turned off. Options to Control Clang Crash Diagnostics; ----------------------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:20716,Availability,down,downgrades,20716,"nchor per warning group. .. option:: -Wextra-tokens. Warn about excess tokens at the end of a preprocessor directive. This option, which defaults to on, enables warnings about extra; tokens at the end of preprocessor directives. For example:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^. These extra tokens are not strictly conforming, and are usually best; handled by commenting them out. .. option:: -Wambiguous-member-template. Warn about unqualified uses of a member template whose name resolves to; another template at the location of the use. This option, which defaults to on, enables a warning in the; following code:. ::. template<typename T> struct set{};; template<typename T> struct trait { typedef const T& type; };; struct Value {; template<typename T> void set(typename trait<T>::type value) {}; };; void foo() {; Value v;; v.set<double>(3.2);; }. C++ [basic.lookup.classref] requires this to be an error, but,; because it's hard to work around, Clang downgrades it to a warning; as an extension. .. option:: -Wbind-to-temporary-copy. Warn about an unusable copy constructor when binding a reference to a; temporary. This option enables warnings about binding a; reference to a temporary when the temporary doesn't have a usable; copy constructor. For example:. ::. struct NonCopyable {; NonCopyable();; private:; NonCopyable(const NonCopyable&);; };; void foo(const NonCopyable&);; void bar() {; foo(NonCopyable()); // Disallowed in C++98; allowed in C++11.; }. ::. struct NonCopyable2 {; NonCopyable2();; NonCopyable2(NonCopyable2&);; };; void foo(const NonCopyable2&);; void bar() {; foo(NonCopyable2()); // Disallowed in C++98; allowed in C++11.; }. Note that if ``NonCopyable2::NonCopyable2()`` has a default argument; whose instantiation produces a compile error, that error will still; be a hard error in C++98 mode even if this warning is turned off. Options to Control Clang Crash Diagnostics; ----------------------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:21527,Availability,error,error,21527,"d set(typename trait<T>::type value) {}; };; void foo() {; Value v;; v.set<double>(3.2);; }. C++ [basic.lookup.classref] requires this to be an error, but,; because it's hard to work around, Clang downgrades it to a warning; as an extension. .. option:: -Wbind-to-temporary-copy. Warn about an unusable copy constructor when binding a reference to a; temporary. This option enables warnings about binding a; reference to a temporary when the temporary doesn't have a usable; copy constructor. For example:. ::. struct NonCopyable {; NonCopyable();; private:; NonCopyable(const NonCopyable&);; };; void foo(const NonCopyable&);; void bar() {; foo(NonCopyable()); // Disallowed in C++98; allowed in C++11.; }. ::. struct NonCopyable2 {; NonCopyable2();; NonCopyable2(NonCopyable2&);; };; void foo(const NonCopyable2&);; void bar() {; foo(NonCopyable2()); // Disallowed in C++98; allowed in C++11.; }. Note that if ``NonCopyable2::NonCopyable2()`` has a default argument; whose instantiation produces a compile error, that error will still; be a hard error in C++98 mode even if this warning is turned off. Options to Control Clang Crash Diagnostics; ------------------------------------------. As unbelievable as it may sound, Clang does crash from time to time.; Generally, this only occurs to those living on the `bleeding; edge <https://llvm.org/releases/download.html#svn>`_. Clang goes to great; lengths to assist you in filing a bug report. Specifically, Clang; generates preprocessed source file(s) and associated run script(s) upon; a crash. These files should be attached to a bug report to ease; reproducibility of the failure. Below are the command line options to; control the crash diagnostics. .. option:: -fcrash-diagnostics=<val>. Valid values are:. * ``off`` (Disable auto-generation of preprocessed source files during a clang crash.); * ``compiler`` (Generate diagnostics for compiler crashes (default)); * ``all`` (Generate diagnostics for all tools which support it). .. option:: -f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:21539,Availability,error,error,21539,"d set(typename trait<T>::type value) {}; };; void foo() {; Value v;; v.set<double>(3.2);; }. C++ [basic.lookup.classref] requires this to be an error, but,; because it's hard to work around, Clang downgrades it to a warning; as an extension. .. option:: -Wbind-to-temporary-copy. Warn about an unusable copy constructor when binding a reference to a; temporary. This option enables warnings about binding a; reference to a temporary when the temporary doesn't have a usable; copy constructor. For example:. ::. struct NonCopyable {; NonCopyable();; private:; NonCopyable(const NonCopyable&);; };; void foo(const NonCopyable&);; void bar() {; foo(NonCopyable()); // Disallowed in C++98; allowed in C++11.; }. ::. struct NonCopyable2 {; NonCopyable2();; NonCopyable2(NonCopyable2&);; };; void foo(const NonCopyable2&);; void bar() {; foo(NonCopyable2()); // Disallowed in C++98; allowed in C++11.; }. Note that if ``NonCopyable2::NonCopyable2()`` has a default argument; whose instantiation produces a compile error, that error will still; be a hard error in C++98 mode even if this warning is turned off. Options to Control Clang Crash Diagnostics; ------------------------------------------. As unbelievable as it may sound, Clang does crash from time to time.; Generally, this only occurs to those living on the `bleeding; edge <https://llvm.org/releases/download.html#svn>`_. Clang goes to great; lengths to assist you in filing a bug report. Specifically, Clang; generates preprocessed source file(s) and associated run script(s) upon; a crash. These files should be attached to a bug report to ease; reproducibility of the failure. Below are the command line options to; control the crash diagnostics. .. option:: -fcrash-diagnostics=<val>. Valid values are:. * ``off`` (Disable auto-generation of preprocessed source files during a clang crash.); * ``compiler`` (Generate diagnostics for compiler crashes (default)); * ``all`` (Generate diagnostics for all tools which support it). .. option:: -f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:21567,Availability,error,error,21567,"d set(typename trait<T>::type value) {}; };; void foo() {; Value v;; v.set<double>(3.2);; }. C++ [basic.lookup.classref] requires this to be an error, but,; because it's hard to work around, Clang downgrades it to a warning; as an extension. .. option:: -Wbind-to-temporary-copy. Warn about an unusable copy constructor when binding a reference to a; temporary. This option enables warnings about binding a; reference to a temporary when the temporary doesn't have a usable; copy constructor. For example:. ::. struct NonCopyable {; NonCopyable();; private:; NonCopyable(const NonCopyable&);; };; void foo(const NonCopyable&);; void bar() {; foo(NonCopyable()); // Disallowed in C++98; allowed in C++11.; }. ::. struct NonCopyable2 {; NonCopyable2();; NonCopyable2(NonCopyable2&);; };; void foo(const NonCopyable2&);; void bar() {; foo(NonCopyable2()); // Disallowed in C++98; allowed in C++11.; }. Note that if ``NonCopyable2::NonCopyable2()`` has a default argument; whose instantiation produces a compile error, that error will still; be a hard error in C++98 mode even if this warning is turned off. Options to Control Clang Crash Diagnostics; ------------------------------------------. As unbelievable as it may sound, Clang does crash from time to time.; Generally, this only occurs to those living on the `bleeding; edge <https://llvm.org/releases/download.html#svn>`_. Clang goes to great; lengths to assist you in filing a bug report. Specifically, Clang; generates preprocessed source file(s) and associated run script(s) upon; a crash. These files should be attached to a bug report to ease; reproducibility of the failure. Below are the command line options to; control the crash diagnostics. .. option:: -fcrash-diagnostics=<val>. Valid values are:. * ``off`` (Disable auto-generation of preprocessed source files during a clang crash.); * ``compiler`` (Generate diagnostics for compiler crashes (default)); * ``all`` (Generate diagnostics for all tools which support it). .. option:: -f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:21875,Availability,down,download,21875,"porary. This option enables warnings about binding a; reference to a temporary when the temporary doesn't have a usable; copy constructor. For example:. ::. struct NonCopyable {; NonCopyable();; private:; NonCopyable(const NonCopyable&);; };; void foo(const NonCopyable&);; void bar() {; foo(NonCopyable()); // Disallowed in C++98; allowed in C++11.; }. ::. struct NonCopyable2 {; NonCopyable2();; NonCopyable2(NonCopyable2&);; };; void foo(const NonCopyable2&);; void bar() {; foo(NonCopyable2()); // Disallowed in C++98; allowed in C++11.; }. Note that if ``NonCopyable2::NonCopyable2()`` has a default argument; whose instantiation produces a compile error, that error will still; be a hard error in C++98 mode even if this warning is turned off. Options to Control Clang Crash Diagnostics; ------------------------------------------. As unbelievable as it may sound, Clang does crash from time to time.; Generally, this only occurs to those living on the `bleeding; edge <https://llvm.org/releases/download.html#svn>`_. Clang goes to great; lengths to assist you in filing a bug report. Specifically, Clang; generates preprocessed source file(s) and associated run script(s) upon; a crash. These files should be attached to a bug report to ease; reproducibility of the failure. Below are the command line options to; control the crash diagnostics. .. option:: -fcrash-diagnostics=<val>. Valid values are:. * ``off`` (Disable auto-generation of preprocessed source files during a clang crash.); * ``compiler`` (Generate diagnostics for compiler crashes (default)); * ``all`` (Generate diagnostics for all tools which support it). .. option:: -fno-crash-diagnostics. Disable auto-generation of preprocessed source files during a clang crash. The -fno-crash-diagnostics flag can be helpful for speeding the process; of generating a delta reduced test case. .. option:: -fcrash-diagnostics-dir=<dir>. Specify where to write the crash diagnostics files; defaults to the; usual location for temporary f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:22146,Availability,failure,failure,22146,"; };; void foo(const NonCopyable&);; void bar() {; foo(NonCopyable()); // Disallowed in C++98; allowed in C++11.; }. ::. struct NonCopyable2 {; NonCopyable2();; NonCopyable2(NonCopyable2&);; };; void foo(const NonCopyable2&);; void bar() {; foo(NonCopyable2()); // Disallowed in C++98; allowed in C++11.; }. Note that if ``NonCopyable2::NonCopyable2()`` has a default argument; whose instantiation produces a compile error, that error will still; be a hard error in C++98 mode even if this warning is turned off. Options to Control Clang Crash Diagnostics; ------------------------------------------. As unbelievable as it may sound, Clang does crash from time to time.; Generally, this only occurs to those living on the `bleeding; edge <https://llvm.org/releases/download.html#svn>`_. Clang goes to great; lengths to assist you in filing a bug report. Specifically, Clang; generates preprocessed source file(s) and associated run script(s) upon; a crash. These files should be attached to a bug report to ease; reproducibility of the failure. Below are the command line options to; control the crash diagnostics. .. option:: -fcrash-diagnostics=<val>. Valid values are:. * ``off`` (Disable auto-generation of preprocessed source files during a clang crash.); * ``compiler`` (Generate diagnostics for compiler crashes (default)); * ``all`` (Generate diagnostics for all tools which support it). .. option:: -fno-crash-diagnostics. Disable auto-generation of preprocessed source files during a clang crash. The -fno-crash-diagnostics flag can be helpful for speeding the process; of generating a delta reduced test case. .. option:: -fcrash-diagnostics-dir=<dir>. Specify where to write the crash diagnostics files; defaults to the; usual location for temporary files. .. envvar:: CLANG_CRASH_DIAGNOSTICS_DIR=<dir>. Like ``-fcrash-diagnostics-dir=<dir>``, specifies where to write the; crash diagnostics files, but with lower precedence than the option. Clang is also capable of generating preprocess",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:23259,Availability,error,errors,23259,"on:: -fcrash-diagnostics=<val>. Valid values are:. * ``off`` (Disable auto-generation of preprocessed source files during a clang crash.); * ``compiler`` (Generate diagnostics for compiler crashes (default)); * ``all`` (Generate diagnostics for all tools which support it). .. option:: -fno-crash-diagnostics. Disable auto-generation of preprocessed source files during a clang crash. The -fno-crash-diagnostics flag can be helpful for speeding the process; of generating a delta reduced test case. .. option:: -fcrash-diagnostics-dir=<dir>. Specify where to write the crash diagnostics files; defaults to the; usual location for temporary files. .. envvar:: CLANG_CRASH_DIAGNOSTICS_DIR=<dir>. Like ``-fcrash-diagnostics-dir=<dir>``, specifies where to write the; crash diagnostics files, but with lower precedence than the option. Clang is also capable of generating preprocessed source file(s) and associated; run script(s) even without a crash. This is specially useful when trying to; generate a reproducer for warnings or errors while using modules. .. option:: -gen-reproducer. Generates preprocessed source files, a reproducer script and if relevant, a; cache containing: built module pcm's and all headers needed to rebuild the; same modules. .. _rpass:. Options to Emit Optimization Reports; ------------------------------------. Optimization reports trace, at a high-level, all the major decisions; done by compiler transformations. For instance, when the inliner; decides to inline function ``foo()`` into ``bar()``, or the loop unroller; decides to unroll a loop N times, or the vectorizer decides to; vectorize a loop body. Clang offers a family of flags which the optimizers can use to emit; a diagnostic in three cases:. 1. When the pass makes a transformation (`-Rpass`). 2. When the pass fails to make a transformation (`-Rpass-missed`). 3. When the pass determines whether or not to make a transformation; (`-Rpass-analysis`). NOTE: Although the discussion below focuses on `-Rpass`,",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:30053,Availability,avail,available,30053,"`` and other; GNU-namespaced macros, such as ``__GXX_WEAK__``, undefined. .. option:: -MV. When emitting a dependency file, use formatting conventions appropriate; for NMake or Jom. Ignored unless another option causes Clang to emit a; dependency file. When Clang emits a dependency file (e.g., you supplied the -M option); most filenames can be written to the file without any special formatting.; Different Make tools will treat different sets of characters as ""special""; and use different conventions for telling the Make tool that the character; is actually part of the filename. Normally Clang uses backslash to ""escape""; a special character, which is the convention used by GNU Make. The -MV; option tells Clang to put double-quotes around the entire filename, which; is the convention used by NMake and Jom. .. option:: -femit-dwarf-unwind=<value>. When to emit DWARF unwind (EH frame) info. This is a Mach-O-specific option. Valid values are:. * ``no-compact-unwind`` - Only emit DWARF unwind when compact unwind encodings; aren't available. This is the default for arm64.; * ``always`` - Always emit DWARF unwind regardless.; * ``default`` - Use the platform-specific default (``always`` for all; non-arm64-platforms). ``no-compact-unwind`` is a performance optimization -- Clang will emit smaller; object files that are more quickly processed by the linker. This may cause; binary compatibility issues on older x86_64 targets, however, so use it with; caution. .. _configuration-files:. Configuration files; -------------------. Configuration files group command-line options and allow all of them to be; specified just by referencing the configuration file. They may be used, for; example, to collect options required to tune compilation for particular; target, such as ``-L``, ``-I``, ``-l``, ``--sysroot``, codegen options, etc. Configuration files can be either specified on the command line or loaded; from default locations. If both variants are present, the default configuration; fi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:31899,Availability,error,error,31899,"line or loaded; from default locations. If both variants are present, the default configuration; files are loaded first. The command line option ``--config=`` can be used to specify explicit; configuration files in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - the directory where Clang executable resides. Both user and system directories for configuration files are specified during; clang build using CMake parameters, ``CLANG_CONFIG_FILE_USER_DIR`` and; ``CLANG_CONFIG_FILE_SYSTEM_DIR`` respectively. The first file found is used.; It is an error if the required file cannot be found. The default configuration files are searched for in the same directories; following the rules described in the next paragraphs. Loading default; configuration files can be disabled entirely via passing; the ``--no-default-config`` flag. First, the algorithm searches for a configuration file named; ``<triple>-<driver>.cfg`` where `triple` is the triple for the target being; built for, and `driver` is the name of the currently used driver. The algorithm; first attempts to use the canonical name for the driver used, then falls back; to the one found in the executable name. The following canonical driver names are used:. - ``clang`` for the ``gcc`` driver (used to compile C programs); - ``clang++`` for the ``gxx`` driver (used to compile C++ programs); - ``clang-cpp`` for the ``cpp`` driver (pure preprocessor); - ``clang-cl`` for the ``cl`` driver; - ``flang`` for the ``flang`` driver; - ``clang-dxc`` for the ``dxc`` driver. For example, when calling ``x86_64-pc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:34010,Availability,error,error,34010,"gnu-clang++.cfg. If this file is not found, it will attempt to use the name found; in the executable instead::. x86_64-pc-linux-gnu-clang-g++.cfg. Note that options such as ``--driver-mode=``, ``--target=``, ``-m32`` affect; the search algorithm. For example, the aforementioned executable called with; ``-m32`` argument will instead search for::. i386-pc-linux-gnu-clang++.cfg. If none of the aforementioned files are found, the driver will instead search; for separate driver and target configuration files and attempt to load both.; The former is named ``<driver>.cfg`` while the latter is named; ``<triple>.cfg``. Similarly to the previous variants, the canonical driver name; will be preferred, and the compiler will fall back to the actual name. For example, ``x86_64-pc-linux-gnu-clang-g++`` will attempt to load two; configuration files named respectively::. clang++.cfg; x86_64-pc-linux-gnu.cfg. with fallback to trying::. clang-g++.cfg; x86_64-pc-linux-gnu.cfg. It is not an error if either of these files is not found. The configuration file consists of command-line options specified on one or; more lines. Lines composed of whitespace characters only are ignored as well as; lines in which the first non-blank character is ``#``. Long options may be split; between several lines by a trailing backslash. Here is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between lines; -I/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:35902,Availability,error,errors,35902,"s``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate paths relative to the configuration file, the ``<CFGDIR>`` token may; be used. This will expand to the absolute path of the directory containing the; configuration file. In cases where a configuration file is deployed alongside SDK contents, the; SDK directory can remain fully portable by using ``<CFGDIR>`` prefixed paths.; In this way, the user may only need to specify a root configuration file with; ``--config=`` to establish every aspect of the SDK with the compiler:. ::. --target=foo; -isystem <CFGDIR>/include; -L <CFGDIR>/lib; -T <CFGDIR>/ldscripts/link.ld. Language and Target-Independent Features; ========================================. Controlling Errors and Warnings; -------------------------------. Clang provides a number of ways to control which code constructs cause; it to emit errors and warning messages, and how they are displayed to; the console. Controlling How Clang Displays Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When Clang emits a diagnostic, it includes rich information in the; output, and gives you fine-grain control over which information is; printed. Clang has the ability to print this information, and these are; the options that control it:. #. A file/line/column indicator that shows exactly where the diagnostic; occurs in your code [:ref:`-fshow-column <opt_fshow-column>`,; :ref:`-fshow-source-location <opt_fshow-source-location>`].; #. A categorization of the diagnostic as a note, warning, error, or; fatal error.; #. A text string that describes what the problem is.; #. An option that indicates how to control the diagnostic (for; diagnostics that support it); [:ref:`-fdiagnostics-show-option <opt_fdiagnostics-show-option>`].; #. A :ref:`high-level category <diagnostics_categories>` for the diagnostic; for clients that want",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:36557,Availability,error,error,36557,"pect of the SDK with the compiler:. ::. --target=foo; -isystem <CFGDIR>/include; -L <CFGDIR>/lib; -T <CFGDIR>/ldscripts/link.ld. Language and Target-Independent Features; ========================================. Controlling Errors and Warnings; -------------------------------. Clang provides a number of ways to control which code constructs cause; it to emit errors and warning messages, and how they are displayed to; the console. Controlling How Clang Displays Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When Clang emits a diagnostic, it includes rich information in the; output, and gives you fine-grain control over which information is; printed. Clang has the ability to print this information, and these are; the options that control it:. #. A file/line/column indicator that shows exactly where the diagnostic; occurs in your code [:ref:`-fshow-column <opt_fshow-column>`,; :ref:`-fshow-source-location <opt_fshow-source-location>`].; #. A categorization of the diagnostic as a note, warning, error, or; fatal error.; #. A text string that describes what the problem is.; #. An option that indicates how to control the diagnostic (for; diagnostics that support it); [:ref:`-fdiagnostics-show-option <opt_fdiagnostics-show-option>`].; #. A :ref:`high-level category <diagnostics_categories>` for the diagnostic; for clients that want to group diagnostics by class (for diagnostics; that support it); [:option:`-fdiagnostics-show-category`].; #. The line of source code that the issue occurs on, along with a caret; and ranges that indicate the important locations; [:ref:`-fcaret-diagnostics <opt_fcaret-diagnostics>`].; #. ""FixIt"" information, which is a concise explanation of how to fix the; problem (when Clang is certain it knows); [:ref:`-fdiagnostics-fixit-info <opt_fdiagnostics-fixit-info>`].; #. A machine-parsable representation of the ranges involved (off by; default); [:ref:`-fdiagnostics-print-source-range-info <opt_fdiagnostics-print-source-range-info>`]. For m",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:36574,Availability,error,error,36574,"pect of the SDK with the compiler:. ::. --target=foo; -isystem <CFGDIR>/include; -L <CFGDIR>/lib; -T <CFGDIR>/ldscripts/link.ld. Language and Target-Independent Features; ========================================. Controlling Errors and Warnings; -------------------------------. Clang provides a number of ways to control which code constructs cause; it to emit errors and warning messages, and how they are displayed to; the console. Controlling How Clang Displays Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When Clang emits a diagnostic, it includes rich information in the; output, and gives you fine-grain control over which information is; printed. Clang has the ability to print this information, and these are; the options that control it:. #. A file/line/column indicator that shows exactly where the diagnostic; occurs in your code [:ref:`-fshow-column <opt_fshow-column>`,; :ref:`-fshow-source-location <opt_fshow-source-location>`].; #. A categorization of the diagnostic as a note, warning, error, or; fatal error.; #. A text string that describes what the problem is.; #. An option that indicates how to control the diagnostic (for; diagnostics that support it); [:ref:`-fdiagnostics-show-option <opt_fdiagnostics-show-option>`].; #. A :ref:`high-level category <diagnostics_categories>` for the diagnostic; for clients that want to group diagnostics by class (for diagnostics; that support it); [:option:`-fdiagnostics-show-category`].; #. The line of source code that the issue occurs on, along with a caret; and ranges that indicate the important locations; [:ref:`-fcaret-diagnostics <opt_fcaret-diagnostics>`].; #. ""FixIt"" information, which is a concise explanation of how to fix the; problem (when Clang is certain it knows); [:ref:`-fdiagnostics-fixit-info <opt_fdiagnostics-fixit-info>`].; #. A machine-parsable representation of the ranges involved (off by; default); [:ref:`-fdiagnostics-print-source-range-info <opt_fdiagnostics-print-source-range-info>`]. For m",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:38044,Availability,error,errors,38044,"ne of source code that the issue occurs on, along with a caret; and ranges that indicate the important locations; [:ref:`-fcaret-diagnostics <opt_fcaret-diagnostics>`].; #. ""FixIt"" information, which is a concise explanation of how to fix the; problem (when Clang is certain it knows); [:ref:`-fdiagnostics-fixit-info <opt_fdiagnostics-fixit-info>`].; #. A machine-parsable representation of the ranges involved (off by; default); [:ref:`-fdiagnostics-print-source-range-info <opt_fdiagnostics-print-source-range-info>`]. For more information please see :ref:`Formatting of; Diagnostics <cl_diag_formatting>`. Diagnostic Mappings; ^^^^^^^^^^^^^^^^^^^. All diagnostics are mapped into one of these 6 classes:. - Ignored; - Note; - Remark; - Warning; - Error; - Fatal. .. _diagnostics_categories:. Diagnostic Categories; ^^^^^^^^^^^^^^^^^^^^^. Though not shown by default, diagnostics may each be associated with a; high-level category. This category is intended to make it possible to; triage builds that produce a large number of errors or warnings in a; grouped way. Categories are not shown by default, but they can be turned on with the; :option:`-fdiagnostics-show-category` option.; When set to ""``name``"", the category is printed textually in the; diagnostic output. When it is set to ""``id``"", a category number is; printed. The mapping of category names to category id's can be obtained; by running '``clang --print-diagnostic-categories``'. Controlling Diagnostics via Command Line Flags; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. TODO: -W flags, -pedantic, etc. .. _pragma_gcc_diagnostic:. Controlling Diagnostics via Pragmas; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Clang can also control what diagnostics are enabled through the use of; pragmas in the source code. This is useful for turning off specific; warnings in a section of source code. Clang supports GCC's pragma for; compatibility with existing source code, as well as several extensions. The pragma may control any warning th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:39095,Availability,error,error,39095,"Categories are not shown by default, but they can be turned on with the; :option:`-fdiagnostics-show-category` option.; When set to ""``name``"", the category is printed textually in the; diagnostic output. When it is set to ""``id``"", a category number is; printed. The mapping of category names to category id's can be obtained; by running '``clang --print-diagnostic-categories``'. Controlling Diagnostics via Command Line Flags; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. TODO: -W flags, -pedantic, etc. .. _pragma_gcc_diagnostic:. Controlling Diagnostics via Pragmas; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Clang can also control what diagnostics are enabled through the use of; pragmas in the source code. This is useful for turning off specific; warnings in a section of source code. Clang supports GCC's pragma for; compatibility with existing source code, as well as several extensions. The pragma may control any warning that can be used from the command; line. Warnings may be set to ignored, warning, error, or fatal. The; following example code will tell Clang or GCC to ignore the -Wall; warnings:. .. code-block:: c. #pragma GCC diagnostic ignored ""-Wall"". In addition to all of the functionality provided by GCC's pragma, Clang; also allows you to push and pop the current warning state. This is; particularly useful when writing a header file that will be compiled by; other people, because you don't know what warning flags they build with. In the below example :option:`-Wextra-tokens` is ignored for only a single line; of code, after which the diagnostics return to whatever state had previously; existed. .. code-block:: c. #if foo; #endif foo // warning: extra tokens at end of #endif directive. #pragma clang diagnostic push; #pragma clang diagnostic ignored ""-Wextra-tokens"". #if foo; #endif foo // no warning. #pragma clang diagnostic pop. The push and pop pragmas will save and restore the full diagnostic state; of the compiler, regardless of how it was set. That means th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:40556,Availability,error,errors,40556,"or only a single line; of code, after which the diagnostics return to whatever state had previously; existed. .. code-block:: c. #if foo; #endif foo // warning: extra tokens at end of #endif directive. #pragma clang diagnostic push; #pragma clang diagnostic ignored ""-Wextra-tokens"". #if foo; #endif foo // no warning. #pragma clang diagnostic pop. The push and pop pragmas will save and restore the full diagnostic state; of the compiler, regardless of how it was set. That means that it is; possible to use push and pop around GCC compatible diagnostics and Clang; will push and pop them appropriately, while GCC will ignore the pushes; and pops as unknown pragmas. It should be noted that while Clang; supports the GCC pragma, Clang and GCC do not support the exact same set; of warnings, so even when using GCC compatible #pragmas there is no; guarantee that they will have identical behaviour on both compilers. In addition to controlling warnings and errors generated by the compiler, it is; possible to generate custom warning and error messages through the following; pragmas:. .. code-block:: c. // The following will produce warning messages; #pragma message ""some diagnostic message""; #pragma GCC warning ""TODO: replace deprecated feature"". // The following will produce an error message; #pragma GCC error ""Not supported"". These pragmas operate similarly to the ``#warning`` and ``#error`` preprocessor; directives, except that they may also be embedded into preprocessor macros via; the C99 ``_Pragma`` operator, for example:. .. code-block:: c. #define STR(X) #X; #define DEFER(M,...) M(__VA_ARGS__); #define CUSTOM_ERROR(X) _Pragma(STR(GCC error(X "" at line "" DEFER(STR,__LINE__)))). CUSTOM_ERROR(""Feature not available"");. Controlling Diagnostics in System Headers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Warnings are suppressed when they occur in system headers. By default,; an included file is treated as a system header if it is found in an; include path specified by ``-isyste",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:40637,Availability,error,error,40637,"or only a single line; of code, after which the diagnostics return to whatever state had previously; existed. .. code-block:: c. #if foo; #endif foo // warning: extra tokens at end of #endif directive. #pragma clang diagnostic push; #pragma clang diagnostic ignored ""-Wextra-tokens"". #if foo; #endif foo // no warning. #pragma clang diagnostic pop. The push and pop pragmas will save and restore the full diagnostic state; of the compiler, regardless of how it was set. That means that it is; possible to use push and pop around GCC compatible diagnostics and Clang; will push and pop them appropriately, while GCC will ignore the pushes; and pops as unknown pragmas. It should be noted that while Clang; supports the GCC pragma, Clang and GCC do not support the exact same set; of warnings, so even when using GCC compatible #pragmas there is no; guarantee that they will have identical behaviour on both compilers. In addition to controlling warnings and errors generated by the compiler, it is; possible to generate custom warning and error messages through the following; pragmas:. .. code-block:: c. // The following will produce warning messages; #pragma message ""some diagnostic message""; #pragma GCC warning ""TODO: replace deprecated feature"". // The following will produce an error message; #pragma GCC error ""Not supported"". These pragmas operate similarly to the ``#warning`` and ``#error`` preprocessor; directives, except that they may also be embedded into preprocessor macros via; the C99 ``_Pragma`` operator, for example:. .. code-block:: c. #define STR(X) #X; #define DEFER(M,...) M(__VA_ARGS__); #define CUSTOM_ERROR(X) _Pragma(STR(GCC error(X "" at line "" DEFER(STR,__LINE__)))). CUSTOM_ERROR(""Feature not available"");. Controlling Diagnostics in System Headers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Warnings are suppressed when they occur in system headers. By default,; an included file is treated as a system header if it is found in an; include path specified by ``-isyste",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:40884,Availability,error,error,40884," #endif foo // no warning. #pragma clang diagnostic pop. The push and pop pragmas will save and restore the full diagnostic state; of the compiler, regardless of how it was set. That means that it is; possible to use push and pop around GCC compatible diagnostics and Clang; will push and pop them appropriately, while GCC will ignore the pushes; and pops as unknown pragmas. It should be noted that while Clang; supports the GCC pragma, Clang and GCC do not support the exact same set; of warnings, so even when using GCC compatible #pragmas there is no; guarantee that they will have identical behaviour on both compilers. In addition to controlling warnings and errors generated by the compiler, it is; possible to generate custom warning and error messages through the following; pragmas:. .. code-block:: c. // The following will produce warning messages; #pragma message ""some diagnostic message""; #pragma GCC warning ""TODO: replace deprecated feature"". // The following will produce an error message; #pragma GCC error ""Not supported"". These pragmas operate similarly to the ``#warning`` and ``#error`` preprocessor; directives, except that they may also be embedded into preprocessor macros via; the C99 ``_Pragma`` operator, for example:. .. code-block:: c. #define STR(X) #X; #define DEFER(M,...) M(__VA_ARGS__); #define CUSTOM_ERROR(X) _Pragma(STR(GCC error(X "" at line "" DEFER(STR,__LINE__)))). CUSTOM_ERROR(""Feature not available"");. Controlling Diagnostics in System Headers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Warnings are suppressed when they occur in system headers. By default,; an included file is treated as a system header if it is found in an; include path specified by ``-isystem``, but this can be overridden in; several ways. The ``system_header`` pragma can be used to mark the current file as; being a system header. No warnings will be produced from the location of; the pragma onwards within the same file. .. code-block:: c. #if foo; #endif foo // warning: extra ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:40911,Availability,error,error,40911," #endif foo // no warning. #pragma clang diagnostic pop. The push and pop pragmas will save and restore the full diagnostic state; of the compiler, regardless of how it was set. That means that it is; possible to use push and pop around GCC compatible diagnostics and Clang; will push and pop them appropriately, while GCC will ignore the pushes; and pops as unknown pragmas. It should be noted that while Clang; supports the GCC pragma, Clang and GCC do not support the exact same set; of warnings, so even when using GCC compatible #pragmas there is no; guarantee that they will have identical behaviour on both compilers. In addition to controlling warnings and errors generated by the compiler, it is; possible to generate custom warning and error messages through the following; pragmas:. .. code-block:: c. // The following will produce warning messages; #pragma message ""some diagnostic message""; #pragma GCC warning ""TODO: replace deprecated feature"". // The following will produce an error message; #pragma GCC error ""Not supported"". These pragmas operate similarly to the ``#warning`` and ``#error`` preprocessor; directives, except that they may also be embedded into preprocessor macros via; the C99 ``_Pragma`` operator, for example:. .. code-block:: c. #define STR(X) #X; #define DEFER(M,...) M(__VA_ARGS__); #define CUSTOM_ERROR(X) _Pragma(STR(GCC error(X "" at line "" DEFER(STR,__LINE__)))). CUSTOM_ERROR(""Feature not available"");. Controlling Diagnostics in System Headers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Warnings are suppressed when they occur in system headers. By default,; an included file is treated as a system header if it is found in an; include path specified by ``-isystem``, but this can be overridden in; several ways. The ``system_header`` pragma can be used to mark the current file as; being a system header. No warnings will be produced from the location of; the pragma onwards within the same file. .. code-block:: c. #if foo; #endif foo // warning: extra ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:40993,Availability,error,error,40993,"er, regardless of how it was set. That means that it is; possible to use push and pop around GCC compatible diagnostics and Clang; will push and pop them appropriately, while GCC will ignore the pushes; and pops as unknown pragmas. It should be noted that while Clang; supports the GCC pragma, Clang and GCC do not support the exact same set; of warnings, so even when using GCC compatible #pragmas there is no; guarantee that they will have identical behaviour on both compilers. In addition to controlling warnings and errors generated by the compiler, it is; possible to generate custom warning and error messages through the following; pragmas:. .. code-block:: c. // The following will produce warning messages; #pragma message ""some diagnostic message""; #pragma GCC warning ""TODO: replace deprecated feature"". // The following will produce an error message; #pragma GCC error ""Not supported"". These pragmas operate similarly to the ``#warning`` and ``#error`` preprocessor; directives, except that they may also be embedded into preprocessor macros via; the C99 ``_Pragma`` operator, for example:. .. code-block:: c. #define STR(X) #X; #define DEFER(M,...) M(__VA_ARGS__); #define CUSTOM_ERROR(X) _Pragma(STR(GCC error(X "" at line "" DEFER(STR,__LINE__)))). CUSTOM_ERROR(""Feature not available"");. Controlling Diagnostics in System Headers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Warnings are suppressed when they occur in system headers. By default,; an included file is treated as a system header if it is found in an; include path specified by ``-isystem``, but this can be overridden in; several ways. The ``system_header`` pragma can be used to mark the current file as; being a system header. No warnings will be produced from the location of; the pragma onwards within the same file. .. code-block:: c. #if foo; #endif foo // warning: extra tokens at end of #endif directive. #pragma clang system_header. #if foo; #endif foo // no warning. The `--system-header-prefix=` and `--no-syste",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:41254,Availability,error,error,41254," as unknown pragmas. It should be noted that while Clang; supports the GCC pragma, Clang and GCC do not support the exact same set; of warnings, so even when using GCC compatible #pragmas there is no; guarantee that they will have identical behaviour on both compilers. In addition to controlling warnings and errors generated by the compiler, it is; possible to generate custom warning and error messages through the following; pragmas:. .. code-block:: c. // The following will produce warning messages; #pragma message ""some diagnostic message""; #pragma GCC warning ""TODO: replace deprecated feature"". // The following will produce an error message; #pragma GCC error ""Not supported"". These pragmas operate similarly to the ``#warning`` and ``#error`` preprocessor; directives, except that they may also be embedded into preprocessor macros via; the C99 ``_Pragma`` operator, for example:. .. code-block:: c. #define STR(X) #X; #define DEFER(M,...) M(__VA_ARGS__); #define CUSTOM_ERROR(X) _Pragma(STR(GCC error(X "" at line "" DEFER(STR,__LINE__)))). CUSTOM_ERROR(""Feature not available"");. Controlling Diagnostics in System Headers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Warnings are suppressed when they occur in system headers. By default,; an included file is treated as a system header if it is found in an; include path specified by ``-isystem``, but this can be overridden in; several ways. The ``system_header`` pragma can be used to mark the current file as; being a system header. No warnings will be produced from the location of; the pragma onwards within the same file. .. code-block:: c. #if foo; #endif foo // warning: extra tokens at end of #endif directive. #pragma clang system_header. #if foo; #endif foo // no warning. The `--system-header-prefix=` and `--no-system-header-prefix=`; command-line arguments can be used to override whether subsets of an include; path are treated as system headers. When the name in a ``#include`` directive; is found within a header search pat",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:41324,Availability,avail,available,41324,"GCC pragma, Clang and GCC do not support the exact same set; of warnings, so even when using GCC compatible #pragmas there is no; guarantee that they will have identical behaviour on both compilers. In addition to controlling warnings and errors generated by the compiler, it is; possible to generate custom warning and error messages through the following; pragmas:. .. code-block:: c. // The following will produce warning messages; #pragma message ""some diagnostic message""; #pragma GCC warning ""TODO: replace deprecated feature"". // The following will produce an error message; #pragma GCC error ""Not supported"". These pragmas operate similarly to the ``#warning`` and ``#error`` preprocessor; directives, except that they may also be embedded into preprocessor macros via; the C99 ``_Pragma`` operator, for example:. .. code-block:: c. #define STR(X) #X; #define DEFER(M,...) M(__VA_ARGS__); #define CUSTOM_ERROR(X) _Pragma(STR(GCC error(X "" at line "" DEFER(STR,__LINE__)))). CUSTOM_ERROR(""Feature not available"");. Controlling Diagnostics in System Headers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Warnings are suppressed when they occur in system headers. By default,; an included file is treated as a system header if it is found in an; include path specified by ``-isystem``, but this can be overridden in; several ways. The ``system_header`` pragma can be used to mark the current file as; being a system header. No warnings will be produced from the location of; the pragma onwards within the same file. .. code-block:: c. #if foo; #endif foo // warning: extra tokens at end of #endif directive. #pragma clang system_header. #if foo; #endif foo // no warning. The `--system-header-prefix=` and `--no-system-header-prefix=`; command-line arguments can be used to override whether subsets of an include; path are treated as system headers. When the name in a ``#include`` directive; is found within a header search path and starts with a system prefix, the; header is treated as a system ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:45396,Availability,avail,available,45396,"andards. Since :option:`-Weverything` enables every diagnostic, we generally don't; recommend using it. `-Wall` `-Wextra` are a better choice for most projects.; Using :option:`-Weverything` means that updating your compiler is more difficult; because you're exposed to experimental diagnostics which might be of lower; quality than the default ones. If you do use :option:`-Weverything` then we; advise that you address all new compiler diagnostics as they get added to Clang,; either by fixing everything they find or explicitly disabling that diagnostic; with its corresponding `Wno-` option. Note that when combined with :option:`-w` (which disables all warnings),; disabling all warnings wins. Controlling Static Analyzer Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. While not strictly part of the compiler, the diagnostics from Clang's; `static analyzer <https://clang-analyzer.llvm.org>`_ can also be; influenced by the user via changes to the source code. See the available; `annotations <https://clang-analyzer.llvm.org/annotations.html>`_ and the; analyzer's `FAQ; page <https://clang-analyzer.llvm.org/faq.html#exclude_code>`_ for more; information. .. _usersmanual-precompiled-headers:. Precompiled Headers; -------------------. `Precompiled headers <https://en.wikipedia.org/wiki/Precompiled_header>`_; are a general approach employed by many compilers to reduce compilation; time. The underlying motivation of the approach is that it is common for; the same (and often large) header files to be included by multiple; source files. Consequently, compile times can often be greatly improved; by caching some of the (redundant) work done by a compiler to process; headers. Precompiled header files, which represent one of many ways to; implement this optimization, are literally files that represent an; on-disk cache that contains the vital information necessary to reduce; some of the work needed to process a corresponding header file. While; details of precompiled headers vary",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:46052,Availability,redundant,redundant,46052,"th :option:`-w` (which disables all warnings),; disabling all warnings wins. Controlling Static Analyzer Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. While not strictly part of the compiler, the diagnostics from Clang's; `static analyzer <https://clang-analyzer.llvm.org>`_ can also be; influenced by the user via changes to the source code. See the available; `annotations <https://clang-analyzer.llvm.org/annotations.html>`_ and the; analyzer's `FAQ; page <https://clang-analyzer.llvm.org/faq.html#exclude_code>`_ for more; information. .. _usersmanual-precompiled-headers:. Precompiled Headers; -------------------. `Precompiled headers <https://en.wikipedia.org/wiki/Precompiled_header>`_; are a general approach employed by many compilers to reduce compilation; time. The underlying motivation of the approach is that it is common for; the same (and often large) header files to be included by multiple; source files. Consequently, compile times can often be greatly improved; by caching some of the (redundant) work done by a compiler to process; headers. Precompiled header files, which represent one of many ways to; implement this optimization, are literally files that represent an; on-disk cache that contains the vital information necessary to reduce; some of the work needed to process a corresponding header file. While; details of precompiled headers vary between compilers, precompiled; headers have been shown to be highly effective at speeding up program; compilation on systems with very large system headers (e.g., macOS). Generating a PCH File; ^^^^^^^^^^^^^^^^^^^^^. To generate a PCH file using Clang, one invokes Clang with the; `-x <language>-header` option. This mirrors the interface in GCC; for generating PCH files:. .. code-block:: console. $ gcc -x c-header test.h -o test.h.gch; $ clang -x c-header test.h -o test.h.pch. Using a PCH File; ^^^^^^^^^^^^^^^^. A PCH file can then be used as a prefix header when a ``-include-pch``; option is passed to ``clang``:.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:47179,Availability,avail,available,47179,"tion, are literally files that represent an; on-disk cache that contains the vital information necessary to reduce; some of the work needed to process a corresponding header file. While; details of precompiled headers vary between compilers, precompiled; headers have been shown to be highly effective at speeding up program; compilation on systems with very large system headers (e.g., macOS). Generating a PCH File; ^^^^^^^^^^^^^^^^^^^^^. To generate a PCH file using Clang, one invokes Clang with the; `-x <language>-header` option. This mirrors the interface in GCC; for generating PCH files:. .. code-block:: console. $ gcc -x c-header test.h -o test.h.gch; $ clang -x c-header test.h -o test.h.pch. Using a PCH File; ^^^^^^^^^^^^^^^^. A PCH file can then be used as a prefix header when a ``-include-pch``; option is passed to ``clang``:. .. code-block:: console. $ clang -include-pch test.h.pch test.c -o test. The ``clang`` driver will check if the PCH file ``test.h.pch`` is; available; if so, the contents of ``test.h`` (and the files it includes); will be processed from the PCH file. Otherwise, Clang will report an error. .. note::. Clang does *not* automatically use PCH files for headers that are directly; included within a source file or indirectly via :option:`-include`.; For example:. .. code-block:: console. $ clang -x c-header test.h -o test.h.pch; $ cat test.c; #include ""test.h""; $ clang test.c -o test. In this example, ``clang`` will not automatically use the PCH file for; ``test.h`` since ``test.h`` was included directly in the source file and not; specified on the command line using ``-include-pch``. Relocatable PCH Files; ^^^^^^^^^^^^^^^^^^^^^. It is sometimes necessary to build a precompiled header from headers; that are not yet in their final, installed locations. For example, one; might build a precompiled header within the build tree that is then; meant to be installed alongside the headers. Clang permits the creation; of ""relocatable"" precompiled headers, ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:47322,Availability,error,error,47322,"; some of the work needed to process a corresponding header file. While; details of precompiled headers vary between compilers, precompiled; headers have been shown to be highly effective at speeding up program; compilation on systems with very large system headers (e.g., macOS). Generating a PCH File; ^^^^^^^^^^^^^^^^^^^^^. To generate a PCH file using Clang, one invokes Clang with the; `-x <language>-header` option. This mirrors the interface in GCC; for generating PCH files:. .. code-block:: console. $ gcc -x c-header test.h -o test.h.gch; $ clang -x c-header test.h -o test.h.pch. Using a PCH File; ^^^^^^^^^^^^^^^^. A PCH file can then be used as a prefix header when a ``-include-pch``; option is passed to ``clang``:. .. code-block:: console. $ clang -include-pch test.h.pch test.c -o test. The ``clang`` driver will check if the PCH file ``test.h.pch`` is; available; if so, the contents of ``test.h`` (and the files it includes); will be processed from the PCH file. Otherwise, Clang will report an error. .. note::. Clang does *not* automatically use PCH files for headers that are directly; included within a source file or indirectly via :option:`-include`.; For example:. .. code-block:: console. $ clang -x c-header test.h -o test.h.pch; $ cat test.c; #include ""test.h""; $ clang test.c -o test. In this example, ``clang`` will not automatically use the PCH file for; ``test.h`` since ``test.h`` was included directly in the source file and not; specified on the command line using ``-include-pch``. Relocatable PCH Files; ^^^^^^^^^^^^^^^^^^^^^. It is sometimes necessary to build a precompiled header from headers; that are not yet in their final, installed locations. For example, one; might build a precompiled header within the build tree that is then; meant to be installed alongside the headers. Clang permits the creation; of ""relocatable"" precompiled headers, which are built with a given path; (into the build directory) and can later be used from an installed; location. T",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:50535,Availability,down,downward,50535,"`mylib.h`` in ``/Developer/SDKs/MacOSX10.4u.sdk/usr/include/mylib.h``. Relocatable precompiled headers are intended to be used in a limited; number of cases where the compilation environment is tightly controlled; and the precompiled header cannot be generated after headers have been; installed. .. _controlling-fp-behavior:. Controlling Floating Point Behavior; -----------------------------------. Clang provides a number of ways to control floating point behavior, including; with command line options and source pragmas. This section; describes the various floating point semantic modes and the corresponding options. .. csv-table:: Floating Point Semantic Modes; :header: ""Mode"", ""Values""; :widths: 15, 30, 30. ""ffp-exception-behavior"", ""{ignore, strict, maytrap}"",; ""fenv_access"", ""{off, on}"", ""(none)""; ""frounding-math"", ""{dynamic, tonearest, downward, upward, towardzero}""; ""ffp-contract"", ""{on, off, fast, fast-honor-pragmas}""; ""fdenormal-fp-math"", ""{IEEE, PreserveSign, PositiveZero}""; ""fdenormal-fp-math-fp32"", ""{IEEE, PreserveSign, PositiveZero}""; ""fmath-errno"", ""{on, off}""; ""fhonor-nans"", ""{on, off}""; ""fhonor-infinities"", ""{on, off}""; ""fsigned-zeros"", ""{on, off}""; ""freciprocal-math"", ""{on, off}""; ""allow_approximate_fns"", ""{on, off}""; ""fassociative-math"", ""{on, off}"". This table describes the option settings that correspond to the three; floating point semantic models: precise (the default), strict, and fast. .. csv-table:: Floating Point Models; :header: ""Mode"", ""Precise"", ""Strict"", ""Fast""; :widths: 25, 15, 15, 15. ""except_behavior"", ""ignore"", ""strict"", ""ignore""; ""fenv_access"", ""off"", ""on"", ""off""; ""rounding_mode"", ""tonearest"", ""dynamic"", ""tonearest""; ""contract"", ""on"", ""off"", ""fast""; ""denormal_fp_math"", ""IEEE"", ""IEEE"", ""IEEE""; ""denormal_fp32_math"", ""IEEE"",""IEEE"", ""IEEE""; ""support_math_errno"", ""on"", ""on"", ""off""; ""no_honor_nans"", ""off"", ""off"", ""on""; ""no_honor_infinities"", ""off"", ""off"", ""on""; ""no_signed_zeros"", ""off"", ""off"", ""on""; ""allow_reciprocal"", ""off"", ""off"", ""on""; ""a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:55526,Availability,error,errors,55526,"``-fno-fast-math`` causes ``crtfastmath.o`` to not be linked with code. .. option:: -fdenormal-fp-math=<value>. Select which denormal numbers the code is permitted to require. Valid values are:. * ``ieee`` - IEEE 754 denormal numbers; * ``preserve-sign`` - the sign of a flushed-to-zero number is preserved in the sign of 0; * ``positive-zero`` - denormals are flushed to positive zero. The default value depends on the target. For most targets, defaults to; ``ieee``. .. option:: -f[no-]strict-float-cast-overflow. When a floating-point value is not representable in a destination integer; type, the code has undefined behavior according to the language standard.; By default, Clang will not guarantee any particular result in that case.; With the 'no-strict' option, Clang will saturate towards the smallest and; largest representable integer values instead. NaNs will be converted to zero.; Defaults to ``-fstrict-float-cast-overflow``. .. option:: -f[no-]math-errno. Require math functions to indicate errors by setting errno.; The default varies by ToolChain. ``-fno-math-errno`` allows optimizations; that might cause standard C math functions to not set ``errno``.; For example, on some systems, the math function ``sqrt`` is specified; as setting ``errno`` to ``EDOM`` when the input is negative. On these; systems, the compiler cannot normally optimize a call to ``sqrt`` to use; inline code (e.g. the x86 ``sqrtsd`` instruction) without additional; checking to ensure that ``errno`` is set appropriately.; ``-fno-math-errno`` permits these transformations. On some targets, math library functions never set ``errno``, and so; ``-fno-math-errno`` is the default. This includes most BSD-derived; systems, including Darwin. .. option:: -f[no-]trapping-math. Control floating point exception behavior. ``-fno-trapping-math`` allows optimizations that assume that floating point operations cannot generate traps such as divide-by-zero, overflow and underflow. - The option ``-ftrapping-math`` be",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:63730,Availability,mask,masked,63730," and disables contractions (FMA). All; of the ``-ffast-math`` enablements are disabled. Enables; ``STDC FENV_ACCESS``: by default ``FENV_ACCESS`` is disabled. This option; setting behaves as though ``#pragma STDC FENV_ACCESS ON`` appeared at the; top of the source file.; * ``fast`` Behaves identically to specifying both ``-ffast-math`` and; ``ffp-contract=fast``. Note: If your command line specifies multiple instances; of the ``-ffp-model`` option, or if your command line option specifies; ``-ffp-model`` and later on the command line selects a floating point; option that has the effect of negating part of the ``ffp-model`` that; has been selected, then the compiler will issue a diagnostic warning; that the override has occurred. .. option:: -ffp-exception-behavior=<value>. Specify the floating-point exception behavior. Valid values are: ``ignore``, ``maytrap``, and ``strict``.; The default value is ``ignore``. Details:. * ``ignore`` The compiler assumes that the exception status flags will not be read and that floating point exceptions will be masked.; * ``maytrap`` The compiler avoids transformations that may raise exceptions that would not have been raised by the original code. Constant folding performed by the compiler is exempt from this option.; * ``strict`` The compiler ensures that all transformations strictly preserve the floating point exception semantics of the original code. .. option:: -ffp-eval-method=<value>. Specify the floating-point evaluation method for intermediate results within; a single expression of the code. Valid values are: ``source``, ``double``, and ``extended``.; For 64-bit targets, the default value is ``source``. For 32-bit x86 targets; however, in the case of NETBSD 6.99.26 and under, the default value is; ``double``; in the case of NETBSD greater than 6.99.26, with NoSSE, the; default value is ``extended``, with SSE the default value is ``source``.; Details:. * ``source`` The compiler uses the floating-point type declared in the sour",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:67080,Availability,reliab,reliable,67080,"hat in safe floating-point; modes, such as `-ffp-model=precise` or `-ffp-model=strict`, this option; has no effect because the optimizer is prohibited from making unsafe; transformations. .. option:: -fexcess-precision:. The C and C++ standards allow floating-point expressions to be computed as if; intermediate results had more precision (and/or a wider range) than the type; of the expression strictly allows. This is called excess precision; arithmetic.; Excess precision arithmetic can improve the accuracy of results (although not; always), and it can make computation significantly faster if the target lacks; direct hardware support for arithmetic in a particular type. However, it can; also undermine strict floating-point reproducibility. Under the standards, assignments and explicit casts force the operand to be; converted to its formal type, discarding any excess precision. Because data; can only flow between statements via an assignment, this means that the use; of excess precision arithmetic is a reliable local property of a single; statement, and results do not change based on optimization. However, when; excess precision arithmetic is in use, Clang does not guarantee strict; reproducibility, and future compiler releases may recognize more; opportunities to use excess precision arithmetic, e.g. with floating-point; builtins. Clang does not use excess precision arithmetic for most types or on most; targets. For example, even on pre-SSE X86 targets where ``float`` and; ``double`` computations must be performed in the 80-bit X87 format, Clang; rounds all intermediate results correctly for their type. Clang currently; uses excess precision arithmetic by default only for the following types and; targets:. * ``_Float16`` on X86 targets without ``AVX512-FP16``. The ``-fexcess-precision=<value>`` option can be used to control the use of; excess precision arithmetic. Valid values are:. * ``standard`` - The default. Allow the use of excess precision arithmetic; under the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:72535,Availability,error,error,72535,"th.o:. A note about ``crtfastmath.o``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ``-ffast-math`` and ``-funsafe-math-optimizations`` cause ``crtfastmath.o`` to be; automatically linked, which adds a static constructor that sets the FTZ/DAZ; bits in MXCSR, affecting not only the current compilation unit but all static; and shared libraries included in the program. .. _FLT_EVAL_METHOD:. A note about ``__FLT_EVAL_METHOD__``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; The ``__FLT_EVAL_METHOD__`` is not defined as a traditional macro, and so it; will not appear when dumping preprocessor macros. Instead, the value; ``__FLT_EVAL_METHOD__`` expands to is determined at the point of expansion; either from the value set by the ``-ffp-eval-method`` command line option or; from the target. This is because the ``__FLT_EVAL_METHOD__`` macro; cannot expand to the correct evaluation method in the presence of a ``#pragma``; which alters the evaluation method. An error is issued if; ``__FLT_EVAL_METHOD__`` is expanded inside a scope modified by; ``#pragma clang fp eval_method``. .. _fp-constant-eval:. A note about Floating Point Constant Evaluation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In C, the only place floating point operations are guaranteed to be evaluated; during translation is in the initializers of variables of static storage; duration, which are all notionally initialized before the program begins; executing (and thus before a non-default floating point environment can be; entered). But C++ has many more contexts where floating point constant; evaluation occurs. Specifically: for static/thread-local variables,; first try evaluating the initializer in a constant context, including in the; constant floating point environment (just like in C), and then, if that fails,; fall back to emitting runtime code to perform the initialization (which might; in general be in a different floating point environment). Consider this example when compiled with ``-frounding-math``. .. code-block:: c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:75290,Availability,error,error,75290,"on’’). All computation for initialization of objects; that have static or thread storage duration is done (as if) at translation; time.* C++ generalizes this by adding another phase of initialization; (at runtime) if the translation-time initialization fails, but the; translation-time evaluation of the initializer of succeeds, it will be; treated as a constant initializer. .. _controlling-code-generation:. Controlling Code Generation; ---------------------------. Clang provides a number of ways to control code generation. The options; are listed below. .. option:: -f[no-]sanitize=check1,check2,... Turn on runtime checks for various forms of undefined or suspicious; behavior. This option controls whether Clang adds runtime checks for various; forms of undefined or suspicious behavior, and is disabled by; default. If a check fails, a diagnostic message is produced at; runtime explaining the problem. The main checks are:. - .. _opt_fsanitize_address:. ``-fsanitize=address``:; :doc:`AddressSanitizer`, a memory error; detector.; - .. _opt_fsanitize_thread:. ``-fsanitize=thread``: :doc:`ThreadSanitizer`, a data race detector.; - .. _opt_fsanitize_memory:. ``-fsanitize=memory``: :doc:`MemorySanitizer`,; a detector of uninitialized reads. Requires instrumentation of all; program code.; - .. _opt_fsanitize_undefined:. ``-fsanitize=undefined``: :doc:`UndefinedBehaviorSanitizer`,; a fast and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:76093,Availability,error,errors,76093," suspicious behavior, and is disabled by; default. If a check fails, a diagnostic message is produced at; runtime explaining the problem. The main checks are:. - .. _opt_fsanitize_address:. ``-fsanitize=address``:; :doc:`AddressSanitizer`, a memory error; detector.; - .. _opt_fsanitize_thread:. ``-fsanitize=thread``: :doc:`ThreadSanitizer`, a data race detector.; - .. _opt_fsanitize_memory:. ``-fsanitize=memory``: :doc:`MemorySanitizer`,; a detector of uninitialized reads. Requires instrumentation of all; program code.; - .. _opt_fsanitize_undefined:. ``-fsanitize=undefined``: :doc:`UndefinedBehaviorSanitizer`,; a fast and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitize",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:76136,Availability,avail,available,76136,"opt_fsanitize_address:. ``-fsanitize=address``:; :doc:`AddressSanitizer`, a memory error; detector.; - .. _opt_fsanitize_thread:. ``-fsanitize=thread``: :doc:`ThreadSanitizer`, a data race detector.; - .. _opt_fsanitize_memory:. ``-fsanitize=memory``: :doc:`MemorySanitizer`,; a detector of uninitialized reads. Requires instrumentation of all; program code.; - .. _opt_fsanitize_undefined:. ``-fsanitize=undefined``: :doc:`UndefinedBehaviorSanitizer`,; a fast and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:76618,Availability,recover,recover,76618,"fined``: :doc:`UndefinedBehaviorSanitizer`,; a fast and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:76672,Availability,recover,recover,76672,"t and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effec",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:76814,Availability,error,error,76814,"``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:76850,Availability,error,error,76850,"``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:77060,Availability,recover,recovery,77060,"tack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binar",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:77627,Availability,recover,recover,77627,"r=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ign",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:79399,Availability,error,error,79399,"gnorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sanitizers.; See :doc:`SanitizerCoverage` for more details. .. option:: -f[no-]sanitize-address-outline-instrumentation. Controls how address sanitizer code is generated. If enabled will always use; a function call instead of inlining the code. Turning this option on could; reduce the binary size, but might result in a worse run-time performance. See :doc: `AddressSanitizer` for more details. .. option:: -f[no-]sanitize-stats. Enable simple statistics gathering for the enabled sanitizers.; See :doc:`SanitizerStats` for more details. .. option:: -fsanitize-undefined-trap-on-error. Deprecated alias for ``-fsanitize-trap=undefined``. .. option:: -fsanitize-cfi-cross-dso. Enable cross-DSO control flow integrity checks. This flag modifies; the behavior of sanitizers in the ``cfi`` group to allow checking; of cross-DSO virtual and indirect calls. .. option:: -fsanitize-cfi-icall-generalize-pointers. Generalize pointers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more details. .. option:: -fsanitize-cfi-icall-experimental-normalize-integers. Normalize integers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more details. This option is currently experimental. .. option:: -fstrict-vtable-pointers. Enable optimizations based on the strict rules for overwriting polymorphic; C++ objects, i.e. the vptr is invariant during an object's lifeti",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:81085,Availability,error,error,81085,"ow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more details. This option is currently experimental. .. option:: -fstrict-vtable-pointers. Enable optimizations based on the strict rules for overwriting polymorphic; C++ objects, i.e. the vptr is invariant during an object's lifetime.; This enables better devirtualization. Turned off by default, because it is; still experimental. .. option:: -fwhole-program-vtables. Enable whole-program vtable optimizations, such as single-implementation; devirtualization and virtual constant propagation, for classes with; :doc:`hidden LTO visibility <LTOVisibility>`. Requires ``-flto``. .. option:: -f[no]split-lto-unit. Controls splitting the :doc:`LTO unit <LTOVisibility>` into regular LTO and; :doc:`ThinLTO` portions, when compiling with -flto=thin. Defaults to false; unless ``-fsanitize=cfi`` or ``-fwhole-program-vtables`` are specified, in; which case it defaults to true. Splitting is required with ``fsanitize=cfi``,; and it is an error to disable via ``-fno-split-lto-unit``. Splitting is; optional with ``-fwhole-program-vtables``, however, it enables more; aggressive whole program vtable optimizations (specifically virtual constant; propagation). When enabled, vtable definitions and select virtual functions are placed; in the split regular LTO module, enabling more aggressive whole program; vtable optimizations required for CFI and virtual constant propagation.; However, this can increase the LTO link time and memory requirements over; pure ThinLTO, as all split regular LTO modules are merged and LTO linked; with regular LTO. .. option:: -fforce-emit-vtables. In order to improve devirtualization, forces emitting of vtables even in; modules where it isn't necessary. It causes more inline virtual functions; to be emitted. .. option:: -fno-assume-sane-operator-new. Don't assume that the C++'s new operator is sane. This option tells the compiler to do not assume that C++'s global; new operator will always r",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:82393,Availability,error,error,82393,"tual functions are placed; in the split regular LTO module, enabling more aggressive whole program; vtable optimizations required for CFI and virtual constant propagation.; However, this can increase the LTO link time and memory requirements over; pure ThinLTO, as all split regular LTO modules are merged and LTO linked; with regular LTO. .. option:: -fforce-emit-vtables. In order to improve devirtualization, forces emitting of vtables even in; modules where it isn't necessary. It causes more inline virtual functions; to be emitted. .. option:: -fno-assume-sane-operator-new. Don't assume that the C++'s new operator is sane. This option tells the compiler to do not assume that C++'s global; new operator will always return a pointer that does not alias any; other pointer when the function returns. .. option:: -fassume-nothrow-exception-dtor. Assume that an exception object' destructor will not throw, and generate; less code for catch handlers. A throw expression of a type with a; potentially-throwing destructor will lead to an error. By default, Clang assumes that the exception object may have a throwing; destructor. For the Itanium C++ ABI, Clang generates a landing pad to; destroy local variables and call ``_Unwind_Resume`` for the code; ``catch (...) { ... }``. This option tells Clang that an exception object's; destructor will not throw and code simplification is possible. .. option:: -ftrap-function=[name]. Instruct code generator to emit a function call to the specified; function name for ``__builtin_trap()``. LLVM code generator translates ``__builtin_trap()`` to a trap; instruction if it is supported by the target ISA. Otherwise, the; builtin is translated into a call to ``abort``. If this option is; set, then the code generator will always lower the builtin to a call; to the specified function regardless of whether the target ISA has a; trap instruction. This option is useful for environments (e.g.; deeply embedded) where a trap cannot be properly handled, or ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:93915,Availability,avail,available,93915,"is is important for the profiler to be able to map; instructions back to source line locations. .. code-block:: console. $ clang++ -O2 -gline-tables-only code.cc -o code. 2. Run the executable under a sampling profiler. The specific profiler; you use does not really matter, as long as its output can be converted; into the format that the LLVM optimizer understands. Currently, there; exists a conversion tool for the Linux Perf profiler; (https://perf.wiki.kernel.org/), so these examples assume that you; are using Linux Perf to profile your code. .. code-block:: console. $ perf record -b ./code. Note the use of the ``-b`` flag. This tells Perf to use the Last Branch; Record (LBR) to record call chains. While this is not strictly required,; it provides better call information, which improves the accuracy of; the profile data. 3. Convert the collected profile data to LLVM's sample profile format.; This is currently supported via the AutoFDO converter ``create_llvm_prof``.; It is available at https://github.com/google/autofdo. Once built and; installed, you can convert the ``perf.data`` file to LLVM using; the command:. .. code-block:: console. $ create_llvm_prof --binary=./code --out=code.prof. This will read ``perf.data`` and the binary file ``./code`` and emit; the profile data in ``code.prof``. Note that if you ran ``perf``; without the ``-b`` flag, you need to use ``--use_lbr=false`` when; calling ``create_llvm_prof``. Alternatively, the LLVM tool ``llvm-profgen`` can also be used to generate; the LLVM sample profile:. .. code-block:: console. $ llvm-profgen --binary=./code --output=code.prof--perfdata=perf.data. 4. Build the code again using the collected profile. This step feeds; the profile back to the optimizers. This should result in a binary; that executes faster than the original one. Note that you are not; required to build the code with the exact same arguments that you; used in the first step. The only requirement is that you build the code; with ``-gline-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:98003,Availability,error,error,98003,"one to generate. If you are interested in generating any; of the other two, consult the ``ProfileData`` library in LLVM's source tree; (specifically, ``include/llvm/ProfileData/SampleProfReader.h``). .. code-block:: console. function1:total_samples:total_head_samples; offset1[.discriminator]: number_of_samples [fn1:num fn2:num ... ]; offset2[.discriminator]: number_of_samples [fn3:num fn4:num ... ]; ...; offsetN[.discriminator]: number_of_samples [fn5:num fn6:num ... ]; offsetA[.discriminator]: fnA:num_of_total_samples; offsetA1[.discriminator]: number_of_samples [fn7:num fn8:num ... ]; offsetA1[.discriminator]: number_of_samples [fn9:num fn10:num ... ]; offsetB[.discriminator]: fnB:num_of_total_samples; offsetB1[.discriminator]: number_of_samples [fn11:num fn12:num ... ]. This is a nested tree in which the indentation represents the nesting level; of the inline stack. There are no blank lines in the file. And the spacing; within a single line is fixed. Additional spaces will result in an error; while reading the file. Any line starting with the '#' character is completely ignored. Inlined calls are represented with indentation. The Inline stack is a; stack of source locations in which the top of the stack represents the; leaf function, and the bottom of the stack represents the actual; symbol to which the instruction belongs. Function names must be mangled in order for the profile loader to; match them in the current translation unit. The two numbers in the; function header specify how many total samples were accumulated in the; function (first number), and the total number of samples accumulated; in the prologue of the function (second number). This head sample; count provides an indicator of how frequently the function is invoked. There are two types of lines in the function body. - Sampled line represents the profile information of a source location.; ``offsetN[.discriminator]: number_of_samples [fn5:num fn6:num ... ]``. - Callsite line represents the profile inf",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:130388,Availability,error,errors,130388,"lock-commands=foo,bar`` defines; custom commands ``\foo`` and ``\bar``. It is also possible to use ``-fcomment-block-commands`` several times; e.g.; ``-fcomment-block-commands=foo -fcomment-block-commands=bar`` does the same; as above. .. _c:. C Language Features; ===================. The support for standard C in clang is feature-complete except for the; C99 floating-point pragmas. Extensions supported by clang; -----------------------------. See :doc:`LanguageExtensions`. Differences between various standard modes; ------------------------------------------. clang supports the -std option, which changes what language mode clang uses.; The supported modes for C are c89, gnu89, c94, c99, gnu99, c11, gnu11, c17,; gnu17, c23, gnu23, and various aliases for those modes. If no -std option is; specified, clang defaults to gnu17 mode. Many C99 and C11 features are; supported in earlier modes as a conforming extension, with a warning. Use; ``-pedantic-errors`` to request an error if a feature from a later standard; revision is used in an earlier mode. Differences between all ``c*`` and ``gnu*`` modes:. - ``c*`` modes define ""``__STRICT_ANSI__``"".; - Target-specific defines not prefixed by underscores, like ``linux``,; are defined in ``gnu*`` modes.; - Trigraphs default to being off in ``gnu*`` modes; they can be enabled; by the ``-trigraphs`` option.; - The parser recognizes ``asm`` and ``typeof`` as keywords in ``gnu*`` modes;; the variants ``__asm__`` and ``__typeof__`` are recognized in all modes.; - The parser recognizes ``inline`` as a keyword in ``gnu*`` mode, in; addition to recognizing it in the ``*99`` and later modes for which it is; part of the ISO C standard. The variant ``__inline__`` is recognized in all; modes.; - The Apple ""blocks"" extension is recognized by default in ``gnu*`` modes; on some platforms; it can be enabled in any mode with the ``-fblocks``; option. Differences between ``*89`` and ``*94`` modes:. - Digraphs are not recognized in c89 mode. Diffe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:130411,Availability,error,error,130411,"lock-commands=foo,bar`` defines; custom commands ``\foo`` and ``\bar``. It is also possible to use ``-fcomment-block-commands`` several times; e.g.; ``-fcomment-block-commands=foo -fcomment-block-commands=bar`` does the same; as above. .. _c:. C Language Features; ===================. The support for standard C in clang is feature-complete except for the; C99 floating-point pragmas. Extensions supported by clang; -----------------------------. See :doc:`LanguageExtensions`. Differences between various standard modes; ------------------------------------------. clang supports the -std option, which changes what language mode clang uses.; The supported modes for C are c89, gnu89, c94, c99, gnu99, c11, gnu11, c17,; gnu17, c23, gnu23, and various aliases for those modes. If no -std option is; specified, clang defaults to gnu17 mode. Many C99 and C11 features are; supported in earlier modes as a conforming extension, with a warning. Use; ``-pedantic-errors`` to request an error if a feature from a later standard; revision is used in an earlier mode. Differences between all ``c*`` and ``gnu*`` modes:. - ``c*`` modes define ""``__STRICT_ANSI__``"".; - Target-specific defines not prefixed by underscores, like ``linux``,; are defined in ``gnu*`` modes.; - Trigraphs default to being off in ``gnu*`` modes; they can be enabled; by the ``-trigraphs`` option.; - The parser recognizes ``asm`` and ``typeof`` as keywords in ``gnu*`` modes;; the variants ``__asm__`` and ``__typeof__`` are recognized in all modes.; - The parser recognizes ``inline`` as a keyword in ``gnu*`` mode, in; addition to recognizing it in the ``*99`` and later modes for which it is; part of the ISO C standard. The variant ``__inline__`` is recognized in all; modes.; - The Apple ""blocks"" extension is recognized by default in ``gnu*`` modes; on some platforms; it can be enabled in any mode with the ``-fblocks``; option. Differences between ``*89`` and ``*94`` modes:. - Digraphs are not recognized in c89 mode. Diffe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:136469,Availability,reliab,reliably,136469,"e a section for bug-reporting; guidelines somewhere?). Intentionally unsupported GCC extensions; ----------------------------------------. - clang does not support the gcc extension that allows variable-length; arrays in structures. This is for a few reasons: one, it is tricky to; implement, two, the extension is completely undocumented, and three,; the extension appears to be rarely used. Note that clang *does*; support flexible array members (arrays with a zero or unspecified; size at the end of a structure).; - GCC accepts many expression forms that are not valid integer constant; expressions in bit-field widths, enumerator constants, case labels,; and in array bounds at global scope. Clang also accepts additional; expression forms in these contexts, but constructs that GCC accepts due to; simplifications GCC performs while parsing, such as ``x - x`` (where ``x`` is a; variable) will likely never be accepted by Clang.; - clang does not support ``__builtin_apply`` and friends; this extension; is extremely obscure and difficult to implement reliably. .. _c_ms:. Microsoft extensions; --------------------. clang has support for many extensions from Microsoft Visual C++. To enable these; extensions, use the ``-fms-extensions`` command-line option. This is the default; for Windows targets. Clang does not implement every pragma or declspec provided; by MSVC, but the popular ones, such as ``__declspec(dllexport)`` and ``#pragma; comment(lib)`` are well supported. clang has a ``-fms-compatibility`` flag that makes clang accept enough; invalid C++ to be able to parse most Microsoft headers. For example, it; allows `unqualified lookup of dependent base class members; <https://clang.llvm.org/compatibility.html#dep_lookup_bases>`_, which is; a common compatibility issue with clang. This flag is enabled by default; for Windows targets. ``-fdelayed-template-parsing`` lets clang delay parsing of function template; definitions until the end of a translation unit. This flag is enab",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:140899,Availability,echo,echo,140899," Controlling implementation limits; ---------------------------------. .. option:: -fopenmp-use-tls. Controls code generation for OpenMP threadprivate variables. In presence of; this option all threadprivate variables are generated the same way as thread; local variables, using TLS support. If `-fno-openmp-use-tls`; is provided or target does not support TLS, code generation for threadprivate; variables relies on OpenMP runtime library. .. _opencl:. OpenCL Features; ===============. Clang can be used to compile OpenCL kernels for execution on a device; (e.g. GPU). It is possible to compile the kernel into a binary (e.g. for AMDGPU); that can be uploaded to run directly on a device (e.g. using; `clCreateProgramWithBinary; <https://www.khronos.org/registry/OpenCL/specs/opencl-1.1.pdf#111>`_) or; into generic bitcode files loadable into other toolchains. Compiling to a binary using the default target from the installation can be done; as follows:. .. code-block:: console. $ echo ""kernel void k(){}"" > test.cl; $ clang test.cl. Compiling for a specific target can be done by specifying the triple corresponding; to the target, for example:. .. code-block:: console. $ clang --target=nvptx64-unknown-unknown test.cl; $ clang --target=amdgcn-amd-amdhsa -mcpu=gfx900 test.cl. Compiling to bitcode can be done as follows:. .. code-block:: console. $ clang -c -emit-llvm test.cl. This will produce a file `test.bc` that can be used in vendor toolchains; to perform machine code generation. Note that if compiled to bitcode for generic targets such as SPIR/SPIR-V,; portable IR is produced that can be used with various vendor; tools as well as open source tools such as `SPIRV-LLVM Translator; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator>`_; to produce SPIR-V binary. More details are provided in `the offline; compilation from OpenCL kernel sources into SPIR-V using open source; tools; <https://github.com/KhronosGroup/OpenCL-Guide/blob/main/chapters/os_tooling.md>`_.; From clang 1",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:142208,Availability,avail,available,142208,"ne as follows:. .. code-block:: console. $ clang -c -emit-llvm test.cl. This will produce a file `test.bc` that can be used in vendor toolchains; to perform machine code generation. Note that if compiled to bitcode for generic targets such as SPIR/SPIR-V,; portable IR is produced that can be used with various vendor; tools as well as open source tools such as `SPIRV-LLVM Translator; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator>`_; to produce SPIR-V binary. More details are provided in `the offline; compilation from OpenCL kernel sources into SPIR-V using open source; tools; <https://github.com/KhronosGroup/OpenCL-Guide/blob/main/chapters/os_tooling.md>`_.; From clang 14 onwards SPIR-V can be generated directly as detailed in; :ref:`the SPIR-V support section <spir-v>`. Clang currently supports OpenCL C language standards up to v2.0. Clang mainly; supports full profile. There is only very limited support of the embedded; profile.; From clang 9 a C++ mode is available for OpenCL (see; :ref:`C++ for OpenCL <cxx_for_opencl>`). OpenCL v3.0 support is complete but it remains in experimental state, see more; details about the experimental features and limitations in :doc:`OpenCLSupport`; page. OpenCL Specific Options; -----------------------. Most of the OpenCL build options from `the specification v2.0 section 5.8.4; <https://www.khronos.org/registry/cl/specs/opencl-2.0.pdf#200>`_ are available. Examples:. .. code-block:: console. $ clang -cl-std=CL2.0 -cl-single-precision-constant test.cl. Many flags used for the compilation for C sources can also be passed while; compiling for OpenCL, examples: ``-c``, ``-O<1-4|s>``, ``-o``, ``-emit-llvm``, etc. Some extra options are available to support special OpenCL features. .. option:: -cl-no-stdinc. Allows to disable all extra types and functions that are not native to the compiler.; This might reduce the compilation speed marginally but many declarations from the; OpenCL standard will not be accessible. For example, th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:142639,Availability,avail,available,142639,"onosGroup/SPIRV-LLVM-Translator>`_; to produce SPIR-V binary. More details are provided in `the offline; compilation from OpenCL kernel sources into SPIR-V using open source; tools; <https://github.com/KhronosGroup/OpenCL-Guide/blob/main/chapters/os_tooling.md>`_.; From clang 14 onwards SPIR-V can be generated directly as detailed in; :ref:`the SPIR-V support section <spir-v>`. Clang currently supports OpenCL C language standards up to v2.0. Clang mainly; supports full profile. There is only very limited support of the embedded; profile.; From clang 9 a C++ mode is available for OpenCL (see; :ref:`C++ for OpenCL <cxx_for_opencl>`). OpenCL v3.0 support is complete but it remains in experimental state, see more; details about the experimental features and limitations in :doc:`OpenCLSupport`; page. OpenCL Specific Options; -----------------------. Most of the OpenCL build options from `the specification v2.0 section 5.8.4; <https://www.khronos.org/registry/cl/specs/opencl-2.0.pdf#200>`_ are available. Examples:. .. code-block:: console. $ clang -cl-std=CL2.0 -cl-single-precision-constant test.cl. Many flags used for the compilation for C sources can also be passed while; compiling for OpenCL, examples: ``-c``, ``-O<1-4|s>``, ``-o``, ``-emit-llvm``, etc. Some extra options are available to support special OpenCL features. .. option:: -cl-no-stdinc. Allows to disable all extra types and functions that are not native to the compiler.; This might reduce the compilation speed marginally but many declarations from the; OpenCL standard will not be accessible. For example, the following will fail to; compile. .. code-block:: console. $ echo ""bool is_wg_uniform(int i){return get_enqueued_local_size(i)==get_local_size(i);}"" > test.cl; $ clang -cl-std=CL2.0 -cl-no-stdinc test.cl; error: use of undeclared identifier 'get_enqueued_local_size'; error: use of undeclared identifier 'get_local_size'. More information about the standard types and functions is provided in :ref:`the; secti",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:142930,Availability,avail,available,142930,"nerated directly as detailed in; :ref:`the SPIR-V support section <spir-v>`. Clang currently supports OpenCL C language standards up to v2.0. Clang mainly; supports full profile. There is only very limited support of the embedded; profile.; From clang 9 a C++ mode is available for OpenCL (see; :ref:`C++ for OpenCL <cxx_for_opencl>`). OpenCL v3.0 support is complete but it remains in experimental state, see more; details about the experimental features and limitations in :doc:`OpenCLSupport`; page. OpenCL Specific Options; -----------------------. Most of the OpenCL build options from `the specification v2.0 section 5.8.4; <https://www.khronos.org/registry/cl/specs/opencl-2.0.pdf#200>`_ are available. Examples:. .. code-block:: console. $ clang -cl-std=CL2.0 -cl-single-precision-constant test.cl. Many flags used for the compilation for C sources can also be passed while; compiling for OpenCL, examples: ``-c``, ``-O<1-4|s>``, ``-o``, ``-emit-llvm``, etc. Some extra options are available to support special OpenCL features. .. option:: -cl-no-stdinc. Allows to disable all extra types and functions that are not native to the compiler.; This might reduce the compilation speed marginally but many declarations from the; OpenCL standard will not be accessible. For example, the following will fail to; compile. .. code-block:: console. $ echo ""bool is_wg_uniform(int i){return get_enqueued_local_size(i)==get_local_size(i);}"" > test.cl; $ clang -cl-std=CL2.0 -cl-no-stdinc test.cl; error: use of undeclared identifier 'get_enqueued_local_size'; error: use of undeclared identifier 'get_local_size'. More information about the standard types and functions is provided in :ref:`the; section on the OpenCL Header <opencl_header>`. .. _opencl_cl_ext:. .. option:: -cl-ext. Enables/Disables support of OpenCL extensions and optional features. All OpenCL; targets set a list of extensions that they support. Clang allows to amend this using; the ``-cl-ext`` flag with a comma-separated list of ex",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:143289,Availability,echo,echo,143289,"tal state, see more; details about the experimental features and limitations in :doc:`OpenCLSupport`; page. OpenCL Specific Options; -----------------------. Most of the OpenCL build options from `the specification v2.0 section 5.8.4; <https://www.khronos.org/registry/cl/specs/opencl-2.0.pdf#200>`_ are available. Examples:. .. code-block:: console. $ clang -cl-std=CL2.0 -cl-single-precision-constant test.cl. Many flags used for the compilation for C sources can also be passed while; compiling for OpenCL, examples: ``-c``, ``-O<1-4|s>``, ``-o``, ``-emit-llvm``, etc. Some extra options are available to support special OpenCL features. .. option:: -cl-no-stdinc. Allows to disable all extra types and functions that are not native to the compiler.; This might reduce the compilation speed marginally but many declarations from the; OpenCL standard will not be accessible. For example, the following will fail to; compile. .. code-block:: console. $ echo ""bool is_wg_uniform(int i){return get_enqueued_local_size(i)==get_local_size(i);}"" > test.cl; $ clang -cl-std=CL2.0 -cl-no-stdinc test.cl; error: use of undeclared identifier 'get_enqueued_local_size'; error: use of undeclared identifier 'get_local_size'. More information about the standard types and functions is provided in :ref:`the; section on the OpenCL Header <opencl_header>`. .. _opencl_cl_ext:. .. option:: -cl-ext. Enables/Disables support of OpenCL extensions and optional features. All OpenCL; targets set a list of extensions that they support. Clang allows to amend this using; the ``-cl-ext`` flag with a comma-separated list of extensions prefixed with; ``'+'`` or ``'-'``. The syntax: ``-cl-ext=<(['-'|'+']<extension>[,])+>``, where; extensions can be either one of `the OpenCL published extensions; <https://www.khronos.org/registry/OpenCL>`_; or any vendor extension. Alternatively, ``'all'`` can be used to enable; or disable all known extensions. Example disabling double support for the 64-bit SPIR-V target:. .. code-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:143433,Availability,error,error,143433,"--. Most of the OpenCL build options from `the specification v2.0 section 5.8.4; <https://www.khronos.org/registry/cl/specs/opencl-2.0.pdf#200>`_ are available. Examples:. .. code-block:: console. $ clang -cl-std=CL2.0 -cl-single-precision-constant test.cl. Many flags used for the compilation for C sources can also be passed while; compiling for OpenCL, examples: ``-c``, ``-O<1-4|s>``, ``-o``, ``-emit-llvm``, etc. Some extra options are available to support special OpenCL features. .. option:: -cl-no-stdinc. Allows to disable all extra types and functions that are not native to the compiler.; This might reduce the compilation speed marginally but many declarations from the; OpenCL standard will not be accessible. For example, the following will fail to; compile. .. code-block:: console. $ echo ""bool is_wg_uniform(int i){return get_enqueued_local_size(i)==get_local_size(i);}"" > test.cl; $ clang -cl-std=CL2.0 -cl-no-stdinc test.cl; error: use of undeclared identifier 'get_enqueued_local_size'; error: use of undeclared identifier 'get_local_size'. More information about the standard types and functions is provided in :ref:`the; section on the OpenCL Header <opencl_header>`. .. _opencl_cl_ext:. .. option:: -cl-ext. Enables/Disables support of OpenCL extensions and optional features. All OpenCL; targets set a list of extensions that they support. Clang allows to amend this using; the ``-cl-ext`` flag with a comma-separated list of extensions prefixed with; ``'+'`` or ``'-'``. The syntax: ``-cl-ext=<(['-'|'+']<extension>[,])+>``, where; extensions can be either one of `the OpenCL published extensions; <https://www.khronos.org/registry/OpenCL>`_; or any vendor extension. Alternatively, ``'all'`` can be used to enable; or disable all known extensions. Example disabling double support for the 64-bit SPIR-V target:. .. code-block:: console. $ clang -c --target=spirv64 -cl-ext=-cl_khr_fp64 test.cl. Enabling all extensions except double support in R600 AMD GPU can be done using",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:143496,Availability,error,error,143496,"--. Most of the OpenCL build options from `the specification v2.0 section 5.8.4; <https://www.khronos.org/registry/cl/specs/opencl-2.0.pdf#200>`_ are available. Examples:. .. code-block:: console. $ clang -cl-std=CL2.0 -cl-single-precision-constant test.cl. Many flags used for the compilation for C sources can also be passed while; compiling for OpenCL, examples: ``-c``, ``-O<1-4|s>``, ``-o``, ``-emit-llvm``, etc. Some extra options are available to support special OpenCL features. .. option:: -cl-no-stdinc. Allows to disable all extra types and functions that are not native to the compiler.; This might reduce the compilation speed marginally but many declarations from the; OpenCL standard will not be accessible. For example, the following will fail to; compile. .. code-block:: console. $ echo ""bool is_wg_uniform(int i){return get_enqueued_local_size(i)==get_local_size(i);}"" > test.cl; $ clang -cl-std=CL2.0 -cl-no-stdinc test.cl; error: use of undeclared identifier 'get_enqueued_local_size'; error: use of undeclared identifier 'get_local_size'. More information about the standard types and functions is provided in :ref:`the; section on the OpenCL Header <opencl_header>`. .. _opencl_cl_ext:. .. option:: -cl-ext. Enables/Disables support of OpenCL extensions and optional features. All OpenCL; targets set a list of extensions that they support. Clang allows to amend this using; the ``-cl-ext`` flag with a comma-separated list of extensions prefixed with; ``'+'`` or ``'-'``. The syntax: ``-cl-ext=<(['-'|'+']<extension>[,])+>``, where; extensions can be either one of `the OpenCL published extensions; <https://www.khronos.org/registry/OpenCL>`_; or any vendor extension. Alternatively, ``'all'`` can be used to enable; or disable all known extensions. Example disabling double support for the 64-bit SPIR-V target:. .. code-block:: console. $ clang -c --target=spirv64 -cl-ext=-cl_khr_fp64 test.cl. Enabling all extensions except double support in R600 AMD GPU can be done using",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:145496,Availability,avail,available,145496,"=-all,+cl_khr_fp16 test.cl. Note that some generic targets e.g. SPIR/SPIR-V enable all extensions/features in; clang by default. OpenCL Targets; --------------. OpenCL targets are derived from the regular Clang target classes. The OpenCL; specific parts of the target representation provide address space mapping as; well as a set of supported extensions. Specific Targets; ^^^^^^^^^^^^^^^^. There is a set of concrete HW architectures that OpenCL can be compiled for. - For AMD target:. .. code-block:: console. $ clang --target=amdgcn-amd-amdhsa -mcpu=gfx900 test.cl. - For Nvidia architectures:. .. code-block:: console. $ clang --target=nvptx64-unknown-unknown test.cl. Generic Targets; ^^^^^^^^^^^^^^^. - A SPIR-V binary can be produced for 32 or 64 bit targets. .. code-block:: console. $ clang --target=spirv32 -c test.cl; $ clang --target=spirv64 -c test.cl. More details can be found in :ref:`the SPIR-V support section <spir-v>`. - SPIR is available as a generic target to allow portable bitcode to be produced; that can be used across GPU toolchains. The implementation follows `the SPIR; specification <https://www.khronos.org/spir>`_. There are two flavors; available for 32 and 64 bits. .. code-block:: console. $ clang --target=spir test.cl -emit-llvm -c; $ clang --target=spir64 test.cl -emit-llvm -c. Clang will generate SPIR v1.2 compatible IR for OpenCL versions up to 2.0 and; SPIR v2.0 for OpenCL v2.0 or C++ for OpenCL. - x86 is used by some implementations that are x86 compatible and currently; remains for backwards compatibility (with older implementations prior to; SPIR target support). For ""non-SPMD"" targets which cannot spawn multiple; work-items on the fly using hardware, which covers practically all non-GPU; devices such as CPUs and DSPs, additional processing is needed for the kernels; to support multiple work-item execution. For this, a 3rd party toolchain,; such as for example `POCL <http://portablecl.org/>`_, can be used. This target does not support multip",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:145717,Availability,avail,available,145717,"ts are derived from the regular Clang target classes. The OpenCL; specific parts of the target representation provide address space mapping as; well as a set of supported extensions. Specific Targets; ^^^^^^^^^^^^^^^^. There is a set of concrete HW architectures that OpenCL can be compiled for. - For AMD target:. .. code-block:: console. $ clang --target=amdgcn-amd-amdhsa -mcpu=gfx900 test.cl. - For Nvidia architectures:. .. code-block:: console. $ clang --target=nvptx64-unknown-unknown test.cl. Generic Targets; ^^^^^^^^^^^^^^^. - A SPIR-V binary can be produced for 32 or 64 bit targets. .. code-block:: console. $ clang --target=spirv32 -c test.cl; $ clang --target=spirv64 -c test.cl. More details can be found in :ref:`the SPIR-V support section <spir-v>`. - SPIR is available as a generic target to allow portable bitcode to be produced; that can be used across GPU toolchains. The implementation follows `the SPIR; specification <https://www.khronos.org/spir>`_. There are two flavors; available for 32 and 64 bits. .. code-block:: console. $ clang --target=spir test.cl -emit-llvm -c; $ clang --target=spir64 test.cl -emit-llvm -c. Clang will generate SPIR v1.2 compatible IR for OpenCL versions up to 2.0 and; SPIR v2.0 for OpenCL v2.0 or C++ for OpenCL. - x86 is used by some implementations that are x86 compatible and currently; remains for backwards compatibility (with older implementations prior to; SPIR target support). For ""non-SPMD"" targets which cannot spawn multiple; work-items on the fly using hardware, which covers practically all non-GPU; devices such as CPUs and DSPs, additional processing is needed for the kernels; to support multiple work-item execution. For this, a 3rd party toolchain,; such as for example `POCL <http://portablecl.org/>`_, can be used. This target does not support multiple memory segments and, therefore, the fake; address space map can be added using the :ref:`-ffake-address-space-map; <opencl_fake_address_space_map>` flag. All known OpenCL ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:147039,Availability,avail,available,147039,"sed by some implementations that are x86 compatible and currently; remains for backwards compatibility (with older implementations prior to; SPIR target support). For ""non-SPMD"" targets which cannot spawn multiple; work-items on the fly using hardware, which covers practically all non-GPU; devices such as CPUs and DSPs, additional processing is needed for the kernels; to support multiple work-item execution. For this, a 3rd party toolchain,; such as for example `POCL <http://portablecl.org/>`_, can be used. This target does not support multiple memory segments and, therefore, the fake; address space map can be added using the :ref:`-ffake-address-space-map; <opencl_fake_address_space_map>` flag. All known OpenCL extensions and features are set to supported in the generic targets,; however :option:`-cl-ext` flag can be used to toggle individual extensions and; features. .. _opencl_header:. OpenCL Header; -------------. By default Clang will include standard headers and therefore most of OpenCL; builtin functions and types are available during compilation. The; default declarations of non-native compiler types and functions can be disabled; by using flag :option:`-cl-no-stdinc`. The following example demonstrates that OpenCL kernel sources with various; standard builtin functions can be compiled without the need for an explicit; includes or compiler flags. .. code-block:: console. $ echo ""bool is_wg_uniform(int i){return get_enqueued_local_size(i)==get_local_size(i);}"" > test.cl; $ clang -cl-std=CL2.0 test.cl. More information about the default headers is provided in :doc:`OpenCLSupport`. OpenCL Extensions; -----------------. Most of the ``cl_khr_*`` extensions to OpenCL C from `the official OpenCL; registry <https://www.khronos.org/registry/OpenCL/>`_ are available and; configured per target depending on the support available in the specific; architecture. It is possible to alter the default extensions setting per target using; ``-cl-ext`` flag. (See :ref:`flags descr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:147402,Availability,echo,echo,147402," as for example `POCL <http://portablecl.org/>`_, can be used. This target does not support multiple memory segments and, therefore, the fake; address space map can be added using the :ref:`-ffake-address-space-map; <opencl_fake_address_space_map>` flag. All known OpenCL extensions and features are set to supported in the generic targets,; however :option:`-cl-ext` flag can be used to toggle individual extensions and; features. .. _opencl_header:. OpenCL Header; -------------. By default Clang will include standard headers and therefore most of OpenCL; builtin functions and types are available during compilation. The; default declarations of non-native compiler types and functions can be disabled; by using flag :option:`-cl-no-stdinc`. The following example demonstrates that OpenCL kernel sources with various; standard builtin functions can be compiled without the need for an explicit; includes or compiler flags. .. code-block:: console. $ echo ""bool is_wg_uniform(int i){return get_enqueued_local_size(i)==get_local_size(i);}"" > test.cl; $ clang -cl-std=CL2.0 test.cl. More information about the default headers is provided in :doc:`OpenCLSupport`. OpenCL Extensions; -----------------. Most of the ``cl_khr_*`` extensions to OpenCL C from `the official OpenCL; registry <https://www.khronos.org/registry/OpenCL/>`_ are available and; configured per target depending on the support available in the specific; architecture. It is possible to alter the default extensions setting per target using; ``-cl-ext`` flag. (See :ref:`flags description <opencl_cl_ext>` for more details). Vendor extensions can be added flexibly by declaring the list of types and; functions associated with each extensions enclosed within the following; compiler pragma directives:. .. code-block:: c. #pragma OPENCL EXTENSION the_new_extension_name : begin; // declare types and functions associated with the extension here; #pragma OPENCL EXTENSION the_new_extension_name : end. For example, parsing the follo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:147783,Availability,avail,available,147783," can be used to toggle individual extensions and; features. .. _opencl_header:. OpenCL Header; -------------. By default Clang will include standard headers and therefore most of OpenCL; builtin functions and types are available during compilation. The; default declarations of non-native compiler types and functions can be disabled; by using flag :option:`-cl-no-stdinc`. The following example demonstrates that OpenCL kernel sources with various; standard builtin functions can be compiled without the need for an explicit; includes or compiler flags. .. code-block:: console. $ echo ""bool is_wg_uniform(int i){return get_enqueued_local_size(i)==get_local_size(i);}"" > test.cl; $ clang -cl-std=CL2.0 test.cl. More information about the default headers is provided in :doc:`OpenCLSupport`. OpenCL Extensions; -----------------. Most of the ``cl_khr_*`` extensions to OpenCL C from `the official OpenCL; registry <https://www.khronos.org/registry/OpenCL/>`_ are available and; configured per target depending on the support available in the specific; architecture. It is possible to alter the default extensions setting per target using; ``-cl-ext`` flag. (See :ref:`flags description <opencl_cl_ext>` for more details). Vendor extensions can be added flexibly by declaring the list of types and; functions associated with each extensions enclosed within the following; compiler pragma directives:. .. code-block:: c. #pragma OPENCL EXTENSION the_new_extension_name : begin; // declare types and functions associated with the extension here; #pragma OPENCL EXTENSION the_new_extension_name : end. For example, parsing the following code adds ``my_t`` type and ``my_func``; function to the custom ``my_ext`` extension. .. code-block:: c. #pragma OPENCL EXTENSION my_ext : begin; typedef struct{; int a;; }my_t;; void my_func(my_t);; #pragma OPENCL EXTENSION my_ext : end. There is no conflict resolution for identifier clashes among extensions.; It is therefore recommended that the identifiers are p",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:147845,Availability,avail,available,147845," can be used to toggle individual extensions and; features. .. _opencl_header:. OpenCL Header; -------------. By default Clang will include standard headers and therefore most of OpenCL; builtin functions and types are available during compilation. The; default declarations of non-native compiler types and functions can be disabled; by using flag :option:`-cl-no-stdinc`. The following example demonstrates that OpenCL kernel sources with various; standard builtin functions can be compiled without the need for an explicit; includes or compiler flags. .. code-block:: console. $ echo ""bool is_wg_uniform(int i){return get_enqueued_local_size(i)==get_local_size(i);}"" > test.cl; $ clang -cl-std=CL2.0 test.cl. More information about the default headers is provided in :doc:`OpenCLSupport`. OpenCL Extensions; -----------------. Most of the ``cl_khr_*`` extensions to OpenCL C from `the official OpenCL; registry <https://www.khronos.org/registry/OpenCL/>`_ are available and; configured per target depending on the support available in the specific; architecture. It is possible to alter the default extensions setting per target using; ``-cl-ext`` flag. (See :ref:`flags description <opencl_cl_ext>` for more details). Vendor extensions can be added flexibly by declaring the list of types and; functions associated with each extensions enclosed within the following; compiler pragma directives:. .. code-block:: c. #pragma OPENCL EXTENSION the_new_extension_name : begin; // declare types and functions associated with the extension here; #pragma OPENCL EXTENSION the_new_extension_name : end. For example, parsing the following code adds ``my_t`` type and ``my_func``; function to the custom ``my_ext`` extension. .. code-block:: c. #pragma OPENCL EXTENSION my_ext : begin; typedef struct{; int a;; }my_t;; void my_func(my_t);; #pragma OPENCL EXTENSION my_ext : end. There is no conflict resolution for identifier clashes among extensions.; It is therefore recommended that the identifiers are p",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:152749,Availability,avail,available,152749,"ffle(). can be modified to:. .. code-block:: c. my_sub_group_shuffle();; my_sub_group_shuffle();; my_sub_group_shuffle();; my_sub_group_shuffle();. while using ``noduplicate`` would disallow this. Also ``noduplicate`` doesn't; have the same safe semantics of CFG as ``convergent`` and can cause changes in; CFG that modify semantics of the original program. ``noduplicate`` is kept for backwards compatibility only and it considered to be; deprecated for future uses. .. _cxx_for_opencl:. C++ for OpenCL; --------------. Starting from clang 9 kernel code can contain C++17 features: classes, templates,; function overloading, type deduction, etc. Please note that this is not an; implementation of `OpenCL C++; <https://www.khronos.org/registry/OpenCL/specs/2.2/pdf/OpenCL_Cxx.pdf>`_ and; there is no plan to support it in clang in any new releases in the near future. Clang currently supports C++ for OpenCL 1.0 and 2021.; For detailed information about this language refer to the C++ for OpenCL; Programming Language Documentation available; in `the latest build; <https://www.khronos.org/opencl/assets/CXX_for_OpenCL.html>`_; or in `the official release; <https://github.com/KhronosGroup/OpenCL-Docs/releases/tag/cxxforopencl-docrev2021.12>`_. To enable the C++ for OpenCL mode, pass one of following command line options when; compiling ``.clcpp`` file:. - C++ for OpenCL 1.0: ``-cl-std=clc++``, ``-cl-std=CLC++``, ``-cl-std=clc++1.0``,; ``-cl-std=CLC++1.0``, ``-std=clc++``, ``-std=CLC++``, ``-std=clc++1.0`` or; ``-std=CLC++1.0``. - C++ for OpenCL 2021: ``-cl-std=clc++2021``, ``-cl-std=CLC++2021``,; ``-std=clc++2021``, ``-std=CLC++2021``. Example of use:; .. code-block:: c++. template<class T> T add( T x, T y ); {; return x + y;; }. __kernel void test( __global float* a, __global float* b); {; auto index = get_global_id(0);; a[index] = add(b[index], b[index+1]);; }. .. code-block:: console. clang -cl-std=clc++1.0 test.clcpp; clang -cl-std=clc++ -c --target=spirv64 test.cl. By default, f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:167116,Availability,avail,available,167116,"up/SPIRV-LLVM-Translator/#build-with-spirv-tools>`_. `The versioning; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator/releases>`_ of; ``llvm-spirv`` is aligned with Clang major releases. The same applies to the; main development branch. It is therefore important to ensure the ``llvm-spirv``; version is in alignment with the Clang version. For troubleshooting purposes; ``llvm-spirv`` can be `tested in isolation; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator#test-instructions>`_. Example usage for OpenCL kernel compilation:. .. code-block:: console. $ clang --target=spirv32 -c test.cl; $ clang --target=spirv64 -c test.cl. Both invocations of Clang will result in the generation of a SPIR-V binary file; `test.o` for 32 bit and 64 bit respectively. This file can be imported; by an OpenCL driver that support SPIR-V consumption or it can be compiled; further by offline SPIR-V consumer tools. Converting to SPIR-V produced with the optimization levels other than `-O0` is; currently available as an experimental feature and it is not guaranteed to work; in all cases. Clang also supports integrated generation of SPIR-V without use of ``llvm-spirv``; tool as an experimental feature when ``-fintegrated-objemitter`` flag is passed in; the command line. .. code-block:: console. $ clang --target=spirv32 -fintegrated-objemitter -c test.cl. Note that only very basic functionality is supported at this point and therefore; it is not suitable for arbitrary use cases. This feature is only enabled when clang; build is configured with ``-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=SPIRV`` option. Linking is done using ``spirv-link`` from `the SPIRV-Tools project; <https://github.com/KhronosGroup/SPIRV-Tools#linker>`_. Similar to other external; linkers, Clang will expect ``spirv-link`` to be installed separately and to be; present in the ``PATH`` environment variable. Please refer to `the build and; installation instructions; <https://github.com/KhronosGroup/SPIRV-Tools#build>`_. .. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:170833,Availability,error,errors,170833,"the toolset can be set with the ``-T`` flag:. ::. cmake -G""Visual Studio 16 2019"" -T LLVM .. When using CMake with the Ninja generator, set the ``CMAKE_C_COMPILER`` and; ``CMAKE_CXX_COMPILER`` variables to clang-cl:. ::. cmake -GNinja -DCMAKE_C_COMPILER=""c:/Program Files (x86)/LLVM/bin/clang-cl.exe""; -DCMAKE_CXX_COMPILER=""c:/Program Files (x86)/LLVM/bin/clang-cl.exe"" .. Command-Line Options; --------------------. To be compatible with cl.exe, clang-cl supports most of the same command-line; options. Those options can start with either ``/`` or ``-``. It also supports; some of Clang's core options, such as the ``-W`` options. Options that are known to clang-cl, but not currently supported, are ignored; with a warning. For example:. ::. clang-cl.exe: warning: argument unused during compilation: '/AI'. To suppress warnings about unused arguments, use the ``-Qunused-arguments`` option. Options that are not known to clang-cl will be ignored by default. Use the; ``-Werror=unknown-argument`` option in order to treat them as errors. If these; options are spelled with a leading ``/``, they will be mistaken for a filename:. ::. clang-cl.exe: error: no such file or directory: '/foobar'. Please `file a bug <https://github.com/llvm/llvm-project/issues/new?labels=clang-cl>`_; for any valid cl.exe flags that clang-cl does not understand. Execute ``clang-cl /?`` to see a list of supported options:. ::. CL.EXE COMPATIBILITY OPTIONS:; /? Display available options; /arch:<value> Set architecture for code generation; /Brepro- Emit an object file which cannot be reproduced over time; /Brepro Emit an object file which can be reproduced over time; /clang:<arg> Pass <arg> to the clang driver; /C Don't discard comments when preprocessing; /c Compile only; /d1PP Retain macro definitions in /E mode; /d1reportAllClassLayout Dump record layout information; /diagnostics:caret Enable caret and column diagnostics (on by default); /diagnostics:classic Disable column and caret diagnostics; /diagnosti",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:170950,Availability,error,error,170950," ``CMAKE_CXX_COMPILER`` variables to clang-cl:. ::. cmake -GNinja -DCMAKE_C_COMPILER=""c:/Program Files (x86)/LLVM/bin/clang-cl.exe""; -DCMAKE_CXX_COMPILER=""c:/Program Files (x86)/LLVM/bin/clang-cl.exe"" .. Command-Line Options; --------------------. To be compatible with cl.exe, clang-cl supports most of the same command-line; options. Those options can start with either ``/`` or ``-``. It also supports; some of Clang's core options, such as the ``-W`` options. Options that are known to clang-cl, but not currently supported, are ignored; with a warning. For example:. ::. clang-cl.exe: warning: argument unused during compilation: '/AI'. To suppress warnings about unused arguments, use the ``-Qunused-arguments`` option. Options that are not known to clang-cl will be ignored by default. Use the; ``-Werror=unknown-argument`` option in order to treat them as errors. If these; options are spelled with a leading ``/``, they will be mistaken for a filename:. ::. clang-cl.exe: error: no such file or directory: '/foobar'. Please `file a bug <https://github.com/llvm/llvm-project/issues/new?labels=clang-cl>`_; for any valid cl.exe flags that clang-cl does not understand. Execute ``clang-cl /?`` to see a list of supported options:. ::. CL.EXE COMPATIBILITY OPTIONS:; /? Display available options; /arch:<value> Set architecture for code generation; /Brepro- Emit an object file which cannot be reproduced over time; /Brepro Emit an object file which can be reproduced over time; /clang:<arg> Pass <arg> to the clang driver; /C Don't discard comments when preprocessing; /c Compile only; /d1PP Retain macro definitions in /E mode; /d1reportAllClassLayout Dump record layout information; /diagnostics:caret Enable caret and column diagnostics (on by default); /diagnostics:classic Disable column and caret diagnostics; /diagnostics:column Disable caret diagnostics but keep column info; /D <macro[=value]> Define macro; /EH<value> Exception handling model; /EP Disable linemarker output and preproc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:171252,Availability,avail,available,171252,"CL.EXE COMPATIBILITY OPTIONS:; /? Display available options; /arch:<value> Set architecture for code generation; /Brepro- Emit an object file which cannot be reproduced over time; /Brepro Emit an object file which can be reproduced over time; /clang:<arg> Pass <arg> to the clang driver; /C Don't discard comments when preprocessing; /c Compile only; /d1PP Retain macro definitions in /E mode; /d1reportAllClassLayout Dump record layout information; /diagnostics:caret Enable caret and column diagnostics (on by default); /diagnostics:classic Disable column and caret diagnostics; /diagnostics:column Disable caret diagnostics but keep column info; /D <macro[=value]> Define macro; /EH<value> Exception handling model; /EP Disable linemarker output and preprocess to stdout; /execution-charset:<value>; Runtime encoding, supports only UTF-8; /E Preprocess to stdout; /FA Output assembly code file during compilation; /Fa<file or directory> Output assembly code to this file during compilation (with /FA); /Fe<file or directory> Set output executable file or directory (ends in / or \); /FI <value> Include file before parsing; /Fi<file> Set preprocess output file name (with /P); /Fo<file or directory> Set output object file, or directory (ends in / or \) (with /c); /fp:except-; /fp:except; /fp:fast; /fp:precise; /fp:strict; /Fp<filename> Set pch filename (with /Yc and /Yu); /GA Assume thread-local variables are defined in the executable; /Gd Set __cdecl as a default calling convention; /GF- Disable string pooling; /GF Enable string pooling (default); /GR- Disable emission of RTTI data; /Gregcall Set __regcall as a default calling convention; /GR Enable emission of RTTI data; /Gr Set __fastcall as a default calling convention; /GS- Disable buffer security check; /GS Enable buffer security check (default); /Gs Use stack probes (default); /Gs<value> Set stack probe size (default 4096); /guard:<value> Enable Control Flow Guard with /guard:cf,; or only the table with /guard:cf,nochecks.; E",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:173636,Availability,avail,available,173636,"Disable buffer security check; /GS Enable buffer security check (default); /Gs Use stack probes (default); /Gs<value> Set stack probe size (default 4096); /guard:<value> Enable Control Flow Guard with /guard:cf,; or only the table with /guard:cf,nochecks.; Enable EH Continuation Guard with /guard:ehcont; /Gv Set __vectorcall as a default calling convention; /Gw- Don't put each data item in its own section; /Gw Put each data item in its own section; /GX- Disable exception handling; /GX Enable exception handling; /Gy- Don't put each function in its own section (default); /Gy Put each function in its own section; /Gz Set __stdcall as a default calling convention; /help Display available options; /imsvc <dir> Add directory to system include search path, as if part of %INCLUDE%; /I <dir> Add directory to include search path; /J Make char type unsigned; /LDd Create debug DLL; /LD Create DLL; /link <options> Forward options to the linker; /MDd Use DLL debug run-time; /MD Use DLL run-time; /MTd Use static debug run-time; /MT Use static run-time; /O0 Disable optimization; /O1 Optimize for size (same as /Og /Os /Oy /Ob2 /GF /Gy); /O2 Optimize for speed (same as /Og /Oi /Ot /Oy /Ob2 /GF /Gy); /Ob0 Disable function inlining; /Ob1 Only inline functions which are (explicitly or implicitly) marked inline; /Ob2 Inline functions as deemed beneficial by the compiler; /Od Disable optimization; /Og No effect; /Oi- Disable use of builtin functions; /Oi Enable use of builtin functions; /Os Optimize for size; /Ot Optimize for speed; /Ox Deprecated (same as /Og /Oi /Ot /Oy /Ob2); use /O2 instead; /Oy- Disable frame pointer omission (x86 only, default); /Oy Enable frame pointer omission (x86 only); /O<flags> Set multiple /O flags at once; e.g. '/O2y-' for '/O2 /Oy-'; /o <file or directory> Set output file or directory (ends in / or \); /P Preprocess to file; /Qvec- Disable the loop vectorization passes; /Qvec Enable the loop vectorization passes; /showFilenames- Don't print the name of each ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:176123,Availability,error,errors,176123,"ng, supports only UTF-8; /std:<value> Language standard to compile for; /TC Treat all source files as C; /Tc <filename> Specify a C source file; /TP Treat all source files as C++; /Tp <filename> Specify a C++ source file; /utf-8 Set source and runtime encoding to UTF-8 (default); /U <macro> Undefine macro; /vd<value> Control vtordisp placement; /vmb Use a best-case representation method for member pointers; /vmg Use a most-general representation for member pointers; /vmm Set the default most-general representation to multiple inheritance; /vms Set the default most-general representation to single inheritance; /vmv Set the default most-general representation to virtual inheritance; /volatile:iso Volatile loads and stores have standard semantics; /volatile:ms Volatile loads and stores have acquire and release semantics; /W0 Disable all warnings; /W1 Enable -Wall; /W2 Enable -Wall; /W3 Enable -Wall; /W4 Enable -Wall and -Wextra; /Wall Enable -Weverything; /WX- Do not treat warnings as errors; /WX Treat warnings as errors; /w Disable all warnings; /X Don't add %INCLUDE% to the include search path; /Y- Disable precompiled headers, overrides /Yc and /Yu; /Yc<filename> Generate a pch file for all code up to and including <filename>; /Yu<filename> Load a pch file and use it instead of all code up to and including <filename>; /Z7 Enable CodeView debug information in object files; /Zc:char8_t Enable C++20 char8_t type; /Zc:char8_t- Disable C++20 char8_t type; /Zc:dllexportInlines- Don't dllexport/dllimport inline member functions of dllexport/import classes; /Zc:dllexportInlines dllexport/dllimport inline member functions of dllexport/import classes (default); /Zc:sizedDealloc- Disable C++14 sized global deallocation functions; /Zc:sizedDealloc Enable C++14 sized global deallocation functions; /Zc:strictStrings Treat string literals as const; /Zc:threadSafeInit- Disable thread-safe initialization of static variables; /Zc:threadSafeInit Enable thread-safe initialization of stat",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:176153,Availability,error,errors,176153,"<value> Language standard to compile for; /TC Treat all source files as C; /Tc <filename> Specify a C source file; /TP Treat all source files as C++; /Tp <filename> Specify a C++ source file; /utf-8 Set source and runtime encoding to UTF-8 (default); /U <macro> Undefine macro; /vd<value> Control vtordisp placement; /vmb Use a best-case representation method for member pointers; /vmg Use a most-general representation for member pointers; /vmm Set the default most-general representation to multiple inheritance; /vms Set the default most-general representation to single inheritance; /vmv Set the default most-general representation to virtual inheritance; /volatile:iso Volatile loads and stores have standard semantics; /volatile:ms Volatile loads and stores have acquire and release semantics; /W0 Disable all warnings; /W1 Enable -Wall; /W2 Enable -Wall; /W3 Enable -Wall; /W4 Enable -Wall and -Wextra; /Wall Enable -Weverything; /WX- Do not treat warnings as errors; /WX Treat warnings as errors; /w Disable all warnings; /X Don't add %INCLUDE% to the include search path; /Y- Disable precompiled headers, overrides /Yc and /Yu; /Yc<filename> Generate a pch file for all code up to and including <filename>; /Yu<filename> Load a pch file and use it instead of all code up to and including <filename>; /Z7 Enable CodeView debug information in object files; /Zc:char8_t Enable C++20 char8_t type; /Zc:char8_t- Disable C++20 char8_t type; /Zc:dllexportInlines- Don't dllexport/dllimport inline member functions of dllexport/import classes; /Zc:dllexportInlines dllexport/dllimport inline member functions of dllexport/import classes (default); /Zc:sizedDealloc- Disable C++14 sized global deallocation functions; /Zc:sizedDealloc Enable C++14 sized global deallocation functions; /Zc:strictStrings Treat string literals as const; /Zc:threadSafeInit- Disable thread-safe initialization of static variables; /Zc:threadSafeInit Enable thread-safe initialization of static variables; /Zc:trigraphs- D",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:180705,Availability,recover,recover,180705,icant under the Microsoft ABI; -fno-coverage-mapping Disable code coverage analysis; -fno-crash-diagnostics Disable auto-generation of preprocessed source files and a script for reproduction during a clang crash; -fno-debug-macro Do not emit macro debug information; -fno-delayed-template-parsing; Disable delayed template parsing; -fno-sanitize-address-poison-custom-array-cookie; Disable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fno-sanitize-address-use-after-scope; Disable use-after-scope detection in AddressSanitizer; -fno-sanitize-address-use-odr-indicator; Disable ODR indicator globals; -fno-sanitize-ignorelist Don't use ignorelist file for sanitizers; -fno-sanitize-cfi-cross-dso; Disable control flow integrity (CFI) checks for cross-DSO calls.; -fno-sanitize-coverage=<value>; Disable specified features of coverage instrumentation for Sanitizers; -fno-sanitize-memory-track-origins; Disable origins tracking in MemorySanitizer; -fno-sanitize-memory-use-after-dtor; Disable use-after-destroy detection in MemorySanitizer; -fno-sanitize-recover=<value>; Disable recovery for specified sanitizers; -fno-sanitize-stats Disable sanitizer statistics gathering.; -fno-sanitize-thread-atomics; Disable atomic operations instrumentation in ThreadSanitizer; -fno-sanitize-thread-func-entry-exit; Disable function entry/exit instrumentation in ThreadSanitizer; -fno-sanitize-thread-memory-access; Disable memory access instrumentation in ThreadSanitizer; -fno-sanitize-trap=<value>; Disable trapping for specified sanitizers; -fno-standalone-debug Limit debug information produced to reduce size of debug binary; -fno-strict-aliasing Disable optimizations based on strict aliasing rules (default); -fobjc-runtime=<value> Specify the target Objective-C runtime kind and version; -fprofile-exclude-files=<value>; Instrument only functions from files where names don't match all the regexes separated by a semi-colon; -fprofile-filter-files=<value>; Instrument o,MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:180730,Availability,recover,recovery,180730,icant under the Microsoft ABI; -fno-coverage-mapping Disable code coverage analysis; -fno-crash-diagnostics Disable auto-generation of preprocessed source files and a script for reproduction during a clang crash; -fno-debug-macro Do not emit macro debug information; -fno-delayed-template-parsing; Disable delayed template parsing; -fno-sanitize-address-poison-custom-array-cookie; Disable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fno-sanitize-address-use-after-scope; Disable use-after-scope detection in AddressSanitizer; -fno-sanitize-address-use-odr-indicator; Disable ODR indicator globals; -fno-sanitize-ignorelist Don't use ignorelist file for sanitizers; -fno-sanitize-cfi-cross-dso; Disable control flow integrity (CFI) checks for cross-DSO calls.; -fno-sanitize-coverage=<value>; Disable specified features of coverage instrumentation for Sanitizers; -fno-sanitize-memory-track-origins; Disable origins tracking in MemorySanitizer; -fno-sanitize-memory-use-after-dtor; Disable use-after-destroy detection in MemorySanitizer; -fno-sanitize-recover=<value>; Disable recovery for specified sanitizers; -fno-sanitize-stats Disable sanitizer statistics gathering.; -fno-sanitize-thread-atomics; Disable atomic operations instrumentation in ThreadSanitizer; -fno-sanitize-thread-func-entry-exit; Disable function entry/exit instrumentation in ThreadSanitizer; -fno-sanitize-thread-memory-access; Disable memory access instrumentation in ThreadSanitizer; -fno-sanitize-trap=<value>; Disable trapping for specified sanitizers; -fno-standalone-debug Limit debug information produced to reduce size of debug binary; -fno-strict-aliasing Disable optimizations based on strict aliasing rules (default); -fobjc-runtime=<value> Specify the target Objective-C runtime kind and version; -fprofile-exclude-files=<value>; Instrument only functions from files where names don't match all the regexes separated by a semi-colon; -fprofile-filter-files=<value>; Instrument o,MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:184381,Availability,recover,recover,184381,"array cookies when using custom operator new[] in AddressSanitizer; -fsanitize-address-use-after-return=<mode>; Select the mode of detecting stack use-after-return in AddressSanitizer: never | runtime (default) | always; -fsanitize-address-use-after-scope; Enable use-after-scope detection in AddressSanitizer; -fsanitize-address-use-odr-indicator; Enable ODR indicator globals to avoid false ODR violation reports in partially sanitized programs at the cost of an increase in binary size; -fsanitize-ignorelist=<value>; Path to ignorelist file for sanitizers; -fsanitize-cfi-cross-dso; Enable control flow integrity (CFI) checks for cross-DSO calls.; -fsanitize-cfi-icall-generalize-pointers; Generalize pointers in CFI indirect call type signature checks; -fsanitize-coverage=<value>; Specify the type of coverage instrumentation for Sanitizers; -fsanitize-hwaddress-abi=<value>; Select the HWAddressSanitizer ABI to target (interceptor or platform, default interceptor); -fsanitize-memory-track-origins=<value>; Enable origins tracking in MemorySanitizer; -fsanitize-memory-track-origins; Enable origins tracking in MemorySanitizer; -fsanitize-memory-use-after-dtor; Enable use-after-destroy detection in MemorySanitizer; -fsanitize-recover=<value>; Enable recovery for specified sanitizers; -fsanitize-stats Enable sanitizer statistics gathering.; -fsanitize-thread-atomics; Enable atomic operations instrumentation in ThreadSanitizer (default); -fsanitize-thread-func-entry-exit; Enable function entry/exit instrumentation in ThreadSanitizer (default); -fsanitize-thread-memory-access; Enable memory access instrumentation in ThreadSanitizer (default); -fsanitize-trap=<value> Enable trapping for specified sanitizers; -fsanitize-undefined-strip-path-components=<number>; Strip (or keep only, if negative) a given number of path components when emitting check metadata.; -fsanitize=<check> Turn on runtime checks for various forms of undefined or suspicious; behavior. See user manual for availa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:184405,Availability,recover,recovery,184405,"array cookies when using custom operator new[] in AddressSanitizer; -fsanitize-address-use-after-return=<mode>; Select the mode of detecting stack use-after-return in AddressSanitizer: never | runtime (default) | always; -fsanitize-address-use-after-scope; Enable use-after-scope detection in AddressSanitizer; -fsanitize-address-use-odr-indicator; Enable ODR indicator globals to avoid false ODR violation reports in partially sanitized programs at the cost of an increase in binary size; -fsanitize-ignorelist=<value>; Path to ignorelist file for sanitizers; -fsanitize-cfi-cross-dso; Enable control flow integrity (CFI) checks for cross-DSO calls.; -fsanitize-cfi-icall-generalize-pointers; Generalize pointers in CFI indirect call type signature checks; -fsanitize-coverage=<value>; Specify the type of coverage instrumentation for Sanitizers; -fsanitize-hwaddress-abi=<value>; Select the HWAddressSanitizer ABI to target (interceptor or platform, default interceptor); -fsanitize-memory-track-origins=<value>; Enable origins tracking in MemorySanitizer; -fsanitize-memory-track-origins; Enable origins tracking in MemorySanitizer; -fsanitize-memory-use-after-dtor; Enable use-after-destroy detection in MemorySanitizer; -fsanitize-recover=<value>; Enable recovery for specified sanitizers; -fsanitize-stats Enable sanitizer statistics gathering.; -fsanitize-thread-atomics; Enable atomic operations instrumentation in ThreadSanitizer (default); -fsanitize-thread-func-entry-exit; Enable function entry/exit instrumentation in ThreadSanitizer (default); -fsanitize-thread-memory-access; Enable memory access instrumentation in ThreadSanitizer (default); -fsanitize-trap=<value> Enable trapping for specified sanitizers; -fsanitize-undefined-strip-path-components=<number>; Strip (or keep only, if negative) a given number of path components when emitting check metadata.; -fsanitize=<check> Turn on runtime checks for various forms of undefined or suspicious; behavior. See user manual for availa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:185139,Availability,avail,available,185139,"ble origins tracking in MemorySanitizer; -fsanitize-memory-track-origins; Enable origins tracking in MemorySanitizer; -fsanitize-memory-use-after-dtor; Enable use-after-destroy detection in MemorySanitizer; -fsanitize-recover=<value>; Enable recovery for specified sanitizers; -fsanitize-stats Enable sanitizer statistics gathering.; -fsanitize-thread-atomics; Enable atomic operations instrumentation in ThreadSanitizer (default); -fsanitize-thread-func-entry-exit; Enable function entry/exit instrumentation in ThreadSanitizer (default); -fsanitize-thread-memory-access; Enable memory access instrumentation in ThreadSanitizer (default); -fsanitize-trap=<value> Enable trapping for specified sanitizers; -fsanitize-undefined-strip-path-components=<number>; Strip (or keep only, if negative) a given number of path components when emitting check metadata.; -fsanitize=<check> Turn on runtime checks for various forms of undefined or suspicious; behavior. See user manual for available checks; -fsplit-lto-unit Enables splitting of the LTO unit.; -fstandalone-debug Emit full debug info for all types used by the program; -fstrict-aliasing	 Enable optimizations based on strict aliasing rules; -fsyntax-only Run the preprocessor, parser and semantic analysis stages; -fwhole-program-vtables Enables whole-program vtable optimization. Requires -flto; -gcodeview-ghash Emit type record hashes in a .debug$H section; -gcodeview Generate CodeView debug information; -gline-directives-only Emit debug line info directives only; -gline-tables-only Emit debug line number tables only; -miamcu Use Intel MCU ABI; -mllvm <value> Additional arguments to forward to LLVM's option processing; -nobuiltininc Disable builtin #include directories; -Qunused-arguments Don't emit warning for unused driver arguments; -R<remark> Enable the specified remark; --target=<value> Generate code for the given target; --version Print version information; -v Show commands to run and use verbose output; -W<warning> Enable the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:188905,Availability,avail,available,188905," that definition directly instead of importing it from the DLL. Note that the Microsoft Visual C++ compiler does not support this option, and; if code in a DLL is compiled with ``/Zc:dllexportInlines-``, the code using the; DLL must be compiled in the same way so that it doesn't attempt to dllimport; the inline member functions. The reverse scenario should generally work though:; a DLL compiled without this flag (such as a system library compiled with Visual; C++) can be referenced from code compiled using the flag, meaning that the; referencing code will use the inline definitions instead of importing them from; the DLL. Also note that like when using ``-fvisibility-inlines-hidden``, the address of; `S::foo()` will be different inside and outside the DLL, breaking the C/C++; standard requirement that functions have a unique address. The flag does not apply to explicit class template instantiation definitions or; declarations, as those are typically used to explicitly provide a single; definition in a DLL, (dllexported instantiation definition) or to signal that; the definition is available elsewhere (dllimport instantiation declaration). It; also doesn't apply to inline members with static local variables, to ensure; that the same instance of the variable is used inside and outside the DLL. Using this flag can cause problems when inline functions that would otherwise; be dllexported refer to internal symbols of a DLL. For example:. .. code-block:: c. void internal();. struct __declspec(dllimport) S {; void foo() { internal(); }; }. Normally, references to `S::foo()` would use the definition in the DLL from; which it was exported, and which presumably also has the definition of; `internal()`. However, when using ``/Zc:dllexportInlines-``, the inline; definition of `S::foo()` is used directly, resulting in a link error since; `internal()` is not available. Even worse, if there is an inline definition of; `internal()` containing a static local variable, we will now ref",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:189651,Availability,error,error,189651,"ent that functions have a unique address. The flag does not apply to explicit class template instantiation definitions or; declarations, as those are typically used to explicitly provide a single; definition in a DLL, (dllexported instantiation definition) or to signal that; the definition is available elsewhere (dllimport instantiation declaration). It; also doesn't apply to inline members with static local variables, to ensure; that the same instance of the variable is used inside and outside the DLL. Using this flag can cause problems when inline functions that would otherwise; be dllexported refer to internal symbols of a DLL. For example:. .. code-block:: c. void internal();. struct __declspec(dllimport) S {; void foo() { internal(); }; }. Normally, references to `S::foo()` would use the definition in the DLL from; which it was exported, and which presumably also has the definition of; `internal()`. However, when using ``/Zc:dllexportInlines-``, the inline; definition of `S::foo()` is used directly, resulting in a link error since; `internal()` is not available. Even worse, if there is an inline definition of; `internal()` containing a static local variable, we will now refer to a; different instance of that variable than in the DLL:. .. code-block:: c. inline int internal() { static int x; return x++; }. struct __declspec(dllimport) S {; int foo() { return internal(); }; }. This could lead to very subtle bugs. Using ``-fvisibility-inlines-hidden`` can; lead to the same issue. To avoid it in this case, make `S::foo()` or; `internal()` non-inline, or mark them `dllimport/dllexport` explicitly. Finding Clang runtime libraries; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. clang-cl supports several features that require runtime library support:. - Address Sanitizer (ASan): ``-fsanitize=address``; - Undefined Behavior Sanitizer (UBSan): ``-fsanitize=undefined``; - Code coverage: ``-fprofile-instr-generate -fcoverage-mapping``; - Profile Guided Optimization (PGO): ``-fprofile-ge",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:189684,Availability,avail,available,189684,"ent that functions have a unique address. The flag does not apply to explicit class template instantiation definitions or; declarations, as those are typically used to explicitly provide a single; definition in a DLL, (dllexported instantiation definition) or to signal that; the definition is available elsewhere (dllimport instantiation declaration). It; also doesn't apply to inline members with static local variables, to ensure; that the same instance of the variable is used inside and outside the DLL. Using this flag can cause problems when inline functions that would otherwise; be dllexported refer to internal symbols of a DLL. For example:. .. code-block:: c. void internal();. struct __declspec(dllimport) S {; void foo() { internal(); }; }. Normally, references to `S::foo()` would use the definition in the DLL from; which it was exported, and which presumably also has the definition of; `internal()`. However, when using ``/Zc:dllexportInlines-``, the inline; definition of `S::foo()` is used directly, resulting in a link error since; `internal()` is not available. Even worse, if there is an inline definition of; `internal()` containing a static local variable, we will now refer to a; different instance of that variable than in the DLL:. .. code-block:: c. inline int internal() { static int x; return x++; }. struct __declspec(dllimport) S {; int foo() { return internal(); }; }. This could lead to very subtle bugs. Using ``-fvisibility-inlines-hidden`` can; lead to the same issue. To avoid it in this case, make `S::foo()` or; `internal()` non-inline, or mark them `dllimport/dllexport` explicitly. Finding Clang runtime libraries; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. clang-cl supports several features that require runtime library support:. - Address Sanitizer (ASan): ``-fsanitize=address``; - Undefined Behavior Sanitizer (UBSan): ``-fsanitize=undefined``; - Code coverage: ``-fprofile-instr-generate -fcoverage-mapping``; - Profile Guided Optimization (PGO): ``-fprofile-ge",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:191756,Availability,error,error,191756,"user must link the right runtime libraries; into their program. These libraries are distributed alongside Clang in the; library resource directory. Clang searches for the resource directory by; searching relative to the Clang executable. For example, if LLVM is installed; in ``C:\Program Files\LLVM``, then the profile runtime library will be located; at the path; ``C:\Program Files\LLVM\lib\clang\11.0.0\lib\windows\clang_rt.profile-x86_64.lib``. For UBSan, PGO, and coverage, Clang will emit object files that auto-link the; appropriate runtime library, but the user generally needs to help the linker; (whether it is ``lld-link.exe`` or MSVC ``link.exe``) find the library resource; directory. Using the example installation above, this would mean passing; ``/LIBPATH:C:\Program Files\LLVM\lib\clang\11.0.0\lib\windows`` to the linker.; If the user links the program with the ``clang`` or ``clang-cl`` drivers, the; driver will pass this flag for them. If the linker cannot find the appropriate library, it will emit an error like; this::. $ clang-cl -c -fsanitize=undefined t.cpp. $ lld-link t.obj -dll; lld-link: error: could not open 'clang_rt.ubsan_standalone-x86_64.lib': no such file or directory; lld-link: error: could not open 'clang_rt.ubsan_standalone_cxx-x86_64.lib': no such file or directory. $ link t.obj -dll -nologo; LINK : fatal error LNK1104: cannot open file 'clang_rt.ubsan_standalone-x86_64.lib'. To fix the error, add the appropriate ``/libpath:`` flag to the link line. For ASan, as of this writing, the user is also responsible for linking against; the correct ASan libraries. If the user is using the dynamic CRT (``/MD``), then they should add; ``clang_rt.asan_dynamic-x86_64.lib`` to the link line as a regular input. For; other architectures, replace x86_64 with the appropriate name here and below. If the user is using the static CRT (``/MT``), then different runtimes are used; to produce DLLs and EXEs. To link a DLL, pass; ``clang_rt.asan_dll_thunk-x86_64.lib``.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:191851,Availability,error,error,191851,"y resource directory. Clang searches for the resource directory by; searching relative to the Clang executable. For example, if LLVM is installed; in ``C:\Program Files\LLVM``, then the profile runtime library will be located; at the path; ``C:\Program Files\LLVM\lib\clang\11.0.0\lib\windows\clang_rt.profile-x86_64.lib``. For UBSan, PGO, and coverage, Clang will emit object files that auto-link the; appropriate runtime library, but the user generally needs to help the linker; (whether it is ``lld-link.exe`` or MSVC ``link.exe``) find the library resource; directory. Using the example installation above, this would mean passing; ``/LIBPATH:C:\Program Files\LLVM\lib\clang\11.0.0\lib\windows`` to the linker.; If the user links the program with the ``clang`` or ``clang-cl`` drivers, the; driver will pass this flag for them. If the linker cannot find the appropriate library, it will emit an error like; this::. $ clang-cl -c -fsanitize=undefined t.cpp. $ lld-link t.obj -dll; lld-link: error: could not open 'clang_rt.ubsan_standalone-x86_64.lib': no such file or directory; lld-link: error: could not open 'clang_rt.ubsan_standalone_cxx-x86_64.lib': no such file or directory. $ link t.obj -dll -nologo; LINK : fatal error LNK1104: cannot open file 'clang_rt.ubsan_standalone-x86_64.lib'. To fix the error, add the appropriate ``/libpath:`` flag to the link line. For ASan, as of this writing, the user is also responsible for linking against; the correct ASan libraries. If the user is using the dynamic CRT (``/MD``), then they should add; ``clang_rt.asan_dynamic-x86_64.lib`` to the link line as a regular input. For; other architectures, replace x86_64 with the appropriate name here and below. If the user is using the static CRT (``/MT``), then different runtimes are used; to produce DLLs and EXEs. To link a DLL, pass; ``clang_rt.asan_dll_thunk-x86_64.lib``. To link an EXE, pass; ``-wholearchive:clang_rt.asan-x86_64.lib``. Windows System Headers and Library Lookup; ^^^^^^^^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:191950,Availability,error,error,191950,"to the Clang executable. For example, if LLVM is installed; in ``C:\Program Files\LLVM``, then the profile runtime library will be located; at the path; ``C:\Program Files\LLVM\lib\clang\11.0.0\lib\windows\clang_rt.profile-x86_64.lib``. For UBSan, PGO, and coverage, Clang will emit object files that auto-link the; appropriate runtime library, but the user generally needs to help the linker; (whether it is ``lld-link.exe`` or MSVC ``link.exe``) find the library resource; directory. Using the example installation above, this would mean passing; ``/LIBPATH:C:\Program Files\LLVM\lib\clang\11.0.0\lib\windows`` to the linker.; If the user links the program with the ``clang`` or ``clang-cl`` drivers, the; driver will pass this flag for them. If the linker cannot find the appropriate library, it will emit an error like; this::. $ clang-cl -c -fsanitize=undefined t.cpp. $ lld-link t.obj -dll; lld-link: error: could not open 'clang_rt.ubsan_standalone-x86_64.lib': no such file or directory; lld-link: error: could not open 'clang_rt.ubsan_standalone_cxx-x86_64.lib': no such file or directory. $ link t.obj -dll -nologo; LINK : fatal error LNK1104: cannot open file 'clang_rt.ubsan_standalone-x86_64.lib'. To fix the error, add the appropriate ``/libpath:`` flag to the link line. For ASan, as of this writing, the user is also responsible for linking against; the correct ASan libraries. If the user is using the dynamic CRT (``/MD``), then they should add; ``clang_rt.asan_dynamic-x86_64.lib`` to the link line as a regular input. For; other architectures, replace x86_64 with the appropriate name here and below. If the user is using the static CRT (``/MT``), then different runtimes are used; to produce DLLs and EXEs. To link a DLL, pass; ``clang_rt.asan_dll_thunk-x86_64.lib``. To link an EXE, pass; ``-wholearchive:clang_rt.asan-x86_64.lib``. Windows System Headers and Library Lookup; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. clang-cl uses a set of different approaches to locate the ri",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:192083,Availability,error,error,192083,"he path; ``C:\Program Files\LLVM\lib\clang\11.0.0\lib\windows\clang_rt.profile-x86_64.lib``. For UBSan, PGO, and coverage, Clang will emit object files that auto-link the; appropriate runtime library, but the user generally needs to help the linker; (whether it is ``lld-link.exe`` or MSVC ``link.exe``) find the library resource; directory. Using the example installation above, this would mean passing; ``/LIBPATH:C:\Program Files\LLVM\lib\clang\11.0.0\lib\windows`` to the linker.; If the user links the program with the ``clang`` or ``clang-cl`` drivers, the; driver will pass this flag for them. If the linker cannot find the appropriate library, it will emit an error like; this::. $ clang-cl -c -fsanitize=undefined t.cpp. $ lld-link t.obj -dll; lld-link: error: could not open 'clang_rt.ubsan_standalone-x86_64.lib': no such file or directory; lld-link: error: could not open 'clang_rt.ubsan_standalone_cxx-x86_64.lib': no such file or directory. $ link t.obj -dll -nologo; LINK : fatal error LNK1104: cannot open file 'clang_rt.ubsan_standalone-x86_64.lib'. To fix the error, add the appropriate ``/libpath:`` flag to the link line. For ASan, as of this writing, the user is also responsible for linking against; the correct ASan libraries. If the user is using the dynamic CRT (``/MD``), then they should add; ``clang_rt.asan_dynamic-x86_64.lib`` to the link line as a regular input. For; other architectures, replace x86_64 with the appropriate name here and below. If the user is using the static CRT (``/MT``), then different runtimes are used; to produce DLLs and EXEs. To link a DLL, pass; ``clang_rt.asan_dll_thunk-x86_64.lib``. To link an EXE, pass; ``-wholearchive:clang_rt.asan-x86_64.lib``. Windows System Headers and Library Lookup; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. clang-cl uses a set of different approaches to locate the right system libraries; to link against when building code. The Windows environment uses libraries from; three distinct sources:. 1. Windows SDK; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:192166,Availability,error,error,192166," PGO, and coverage, Clang will emit object files that auto-link the; appropriate runtime library, but the user generally needs to help the linker; (whether it is ``lld-link.exe`` or MSVC ``link.exe``) find the library resource; directory. Using the example installation above, this would mean passing; ``/LIBPATH:C:\Program Files\LLVM\lib\clang\11.0.0\lib\windows`` to the linker.; If the user links the program with the ``clang`` or ``clang-cl`` drivers, the; driver will pass this flag for them. If the linker cannot find the appropriate library, it will emit an error like; this::. $ clang-cl -c -fsanitize=undefined t.cpp. $ lld-link t.obj -dll; lld-link: error: could not open 'clang_rt.ubsan_standalone-x86_64.lib': no such file or directory; lld-link: error: could not open 'clang_rt.ubsan_standalone_cxx-x86_64.lib': no such file or directory. $ link t.obj -dll -nologo; LINK : fatal error LNK1104: cannot open file 'clang_rt.ubsan_standalone-x86_64.lib'. To fix the error, add the appropriate ``/libpath:`` flag to the link line. For ASan, as of this writing, the user is also responsible for linking against; the correct ASan libraries. If the user is using the dynamic CRT (``/MD``), then they should add; ``clang_rt.asan_dynamic-x86_64.lib`` to the link line as a regular input. For; other architectures, replace x86_64 with the appropriate name here and below. If the user is using the static CRT (``/MT``), then different runtimes are used; to produce DLLs and EXEs. To link a DLL, pass; ``clang_rt.asan_dll_thunk-x86_64.lib``. To link an EXE, pass; ``-wholearchive:clang_rt.asan-x86_64.lib``. Windows System Headers and Library Lookup; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. clang-cl uses a set of different approaches to locate the right system libraries; to link against when building code. The Windows environment uses libraries from; three distinct sources:. 1. Windows SDK; 2. UCRT (Universal C Runtime); 3. Visual C++ Tools (VCRuntime). The Windows SDK provides the import lib",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:21866,Deployability,release,releases,21866,"porary. This option enables warnings about binding a; reference to a temporary when the temporary doesn't have a usable; copy constructor. For example:. ::. struct NonCopyable {; NonCopyable();; private:; NonCopyable(const NonCopyable&);; };; void foo(const NonCopyable&);; void bar() {; foo(NonCopyable()); // Disallowed in C++98; allowed in C++11.; }. ::. struct NonCopyable2 {; NonCopyable2();; NonCopyable2(NonCopyable2&);; };; void foo(const NonCopyable2&);; void bar() {; foo(NonCopyable2()); // Disallowed in C++98; allowed in C++11.; }. Note that if ``NonCopyable2::NonCopyable2()`` has a default argument; whose instantiation produces a compile error, that error will still; be a hard error in C++98 mode even if this warning is turned off. Options to Control Clang Crash Diagnostics; ------------------------------------------. As unbelievable as it may sound, Clang does crash from time to time.; Generally, this only occurs to those living on the `bleeding; edge <https://llvm.org/releases/download.html#svn>`_. Clang goes to great; lengths to assist you in filing a bug report. Specifically, Clang; generates preprocessed source file(s) and associated run script(s) upon; a crash. These files should be attached to a bug report to ease; reproducibility of the failure. Below are the command line options to; control the crash diagnostics. .. option:: -fcrash-diagnostics=<val>. Valid values are:. * ``off`` (Disable auto-generation of preprocessed source files during a clang crash.); * ``compiler`` (Generate diagnostics for compiler crashes (default)); * ``all`` (Generate diagnostics for all tools which support it). .. option:: -fno-crash-diagnostics. Disable auto-generation of preprocessed source files during a clang crash. The -fno-crash-diagnostics flag can be helpful for speeding the process; of generating a delta reduced test case. .. option:: -fcrash-diagnostics-dir=<dir>. Specify where to write the crash diagnostics files; defaults to the; usual location for temporary f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:30663,Deployability,configurat,configuration,30663," backslash to ""escape""; a special character, which is the convention used by GNU Make. The -MV; option tells Clang to put double-quotes around the entire filename, which; is the convention used by NMake and Jom. .. option:: -femit-dwarf-unwind=<value>. When to emit DWARF unwind (EH frame) info. This is a Mach-O-specific option. Valid values are:. * ``no-compact-unwind`` - Only emit DWARF unwind when compact unwind encodings; aren't available. This is the default for arm64.; * ``always`` - Always emit DWARF unwind regardless.; * ``default`` - Use the platform-specific default (``always`` for all; non-arm64-platforms). ``no-compact-unwind`` is a performance optimization -- Clang will emit smaller; object files that are more quickly processed by the linker. This may cause; binary compatibility issues on older x86_64 targets, however, so use it with; caution. .. _configuration-files:. Configuration files; -------------------. Configuration files group command-line options and allow all of them to be; specified just by referencing the configuration file. They may be used, for; example, to collect options required to tune compilation for particular; target, such as ``-L``, ``-I``, ``-l``, ``--sysroot``, codegen options, etc. Configuration files can be either specified on the command line or loaded; from default locations. If both variants are present, the default configuration; files are loaded first. The command line option ``--config=`` can be used to specify explicit; configuration files in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:30997,Deployability,configurat,configuration,30997,"ly emit DWARF unwind when compact unwind encodings; aren't available. This is the default for arm64.; * ``always`` - Always emit DWARF unwind regardless.; * ``default`` - Use the platform-specific default (``always`` for all; non-arm64-platforms). ``no-compact-unwind`` is a performance optimization -- Clang will emit smaller; object files that are more quickly processed by the linker. This may cause; binary compatibility issues on older x86_64 targets, however, so use it with; caution. .. _configuration-files:. Configuration files; -------------------. Configuration files group command-line options and allow all of them to be; specified just by referencing the configuration file. They may be used, for; example, to collect options required to tune compilation for particular; target, such as ``-L``, ``-I``, ``-l``, ``--sysroot``, codegen options, etc. Configuration files can be either specified on the command line or loaded; from default locations. If both variants are present, the default configuration; files are loaded first. The command line option ``--config=`` can be used to specify explicit; configuration files in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - the directory where Clang executable resides. Both user and system directories for configuration files are specified during; clang build using CMake parameters, ``CLANG_CONFIG_FILE_USER_DIR`` and; ``CLANG_CONFIG_FILE_SYSTEM_DIR`` respectively. The first file found is used.; It is an error if the required file cannot be found. The default configuration files are searched for in ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:31107,Deployability,configurat,configuration,31107,"4.; * ``always`` - Always emit DWARF unwind regardless.; * ``default`` - Use the platform-specific default (``always`` for all; non-arm64-platforms). ``no-compact-unwind`` is a performance optimization -- Clang will emit smaller; object files that are more quickly processed by the linker. This may cause; binary compatibility issues on older x86_64 targets, however, so use it with; caution. .. _configuration-files:. Configuration files; -------------------. Configuration files group command-line options and allow all of them to be; specified just by referencing the configuration file. They may be used, for; example, to collect options required to tune compilation for particular; target, such as ``-L``, ``-I``, ``-l``, ``--sysroot``, codegen options, etc. Configuration files can be either specified on the command line or loaded; from default locations. If both variants are present, the default configuration; files are loaded first. The command line option ``--config=`` can be used to specify explicit; configuration files in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - the directory where Clang executable resides. Both user and system directories for configuration files are specified during; clang build using CMake parameters, ``CLANG_CONFIG_FILE_USER_DIR`` and; ``CLANG_CONFIG_FILE_SYSTEM_DIR`` respectively. The first file found is used.; It is an error if the required file cannot be found. The default configuration files are searched for in the same directories; following the rules described in the next paragraphs. Loading default; conf",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:31698,Deployability,configurat,configuration,31698,"ion for particular; target, such as ``-L``, ``-I``, ``-l``, ``--sysroot``, codegen options, etc. Configuration files can be either specified on the command line or loaded; from default locations. If both variants are present, the default configuration; files are loaded first. The command line option ``--config=`` can be used to specify explicit; configuration files in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - the directory where Clang executable resides. Both user and system directories for configuration files are specified during; clang build using CMake parameters, ``CLANG_CONFIG_FILE_USER_DIR`` and; ``CLANG_CONFIG_FILE_SYSTEM_DIR`` respectively. The first file found is used.; It is an error if the required file cannot be found. The default configuration files are searched for in the same directories; following the rules described in the next paragraphs. Loading default; configuration files can be disabled entirely via passing; the ``--no-default-config`` flag. First, the algorithm searches for a configuration file named; ``<triple>-<driver>.cfg`` where `triple` is the triple for the target being; built for, and `driver` is the name of the currently used driver. The algorithm; first attempts to use the canonical name for the driver used, then falls back; to the one found in the executable name. The following canonical driver names are used:. - ``clang`` for the ``gcc`` driver (used to compile C programs); - ``clang++`` for the ``gxx`` driver (used to compile C++ programs); - ``clang-cpp`` for the ``cpp`` driver (pure preprocessor",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:31955,Deployability,configurat,configuration,31955,"tion; files are loaded first. The command line option ``--config=`` can be used to specify explicit; configuration files in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - the directory where Clang executable resides. Both user and system directories for configuration files are specified during; clang build using CMake parameters, ``CLANG_CONFIG_FILE_USER_DIR`` and; ``CLANG_CONFIG_FILE_SYSTEM_DIR`` respectively. The first file found is used.; It is an error if the required file cannot be found. The default configuration files are searched for in the same directories; following the rules described in the next paragraphs. Loading default; configuration files can be disabled entirely via passing; the ``--no-default-config`` flag. First, the algorithm searches for a configuration file named; ``<triple>-<driver>.cfg`` where `triple` is the triple for the target being; built for, and `driver` is the name of the currently used driver. The algorithm; first attempts to use the canonical name for the driver used, then falls back; to the one found in the executable name. The following canonical driver names are used:. - ``clang`` for the ``gcc`` driver (used to compile C programs); - ``clang++`` for the ``gxx`` driver (used to compile C++ programs); - ``clang-cpp`` for the ``cpp`` driver (pure preprocessor); - ``clang-cl`` for the ``cl`` driver; - ``flang`` for the ``flang`` driver; - ``clang-dxc`` for the ``dxc`` driver. For example, when calling ``x86_64-pc-linux-gnu-clang-g++``,; the driver will first attempt to use the configuration file named:",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:32088,Deployability,configurat,configuration,32088,"es in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - the directory where Clang executable resides. Both user and system directories for configuration files are specified during; clang build using CMake parameters, ``CLANG_CONFIG_FILE_USER_DIR`` and; ``CLANG_CONFIG_FILE_SYSTEM_DIR`` respectively. The first file found is used.; It is an error if the required file cannot be found. The default configuration files are searched for in the same directories; following the rules described in the next paragraphs. Loading default; configuration files can be disabled entirely via passing; the ``--no-default-config`` flag. First, the algorithm searches for a configuration file named; ``<triple>-<driver>.cfg`` where `triple` is the triple for the target being; built for, and `driver` is the name of the currently used driver. The algorithm; first attempts to use the canonical name for the driver used, then falls back; to the one found in the executable name. The following canonical driver names are used:. - ``clang`` for the ``gcc`` driver (used to compile C programs); - ``clang++`` for the ``gxx`` driver (used to compile C++ programs); - ``clang-cpp`` for the ``cpp`` driver (pure preprocessor); - ``clang-cl`` for the ``cl`` driver; - ``flang`` for the ``flang`` driver; - ``clang-dxc`` for the ``dxc`` driver. For example, when calling ``x86_64-pc-linux-gnu-clang-g++``,; the driver will first attempt to use the configuration file named::. x86_64-pc-linux-gnu-clang++.cfg. If this file is not found, it will attempt to use the name found; in the executable",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:32216,Deployability,configurat,configuration,32216," in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - the directory where Clang executable resides. Both user and system directories for configuration files are specified during; clang build using CMake parameters, ``CLANG_CONFIG_FILE_USER_DIR`` and; ``CLANG_CONFIG_FILE_SYSTEM_DIR`` respectively. The first file found is used.; It is an error if the required file cannot be found. The default configuration files are searched for in the same directories; following the rules described in the next paragraphs. Loading default; configuration files can be disabled entirely via passing; the ``--no-default-config`` flag. First, the algorithm searches for a configuration file named; ``<triple>-<driver>.cfg`` where `triple` is the triple for the target being; built for, and `driver` is the name of the currently used driver. The algorithm; first attempts to use the canonical name for the driver used, then falls back; to the one found in the executable name. The following canonical driver names are used:. - ``clang`` for the ``gcc`` driver (used to compile C programs); - ``clang++`` for the ``gxx`` driver (used to compile C++ programs); - ``clang-cpp`` for the ``cpp`` driver (pure preprocessor); - ``clang-cl`` for the ``cl`` driver; - ``flang`` for the ``flang`` driver; - ``clang-dxc`` for the ``dxc`` driver. For example, when calling ``x86_64-pc-linux-gnu-clang-g++``,; the driver will first attempt to use the configuration file named::. x86_64-pc-linux-gnu-clang++.cfg. If this file is not found, it will attempt to use the name found; in the executable instead::. x86_64-pc-linux-gnu-clang-g++.cfg. Note that options such as ``--driver-mode=``, ``-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:32981,Deployability,configurat,configuration,32981," The default configuration files are searched for in the same directories; following the rules described in the next paragraphs. Loading default; configuration files can be disabled entirely via passing; the ``--no-default-config`` flag. First, the algorithm searches for a configuration file named; ``<triple>-<driver>.cfg`` where `triple` is the triple for the target being; built for, and `driver` is the name of the currently used driver. The algorithm; first attempts to use the canonical name for the driver used, then falls back; to the one found in the executable name. The following canonical driver names are used:. - ``clang`` for the ``gcc`` driver (used to compile C programs); - ``clang++`` for the ``gxx`` driver (used to compile C++ programs); - ``clang-cpp`` for the ``cpp`` driver (pure preprocessor); - ``clang-cl`` for the ``cl`` driver; - ``flang`` for the ``flang`` driver; - ``clang-dxc`` for the ``dxc`` driver. For example, when calling ``x86_64-pc-linux-gnu-clang-g++``,; the driver will first attempt to use the configuration file named::. x86_64-pc-linux-gnu-clang++.cfg. If this file is not found, it will attempt to use the name found; in the executable instead::. x86_64-pc-linux-gnu-clang-g++.cfg. Note that options such as ``--driver-mode=``, ``--target=``, ``-m32`` affect; the search algorithm. For example, the aforementioned executable called with; ``-m32`` argument will instead search for::. i386-pc-linux-gnu-clang++.cfg. If none of the aforementioned files are found, the driver will instead search; for separate driver and target configuration files and attempt to load both.; The former is named ``<driver>.cfg`` while the latter is named; ``<triple>.cfg``. Similarly to the previous variants, the canonical driver name; will be preferred, and the compiler will fall back to the actual name. For example, ``x86_64-pc-linux-gnu-clang-g++`` will attempt to load two; configuration files named respectively::. clang++.cfg; x86_64-pc-linux-gnu.cfg. with fallback",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:33514,Deployability,configurat,configuration,33514," the one found in the executable name. The following canonical driver names are used:. - ``clang`` for the ``gcc`` driver (used to compile C programs); - ``clang++`` for the ``gxx`` driver (used to compile C++ programs); - ``clang-cpp`` for the ``cpp`` driver (pure preprocessor); - ``clang-cl`` for the ``cl`` driver; - ``flang`` for the ``flang`` driver; - ``clang-dxc`` for the ``dxc`` driver. For example, when calling ``x86_64-pc-linux-gnu-clang-g++``,; the driver will first attempt to use the configuration file named::. x86_64-pc-linux-gnu-clang++.cfg. If this file is not found, it will attempt to use the name found; in the executable instead::. x86_64-pc-linux-gnu-clang-g++.cfg. Note that options such as ``--driver-mode=``, ``--target=``, ``-m32`` affect; the search algorithm. For example, the aforementioned executable called with; ``-m32`` argument will instead search for::. i386-pc-linux-gnu-clang++.cfg. If none of the aforementioned files are found, the driver will instead search; for separate driver and target configuration files and attempt to load both.; The former is named ``<driver>.cfg`` while the latter is named; ``<triple>.cfg``. Similarly to the previous variants, the canonical driver name; will be preferred, and the compiler will fall back to the actual name. For example, ``x86_64-pc-linux-gnu-clang-g++`` will attempt to load two; configuration files named respectively::. clang++.cfg; x86_64-pc-linux-gnu.cfg. with fallback to trying::. clang-g++.cfg; x86_64-pc-linux-gnu.cfg. It is not an error if either of these files is not found. The configuration file consists of command-line options specified on one or; more lines. Lines composed of whitespace characters only are ignored as well as; lines in which the first non-blank character is ``#``. Long options may be split; between several lines by a trailing backslash. Here is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:33850,Deployability,configurat,configuration,33850,"ver; - ``clang-dxc`` for the ``dxc`` driver. For example, when calling ``x86_64-pc-linux-gnu-clang-g++``,; the driver will first attempt to use the configuration file named::. x86_64-pc-linux-gnu-clang++.cfg. If this file is not found, it will attempt to use the name found; in the executable instead::. x86_64-pc-linux-gnu-clang-g++.cfg. Note that options such as ``--driver-mode=``, ``--target=``, ``-m32`` affect; the search algorithm. For example, the aforementioned executable called with; ``-m32`` argument will instead search for::. i386-pc-linux-gnu-clang++.cfg. If none of the aforementioned files are found, the driver will instead search; for separate driver and target configuration files and attempt to load both.; The former is named ``<driver>.cfg`` while the latter is named; ``<triple>.cfg``. Similarly to the previous variants, the canonical driver name; will be preferred, and the compiler will fall back to the actual name. For example, ``x86_64-pc-linux-gnu-clang-g++`` will attempt to load two; configuration files named respectively::. clang++.cfg; x86_64-pc-linux-gnu.cfg. with fallback to trying::. clang-g++.cfg; x86_64-pc-linux-gnu.cfg. It is not an error if either of these files is not found. The configuration file consists of command-line options specified on one or; more lines. Lines composed of whitespace characters only are ignored as well as; lines in which the first non-blank character is ``#``. Long options may be split; between several lines by a trailing backslash. Here is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between lines; -I/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the fil",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:34059,Deployability,configurat,configuration,34059,"me found; in the executable instead::. x86_64-pc-linux-gnu-clang-g++.cfg. Note that options such as ``--driver-mode=``, ``--target=``, ``-m32`` affect; the search algorithm. For example, the aforementioned executable called with; ``-m32`` argument will instead search for::. i386-pc-linux-gnu-clang++.cfg. If none of the aforementioned files are found, the driver will instead search; for separate driver and target configuration files and attempt to load both.; The former is named ``<driver>.cfg`` while the latter is named; ``<triple>.cfg``. Similarly to the previous variants, the canonical driver name; will be preferred, and the compiler will fall back to the actual name. For example, ``x86_64-pc-linux-gnu-clang-g++`` will attempt to load two; configuration files named respectively::. clang++.cfg; x86_64-pc-linux-gnu.cfg. with fallback to trying::. clang-g++.cfg; x86_64-pc-linux-gnu.cfg. It is not an error if either of these files is not found. The configuration file consists of command-line options specified on one or; more lines. Lines composed of whitespace characters only are ignored as well as; lines in which the first non-blank character is ``#``. Long options may be split; between several lines by a trailing backslash. Here is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between lines; -I/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:34364,Deployability,configurat,configuration,34364,"rch for::. i386-pc-linux-gnu-clang++.cfg. If none of the aforementioned files are found, the driver will instead search; for separate driver and target configuration files and attempt to load both.; The former is named ``<driver>.cfg`` while the latter is named; ``<triple>.cfg``. Similarly to the previous variants, the canonical driver name; will be preferred, and the compiler will fall back to the actual name. For example, ``x86_64-pc-linux-gnu-clang-g++`` will attempt to load two; configuration files named respectively::. clang++.cfg; x86_64-pc-linux-gnu.cfg. with fallback to trying::. clang-g++.cfg; x86_64-pc-linux-gnu.cfg. It is not an error if either of these files is not found. The configuration file consists of command-line options specified on one or; more lines. Lines composed of whitespace characters only are ignored as well as; lines in which the first non-blank character is ``#``. Long options may be split; between several lines by a trailing backslash. Here is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between lines; -I/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate paths relative to the configuration file, the ``<CFGDIR>`` token may; be used. This will expand to the absolute path of the directory containing the; configuration file. In cases where a configuration file is deployed alongside SDK contents, the; SDK directory ca",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:34657,Deployability,configurat,configuration,34657," variants, the canonical driver name; will be preferred, and the compiler will fall back to the actual name. For example, ``x86_64-pc-linux-gnu-clang-g++`` will attempt to load two; configuration files named respectively::. clang++.cfg; x86_64-pc-linux-gnu.cfg. with fallback to trying::. clang-g++.cfg; x86_64-pc-linux-gnu.cfg. It is not an error if either of these files is not found. The configuration file consists of command-line options specified on one or; more lines. Lines composed of whitespace characters only are ignored as well as; lines in which the first non-blank character is ``#``. Long options may be split; between several lines by a trailing backslash. Here is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between lines; -I/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate paths relative to the configuration file, the ``<CFGDIR>`` token may; be used. This will expand to the absolute path of the directory containing the; configuration file. In cases where a configuration file is deployed alongside SDK contents, the; SDK directory can remain fully portable by using ``<CFGDIR>`` prefixed paths.; In this way, the user may only need to specify a root configuration file with; ``--config=`` to establish every aspect of the SDK with the compiler:. ::. --target=foo; -isystem <CFGDIR>/include; -L <CFGDIR>/lib; -T <CFGDIR>/ldscripts/link.ld.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:34741,Deployability,configurat,configuration,34741,"ll fall back to the actual name. For example, ``x86_64-pc-linux-gnu-clang-g++`` will attempt to load two; configuration files named respectively::. clang++.cfg; x86_64-pc-linux-gnu.cfg. with fallback to trying::. clang-g++.cfg; x86_64-pc-linux-gnu.cfg. It is not an error if either of these files is not found. The configuration file consists of command-line options specified on one or; more lines. Lines composed of whitespace characters only are ignored as well as; lines in which the first non-blank character is ``#``. Long options may be split; between several lines by a trailing backslash. Here is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between lines; -I/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate paths relative to the configuration file, the ``<CFGDIR>`` token may; be used. This will expand to the absolute path of the directory containing the; configuration file. In cases where a configuration file is deployed alongside SDK contents, the; SDK directory can remain fully portable by using ``<CFGDIR>`` prefixed paths.; In this way, the user may only need to specify a root configuration file with; ``--config=`` to establish every aspect of the SDK with the compiler:. ::. --target=foo; -isystem <CFGDIR>/include; -L <CFGDIR>/lib; -T <CFGDIR>/ldscripts/link.ld. Language and Target-Independent Features; =================================",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:35066,Deployability,configurat,configuration,35066,"les is not found. The configuration file consists of command-line options specified on one or; more lines. Lines composed of whitespace characters only are ignored as well as; lines in which the first non-blank character is ``#``. Long options may be split; between several lines by a trailing backslash. Here is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between lines; -I/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate paths relative to the configuration file, the ``<CFGDIR>`` token may; be used. This will expand to the absolute path of the directory containing the; configuration file. In cases where a configuration file is deployed alongside SDK contents, the; SDK directory can remain fully portable by using ``<CFGDIR>`` prefixed paths.; In this way, the user may only need to specify a root configuration file with; ``--config=`` to establish every aspect of the SDK with the compiler:. ::. --target=foo; -isystem <CFGDIR>/include; -L <CFGDIR>/lib; -T <CFGDIR>/ldscripts/link.ld. Language and Target-Independent Features; ========================================. Controlling Errors and Warnings; -------------------------------. Clang provides a number of ways to control which code constructs cause; it to emit errors and warning messages, and how they are displayed to; the console. Controlling How Clang Displays Diagnostics; ^^^^^^^^^^^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:35122,Deployability,configurat,configuration,35122,"more lines. Lines composed of whitespace characters only are ignored as well as; lines in which the first non-blank character is ``#``. Long options may be split; between several lines by a trailing backslash. Here is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between lines; -I/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate paths relative to the configuration file, the ``<CFGDIR>`` token may; be used. This will expand to the absolute path of the directory containing the; configuration file. In cases where a configuration file is deployed alongside SDK contents, the; SDK directory can remain fully portable by using ``<CFGDIR>`` prefixed paths.; In this way, the user may only need to specify a root configuration file with; ``--config=`` to establish every aspect of the SDK with the compiler:. ::. --target=foo; -isystem <CFGDIR>/include; -L <CFGDIR>/lib; -T <CFGDIR>/ldscripts/link.ld. Language and Target-Independent Features; ========================================. Controlling Errors and Warnings; -------------------------------. Clang provides a number of ways to control which code constructs cause; it to emit errors and warning messages, and how they are displayed to; the console. Controlling How Clang Displays Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When Clang emits a diagnostic, it includes rich information in the; ou",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:35250,Deployability,configurat,configuration,35250,"hich the first non-blank character is ``#``. Long options may be split; between several lines by a trailing backslash. Here is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between lines; -I/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate paths relative to the configuration file, the ``<CFGDIR>`` token may; be used. This will expand to the absolute path of the directory containing the; configuration file. In cases where a configuration file is deployed alongside SDK contents, the; SDK directory can remain fully portable by using ``<CFGDIR>`` prefixed paths.; In this way, the user may only need to specify a root configuration file with; ``--config=`` to establish every aspect of the SDK with the compiler:. ::. --target=foo; -isystem <CFGDIR>/include; -L <CFGDIR>/lib; -T <CFGDIR>/ldscripts/link.ld. Language and Target-Independent Features; ========================================. Controlling Errors and Warnings; -------------------------------. Clang provides a number of ways to control which code constructs cause; it to emit errors and warning messages, and how they are displayed to; the console. Controlling How Clang Displays Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When Clang emits a diagnostic, it includes rich information in the; output, and gives you fine-grain control over which information is; printed. Clang has the ab",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:35287,Deployability,configurat,configuration,35287," is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between lines; -I/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate paths relative to the configuration file, the ``<CFGDIR>`` token may; be used. This will expand to the absolute path of the directory containing the; configuration file. In cases where a configuration file is deployed alongside SDK contents, the; SDK directory can remain fully portable by using ``<CFGDIR>`` prefixed paths.; In this way, the user may only need to specify a root configuration file with; ``--config=`` to establish every aspect of the SDK with the compiler:. ::. --target=foo; -isystem <CFGDIR>/include; -L <CFGDIR>/lib; -T <CFGDIR>/ldscripts/link.ld. Language and Target-Independent Features; ========================================. Controlling Errors and Warnings; -------------------------------. Clang provides a number of ways to control which code constructs cause; it to emit errors and warning messages, and how they are displayed to; the console. Controlling How Clang Displays Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When Clang emits a diagnostic, it includes rich information in the; output, and gives you fine-grain control over which information is; printed. Clang has the ability to print this information, and these are; the options that control it:. #. A file/line/column indicator that shows ex",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:35309,Deployability,deploy,deployed,35309," is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between lines; -I/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate paths relative to the configuration file, the ``<CFGDIR>`` token may; be used. This will expand to the absolute path of the directory containing the; configuration file. In cases where a configuration file is deployed alongside SDK contents, the; SDK directory can remain fully portable by using ``<CFGDIR>`` prefixed paths.; In this way, the user may only need to specify a root configuration file with; ``--config=`` to establish every aspect of the SDK with the compiler:. ::. --target=foo; -isystem <CFGDIR>/include; -L <CFGDIR>/lib; -T <CFGDIR>/ldscripts/link.ld. Language and Target-Independent Features; ========================================. Controlling Errors and Warnings; -------------------------------. Clang provides a number of ways to control which code constructs cause; it to emit errors and warning messages, and how they are displayed to; the console. Controlling How Clang Displays Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When Clang emits a diagnostic, it includes rich information in the; output, and gives you fine-grain control over which information is; printed. Clang has the ability to print this information, and these are; the options that control it:. #. A file/line/column indicator that shows ex",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:35480,Deployability,configurat,configuration,35480,"/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate paths relative to the configuration file, the ``<CFGDIR>`` token may; be used. This will expand to the absolute path of the directory containing the; configuration file. In cases where a configuration file is deployed alongside SDK contents, the; SDK directory can remain fully portable by using ``<CFGDIR>`` prefixed paths.; In this way, the user may only need to specify a root configuration file with; ``--config=`` to establish every aspect of the SDK with the compiler:. ::. --target=foo; -isystem <CFGDIR>/include; -L <CFGDIR>/lib; -T <CFGDIR>/ldscripts/link.ld. Language and Target-Independent Features; ========================================. Controlling Errors and Warnings; -------------------------------. Clang provides a number of ways to control which code constructs cause; it to emit errors and warning messages, and how they are displayed to; the console. Controlling How Clang Displays Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When Clang emits a diagnostic, it includes rich information in the; output, and gives you fine-grain control over which information is; printed. Clang has the ability to print this information, and these are; the options that control it:. #. A file/line/column indicator that shows exactly where the diagnostic; occurs in your code [:ref:`-fshow-column <opt_fshow-column>`,; :ref:`-fshow-source-location <opt_fshow-source-location>`].; #",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:47976,Deployability,install,installed,47976," A PCH file can then be used as a prefix header when a ``-include-pch``; option is passed to ``clang``:. .. code-block:: console. $ clang -include-pch test.h.pch test.c -o test. The ``clang`` driver will check if the PCH file ``test.h.pch`` is; available; if so, the contents of ``test.h`` (and the files it includes); will be processed from the PCH file. Otherwise, Clang will report an error. .. note::. Clang does *not* automatically use PCH files for headers that are directly; included within a source file or indirectly via :option:`-include`.; For example:. .. code-block:: console. $ clang -x c-header test.h -o test.h.pch; $ cat test.c; #include ""test.h""; $ clang test.c -o test. In this example, ``clang`` will not automatically use the PCH file for; ``test.h`` since ``test.h`` was included directly in the source file and not; specified on the command line using ``-include-pch``. Relocatable PCH Files; ^^^^^^^^^^^^^^^^^^^^^. It is sometimes necessary to build a precompiled header from headers; that are not yet in their final, installed locations. For example, one; might build a precompiled header within the build tree that is then; meant to be installed alongside the headers. Clang permits the creation; of ""relocatable"" precompiled headers, which are built with a given path; (into the build directory) and can later be used from an installed; location. To build a relocatable precompiled header, place your headers into a; subdirectory whose structure mimics the installed location. For example,; if you want to build a precompiled header for the header ``mylib.h``; that will be installed into ``/usr/include``, create a subdirectory; ``build/usr/include`` and place the header ``mylib.h`` into that; subdirectory. If ``mylib.h`` depends on other headers, then they can be; stored within ``build/usr/include`` in a way that mimics the installed; location. Building a relocatable precompiled header requires two additional; arguments. First, pass the ``--relocatable-pch`` flag t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:48096,Deployability,install,installed,48096,". $ clang -include-pch test.h.pch test.c -o test. The ``clang`` driver will check if the PCH file ``test.h.pch`` is; available; if so, the contents of ``test.h`` (and the files it includes); will be processed from the PCH file. Otherwise, Clang will report an error. .. note::. Clang does *not* automatically use PCH files for headers that are directly; included within a source file or indirectly via :option:`-include`.; For example:. .. code-block:: console. $ clang -x c-header test.h -o test.h.pch; $ cat test.c; #include ""test.h""; $ clang test.c -o test. In this example, ``clang`` will not automatically use the PCH file for; ``test.h`` since ``test.h`` was included directly in the source file and not; specified on the command line using ``-include-pch``. Relocatable PCH Files; ^^^^^^^^^^^^^^^^^^^^^. It is sometimes necessary to build a precompiled header from headers; that are not yet in their final, installed locations. For example, one; might build a precompiled header within the build tree that is then; meant to be installed alongside the headers. Clang permits the creation; of ""relocatable"" precompiled headers, which are built with a given path; (into the build directory) and can later be used from an installed; location. To build a relocatable precompiled header, place your headers into a; subdirectory whose structure mimics the installed location. For example,; if you want to build a precompiled header for the header ``mylib.h``; that will be installed into ``/usr/include``, create a subdirectory; ``build/usr/include`` and place the header ``mylib.h`` into that; subdirectory. If ``mylib.h`` depends on other headers, then they can be; stored within ``build/usr/include`` in a way that mimics the installed; location. Building a relocatable precompiled header requires two additional; arguments. First, pass the ``--relocatable-pch`` flag to indicate that; the resulting PCH file should be relocatable. Second, pass; ``-isysroot /path/to/build``, which makes all inclu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:48287,Deployability,install,installed,48287,"st.h`` (and the files it includes); will be processed from the PCH file. Otherwise, Clang will report an error. .. note::. Clang does *not* automatically use PCH files for headers that are directly; included within a source file or indirectly via :option:`-include`.; For example:. .. code-block:: console. $ clang -x c-header test.h -o test.h.pch; $ cat test.c; #include ""test.h""; $ clang test.c -o test. In this example, ``clang`` will not automatically use the PCH file for; ``test.h`` since ``test.h`` was included directly in the source file and not; specified on the command line using ``-include-pch``. Relocatable PCH Files; ^^^^^^^^^^^^^^^^^^^^^. It is sometimes necessary to build a precompiled header from headers; that are not yet in their final, installed locations. For example, one; might build a precompiled header within the build tree that is then; meant to be installed alongside the headers. Clang permits the creation; of ""relocatable"" precompiled headers, which are built with a given path; (into the build directory) and can later be used from an installed; location. To build a relocatable precompiled header, place your headers into a; subdirectory whose structure mimics the installed location. For example,; if you want to build a precompiled header for the header ``mylib.h``; that will be installed into ``/usr/include``, create a subdirectory; ``build/usr/include`` and place the header ``mylib.h`` into that; subdirectory. If ``mylib.h`` depends on other headers, then they can be; stored within ``build/usr/include`` in a way that mimics the installed; location. Building a relocatable precompiled header requires two additional; arguments. First, pass the ``--relocatable-pch`` flag to indicate that; the resulting PCH file should be relocatable. Second, pass; ``-isysroot /path/to/build``, which makes all includes for your library; relative to the build directory. For example:. .. code-block:: console. # clang -x c-header --relocatable-pch -isysroot /path/to/build",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:48418,Deployability,install,installed,48418,"se PCH files for headers that are directly; included within a source file or indirectly via :option:`-include`.; For example:. .. code-block:: console. $ clang -x c-header test.h -o test.h.pch; $ cat test.c; #include ""test.h""; $ clang test.c -o test. In this example, ``clang`` will not automatically use the PCH file for; ``test.h`` since ``test.h`` was included directly in the source file and not; specified on the command line using ``-include-pch``. Relocatable PCH Files; ^^^^^^^^^^^^^^^^^^^^^. It is sometimes necessary to build a precompiled header from headers; that are not yet in their final, installed locations. For example, one; might build a precompiled header within the build tree that is then; meant to be installed alongside the headers. Clang permits the creation; of ""relocatable"" precompiled headers, which are built with a given path; (into the build directory) and can later be used from an installed; location. To build a relocatable precompiled header, place your headers into a; subdirectory whose structure mimics the installed location. For example,; if you want to build a precompiled header for the header ``mylib.h``; that will be installed into ``/usr/include``, create a subdirectory; ``build/usr/include`` and place the header ``mylib.h`` into that; subdirectory. If ``mylib.h`` depends on other headers, then they can be; stored within ``build/usr/include`` in a way that mimics the installed; location. Building a relocatable precompiled header requires two additional; arguments. First, pass the ``--relocatable-pch`` flag to indicate that; the resulting PCH file should be relocatable. Second, pass; ``-isysroot /path/to/build``, which makes all includes for your library; relative to the build directory. For example:. .. code-block:: console. # clang -x c-header --relocatable-pch -isysroot /path/to/build /path/to/build/mylib.h mylib.h.pch. When loading the relocatable PCH file, the various headers used in the; PCH file are found from the system header roo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:48535,Deployability,install,installed,48535," #include ""test.h""; $ clang test.c -o test. In this example, ``clang`` will not automatically use the PCH file for; ``test.h`` since ``test.h`` was included directly in the source file and not; specified on the command line using ``-include-pch``. Relocatable PCH Files; ^^^^^^^^^^^^^^^^^^^^^. It is sometimes necessary to build a precompiled header from headers; that are not yet in their final, installed locations. For example, one; might build a precompiled header within the build tree that is then; meant to be installed alongside the headers. Clang permits the creation; of ""relocatable"" precompiled headers, which are built with a given path; (into the build directory) and can later be used from an installed; location. To build a relocatable precompiled header, place your headers into a; subdirectory whose structure mimics the installed location. For example,; if you want to build a precompiled header for the header ``mylib.h``; that will be installed into ``/usr/include``, create a subdirectory; ``build/usr/include`` and place the header ``mylib.h`` into that; subdirectory. If ``mylib.h`` depends on other headers, then they can be; stored within ``build/usr/include`` in a way that mimics the installed; location. Building a relocatable precompiled header requires two additional; arguments. First, pass the ``--relocatable-pch`` flag to indicate that; the resulting PCH file should be relocatable. Second, pass; ``-isysroot /path/to/build``, which makes all includes for your library; relative to the build directory. For example:. .. code-block:: console. # clang -x c-header --relocatable-pch -isysroot /path/to/build /path/to/build/mylib.h mylib.h.pch. When loading the relocatable PCH file, the various headers used in the; PCH file are found from the system header root. For example, ``mylib.h``; can be found in ``/usr/include/mylib.h``. If the headers are installed; in some other system root, the ``-isysroot`` option can be used provide; a different system root from which",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:48791,Deployability,install,installed,48791,"n the source file and not; specified on the command line using ``-include-pch``. Relocatable PCH Files; ^^^^^^^^^^^^^^^^^^^^^. It is sometimes necessary to build a precompiled header from headers; that are not yet in their final, installed locations. For example, one; might build a precompiled header within the build tree that is then; meant to be installed alongside the headers. Clang permits the creation; of ""relocatable"" precompiled headers, which are built with a given path; (into the build directory) and can later be used from an installed; location. To build a relocatable precompiled header, place your headers into a; subdirectory whose structure mimics the installed location. For example,; if you want to build a precompiled header for the header ``mylib.h``; that will be installed into ``/usr/include``, create a subdirectory; ``build/usr/include`` and place the header ``mylib.h`` into that; subdirectory. If ``mylib.h`` depends on other headers, then they can be; stored within ``build/usr/include`` in a way that mimics the installed; location. Building a relocatable precompiled header requires two additional; arguments. First, pass the ``--relocatable-pch`` flag to indicate that; the resulting PCH file should be relocatable. Second, pass; ``-isysroot /path/to/build``, which makes all includes for your library; relative to the build directory. For example:. .. code-block:: console. # clang -x c-header --relocatable-pch -isysroot /path/to/build /path/to/build/mylib.h mylib.h.pch. When loading the relocatable PCH file, the various headers used in the; PCH file are found from the system header root. For example, ``mylib.h``; can be found in ``/usr/include/mylib.h``. If the headers are installed; in some other system root, the ``-isysroot`` option can be used provide; a different system root from which the headers will be based. For; example, ``-isysroot /Developer/SDKs/MacOSX10.4u.sdk`` will look for; ``mylib.h`` in ``/Developer/SDKs/MacOSX10.4u.sdk/usr/include/myl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:49462,Deployability,install,installed,49462,"at will be installed into ``/usr/include``, create a subdirectory; ``build/usr/include`` and place the header ``mylib.h`` into that; subdirectory. If ``mylib.h`` depends on other headers, then they can be; stored within ``build/usr/include`` in a way that mimics the installed; location. Building a relocatable precompiled header requires two additional; arguments. First, pass the ``--relocatable-pch`` flag to indicate that; the resulting PCH file should be relocatable. Second, pass; ``-isysroot /path/to/build``, which makes all includes for your library; relative to the build directory. For example:. .. code-block:: console. # clang -x c-header --relocatable-pch -isysroot /path/to/build /path/to/build/mylib.h mylib.h.pch. When loading the relocatable PCH file, the various headers used in the; PCH file are found from the system header root. For example, ``mylib.h``; can be found in ``/usr/include/mylib.h``. If the headers are installed; in some other system root, the ``-isysroot`` option can be used provide; a different system root from which the headers will be based. For; example, ``-isysroot /Developer/SDKs/MacOSX10.4u.sdk`` will look for; ``mylib.h`` in ``/Developer/SDKs/MacOSX10.4u.sdk/usr/include/mylib.h``. Relocatable precompiled headers are intended to be used in a limited; number of cases where the compilation environment is tightly controlled; and the precompiled header cannot be generated after headers have been; installed. .. _controlling-fp-behavior:. Controlling Floating Point Behavior; -----------------------------------. Clang provides a number of ways to control floating point behavior, including; with command line options and source pragmas. This section; describes the various floating point semantic modes and the corresponding options. .. csv-table:: Floating Point Semantic Modes; :header: ""Mode"", ""Values""; :widths: 15, 30, 30. ""ffp-exception-behavior"", ""{ignore, strict, maytrap}"",; ""fenv_access"", ""{off, on}"", ""(none)""; ""frounding-math"", ""{dynamic, t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:49970,Deployability,install,installed,49970,"additional; arguments. First, pass the ``--relocatable-pch`` flag to indicate that; the resulting PCH file should be relocatable. Second, pass; ``-isysroot /path/to/build``, which makes all includes for your library; relative to the build directory. For example:. .. code-block:: console. # clang -x c-header --relocatable-pch -isysroot /path/to/build /path/to/build/mylib.h mylib.h.pch. When loading the relocatable PCH file, the various headers used in the; PCH file are found from the system header root. For example, ``mylib.h``; can be found in ``/usr/include/mylib.h``. If the headers are installed; in some other system root, the ``-isysroot`` option can be used provide; a different system root from which the headers will be based. For; example, ``-isysroot /Developer/SDKs/MacOSX10.4u.sdk`` will look for; ``mylib.h`` in ``/Developer/SDKs/MacOSX10.4u.sdk/usr/include/mylib.h``. Relocatable precompiled headers are intended to be used in a limited; number of cases where the compilation environment is tightly controlled; and the precompiled header cannot be generated after headers have been; installed. .. _controlling-fp-behavior:. Controlling Floating Point Behavior; -----------------------------------. Clang provides a number of ways to control floating point behavior, including; with command line options and source pragmas. This section; describes the various floating point semantic modes and the corresponding options. .. csv-table:: Floating Point Semantic Modes; :header: ""Mode"", ""Values""; :widths: 15, 30, 30. ""ffp-exception-behavior"", ""{ignore, strict, maytrap}"",; ""fenv_access"", ""{off, on}"", ""(none)""; ""frounding-math"", ""{dynamic, tonearest, downward, upward, towardzero}""; ""ffp-contract"", ""{on, off, fast, fast-honor-pragmas}""; ""fdenormal-fp-math"", ""{IEEE, PreserveSign, PositiveZero}""; ""fdenormal-fp-math-fp32"", ""{IEEE, PreserveSign, PositiveZero}""; ""fmath-errno"", ""{on, off}""; ""fhonor-nans"", ""{on, off}""; ""fhonor-infinities"", ""{on, off}""; ""fsigned-zeros"", ""{on, off}""; ""f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:67301,Deployability,release,releases,67301,"ion:. The C and C++ standards allow floating-point expressions to be computed as if; intermediate results had more precision (and/or a wider range) than the type; of the expression strictly allows. This is called excess precision; arithmetic.; Excess precision arithmetic can improve the accuracy of results (although not; always), and it can make computation significantly faster if the target lacks; direct hardware support for arithmetic in a particular type. However, it can; also undermine strict floating-point reproducibility. Under the standards, assignments and explicit casts force the operand to be; converted to its formal type, discarding any excess precision. Because data; can only flow between statements via an assignment, this means that the use; of excess precision arithmetic is a reliable local property of a single; statement, and results do not change based on optimization. However, when; excess precision arithmetic is in use, Clang does not guarantee strict; reproducibility, and future compiler releases may recognize more; opportunities to use excess precision arithmetic, e.g. with floating-point; builtins. Clang does not use excess precision arithmetic for most types or on most; targets. For example, even on pre-SSE X86 targets where ``float`` and; ``double`` computations must be performed in the 80-bit X87 format, Clang; rounds all intermediate results correctly for their type. Clang currently; uses excess precision arithmetic by default only for the following types and; targets:. * ``_Float16`` on X86 targets without ``AVX512-FP16``. The ``-fexcess-precision=<value>`` option can be used to control the use of; excess precision arithmetic. Valid values are:. * ``standard`` - The default. Allow the use of excess precision arithmetic; under the constraints of the C and C++ standards. Has no effect except on; the types and targets listed above.; * ``fast`` - Accepted for GCC compatibility, but currently treated as an; alias for ``standard``.; * ``16`` - Fo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:69226,Deployability,configurat,configuration,69226," ``standard``.; * ``16`` - Forces ``_Float16`` operations to be emitted without using excess; precision arithmetic. .. option:: -fcx-limited-range:. This option enables the naive mathematical formulas for complex division and; multiplication with no NaN checking of results. The default is; ``-fno-cx-limited-range``, but this option is enabled by the ``-ffast-math``; option. .. option:: -fcx-fortran-rules:. This option enables the naive mathematical formulas for complex; multiplication and enables application of Smith's algorithm for complex; division. See SMITH, R. L. Algorithm 116: Complex division. Commun.; ACM 5, 8 (1962). The default is ``-fno-cx-fortran-rules``. .. _floating-point-environment:. Accessing the floating point environment; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; Many targets allow floating point operations to be configured to control things; such as how inexact results should be rounded and how exceptional conditions; should be handled. This configuration is called the floating point environment.; C and C++ restrict access to the floating point environment by default, and the; compiler is allowed to assume that all operations are performed in the default; environment. When code is compiled in this default mode, operations that depend; on the environment (such as floating-point arithmetic and `FLT_ROUNDS`) may have; undefined behavior if the dynamic environment is not the default environment; for; example, `FLT_ROUNDS` may or may not simply return its default value for the target; instead of reading the dynamic environment, and floating-point operations may be; optimized as if the dynamic environment were the default. Similarly, it is undefined; behavior to change the floating point environment in this default mode, for example; by calling the `fesetround` function.; C provides two pragmas to allow code to dynamically modify the floating point environment:. - ``#pragma STDC FENV_ACCESS ON`` allows dynamic changes to the entire floating; point envir",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:87053,Deployability,integrat,integrated,87053," ABI alignment of types; the layout of structs and; unions and the value returned by the alignof operator remain the same. This option can be overridden on a case-by-case basis by putting an explicit; “aligned” alignment on a struct, union, or typedef. For example:. .. code-block:: console. #include <immintrin.h>; // Make an aligned typedef of the AVX-512 16-int vector type.; typedef __v16si __aligned_v16si __attribute__((aligned(64)));. void initialize_vector(__aligned_v16si *v) {; // The compiler may assume that ‘v’ is 64-byte aligned, regardless of the; // value of -fmax-type-align.; }. .. option:: -faddrsig, -fno-addrsig. Controls whether Clang emits an address-significance table into the object; file. Address-significance tables allow linkers to implement `safe ICF; <https://research.google.com/pubs/archive/36912.pdf>`_ without the false; positives that can result from other implementation techniques such as; relocation scanning. Address-significance tables are enabled by default; on ELF targets when using the integrated assembler. This flag currently; only has an effect on ELF targets. .. option:: -f[no]-unique-internal-linkage-names. Controls whether Clang emits a unique (best-effort) symbol name for internal; linkage symbols. When this option is set, compiler hashes the main source; file path from the command line and appends it to all internal symbols. If a; program contains multiple objects compiled with the same command-line source; file path, the symbols are not guaranteed to be unique. This option is; particularly useful in attributing profile information to the correct; function when multiple functions with the same private linkage name exist; in the binary. It should be noted that this option cannot guarantee uniqueness and the; following is an example where it is not unique when two modules contain; symbols with the same private linkage name:. .. code-block:: console. $ cd $P/foo && clang -c -funique-internal-linkage-names name_conflict.c; $ cd $P/ba",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:93979,Deployability,install,installed,93979," back to source line locations. .. code-block:: console. $ clang++ -O2 -gline-tables-only code.cc -o code. 2. Run the executable under a sampling profiler. The specific profiler; you use does not really matter, as long as its output can be converted; into the format that the LLVM optimizer understands. Currently, there; exists a conversion tool for the Linux Perf profiler; (https://perf.wiki.kernel.org/), so these examples assume that you; are using Linux Perf to profile your code. .. code-block:: console. $ perf record -b ./code. Note the use of the ``-b`` flag. This tells Perf to use the Last Branch; Record (LBR) to record call chains. While this is not strictly required,; it provides better call information, which improves the accuracy of; the profile data. 3. Convert the collected profile data to LLVM's sample profile format.; This is currently supported via the AutoFDO converter ``create_llvm_prof``.; It is available at https://github.com/google/autofdo. Once built and; installed, you can convert the ``perf.data`` file to LLVM using; the command:. .. code-block:: console. $ create_llvm_prof --binary=./code --out=code.prof. This will read ``perf.data`` and the binary file ``./code`` and emit; the profile data in ``code.prof``. Note that if you ran ``perf``; without the ``-b`` flag, you need to use ``--use_lbr=false`` when; calling ``create_llvm_prof``. Alternatively, the LLVM tool ``llvm-profgen`` can also be used to generate; the LLVM sample profile:. .. code-block:: console. $ llvm-profgen --binary=./code --output=code.prof--perfdata=perf.data. 4. Build the code again using the collected profile. This step feeds; the profile back to the optimizers. This should result in a binary; that executes faster than the original one. Note that you are not; required to build the code with the exact same arguments that you; used in the first step. The only requirement is that you build the code; with ``-gline-tables-only`` and ``-fprofile-sample-use``. .. code-block:: conso",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:110627,Deployability,update,update,110627,"steps are the same as that in ``-fprofile-generate``; compilation. Then perform a second round of instrumentation. .. code-block:: console. $ clang++ -O2 -fprofile-use=code.profdata -fcs-profile-generate=sss/ttt \; -o cs_code; $ ./cs_code; $ llvm-profdata merge -output=cs_code.profdata sss/ttt code.profdata. The resulted ``cs_code.prodata`` combines ``code.profdata`` and the profile; generated from binary ``cs_code``. Profile ``cs_code.profata`` can be used by; ``-fprofile-use`` compilation. .. code-block:: console. $ clang++ -O2 -fprofile-use=cs_code.profdata. The above command will read both profiles to the compiler at the identical; point of instrumentations. .. option:: -fprofile-use[=<pathname>]. Without any other arguments, ``-fprofile-use`` behaves identically to; ``-fprofile-instr-use``. Otherwise, if ``pathname`` is the full path to a; profile file, it reads from that file. If ``pathname`` is a directory name,; it reads from ``pathname/default.profdata``. .. option:: -fprofile-update[=<method>]. Unless ``-fsanitize=thread`` is specified, the default is ``single``, which; uses non-atomic increments. The counters can be inaccurate under thread; contention. ``atomic`` uses atomic increments which is accurate but has; overhead. ``prefer-atomic`` will be transformed to ``atomic`` when supported; by the target, or ``single`` otherwise. Fine Tuning Profile Collection; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The PGO infrastructure provides user program knobs to fine tune profile; collection. Specifically, the PGO runtime provides the following functions; that can be used to control the regions in the program where profiles should; be collected. * ``void __llvm_profile_set_filename(const char *Name)``: changes the name of; the profile file to ``Name``.; * ``void __llvm_profile_reset_counters(void)``: resets all counters to zero.; * ``int __llvm_profile_dump(void)``: write the profile data to disk.; * ``int __llvm_orderfile_dump(void)``: write the order file to disk. For exa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:116104,Deployability,patch,patch,116104,"ecific files in a build, without affecting the main compilation flags; used for the other files in the project. In these cases, you can use the flag ``-fno-profile-instr-generate`` (or; ``-fno-profile-generate``) to disable profile generation, and; ``-fno-profile-instr-use`` (or ``-fno-profile-use``) to disable profile use. Note that these flags should appear after the corresponding profile; flags to have an effect. .. note::. When none of the translation units inside a binary is instrumented, in the; case of Fuchsia the profile runtime will not be linked into the binary and; no profile will be produced, while on other platforms the profile runtime; will be linked and profile will be produced but there will not be any; counters. Instrumenting only selected files or functions; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Sometimes it's useful to only instrument certain files or functions. For; example in automated testing infrastructure, it may be desirable to only; instrument files or functions that were modified by a patch to reduce the; overhead of instrumenting a full system. This can be done using the ``-fprofile-list`` option. .. option:: -fprofile-list=<pathname>. This option can be used to apply profile instrumentation only to selected; files or functions. ``pathname`` should point to a file in the; :doc:`SanitizerSpecialCaseList` format which selects which files and; functions to instrument. .. code-block:: console. $ clang++ -O2 -fprofile-instr-generate -fprofile-list=fun.list code.cc -o code. The option can be specified multiple times to pass multiple files. .. code-block:: console. $ clang++ -O2 -fprofile-instr-generate -fcoverage-mapping -fprofile-list=fun.list -fprofile-list=code.list code.cc -o code. Supported sections are ``[clang]``, ``[llvm]``, and ``[csllvm]`` representing; clang PGO, IRPGO, and CSIRPGO, respectively. Supported prefixes are ``function``; and ``source``. Supported categories are ``allow``, ``skip``, and ``forbid``.; ``skip`` adds ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:122206,Deployability,update,updated,122206,"://itanium-cxx-abi.github.io/cxx-abi/abi.html#mangle.encoding>`_>s,; respectively.; Blank lines and lines starting with ``#`` are ignored. For convenience, built-in <substitution>s such as ``St`` and ``Ss``; are accepted as <name>s (even though they technically are not <name>s). For example, to specify that ``absl::string_view`` and ``std::string_view``; should be treated as equivalent when matching profile data, the following; remapping file could be used:. .. code-block:: text. # absl::string_view is considered equivalent to std::string_view; type N4absl11string_viewE St17basic_string_viewIcSt11char_traitsIcEE. # std:: might be std::__1:: in libc++ or std::__cxx11:: in libstdc++; name 3std St3__1; name 3std St7__cxx11. Matching profile data using a profile remapping file is supported on a; best-effort basis. For example, information regarding indirect call targets is; currently not remapped. For best results, you are encouraged to generate new; profile data matching the updated program, or to remap the profile data; using the ``llvm-cxxmap`` and ``llvm-profdata merge`` tools. .. note::. Profile data remapping is currently only supported for C++ mangled names; following the Itanium C++ ABI mangling scheme. This covers all C++ targets; supported by Clang other than Windows. GCOV-based Profiling; --------------------. GCOV is a test coverage program, it helps to know how often a line of code; is executed. When instrumenting the code with ``--coverage`` option, some; counters are added for each edge linking basic blocks. At compile time, gcno files are generated containing information about; blocks and edges between them. At runtime the counters are incremented and at; exit the counters are dumped in gcda files. The tool ``llvm-cov gcov`` will parse gcno, gcda and source files to generate; a report ``.c.gcov``. .. option:: -fprofile-filter-files=[regexes]. Define a list of regexes separated by a semi-colon.; If a file name matches any of the regexes then the file is i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:128229,Deployability,release,release,128229,"ferent specific DWARF; features. You can ""tune"" the debug info for one of several different debuggers. .. option:: -ggdb, -glldb, -gsce, -gdbx. Tune the debug info for the ``gdb``, ``lldb``, Sony PlayStation\ |reg|; debugger, or ``dbx``, respectively. Each of these options implies **-g**.; (Therefore, if you want both **-gline-tables-only** and debugger tuning, the; tuning option must come first.). Controlling LLVM IR Output; --------------------------. Controlling Value Names in LLVM IR; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Emitting value names in LLVM IR increases the size and verbosity of the IR.; By default, value names are only emitted in assertion-enabled builds of Clang.; However, when reading IR it can be useful to re-enable the emission of value; names to improve readability. .. option:: -fdiscard-value-names. Discard value names when generating LLVM IR. .. option:: -fno-discard-value-names. Do not discard value names when generating LLVM IR. This option can be used; to re-enable names for release builds of Clang. Comment Parsing Options; -----------------------. Clang parses Doxygen and non-Doxygen style documentation comments and attaches; them to the appropriate declaration nodes. By default, it only parses; Doxygen-style comments and ignores ordinary comments starting with ``//`` and; ``/*``. .. option:: -Wdocumentation. Emit warnings about use of documentation comments. This warning group is off; by default. This includes checking that ``\param`` commands name parameters that actually; present in the function signature, checking that ``\returns`` is used only on; functions that actually return a value etc. .. option:: -Wno-documentation-unknown-command. Don't warn when encountering an unknown Doxygen command. .. option:: -fparse-all-comments. Parse all comments as documentation comments (including ordinary comments; starting with ``//`` and ``/*``). .. option:: -fcomment-block-commands=[commands]. Define custom documentation commands as block commands. T",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:137647,Deployability,install,installed,137647,"sions, use the ``-fms-extensions`` command-line option. This is the default; for Windows targets. Clang does not implement every pragma or declspec provided; by MSVC, but the popular ones, such as ``__declspec(dllexport)`` and ``#pragma; comment(lib)`` are well supported. clang has a ``-fms-compatibility`` flag that makes clang accept enough; invalid C++ to be able to parse most Microsoft headers. For example, it; allows `unqualified lookup of dependent base class members; <https://clang.llvm.org/compatibility.html#dep_lookup_bases>`_, which is; a common compatibility issue with clang. This flag is enabled by default; for Windows targets. ``-fdelayed-template-parsing`` lets clang delay parsing of function template; definitions until the end of a translation unit. This flag is enabled by; default for Windows targets. For compatibility with existing code that compiles with MSVC, clang defines the; ``_MSC_VER`` and ``_MSC_FULL_VER`` macros. When on Windows, these default to; either the same value as the currently installed version of cl.exe, or ``1933``; and ``193300000`` (respectively). The ``-fms-compatibility-version=`` flag; overrides these values. It accepts a dotted version tuple, such as 19.00.23506.; Changing the MSVC compatibility version makes clang behave more like that; version of MSVC. For example, ``-fms-compatibility-version=19`` will enable; C++14 features and define ``char16_t`` and ``char32_t`` as builtin types. .. _cxx:. C++ Language Features; =====================. clang fully implements all of standard C++98 except for exported; templates (which were removed in C++11), all of standard C++11,; C++14, and C++17, and most of C++20. See the `C++ support in Clang <https://clang.llvm.org/cxx_status.html>`_ page; for detailed information on C++ feature support across Clang versions. Controlling implementation limits; ---------------------------------. .. option:: -fbracket-depth=N. Sets the limit for nested parentheses, brackets, and braces to N. The; defa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:140833,Deployability,install,installation,140833,"imd directives and clauses; will be ignored. This can be disabled with `-fno-openmp-simd`. Controlling implementation limits; ---------------------------------. .. option:: -fopenmp-use-tls. Controls code generation for OpenMP threadprivate variables. In presence of; this option all threadprivate variables are generated the same way as thread; local variables, using TLS support. If `-fno-openmp-use-tls`; is provided or target does not support TLS, code generation for threadprivate; variables relies on OpenMP runtime library. .. _opencl:. OpenCL Features; ===============. Clang can be used to compile OpenCL kernels for execution on a device; (e.g. GPU). It is possible to compile the kernel into a binary (e.g. for AMDGPU); that can be uploaded to run directly on a device (e.g. using; `clCreateProgramWithBinary; <https://www.khronos.org/registry/OpenCL/specs/opencl-1.1.pdf#111>`_) or; into generic bitcode files loadable into other toolchains. Compiling to a binary using the default target from the installation can be done; as follows:. .. code-block:: console. $ echo ""kernel void k(){}"" > test.cl; $ clang test.cl. Compiling for a specific target can be done by specifying the triple corresponding; to the target, for example:. .. code-block:: console. $ clang --target=nvptx64-unknown-unknown test.cl; $ clang --target=amdgcn-amd-amdhsa -mcpu=gfx900 test.cl. Compiling to bitcode can be done as follows:. .. code-block:: console. $ clang -c -emit-llvm test.cl. This will produce a file `test.bc` that can be used in vendor toolchains; to perform machine code generation. Note that if compiled to bitcode for generic targets such as SPIR/SPIR-V,; portable IR is produced that can be used with various vendor; tools as well as open source tools such as `SPIRV-LLVM Translator; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator>`_; to produce SPIR-V binary. More details are provided in `the offline; compilation from OpenCL kernel sources into SPIR-V using open source; tools; <https",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:146836,Deployability,toggle,toggle,146836,"pir test.cl -emit-llvm -c; $ clang --target=spir64 test.cl -emit-llvm -c. Clang will generate SPIR v1.2 compatible IR for OpenCL versions up to 2.0 and; SPIR v2.0 for OpenCL v2.0 or C++ for OpenCL. - x86 is used by some implementations that are x86 compatible and currently; remains for backwards compatibility (with older implementations prior to; SPIR target support). For ""non-SPMD"" targets which cannot spawn multiple; work-items on the fly using hardware, which covers practically all non-GPU; devices such as CPUs and DSPs, additional processing is needed for the kernels; to support multiple work-item execution. For this, a 3rd party toolchain,; such as for example `POCL <http://portablecl.org/>`_, can be used. This target does not support multiple memory segments and, therefore, the fake; address space map can be added using the :ref:`-ffake-address-space-map; <opencl_fake_address_space_map>` flag. All known OpenCL extensions and features are set to supported in the generic targets,; however :option:`-cl-ext` flag can be used to toggle individual extensions and; features. .. _opencl_header:. OpenCL Header; -------------. By default Clang will include standard headers and therefore most of OpenCL; builtin functions and types are available during compilation. The; default declarations of non-native compiler types and functions can be disabled; by using flag :option:`-cl-no-stdinc`. The following example demonstrates that OpenCL kernel sources with various; standard builtin functions can be compiled without the need for an explicit; includes or compiler flags. .. code-block:: console. $ echo ""bool is_wg_uniform(int i){return get_enqueued_local_size(i)==get_local_size(i);}"" > test.cl; $ clang -cl-std=CL2.0 test.cl. More information about the default headers is provided in :doc:`OpenCLSupport`. OpenCL Extensions; -----------------. Most of the ``cl_khr_*`` extensions to OpenCL C from `the official OpenCL; registry <https://www.khronos.org/registry/OpenCL/>`_ are availabl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:152556,Deployability,release,releases,152556,"preserves CFG equivalence.; This allows some optimizations to happen as long as the control flow remains; unmodified. .. code-block:: c. for (int i=0; i<4; i++); my_sub_group_shuffle(). can be modified to:. .. code-block:: c. my_sub_group_shuffle();; my_sub_group_shuffle();; my_sub_group_shuffle();; my_sub_group_shuffle();. while using ``noduplicate`` would disallow this. Also ``noduplicate`` doesn't; have the same safe semantics of CFG as ``convergent`` and can cause changes in; CFG that modify semantics of the original program. ``noduplicate`` is kept for backwards compatibility only and it considered to be; deprecated for future uses. .. _cxx_for_opencl:. C++ for OpenCL; --------------. Starting from clang 9 kernel code can contain C++17 features: classes, templates,; function overloading, type deduction, etc. Please note that this is not an; implementation of `OpenCL C++; <https://www.khronos.org/registry/OpenCL/specs/2.2/pdf/OpenCL_Cxx.pdf>`_ and; there is no plan to support it in clang in any new releases in the near future. Clang currently supports C++ for OpenCL 1.0 and 2021.; For detailed information about this language refer to the C++ for OpenCL; Programming Language Documentation available; in `the latest build; <https://www.khronos.org/opencl/assets/CXX_for_OpenCL.html>`_; or in `the official release; <https://github.com/KhronosGroup/OpenCL-Docs/releases/tag/cxxforopencl-docrev2021.12>`_. To enable the C++ for OpenCL mode, pass one of following command line options when; compiling ``.clcpp`` file:. - C++ for OpenCL 1.0: ``-cl-std=clc++``, ``-cl-std=CLC++``, ``-cl-std=clc++1.0``,; ``-cl-std=CLC++1.0``, ``-std=clc++``, ``-std=CLC++``, ``-std=clc++1.0`` or; ``-std=CLC++1.0``. - C++ for OpenCL 2021: ``-cl-std=clc++2021``, ``-cl-std=CLC++2021``,; ``-std=clc++2021``, ``-std=CLC++2021``. Example of use:; .. code-block:: c++. template<class T> T add( T x, T y ); {; return x + y;; }. __kernel void test( __global float* a, __global float* b); {; auto index = get_g",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:152865,Deployability,release,release,152865," while using ``noduplicate`` would disallow this. Also ``noduplicate`` doesn't; have the same safe semantics of CFG as ``convergent`` and can cause changes in; CFG that modify semantics of the original program. ``noduplicate`` is kept for backwards compatibility only and it considered to be; deprecated for future uses. .. _cxx_for_opencl:. C++ for OpenCL; --------------. Starting from clang 9 kernel code can contain C++17 features: classes, templates,; function overloading, type deduction, etc. Please note that this is not an; implementation of `OpenCL C++; <https://www.khronos.org/registry/OpenCL/specs/2.2/pdf/OpenCL_Cxx.pdf>`_ and; there is no plan to support it in clang in any new releases in the near future. Clang currently supports C++ for OpenCL 1.0 and 2021.; For detailed information about this language refer to the C++ for OpenCL; Programming Language Documentation available; in `the latest build; <https://www.khronos.org/opencl/assets/CXX_for_OpenCL.html>`_; or in `the official release; <https://github.com/KhronosGroup/OpenCL-Docs/releases/tag/cxxforopencl-docrev2021.12>`_. To enable the C++ for OpenCL mode, pass one of following command line options when; compiling ``.clcpp`` file:. - C++ for OpenCL 1.0: ``-cl-std=clc++``, ``-cl-std=CLC++``, ``-cl-std=clc++1.0``,; ``-cl-std=CLC++1.0``, ``-std=clc++``, ``-std=CLC++``, ``-std=clc++1.0`` or; ``-std=CLC++1.0``. - C++ for OpenCL 2021: ``-cl-std=clc++2021``, ``-cl-std=CLC++2021``,; ``-std=clc++2021``, ``-std=CLC++2021``. Example of use:; .. code-block:: c++. template<class T> T add( T x, T y ); {; return x + y;; }. __kernel void test( __global float* a, __global float* b); {; auto index = get_global_id(0);; a[index] = add(b[index], b[index+1]);; }. .. code-block:: console. clang -cl-std=clc++1.0 test.clcpp; clang -cl-std=clc++ -c --target=spirv64 test.cl. By default, files with ``.clcpp`` extension are compiled with the C++ for; OpenCL 1.0 mode. .. code-block:: console. clang test.clcpp. For backward compatibili",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:152919,Deployability,release,releases,152919,"uplicate`` doesn't; have the same safe semantics of CFG as ``convergent`` and can cause changes in; CFG that modify semantics of the original program. ``noduplicate`` is kept for backwards compatibility only and it considered to be; deprecated for future uses. .. _cxx_for_opencl:. C++ for OpenCL; --------------. Starting from clang 9 kernel code can contain C++17 features: classes, templates,; function overloading, type deduction, etc. Please note that this is not an; implementation of `OpenCL C++; <https://www.khronos.org/registry/OpenCL/specs/2.2/pdf/OpenCL_Cxx.pdf>`_ and; there is no plan to support it in clang in any new releases in the near future. Clang currently supports C++ for OpenCL 1.0 and 2021.; For detailed information about this language refer to the C++ for OpenCL; Programming Language Documentation available; in `the latest build; <https://www.khronos.org/opencl/assets/CXX_for_OpenCL.html>`_; or in `the official release; <https://github.com/KhronosGroup/OpenCL-Docs/releases/tag/cxxforopencl-docrev2021.12>`_. To enable the C++ for OpenCL mode, pass one of following command line options when; compiling ``.clcpp`` file:. - C++ for OpenCL 1.0: ``-cl-std=clc++``, ``-cl-std=CLC++``, ``-cl-std=clc++1.0``,; ``-cl-std=CLC++1.0``, ``-std=clc++``, ``-std=CLC++``, ``-std=clc++1.0`` or; ``-std=CLC++1.0``. - C++ for OpenCL 2021: ``-cl-std=clc++2021``, ``-cl-std=CLC++2021``,; ``-std=clc++2021``, ``-std=CLC++2021``. Example of use:; .. code-block:: c++. template<class T> T add( T x, T y ); {; return x + y;; }. __kernel void test( __global float* a, __global float* b); {; auto index = get_global_id(0);; a[index] = add(b[index], b[index+1]);; }. .. code-block:: console. clang -cl-std=clc++1.0 test.clcpp; clang -cl-std=clc++ -c --target=spirv64 test.cl. By default, files with ``.clcpp`` extension are compiled with the C++ for; OpenCL 1.0 mode. .. code-block:: console. clang test.clcpp. For backward compatibility files with ``.cl`` extensions can also be compiled; in C+",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:156214,Deployability,release,released,156214,"AMES`` to ``clGetProgramInfo`` (OpenCL v2.0; s5.8.7) and then checking whether any kernel name matches the naming scheme of; global constructor initialization kernel above. Note that if multiple files are compiled and linked into libraries, multiple; kernels that initialize global objects for multiple modules would have to be; invoked. Applications are currently required to run initialization of global objects; manually before running any kernels in which the objects are used. .. code-block:: console. clang -cl-std=clc++ test.cl. If there are any global objects to be initialized, the final binary will; contain the ``_GLOBAL__sub_I_test.cl`` kernel to be enqueued. Note that the manual workaround only applies to objects declared at the; program scope. There is no manual workaround for the construction of static; objects with non-trivial constructors inside functions. Global destructors can not be invoked manually in the OpenCL v2.0 drivers.; However, all memory used for program scope objects should be released on; ``clReleaseProgram``. Libraries; ^^^^^^^^^; Limited experimental support of C++ standard libraries for OpenCL is; described in :doc:`OpenCLSupport` page. .. _target_features:. Target-Specific Features and Limitations; ========================================. CPU Architectures Features and Limitations; ------------------------------------------. X86; ^^^. The support for X86 (both 32-bit and 64-bit) is considered stable on; Darwin (macOS), Linux, FreeBSD, and Dragonfly BSD: it has been tested; to correctly compile many large C, C++, Objective-C, and Objective-C++; codebases. On ``x86_64-mingw32``, passing i128(by value) is incompatible with the; Microsoft x64 calling convention. You might need to tweak; ``WinX86_64ABIInfo::classify()`` in lib/CodeGen/Targets/X86.cpp. For the X86 target, clang supports the `-m16` command line; argument which enables 16-bit code output. This is broadly similar to; using ``asm("".code16gcc"")`` with the GNU toolchain. The generate",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:158366,Deployability,continuous,continuous,158366,"addressing and operations. Several micro-architecture levels as specified by the x86-64 psABI are defined.; They are cumulative in the sense that features from previous levels are; implicitly included in later levels. - ``-march=x86-64``: CMOV, CMPXCHG8B, FPU, FXSR, MMX, FXSR, SCE, SSE, SSE2; - ``-march=x86-64-v2``: (close to Nehalem) CMPXCHG16B, LAHF-SAHF, POPCNT, SSE3, SSE4.1, SSE4.2, SSSE3; - ``-march=x86-64-v3``: (close to Haswell) AVX, AVX2, BMI1, BMI2, F16C, FMA, LZCNT, MOVBE, XSAVE; - ``-march=x86-64-v4``: AVX512F, AVX512BW, AVX512CD, AVX512DQ, AVX512VL. `Intel AVX10 ISA <https://cdrdv2.intel.com/v1/dl/getContent/784267>`_ is; a major new vector ISA incorporating the modern vectorization aspects of; Intel AVX-512. This ISA will be supported on all future Intel processors.; Users are supposed to use the new options ``-mavx10.N`` and ``-mavx10.N-512``; on these processors and should not use traditional AVX512 options anymore. The ``N`` in ``-mavx10.N`` represents a continuous integer number starting; from ``1``. ``-mavx10.N`` is an alias of ``-mavx10.N-256``, which means to; enable all instructions within AVX10 version N at a maximum vector length of; 256 bits. ``-mavx10.N-512`` enables all instructions at a maximum vector; length of 512 bits, which is a superset of instructions ``-mavx10.N`` enabled. Current binaries built with AVX512 features can run on Intel AVX10/512 capable; processors without re-compile, but cannot run on AVX10/256 capable processors.; Users need to re-compile their code with ``-mavx10.N``, and maybe update some; code that calling to 512-bit X86 specific intrinsics and passing or returning; 512-bit vector types in function call, if they want to run on AVX10/256 capable; processors. Binaries built with ``-mavx10.N`` can run on both AVX10/256 and; AVX10/512 capable processors. Users can add a ``-mno-evex512`` in the command line with AVX512 options if; they want to run the binary on both legacy AVX512 and new AVX10/256 capable; processors. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:158935,Deployability,update,update,158935,"is; a major new vector ISA incorporating the modern vectorization aspects of; Intel AVX-512. This ISA will be supported on all future Intel processors.; Users are supposed to use the new options ``-mavx10.N`` and ``-mavx10.N-512``; on these processors and should not use traditional AVX512 options anymore. The ``N`` in ``-mavx10.N`` represents a continuous integer number starting; from ``1``. ``-mavx10.N`` is an alias of ``-mavx10.N-256``, which means to; enable all instructions within AVX10 version N at a maximum vector length of; 256 bits. ``-mavx10.N-512`` enables all instructions at a maximum vector; length of 512 bits, which is a superset of instructions ``-mavx10.N`` enabled. Current binaries built with AVX512 features can run on Intel AVX10/512 capable; processors without re-compile, but cannot run on AVX10/256 capable processors.; Users need to re-compile their code with ``-mavx10.N``, and maybe update some; code that calling to 512-bit X86 specific intrinsics and passing or returning; 512-bit vector types in function call, if they want to run on AVX10/256 capable; processors. Binaries built with ``-mavx10.N`` can run on both AVX10/256 and; AVX10/512 capable processors. Users can add a ``-mno-evex512`` in the command line with AVX512 options if; they want to run the binary on both legacy AVX512 and new AVX10/256 capable; processors. The option has the same constraints as ``-mavx10.N``, i.e.,; cannot call to 512-bit X86 specific intrinsics and pass or return 512-bit vector; types in function call. Users should avoid using AVX512 features in function target attributes when; developing code for AVX10. If they have to do so, they need to add an explicit; ``evex512`` or ``no-evex512`` together with AVX512 features for 512-bit or; non-512-bit functions respectively to avoid unexpected code generation. Both; command line option and target attribute of EVEX512 feature can only be used; with AVX512. They don't affect vector size of AVX10. User should not mix the use AV",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:165752,Deployability,install,installed,165752,":. * ``-mdefault-visibility-export-mapping=none``: no additional export; information is created for entities with default visibility.; * ``-mdefault-visibility-export-mapping=explicit``: mark entities for export; if they have explicit (e.g. via an attribute) default visibility from the; source, including RTTI.; * ``-mdefault-visibility-export-mapping=all``: set XCOFF exported visibility; for all entities with default visibility from any source. This gives a; export behavior similar to ELF platforms where all entities with default; visibility are exported. .. _spir-v:. SPIR-V support; --------------. Clang supports generation of SPIR-V conformant to `the OpenCL Environment; Specification; <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_Env.html>`_. To generate SPIR-V binaries, Clang uses the external ``llvm-spirv`` tool from the; `SPIRV-LLVM-Translator repo; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator>`_. Prior to the generation of SPIR-V binary with Clang, ``llvm-spirv``; should be built or installed. Please refer to `the following instructions; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator#build-instructions>`_; for more details. Clang will expect the ``llvm-spirv`` executable to; be present in the ``PATH`` environment variable. Clang uses ``llvm-spirv``; with `the widely adopted assembly syntax package; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator/#build-with-spirv-tools>`_. `The versioning; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator/releases>`_ of; ``llvm-spirv`` is aligned with Clang major releases. The same applies to the; main development branch. It is therefore important to ensure the ``llvm-spirv``; version is in alignment with the Clang version. For troubleshooting purposes; ``llvm-spirv`` can be `tested in isolation; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator#test-instructions>`_. Example usage for OpenCL kernel compilation:. .. code-block:: console. $ clang --target=spirv32 -c tes",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:166237,Deployability,release,releases,166237,"sibility are exported. .. _spir-v:. SPIR-V support; --------------. Clang supports generation of SPIR-V conformant to `the OpenCL Environment; Specification; <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_Env.html>`_. To generate SPIR-V binaries, Clang uses the external ``llvm-spirv`` tool from the; `SPIRV-LLVM-Translator repo; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator>`_. Prior to the generation of SPIR-V binary with Clang, ``llvm-spirv``; should be built or installed. Please refer to `the following instructions; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator#build-instructions>`_; for more details. Clang will expect the ``llvm-spirv`` executable to; be present in the ``PATH`` environment variable. Clang uses ``llvm-spirv``; with `the widely adopted assembly syntax package; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator/#build-with-spirv-tools>`_. `The versioning; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator/releases>`_ of; ``llvm-spirv`` is aligned with Clang major releases. The same applies to the; main development branch. It is therefore important to ensure the ``llvm-spirv``; version is in alignment with the Clang version. For troubleshooting purposes; ``llvm-spirv`` can be `tested in isolation; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator#test-instructions>`_. Example usage for OpenCL kernel compilation:. .. code-block:: console. $ clang --target=spirv32 -c test.cl; $ clang --target=spirv64 -c test.cl. Both invocations of Clang will result in the generation of a SPIR-V binary file; `test.o` for 32 bit and 64 bit respectively. This file can be imported; by an OpenCL driver that support SPIR-V consumption or it can be compiled; further by offline SPIR-V consumer tools. Converting to SPIR-V produced with the optimization levels other than `-O0` is; currently available as an experimental feature and it is not guaranteed to work; in all cases. Clang also supports integrated generation of SPIR-V",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:166296,Deployability,release,releases,166296,"sibility are exported. .. _spir-v:. SPIR-V support; --------------. Clang supports generation of SPIR-V conformant to `the OpenCL Environment; Specification; <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_Env.html>`_. To generate SPIR-V binaries, Clang uses the external ``llvm-spirv`` tool from the; `SPIRV-LLVM-Translator repo; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator>`_. Prior to the generation of SPIR-V binary with Clang, ``llvm-spirv``; should be built or installed. Please refer to `the following instructions; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator#build-instructions>`_; for more details. Clang will expect the ``llvm-spirv`` executable to; be present in the ``PATH`` environment variable. Clang uses ``llvm-spirv``; with `the widely adopted assembly syntax package; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator/#build-with-spirv-tools>`_. `The versioning; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator/releases>`_ of; ``llvm-spirv`` is aligned with Clang major releases. The same applies to the; main development branch. It is therefore important to ensure the ``llvm-spirv``; version is in alignment with the Clang version. For troubleshooting purposes; ``llvm-spirv`` can be `tested in isolation; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator#test-instructions>`_. Example usage for OpenCL kernel compilation:. .. code-block:: console. $ clang --target=spirv32 -c test.cl; $ clang --target=spirv64 -c test.cl. Both invocations of Clang will result in the generation of a SPIR-V binary file; `test.o` for 32 bit and 64 bit respectively. This file can be imported; by an OpenCL driver that support SPIR-V consumption or it can be compiled; further by offline SPIR-V consumer tools. Converting to SPIR-V produced with the optimization levels other than `-O0` is; currently available as an experimental feature and it is not guaranteed to work; in all cases. Clang also supports integrated generation of SPIR-V",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:167221,Deployability,integrat,integrated,167221,"jor releases. The same applies to the; main development branch. It is therefore important to ensure the ``llvm-spirv``; version is in alignment with the Clang version. For troubleshooting purposes; ``llvm-spirv`` can be `tested in isolation; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator#test-instructions>`_. Example usage for OpenCL kernel compilation:. .. code-block:: console. $ clang --target=spirv32 -c test.cl; $ clang --target=spirv64 -c test.cl. Both invocations of Clang will result in the generation of a SPIR-V binary file; `test.o` for 32 bit and 64 bit respectively. This file can be imported; by an OpenCL driver that support SPIR-V consumption or it can be compiled; further by offline SPIR-V consumer tools. Converting to SPIR-V produced with the optimization levels other than `-O0` is; currently available as an experimental feature and it is not guaranteed to work; in all cases. Clang also supports integrated generation of SPIR-V without use of ``llvm-spirv``; tool as an experimental feature when ``-fintegrated-objemitter`` flag is passed in; the command line. .. code-block:: console. $ clang --target=spirv32 -fintegrated-objemitter -c test.cl. Note that only very basic functionality is supported at this point and therefore; it is not suitable for arbitrary use cases. This feature is only enabled when clang; build is configured with ``-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=SPIRV`` option. Linking is done using ``spirv-link`` from `the SPIRV-Tools project; <https://github.com/KhronosGroup/SPIRV-Tools#linker>`_. Similar to other external; linkers, Clang will expect ``spirv-link`` to be installed separately and to be; present in the ``PATH`` environment variable. Please refer to `the build and; installation instructions; <https://github.com/KhronosGroup/SPIRV-Tools#build>`_. .. code-block:: console. $ clang --target=spirv64 test1.cl test2.cl. More information about the SPIR-V target settings and supported versions of SPIR-V; format can be found in `the SP",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:167918,Deployability,install,installed,167918,"nCL driver that support SPIR-V consumption or it can be compiled; further by offline SPIR-V consumer tools. Converting to SPIR-V produced with the optimization levels other than `-O0` is; currently available as an experimental feature and it is not guaranteed to work; in all cases. Clang also supports integrated generation of SPIR-V without use of ``llvm-spirv``; tool as an experimental feature when ``-fintegrated-objemitter`` flag is passed in; the command line. .. code-block:: console. $ clang --target=spirv32 -fintegrated-objemitter -c test.cl. Note that only very basic functionality is supported at this point and therefore; it is not suitable for arbitrary use cases. This feature is only enabled when clang; build is configured with ``-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=SPIRV`` option. Linking is done using ``spirv-link`` from `the SPIRV-Tools project; <https://github.com/KhronosGroup/SPIRV-Tools#linker>`_. Similar to other external; linkers, Clang will expect ``spirv-link`` to be installed separately and to be; present in the ``PATH`` environment variable. Please refer to `the build and; installation instructions; <https://github.com/KhronosGroup/SPIRV-Tools#build>`_. .. code-block:: console. $ clang --target=spirv64 test1.cl test2.cl. More information about the SPIR-V target settings and supported versions of SPIR-V; format can be found in `the SPIR-V target guide; <https://llvm.org/docs/SPIRVUsage.html>`__. .. _clang-cl:. clang-cl; ========. clang-cl is an alternative command-line interface to Clang, designed for; compatibility with the Visual C++ compiler, cl.exe. To enable clang-cl to find system headers, libraries, and the linker when run; from the command-line, it should be executed inside a Visual Studio Native Tools; Command Prompt or a regular Command Prompt where the environment has been set; up using e.g. `vcvarsall.bat <https://msdn.microsoft.com/en-us/library/f2ccy3wt.aspx>`_. clang-cl can also be used from inside Visual Studio by selecting the LLVM",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:168028,Deployability,install,installation,168028,"ing to SPIR-V produced with the optimization levels other than `-O0` is; currently available as an experimental feature and it is not guaranteed to work; in all cases. Clang also supports integrated generation of SPIR-V without use of ``llvm-spirv``; tool as an experimental feature when ``-fintegrated-objemitter`` flag is passed in; the command line. .. code-block:: console. $ clang --target=spirv32 -fintegrated-objemitter -c test.cl. Note that only very basic functionality is supported at this point and therefore; it is not suitable for arbitrary use cases. This feature is only enabled when clang; build is configured with ``-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=SPIRV`` option. Linking is done using ``spirv-link`` from `the SPIRV-Tools project; <https://github.com/KhronosGroup/SPIRV-Tools#linker>`_. Similar to other external; linkers, Clang will expect ``spirv-link`` to be installed separately and to be; present in the ``PATH`` environment variable. Please refer to `the build and; installation instructions; <https://github.com/KhronosGroup/SPIRV-Tools#build>`_. .. code-block:: console. $ clang --target=spirv64 test1.cl test2.cl. More information about the SPIR-V target settings and supported versions of SPIR-V; format can be found in `the SPIR-V target guide; <https://llvm.org/docs/SPIRVUsage.html>`__. .. _clang-cl:. clang-cl; ========. clang-cl is an alternative command-line interface to Clang, designed for; compatibility with the Visual C++ compiler, cl.exe. To enable clang-cl to find system headers, libraries, and the linker when run; from the command-line, it should be executed inside a Visual Studio Native Tools; Command Prompt or a regular Command Prompt where the environment has been set; up using e.g. `vcvarsall.bat <https://msdn.microsoft.com/en-us/library/f2ccy3wt.aspx>`_. clang-cl can also be used from inside Visual Studio by selecting the LLVM; Platform Toolset. The toolset is not part of the installer, but may be installed; separately from the; `Visual S",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:168970,Deployability,install,installer,168970,"fer to `the build and; installation instructions; <https://github.com/KhronosGroup/SPIRV-Tools#build>`_. .. code-block:: console. $ clang --target=spirv64 test1.cl test2.cl. More information about the SPIR-V target settings and supported versions of SPIR-V; format can be found in `the SPIR-V target guide; <https://llvm.org/docs/SPIRVUsage.html>`__. .. _clang-cl:. clang-cl; ========. clang-cl is an alternative command-line interface to Clang, designed for; compatibility with the Visual C++ compiler, cl.exe. To enable clang-cl to find system headers, libraries, and the linker when run; from the command-line, it should be executed inside a Visual Studio Native Tools; Command Prompt or a regular Command Prompt where the environment has been set; up using e.g. `vcvarsall.bat <https://msdn.microsoft.com/en-us/library/f2ccy3wt.aspx>`_. clang-cl can also be used from inside Visual Studio by selecting the LLVM; Platform Toolset. The toolset is not part of the installer, but may be installed; separately from the; `Visual Studio Marketplace <https://marketplace.visualstudio.com/items?itemName=LLVMExtensions.llvm-toolchain>`_.; To use the toolset, select a project in Solution Explorer, open its Property; Page (Alt+F7), and in the ""General"" section of ""Configuration Properties""; change ""Platform Toolset"" to LLVM. Doing so enables an additional Property; Page for selecting the clang-cl executable to use for builds. To use the toolset with MSBuild directly, invoke it with e.g.; ``/p:PlatformToolset=LLVM``. This allows trying out the clang-cl toolchain; without modifying your project files. It's also possible to point MSBuild at clang-cl without changing toolset by; passing ``/p:CLToolPath=c:\llvm\bin /p:CLToolExe=clang-cl.exe``. When using CMake and the Visual Studio generators, the toolset can be set with the ``-T`` flag:. ::. cmake -G""Visual Studio 16 2019"" -T LLVM .. When using CMake with the Ninja generator, set the ``CMAKE_C_COMPILER`` and; ``CMAKE_CXX_COMPILER`` variables to",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:168992,Deployability,install,installed,168992,"fer to `the build and; installation instructions; <https://github.com/KhronosGroup/SPIRV-Tools#build>`_. .. code-block:: console. $ clang --target=spirv64 test1.cl test2.cl. More information about the SPIR-V target settings and supported versions of SPIR-V; format can be found in `the SPIR-V target guide; <https://llvm.org/docs/SPIRVUsage.html>`__. .. _clang-cl:. clang-cl; ========. clang-cl is an alternative command-line interface to Clang, designed for; compatibility with the Visual C++ compiler, cl.exe. To enable clang-cl to find system headers, libraries, and the linker when run; from the command-line, it should be executed inside a Visual Studio Native Tools; Command Prompt or a regular Command Prompt where the environment has been set; up using e.g. `vcvarsall.bat <https://msdn.microsoft.com/en-us/library/f2ccy3wt.aspx>`_. clang-cl can also be used from inside Visual Studio by selecting the LLVM; Platform Toolset. The toolset is not part of the installer, but may be installed; separately from the; `Visual Studio Marketplace <https://marketplace.visualstudio.com/items?itemName=LLVMExtensions.llvm-toolchain>`_.; To use the toolset, select a project in Solution Explorer, open its Property; Page (Alt+F7), and in the ""General"" section of ""Configuration Properties""; change ""Platform Toolset"" to LLVM. Doing so enables an additional Property; Page for selecting the clang-cl executable to use for builds. To use the toolset with MSBuild directly, invoke it with e.g.; ``/p:PlatformToolset=LLVM``. This allows trying out the clang-cl toolchain; without modifying your project files. It's also possible to point MSBuild at clang-cl without changing toolset by; passing ``/p:CLToolPath=c:\llvm\bin /p:CLToolExe=clang-cl.exe``. When using CMake and the Visual Studio generators, the toolset can be set with the ``-T`` flag:. ::. cmake -G""Visual Studio 16 2019"" -T LLVM .. When using CMake with the Ninja generator, set the ``CMAKE_C_COMPILER`` and; ``CMAKE_CXX_COMPILER`` variables to",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:175937,Deployability,release,release,175937,"name of each compiled file (default); /showFilenames Print the name of each compiled file; /showIncludes Print info about included files to stderr; /source-charset:<value> Source encoding, supports only UTF-8; /std:<value> Language standard to compile for; /TC Treat all source files as C; /Tc <filename> Specify a C source file; /TP Treat all source files as C++; /Tp <filename> Specify a C++ source file; /utf-8 Set source and runtime encoding to UTF-8 (default); /U <macro> Undefine macro; /vd<value> Control vtordisp placement; /vmb Use a best-case representation method for member pointers; /vmg Use a most-general representation for member pointers; /vmm Set the default most-general representation to multiple inheritance; /vms Set the default most-general representation to single inheritance; /vmv Set the default most-general representation to virtual inheritance; /volatile:iso Volatile loads and stores have standard semantics; /volatile:ms Volatile loads and stores have acquire and release semantics; /W0 Disable all warnings; /W1 Enable -Wall; /W2 Enable -Wall; /W3 Enable -Wall; /W4 Enable -Wall and -Wextra; /Wall Enable -Weverything; /WX- Do not treat warnings as errors; /WX Treat warnings as errors; /w Disable all warnings; /X Don't add %INCLUDE% to the include search path; /Y- Disable precompiled headers, overrides /Yc and /Yu; /Yc<filename> Generate a pch file for all code up to and including <filename>; /Yu<filename> Load a pch file and use it instead of all code up to and including <filename>; /Z7 Enable CodeView debug information in object files; /Zc:char8_t Enable C++20 char8_t type; /Zc:char8_t- Disable C++20 char8_t type; /Zc:dllexportInlines- Don't dllexport/dllimport inline member functions of dllexport/import classes; /Zc:dllexportInlines dllexport/dllimport inline member functions of dllexport/import classes (default); /Zc:sizedDealloc- Disable C++14 sized global deallocation functions; /Zc:sizedDealloc Enable C++14 sized global deallocation functions; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:178973,Deployability,install,installed,178973,"; /Zp<value> Specify the default maximum struct packing alignment; /Zs Run the preprocessor, parser and semantic analysis stages. OPTIONS:; -### Print (but do not run) the commands to run for this compilation; --analyze Run the static analyzer; -faddrsig Emit an address-significance table; -fansi-escape-codes Use ANSI escape codes for diagnostics; -fblocks Enable the 'blocks' language feature; -fcf-protection=<value> Instrument control-flow architecture protection. Options: return, branch, full, none.; -fcf-protection Enable cf-protection in 'full' mode; -fcolor-diagnostics Use colors in diagnostics; -fcomplete-member-pointers; Require member pointer base types to be complete if they would be significant under the Microsoft ABI; -fcoverage-mapping Generate coverage mapping to enable code coverage analysis; -fcrash-diagnostics-dir=<dir>; Put crash-report files in <dir>; -fdebug-macro Emit macro debug information; -fdelayed-template-parsing; Parse templated function definitions at the end of the translation unit; -fdiagnostics-absolute-paths; Print absolute paths in diagnostics; -fdiagnostics-parseable-fixits; Print fix-its in machine parseable form; -flto=<value> Set LTO mode to either 'full' or 'thin'; -flto Enable LTO in 'full' mode; -fmerge-all-constants Allow merging of constants; -fms-compatibility-version=<value>; Dot-separated value representing the Microsoft compiler version; number to report in _MSC_VER (0 = don't define it; default is same value as installed cl.exe, or 1933); -fms-compatibility Enable full Microsoft Visual C++ compatibility; -fms-extensions Accept some non-standard constructs supported by the Microsoft compiler; -fmsc-version=<value> Microsoft compiler version number to report in _MSC_VER; (0 = don't define it; default is same value as installed cl.exe, or 1933); -fno-addrsig Don't emit an address-significance table; -fno-builtin-<value> Disable implicit builtin knowledge of a specific function; -fno-builtin Disable implicit builtin knowledg",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:179283,Deployability,install,installed,179283," pointer base types to be complete if they would be significant under the Microsoft ABI; -fcoverage-mapping Generate coverage mapping to enable code coverage analysis; -fcrash-diagnostics-dir=<dir>; Put crash-report files in <dir>; -fdebug-macro Emit macro debug information; -fdelayed-template-parsing; Parse templated function definitions at the end of the translation unit; -fdiagnostics-absolute-paths; Print absolute paths in diagnostics; -fdiagnostics-parseable-fixits; Print fix-its in machine parseable form; -flto=<value> Set LTO mode to either 'full' or 'thin'; -flto Enable LTO in 'full' mode; -fmerge-all-constants Allow merging of constants; -fms-compatibility-version=<value>; Dot-separated value representing the Microsoft compiler version; number to report in _MSC_VER (0 = don't define it; default is same value as installed cl.exe, or 1933); -fms-compatibility Enable full Microsoft Visual C++ compatibility; -fms-extensions Accept some non-standard constructs supported by the Microsoft compiler; -fmsc-version=<value> Microsoft compiler version number to report in _MSC_VER; (0 = don't define it; default is same value as installed cl.exe, or 1933); -fno-addrsig Don't emit an address-significance table; -fno-builtin-<value> Disable implicit builtin knowledge of a specific function; -fno-builtin Disable implicit builtin knowledge of functions; -fno-complete-member-pointers; Do not require member pointer base types to be complete if they would be significant under the Microsoft ABI; -fno-coverage-mapping Disable code coverage analysis; -fno-crash-diagnostics Disable auto-generation of preprocessed source files and a script for reproduction during a clang crash; -fno-debug-macro Do not emit macro debug information; -fno-delayed-template-parsing; Disable delayed template parsing; -fno-sanitize-address-poison-custom-array-cookie; Disable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fno-sanitize-address-use-after-scope; Disable use-afte",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:190993,Deployability,install,installed,190993,"Using ``-fvisibility-inlines-hidden`` can; lead to the same issue. To avoid it in this case, make `S::foo()` or; `internal()` non-inline, or mark them `dllimport/dllexport` explicitly. Finding Clang runtime libraries; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. clang-cl supports several features that require runtime library support:. - Address Sanitizer (ASan): ``-fsanitize=address``; - Undefined Behavior Sanitizer (UBSan): ``-fsanitize=undefined``; - Code coverage: ``-fprofile-instr-generate -fcoverage-mapping``; - Profile Guided Optimization (PGO): ``-fprofile-generate``; - Certain math operations (int128 division) require the builtins library. In order to use these features, the user must link the right runtime libraries; into their program. These libraries are distributed alongside Clang in the; library resource directory. Clang searches for the resource directory by; searching relative to the Clang executable. For example, if LLVM is installed; in ``C:\Program Files\LLVM``, then the profile runtime library will be located; at the path; ``C:\Program Files\LLVM\lib\clang\11.0.0\lib\windows\clang_rt.profile-x86_64.lib``. For UBSan, PGO, and coverage, Clang will emit object files that auto-link the; appropriate runtime library, but the user generally needs to help the linker; (whether it is ``lld-link.exe`` or MSVC ``link.exe``) find the library resource; directory. Using the example installation above, this would mean passing; ``/LIBPATH:C:\Program Files\LLVM\lib\clang\11.0.0\lib\windows`` to the linker.; If the user links the program with the ``clang`` or ``clang-cl`` drivers, the; driver will pass this flag for them. If the linker cannot find the appropriate library, it will emit an error like; this::. $ clang-cl -c -fsanitize=undefined t.cpp. $ lld-link t.obj -dll; lld-link: error: could not open 'clang_rt.ubsan_standalone-x86_64.lib': no such file or directory; lld-link: error: could not open 'clang_rt.ubsan_standalone_cxx-x86_64.lib': no such file or directory. $ link t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:191448,Deployability,install,installation,191448,"efined``; - Code coverage: ``-fprofile-instr-generate -fcoverage-mapping``; - Profile Guided Optimization (PGO): ``-fprofile-generate``; - Certain math operations (int128 division) require the builtins library. In order to use these features, the user must link the right runtime libraries; into their program. These libraries are distributed alongside Clang in the; library resource directory. Clang searches for the resource directory by; searching relative to the Clang executable. For example, if LLVM is installed; in ``C:\Program Files\LLVM``, then the profile runtime library will be located; at the path; ``C:\Program Files\LLVM\lib\clang\11.0.0\lib\windows\clang_rt.profile-x86_64.lib``. For UBSan, PGO, and coverage, Clang will emit object files that auto-link the; appropriate runtime library, but the user generally needs to help the linker; (whether it is ``lld-link.exe`` or MSVC ``link.exe``) find the library resource; directory. Using the example installation above, this would mean passing; ``/LIBPATH:C:\Program Files\LLVM\lib\clang\11.0.0\lib\windows`` to the linker.; If the user links the program with the ``clang`` or ``clang-cl`` drivers, the; driver will pass this flag for them. If the linker cannot find the appropriate library, it will emit an error like; this::. $ clang-cl -c -fsanitize=undefined t.cpp. $ lld-link t.obj -dll; lld-link: error: could not open 'clang_rt.ubsan_standalone-x86_64.lib': no such file or directory; lld-link: error: could not open 'clang_rt.ubsan_standalone_cxx-x86_64.lib': no such file or directory. $ link t.obj -dll -nologo; LINK : fatal error LNK1104: cannot open file 'clang_rt.ubsan_standalone-x86_64.lib'. To fix the error, add the appropriate ``/libpath:`` flag to the link line. For ASan, as of this writing, the user is also responsible for linking against; the correct ASan libraries. If the user is using the dynamic CRT (``/MD``), then they should add; ``clang_rt.asan_dynamic-x86_64.lib`` to the link line as a regular input. Fo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:195263,Deployability,install,installation,195263,"onments. It allows the control of an alternate location to be treated; as a system root. When specified, it will be used as the root where the; `Windows Kits` is located. - `/winsdkversion:`; - `/winsdkdir:`. If `/winsysroot:` is not specified, the `/winsdkdir:` argument is consulted; as a location to identify where the Windows SDK is located. Contrary to; `/winsysroot:`, `/winsdkdir:` is expected to be the complete path rather; than a root to locate `Windows Kits`. The `/winsdkversion:` flag allows the user to specify a version identifier; for the SDK to prefer. When this is specified, no additional validation is; performed and this version is preferred. If the version is not specified,; the highest detected version number will be used. 2. Consult the environment. TODO: This is not yet implemented. This will consult the environment variables:. - `WindowsSdkDir`; - `UCRTVersion`. 3. Fallback to the registry. If no arguments are used to indicate where the SDK is present, and the; compiler is running on Windows, the registry is consulted to locate the; installation. The Visual C++ Toolset has a slightly more elaborate mechanism for detection. 1. Consult the command line. - `/winsysroot:`. The `/winsysroot:` is used as an equivalent to `-sysroot` on Unix; environments. It allows the control of an alternate location to be treated; as a system root. When specified, it will be used as the root where the; `VC` directory is located. - `/vctoolsdir:`; - `/vctoolsversion:`. If `/winsysroot:` is not specified, the `/vctoolsdir:` argument is consulted; as a location to identify where the Visual C++ Tools are located. If; `/vctoolsversion:` is specified, that version is preferred, otherwise, the; highest version detected is used. 2. Consult the environment. - `/external:[VARIABLE]`. This specifies a user identified environment variable which is treated as; a path delimiter (`;`) separated list of paths to map into `-imsvc`; arguments which are treated as `-isystem`. - `INCLUDE` a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:196976,Deployability,install,installation,196976,"insysroot:` is not specified, the `/vctoolsdir:` argument is consulted; as a location to identify where the Visual C++ Tools are located. If; `/vctoolsversion:` is specified, that version is preferred, otherwise, the; highest version detected is used. 2. Consult the environment. - `/external:[VARIABLE]`. This specifies a user identified environment variable which is treated as; a path delimiter (`;`) separated list of paths to map into `-imsvc`; arguments which are treated as `-isystem`. - `INCLUDE` and `EXTERNAL_INCLUDE`. The path delimiter (`;`) separated list of paths will be mapped to; `-imsvc` arguments which are treated as `-isystem`. - `LIB` (indirectly). The linker `link.exe` or `lld-link.exe` will honour the environment; variable `LIB` which is a path delimiter (`;`) set of paths to consult for; the import libraries to use when linking the final target. The following environment variables will be consulted and used to form paths; to validate and load content from as appropriate:. - `VCToolsInstallDir`; - `VCINSTALLDIR`; - `Path`. 3. Consult `ISetupConfiguration` [Windows Only]. Assuming that the toolchain is built with `USE_MSVC_SETUP_API` defined and; is running on Windows, the Visual Studio COM interface `ISetupConfiguration`; will be used to locate the installation of the MSVC toolset. 4. Fallback to the registry [DEPRECATED]. The registry information is used to help locate the installation as a final; fallback. This is only possible for pre-VS2017 installations and is; considered deprecated. Restrictions and Limitations compared to Clang; ----------------------------------------------. Strict Aliasing; ^^^^^^^^^^^^^^^. Strict aliasing (TBAA) is always off by default in clang-cl. Whereas in clang,; strict aliasing is turned on by default for all optimization levels. To enable LLVM optimizations based on strict aliasing rules (e.g., optimizations; based on type of expressions in C/C++), user will need to explicitly pass; `-fstrict-aliasing` to clang-cl.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:197104,Deployability,install,installation,197104,"insysroot:` is not specified, the `/vctoolsdir:` argument is consulted; as a location to identify where the Visual C++ Tools are located. If; `/vctoolsversion:` is specified, that version is preferred, otherwise, the; highest version detected is used. 2. Consult the environment. - `/external:[VARIABLE]`. This specifies a user identified environment variable which is treated as; a path delimiter (`;`) separated list of paths to map into `-imsvc`; arguments which are treated as `-isystem`. - `INCLUDE` and `EXTERNAL_INCLUDE`. The path delimiter (`;`) separated list of paths will be mapped to; `-imsvc` arguments which are treated as `-isystem`. - `LIB` (indirectly). The linker `link.exe` or `lld-link.exe` will honour the environment; variable `LIB` which is a path delimiter (`;`) set of paths to consult for; the import libraries to use when linking the final target. The following environment variables will be consulted and used to form paths; to validate and load content from as appropriate:. - `VCToolsInstallDir`; - `VCINSTALLDIR`; - `Path`. 3. Consult `ISetupConfiguration` [Windows Only]. Assuming that the toolchain is built with `USE_MSVC_SETUP_API` defined and; is running on Windows, the Visual Studio COM interface `ISetupConfiguration`; will be used to locate the installation of the MSVC toolset. 4. Fallback to the registry [DEPRECATED]. The registry information is used to help locate the installation as a final; fallback. This is only possible for pre-VS2017 installations and is; considered deprecated. Restrictions and Limitations compared to Clang; ----------------------------------------------. Strict Aliasing; ^^^^^^^^^^^^^^^. Strict aliasing (TBAA) is always off by default in clang-cl. Whereas in clang,; strict aliasing is turned on by default for all optimization levels. To enable LLVM optimizations based on strict aliasing rules (e.g., optimizations; based on type of expressions in C/C++), user will need to explicitly pass; `-fstrict-aliasing` to clang-cl.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:197176,Deployability,install,installations,197176,"insysroot:` is not specified, the `/vctoolsdir:` argument is consulted; as a location to identify where the Visual C++ Tools are located. If; `/vctoolsversion:` is specified, that version is preferred, otherwise, the; highest version detected is used. 2. Consult the environment. - `/external:[VARIABLE]`. This specifies a user identified environment variable which is treated as; a path delimiter (`;`) separated list of paths to map into `-imsvc`; arguments which are treated as `-isystem`. - `INCLUDE` and `EXTERNAL_INCLUDE`. The path delimiter (`;`) separated list of paths will be mapped to; `-imsvc` arguments which are treated as `-isystem`. - `LIB` (indirectly). The linker `link.exe` or `lld-link.exe` will honour the environment; variable `LIB` which is a path delimiter (`;`) set of paths to consult for; the import libraries to use when linking the final target. The following environment variables will be consulted and used to form paths; to validate and load content from as appropriate:. - `VCToolsInstallDir`; - `VCINSTALLDIR`; - `Path`. 3. Consult `ISetupConfiguration` [Windows Only]. Assuming that the toolchain is built with `USE_MSVC_SETUP_API` defined and; is running on Windows, the Visual Studio COM interface `ISetupConfiguration`; will be used to locate the installation of the MSVC toolset. 4. Fallback to the registry [DEPRECATED]. The registry information is used to help locate the installation as a final; fallback. This is only possible for pre-VS2017 installations and is; considered deprecated. Restrictions and Limitations compared to Clang; ----------------------------------------------. Strict Aliasing; ^^^^^^^^^^^^^^^. Strict aliasing (TBAA) is always off by default in clang-cl. Whereas in clang,; strict aliasing is turned on by default for all optimization levels. To enable LLVM optimizations based on strict aliasing rules (e.g., optimizations; based on type of expressions in C/C++), user will need to explicitly pass; `-fstrict-aliasing` to clang-cl.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:7672,Energy Efficiency,green,green,7672," When this is disabled, Clang will not print the ""test.c:28:8: ""; part. .. _opt_fcaret-diagnostics:. .. option:: -f[no-]caret-diagnostics. Print source line and ranges from source code in diagnostic.; This option, which defaults to on, controls whether or not Clang; prints the source line, source ranges, and caret when emitting a; diagnostic. For example, when this is enabled, Clang will print; something like:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. .. option:: -f[no-]color-diagnostics. This option, which defaults to on when a color-capable terminal is; detected, controls whether or not Clang prints diagnostics in color. When this option is enabled, Clang will use colors to highlight; specific parts of the diagnostic, e.g.,. .. nasty hack to not lose our dignity. .. raw:: html. <pre>; <b><span style=""color:black"">test.c:28:8: <span style=""color:magenta"">warning</span>: extra tokens at end of #endif directive [-Wextra-tokens]</span></b>; #endif bad; <span style=""color:green"">^</span>; <span style=""color:green"">//</span>; </pre>. When this is disabled, Clang will just print:. ::. test.c:2:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. If the ``NO_COLOR`` environment variable is defined and not empty; (regardless of value), color diagnostics are disabled. If ``NO_COLOR`` is; defined and ``-fcolor-diagnostics`` is passed on the command line, Clang; will honor the command line argument. .. option:: -fansi-escape-codes. Controls whether ANSI escape codes are used instead of the Windows Console; API to output colored diagnostics. This option is only used on Windows and; defaults to off. .. option:: -fdiagnostics-format=clang/msvc/vi. Changes diagnostic output format to better match IDEs and command line tools. This option controls the output format of the filename, line number,; and column printed in diagnostic messages. The options, and their; affect on formatting a si",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:7708,Energy Efficiency,green,green,7708," When this is disabled, Clang will not print the ""test.c:28:8: ""; part. .. _opt_fcaret-diagnostics:. .. option:: -f[no-]caret-diagnostics. Print source line and ranges from source code in diagnostic.; This option, which defaults to on, controls whether or not Clang; prints the source line, source ranges, and caret when emitting a; diagnostic. For example, when this is enabled, Clang will print; something like:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. .. option:: -f[no-]color-diagnostics. This option, which defaults to on when a color-capable terminal is; detected, controls whether or not Clang prints diagnostics in color. When this option is enabled, Clang will use colors to highlight; specific parts of the diagnostic, e.g.,. .. nasty hack to not lose our dignity. .. raw:: html. <pre>; <b><span style=""color:black"">test.c:28:8: <span style=""color:magenta"">warning</span>: extra tokens at end of #endif directive [-Wextra-tokens]</span></b>; #endif bad; <span style=""color:green"">^</span>; <span style=""color:green"">//</span>; </pre>. When this is disabled, Clang will just print:. ::. test.c:2:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. If the ``NO_COLOR`` environment variable is defined and not empty; (regardless of value), color diagnostics are disabled. If ``NO_COLOR`` is; defined and ``-fcolor-diagnostics`` is passed on the command line, Clang; will honor the command line argument. .. option:: -fansi-escape-codes. Controls whether ANSI escape codes are used instead of the Windows Console; API to output colored diagnostics. This option is only used on Windows and; defaults to off. .. option:: -fdiagnostics-format=clang/msvc/vi. Changes diagnostic output format to better match IDEs and command line tools. This option controls the output format of the filename, line number,; and column printed in diagnostic messages. The options, and their; affect on formatting a si",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:22712,Energy Efficiency,reduce,reduced,22712,"------------------------------------. As unbelievable as it may sound, Clang does crash from time to time.; Generally, this only occurs to those living on the `bleeding; edge <https://llvm.org/releases/download.html#svn>`_. Clang goes to great; lengths to assist you in filing a bug report. Specifically, Clang; generates preprocessed source file(s) and associated run script(s) upon; a crash. These files should be attached to a bug report to ease; reproducibility of the failure. Below are the command line options to; control the crash diagnostics. .. option:: -fcrash-diagnostics=<val>. Valid values are:. * ``off`` (Disable auto-generation of preprocessed source files during a clang crash.); * ``compiler`` (Generate diagnostics for compiler crashes (default)); * ``all`` (Generate diagnostics for all tools which support it). .. option:: -fno-crash-diagnostics. Disable auto-generation of preprocessed source files during a clang crash. The -fno-crash-diagnostics flag can be helpful for speeding the process; of generating a delta reduced test case. .. option:: -fcrash-diagnostics-dir=<dir>. Specify where to write the crash diagnostics files; defaults to the; usual location for temporary files. .. envvar:: CLANG_CRASH_DIAGNOSTICS_DIR=<dir>. Like ``-fcrash-diagnostics-dir=<dir>``, specifies where to write the; crash diagnostics files, but with lower precedence than the option. Clang is also capable of generating preprocessed source file(s) and associated; run script(s) even without a crash. This is specially useful when trying to; generate a reproducer for warnings or errors while using modules. .. option:: -gen-reproducer. Generates preprocessed source files, a reproducer script and if relevant, a; cache containing: built module pcm's and all headers needed to rebuild the; same modules. .. _rpass:. Options to Emit Optimization Reports; ------------------------------------. Optimization reports trace, at a high-level, all the major decisions; done by compiler transformations",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:45793,Energy Efficiency,reduce,reduce,45793,"s. If you do use :option:`-Weverything` then we; advise that you address all new compiler diagnostics as they get added to Clang,; either by fixing everything they find or explicitly disabling that diagnostic; with its corresponding `Wno-` option. Note that when combined with :option:`-w` (which disables all warnings),; disabling all warnings wins. Controlling Static Analyzer Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. While not strictly part of the compiler, the diagnostics from Clang's; `static analyzer <https://clang-analyzer.llvm.org>`_ can also be; influenced by the user via changes to the source code. See the available; `annotations <https://clang-analyzer.llvm.org/annotations.html>`_ and the; analyzer's `FAQ; page <https://clang-analyzer.llvm.org/faq.html#exclude_code>`_ for more; information. .. _usersmanual-precompiled-headers:. Precompiled Headers; -------------------. `Precompiled headers <https://en.wikipedia.org/wiki/Precompiled_header>`_; are a general approach employed by many compilers to reduce compilation; time. The underlying motivation of the approach is that it is common for; the same (and often large) header files to be included by multiple; source files. Consequently, compile times can often be greatly improved; by caching some of the (redundant) work done by a compiler to process; headers. Precompiled header files, which represent one of many ways to; implement this optimization, are literally files that represent an; on-disk cache that contains the vital information necessary to reduce; some of the work needed to process a corresponding header file. While; details of precompiled headers vary between compilers, precompiled; headers have been shown to be highly effective at speeding up program; compilation on systems with very large system headers (e.g., macOS). Generating a PCH File; ^^^^^^^^^^^^^^^^^^^^^. To generate a PCH file using Clang, one invokes Clang with the; `-x <language>-header` option. This mirrors the interface in GCC",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:46302,Energy Efficiency,reduce,reduce,46302," diagnostics from Clang's; `static analyzer <https://clang-analyzer.llvm.org>`_ can also be; influenced by the user via changes to the source code. See the available; `annotations <https://clang-analyzer.llvm.org/annotations.html>`_ and the; analyzer's `FAQ; page <https://clang-analyzer.llvm.org/faq.html#exclude_code>`_ for more; information. .. _usersmanual-precompiled-headers:. Precompiled Headers; -------------------. `Precompiled headers <https://en.wikipedia.org/wiki/Precompiled_header>`_; are a general approach employed by many compilers to reduce compilation; time. The underlying motivation of the approach is that it is common for; the same (and often large) header files to be included by multiple; source files. Consequently, compile times can often be greatly improved; by caching some of the (redundant) work done by a compiler to process; headers. Precompiled header files, which represent one of many ways to; implement this optimization, are literally files that represent an; on-disk cache that contains the vital information necessary to reduce; some of the work needed to process a corresponding header file. While; details of precompiled headers vary between compilers, precompiled; headers have been shown to be highly effective at speeding up program; compilation on systems with very large system headers (e.g., macOS). Generating a PCH File; ^^^^^^^^^^^^^^^^^^^^^. To generate a PCH file using Clang, one invokes Clang with the; `-x <language>-header` option. This mirrors the interface in GCC; for generating PCH files:. .. code-block:: console. $ gcc -x c-header test.h -o test.h.gch; $ clang -x c-header test.h -o test.h.pch. Using a PCH File; ^^^^^^^^^^^^^^^^. A PCH file can then be used as a prefix header when a ``-include-pch``; option is passed to ``clang``:. .. code-block:: console. $ clang -include-pch test.h.pch test.c -o test. The ``clang`` driver will check if the PCH file ``test.h.pch`` is; available; if so, the contents of ``test.h`` (and the files i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:79094,Energy Efficiency,reduce,reduce,79094,"a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sanitizers.; See :doc:`SanitizerCoverage` for more details. .. option:: -f[no-]sanitize-address-outline-instrumentation. Controls how address sanitizer code is generated. If enabled will always use; a function call instead of inlining the code. Turning this option on could; reduce the binary size, but might result in a worse run-time performance. See :doc: `AddressSanitizer` for more details. .. option:: -f[no-]sanitize-stats. Enable simple statistics gathering for the enabled sanitizers.; See :doc:`SanitizerStats` for more details. .. option:: -fsanitize-undefined-trap-on-error. Deprecated alias for ``-fsanitize-trap=undefined``. .. option:: -fsanitize-cfi-cross-dso. Enable cross-DSO control flow integrity checks. This flag modifies; the behavior of sanitizers in the ``cfi`` group to allow checking; of cross-DSO virtual and indirect calls. .. option:: -fsanitize-cfi-icall-generalize-pointers. Generalize pointers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more details. .. option:: -fsanitize-cfi-icall-experimental-normalize-integers. Normalize integers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. S",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:83701,Energy Efficiency,efficient,efficient,83701,"hat an exception object's; destructor will not throw and code simplification is possible. .. option:: -ftrap-function=[name]. Instruct code generator to emit a function call to the specified; function name for ``__builtin_trap()``. LLVM code generator translates ``__builtin_trap()`` to a trap; instruction if it is supported by the target ISA. Otherwise, the; builtin is translated into a call to ``abort``. If this option is; set, then the code generator will always lower the builtin to a call; to the specified function regardless of whether the target ISA has a; trap instruction. This option is useful for environments (e.g.; deeply embedded) where a trap cannot be properly handled, or when; some custom behavior is desired. .. option:: -ftls-model=[model]. Select which TLS model to use. Valid values are: ``global-dynamic``, ``local-dynamic``,; ``initial-exec`` and ``local-exec``. The default value is; ``global-dynamic``. The compiler may use a different model if the; selected model is not supported by the target, or if a more; efficient model can be used. The TLS model can be overridden per; variable using the ``tls_model`` attribute. .. option:: -femulated-tls. Select emulated TLS model, which overrides all -ftls-model choices. In emulated TLS mode, all access to TLS variables are converted to; calls to __emutls_get_address in the runtime library. .. option:: -mhwdiv=[values]. Select the ARM modes (arm or thumb) that support hardware division; instructions. Valid values are: ``arm``, ``thumb`` and ``arm,thumb``.; This option is used to indicate which mode (arm or thumb) supports; hardware division instructions. This only applies to the ARM; architecture. .. option:: -m[no-]crc. Enable or disable CRC instructions. This option is used to indicate whether CRC instructions are to; be generated. This only applies to the ARM architecture. CRC instructions are enabled by default on ARMv8. .. option:: -mgeneral-regs-only. Generate code which only uses the general purpose regi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:92228,Energy Efficiency,efficient,efficient,92228,"r-use``. Similarly, sampling profiles; generated by external profilers must be converted and used with ``-fprofile-sample-use``; or ``-fauto-profile``. 2. Instrumentation profile data can be used for code coverage analysis and; optimization. 3. Sampling profiles can only be used for optimization. They cannot be used for; code coverage analysis. Although it would be technically possible to use; sampling profiles for code coverage, sample-based profiles are too; coarse-grained for code coverage purposes; it would yield poor results. 4. Sampling profiles must be generated by an external tool. The profile; generated by that tool must then be converted into a format that can be read; by LLVM. The section on sampling profilers describes one of the supported; sampling profile formats. Using Sampling Profilers; ^^^^^^^^^^^^^^^^^^^^^^^^. Sampling profilers are used to collect runtime information, such as; hardware counters, while your application executes. They are typically; very efficient and do not incur a large runtime overhead. The; sample data collected by the profiler can be used during compilation; to determine what the most executed areas of the code are. Using the data from a sample profiler requires some changes in the way; a program is built. Before the compiler can use profiling information,; the code needs to execute under the profiler. The following is the; usual build cycle when using sample profilers for optimization:. 1. Build the code with source line table information. You can use all the; usual build flags that you always build your application with. The only; requirement is that you add ``-gline-tables-only`` or ``-g`` to the; command line. This is important for the profiler to be able to map; instructions back to source line locations. .. code-block:: console. $ clang++ -O2 -gline-tables-only code.cc -o code. 2. Run the executable under a sampling profiler. The specific profiler; you use does not really matter, as long as its output can be converted; i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:96086,Energy Efficiency,efficient,efficient,96086,"files can have inaccuracies or missing block/; edge counters. The profile inference algorithm (profi) can be used to infer; missing blocks and edge counts, and improve the quality of profile data.; Enable it with ``-fsample-profile-use-profi``. .. code-block:: console. $ clang++ -O2 -gline-tables-only -fprofile-sample-use=code.prof \; -fsample-profile-use-profi code.cc -o code. Sample Profile Formats; """""""""""""""""""""""""""""""""""""""""""". Since external profilers generate profile data in a variety of custom formats,; the data generated by the profiler must be converted into a format that can be; read by the backend. LLVM supports three different sample profile formats:. 1. ASCII text. This is the easiest one to generate. The file is divided into; sections, which correspond to each of the functions with profile; information. The format is described below. It can also be generated from; the binary or gcov formats using the ``llvm-profdata`` tool. 2. Binary encoding. This uses a more efficient encoding that yields smaller; profile files. This is the format generated by the ``create_llvm_prof`` tool; in https://github.com/google/autofdo. 3. GCC encoding. This is based on the gcov format, which is accepted by GCC. It; is only interesting in environments where GCC and Clang co-exist. This; encoding is only generated by the ``create_gcov`` tool in; https://github.com/google/autofdo. It can be read by LLVM and; ``llvm-profdata``, but it cannot be generated by either. If you are using Linux Perf to generate sampling profiles, you can use the; conversion tool ``create_llvm_prof`` described in the previous section.; Otherwise, you will need to write a conversion tool that converts your; profiler's native format into one of these three. Sample Profile Text Format; """""""""""""""""""""""""""""""""""""""""""""""""""". This section describes the ASCII text format for sampling profiles. It is,; arguably, the easiest one to generate. If you are interested in generating any; of the other two, consult the ``ProfileData`` l",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:104815,Energy Efficiency,reduce,reduce,104815,"erate=`` or by setting the ``LLVM_PROFILE_FILE``; environment variable to specify an alternate file. If non-default file name; is specified by both the environment variable and the command line option,; the environment variable takes precedence. The file name pattern specified; can include different modifiers: ``%p``, ``%h``, ``%m``, ``%t``, and ``%c``. Any instance of ``%p`` in that file name will be replaced by the process; ID, so that you can easily distinguish the profile output from multiple; runs. .. code-block:: console. $ LLVM_PROFILE_FILE=""code-%p.profraw"" ./code. The modifier ``%h`` can be used in scenarios where the same instrumented; binary is run in multiple different host machines dumping profile data; to a shared network based storage. The ``%h`` specifier will be substituted; with the hostname so that profiles collected from different hosts do not; clobber each other. While the use of ``%p`` specifier can reduce the likelihood for the profiles; dumped from different processes to clobber each other, such clobbering can still; happen because of the ``pid`` re-use by the OS. Another side-effect of using; ``%p`` is that the storage requirement for raw profile data files is greatly; increased. To avoid issues like this, the ``%m`` specifier can used in the profile; name. When this specifier is used, the profiler runtime will substitute ``%m``; with a unique integer identifier associated with the instrumented binary. Additionally,; multiple raw profiles dumped from different processes that share a file system (can be; on different hosts) will be automatically merged by the profiler runtime during the; dumping. If the program links in multiple instrumented shared libraries, each library; will dump the profile data into its own profile data file (with its unique integer; id embedded in the profile name). Note that the merging enabled by ``%m`` is for raw; profile data generated by profiler runtime. The resulting merged ""raw"" profile data; file still needs to",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:116113,Energy Efficiency,reduce,reduce,116113,"ecific files in a build, without affecting the main compilation flags; used for the other files in the project. In these cases, you can use the flag ``-fno-profile-instr-generate`` (or; ``-fno-profile-generate``) to disable profile generation, and; ``-fno-profile-instr-use`` (or ``-fno-profile-use``) to disable profile use. Note that these flags should appear after the corresponding profile; flags to have an effect. .. note::. When none of the translation units inside a binary is instrumented, in the; case of Fuchsia the profile runtime will not be linked into the binary and; no profile will be produced, while on other platforms the profile runtime; will be linked and profile will be produced but there will not be any; counters. Instrumenting only selected files or functions; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Sometimes it's useful to only instrument certain files or functions. For; example in automated testing infrastructure, it may be desirable to only; instrument files or functions that were modified by a patch to reduce the; overhead of instrumenting a full system. This can be done using the ``-fprofile-list`` option. .. option:: -fprofile-list=<pathname>. This option can be used to apply profile instrumentation only to selected; files or functions. ``pathname`` should point to a file in the; :doc:`SanitizerSpecialCaseList` format which selects which files and; functions to instrument. .. code-block:: console. $ clang++ -O2 -fprofile-instr-generate -fprofile-list=fun.list code.cc -o code. The option can be specified multiple times to pass multiple files. .. code-block:: console. $ clang++ -O2 -fprofile-instr-generate -fcoverage-mapping -fprofile-list=fun.list -fprofile-list=code.list code.cc -o code. Supported sections are ``[clang]``, ``[llvm]``, and ``[csllvm]`` representing; clang PGO, IRPGO, and CSIRPGO, respectively. Supported prefixes are ``function``; and ``source``. Supported categories are ``allow``, ``skip``, and ``forbid``.; ``skip`` adds ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:124994,Energy Efficiency,reduce,reduce,124994," -fprofile-exclude-files=""^/usr/include/.*$"" \; -fprofile-filter-files=""^/usr/.*$"". In that case ``/usr/foo/oof.h`` is instrumented since it matches the filter regex and; doesn't match the exclude regex, but ``/usr/include/foo.h`` doesn't since it matches; the exclude regex. Controlling Debug Information; -----------------------------. Controlling Size of Debug Information; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Debug info kind generated by Clang can be set by one of the flags listed; below. If multiple flags are present, the last one is used. .. option:: -g0. Don't generate any debug info (default). .. option:: -gline-tables-only. Generate line number tables only. This kind of debug info allows to obtain stack traces with function names,; file names and line numbers (by such tools as ``gdb`` or ``addr2line``). It; doesn't contain any other data (e.g. description of local variables or; function parameters). .. option:: -fstandalone-debug. Clang supports a number of optimizations to reduce the size of debug; information in the binary. They work based on the assumption that; the debug type information can be spread out over multiple; compilation units. Specifically, the optimizations are:. - will not emit type definitions for types that are not needed by a; module and could be replaced with a forward declaration.; - will only emit type info for a dynamic C++ class in the module that; contains the vtable for the class.; - will only emit type info for a C++ class (non-trivial, non-aggregate); in the modules that contain a definition for one of its constructors.; - will only emit type definitions for types that are the subject of explicit; template instantiation declarations in the presence of an explicit; instantiation definition for the type. The **-fstandalone-debug** option turns off these optimizations.; This is useful when working with 3rd-party libraries that don't come; with debug information. Note that Clang will never emit type; information for types that are no",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:143100,Energy Efficiency,reduce,reduce,143100,"port of the embedded; profile.; From clang 9 a C++ mode is available for OpenCL (see; :ref:`C++ for OpenCL <cxx_for_opencl>`). OpenCL v3.0 support is complete but it remains in experimental state, see more; details about the experimental features and limitations in :doc:`OpenCLSupport`; page. OpenCL Specific Options; -----------------------. Most of the OpenCL build options from `the specification v2.0 section 5.8.4; <https://www.khronos.org/registry/cl/specs/opencl-2.0.pdf#200>`_ are available. Examples:. .. code-block:: console. $ clang -cl-std=CL2.0 -cl-single-precision-constant test.cl. Many flags used for the compilation for C sources can also be passed while; compiling for OpenCL, examples: ``-c``, ``-O<1-4|s>``, ``-o``, ``-emit-llvm``, etc. Some extra options are available to support special OpenCL features. .. option:: -cl-no-stdinc. Allows to disable all extra types and functions that are not native to the compiler.; This might reduce the compilation speed marginally but many declarations from the; OpenCL standard will not be accessible. For example, the following will fail to; compile. .. code-block:: console. $ echo ""bool is_wg_uniform(int i){return get_enqueued_local_size(i)==get_local_size(i);}"" > test.cl; $ clang -cl-std=CL2.0 -cl-no-stdinc test.cl; error: use of undeclared identifier 'get_enqueued_local_size'; error: use of undeclared identifier 'get_local_size'. More information about the standard types and functions is provided in :ref:`the; section on the OpenCL Header <opencl_header>`. .. _opencl_cl_ext:. .. option:: -cl-ext. Enables/Disables support of OpenCL extensions and optional features. All OpenCL; targets set a list of extensions that they support. Clang allows to amend this using; the ``-cl-ext`` flag with a comma-separated list of extensions prefixed with; ``'+'`` or ``'-'``. The syntax: ``-cl-ext=<(['-'|'+']<extension>[,])+>``, where; extensions can be either one of `the OpenCL published extensions; <https://www.khronos.org/registry/Ope",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:166949,Energy Efficiency,consumption,consumption,166949,"o; be present in the ``PATH`` environment variable. Clang uses ``llvm-spirv``; with `the widely adopted assembly syntax package; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator/#build-with-spirv-tools>`_. `The versioning; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator/releases>`_ of; ``llvm-spirv`` is aligned with Clang major releases. The same applies to the; main development branch. It is therefore important to ensure the ``llvm-spirv``; version is in alignment with the Clang version. For troubleshooting purposes; ``llvm-spirv`` can be `tested in isolation; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator#test-instructions>`_. Example usage for OpenCL kernel compilation:. .. code-block:: console. $ clang --target=spirv32 -c test.cl; $ clang --target=spirv64 -c test.cl. Both invocations of Clang will result in the generation of a SPIR-V binary file; `test.o` for 32 bit and 64 bit respectively. This file can be imported; by an OpenCL driver that support SPIR-V consumption or it can be compiled; further by offline SPIR-V consumer tools. Converting to SPIR-V produced with the optimization levels other than `-O0` is; currently available as an experimental feature and it is not guaranteed to work; in all cases. Clang also supports integrated generation of SPIR-V without use of ``llvm-spirv``; tool as an experimental feature when ``-fintegrated-objemitter`` flag is passed in; the command line. .. code-block:: console. $ clang --target=spirv32 -fintegrated-objemitter -c test.cl. Note that only very basic functionality is supported at this point and therefore; it is not suitable for arbitrary use cases. This feature is only enabled when clang; build is configured with ``-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=SPIRV`` option. Linking is done using ``spirv-link`` from `the SPIRV-Tools project; <https://github.com/KhronosGroup/SPIRV-Tools#linker>`_. Similar to other external; linkers, Clang will expect ``spirv-link`` to be installed separately and to be; pre",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:181243,Energy Efficiency,reduce,reduce,181243,cross-dso; Disable control flow integrity (CFI) checks for cross-DSO calls.; -fno-sanitize-coverage=<value>; Disable specified features of coverage instrumentation for Sanitizers; -fno-sanitize-memory-track-origins; Disable origins tracking in MemorySanitizer; -fno-sanitize-memory-use-after-dtor; Disable use-after-destroy detection in MemorySanitizer; -fno-sanitize-recover=<value>; Disable recovery for specified sanitizers; -fno-sanitize-stats Disable sanitizer statistics gathering.; -fno-sanitize-thread-atomics; Disable atomic operations instrumentation in ThreadSanitizer; -fno-sanitize-thread-func-entry-exit; Disable function entry/exit instrumentation in ThreadSanitizer; -fno-sanitize-thread-memory-access; Disable memory access instrumentation in ThreadSanitizer; -fno-sanitize-trap=<value>; Disable trapping for specified sanitizers; -fno-standalone-debug Limit debug information produced to reduce size of debug binary; -fno-strict-aliasing Disable optimizations based on strict aliasing rules (default); -fobjc-runtime=<value> Specify the target Objective-C runtime kind and version; -fprofile-exclude-files=<value>; Instrument only functions from files where names don't match all the regexes separated by a semi-colon; -fprofile-filter-files=<value>; Instrument only functions from files where names match any regex separated by a semi-colon; -fprofile-generate=<dirname>; Generate instrumented code to collect execution counts into a raw profile file in the directory specified by the argument. The filename uses default_%m.profraw pattern; (overridden by LLVM_PROFILE_FILE env var); -fprofile-generate; Generate instrumented code to collect execution counts into default_%m.profraw file; (overridden by '=' form of option or LLVM_PROFILE_FILE env var); -fprofile-instr-generate=<file_name_pattern>; Generate instrumented code to collect execution counts into the file whose name pattern is specified as the argument; (overridden by LLVM_PROFILE_FILE env var); -fprofile-instr-gene,MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:187566,Energy Efficiency,reduce,reduces,187566," the command line, the ``/clang:``; arguments are treated as if they were passed at the end of the clang-cl command; line. The /Zc:dllexportInlines- Option; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This causes the class-level `dllexport` and `dllimport` attributes to not apply; to inline member functions, as they otherwise would. For example, in the code; below `S::foo()` would normally be defined and exported by the DLL, but when; using the ``/Zc:dllexportInlines-`` flag it is not:. .. code-block:: c. struct __declspec(dllexport) S {; void foo() {}; }. This has the benefit that the compiler doesn't need to emit a definition of; `S::foo()` in every translation unit where the declaration is included, as it; would otherwise do to ensure there's a definition in the DLL even if it's not; used there. If the declaration occurs in a header file that's widely used, this; can save significant compilation time and output size. It also reduces the; number of functions exported by the DLL similarly to what; ``-fvisibility-inlines-hidden`` does for shared objects on ELF and Mach-O.; Since the function declaration comes with an inline definition, users of the; library can use that definition directly instead of importing it from the DLL. Note that the Microsoft Visual C++ compiler does not support this option, and; if code in a DLL is compiled with ``/Zc:dllexportInlines-``, the code using the; DLL must be compiled in the same way so that it doesn't attempt to dllimport; the inline member functions. The reverse scenario should generally work though:; a DLL compiled without this flag (such as a system library compiled with Visual; C++) can be referenced from code compiled using the flag, meaning that the; referencing code will use the inline definitions instead of importing them from; the DLL. Also note that like when using ``-fvisibility-inlines-hidden``, the address of; `S::foo()` will be different inside and outside the DLL, breaking the C/C++; standard requirement that functions have ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:1660,Integrability,depend,depending,1660,"Clang as a compiler; for an end-user, documenting the supported features, command line; options, etc. If you are interested in using Clang to build a tool that; processes code, please see :doc:`InternalsManual`. If you are interested in the; `Clang Static Analyzer <https://clang-analyzer.llvm.org>`_, please see its web; page. Clang is one component in a complete toolchain for C family languages.; A separate document describes the other pieces necessary to; :doc:`assemble a complete toolchain <Toolchain>`. Clang is designed to support the C family of programming languages,; which includes :ref:`C <c>`, :ref:`Objective-C <objc>`, :ref:`C++ <cxx>`, and; :ref:`Objective-C++ <objcxx>` as well as many dialects of those. For; language-specific information, please see the corresponding language; specific section:. - :ref:`C Language <c>`: K&R C, ANSI C89, ISO C90, ISO C94 (C89+AMD1), ISO; C99 (+TC1, TC2, TC3).; - :ref:`Objective-C Language <objc>`: ObjC 1, ObjC 2, ObjC 2.1, plus; variants depending on base language.; - :ref:`C++ Language <cxx>`; - :ref:`Objective C++ Language <objcxx>`; - :ref:`OpenCL Kernel Language <opencl>`: OpenCL C 1.0, 1.1, 1.2, 2.0, 3.0,; and C++ for OpenCL 1.0 and 2021. In addition to these base languages and their dialects, Clang supports a; broad variety of language extensions, which are documented in the; corresponding language section. These extensions are provided to be; compatible with the GCC, Microsoft, and other popular compilers as well; as to improve functionality through Clang-specific features. The Clang; driver and language features are intentionally designed to be as; compatible with the GNU GCC compiler as reasonably possible, easing; migration from GCC to Clang. In most cases, code ""just works"".; Clang also provides an alternative driver, :ref:`clang-cl`, that is designed; to be compatible with the Visual C++ compiler, cl.exe. In addition to language specific features, Clang has a variety of; features that depend on what CPU architec",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:2638,Integrability,depend,depend,2638," ObjC 2.1, plus; variants depending on base language.; - :ref:`C++ Language <cxx>`; - :ref:`Objective C++ Language <objcxx>`; - :ref:`OpenCL Kernel Language <opencl>`: OpenCL C 1.0, 1.1, 1.2, 2.0, 3.0,; and C++ for OpenCL 1.0 and 2021. In addition to these base languages and their dialects, Clang supports a; broad variety of language extensions, which are documented in the; corresponding language section. These extensions are provided to be; compatible with the GCC, Microsoft, and other popular compilers as well; as to improve functionality through Clang-specific features. The Clang; driver and language features are intentionally designed to be as; compatible with the GNU GCC compiler as reasonably possible, easing; migration from GCC to Clang. In most cases, code ""just works"".; Clang also provides an alternative driver, :ref:`clang-cl`, that is designed; to be compatible with the Visual C++ compiler, cl.exe. In addition to language specific features, Clang has a variety of; features that depend on what CPU architecture or operating system is; being compiled for. Please see the :ref:`Target-Specific Features and; Limitations <target_features>` section for more details. The rest of the introduction introduces some basic :ref:`compiler; terminology <terminology>` that is used throughout this manual and; contains a basic :ref:`introduction to using Clang <basicusage>` as a; command line compiler. .. _terminology:. Terminology; -----------. Front end, parser, backend, preprocessor, undefined behavior,; diagnostic, optimizer. .. _basicusage:. Basic Usage; -----------. Intro to how to use a C compiler for newbies. compile + link compile then link debug info enabling optimizations; picking a language to use, defaults to C17 by default. Autosenses based; on extension. using a makefile. Command Line Options; ====================. This section is generally an index into other sections. It does not go; into depth on the ones that are covered by other sections. However, the; fir",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:8568,Integrability,message,messages,8568,"c:28:8: <span style=""color:magenta"">warning</span>: extra tokens at end of #endif directive [-Wextra-tokens]</span></b>; #endif bad; <span style=""color:green"">^</span>; <span style=""color:green"">//</span>; </pre>. When this is disabled, Clang will just print:. ::. test.c:2:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. If the ``NO_COLOR`` environment variable is defined and not empty; (regardless of value), color diagnostics are disabled. If ``NO_COLOR`` is; defined and ``-fcolor-diagnostics`` is passed on the command line, Clang; will honor the command line argument. .. option:: -fansi-escape-codes. Controls whether ANSI escape codes are used instead of the Windows Console; API to output colored diagnostics. This option is only used on Windows and; defaults to off. .. option:: -fdiagnostics-format=clang/msvc/vi. Changes diagnostic output format to better match IDEs and command line tools. This option controls the output format of the filename, line number,; and column printed in diagnostic messages. The options, and their; affect on formatting a simple conversion diagnostic, follow:. **clang** (default); ::. t.c:3:11: warning: conversion specifies type 'char *' but the argument has type 'int'. **msvc**; ::. t.c(3,11) : warning: conversion specifies type 'char *' but the argument has type 'int'. **vi**; ::. t.c +3:11: warning: conversion specifies type 'char *' but the argument has type 'int'. .. _opt_fdiagnostics-show-option:. .. option:: -f[no-]diagnostics-show-option. Enable ``[-Woption]`` information in diagnostic line. This option, which defaults to on, controls whether or not Clang; prints the associated :ref:`warning group <cl_diag_warning_groups>`; option name when outputting a warning diagnostic. For example, in; this output:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. Passing **-fno-diagnostics-show-option** will prevent Clang from; printing the [:option:`-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:15699,Integrability,message,message,15699,". .. option:: -fdiagnostics-hotness-threshold. Prevent optimization remarks from being output if they do not have at least; this hotness value. This option, which defaults to zero, controls the minimum hotness an; optimization remark would need in order to be output by Clang. This is; currently supported with optimization remarks (see :ref:`Options to Emit; Optimization Reports <rpass>`) when profile hotness information in; diagnostics is enabled (see; :ref:`-fdiagnostics-show-hotness <opt_fdiagnostics-show-hotness>`). .. _opt_fdiagnostics-fixit-info:. .. option:: -f[no-]diagnostics-fixit-info. Enable ""FixIt"" information in the diagnostics output. This option, which defaults to on, controls whether or not Clang; prints the information on how to fix a specific diagnostic; underneath it when it knows. For example, in this output:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. Passing **-fno-diagnostics-fixit-info** will prevent Clang from; printing the ""//"" line at the end of the message. This information; is useful for users who may not understand what is wrong, but can be; confusing for machine parsing. .. _opt_fdiagnostics-print-source-range-info:. .. option:: -fdiagnostics-print-source-range-info. Print machine parsable information about source ranges.; This option makes Clang print information about source ranges in a machine; parsable format after the file/line/column number information. The; information is a simple sequence of brace enclosed ranges, where each range; lists the start and end line/column locations. For example, in this output:. ::. exprs.c:47:15:{47:8-47:14}{47:17-47:24}: error: invalid operands to binary expression ('int *' and '_Complex float'); P = (P-42) + Gamma*4;; ~~~~~~ ^ ~~~~~~~. The {}'s are generated by -fdiagnostics-print-source-range-info. The printed column numbers count bytes from the beginning of the; line; take care if your source contains multibyte characters. .. option:: -f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:29121,Integrability,depend,dependency,29121," to multiple files with the same name created in different; directories, since the path is relative to a changing working directory. These environment variables are handy when you need to request the statistics; report without changing your build scripts or alter the existing set of compiler; options. Note that ``-fproc-stat-report`` take precedence over ``CC_PRINT_PROC_STAT``; and ``CC_PRINT_PROC_STAT_FILE``. .. code-block:: console. $ export CC_PRINT_PROC_STAT=1; $ export CC_PRINT_PROC_STAT_FILE=~/project-build-proc-stat.csv; $ make. Other Options; -------------; Clang options that don't fit neatly into other categories. .. option:: -fgnuc-version=. This flag controls the value of ``__GNUC__`` and related macros. This flag; does not enable or disable any GCC extensions implemented in Clang. Setting; the version to zero causes Clang to leave ``__GNUC__`` and other; GNU-namespaced macros, such as ``__GXX_WEAK__``, undefined. .. option:: -MV. When emitting a dependency file, use formatting conventions appropriate; for NMake or Jom. Ignored unless another option causes Clang to emit a; dependency file. When Clang emits a dependency file (e.g., you supplied the -M option); most filenames can be written to the file without any special formatting.; Different Make tools will treat different sets of characters as ""special""; and use different conventions for telling the Make tool that the character; is actually part of the filename. Normally Clang uses backslash to ""escape""; a special character, which is the convention used by GNU Make. The -MV; option tells Clang to put double-quotes around the entire filename, which; is the convention used by NMake and Jom. .. option:: -femit-dwarf-unwind=<value>. When to emit DWARF unwind (EH frame) info. This is a Mach-O-specific option. Valid values are:. * ``no-compact-unwind`` - Only emit DWARF unwind when compact unwind encodings; aren't available. This is the default for arm64.; * ``always`` - Always emit DWARF unwind regardless.; *",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:29250,Integrability,depend,dependency,29250,"e path is relative to a changing working directory. These environment variables are handy when you need to request the statistics; report without changing your build scripts or alter the existing set of compiler; options. Note that ``-fproc-stat-report`` take precedence over ``CC_PRINT_PROC_STAT``; and ``CC_PRINT_PROC_STAT_FILE``. .. code-block:: console. $ export CC_PRINT_PROC_STAT=1; $ export CC_PRINT_PROC_STAT_FILE=~/project-build-proc-stat.csv; $ make. Other Options; -------------; Clang options that don't fit neatly into other categories. .. option:: -fgnuc-version=. This flag controls the value of ``__GNUC__`` and related macros. This flag; does not enable or disable any GCC extensions implemented in Clang. Setting; the version to zero causes Clang to leave ``__GNUC__`` and other; GNU-namespaced macros, such as ``__GXX_WEAK__``, undefined. .. option:: -MV. When emitting a dependency file, use formatting conventions appropriate; for NMake or Jom. Ignored unless another option causes Clang to emit a; dependency file. When Clang emits a dependency file (e.g., you supplied the -M option); most filenames can be written to the file without any special formatting.; Different Make tools will treat different sets of characters as ""special""; and use different conventions for telling the Make tool that the character; is actually part of the filename. Normally Clang uses backslash to ""escape""; a special character, which is the convention used by GNU Make. The -MV; option tells Clang to put double-quotes around the entire filename, which; is the convention used by NMake and Jom. .. option:: -femit-dwarf-unwind=<value>. When to emit DWARF unwind (EH frame) info. This is a Mach-O-specific option. Valid values are:. * ``no-compact-unwind`` - Only emit DWARF unwind when compact unwind encodings; aren't available. This is the default for arm64.; * ``always`` - Always emit DWARF unwind regardless.; * ``default`` - Use the platform-specific default (``always`` for all; non-arm64-p",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:29286,Integrability,depend,dependency,29286,"se environment variables are handy when you need to request the statistics; report without changing your build scripts or alter the existing set of compiler; options. Note that ``-fproc-stat-report`` take precedence over ``CC_PRINT_PROC_STAT``; and ``CC_PRINT_PROC_STAT_FILE``. .. code-block:: console. $ export CC_PRINT_PROC_STAT=1; $ export CC_PRINT_PROC_STAT_FILE=~/project-build-proc-stat.csv; $ make. Other Options; -------------; Clang options that don't fit neatly into other categories. .. option:: -fgnuc-version=. This flag controls the value of ``__GNUC__`` and related macros. This flag; does not enable or disable any GCC extensions implemented in Clang. Setting; the version to zero causes Clang to leave ``__GNUC__`` and other; GNU-namespaced macros, such as ``__GXX_WEAK__``, undefined. .. option:: -MV. When emitting a dependency file, use formatting conventions appropriate; for NMake or Jom. Ignored unless another option causes Clang to emit a; dependency file. When Clang emits a dependency file (e.g., you supplied the -M option); most filenames can be written to the file without any special formatting.; Different Make tools will treat different sets of characters as ""special""; and use different conventions for telling the Make tool that the character; is actually part of the filename. Normally Clang uses backslash to ""escape""; a special character, which is the convention used by GNU Make. The -MV; option tells Clang to put double-quotes around the entire filename, which; is the convention used by NMake and Jom. .. option:: -femit-dwarf-unwind=<value>. When to emit DWARF unwind (EH frame) info. This is a Mach-O-specific option. Valid values are:. * ``no-compact-unwind`` - Only emit DWARF unwind when compact unwind encodings; aren't available. This is the default for arm64.; * ``always`` - Always emit DWARF unwind regardless.; * ``default`` - Use the platform-specific default (``always`` for all; non-arm64-platforms). ``no-compact-unwind`` is a performance optim",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:35921,Integrability,message,messages,35921,"s``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate paths relative to the configuration file, the ``<CFGDIR>`` token may; be used. This will expand to the absolute path of the directory containing the; configuration file. In cases where a configuration file is deployed alongside SDK contents, the; SDK directory can remain fully portable by using ``<CFGDIR>`` prefixed paths.; In this way, the user may only need to specify a root configuration file with; ``--config=`` to establish every aspect of the SDK with the compiler:. ::. --target=foo; -isystem <CFGDIR>/include; -L <CFGDIR>/lib; -T <CFGDIR>/ldscripts/link.ld. Language and Target-Independent Features; ========================================. Controlling Errors and Warnings; -------------------------------. Clang provides a number of ways to control which code constructs cause; it to emit errors and warning messages, and how they are displayed to; the console. Controlling How Clang Displays Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When Clang emits a diagnostic, it includes rich information in the; output, and gives you fine-grain control over which information is; printed. Clang has the ability to print this information, and these are; the options that control it:. #. A file/line/column indicator that shows exactly where the diagnostic; occurs in your code [:ref:`-fshow-column <opt_fshow-column>`,; :ref:`-fshow-source-location <opt_fshow-source-location>`].; #. A categorization of the diagnostic as a note, warning, error, or; fatal error.; #. A text string that describes what the problem is.; #. An option that indicates how to control the diagnostic (for; diagnostics that support it); [:ref:`-fdiagnostics-show-option <opt_fdiagnostics-show-option>`].; #. A :ref:`high-level category <diagnostics_categories>` for the diagnostic; for clients that want",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:40643,Integrability,message,messages,40643,"or only a single line; of code, after which the diagnostics return to whatever state had previously; existed. .. code-block:: c. #if foo; #endif foo // warning: extra tokens at end of #endif directive. #pragma clang diagnostic push; #pragma clang diagnostic ignored ""-Wextra-tokens"". #if foo; #endif foo // no warning. #pragma clang diagnostic pop. The push and pop pragmas will save and restore the full diagnostic state; of the compiler, regardless of how it was set. That means that it is; possible to use push and pop around GCC compatible diagnostics and Clang; will push and pop them appropriately, while GCC will ignore the pushes; and pops as unknown pragmas. It should be noted that while Clang; supports the GCC pragma, Clang and GCC do not support the exact same set; of warnings, so even when using GCC compatible #pragmas there is no; guarantee that they will have identical behaviour on both compilers. In addition to controlling warnings and errors generated by the compiler, it is; possible to generate custom warning and error messages through the following; pragmas:. .. code-block:: c. // The following will produce warning messages; #pragma message ""some diagnostic message""; #pragma GCC warning ""TODO: replace deprecated feature"". // The following will produce an error message; #pragma GCC error ""Not supported"". These pragmas operate similarly to the ``#warning`` and ``#error`` preprocessor; directives, except that they may also be embedded into preprocessor macros via; the C99 ``_Pragma`` operator, for example:. .. code-block:: c. #define STR(X) #X; #define DEFER(M,...) M(__VA_ARGS__); #define CUSTOM_ERROR(X) _Pragma(STR(GCC error(X "" at line "" DEFER(STR,__LINE__)))). CUSTOM_ERROR(""Feature not available"");. Controlling Diagnostics in System Headers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Warnings are suppressed when they occur in system headers. By default,; an included file is treated as a system header if it is found in an; include path specified by ``-isyste",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:40742,Integrability,message,messages,40742,"end of #endif directive. #pragma clang diagnostic push; #pragma clang diagnostic ignored ""-Wextra-tokens"". #if foo; #endif foo // no warning. #pragma clang diagnostic pop. The push and pop pragmas will save and restore the full diagnostic state; of the compiler, regardless of how it was set. That means that it is; possible to use push and pop around GCC compatible diagnostics and Clang; will push and pop them appropriately, while GCC will ignore the pushes; and pops as unknown pragmas. It should be noted that while Clang; supports the GCC pragma, Clang and GCC do not support the exact same set; of warnings, so even when using GCC compatible #pragmas there is no; guarantee that they will have identical behaviour on both compilers. In addition to controlling warnings and errors generated by the compiler, it is; possible to generate custom warning and error messages through the following; pragmas:. .. code-block:: c. // The following will produce warning messages; #pragma message ""some diagnostic message""; #pragma GCC warning ""TODO: replace deprecated feature"". // The following will produce an error message; #pragma GCC error ""Not supported"". These pragmas operate similarly to the ``#warning`` and ``#error`` preprocessor; directives, except that they may also be embedded into preprocessor macros via; the C99 ``_Pragma`` operator, for example:. .. code-block:: c. #define STR(X) #X; #define DEFER(M,...) M(__VA_ARGS__); #define CUSTOM_ERROR(X) _Pragma(STR(GCC error(X "" at line "" DEFER(STR,__LINE__)))). CUSTOM_ERROR(""Feature not available"");. Controlling Diagnostics in System Headers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Warnings are suppressed when they occur in system headers. By default,; an included file is treated as a system header if it is found in an; include path specified by ``-isystem``, but this can be overridden in; several ways. The ``system_header`` pragma can be used to mark the current file as; being a system header. No warnings will be produced from ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:40760,Integrability,message,message,40760,"end of #endif directive. #pragma clang diagnostic push; #pragma clang diagnostic ignored ""-Wextra-tokens"". #if foo; #endif foo // no warning. #pragma clang diagnostic pop. The push and pop pragmas will save and restore the full diagnostic state; of the compiler, regardless of how it was set. That means that it is; possible to use push and pop around GCC compatible diagnostics and Clang; will push and pop them appropriately, while GCC will ignore the pushes; and pops as unknown pragmas. It should be noted that while Clang; supports the GCC pragma, Clang and GCC do not support the exact same set; of warnings, so even when using GCC compatible #pragmas there is no; guarantee that they will have identical behaviour on both compilers. In addition to controlling warnings and errors generated by the compiler, it is; possible to generate custom warning and error messages through the following; pragmas:. .. code-block:: c. // The following will produce warning messages; #pragma message ""some diagnostic message""; #pragma GCC warning ""TODO: replace deprecated feature"". // The following will produce an error message; #pragma GCC error ""Not supported"". These pragmas operate similarly to the ``#warning`` and ``#error`` preprocessor; directives, except that they may also be embedded into preprocessor macros via; the C99 ``_Pragma`` operator, for example:. .. code-block:: c. #define STR(X) #X; #define DEFER(M,...) M(__VA_ARGS__); #define CUSTOM_ERROR(X) _Pragma(STR(GCC error(X "" at line "" DEFER(STR,__LINE__)))). CUSTOM_ERROR(""Feature not available"");. Controlling Diagnostics in System Headers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Warnings are suppressed when they occur in system headers. By default,; an included file is treated as a system header if it is found in an; include path specified by ``-isystem``, but this can be overridden in; several ways. The ``system_header`` pragma can be used to mark the current file as; being a system header. No warnings will be produced from ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:40785,Integrability,message,message,40785,"end of #endif directive. #pragma clang diagnostic push; #pragma clang diagnostic ignored ""-Wextra-tokens"". #if foo; #endif foo // no warning. #pragma clang diagnostic pop. The push and pop pragmas will save and restore the full diagnostic state; of the compiler, regardless of how it was set. That means that it is; possible to use push and pop around GCC compatible diagnostics and Clang; will push and pop them appropriately, while GCC will ignore the pushes; and pops as unknown pragmas. It should be noted that while Clang; supports the GCC pragma, Clang and GCC do not support the exact same set; of warnings, so even when using GCC compatible #pragmas there is no; guarantee that they will have identical behaviour on both compilers. In addition to controlling warnings and errors generated by the compiler, it is; possible to generate custom warning and error messages through the following; pragmas:. .. code-block:: c. // The following will produce warning messages; #pragma message ""some diagnostic message""; #pragma GCC warning ""TODO: replace deprecated feature"". // The following will produce an error message; #pragma GCC error ""Not supported"". These pragmas operate similarly to the ``#warning`` and ``#error`` preprocessor; directives, except that they may also be embedded into preprocessor macros via; the C99 ``_Pragma`` operator, for example:. .. code-block:: c. #define STR(X) #X; #define DEFER(M,...) M(__VA_ARGS__); #define CUSTOM_ERROR(X) _Pragma(STR(GCC error(X "" at line "" DEFER(STR,__LINE__)))). CUSTOM_ERROR(""Feature not available"");. Controlling Diagnostics in System Headers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Warnings are suppressed when they occur in system headers. By default,; an included file is treated as a system header if it is found in an; include path specified by ``-isystem``, but this can be overridden in; several ways. The ``system_header`` pragma can be used to mark the current file as; being a system header. No warnings will be produced from ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:40890,Integrability,message,message,40890," #endif foo // no warning. #pragma clang diagnostic pop. The push and pop pragmas will save and restore the full diagnostic state; of the compiler, regardless of how it was set. That means that it is; possible to use push and pop around GCC compatible diagnostics and Clang; will push and pop them appropriately, while GCC will ignore the pushes; and pops as unknown pragmas. It should be noted that while Clang; supports the GCC pragma, Clang and GCC do not support the exact same set; of warnings, so even when using GCC compatible #pragmas there is no; guarantee that they will have identical behaviour on both compilers. In addition to controlling warnings and errors generated by the compiler, it is; possible to generate custom warning and error messages through the following; pragmas:. .. code-block:: c. // The following will produce warning messages; #pragma message ""some diagnostic message""; #pragma GCC warning ""TODO: replace deprecated feature"". // The following will produce an error message; #pragma GCC error ""Not supported"". These pragmas operate similarly to the ``#warning`` and ``#error`` preprocessor; directives, except that they may also be embedded into preprocessor macros via; the C99 ``_Pragma`` operator, for example:. .. code-block:: c. #define STR(X) #X; #define DEFER(M,...) M(__VA_ARGS__); #define CUSTOM_ERROR(X) _Pragma(STR(GCC error(X "" at line "" DEFER(STR,__LINE__)))). CUSTOM_ERROR(""Feature not available"");. Controlling Diagnostics in System Headers; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Warnings are suppressed when they occur in system headers. By default,; an included file is treated as a system header if it is found in an; include path specified by ``-isystem``, but this can be overridden in; several ways. The ``system_header`` pragma can be used to mark the current file as; being a system header. No warnings will be produced from the location of; the pragma onwards within the same file. .. code-block:: c. #if foo; #endif foo // warning: extra ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:46747,Integrability,interface,interface,46747,"ch employed by many compilers to reduce compilation; time. The underlying motivation of the approach is that it is common for; the same (and often large) header files to be included by multiple; source files. Consequently, compile times can often be greatly improved; by caching some of the (redundant) work done by a compiler to process; headers. Precompiled header files, which represent one of many ways to; implement this optimization, are literally files that represent an; on-disk cache that contains the vital information necessary to reduce; some of the work needed to process a corresponding header file. While; details of precompiled headers vary between compilers, precompiled; headers have been shown to be highly effective at speeding up program; compilation on systems with very large system headers (e.g., macOS). Generating a PCH File; ^^^^^^^^^^^^^^^^^^^^^. To generate a PCH file using Clang, one invokes Clang with the; `-x <language>-header` option. This mirrors the interface in GCC; for generating PCH files:. .. code-block:: console. $ gcc -x c-header test.h -o test.h.gch; $ clang -x c-header test.h -o test.h.pch. Using a PCH File; ^^^^^^^^^^^^^^^^. A PCH file can then be used as a prefix header when a ``-include-pch``; option is passed to ``clang``:. .. code-block:: console. $ clang -include-pch test.h.pch test.c -o test. The ``clang`` driver will check if the PCH file ``test.h.pch`` is; available; if so, the contents of ``test.h`` (and the files it includes); will be processed from the PCH file. Otherwise, Clang will report an error. .. note::. Clang does *not* automatically use PCH files for headers that are directly; included within a source file or indirectly via :option:`-include`.; For example:. .. code-block:: console. $ clang -x c-header test.h -o test.h.pch; $ cat test.c; #include ""test.h""; $ clang test.c -o test. In this example, ``clang`` will not automatically use the PCH file for; ``test.h`` since ``test.h`` was included directly in the source f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:48686,Integrability,depend,depends,48686,"n the source file and not; specified on the command line using ``-include-pch``. Relocatable PCH Files; ^^^^^^^^^^^^^^^^^^^^^. It is sometimes necessary to build a precompiled header from headers; that are not yet in their final, installed locations. For example, one; might build a precompiled header within the build tree that is then; meant to be installed alongside the headers. Clang permits the creation; of ""relocatable"" precompiled headers, which are built with a given path; (into the build directory) and can later be used from an installed; location. To build a relocatable precompiled header, place your headers into a; subdirectory whose structure mimics the installed location. For example,; if you want to build a precompiled header for the header ``mylib.h``; that will be installed into ``/usr/include``, create a subdirectory; ``build/usr/include`` and place the header ``mylib.h`` into that; subdirectory. If ``mylib.h`` depends on other headers, then they can be; stored within ``build/usr/include`` in a way that mimics the installed; location. Building a relocatable precompiled header requires two additional; arguments. First, pass the ``--relocatable-pch`` flag to indicate that; the resulting PCH file should be relocatable. Second, pass; ``-isysroot /path/to/build``, which makes all includes for your library; relative to the build directory. For example:. .. code-block:: console. # clang -x c-header --relocatable-pch -isysroot /path/to/build /path/to/build/mylib.h mylib.h.pch. When loading the relocatable PCH file, the various headers used in the; PCH file are found from the system header root. For example, ``mylib.h``; can be found in ``/usr/include/mylib.h``. If the headers are installed; in some other system root, the ``-isysroot`` option can be used provide; a different system root from which the headers will be based. For; example, ``-isysroot /Developer/SDKs/MacOSX10.4u.sdk`` will look for; ``mylib.h`` in ``/Developer/SDKs/MacOSX10.4u.sdk/usr/include/myl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:50572,Integrability,contract,contract,50572,"`mylib.h`` in ``/Developer/SDKs/MacOSX10.4u.sdk/usr/include/mylib.h``. Relocatable precompiled headers are intended to be used in a limited; number of cases where the compilation environment is tightly controlled; and the precompiled header cannot be generated after headers have been; installed. .. _controlling-fp-behavior:. Controlling Floating Point Behavior; -----------------------------------. Clang provides a number of ways to control floating point behavior, including; with command line options and source pragmas. This section; describes the various floating point semantic modes and the corresponding options. .. csv-table:: Floating Point Semantic Modes; :header: ""Mode"", ""Values""; :widths: 15, 30, 30. ""ffp-exception-behavior"", ""{ignore, strict, maytrap}"",; ""fenv_access"", ""{off, on}"", ""(none)""; ""frounding-math"", ""{dynamic, tonearest, downward, upward, towardzero}""; ""ffp-contract"", ""{on, off, fast, fast-honor-pragmas}""; ""fdenormal-fp-math"", ""{IEEE, PreserveSign, PositiveZero}""; ""fdenormal-fp-math-fp32"", ""{IEEE, PreserveSign, PositiveZero}""; ""fmath-errno"", ""{on, off}""; ""fhonor-nans"", ""{on, off}""; ""fhonor-infinities"", ""{on, off}""; ""fsigned-zeros"", ""{on, off}""; ""freciprocal-math"", ""{on, off}""; ""allow_approximate_fns"", ""{on, off}""; ""fassociative-math"", ""{on, off}"". This table describes the option settings that correspond to the three; floating point semantic models: precise (the default), strict, and fast. .. csv-table:: Floating Point Models; :header: ""Mode"", ""Precise"", ""Strict"", ""Fast""; :widths: 25, 15, 15, 15. ""except_behavior"", ""ignore"", ""strict"", ""ignore""; ""fenv_access"", ""off"", ""on"", ""off""; ""rounding_mode"", ""tonearest"", ""dynamic"", ""tonearest""; ""contract"", ""on"", ""off"", ""fast""; ""denormal_fp_math"", ""IEEE"", ""IEEE"", ""IEEE""; ""denormal_fp32_math"", ""IEEE"",""IEEE"", ""IEEE""; ""support_math_errno"", ""on"", ""on"", ""off""; ""no_honor_nans"", ""off"", ""off"", ""on""; ""no_honor_infinities"", ""off"", ""off"", ""on""; ""no_signed_zeros"", ""off"", ""off"", ""on""; ""allow_reciprocal"", ""off"", ""off"", ""on""; ""a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:51362,Integrability,contract,contract,51362,"frounding-math"", ""{dynamic, tonearest, downward, upward, towardzero}""; ""ffp-contract"", ""{on, off, fast, fast-honor-pragmas}""; ""fdenormal-fp-math"", ""{IEEE, PreserveSign, PositiveZero}""; ""fdenormal-fp-math-fp32"", ""{IEEE, PreserveSign, PositiveZero}""; ""fmath-errno"", ""{on, off}""; ""fhonor-nans"", ""{on, off}""; ""fhonor-infinities"", ""{on, off}""; ""fsigned-zeros"", ""{on, off}""; ""freciprocal-math"", ""{on, off}""; ""allow_approximate_fns"", ""{on, off}""; ""fassociative-math"", ""{on, off}"". This table describes the option settings that correspond to the three; floating point semantic models: precise (the default), strict, and fast. .. csv-table:: Floating Point Models; :header: ""Mode"", ""Precise"", ""Strict"", ""Fast""; :widths: 25, 15, 15, 15. ""except_behavior"", ""ignore"", ""strict"", ""ignore""; ""fenv_access"", ""off"", ""on"", ""off""; ""rounding_mode"", ""tonearest"", ""dynamic"", ""tonearest""; ""contract"", ""on"", ""off"", ""fast""; ""denormal_fp_math"", ""IEEE"", ""IEEE"", ""IEEE""; ""denormal_fp32_math"", ""IEEE"",""IEEE"", ""IEEE""; ""support_math_errno"", ""on"", ""on"", ""off""; ""no_honor_nans"", ""off"", ""off"", ""on""; ""no_honor_infinities"", ""off"", ""off"", ""on""; ""no_signed_zeros"", ""off"", ""off"", ""on""; ""allow_reciprocal"", ""off"", ""off"", ""on""; ""allow_approximate_fns"", ""off"", ""off"", ""on""; ""allow_reassociation"", ""off"", ""off"", ""on"". .. option:: -ffast-math. Enable fast-math mode. This option lets the; compiler make aggressive, potentially-lossy assumptions about; floating-point math. These include:. * Floating-point math obeys regular algebraic rules for real numbers (e.g.; ``+`` and ``*`` are associative, ``x/y == x * (1/y)``, and; ``(a + b) * c == a * c + b * c``),; * Operands to floating-point operations are not equal to ``NaN`` and; ``Inf``, and; * ``+0`` and ``-0`` are interchangeable. ``-ffast-math`` also defines the ``__FAST_MATH__`` preprocessor; macro. Some math libraries recognize this macro and change their behavior.; With the exception of ``-ffp-contract=fast``, using any of the options; below to disable any of the individual optimi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:52408,Integrability,contract,contract,52408,"""IEEE""; ""support_math_errno"", ""on"", ""on"", ""off""; ""no_honor_nans"", ""off"", ""off"", ""on""; ""no_honor_infinities"", ""off"", ""off"", ""on""; ""no_signed_zeros"", ""off"", ""off"", ""on""; ""allow_reciprocal"", ""off"", ""off"", ""on""; ""allow_approximate_fns"", ""off"", ""off"", ""on""; ""allow_reassociation"", ""off"", ""off"", ""on"". .. option:: -ffast-math. Enable fast-math mode. This option lets the; compiler make aggressive, potentially-lossy assumptions about; floating-point math. These include:. * Floating-point math obeys regular algebraic rules for real numbers (e.g.; ``+`` and ``*`` are associative, ``x/y == x * (1/y)``, and; ``(a + b) * c == a * c + b * c``),; * Operands to floating-point operations are not equal to ``NaN`` and; ``Inf``, and; * ``+0`` and ``-0`` are interchangeable. ``-ffast-math`` also defines the ``__FAST_MATH__`` preprocessor; macro. Some math libraries recognize this macro and change their behavior.; With the exception of ``-ffp-contract=fast``, using any of the options; below to disable any of the individual optimizations in ``-ffast-math``; will cause ``__FAST_MATH__`` to no longer be set.; ``-ffast-math`` enables ``-fcx-limited-range``. This option implies:. * ``-fno-honor-infinities``. * ``-fno-honor-nans``. * ``-fapprox-func``. * ``-fno-math-errno``. * ``-ffinite-math-only``. * ``-fassociative-math``. * ``-freciprocal-math``. * ``-fno-signed-zeros``. * ``-fno-trapping-math``. * ``-fno-rounding-math``. * ``-ffp-contract=fast``. Note: ``-ffast-math`` causes ``crtfastmath.o`` to be linked with code. See; :ref:`crtfastmath.o` for more details. .. option:: -fno-fast-math. Disable fast-math mode. This options disables unsafe floating-point; optimizations by preventing the compiler from making any transformations that; could affect the results. This option implies:. * ``-fhonor-infinities``. * ``-fhonor-nans``. * ``-fno-approx-func``. * ``-fno-finite-math-only``. * ``-fno-associative-math``. * ``-fno-reciprocal-math``. * ``-fsigned-zeros``. * ``-ffp-contract=on``. Also, this op",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:52904,Integrability,contract,contract,52904,"ating-point math. These include:. * Floating-point math obeys regular algebraic rules for real numbers (e.g.; ``+`` and ``*`` are associative, ``x/y == x * (1/y)``, and; ``(a + b) * c == a * c + b * c``),; * Operands to floating-point operations are not equal to ``NaN`` and; ``Inf``, and; * ``+0`` and ``-0`` are interchangeable. ``-ffast-math`` also defines the ``__FAST_MATH__`` preprocessor; macro. Some math libraries recognize this macro and change their behavior.; With the exception of ``-ffp-contract=fast``, using any of the options; below to disable any of the individual optimizations in ``-ffast-math``; will cause ``__FAST_MATH__`` to no longer be set.; ``-ffast-math`` enables ``-fcx-limited-range``. This option implies:. * ``-fno-honor-infinities``. * ``-fno-honor-nans``. * ``-fapprox-func``. * ``-fno-math-errno``. * ``-ffinite-math-only``. * ``-fassociative-math``. * ``-freciprocal-math``. * ``-fno-signed-zeros``. * ``-fno-trapping-math``. * ``-fno-rounding-math``. * ``-ffp-contract=fast``. Note: ``-ffast-math`` causes ``crtfastmath.o`` to be linked with code. See; :ref:`crtfastmath.o` for more details. .. option:: -fno-fast-math. Disable fast-math mode. This options disables unsafe floating-point; optimizations by preventing the compiler from making any transformations that; could affect the results. This option implies:. * ``-fhonor-infinities``. * ``-fhonor-nans``. * ``-fno-approx-func``. * ``-fno-finite-math-only``. * ``-fno-associative-math``. * ``-fno-reciprocal-math``. * ``-fsigned-zeros``. * ``-ffp-contract=on``. Also, this option resets following options to their target-dependent defaults. * ``-f[no-]math-errno``; * ``-fdenormal-fp-math=<value>``. There is ambiguity about how ``-ffp-contract``, ``-ffast-math``,; and ``-fno-fast-math`` behave when combined. To keep the value of; ``-ffp-contract`` consistent, we define this set of rules:. * ``-ffast-math`` sets ``ffp-contract`` to ``fast``. * ``-fno-fast-math`` sets ``-ffp-contract`` to ``on`` (``fast",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:53447,Integrability,contract,contract,53447,"; below to disable any of the individual optimizations in ``-ffast-math``; will cause ``__FAST_MATH__`` to no longer be set.; ``-ffast-math`` enables ``-fcx-limited-range``. This option implies:. * ``-fno-honor-infinities``. * ``-fno-honor-nans``. * ``-fapprox-func``. * ``-fno-math-errno``. * ``-ffinite-math-only``. * ``-fassociative-math``. * ``-freciprocal-math``. * ``-fno-signed-zeros``. * ``-fno-trapping-math``. * ``-fno-rounding-math``. * ``-ffp-contract=fast``. Note: ``-ffast-math`` causes ``crtfastmath.o`` to be linked with code. See; :ref:`crtfastmath.o` for more details. .. option:: -fno-fast-math. Disable fast-math mode. This options disables unsafe floating-point; optimizations by preventing the compiler from making any transformations that; could affect the results. This option implies:. * ``-fhonor-infinities``. * ``-fhonor-nans``. * ``-fno-approx-func``. * ``-fno-finite-math-only``. * ``-fno-associative-math``. * ``-fno-reciprocal-math``. * ``-fsigned-zeros``. * ``-ffp-contract=on``. Also, this option resets following options to their target-dependent defaults. * ``-f[no-]math-errno``; * ``-fdenormal-fp-math=<value>``. There is ambiguity about how ``-ffp-contract``, ``-ffast-math``,; and ``-fno-fast-math`` behave when combined. To keep the value of; ``-ffp-contract`` consistent, we define this set of rules:. * ``-ffast-math`` sets ``ffp-contract`` to ``fast``. * ``-fno-fast-math`` sets ``-ffp-contract`` to ``on`` (``fast`` for CUDA and; HIP). * If ``-ffast-math`` and ``-ffp-contract`` are both seen, but; ``-ffast-math`` is not followed by ``-fno-fast-math``, ``ffp-contract``; will be given the value of whichever option was last seen. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has been seen at least; once, the ``ffp-contract`` will get the value of the last seen value of; ``-ffp-contract``. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has not been seen, the; ``-ffp-contract`` setting is determined by the default value of; ``-ffp-cont",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:53521,Integrability,depend,dependent,53521,"ons in ``-ffast-math``; will cause ``__FAST_MATH__`` to no longer be set.; ``-ffast-math`` enables ``-fcx-limited-range``. This option implies:. * ``-fno-honor-infinities``. * ``-fno-honor-nans``. * ``-fapprox-func``. * ``-fno-math-errno``. * ``-ffinite-math-only``. * ``-fassociative-math``. * ``-freciprocal-math``. * ``-fno-signed-zeros``. * ``-fno-trapping-math``. * ``-fno-rounding-math``. * ``-ffp-contract=fast``. Note: ``-ffast-math`` causes ``crtfastmath.o`` to be linked with code. See; :ref:`crtfastmath.o` for more details. .. option:: -fno-fast-math. Disable fast-math mode. This options disables unsafe floating-point; optimizations by preventing the compiler from making any transformations that; could affect the results. This option implies:. * ``-fhonor-infinities``. * ``-fhonor-nans``. * ``-fno-approx-func``. * ``-fno-finite-math-only``. * ``-fno-associative-math``. * ``-fno-reciprocal-math``. * ``-fsigned-zeros``. * ``-ffp-contract=on``. Also, this option resets following options to their target-dependent defaults. * ``-f[no-]math-errno``; * ``-fdenormal-fp-math=<value>``. There is ambiguity about how ``-ffp-contract``, ``-ffast-math``,; and ``-fno-fast-math`` behave when combined. To keep the value of; ``-ffp-contract`` consistent, we define this set of rules:. * ``-ffast-math`` sets ``ffp-contract`` to ``fast``. * ``-fno-fast-math`` sets ``-ffp-contract`` to ``on`` (``fast`` for CUDA and; HIP). * If ``-ffast-math`` and ``-ffp-contract`` are both seen, but; ``-ffast-math`` is not followed by ``-fno-fast-math``, ``ffp-contract``; will be given the value of whichever option was last seen. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has been seen at least; once, the ``ffp-contract`` will get the value of the last seen value of; ``-ffp-contract``. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has not been seen, the; ``-ffp-contract`` setting is determined by the default value of; ``-ffp-contract``. Note: ``-fno-fast-math`` implies ``-fdenorma",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:53636,Integrability,contract,contract,53636,"honor-infinities``. * ``-fno-honor-nans``. * ``-fapprox-func``. * ``-fno-math-errno``. * ``-ffinite-math-only``. * ``-fassociative-math``. * ``-freciprocal-math``. * ``-fno-signed-zeros``. * ``-fno-trapping-math``. * ``-fno-rounding-math``. * ``-ffp-contract=fast``. Note: ``-ffast-math`` causes ``crtfastmath.o`` to be linked with code. See; :ref:`crtfastmath.o` for more details. .. option:: -fno-fast-math. Disable fast-math mode. This options disables unsafe floating-point; optimizations by preventing the compiler from making any transformations that; could affect the results. This option implies:. * ``-fhonor-infinities``. * ``-fhonor-nans``. * ``-fno-approx-func``. * ``-fno-finite-math-only``. * ``-fno-associative-math``. * ``-fno-reciprocal-math``. * ``-fsigned-zeros``. * ``-ffp-contract=on``. Also, this option resets following options to their target-dependent defaults. * ``-f[no-]math-errno``; * ``-fdenormal-fp-math=<value>``. There is ambiguity about how ``-ffp-contract``, ``-ffast-math``,; and ``-fno-fast-math`` behave when combined. To keep the value of; ``-ffp-contract`` consistent, we define this set of rules:. * ``-ffast-math`` sets ``ffp-contract`` to ``fast``. * ``-fno-fast-math`` sets ``-ffp-contract`` to ``on`` (``fast`` for CUDA and; HIP). * If ``-ffast-math`` and ``-ffp-contract`` are both seen, but; ``-ffast-math`` is not followed by ``-fno-fast-math``, ``ffp-contract``; will be given the value of whichever option was last seen. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has been seen at least; once, the ``ffp-contract`` will get the value of the last seen value of; ``-ffp-contract``. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has not been seen, the; ``-ffp-contract`` setting is determined by the default value of; ``-ffp-contract``. Note: ``-fno-fast-math`` implies ``-fdenormal-fp-math=ieee``.; ``-fno-fast-math`` causes ``crtfastmath.o`` to not be linked with code. .. option:: -fdenormal-fp-math=<value>. Select which denormal n",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:53740,Integrability,contract,contract,53740,"te-math-only``. * ``-fassociative-math``. * ``-freciprocal-math``. * ``-fno-signed-zeros``. * ``-fno-trapping-math``. * ``-fno-rounding-math``. * ``-ffp-contract=fast``. Note: ``-ffast-math`` causes ``crtfastmath.o`` to be linked with code. See; :ref:`crtfastmath.o` for more details. .. option:: -fno-fast-math. Disable fast-math mode. This options disables unsafe floating-point; optimizations by preventing the compiler from making any transformations that; could affect the results. This option implies:. * ``-fhonor-infinities``. * ``-fhonor-nans``. * ``-fno-approx-func``. * ``-fno-finite-math-only``. * ``-fno-associative-math``. * ``-fno-reciprocal-math``. * ``-fsigned-zeros``. * ``-ffp-contract=on``. Also, this option resets following options to their target-dependent defaults. * ``-f[no-]math-errno``; * ``-fdenormal-fp-math=<value>``. There is ambiguity about how ``-ffp-contract``, ``-ffast-math``,; and ``-fno-fast-math`` behave when combined. To keep the value of; ``-ffp-contract`` consistent, we define this set of rules:. * ``-ffast-math`` sets ``ffp-contract`` to ``fast``. * ``-fno-fast-math`` sets ``-ffp-contract`` to ``on`` (``fast`` for CUDA and; HIP). * If ``-ffast-math`` and ``-ffp-contract`` are both seen, but; ``-ffast-math`` is not followed by ``-fno-fast-math``, ``ffp-contract``; will be given the value of whichever option was last seen. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has been seen at least; once, the ``ffp-contract`` will get the value of the last seen value of; ``-ffp-contract``. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has not been seen, the; ``-ffp-contract`` setting is determined by the default value of; ``-ffp-contract``. Note: ``-fno-fast-math`` implies ``-fdenormal-fp-math=ieee``.; ``-fno-fast-math`` causes ``crtfastmath.o`` to not be linked with code. .. option:: -fdenormal-fp-math=<value>. Select which denormal numbers the code is permitted to require. Valid values are:. * ``ieee`` - IEEE 754 denormal numbe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:53822,Integrability,contract,contract,53822,"* ``-fno-signed-zeros``. * ``-fno-trapping-math``. * ``-fno-rounding-math``. * ``-ffp-contract=fast``. Note: ``-ffast-math`` causes ``crtfastmath.o`` to be linked with code. See; :ref:`crtfastmath.o` for more details. .. option:: -fno-fast-math. Disable fast-math mode. This options disables unsafe floating-point; optimizations by preventing the compiler from making any transformations that; could affect the results. This option implies:. * ``-fhonor-infinities``. * ``-fhonor-nans``. * ``-fno-approx-func``. * ``-fno-finite-math-only``. * ``-fno-associative-math``. * ``-fno-reciprocal-math``. * ``-fsigned-zeros``. * ``-ffp-contract=on``. Also, this option resets following options to their target-dependent defaults. * ``-f[no-]math-errno``; * ``-fdenormal-fp-math=<value>``. There is ambiguity about how ``-ffp-contract``, ``-ffast-math``,; and ``-fno-fast-math`` behave when combined. To keep the value of; ``-ffp-contract`` consistent, we define this set of rules:. * ``-ffast-math`` sets ``ffp-contract`` to ``fast``. * ``-fno-fast-math`` sets ``-ffp-contract`` to ``on`` (``fast`` for CUDA and; HIP). * If ``-ffast-math`` and ``-ffp-contract`` are both seen, but; ``-ffast-math`` is not followed by ``-fno-fast-math``, ``ffp-contract``; will be given the value of whichever option was last seen. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has been seen at least; once, the ``ffp-contract`` will get the value of the last seen value of; ``-ffp-contract``. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has not been seen, the; ``-ffp-contract`` setting is determined by the default value of; ``-ffp-contract``. Note: ``-fno-fast-math`` implies ``-fdenormal-fp-math=ieee``.; ``-fno-fast-math`` causes ``crtfastmath.o`` to not be linked with code. .. option:: -fdenormal-fp-math=<value>. Select which denormal numbers the code is permitted to require. Valid values are:. * ``ieee`` - IEEE 754 denormal numbers; * ``preserve-sign`` - the sign of a flushed-to-zero number is pr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:53879,Integrability,contract,contract,53879,"math``. * ``-ffp-contract=fast``. Note: ``-ffast-math`` causes ``crtfastmath.o`` to be linked with code. See; :ref:`crtfastmath.o` for more details. .. option:: -fno-fast-math. Disable fast-math mode. This options disables unsafe floating-point; optimizations by preventing the compiler from making any transformations that; could affect the results. This option implies:. * ``-fhonor-infinities``. * ``-fhonor-nans``. * ``-fno-approx-func``. * ``-fno-finite-math-only``. * ``-fno-associative-math``. * ``-fno-reciprocal-math``. * ``-fsigned-zeros``. * ``-ffp-contract=on``. Also, this option resets following options to their target-dependent defaults. * ``-f[no-]math-errno``; * ``-fdenormal-fp-math=<value>``. There is ambiguity about how ``-ffp-contract``, ``-ffast-math``,; and ``-fno-fast-math`` behave when combined. To keep the value of; ``-ffp-contract`` consistent, we define this set of rules:. * ``-ffast-math`` sets ``ffp-contract`` to ``fast``. * ``-fno-fast-math`` sets ``-ffp-contract`` to ``on`` (``fast`` for CUDA and; HIP). * If ``-ffast-math`` and ``-ffp-contract`` are both seen, but; ``-ffast-math`` is not followed by ``-fno-fast-math``, ``ffp-contract``; will be given the value of whichever option was last seen. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has been seen at least; once, the ``ffp-contract`` will get the value of the last seen value of; ``-ffp-contract``. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has not been seen, the; ``-ffp-contract`` setting is determined by the default value of; ``-ffp-contract``. Note: ``-fno-fast-math`` implies ``-fdenormal-fp-math=ieee``.; ``-fno-fast-math`` causes ``crtfastmath.o`` to not be linked with code. .. option:: -fdenormal-fp-math=<value>. Select which denormal numbers the code is permitted to require. Valid values are:. * ``ieee`` - IEEE 754 denormal numbers; * ``preserve-sign`` - the sign of a flushed-to-zero number is preserved in the sign of 0; * ``positive-zero`` - denormals are flushe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:53962,Integrability,contract,contract,53962," details. .. option:: -fno-fast-math. Disable fast-math mode. This options disables unsafe floating-point; optimizations by preventing the compiler from making any transformations that; could affect the results. This option implies:. * ``-fhonor-infinities``. * ``-fhonor-nans``. * ``-fno-approx-func``. * ``-fno-finite-math-only``. * ``-fno-associative-math``. * ``-fno-reciprocal-math``. * ``-fsigned-zeros``. * ``-ffp-contract=on``. Also, this option resets following options to their target-dependent defaults. * ``-f[no-]math-errno``; * ``-fdenormal-fp-math=<value>``. There is ambiguity about how ``-ffp-contract``, ``-ffast-math``,; and ``-fno-fast-math`` behave when combined. To keep the value of; ``-ffp-contract`` consistent, we define this set of rules:. * ``-ffast-math`` sets ``ffp-contract`` to ``fast``. * ``-fno-fast-math`` sets ``-ffp-contract`` to ``on`` (``fast`` for CUDA and; HIP). * If ``-ffast-math`` and ``-ffp-contract`` are both seen, but; ``-ffast-math`` is not followed by ``-fno-fast-math``, ``ffp-contract``; will be given the value of whichever option was last seen. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has been seen at least; once, the ``ffp-contract`` will get the value of the last seen value of; ``-ffp-contract``. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has not been seen, the; ``-ffp-contract`` setting is determined by the default value of; ``-ffp-contract``. Note: ``-fno-fast-math`` implies ``-fdenormal-fp-math=ieee``.; ``-fno-fast-math`` causes ``crtfastmath.o`` to not be linked with code. .. option:: -fdenormal-fp-math=<value>. Select which denormal numbers the code is permitted to require. Valid values are:. * ``ieee`` - IEEE 754 denormal numbers; * ``preserve-sign`` - the sign of a flushed-to-zero number is preserved in the sign of 0; * ``positive-zero`` - denormals are flushed to positive zero. The default value depends on the target. For most targets, defaults to; ``ieee``. .. option:: -f[no-]strict-float-cast-o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:54054,Integrability,contract,contract,54054," details. .. option:: -fno-fast-math. Disable fast-math mode. This options disables unsafe floating-point; optimizations by preventing the compiler from making any transformations that; could affect the results. This option implies:. * ``-fhonor-infinities``. * ``-fhonor-nans``. * ``-fno-approx-func``. * ``-fno-finite-math-only``. * ``-fno-associative-math``. * ``-fno-reciprocal-math``. * ``-fsigned-zeros``. * ``-ffp-contract=on``. Also, this option resets following options to their target-dependent defaults. * ``-f[no-]math-errno``; * ``-fdenormal-fp-math=<value>``. There is ambiguity about how ``-ffp-contract``, ``-ffast-math``,; and ``-fno-fast-math`` behave when combined. To keep the value of; ``-ffp-contract`` consistent, we define this set of rules:. * ``-ffast-math`` sets ``ffp-contract`` to ``fast``. * ``-fno-fast-math`` sets ``-ffp-contract`` to ``on`` (``fast`` for CUDA and; HIP). * If ``-ffast-math`` and ``-ffp-contract`` are both seen, but; ``-ffast-math`` is not followed by ``-fno-fast-math``, ``ffp-contract``; will be given the value of whichever option was last seen. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has been seen at least; once, the ``ffp-contract`` will get the value of the last seen value of; ``-ffp-contract``. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has not been seen, the; ``-ffp-contract`` setting is determined by the default value of; ``-ffp-contract``. Note: ``-fno-fast-math`` implies ``-fdenormal-fp-math=ieee``.; ``-fno-fast-math`` causes ``crtfastmath.o`` to not be linked with code. .. option:: -fdenormal-fp-math=<value>. Select which denormal numbers the code is permitted to require. Valid values are:. * ``ieee`` - IEEE 754 denormal numbers; * ``preserve-sign`` - the sign of a flushed-to-zero number is preserved in the sign of 0; * ``positive-zero`` - denormals are flushed to positive zero. The default value depends on the target. For most targets, defaults to; ``ieee``. .. option:: -f[no-]strict-float-cast-o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:54168,Integrability,contract,contract,54168,"t; could affect the results. This option implies:. * ``-fhonor-infinities``. * ``-fhonor-nans``. * ``-fno-approx-func``. * ``-fno-finite-math-only``. * ``-fno-associative-math``. * ``-fno-reciprocal-math``. * ``-fsigned-zeros``. * ``-ffp-contract=on``. Also, this option resets following options to their target-dependent defaults. * ``-f[no-]math-errno``; * ``-fdenormal-fp-math=<value>``. There is ambiguity about how ``-ffp-contract``, ``-ffast-math``,; and ``-fno-fast-math`` behave when combined. To keep the value of; ``-ffp-contract`` consistent, we define this set of rules:. * ``-ffast-math`` sets ``ffp-contract`` to ``fast``. * ``-fno-fast-math`` sets ``-ffp-contract`` to ``on`` (``fast`` for CUDA and; HIP). * If ``-ffast-math`` and ``-ffp-contract`` are both seen, but; ``-ffast-math`` is not followed by ``-fno-fast-math``, ``ffp-contract``; will be given the value of whichever option was last seen. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has been seen at least; once, the ``ffp-contract`` will get the value of the last seen value of; ``-ffp-contract``. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has not been seen, the; ``-ffp-contract`` setting is determined by the default value of; ``-ffp-contract``. Note: ``-fno-fast-math`` implies ``-fdenormal-fp-math=ieee``.; ``-fno-fast-math`` causes ``crtfastmath.o`` to not be linked with code. .. option:: -fdenormal-fp-math=<value>. Select which denormal numbers the code is permitted to require. Valid values are:. * ``ieee`` - IEEE 754 denormal numbers; * ``preserve-sign`` - the sign of a flushed-to-zero number is preserved in the sign of 0; * ``positive-zero`` - denormals are flushed to positive zero. The default value depends on the target. For most targets, defaults to; ``ieee``. .. option:: -f[no-]strict-float-cast-overflow. When a floating-point value is not representable in a destination integer; type, the code has undefined behavior according to the language standard.; By default, Clang will ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:54219,Integrability,contract,contract,54219,"t; could affect the results. This option implies:. * ``-fhonor-infinities``. * ``-fhonor-nans``. * ``-fno-approx-func``. * ``-fno-finite-math-only``. * ``-fno-associative-math``. * ``-fno-reciprocal-math``. * ``-fsigned-zeros``. * ``-ffp-contract=on``. Also, this option resets following options to their target-dependent defaults. * ``-f[no-]math-errno``; * ``-fdenormal-fp-math=<value>``. There is ambiguity about how ``-ffp-contract``, ``-ffast-math``,; and ``-fno-fast-math`` behave when combined. To keep the value of; ``-ffp-contract`` consistent, we define this set of rules:. * ``-ffast-math`` sets ``ffp-contract`` to ``fast``. * ``-fno-fast-math`` sets ``-ffp-contract`` to ``on`` (``fast`` for CUDA and; HIP). * If ``-ffast-math`` and ``-ffp-contract`` are both seen, but; ``-ffast-math`` is not followed by ``-fno-fast-math``, ``ffp-contract``; will be given the value of whichever option was last seen. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has been seen at least; once, the ``ffp-contract`` will get the value of the last seen value of; ``-ffp-contract``. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has not been seen, the; ``-ffp-contract`` setting is determined by the default value of; ``-ffp-contract``. Note: ``-fno-fast-math`` implies ``-fdenormal-fp-math=ieee``.; ``-fno-fast-math`` causes ``crtfastmath.o`` to not be linked with code. .. option:: -fdenormal-fp-math=<value>. Select which denormal numbers the code is permitted to require. Valid values are:. * ``ieee`` - IEEE 754 denormal numbers; * ``preserve-sign`` - the sign of a flushed-to-zero number is preserved in the sign of 0; * ``positive-zero`` - denormals are flushed to positive zero. The default value depends on the target. For most targets, defaults to; ``ieee``. .. option:: -f[no-]strict-float-cast-overflow. When a floating-point value is not representable in a destination integer; type, the code has undefined behavior according to the language standard.; By default, Clang will ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:54283,Integrability,contract,contract,54283,"t; could affect the results. This option implies:. * ``-fhonor-infinities``. * ``-fhonor-nans``. * ``-fno-approx-func``. * ``-fno-finite-math-only``. * ``-fno-associative-math``. * ``-fno-reciprocal-math``. * ``-fsigned-zeros``. * ``-ffp-contract=on``. Also, this option resets following options to their target-dependent defaults. * ``-f[no-]math-errno``; * ``-fdenormal-fp-math=<value>``. There is ambiguity about how ``-ffp-contract``, ``-ffast-math``,; and ``-fno-fast-math`` behave when combined. To keep the value of; ``-ffp-contract`` consistent, we define this set of rules:. * ``-ffast-math`` sets ``ffp-contract`` to ``fast``. * ``-fno-fast-math`` sets ``-ffp-contract`` to ``on`` (``fast`` for CUDA and; HIP). * If ``-ffast-math`` and ``-ffp-contract`` are both seen, but; ``-ffast-math`` is not followed by ``-fno-fast-math``, ``ffp-contract``; will be given the value of whichever option was last seen. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has been seen at least; once, the ``ffp-contract`` will get the value of the last seen value of; ``-ffp-contract``. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has not been seen, the; ``-ffp-contract`` setting is determined by the default value of; ``-ffp-contract``. Note: ``-fno-fast-math`` implies ``-fdenormal-fp-math=ieee``.; ``-fno-fast-math`` causes ``crtfastmath.o`` to not be linked with code. .. option:: -fdenormal-fp-math=<value>. Select which denormal numbers the code is permitted to require. Valid values are:. * ``ieee`` - IEEE 754 denormal numbers; * ``preserve-sign`` - the sign of a flushed-to-zero number is preserved in the sign of 0; * ``positive-zero`` - denormals are flushed to positive zero. The default value depends on the target. For most targets, defaults to; ``ieee``. .. option:: -f[no-]strict-float-cast-overflow. When a floating-point value is not representable in a destination integer; type, the code has undefined behavior according to the language standard.; By default, Clang will ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:54338,Integrability,contract,contract,54338,"tive-math``. * ``-fno-reciprocal-math``. * ``-fsigned-zeros``. * ``-ffp-contract=on``. Also, this option resets following options to their target-dependent defaults. * ``-f[no-]math-errno``; * ``-fdenormal-fp-math=<value>``. There is ambiguity about how ``-ffp-contract``, ``-ffast-math``,; and ``-fno-fast-math`` behave when combined. To keep the value of; ``-ffp-contract`` consistent, we define this set of rules:. * ``-ffast-math`` sets ``ffp-contract`` to ``fast``. * ``-fno-fast-math`` sets ``-ffp-contract`` to ``on`` (``fast`` for CUDA and; HIP). * If ``-ffast-math`` and ``-ffp-contract`` are both seen, but; ``-ffast-math`` is not followed by ``-fno-fast-math``, ``ffp-contract``; will be given the value of whichever option was last seen. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has been seen at least; once, the ``ffp-contract`` will get the value of the last seen value of; ``-ffp-contract``. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has not been seen, the; ``-ffp-contract`` setting is determined by the default value of; ``-ffp-contract``. Note: ``-fno-fast-math`` implies ``-fdenormal-fp-math=ieee``.; ``-fno-fast-math`` causes ``crtfastmath.o`` to not be linked with code. .. option:: -fdenormal-fp-math=<value>. Select which denormal numbers the code is permitted to require. Valid values are:. * ``ieee`` - IEEE 754 denormal numbers; * ``preserve-sign`` - the sign of a flushed-to-zero number is preserved in the sign of 0; * ``positive-zero`` - denormals are flushed to positive zero. The default value depends on the target. For most targets, defaults to; ``ieee``. .. option:: -f[no-]strict-float-cast-overflow. When a floating-point value is not representable in a destination integer; type, the code has undefined behavior according to the language standard.; By default, Clang will not guarantee any particular result in that case.; With the 'no-strict' option, Clang will saturate towards the smallest and; largest representable integer values ins",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:54380,Integrability,contract,contract,54380,"tive-math``. * ``-fno-reciprocal-math``. * ``-fsigned-zeros``. * ``-ffp-contract=on``. Also, this option resets following options to their target-dependent defaults. * ``-f[no-]math-errno``; * ``-fdenormal-fp-math=<value>``. There is ambiguity about how ``-ffp-contract``, ``-ffast-math``,; and ``-fno-fast-math`` behave when combined. To keep the value of; ``-ffp-contract`` consistent, we define this set of rules:. * ``-ffast-math`` sets ``ffp-contract`` to ``fast``. * ``-fno-fast-math`` sets ``-ffp-contract`` to ``on`` (``fast`` for CUDA and; HIP). * If ``-ffast-math`` and ``-ffp-contract`` are both seen, but; ``-ffast-math`` is not followed by ``-fno-fast-math``, ``ffp-contract``; will be given the value of whichever option was last seen. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has been seen at least; once, the ``ffp-contract`` will get the value of the last seen value of; ``-ffp-contract``. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has not been seen, the; ``-ffp-contract`` setting is determined by the default value of; ``-ffp-contract``. Note: ``-fno-fast-math`` implies ``-fdenormal-fp-math=ieee``.; ``-fno-fast-math`` causes ``crtfastmath.o`` to not be linked with code. .. option:: -fdenormal-fp-math=<value>. Select which denormal numbers the code is permitted to require. Valid values are:. * ``ieee`` - IEEE 754 denormal numbers; * ``preserve-sign`` - the sign of a flushed-to-zero number is preserved in the sign of 0; * ``positive-zero`` - denormals are flushed to positive zero. The default value depends on the target. For most targets, defaults to; ``ieee``. .. option:: -f[no-]strict-float-cast-overflow. When a floating-point value is not representable in a destination integer; type, the code has undefined behavior according to the language standard.; By default, Clang will not guarantee any particular result in that case.; With the 'no-strict' option, Clang will saturate towards the smallest and; largest representable integer values ins",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:54445,Integrability,contract,contract,54445,"tive-math``. * ``-fno-reciprocal-math``. * ``-fsigned-zeros``. * ``-ffp-contract=on``. Also, this option resets following options to their target-dependent defaults. * ``-f[no-]math-errno``; * ``-fdenormal-fp-math=<value>``. There is ambiguity about how ``-ffp-contract``, ``-ffast-math``,; and ``-fno-fast-math`` behave when combined. To keep the value of; ``-ffp-contract`` consistent, we define this set of rules:. * ``-ffast-math`` sets ``ffp-contract`` to ``fast``. * ``-fno-fast-math`` sets ``-ffp-contract`` to ``on`` (``fast`` for CUDA and; HIP). * If ``-ffast-math`` and ``-ffp-contract`` are both seen, but; ``-ffast-math`` is not followed by ``-fno-fast-math``, ``ffp-contract``; will be given the value of whichever option was last seen. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has been seen at least; once, the ``ffp-contract`` will get the value of the last seen value of; ``-ffp-contract``. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has not been seen, the; ``-ffp-contract`` setting is determined by the default value of; ``-ffp-contract``. Note: ``-fno-fast-math`` implies ``-fdenormal-fp-math=ieee``.; ``-fno-fast-math`` causes ``crtfastmath.o`` to not be linked with code. .. option:: -fdenormal-fp-math=<value>. Select which denormal numbers the code is permitted to require. Valid values are:. * ``ieee`` - IEEE 754 denormal numbers; * ``preserve-sign`` - the sign of a flushed-to-zero number is preserved in the sign of 0; * ``positive-zero`` - denormals are flushed to positive zero. The default value depends on the target. For most targets, defaults to; ``ieee``. .. option:: -f[no-]strict-float-cast-overflow. When a floating-point value is not representable in a destination integer; type, the code has undefined behavior according to the language standard.; By default, Clang will not guarantee any particular result in that case.; With the 'no-strict' option, Clang will saturate towards the smallest and; largest representable integer values ins",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:54925,Integrability,depend,depends,54925,"P). * If ``-ffast-math`` and ``-ffp-contract`` are both seen, but; ``-ffast-math`` is not followed by ``-fno-fast-math``, ``ffp-contract``; will be given the value of whichever option was last seen. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has been seen at least; once, the ``ffp-contract`` will get the value of the last seen value of; ``-ffp-contract``. * If ``-fno-fast-math`` is seen and ``-ffp-contract`` has not been seen, the; ``-ffp-contract`` setting is determined by the default value of; ``-ffp-contract``. Note: ``-fno-fast-math`` implies ``-fdenormal-fp-math=ieee``.; ``-fno-fast-math`` causes ``crtfastmath.o`` to not be linked with code. .. option:: -fdenormal-fp-math=<value>. Select which denormal numbers the code is permitted to require. Valid values are:. * ``ieee`` - IEEE 754 denormal numbers; * ``preserve-sign`` - the sign of a flushed-to-zero number is preserved in the sign of 0; * ``positive-zero`` - denormals are flushed to positive zero. The default value depends on the target. For most targets, defaults to; ``ieee``. .. option:: -f[no-]strict-float-cast-overflow. When a floating-point value is not representable in a destination integer; type, the code has undefined behavior according to the language standard.; By default, Clang will not guarantee any particular result in that case.; With the 'no-strict' option, Clang will saturate towards the smallest and; largest representable integer values instead. NaNs will be converted to zero.; Defaults to ``-fstrict-float-cast-overflow``. .. option:: -f[no-]math-errno. Require math functions to indicate errors by setting errno.; The default varies by ToolChain. ``-fno-math-errno`` allows optimizations; that might cause standard C math functions to not set ``errno``.; For example, on some systems, the math function ``sqrt`` is specified; as setting ``errno`` to ``EDOM`` when the input is negative. On these; systems, the compiler cannot normally optimize a call to ``sqrt`` to use; inline code (e.g. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:56711,Integrability,contract,contract,56711,"e systems, the math function ``sqrt`` is specified; as setting ``errno`` to ``EDOM`` when the input is negative. On these; systems, the compiler cannot normally optimize a call to ``sqrt`` to use; inline code (e.g. the x86 ``sqrtsd`` instruction) without additional; checking to ensure that ``errno`` is set appropriately.; ``-fno-math-errno`` permits these transformations. On some targets, math library functions never set ``errno``, and so; ``-fno-math-errno`` is the default. This includes most BSD-derived; systems, including Darwin. .. option:: -f[no-]trapping-math. Control floating point exception behavior. ``-fno-trapping-math`` allows optimizations that assume that floating point operations cannot generate traps such as divide-by-zero, overflow and underflow. - The option ``-ftrapping-math`` behaves identically to ``-ffp-exception-behavior=strict``.; - The option ``-fno-trapping-math`` behaves identically to ``-ffp-exception-behavior=ignore``. This is the default. .. option:: -ffp-contract=<value>. Specify when the compiler is permitted to form fused floating-point; operations, such as fused multiply-add (FMA). Fused operations are; permitted to produce more precise results than performing the same; operations separately. The C standard permits intermediate floating-point results within an; expression to be computed with more precision than their type would; normally allow. This permits operation fusing, and Clang takes advantage; of this by default. This behavior can be controlled with the ``FP_CONTRACT``; and ``clang fp contract`` pragmas. Please refer to the pragma documentation; for a description of how the pragmas interact with this option. Valid values are:. * ``fast`` (fuse across statements disregarding pragmas, default for CUDA); * ``on`` (fuse in the same statement unless dictated by pragmas, default for languages other than CUDA/HIP); * ``off`` (never fuse); * ``fast-honor-pragmas`` (fuse across statements unless dictated by pragmas, default for HIP). ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:57263,Integrability,contract,contract,57263,"cluding Darwin. .. option:: -f[no-]trapping-math. Control floating point exception behavior. ``-fno-trapping-math`` allows optimizations that assume that floating point operations cannot generate traps such as divide-by-zero, overflow and underflow. - The option ``-ftrapping-math`` behaves identically to ``-ffp-exception-behavior=strict``.; - The option ``-fno-trapping-math`` behaves identically to ``-ffp-exception-behavior=ignore``. This is the default. .. option:: -ffp-contract=<value>. Specify when the compiler is permitted to form fused floating-point; operations, such as fused multiply-add (FMA). Fused operations are; permitted to produce more precise results than performing the same; operations separately. The C standard permits intermediate floating-point results within an; expression to be computed with more precision than their type would; normally allow. This permits operation fusing, and Clang takes advantage; of this by default. This behavior can be controlled with the ``FP_CONTRACT``; and ``clang fp contract`` pragmas. Please refer to the pragma documentation; for a description of how the pragmas interact with this option. Valid values are:. * ``fast`` (fuse across statements disregarding pragmas, default for CUDA); * ``on`` (fuse in the same statement unless dictated by pragmas, default for languages other than CUDA/HIP); * ``off`` (never fuse); * ``fast-honor-pragmas`` (fuse across statements unless dictated by pragmas, default for HIP). .. option:: -f[no-]honor-infinities. Allow floating-point optimizations that assume arguments and results are; not +-Inf.; Defaults to ``-fhonor-infinities``. If both ``-fno-honor-infinities`` and ``-fno-honor-nans`` are used,; has the same effect as specifying ``-ffinite-math-only``. .. option:: -f[no-]honor-nans. Allow floating-point optimizations that assume arguments and results are; not NaNs.; Defaults to ``-fhonor-nans``. If both ``-fno-honor-infinities`` and ``-fno-honor-nans`` are used,; has the same effect as ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:59467,Integrability,contract,contract,59467,"ximately equivalent set of instructions; or alternative math function calls. For example, a ``pow(x, 0.25)``; may be replaced with ``sqrt(sqrt(x))``, despite being an inexact result; in cases where ``x`` is ``-0.0`` or ``-inf``.; Defaults to ``-fno-approx-func``. .. option:: -f[no-]signed-zeros. Allow optimizations that ignore the sign of floating point zeros.; Defaults to ``-fsigned-zeros``. .. option:: -f[no-]associative-math. Allow floating point operations to be reassociated.; Defaults to ``-fno-associative-math``. .. option:: -f[no-]reciprocal-math. Allow division operations to be transformed into multiplication by a; reciprocal. This can be significantly faster than an ordinary division; but can also have significantly less precision. Defaults to; ``-fno-reciprocal-math``. .. option:: -f[no-]unsafe-math-optimizations. Allow unsafe floating-point optimizations.; ``-funsafe-math-optimizations`` also implies:. * ``-fapprox-func``; * ``-fassociative-math``; * ``-freciprocal-math``; * ``-fno-signed-zeros``; * ``-fno-trapping-math``; * ``-ffp-contract=fast``. ``-fno-unsafe-math-optimizations`` implies:. * ``-fno-approx-func``; * ``-fno-associative-math``; * ``-fno-reciprocal-math``; * ``-fsigned-zeros``; * ``-ftrapping-math``; * ``-ffp-contract=on``; * ``-fdenormal-fp-math=ieee``. There is ambiguity about how ``-ffp-contract``,; ``-funsafe-math-optimizations``, and ``-fno-unsafe-math-optimizations``; behave when combined. Explanation in :option:`-fno-fast-math` also applies; to these options. Defaults to ``-fno-unsafe-math-optimizations``. .. option:: -f[no-]finite-math-only. Allow floating-point optimizations that assume arguments and results are; not NaNs or +-Inf. ``-ffinite-math-only`` defines the; ``__FINITE_MATH_ONLY__`` preprocessor macro.; ``-ffinite-math-only`` implies:. * ``-fno-honor-infinities``; * ``-fno-honor-nans``. ``-ffno-inite-math-only`` implies:. * ``-fhonor-infinities``; * ``-fhonor-nans``. Defaults to ``-fno-finite-math-only``. .. option:: -f[no",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:59664,Integrability,contract,contract,59664,"0.0`` or ``-inf``.; Defaults to ``-fno-approx-func``. .. option:: -f[no-]signed-zeros. Allow optimizations that ignore the sign of floating point zeros.; Defaults to ``-fsigned-zeros``. .. option:: -f[no-]associative-math. Allow floating point operations to be reassociated.; Defaults to ``-fno-associative-math``. .. option:: -f[no-]reciprocal-math. Allow division operations to be transformed into multiplication by a; reciprocal. This can be significantly faster than an ordinary division; but can also have significantly less precision. Defaults to; ``-fno-reciprocal-math``. .. option:: -f[no-]unsafe-math-optimizations. Allow unsafe floating-point optimizations.; ``-funsafe-math-optimizations`` also implies:. * ``-fapprox-func``; * ``-fassociative-math``; * ``-freciprocal-math``; * ``-fno-signed-zeros``; * ``-fno-trapping-math``; * ``-ffp-contract=fast``. ``-fno-unsafe-math-optimizations`` implies:. * ``-fno-approx-func``; * ``-fno-associative-math``; * ``-fno-reciprocal-math``; * ``-fsigned-zeros``; * ``-ftrapping-math``; * ``-ffp-contract=on``; * ``-fdenormal-fp-math=ieee``. There is ambiguity about how ``-ffp-contract``,; ``-funsafe-math-optimizations``, and ``-fno-unsafe-math-optimizations``; behave when combined. Explanation in :option:`-fno-fast-math` also applies; to these options. Defaults to ``-fno-unsafe-math-optimizations``. .. option:: -f[no-]finite-math-only. Allow floating-point optimizations that assume arguments and results are; not NaNs or +-Inf. ``-ffinite-math-only`` defines the; ``__FINITE_MATH_ONLY__`` preprocessor macro.; ``-ffinite-math-only`` implies:. * ``-fno-honor-infinities``; * ``-fno-honor-nans``. ``-ffno-inite-math-only`` implies:. * ``-fhonor-infinities``; * ``-fhonor-nans``. Defaults to ``-fno-finite-math-only``. .. option:: -f[no-]rounding-math. Force floating-point operations to honor the dynamically-set rounding mode by default. The result of a floating-point operation often cannot be exactly represented in the result type and theref",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:59746,Integrability,contract,contract,59746,"to ``-fsigned-zeros``. .. option:: -f[no-]associative-math. Allow floating point operations to be reassociated.; Defaults to ``-fno-associative-math``. .. option:: -f[no-]reciprocal-math. Allow division operations to be transformed into multiplication by a; reciprocal. This can be significantly faster than an ordinary division; but can also have significantly less precision. Defaults to; ``-fno-reciprocal-math``. .. option:: -f[no-]unsafe-math-optimizations. Allow unsafe floating-point optimizations.; ``-funsafe-math-optimizations`` also implies:. * ``-fapprox-func``; * ``-fassociative-math``; * ``-freciprocal-math``; * ``-fno-signed-zeros``; * ``-fno-trapping-math``; * ``-ffp-contract=fast``. ``-fno-unsafe-math-optimizations`` implies:. * ``-fno-approx-func``; * ``-fno-associative-math``; * ``-fno-reciprocal-math``; * ``-fsigned-zeros``; * ``-ftrapping-math``; * ``-ffp-contract=on``; * ``-fdenormal-fp-math=ieee``. There is ambiguity about how ``-ffp-contract``,; ``-funsafe-math-optimizations``, and ``-fno-unsafe-math-optimizations``; behave when combined. Explanation in :option:`-fno-fast-math` also applies; to these options. Defaults to ``-fno-unsafe-math-optimizations``. .. option:: -f[no-]finite-math-only. Allow floating-point optimizations that assume arguments and results are; not NaNs or +-Inf. ``-ffinite-math-only`` defines the; ``__FINITE_MATH_ONLY__`` preprocessor macro.; ``-ffinite-math-only`` implies:. * ``-fno-honor-infinities``; * ``-fno-honor-nans``. ``-ffno-inite-math-only`` implies:. * ``-fhonor-infinities``; * ``-fhonor-nans``. Defaults to ``-fno-finite-math-only``. .. option:: -f[no-]rounding-math. Force floating-point operations to honor the dynamically-set rounding mode by default. The result of a floating-point operation often cannot be exactly represented in the result type and therefore must be rounded. IEEE 754 describes different rounding modes that control how to perform this rounding, not all of which are supported by all implementations.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:60793,Integrability,interface,interfaces,60793,"plies; to these options. Defaults to ``-fno-unsafe-math-optimizations``. .. option:: -f[no-]finite-math-only. Allow floating-point optimizations that assume arguments and results are; not NaNs or +-Inf. ``-ffinite-math-only`` defines the; ``__FINITE_MATH_ONLY__`` preprocessor macro.; ``-ffinite-math-only`` implies:. * ``-fno-honor-infinities``; * ``-fno-honor-nans``. ``-ffno-inite-math-only`` implies:. * ``-fhonor-infinities``; * ``-fhonor-nans``. Defaults to ``-fno-finite-math-only``. .. option:: -f[no-]rounding-math. Force floating-point operations to honor the dynamically-set rounding mode by default. The result of a floating-point operation often cannot be exactly represented in the result type and therefore must be rounded. IEEE 754 describes different rounding modes that control how to perform this rounding, not all of which are supported by all implementations. C provides interfaces (``fesetround`` and ``fesetenv``) for dynamically controlling the rounding mode, and while it also recommends certain conventions for changing the rounding mode, these conventions are not typically enforced in the ABI. Since the rounding mode changes the numerical result of operations, the compiler must understand something about it in order to optimize floating point operations. Note that floating-point operations performed as part of constant initialization are formally performed prior to the start of the program and are therefore not subject to the current rounding mode. This includes the initialization of global variables and local ``static`` variables. Floating-point operations in these contexts will be rounded using ``FE_TONEAREST``. - The option ``-fno-rounding-math`` allows the compiler to assume that the rounding mode is set to ``FE_TONEAREST``. This is the default.; - The option ``-frounding-math`` forces the compiler to honor the dynamically-set rounding mode. This prevents optimizations which might affect results if the rounding mode changes or is different from the def",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:62435,Integrability,contract,contraction,62435,"ation of global variables and local ``static`` variables. Floating-point operations in these contexts will be rounded using ``FE_TONEAREST``. - The option ``-fno-rounding-math`` allows the compiler to assume that the rounding mode is set to ``FE_TONEAREST``. This is the default.; - The option ``-frounding-math`` forces the compiler to honor the dynamically-set rounding mode. This prevents optimizations which might affect results if the rounding mode changes or is different from the default; for example, it prevents floating-point operations from being reordered across most calls and prevents constant-folding when the result is not exactly representable. .. option:: -ffp-model=<value>. Specify floating point behavior. ``-ffp-model`` is an umbrella; option that encompasses functionality provided by other, single; purpose, floating point options. Valid values are: ``precise``, ``strict``,; and ``fast``.; Details:. * ``precise`` Disables optimizations that are not value-safe on; floating-point data, although FP contraction (FMA) is enabled; (``-ffp-contract=on``). This is the default behavior. This value resets; ``-fmath-errno`` to its target-dependent default.; * ``strict`` Enables ``-frounding-math`` and; ``-ffp-exception-behavior=strict``, and disables contractions (FMA). All; of the ``-ffast-math`` enablements are disabled. Enables; ``STDC FENV_ACCESS``: by default ``FENV_ACCESS`` is disabled. This option; setting behaves as though ``#pragma STDC FENV_ACCESS ON`` appeared at the; top of the source file.; * ``fast`` Behaves identically to specifying both ``-ffast-math`` and; ``ffp-contract=fast``. Note: If your command line specifies multiple instances; of the ``-ffp-model`` option, or if your command line option specifies; ``-ffp-model`` and later on the command line selects a floating point; option that has the effect of negating part of the ``ffp-model`` that; has been selected, then the compiler will issue a diagnostic warning; that the override has occurred. .. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:62473,Integrability,contract,contract,62473,"ation of global variables and local ``static`` variables. Floating-point operations in these contexts will be rounded using ``FE_TONEAREST``. - The option ``-fno-rounding-math`` allows the compiler to assume that the rounding mode is set to ``FE_TONEAREST``. This is the default.; - The option ``-frounding-math`` forces the compiler to honor the dynamically-set rounding mode. This prevents optimizations which might affect results if the rounding mode changes or is different from the default; for example, it prevents floating-point operations from being reordered across most calls and prevents constant-folding when the result is not exactly representable. .. option:: -ffp-model=<value>. Specify floating point behavior. ``-ffp-model`` is an umbrella; option that encompasses functionality provided by other, single; purpose, floating point options. Valid values are: ``precise``, ``strict``,; and ``fast``.; Details:. * ``precise`` Disables optimizations that are not value-safe on; floating-point data, although FP contraction (FMA) is enabled; (``-ffp-contract=on``). This is the default behavior. This value resets; ``-fmath-errno`` to its target-dependent default.; * ``strict`` Enables ``-frounding-math`` and; ``-ffp-exception-behavior=strict``, and disables contractions (FMA). All; of the ``-ffast-math`` enablements are disabled. Enables; ``STDC FENV_ACCESS``: by default ``FENV_ACCESS`` is disabled. This option; setting behaves as though ``#pragma STDC FENV_ACCESS ON`` appeared at the; top of the source file.; * ``fast`` Behaves identically to specifying both ``-ffast-math`` and; ``ffp-contract=fast``. Note: If your command line specifies multiple instances; of the ``-ffp-model`` option, or if your command line option specifies; ``-ffp-model`` and later on the command line selects a floating point; option that has the effect of negating part of the ``ffp-model`` that; has been selected, then the compiler will issue a diagnostic warning; that the override has occurred. .. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:62569,Integrability,depend,dependent,62569,". - The option ``-fno-rounding-math`` allows the compiler to assume that the rounding mode is set to ``FE_TONEAREST``. This is the default.; - The option ``-frounding-math`` forces the compiler to honor the dynamically-set rounding mode. This prevents optimizations which might affect results if the rounding mode changes or is different from the default; for example, it prevents floating-point operations from being reordered across most calls and prevents constant-folding when the result is not exactly representable. .. option:: -ffp-model=<value>. Specify floating point behavior. ``-ffp-model`` is an umbrella; option that encompasses functionality provided by other, single; purpose, floating point options. Valid values are: ``precise``, ``strict``,; and ``fast``.; Details:. * ``precise`` Disables optimizations that are not value-safe on; floating-point data, although FP contraction (FMA) is enabled; (``-ffp-contract=on``). This is the default behavior. This value resets; ``-fmath-errno`` to its target-dependent default.; * ``strict`` Enables ``-frounding-math`` and; ``-ffp-exception-behavior=strict``, and disables contractions (FMA). All; of the ``-ffast-math`` enablements are disabled. Enables; ``STDC FENV_ACCESS``: by default ``FENV_ACCESS`` is disabled. This option; setting behaves as though ``#pragma STDC FENV_ACCESS ON`` appeared at the; top of the source file.; * ``fast`` Behaves identically to specifying both ``-ffast-math`` and; ``ffp-contract=fast``. Note: If your command line specifies multiple instances; of the ``-ffp-model`` option, or if your command line option specifies; ``-ffp-model`` and later on the command line selects a floating point; option that has the effect of negating part of the ``ffp-model`` that; has been selected, then the compiler will issue a diagnostic warning; that the override has occurred. .. option:: -ffp-exception-behavior=<value>. Specify the floating-point exception behavior. Valid values are: ``ignore``, ``maytrap``, and ``str",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:62684,Integrability,contract,contractions,62684," set to ``FE_TONEAREST``. This is the default.; - The option ``-frounding-math`` forces the compiler to honor the dynamically-set rounding mode. This prevents optimizations which might affect results if the rounding mode changes or is different from the default; for example, it prevents floating-point operations from being reordered across most calls and prevents constant-folding when the result is not exactly representable. .. option:: -ffp-model=<value>. Specify floating point behavior. ``-ffp-model`` is an umbrella; option that encompasses functionality provided by other, single; purpose, floating point options. Valid values are: ``precise``, ``strict``,; and ``fast``.; Details:. * ``precise`` Disables optimizations that are not value-safe on; floating-point data, although FP contraction (FMA) is enabled; (``-ffp-contract=on``). This is the default behavior. This value resets; ``-fmath-errno`` to its target-dependent default.; * ``strict`` Enables ``-frounding-math`` and; ``-ffp-exception-behavior=strict``, and disables contractions (FMA). All; of the ``-ffast-math`` enablements are disabled. Enables; ``STDC FENV_ACCESS``: by default ``FENV_ACCESS`` is disabled. This option; setting behaves as though ``#pragma STDC FENV_ACCESS ON`` appeared at the; top of the source file.; * ``fast`` Behaves identically to specifying both ``-ffast-math`` and; ``ffp-contract=fast``. Note: If your command line specifies multiple instances; of the ``-ffp-model`` option, or if your command line option specifies; ``-ffp-model`` and later on the command line selects a floating point; option that has the effect of negating part of the ``ffp-model`` that; has been selected, then the compiler will issue a diagnostic warning; that the override has occurred. .. option:: -ffp-exception-behavior=<value>. Specify the floating-point exception behavior. Valid values are: ``ignore``, ``maytrap``, and ``strict``.; The default value is ``ignore``. Details:. * ``ignore`` The compiler assumes that th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:63019,Integrability,contract,contract,63019,"most calls and prevents constant-folding when the result is not exactly representable. .. option:: -ffp-model=<value>. Specify floating point behavior. ``-ffp-model`` is an umbrella; option that encompasses functionality provided by other, single; purpose, floating point options. Valid values are: ``precise``, ``strict``,; and ``fast``.; Details:. * ``precise`` Disables optimizations that are not value-safe on; floating-point data, although FP contraction (FMA) is enabled; (``-ffp-contract=on``). This is the default behavior. This value resets; ``-fmath-errno`` to its target-dependent default.; * ``strict`` Enables ``-frounding-math`` and; ``-ffp-exception-behavior=strict``, and disables contractions (FMA). All; of the ``-ffast-math`` enablements are disabled. Enables; ``STDC FENV_ACCESS``: by default ``FENV_ACCESS`` is disabled. This option; setting behaves as though ``#pragma STDC FENV_ACCESS ON`` appeared at the; top of the source file.; * ``fast`` Behaves identically to specifying both ``-ffast-math`` and; ``ffp-contract=fast``. Note: If your command line specifies multiple instances; of the ``-ffp-model`` option, or if your command line option specifies; ``-ffp-model`` and later on the command line selects a floating point; option that has the effect of negating part of the ``ffp-model`` that; has been selected, then the compiler will issue a diagnostic warning; that the override has occurred. .. option:: -ffp-exception-behavior=<value>. Specify the floating-point exception behavior. Valid values are: ``ignore``, ``maytrap``, and ``strict``.; The default value is ``ignore``. Details:. * ``ignore`` The compiler assumes that the exception status flags will not be read and that floating point exceptions will be masked.; * ``maytrap`` The compiler avoids transformations that may raise exceptions that would not have been raised by the original code. Constant folding performed by the compiler is exempt from this option.; * ``strict`` The compiler ensures that all tran",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:65966,Integrability,contract,contraction,65966,"er than ``long double``. .. option:: -f[no-]protect-parens. This option pertains to floating-point types, complex types with; floating-point components, and vectors of these types. Some arithmetic; expression transformations that are mathematically correct and permissible; according to the C and C++ language standards may be incorrect when dealing; with floating-point types, such as reassociation and distribution. Further,; the optimizer may ignore parentheses when computing arithmetic expressions; in circumstances where the parenthesized and unparenthesized expression; express the same mathematical value. For example (a+b)+c is the same; mathematical value as a+(b+c), but the optimizer is free to evaluate the; additions in any order regardless of the parentheses. When enabled, this; option forces the optimizer to honor the order of operations with respect; to parentheses in all circumstances.; Defaults to ``-fno-protect-parens``. Note that floating-point contraction (option `-ffp-contract=`) is disabled; when `-fprotect-parens` is enabled. Also note that in safe floating-point; modes, such as `-ffp-model=precise` or `-ffp-model=strict`, this option; has no effect because the optimizer is prohibited from making unsafe; transformations. .. option:: -fexcess-precision:. The C and C++ standards allow floating-point expressions to be computed as if; intermediate results had more precision (and/or a wider range) than the type; of the expression strictly allows. This is called excess precision; arithmetic.; Excess precision arithmetic can improve the accuracy of results (although not; always), and it can make computation significantly faster if the target lacks; direct hardware support for arithmetic in a particular type. However, it can; also undermine strict floating-point reproducibility. Under the standards, assignments and explicit casts force the operand to be; converted to its formal type, discarding any excess precision. Because data; can only flow between stateme",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:65992,Integrability,contract,contract,65992,"er than ``long double``. .. option:: -f[no-]protect-parens. This option pertains to floating-point types, complex types with; floating-point components, and vectors of these types. Some arithmetic; expression transformations that are mathematically correct and permissible; according to the C and C++ language standards may be incorrect when dealing; with floating-point types, such as reassociation and distribution. Further,; the optimizer may ignore parentheses when computing arithmetic expressions; in circumstances where the parenthesized and unparenthesized expression; express the same mathematical value. For example (a+b)+c is the same; mathematical value as a+(b+c), but the optimizer is free to evaluate the; additions in any order regardless of the parentheses. When enabled, this; option forces the optimizer to honor the order of operations with respect; to parentheses in all circumstances.; Defaults to ``-fno-protect-parens``. Note that floating-point contraction (option `-ffp-contract=`) is disabled; when `-fprotect-parens` is enabled. Also note that in safe floating-point; modes, such as `-ffp-model=precise` or `-ffp-model=strict`, this option; has no effect because the optimizer is prohibited from making unsafe; transformations. .. option:: -fexcess-precision:. The C and C++ standards allow floating-point expressions to be computed as if; intermediate results had more precision (and/or a wider range) than the type; of the expression strictly allows. This is called excess precision; arithmetic.; Excess precision arithmetic can improve the accuracy of results (although not; always), and it can make computation significantly faster if the target lacks; direct hardware support for arithmetic in a particular type. However, it can; also undermine strict floating-point reproducibility. Under the standards, assignments and explicit casts force the operand to be; converted to its formal type, discarding any excess precision. Because data; can only flow between stateme",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:69517,Integrability,depend,depend,69517,"aive mathematical formulas for complex; multiplication and enables application of Smith's algorithm for complex; division. See SMITH, R. L. Algorithm 116: Complex division. Commun.; ACM 5, 8 (1962). The default is ``-fno-cx-fortran-rules``. .. _floating-point-environment:. Accessing the floating point environment; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; Many targets allow floating point operations to be configured to control things; such as how inexact results should be rounded and how exceptional conditions; should be handled. This configuration is called the floating point environment.; C and C++ restrict access to the floating point environment by default, and the; compiler is allowed to assume that all operations are performed in the default; environment. When code is compiled in this default mode, operations that depend; on the environment (such as floating-point arithmetic and `FLT_ROUNDS`) may have; undefined behavior if the dynamic environment is not the default environment; for; example, `FLT_ROUNDS` may or may not simply return its default value for the target; instead of reading the dynamic environment, and floating-point operations may be; optimized as if the dynamic environment were the default. Similarly, it is undefined; behavior to change the floating point environment in this default mode, for example; by calling the `fesetround` function.; C provides two pragmas to allow code to dynamically modify the floating point environment:. - ``#pragma STDC FENV_ACCESS ON`` allows dynamic changes to the entire floating; point environment. - ``#pragma STDC FENV_ROUND FE_DYNAMIC`` allows dynamic changes to just the floating; point rounding mode. This may be more optimizable than ``FENV_ACCESS ON`` because; the compiler can still ignore the possibility of floating-point exceptions by default. Both of these can be used either at the start of a block scope, in which case; they cover all code in that scope (unless they're turned off in a child scope),; or at the ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:75123,Integrability,message,message,75123,"y operative modes and raises; floating-point exceptions as required by IEC 60559 (provided the state for the; FENV_ACCESS pragma is ‘‘on’’). All computation for initialization of objects; that have static or thread storage duration is done (as if) at translation; time.* C++ generalizes this by adding another phase of initialization; (at runtime) if the translation-time initialization fails, but the; translation-time evaluation of the initializer of succeeds, it will be; treated as a constant initializer. .. _controlling-code-generation:. Controlling Code Generation; ---------------------------. Clang provides a number of ways to control code generation. The options; are listed below. .. option:: -f[no-]sanitize=check1,check2,... Turn on runtime checks for various forms of undefined or suspicious; behavior. This option controls whether Clang adds runtime checks for various; forms of undefined or suspicious behavior, and is disabled by; default. If a check fails, a diagnostic message is produced at; runtime explaining the problem. The main checks are:. - .. _opt_fsanitize_address:. ``-fsanitize=address``:; :doc:`AddressSanitizer`, a memory error; detector.; - .. _opt_fsanitize_thread:. ``-fsanitize=thread``: :doc:`ThreadSanitizer`, a data race detector.; - .. _opt_fsanitize_memory:. ``-fsanitize=memory``: :doc:`MemorySanitizer`,; a detector of uninitialized reads. Requires instrumentation of all; program code.; - .. _opt_fsanitize_undefined:. ``-fsanitize=undefined``: :doc:`UndefinedBehaviorSanitizer`,; a fast and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:87053,Integrability,integrat,integrated,87053," ABI alignment of types; the layout of structs and; unions and the value returned by the alignof operator remain the same. This option can be overridden on a case-by-case basis by putting an explicit; “aligned” alignment on a struct, union, or typedef. For example:. .. code-block:: console. #include <immintrin.h>; // Make an aligned typedef of the AVX-512 16-int vector type.; typedef __v16si __aligned_v16si __attribute__((aligned(64)));. void initialize_vector(__aligned_v16si *v) {; // The compiler may assume that ‘v’ is 64-byte aligned, regardless of the; // value of -fmax-type-align.; }. .. option:: -faddrsig, -fno-addrsig. Controls whether Clang emits an address-significance table into the object; file. Address-significance tables allow linkers to implement `safe ICF; <https://research.google.com/pubs/archive/36912.pdf>`_ without the false; positives that can result from other implementation techniques such as; relocation scanning. Address-significance tables are enabled by default; on ELF targets when using the integrated assembler. This flag currently; only has an effect on ELF targets. .. option:: -f[no]-unique-internal-linkage-names. Controls whether Clang emits a unique (best-effort) symbol name for internal; linkage symbols. When this option is set, compiler hashes the main source; file path from the command line and appends it to all internal symbols. If a; program contains multiple objects compiled with the same command-line source; file path, the symbols are not guaranteed to be unique. This option is; particularly useful in attributing profile information to the correct; function when multiple functions with the same private linkage name exist; in the binary. It should be noted that this option cannot guarantee uniqueness and the; following is an example where it is not unique when two modules contain; symbols with the same private linkage name:. .. code-block:: console. $ cd $P/foo && clang -c -funique-internal-linkage-names name_conflict.c; $ cd $P/ba",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:113637,Integrability,depend,depending,113637,"ing. For example, the user can; have. .. code-block:: c. __attribute__((weak)) int __llvm_profile_dump(void);. // Then later in the same source file; if (__llvm_profile_dump); if (__llvm_profile_dump() != 0) { ... }; // The first if condition tests if the symbol is actually defined.; // Profile dumping only happens if the symbol is defined. Hence,; // the user program works correctly during normal (not profile-generate); // executions. Alternatively, the user program can include the header; ``profile/instr_prof_interface.h``, which contains the API names. For example,. .. code-block:: c. #include ""profile/instr_prof_interface.h"". // Then later in the same source file; if (__llvm_profile_dump() != 0) { ... }. The user code does not need to check if the API names are defined, because; these names are automatically replaced by ``(0)`` or the equivalence of noop; if the ``clang`` is not compiling for profile generation. Such replacement can happen because ``clang`` adds one of two macros depending; on the ``-fprofile-generate`` and the ``-fprofile-use`` flags. * ``__LLVM_INSTR_PROFILE_GENERATE``: defined when one of; ``-fprofile[-instr]-generate``/``-fcs-profile-generate`` is in effect.; * ``__LLVM_INSTR_PROFILE_USE``: defined when one of; ``-fprofile-use``/``-fprofile-instr-use`` is in effect. The two macros can be used to provide more flexibiilty so a user program; can execute code specifically intended for profile generate or profile use.; For example, a user program can have special logging during profile generate:. .. code-block:: c. #if __LLVM_INSTR_PROFILE_GENERATE; expensive_logging_of_full_program_state();; #endif. The logging is automatically excluded during a normal build of the program,; hence it does not impact performance during a normal execution. It is advised to use such fine tuning only in a program's cold regions. The weak; symbols can introduce extra control flow (the ``if`` checks), while the macros; (hence declarations they guard in ``profile/instr_",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:137069,Integrability,depend,dependent,137069,"s,; and in array bounds at global scope. Clang also accepts additional; expression forms in these contexts, but constructs that GCC accepts due to; simplifications GCC performs while parsing, such as ``x - x`` (where ``x`` is a; variable) will likely never be accepted by Clang.; - clang does not support ``__builtin_apply`` and friends; this extension; is extremely obscure and difficult to implement reliably. .. _c_ms:. Microsoft extensions; --------------------. clang has support for many extensions from Microsoft Visual C++. To enable these; extensions, use the ``-fms-extensions`` command-line option. This is the default; for Windows targets. Clang does not implement every pragma or declspec provided; by MSVC, but the popular ones, such as ``__declspec(dllexport)`` and ``#pragma; comment(lib)`` are well supported. clang has a ``-fms-compatibility`` flag that makes clang accept enough; invalid C++ to be able to parse most Microsoft headers. For example, it; allows `unqualified lookup of dependent base class members; <https://clang.llvm.org/compatibility.html#dep_lookup_bases>`_, which is; a common compatibility issue with clang. This flag is enabled by default; for Windows targets. ``-fdelayed-template-parsing`` lets clang delay parsing of function template; definitions until the end of a translation unit. This flag is enabled by; default for Windows targets. For compatibility with existing code that compiles with MSVC, clang defines the; ``_MSC_VER`` and ``_MSC_FULL_VER`` macros. When on Windows, these default to; either the same value as the currently installed version of cl.exe, or ``1933``; and ``193300000`` (respectively). The ``-fms-compatibility-version=`` flag; overrides these values. It accepts a dotted version tuple, such as 19.00.23506.; Changing the MSVC compatibility version makes clang behave more like that; version of MSVC. For example, ``-fms-compatibility-version=19`` will enable; C++14 features and define ``char16_t`` and ``char32_t`` as builtin typ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:147820,Integrability,depend,depending,147820," can be used to toggle individual extensions and; features. .. _opencl_header:. OpenCL Header; -------------. By default Clang will include standard headers and therefore most of OpenCL; builtin functions and types are available during compilation. The; default declarations of non-native compiler types and functions can be disabled; by using flag :option:`-cl-no-stdinc`. The following example demonstrates that OpenCL kernel sources with various; standard builtin functions can be compiled without the need for an explicit; includes or compiler flags. .. code-block:: console. $ echo ""bool is_wg_uniform(int i){return get_enqueued_local_size(i)==get_local_size(i);}"" > test.cl; $ clang -cl-std=CL2.0 test.cl. More information about the default headers is provided in :doc:`OpenCLSupport`. OpenCL Extensions; -----------------. Most of the ``cl_khr_*`` extensions to OpenCL C from `the official OpenCL; registry <https://www.khronos.org/registry/OpenCL/>`_ are available and; configured per target depending on the support available in the specific; architecture. It is possible to alter the default extensions setting per target using; ``-cl-ext`` flag. (See :ref:`flags description <opencl_cl_ext>` for more details). Vendor extensions can be added flexibly by declaring the list of types and; functions associated with each extensions enclosed within the following; compiler pragma directives:. .. code-block:: c. #pragma OPENCL EXTENSION the_new_extension_name : begin; // declare types and functions associated with the extension here; #pragma OPENCL EXTENSION the_new_extension_name : end. For example, parsing the following code adds ``my_t`` type and ``my_func``; function to the custom ``my_ext`` extension. .. code-block:: c. #pragma OPENCL EXTENSION my_ext : begin; typedef struct{; int a;; }my_t;; void my_func(my_t);; #pragma OPENCL EXTENSION my_ext : end. There is no conflict resolution for identifier clashes among extensions.; It is therefore recommended that the identifiers are p",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:167221,Integrability,integrat,integrated,167221,"jor releases. The same applies to the; main development branch. It is therefore important to ensure the ``llvm-spirv``; version is in alignment with the Clang version. For troubleshooting purposes; ``llvm-spirv`` can be `tested in isolation; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator#test-instructions>`_. Example usage for OpenCL kernel compilation:. .. code-block:: console. $ clang --target=spirv32 -c test.cl; $ clang --target=spirv64 -c test.cl. Both invocations of Clang will result in the generation of a SPIR-V binary file; `test.o` for 32 bit and 64 bit respectively. This file can be imported; by an OpenCL driver that support SPIR-V consumption or it can be compiled; further by offline SPIR-V consumer tools. Converting to SPIR-V produced with the optimization levels other than `-O0` is; currently available as an experimental feature and it is not guaranteed to work; in all cases. Clang also supports integrated generation of SPIR-V without use of ``llvm-spirv``; tool as an experimental feature when ``-fintegrated-objemitter`` flag is passed in; the command line. .. code-block:: console. $ clang --target=spirv32 -fintegrated-objemitter -c test.cl. Note that only very basic functionality is supported at this point and therefore; it is not suitable for arbitrary use cases. This feature is only enabled when clang; build is configured with ``-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=SPIRV`` option. Linking is done using ``spirv-link`` from `the SPIRV-Tools project; <https://github.com/KhronosGroup/SPIRV-Tools#linker>`_. Similar to other external; linkers, Clang will expect ``spirv-link`` to be installed separately and to be; present in the ``PATH`` environment variable. Please refer to `the build and; installation instructions; <https://github.com/KhronosGroup/SPIRV-Tools#build>`_. .. code-block:: console. $ clang --target=spirv64 test1.cl test2.cl. More information about the SPIR-V target settings and supported versions of SPIR-V; format can be found in `the SP",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:168431,Integrability,interface,interface,168431,"jemitter -c test.cl. Note that only very basic functionality is supported at this point and therefore; it is not suitable for arbitrary use cases. This feature is only enabled when clang; build is configured with ``-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=SPIRV`` option. Linking is done using ``spirv-link`` from `the SPIRV-Tools project; <https://github.com/KhronosGroup/SPIRV-Tools#linker>`_. Similar to other external; linkers, Clang will expect ``spirv-link`` to be installed separately and to be; present in the ``PATH`` environment variable. Please refer to `the build and; installation instructions; <https://github.com/KhronosGroup/SPIRV-Tools#build>`_. .. code-block:: console. $ clang --target=spirv64 test1.cl test2.cl. More information about the SPIR-V target settings and supported versions of SPIR-V; format can be found in `the SPIR-V target guide; <https://llvm.org/docs/SPIRVUsage.html>`__. .. _clang-cl:. clang-cl; ========. clang-cl is an alternative command-line interface to Clang, designed for; compatibility with the Visual C++ compiler, cl.exe. To enable clang-cl to find system headers, libraries, and the linker when run; from the command-line, it should be executed inside a Visual Studio Native Tools; Command Prompt or a regular Command Prompt where the environment has been set; up using e.g. `vcvarsall.bat <https://msdn.microsoft.com/en-us/library/f2ccy3wt.aspx>`_. clang-cl can also be used from inside Visual Studio by selecting the LLVM; Platform Toolset. The toolset is not part of the installer, but may be installed; separately from the; `Visual Studio Marketplace <https://marketplace.visualstudio.com/items?itemName=LLVMExtensions.llvm-toolchain>`_.; To use the toolset, select a project in Solution Explorer, open its Property; Page (Alt+F7), and in the ""General"" section of ""Configuration Properties""; change ""Platform Toolset"" to LLVM. Doing so enables an additional Property; Page for selecting the clang-cl executable to use for builds. To use the toolset wi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:193581,Integrability,interface,interfaces,193581,"nd below. If the user is using the static CRT (``/MT``), then different runtimes are used; to produce DLLs and EXEs. To link a DLL, pass; ``clang_rt.asan_dll_thunk-x86_64.lib``. To link an EXE, pass; ``-wholearchive:clang_rt.asan-x86_64.lib``. Windows System Headers and Library Lookup; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. clang-cl uses a set of different approaches to locate the right system libraries; to link against when building code. The Windows environment uses libraries from; three distinct sources:. 1. Windows SDK; 2. UCRT (Universal C Runtime); 3. Visual C++ Tools (VCRuntime). The Windows SDK provides the import libraries and headers required to build; programs against the Windows system packages. Underlying the Windows SDK is the; UCRT, the universal C runtime. This difference is best illustrated by the various headers that one would find; in the different categories. The WinSDK would contain headers such as; `WinSock2.h` which is part of the Windows API surface, providing the Windows; socketing interfaces for networking. UCRT provides the C library headers,; including e.g. `stdio.h`. Finally, the Visual C++ tools provides the underlying; Visual C++ Runtime headers such as `stdint.h` or `crtdefs.h`. There are various controls that allow the user control over where clang-cl will; locate these headers. The default behaviour for the Windows SDK and UCRT is as; follows:. 1. Consult the command line. Anything the user specifies is always given precedence. The following; extensions are part of the clang-cl toolset:. - `/winsysroot:`. The `/winsysroot:` is used as an equivalent to `-sysroot` on Unix; environments. It allows the control of an alternate location to be treated; as a system root. When specified, it will be used as the root where the; `Windows Kits` is located. - `/winsdkversion:`; - `/winsdkdir:`. If `/winsysroot:` is not specified, the `/winsdkdir:` argument is consulted; as a location to identify where the Windows SDK is located. Contrary to; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:196916,Integrability,interface,interface,196916,"insysroot:` is not specified, the `/vctoolsdir:` argument is consulted; as a location to identify where the Visual C++ Tools are located. If; `/vctoolsversion:` is specified, that version is preferred, otherwise, the; highest version detected is used. 2. Consult the environment. - `/external:[VARIABLE]`. This specifies a user identified environment variable which is treated as; a path delimiter (`;`) separated list of paths to map into `-imsvc`; arguments which are treated as `-isystem`. - `INCLUDE` and `EXTERNAL_INCLUDE`. The path delimiter (`;`) separated list of paths will be mapped to; `-imsvc` arguments which are treated as `-isystem`. - `LIB` (indirectly). The linker `link.exe` or `lld-link.exe` will honour the environment; variable `LIB` which is a path delimiter (`;`) set of paths to consult for; the import libraries to use when linking the final target. The following environment variables will be consulted and used to form paths; to validate and load content from as appropriate:. - `VCToolsInstallDir`; - `VCINSTALLDIR`; - `Path`. 3. Consult `ISetupConfiguration` [Windows Only]. Assuming that the toolchain is built with `USE_MSVC_SETUP_API` defined and; is running on Windows, the Visual Studio COM interface `ISetupConfiguration`; will be used to locate the installation of the MSVC toolset. 4. Fallback to the registry [DEPRECATED]. The registry information is used to help locate the installation as a final; fallback. This is only possible for pre-VS2017 installations and is; considered deprecated. Restrictions and Limitations compared to Clang; ----------------------------------------------. Strict Aliasing; ^^^^^^^^^^^^^^^. Strict aliasing (TBAA) is always off by default in clang-cl. Whereas in clang,; strict aliasing is turned on by default for all optimization levels. To enable LLVM optimizations based on strict aliasing rules (e.g., optimizations; based on type of expressions in C/C++), user will need to explicitly pass; `-fstrict-aliasing` to clang-cl.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:7915,Modifiability,variab,variable,7915,"hen emitting a; diagnostic. For example, when this is enabled, Clang will print; something like:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. .. option:: -f[no-]color-diagnostics. This option, which defaults to on when a color-capable terminal is; detected, controls whether or not Clang prints diagnostics in color. When this option is enabled, Clang will use colors to highlight; specific parts of the diagnostic, e.g.,. .. nasty hack to not lose our dignity. .. raw:: html. <pre>; <b><span style=""color:black"">test.c:28:8: <span style=""color:magenta"">warning</span>: extra tokens at end of #endif directive [-Wextra-tokens]</span></b>; #endif bad; <span style=""color:green"">^</span>; <span style=""color:green"">//</span>; </pre>. When this is disabled, Clang will just print:. ::. test.c:2:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. If the ``NO_COLOR`` environment variable is defined and not empty; (regardless of value), color diagnostics are disabled. If ``NO_COLOR`` is; defined and ``-fcolor-diagnostics`` is passed on the command line, Clang; will honor the command line argument. .. option:: -fansi-escape-codes. Controls whether ANSI escape codes are used instead of the Windows Console; API to output colored diagnostics. This option is only used on Windows and; defaults to off. .. option:: -fdiagnostics-format=clang/msvc/vi. Changes diagnostic output format to better match IDEs and command line tools. This option controls the output format of the filename, line number,; and column printed in diagnostic messages. The options, and their; affect on formatting a simple conversion diagnostic, follow:. **clang** (default); ::. t.c:3:11: warning: conversion specifies type 'char *' but the argument has type 'int'. **msvc**; ::. t.c(3,11) : warning: conversion specifies type 'char *' but the argument has type 'int'. **vi**; ::. t.c +3:11: warning: conversion specifies type 'char ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:27794,Modifiability,variab,variables,27794,". .. code-block:: console. $ clang -fproc-stat-report=abc foo.c; $ cat abc; clang-11,""/tmp/foo-123456.o"",92000,84000,87536; ld,""a.out"",900,8000,53568. The data on each row represent:. * file name of the tool executable,; * output file name in quotes,; * total execution time in microseconds,; * execution time in user mode in microseconds,; * peak memory usage in Kb. It is possible to specify this option without any value. In this case statistics; are printed on standard output in human readable format:. .. code-block:: console. $ clang -fproc-stat-report foo.c; clang-11: output=/tmp/foo-855a8e.o, total=68.000 ms, user=60.000 ms, mem=86920 Kb; ld: output=a.out, total=8.000 ms, user=4.000 ms, mem=52320 Kb. The report file specified in the option is locked for write, so this option; can be used to collect statistics in parallel builds. The report file is not; cleared, new data is appended to it, thus making possible to accumulate build; statistics. You can also use environment variables to control the process statistics reporting.; Setting ``CC_PRINT_PROC_STAT`` to ``1`` enables the feature, the report goes to; stdout in human readable format.; Setting ``CC_PRINT_PROC_STAT_FILE`` to a fully qualified file path makes it report; process statistics to the given file in the CSV format. Specifying a relative; path will likely lead to multiple files with the same name created in different; directories, since the path is relative to a changing working directory. These environment variables are handy when you need to request the statistics; report without changing your build scripts or alter the existing set of compiler; options. Note that ``-fproc-stat-report`` take precedence over ``CC_PRINT_PROC_STAT``; and ``CC_PRINT_PROC_STAT_FILE``. .. code-block:: console. $ export CC_PRINT_PROC_STAT=1; $ export CC_PRINT_PROC_STAT_FILE=~/project-build-proc-stat.csv; $ make. Other Options; -------------; Clang options that don't fit neatly into other categories. .. option:: -fgnuc-version",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:28300,Modifiability,variab,variables,28300,"foo.c; clang-11: output=/tmp/foo-855a8e.o, total=68.000 ms, user=60.000 ms, mem=86920 Kb; ld: output=a.out, total=8.000 ms, user=4.000 ms, mem=52320 Kb. The report file specified in the option is locked for write, so this option; can be used to collect statistics in parallel builds. The report file is not; cleared, new data is appended to it, thus making possible to accumulate build; statistics. You can also use environment variables to control the process statistics reporting.; Setting ``CC_PRINT_PROC_STAT`` to ``1`` enables the feature, the report goes to; stdout in human readable format.; Setting ``CC_PRINT_PROC_STAT_FILE`` to a fully qualified file path makes it report; process statistics to the given file in the CSV format. Specifying a relative; path will likely lead to multiple files with the same name created in different; directories, since the path is relative to a changing working directory. These environment variables are handy when you need to request the statistics; report without changing your build scripts or alter the existing set of compiler; options. Note that ``-fproc-stat-report`` take precedence over ``CC_PRINT_PROC_STAT``; and ``CC_PRINT_PROC_STAT_FILE``. .. code-block:: console. $ export CC_PRINT_PROC_STAT=1; $ export CC_PRINT_PROC_STAT_FILE=~/project-build-proc-stat.csv; $ make. Other Options; -------------; Clang options that don't fit neatly into other categories. .. option:: -fgnuc-version=. This flag controls the value of ``__GNUC__`` and related macros. This flag; does not enable or disable any GCC extensions implemented in Clang. Setting; the version to zero causes Clang to leave ``__GNUC__`` and other; GNU-namespaced macros, such as ``__GXX_WEAK__``, undefined. .. option:: -MV. When emitting a dependency file, use formatting conventions appropriate; for NMake or Jom. Ignored unless another option causes Clang to emit a; dependency file. When Clang emits a dependency file (e.g., you supplied the -M option); most filenames can be writte",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:30663,Modifiability,config,configuration,30663," backslash to ""escape""; a special character, which is the convention used by GNU Make. The -MV; option tells Clang to put double-quotes around the entire filename, which; is the convention used by NMake and Jom. .. option:: -femit-dwarf-unwind=<value>. When to emit DWARF unwind (EH frame) info. This is a Mach-O-specific option. Valid values are:. * ``no-compact-unwind`` - Only emit DWARF unwind when compact unwind encodings; aren't available. This is the default for arm64.; * ``always`` - Always emit DWARF unwind regardless.; * ``default`` - Use the platform-specific default (``always`` for all; non-arm64-platforms). ``no-compact-unwind`` is a performance optimization -- Clang will emit smaller; object files that are more quickly processed by the linker. This may cause; binary compatibility issues on older x86_64 targets, however, so use it with; caution. .. _configuration-files:. Configuration files; -------------------. Configuration files group command-line options and allow all of them to be; specified just by referencing the configuration file. They may be used, for; example, to collect options required to tune compilation for particular; target, such as ``-L``, ``-I``, ``-l``, ``--sysroot``, codegen options, etc. Configuration files can be either specified on the command line or loaded; from default locations. If both variants are present, the default configuration; files are loaded first. The command line option ``--config=`` can be used to specify explicit; configuration files in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:30997,Modifiability,config,configuration,30997,"ly emit DWARF unwind when compact unwind encodings; aren't available. This is the default for arm64.; * ``always`` - Always emit DWARF unwind regardless.; * ``default`` - Use the platform-specific default (``always`` for all; non-arm64-platforms). ``no-compact-unwind`` is a performance optimization -- Clang will emit smaller; object files that are more quickly processed by the linker. This may cause; binary compatibility issues on older x86_64 targets, however, so use it with; caution. .. _configuration-files:. Configuration files; -------------------. Configuration files group command-line options and allow all of them to be; specified just by referencing the configuration file. They may be used, for; example, to collect options required to tune compilation for particular; target, such as ``-L``, ``-I``, ``-l``, ``--sysroot``, codegen options, etc. Configuration files can be either specified on the command line or loaded; from default locations. If both variants are present, the default configuration; files are loaded first. The command line option ``--config=`` can be used to specify explicit; configuration files in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - the directory where Clang executable resides. Both user and system directories for configuration files are specified during; clang build using CMake parameters, ``CLANG_CONFIG_FILE_USER_DIR`` and; ``CLANG_CONFIG_FILE_SYSTEM_DIR`` respectively. The first file found is used.; It is an error if the required file cannot be found. The default configuration files are searched for in ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:31064,Modifiability,config,config,31064,"4.; * ``always`` - Always emit DWARF unwind regardless.; * ``default`` - Use the platform-specific default (``always`` for all; non-arm64-platforms). ``no-compact-unwind`` is a performance optimization -- Clang will emit smaller; object files that are more quickly processed by the linker. This may cause; binary compatibility issues on older x86_64 targets, however, so use it with; caution. .. _configuration-files:. Configuration files; -------------------. Configuration files group command-line options and allow all of them to be; specified just by referencing the configuration file. They may be used, for; example, to collect options required to tune compilation for particular; target, such as ``-L``, ``-I``, ``-l``, ``--sysroot``, codegen options, etc. Configuration files can be either specified on the command line or loaded; from default locations. If both variants are present, the default configuration; files are loaded first. The command line option ``--config=`` can be used to specify explicit; configuration files in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - the directory where Clang executable resides. Both user and system directories for configuration files are specified during; clang build using CMake parameters, ``CLANG_CONFIG_FILE_USER_DIR`` and; ``CLANG_CONFIG_FILE_SYSTEM_DIR`` respectively. The first file found is used.; It is an error if the required file cannot be found. The default configuration files are searched for in the same directories; following the rules described in the next paragraphs. Loading default; conf",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:31107,Modifiability,config,configuration,31107,"4.; * ``always`` - Always emit DWARF unwind regardless.; * ``default`` - Use the platform-specific default (``always`` for all; non-arm64-platforms). ``no-compact-unwind`` is a performance optimization -- Clang will emit smaller; object files that are more quickly processed by the linker. This may cause; binary compatibility issues on older x86_64 targets, however, so use it with; caution. .. _configuration-files:. Configuration files; -------------------. Configuration files group command-line options and allow all of them to be; specified just by referencing the configuration file. They may be used, for; example, to collect options required to tune compilation for particular; target, such as ``-L``, ``-I``, ``-l``, ``--sysroot``, codegen options, etc. Configuration files can be either specified on the command line or loaded; from default locations. If both variants are present, the default configuration; files are loaded first. The command line option ``--config=`` can be used to specify explicit; configuration files in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - the directory where Clang executable resides. Both user and system directories for configuration files are specified during; clang build using CMake parameters, ``CLANG_CONFIG_FILE_USER_DIR`` and; ``CLANG_CONFIG_FILE_SYSTEM_DIR`` respectively. The first file found is used.; It is an error if the required file cannot be found. The default configuration files are searched for in the same directories; following the rules described in the next paragraphs. Loading default; conf",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:31257,Modifiability,config,config,31257," performance optimization -- Clang will emit smaller; object files that are more quickly processed by the linker. This may cause; binary compatibility issues on older x86_64 targets, however, so use it with; caution. .. _configuration-files:. Configuration files; -------------------. Configuration files group command-line options and allow all of them to be; specified just by referencing the configuration file. They may be used, for; example, to collect options required to tune compilation for particular; target, such as ``-L``, ``-I``, ``-l``, ``--sysroot``, codegen options, etc. Configuration files can be either specified on the command line or loaded; from default locations. If both variants are present, the default configuration; files are loaded first. The command line option ``--config=`` can be used to specify explicit; configuration files in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - the directory where Clang executable resides. Both user and system directories for configuration files are specified during; clang build using CMake parameters, ``CLANG_CONFIG_FILE_USER_DIR`` and; ``CLANG_CONFIG_FILE_SYSTEM_DIR`` respectively. The first file found is used.; It is an error if the required file cannot be found. The default configuration files are searched for in the same directories; following the rules described in the next paragraphs. Loading default; configuration files can be disabled entirely via passing; the ``--no-default-config`` flag. First, the algorithm searches for a configuration file named; ``<triple>-<driver>.cfg`` ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:31301,Modifiability,config,config,31301,"g will emit smaller; object files that are more quickly processed by the linker. This may cause; binary compatibility issues on older x86_64 targets, however, so use it with; caution. .. _configuration-files:. Configuration files; -------------------. Configuration files group command-line options and allow all of them to be; specified just by referencing the configuration file. They may be used, for; example, to collect options required to tune compilation for particular; target, such as ``-L``, ``-I``, ``-l``, ``--sysroot``, codegen options, etc. Configuration files can be either specified on the command line or loaded; from default locations. If both variants are present, the default configuration; files are loaded first. The command line option ``--config=`` can be used to specify explicit; configuration files in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - the directory where Clang executable resides. Both user and system directories for configuration files are specified during; clang build using CMake parameters, ``CLANG_CONFIG_FILE_USER_DIR`` and; ``CLANG_CONFIG_FILE_SYSTEM_DIR`` respectively. The first file found is used.; It is an error if the required file cannot be found. The default configuration files are searched for in the same directories; following the rules described in the next paragraphs. Loading default; configuration files can be disabled entirely via passing; the ``--no-default-config`` flag. First, the algorithm searches for a configuration file named; ``<triple>-<driver>.cfg`` where `triple` is the triple for ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:31320,Modifiability,config,config,31320,"ect files that are more quickly processed by the linker. This may cause; binary compatibility issues on older x86_64 targets, however, so use it with; caution. .. _configuration-files:. Configuration files; -------------------. Configuration files group command-line options and allow all of them to be; specified just by referencing the configuration file. They may be used, for; example, to collect options required to tune compilation for particular; target, such as ``-L``, ``-I``, ``-l``, ``--sysroot``, codegen options, etc. Configuration files can be either specified on the command line or loaded; from default locations. If both variants are present, the default configuration; files are loaded first. The command line option ``--config=`` can be used to specify explicit; configuration files in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - the directory where Clang executable resides. Both user and system directories for configuration files are specified during; clang build using CMake parameters, ``CLANG_CONFIG_FILE_USER_DIR`` and; ``CLANG_CONFIG_FILE_SYSTEM_DIR`` respectively. The first file found is used.; It is an error if the required file cannot be found. The default configuration files are searched for in the same directories; following the rules described in the next paragraphs. Loading default; configuration files can be disabled entirely via passing; the ``--no-default-config`` flag. First, the algorithm searches for a configuration file named; ``<triple>-<driver>.cfg`` where `triple` is the triple for the target being; built ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:31698,Modifiability,config,configuration,31698,"ion for particular; target, such as ``-L``, ``-I``, ``-l``, ``--sysroot``, codegen options, etc. Configuration files can be either specified on the command line or loaded; from default locations. If both variants are present, the default configuration; files are loaded first. The command line option ``--config=`` can be used to specify explicit; configuration files in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - the directory where Clang executable resides. Both user and system directories for configuration files are specified during; clang build using CMake parameters, ``CLANG_CONFIG_FILE_USER_DIR`` and; ``CLANG_CONFIG_FILE_SYSTEM_DIR`` respectively. The first file found is used.; It is an error if the required file cannot be found. The default configuration files are searched for in the same directories; following the rules described in the next paragraphs. Loading default; configuration files can be disabled entirely via passing; the ``--no-default-config`` flag. First, the algorithm searches for a configuration file named; ``<triple>-<driver>.cfg`` where `triple` is the triple for the target being; built for, and `driver` is the name of the currently used driver. The algorithm; first attempts to use the canonical name for the driver used, then falls back; to the one found in the executable name. The following canonical driver names are used:. - ``clang`` for the ``gcc`` driver (used to compile C programs); - ``clang++`` for the ``gxx`` driver (used to compile C++ programs); - ``clang-cpp`` for the ``cpp`` driver (pure preprocessor",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:31955,Modifiability,config,configuration,31955,"tion; files are loaded first. The command line option ``--config=`` can be used to specify explicit; configuration files in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - the directory where Clang executable resides. Both user and system directories for configuration files are specified during; clang build using CMake parameters, ``CLANG_CONFIG_FILE_USER_DIR`` and; ``CLANG_CONFIG_FILE_SYSTEM_DIR`` respectively. The first file found is used.; It is an error if the required file cannot be found. The default configuration files are searched for in the same directories; following the rules described in the next paragraphs. Loading default; configuration files can be disabled entirely via passing; the ``--no-default-config`` flag. First, the algorithm searches for a configuration file named; ``<triple>-<driver>.cfg`` where `triple` is the triple for the target being; built for, and `driver` is the name of the currently used driver. The algorithm; first attempts to use the canonical name for the driver used, then falls back; to the one found in the executable name. The following canonical driver names are used:. - ``clang`` for the ``gcc`` driver (used to compile C programs); - ``clang++`` for the ``gxx`` driver (used to compile C++ programs); - ``clang-cpp`` for the ``cpp`` driver (pure preprocessor); - ``clang-cl`` for the ``cl`` driver; - ``flang`` for the ``flang`` driver; - ``clang-dxc`` for the ``dxc`` driver. For example, when calling ``x86_64-pc-linux-gnu-clang-g++``,; the driver will first attempt to use the configuration file named:",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:32088,Modifiability,config,configuration,32088,"es in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - the directory where Clang executable resides. Both user and system directories for configuration files are specified during; clang build using CMake parameters, ``CLANG_CONFIG_FILE_USER_DIR`` and; ``CLANG_CONFIG_FILE_SYSTEM_DIR`` respectively. The first file found is used.; It is an error if the required file cannot be found. The default configuration files are searched for in the same directories; following the rules described in the next paragraphs. Loading default; configuration files can be disabled entirely via passing; the ``--no-default-config`` flag. First, the algorithm searches for a configuration file named; ``<triple>-<driver>.cfg`` where `triple` is the triple for the target being; built for, and `driver` is the name of the currently used driver. The algorithm; first attempts to use the canonical name for the driver used, then falls back; to the one found in the executable name. The following canonical driver names are used:. - ``clang`` for the ``gcc`` driver (used to compile C programs); - ``clang++`` for the ``gxx`` driver (used to compile C++ programs); - ``clang-cpp`` for the ``cpp`` driver (pure preprocessor); - ``clang-cl`` for the ``cl`` driver; - ``flang`` for the ``flang`` driver; - ``clang-dxc`` for the ``dxc`` driver. For example, when calling ``x86_64-pc-linux-gnu-clang-g++``,; the driver will first attempt to use the configuration file named::. x86_64-pc-linux-gnu-clang++.cfg. If this file is not found, it will attempt to use the name found; in the executable",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:32165,Modifiability,config,config,32165,"es in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - the directory where Clang executable resides. Both user and system directories for configuration files are specified during; clang build using CMake parameters, ``CLANG_CONFIG_FILE_USER_DIR`` and; ``CLANG_CONFIG_FILE_SYSTEM_DIR`` respectively. The first file found is used.; It is an error if the required file cannot be found. The default configuration files are searched for in the same directories; following the rules described in the next paragraphs. Loading default; configuration files can be disabled entirely via passing; the ``--no-default-config`` flag. First, the algorithm searches for a configuration file named; ``<triple>-<driver>.cfg`` where `triple` is the triple for the target being; built for, and `driver` is the name of the currently used driver. The algorithm; first attempts to use the canonical name for the driver used, then falls back; to the one found in the executable name. The following canonical driver names are used:. - ``clang`` for the ``gcc`` driver (used to compile C programs); - ``clang++`` for the ``gxx`` driver (used to compile C++ programs); - ``clang-cpp`` for the ``cpp`` driver (pure preprocessor); - ``clang-cl`` for the ``cl`` driver; - ``flang`` for the ``flang`` driver; - ``clang-dxc`` for the ``dxc`` driver. For example, when calling ``x86_64-pc-linux-gnu-clang-g++``,; the driver will first attempt to use the configuration file named::. x86_64-pc-linux-gnu-clang++.cfg. If this file is not found, it will attempt to use the name found; in the executable",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:32216,Modifiability,config,configuration,32216," in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - the directory where Clang executable resides. Both user and system directories for configuration files are specified during; clang build using CMake parameters, ``CLANG_CONFIG_FILE_USER_DIR`` and; ``CLANG_CONFIG_FILE_SYSTEM_DIR`` respectively. The first file found is used.; It is an error if the required file cannot be found. The default configuration files are searched for in the same directories; following the rules described in the next paragraphs. Loading default; configuration files can be disabled entirely via passing; the ``--no-default-config`` flag. First, the algorithm searches for a configuration file named; ``<triple>-<driver>.cfg`` where `triple` is the triple for the target being; built for, and `driver` is the name of the currently used driver. The algorithm; first attempts to use the canonical name for the driver used, then falls back; to the one found in the executable name. The following canonical driver names are used:. - ``clang`` for the ``gcc`` driver (used to compile C programs); - ``clang++`` for the ``gxx`` driver (used to compile C++ programs); - ``clang-cpp`` for the ``cpp`` driver (pure preprocessor); - ``clang-cl`` for the ``cl`` driver; - ``flang`` for the ``flang`` driver; - ``clang-dxc`` for the ``dxc`` driver. For example, when calling ``x86_64-pc-linux-gnu-clang-g++``,; the driver will first attempt to use the configuration file named::. x86_64-pc-linux-gnu-clang++.cfg. If this file is not found, it will attempt to use the name found; in the executable instead::. x86_64-pc-linux-gnu-clang-g++.cfg. Note that options such as ``--driver-mode=``, ``-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:32981,Modifiability,config,configuration,32981," The default configuration files are searched for in the same directories; following the rules described in the next paragraphs. Loading default; configuration files can be disabled entirely via passing; the ``--no-default-config`` flag. First, the algorithm searches for a configuration file named; ``<triple>-<driver>.cfg`` where `triple` is the triple for the target being; built for, and `driver` is the name of the currently used driver. The algorithm; first attempts to use the canonical name for the driver used, then falls back; to the one found in the executable name. The following canonical driver names are used:. - ``clang`` for the ``gcc`` driver (used to compile C programs); - ``clang++`` for the ``gxx`` driver (used to compile C++ programs); - ``clang-cpp`` for the ``cpp`` driver (pure preprocessor); - ``clang-cl`` for the ``cl`` driver; - ``flang`` for the ``flang`` driver; - ``clang-dxc`` for the ``dxc`` driver. For example, when calling ``x86_64-pc-linux-gnu-clang-g++``,; the driver will first attempt to use the configuration file named::. x86_64-pc-linux-gnu-clang++.cfg. If this file is not found, it will attempt to use the name found; in the executable instead::. x86_64-pc-linux-gnu-clang-g++.cfg. Note that options such as ``--driver-mode=``, ``--target=``, ``-m32`` affect; the search algorithm. For example, the aforementioned executable called with; ``-m32`` argument will instead search for::. i386-pc-linux-gnu-clang++.cfg. If none of the aforementioned files are found, the driver will instead search; for separate driver and target configuration files and attempt to load both.; The former is named ``<driver>.cfg`` while the latter is named; ``<triple>.cfg``. Similarly to the previous variants, the canonical driver name; will be preferred, and the compiler will fall back to the actual name. For example, ``x86_64-pc-linux-gnu-clang-g++`` will attempt to load two; configuration files named respectively::. clang++.cfg; x86_64-pc-linux-gnu.cfg. with fallback",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:33514,Modifiability,config,configuration,33514," the one found in the executable name. The following canonical driver names are used:. - ``clang`` for the ``gcc`` driver (used to compile C programs); - ``clang++`` for the ``gxx`` driver (used to compile C++ programs); - ``clang-cpp`` for the ``cpp`` driver (pure preprocessor); - ``clang-cl`` for the ``cl`` driver; - ``flang`` for the ``flang`` driver; - ``clang-dxc`` for the ``dxc`` driver. For example, when calling ``x86_64-pc-linux-gnu-clang-g++``,; the driver will first attempt to use the configuration file named::. x86_64-pc-linux-gnu-clang++.cfg. If this file is not found, it will attempt to use the name found; in the executable instead::. x86_64-pc-linux-gnu-clang-g++.cfg. Note that options such as ``--driver-mode=``, ``--target=``, ``-m32`` affect; the search algorithm. For example, the aforementioned executable called with; ``-m32`` argument will instead search for::. i386-pc-linux-gnu-clang++.cfg. If none of the aforementioned files are found, the driver will instead search; for separate driver and target configuration files and attempt to load both.; The former is named ``<driver>.cfg`` while the latter is named; ``<triple>.cfg``. Similarly to the previous variants, the canonical driver name; will be preferred, and the compiler will fall back to the actual name. For example, ``x86_64-pc-linux-gnu-clang-g++`` will attempt to load two; configuration files named respectively::. clang++.cfg; x86_64-pc-linux-gnu.cfg. with fallback to trying::. clang-g++.cfg; x86_64-pc-linux-gnu.cfg. It is not an error if either of these files is not found. The configuration file consists of command-line options specified on one or; more lines. Lines composed of whitespace characters only are ignored as well as; lines in which the first non-blank character is ``#``. Long options may be split; between several lines by a trailing backslash. Here is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:33850,Modifiability,config,configuration,33850,"ver; - ``clang-dxc`` for the ``dxc`` driver. For example, when calling ``x86_64-pc-linux-gnu-clang-g++``,; the driver will first attempt to use the configuration file named::. x86_64-pc-linux-gnu-clang++.cfg. If this file is not found, it will attempt to use the name found; in the executable instead::. x86_64-pc-linux-gnu-clang-g++.cfg. Note that options such as ``--driver-mode=``, ``--target=``, ``-m32`` affect; the search algorithm. For example, the aforementioned executable called with; ``-m32`` argument will instead search for::. i386-pc-linux-gnu-clang++.cfg. If none of the aforementioned files are found, the driver will instead search; for separate driver and target configuration files and attempt to load both.; The former is named ``<driver>.cfg`` while the latter is named; ``<triple>.cfg``. Similarly to the previous variants, the canonical driver name; will be preferred, and the compiler will fall back to the actual name. For example, ``x86_64-pc-linux-gnu-clang-g++`` will attempt to load two; configuration files named respectively::. clang++.cfg; x86_64-pc-linux-gnu.cfg. with fallback to trying::. clang-g++.cfg; x86_64-pc-linux-gnu.cfg. It is not an error if either of these files is not found. The configuration file consists of command-line options specified on one or; more lines. Lines composed of whitespace characters only are ignored as well as; lines in which the first non-blank character is ``#``. Long options may be split; between several lines by a trailing backslash. Here is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between lines; -I/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the fil",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:34059,Modifiability,config,configuration,34059,"me found; in the executable instead::. x86_64-pc-linux-gnu-clang-g++.cfg. Note that options such as ``--driver-mode=``, ``--target=``, ``-m32`` affect; the search algorithm. For example, the aforementioned executable called with; ``-m32`` argument will instead search for::. i386-pc-linux-gnu-clang++.cfg. If none of the aforementioned files are found, the driver will instead search; for separate driver and target configuration files and attempt to load both.; The former is named ``<driver>.cfg`` while the latter is named; ``<triple>.cfg``. Similarly to the previous variants, the canonical driver name; will be preferred, and the compiler will fall back to the actual name. For example, ``x86_64-pc-linux-gnu-clang-g++`` will attempt to load two; configuration files named respectively::. clang++.cfg; x86_64-pc-linux-gnu.cfg. with fallback to trying::. clang-g++.cfg; x86_64-pc-linux-gnu.cfg. It is not an error if either of these files is not found. The configuration file consists of command-line options specified on one or; more lines. Lines composed of whitespace characters only are ignored as well as; lines in which the first non-blank character is ``#``. Long options may be split; between several lines by a trailing backslash. Here is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between lines; -I/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:34364,Modifiability,config,configuration,34364,"rch for::. i386-pc-linux-gnu-clang++.cfg. If none of the aforementioned files are found, the driver will instead search; for separate driver and target configuration files and attempt to load both.; The former is named ``<driver>.cfg`` while the latter is named; ``<triple>.cfg``. Similarly to the previous variants, the canonical driver name; will be preferred, and the compiler will fall back to the actual name. For example, ``x86_64-pc-linux-gnu-clang-g++`` will attempt to load two; configuration files named respectively::. clang++.cfg; x86_64-pc-linux-gnu.cfg. with fallback to trying::. clang-g++.cfg; x86_64-pc-linux-gnu.cfg. It is not an error if either of these files is not found. The configuration file consists of command-line options specified on one or; more lines. Lines composed of whitespace characters only are ignored as well as; lines in which the first non-blank character is ``#``. Long options may be split; between several lines by a trailing backslash. Here is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between lines; -I/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate paths relative to the configuration file, the ``<CFGDIR>`` token may; be used. This will expand to the absolute path of the directory containing the; configuration file. In cases where a configuration file is deployed alongside SDK contents, the; SDK directory ca",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:34569,Modifiability,config,config,34569,"<driver>.cfg`` while the latter is named; ``<triple>.cfg``. Similarly to the previous variants, the canonical driver name; will be preferred, and the compiler will fall back to the actual name. For example, ``x86_64-pc-linux-gnu-clang-g++`` will attempt to load two; configuration files named respectively::. clang++.cfg; x86_64-pc-linux-gnu.cfg. with fallback to trying::. clang-g++.cfg; x86_64-pc-linux-gnu.cfg. It is not an error if either of these files is not found. The configuration file consists of command-line options specified on one or; more lines. Lines composed of whitespace characters only are ignored as well as; lines in which the first non-blank character is ``#``. Long options may be split; between several lines by a trailing backslash. Here is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between lines; -I/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate paths relative to the configuration file, the ``<CFGDIR>`` token may; be used. This will expand to the absolute path of the directory containing the; configuration file. In cases where a configuration file is deployed alongside SDK contents, the; SDK directory can remain fully portable by using ``<CFGDIR>`` prefixed paths.; In this way, the user may only need to specify a root configuration file with; ``--config=`` to establish every aspect of the SDK with the compiler:. ::. --t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:34657,Modifiability,config,configuration,34657," variants, the canonical driver name; will be preferred, and the compiler will fall back to the actual name. For example, ``x86_64-pc-linux-gnu-clang-g++`` will attempt to load two; configuration files named respectively::. clang++.cfg; x86_64-pc-linux-gnu.cfg. with fallback to trying::. clang-g++.cfg; x86_64-pc-linux-gnu.cfg. It is not an error if either of these files is not found. The configuration file consists of command-line options specified on one or; more lines. Lines composed of whitespace characters only are ignored as well as; lines in which the first non-blank character is ``#``. Long options may be split; between several lines by a trailing backslash. Here is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between lines; -I/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate paths relative to the configuration file, the ``<CFGDIR>`` token may; be used. This will expand to the absolute path of the directory containing the; configuration file. In cases where a configuration file is deployed alongside SDK contents, the; SDK directory can remain fully portable by using ``<CFGDIR>`` prefixed paths.; In this way, the user may only need to specify a root configuration file with; ``--config=`` to establish every aspect of the SDK with the compiler:. ::. --target=foo; -isystem <CFGDIR>/include; -L <CFGDIR>/lib; -T <CFGDIR>/ldscripts/link.ld.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:34741,Modifiability,config,configuration,34741,"ll fall back to the actual name. For example, ``x86_64-pc-linux-gnu-clang-g++`` will attempt to load two; configuration files named respectively::. clang++.cfg; x86_64-pc-linux-gnu.cfg. with fallback to trying::. clang-g++.cfg; x86_64-pc-linux-gnu.cfg. It is not an error if either of these files is not found. The configuration file consists of command-line options specified on one or; more lines. Lines composed of whitespace characters only are ignored as well as; lines in which the first non-blank character is ``#``. Long options may be split; between several lines by a trailing backslash. Here is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between lines; -I/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate paths relative to the configuration file, the ``<CFGDIR>`` token may; be used. This will expand to the absolute path of the directory containing the; configuration file. In cases where a configuration file is deployed alongside SDK contents, the; SDK directory can remain fully portable by using ``<CFGDIR>`` prefixed paths.; In this way, the user may only need to specify a root configuration file with; ``--config=`` to establish every aspect of the SDK with the compiler:. ::. --target=foo; -isystem <CFGDIR>/include; -L <CFGDIR>/lib; -T <CFGDIR>/ldscripts/link.ld. Language and Target-Independent Features; =================================",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:34977,Modifiability,config,config,34977," to trying::. clang-g++.cfg; x86_64-pc-linux-gnu.cfg. It is not an error if either of these files is not found. The configuration file consists of command-line options specified on one or; more lines. Lines composed of whitespace characters only are ignored as well as; lines in which the first non-blank character is ``#``. Long options may be split; between several lines by a trailing backslash. Here is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between lines; -I/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate paths relative to the configuration file, the ``<CFGDIR>`` token may; be used. This will expand to the absolute path of the directory containing the; configuration file. In cases where a configuration file is deployed alongside SDK contents, the; SDK directory can remain fully portable by using ``<CFGDIR>`` prefixed paths.; In this way, the user may only need to specify a root configuration file with; ``--config=`` to establish every aspect of the SDK with the compiler:. ::. --target=foo; -isystem <CFGDIR>/include; -L <CFGDIR>/lib; -T <CFGDIR>/ldscripts/link.ld. Language and Target-Independent Features; ========================================. Controlling Errors and Warnings; -------------------------------. Clang provides a number of ways to control which code constructs cause; it to emit errors and warning messages, and how they ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:35066,Modifiability,config,configuration,35066,"les is not found. The configuration file consists of command-line options specified on one or; more lines. Lines composed of whitespace characters only are ignored as well as; lines in which the first non-blank character is ``#``. Long options may be split; between several lines by a trailing backslash. Here is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between lines; -I/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate paths relative to the configuration file, the ``<CFGDIR>`` token may; be used. This will expand to the absolute path of the directory containing the; configuration file. In cases where a configuration file is deployed alongside SDK contents, the; SDK directory can remain fully portable by using ``<CFGDIR>`` prefixed paths.; In this way, the user may only need to specify a root configuration file with; ``--config=`` to establish every aspect of the SDK with the compiler:. ::. --target=foo; -isystem <CFGDIR>/include; -L <CFGDIR>/lib; -T <CFGDIR>/ldscripts/link.ld. Language and Target-Independent Features; ========================================. Controlling Errors and Warnings; -------------------------------. Clang provides a number of ways to control which code constructs cause; it to emit errors and warning messages, and how they are displayed to; the console. Controlling How Clang Displays Diagnostics; ^^^^^^^^^^^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:35122,Modifiability,config,configuration,35122,"more lines. Lines composed of whitespace characters only are ignored as well as; lines in which the first non-blank character is ``#``. Long options may be split; between several lines by a trailing backslash. Here is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between lines; -I/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate paths relative to the configuration file, the ``<CFGDIR>`` token may; be used. This will expand to the absolute path of the directory containing the; configuration file. In cases where a configuration file is deployed alongside SDK contents, the; SDK directory can remain fully portable by using ``<CFGDIR>`` prefixed paths.; In this way, the user may only need to specify a root configuration file with; ``--config=`` to establish every aspect of the SDK with the compiler:. ::. --target=foo; -isystem <CFGDIR>/include; -L <CFGDIR>/lib; -T <CFGDIR>/ldscripts/link.ld. Language and Target-Independent Features; ========================================. Controlling Errors and Warnings; -------------------------------. Clang provides a number of ways to control which code constructs cause; it to emit errors and warning messages, and how they are displayed to; the console. Controlling How Clang Displays Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When Clang emits a diagnostic, it includes rich information in the; ou",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:35250,Modifiability,config,configuration,35250,"hich the first non-blank character is ``#``. Long options may be split; between several lines by a trailing backslash. Here is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between lines; -I/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate paths relative to the configuration file, the ``<CFGDIR>`` token may; be used. This will expand to the absolute path of the directory containing the; configuration file. In cases where a configuration file is deployed alongside SDK contents, the; SDK directory can remain fully portable by using ``<CFGDIR>`` prefixed paths.; In this way, the user may only need to specify a root configuration file with; ``--config=`` to establish every aspect of the SDK with the compiler:. ::. --target=foo; -isystem <CFGDIR>/include; -L <CFGDIR>/lib; -T <CFGDIR>/ldscripts/link.ld. Language and Target-Independent Features; ========================================. Controlling Errors and Warnings; -------------------------------. Clang provides a number of ways to control which code constructs cause; it to emit errors and warning messages, and how they are displayed to; the console. Controlling How Clang Displays Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When Clang emits a diagnostic, it includes rich information in the; output, and gives you fine-grain control over which information is; printed. Clang has the ab",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:35287,Modifiability,config,configuration,35287," is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between lines; -I/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate paths relative to the configuration file, the ``<CFGDIR>`` token may; be used. This will expand to the absolute path of the directory containing the; configuration file. In cases where a configuration file is deployed alongside SDK contents, the; SDK directory can remain fully portable by using ``<CFGDIR>`` prefixed paths.; In this way, the user may only need to specify a root configuration file with; ``--config=`` to establish every aspect of the SDK with the compiler:. ::. --target=foo; -isystem <CFGDIR>/include; -L <CFGDIR>/lib; -T <CFGDIR>/ldscripts/link.ld. Language and Target-Independent Features; ========================================. Controlling Errors and Warnings; -------------------------------. Clang provides a number of ways to control which code constructs cause; it to emit errors and warning messages, and how they are displayed to; the console. Controlling How Clang Displays Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When Clang emits a diagnostic, it includes rich information in the; output, and gives you fine-grain control over which information is; printed. Clang has the ability to print this information, and these are; the options that control it:. #. A file/line/column indicator that shows ex",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:35378,Modifiability,portab,portable,35378," is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between lines; -I/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate paths relative to the configuration file, the ``<CFGDIR>`` token may; be used. This will expand to the absolute path of the directory containing the; configuration file. In cases where a configuration file is deployed alongside SDK contents, the; SDK directory can remain fully portable by using ``<CFGDIR>`` prefixed paths.; In this way, the user may only need to specify a root configuration file with; ``--config=`` to establish every aspect of the SDK with the compiler:. ::. --target=foo; -isystem <CFGDIR>/include; -L <CFGDIR>/lib; -T <CFGDIR>/ldscripts/link.ld. Language and Target-Independent Features; ========================================. Controlling Errors and Warnings; -------------------------------. Clang provides a number of ways to control which code constructs cause; it to emit errors and warning messages, and how they are displayed to; the console. Controlling How Clang Displays Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When Clang emits a diagnostic, it includes rich information in the; output, and gives you fine-grain control over which information is; printed. Clang has the ability to print this information, and these are; the options that control it:. #. A file/line/column indicator that shows ex",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:35480,Modifiability,config,configuration,35480,"/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate paths relative to the configuration file, the ``<CFGDIR>`` token may; be used. This will expand to the absolute path of the directory containing the; configuration file. In cases where a configuration file is deployed alongside SDK contents, the; SDK directory can remain fully portable by using ``<CFGDIR>`` prefixed paths.; In this way, the user may only need to specify a root configuration file with; ``--config=`` to establish every aspect of the SDK with the compiler:. ::. --target=foo; -isystem <CFGDIR>/include; -L <CFGDIR>/lib; -T <CFGDIR>/ldscripts/link.ld. Language and Target-Independent Features; ========================================. Controlling Errors and Warnings; -------------------------------. Clang provides a number of ways to control which code constructs cause; it to emit errors and warning messages, and how they are displayed to; the console. Controlling How Clang Displays Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When Clang emits a diagnostic, it includes rich information in the; output, and gives you fine-grain control over which information is; printed. Clang has the ability to print this information, and these are; the options that control it:. #. A file/line/column indicator that shows exactly where the diagnostic; occurs in your code [:ref:`-fshow-column <opt_fshow-column>`,; :ref:`-fshow-source-location <opt_fshow-source-location>`].; #",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:35509,Modifiability,config,config,35509,"/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the file; ``linux.opts`` is searched for in the directory ``~/.llvm/os``. Another way to; include a file content is using the command line option ``--config=``. It works; similarly but the included file is searched for using the rules for configuration; files. To generate paths relative to the configuration file, the ``<CFGDIR>`` token may; be used. This will expand to the absolute path of the directory containing the; configuration file. In cases where a configuration file is deployed alongside SDK contents, the; SDK directory can remain fully portable by using ``<CFGDIR>`` prefixed paths.; In this way, the user may only need to specify a root configuration file with; ``--config=`` to establish every aspect of the SDK with the compiler:. ::. --target=foo; -isystem <CFGDIR>/include; -L <CFGDIR>/lib; -T <CFGDIR>/ldscripts/link.ld. Language and Target-Independent Features; ========================================. Controlling Errors and Warnings; -------------------------------. Clang provides a number of ways to control which code constructs cause; it to emit errors and warning messages, and how they are displayed to; the console. Controlling How Clang Displays Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. When Clang emits a diagnostic, it includes rich information in the; output, and gives you fine-grain control over which information is; printed. Clang has the ability to print this information, and these are; the options that control it:. #. A file/line/column indicator that shows exactly where the diagnostic; occurs in your code [:ref:`-fshow-column <opt_fshow-column>`,; :ref:`-fshow-source-location <opt_fshow-source-location>`].; #",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:61428,Modifiability,variab,variables,61428,"Force floating-point operations to honor the dynamically-set rounding mode by default. The result of a floating-point operation often cannot be exactly represented in the result type and therefore must be rounded. IEEE 754 describes different rounding modes that control how to perform this rounding, not all of which are supported by all implementations. C provides interfaces (``fesetround`` and ``fesetenv``) for dynamically controlling the rounding mode, and while it also recommends certain conventions for changing the rounding mode, these conventions are not typically enforced in the ABI. Since the rounding mode changes the numerical result of operations, the compiler must understand something about it in order to optimize floating point operations. Note that floating-point operations performed as part of constant initialization are formally performed prior to the start of the program and are therefore not subject to the current rounding mode. This includes the initialization of global variables and local ``static`` variables. Floating-point operations in these contexts will be rounded using ``FE_TONEAREST``. - The option ``-fno-rounding-math`` allows the compiler to assume that the rounding mode is set to ``FE_TONEAREST``. This is the default.; - The option ``-frounding-math`` forces the compiler to honor the dynamically-set rounding mode. This prevents optimizations which might affect results if the rounding mode changes or is different from the default; for example, it prevents floating-point operations from being reordered across most calls and prevents constant-folding when the result is not exactly representable. .. option:: -ffp-model=<value>. Specify floating point behavior. ``-ffp-model`` is an umbrella; option that encompasses functionality provided by other, single; purpose, floating point options. Valid values are: ``precise``, ``strict``,; and ``fast``.; Details:. * ``precise`` Disables optimizations that are not value-safe on; floating-point data, alth",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:61459,Modifiability,variab,variables,61459,"Force floating-point operations to honor the dynamically-set rounding mode by default. The result of a floating-point operation often cannot be exactly represented in the result type and therefore must be rounded. IEEE 754 describes different rounding modes that control how to perform this rounding, not all of which are supported by all implementations. C provides interfaces (``fesetround`` and ``fesetenv``) for dynamically controlling the rounding mode, and while it also recommends certain conventions for changing the rounding mode, these conventions are not typically enforced in the ABI. Since the rounding mode changes the numerical result of operations, the compiler must understand something about it in order to optimize floating point operations. Note that floating-point operations performed as part of constant initialization are formally performed prior to the start of the program and are therefore not subject to the current rounding mode. This includes the initialization of global variables and local ``static`` variables. Floating-point operations in these contexts will be rounded using ``FE_TONEAREST``. - The option ``-fno-rounding-math`` allows the compiler to assume that the rounding mode is set to ``FE_TONEAREST``. This is the default.; - The option ``-frounding-math`` forces the compiler to honor the dynamically-set rounding mode. This prevents optimizations which might affect results if the rounding mode changes or is different from the default; for example, it prevents floating-point operations from being reordered across most calls and prevents constant-folding when the result is not exactly representable. .. option:: -ffp-model=<value>. Specify floating point behavior. ``-ffp-model`` is an umbrella; option that encompasses functionality provided by other, single; purpose, floating point options. Valid values are: ``precise``, ``strict``,; and ``fast``.; Details:. * ``precise`` Disables optimizations that are not value-safe on; floating-point data, alth",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:64276,Modifiability,extend,extended,64276,"ffect of negating part of the ``ffp-model`` that; has been selected, then the compiler will issue a diagnostic warning; that the override has occurred. .. option:: -ffp-exception-behavior=<value>. Specify the floating-point exception behavior. Valid values are: ``ignore``, ``maytrap``, and ``strict``.; The default value is ``ignore``. Details:. * ``ignore`` The compiler assumes that the exception status flags will not be read and that floating point exceptions will be masked.; * ``maytrap`` The compiler avoids transformations that may raise exceptions that would not have been raised by the original code. Constant folding performed by the compiler is exempt from this option.; * ``strict`` The compiler ensures that all transformations strictly preserve the floating point exception semantics of the original code. .. option:: -ffp-eval-method=<value>. Specify the floating-point evaluation method for intermediate results within; a single expression of the code. Valid values are: ``source``, ``double``, and ``extended``.; For 64-bit targets, the default value is ``source``. For 32-bit x86 targets; however, in the case of NETBSD 6.99.26 and under, the default value is; ``double``; in the case of NETBSD greater than 6.99.26, with NoSSE, the; default value is ``extended``, with SSE the default value is ``source``.; Details:. * ``source`` The compiler uses the floating-point type declared in the source program as the evaluation method.; * ``double`` The compiler uses ``double`` as the floating-point evaluation method for all float expressions of type that is narrower than ``double``.; * ``extended`` The compiler uses ``long double`` as the floating-point evaluation method for all float expressions of type that is narrower than ``long double``. .. option:: -f[no-]protect-parens. This option pertains to floating-point types, complex types with; floating-point components, and vectors of these types. Some arithmetic; expression transformations that are mathematically correct and ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:64530,Modifiability,extend,extended,64530,"trap``, and ``strict``.; The default value is ``ignore``. Details:. * ``ignore`` The compiler assumes that the exception status flags will not be read and that floating point exceptions will be masked.; * ``maytrap`` The compiler avoids transformations that may raise exceptions that would not have been raised by the original code. Constant folding performed by the compiler is exempt from this option.; * ``strict`` The compiler ensures that all transformations strictly preserve the floating point exception semantics of the original code. .. option:: -ffp-eval-method=<value>. Specify the floating-point evaluation method for intermediate results within; a single expression of the code. Valid values are: ``source``, ``double``, and ``extended``.; For 64-bit targets, the default value is ``source``. For 32-bit x86 targets; however, in the case of NETBSD 6.99.26 and under, the default value is; ``double``; in the case of NETBSD greater than 6.99.26, with NoSSE, the; default value is ``extended``, with SSE the default value is ``source``.; Details:. * ``source`` The compiler uses the floating-point type declared in the source program as the evaluation method.; * ``double`` The compiler uses ``double`` as the floating-point evaluation method for all float expressions of type that is narrower than ``double``.; * ``extended`` The compiler uses ``long double`` as the floating-point evaluation method for all float expressions of type that is narrower than ``long double``. .. option:: -f[no-]protect-parens. This option pertains to floating-point types, complex types with; floating-point components, and vectors of these types. Some arithmetic; expression transformations that are mathematically correct and permissible; according to the C and C++ language standards may be incorrect when dealing; with floating-point types, such as reassociation and distribution. Further,; the optimizer may ignore parentheses when computing arithmetic expressions; in circumstances where the parenthesi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:64863,Modifiability,extend,extended,64863,".; * ``strict`` The compiler ensures that all transformations strictly preserve the floating point exception semantics of the original code. .. option:: -ffp-eval-method=<value>. Specify the floating-point evaluation method for intermediate results within; a single expression of the code. Valid values are: ``source``, ``double``, and ``extended``.; For 64-bit targets, the default value is ``source``. For 32-bit x86 targets; however, in the case of NETBSD 6.99.26 and under, the default value is; ``double``; in the case of NETBSD greater than 6.99.26, with NoSSE, the; default value is ``extended``, with SSE the default value is ``source``.; Details:. * ``source`` The compiler uses the floating-point type declared in the source program as the evaluation method.; * ``double`` The compiler uses ``double`` as the floating-point evaluation method for all float expressions of type that is narrower than ``double``.; * ``extended`` The compiler uses ``long double`` as the floating-point evaluation method for all float expressions of type that is narrower than ``long double``. .. option:: -f[no-]protect-parens. This option pertains to floating-point types, complex types with; floating-point components, and vectors of these types. Some arithmetic; expression transformations that are mathematically correct and permissible; according to the C and C++ language standards may be incorrect when dealing; with floating-point types, such as reassociation and distribution. Further,; the optimizer may ignore parentheses when computing arithmetic expressions; in circumstances where the parenthesized and unparenthesized expression; express the same mathematical value. For example (a+b)+c is the same; mathematical value as a+(b+c), but the optimizer is free to evaluate the; additions in any order regardless of the parentheses. When enabled, this; option forces the optimizer to honor the order of operations with respect; to parentheses in all circumstances.; Defaults to ``-fno-protect-parens``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:69094,Modifiability,config,configured,69094," C++ standards. Has no effect except on; the types and targets listed above.; * ``fast`` - Accepted for GCC compatibility, but currently treated as an; alias for ``standard``.; * ``16`` - Forces ``_Float16`` operations to be emitted without using excess; precision arithmetic. .. option:: -fcx-limited-range:. This option enables the naive mathematical formulas for complex division and; multiplication with no NaN checking of results. The default is; ``-fno-cx-limited-range``, but this option is enabled by the ``-ffast-math``; option. .. option:: -fcx-fortran-rules:. This option enables the naive mathematical formulas for complex; multiplication and enables application of Smith's algorithm for complex; division. See SMITH, R. L. Algorithm 116: Complex division. Commun.; ACM 5, 8 (1962). The default is ``-fno-cx-fortran-rules``. .. _floating-point-environment:. Accessing the floating point environment; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; Many targets allow floating point operations to be configured to control things; such as how inexact results should be rounded and how exceptional conditions; should be handled. This configuration is called the floating point environment.; C and C++ restrict access to the floating point environment by default, and the; compiler is allowed to assume that all operations are performed in the default; environment. When code is compiled in this default mode, operations that depend; on the environment (such as floating-point arithmetic and `FLT_ROUNDS`) may have; undefined behavior if the dynamic environment is not the default environment; for; example, `FLT_ROUNDS` may or may not simply return its default value for the target; instead of reading the dynamic environment, and floating-point operations may be; optimized as if the dynamic environment were the default. Similarly, it is undefined; behavior to change the floating point environment in this default mode, for example; by calling the `fesetround` function.; C provides two pragmas",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:69226,Modifiability,config,configuration,69226," ``standard``.; * ``16`` - Forces ``_Float16`` operations to be emitted without using excess; precision arithmetic. .. option:: -fcx-limited-range:. This option enables the naive mathematical formulas for complex division and; multiplication with no NaN checking of results. The default is; ``-fno-cx-limited-range``, but this option is enabled by the ``-ffast-math``; option. .. option:: -fcx-fortran-rules:. This option enables the naive mathematical formulas for complex; multiplication and enables application of Smith's algorithm for complex; division. See SMITH, R. L. Algorithm 116: Complex division. Commun.; ACM 5, 8 (1962). The default is ``-fno-cx-fortran-rules``. .. _floating-point-environment:. Accessing the floating point environment; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; Many targets allow floating point operations to be configured to control things; such as how inexact results should be rounded and how exceptional conditions; should be handled. This configuration is called the floating point environment.; C and C++ restrict access to the floating point environment by default, and the; compiler is allowed to assume that all operations are performed in the default; environment. When code is compiled in this default mode, operations that depend; on the environment (such as floating-point arithmetic and `FLT_ROUNDS`) may have; undefined behavior if the dynamic environment is not the default environment; for; example, `FLT_ROUNDS` may or may not simply return its default value for the target; instead of reading the dynamic environment, and floating-point operations may be; optimized as if the dynamic environment were the default. Similarly, it is undefined; behavior to change the floating point environment in this default mode, for example; by calling the `fesetround` function.; C provides two pragmas to allow code to dynamically modify the floating point environment:. - ``#pragma STDC FENV_ACCESS ON`` allows dynamic changes to the entire floating; point envir",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:72898,Modifiability,variab,variables,72898,"d in the program. .. _FLT_EVAL_METHOD:. A note about ``__FLT_EVAL_METHOD__``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; The ``__FLT_EVAL_METHOD__`` is not defined as a traditional macro, and so it; will not appear when dumping preprocessor macros. Instead, the value; ``__FLT_EVAL_METHOD__`` expands to is determined at the point of expansion; either from the value set by the ``-ffp-eval-method`` command line option or; from the target. This is because the ``__FLT_EVAL_METHOD__`` macro; cannot expand to the correct evaluation method in the presence of a ``#pragma``; which alters the evaluation method. An error is issued if; ``__FLT_EVAL_METHOD__`` is expanded inside a scope modified by; ``#pragma clang fp eval_method``. .. _fp-constant-eval:. A note about Floating Point Constant Evaluation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In C, the only place floating point operations are guaranteed to be evaluated; during translation is in the initializers of variables of static storage; duration, which are all notionally initialized before the program begins; executing (and thus before a non-default floating point environment can be; entered). But C++ has many more contexts where floating point constant; evaluation occurs. Specifically: for static/thread-local variables,; first try evaluating the initializer in a constant context, including in the; constant floating point environment (just like in C), and then, if that fails,; fall back to emitting runtime code to perform the initialization (which might; in general be in a different floating point environment). Consider this example when compiled with ``-frounding-math``. .. code-block:: console. constexpr float func_01(float x, float y) {; return x + y;; }; float V1 = func_01(1.0F, 0x0.000001p0F);. The C++ rule is that initializers for static storage duration variables are; first evaluated during translation (therefore, in the default rounding mode),; and only evaluated at runtime (and therefore in the runtime rounding ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:73206,Modifiability,variab,variables,73206,"ion or; from the target. This is because the ``__FLT_EVAL_METHOD__`` macro; cannot expand to the correct evaluation method in the presence of a ``#pragma``; which alters the evaluation method. An error is issued if; ``__FLT_EVAL_METHOD__`` is expanded inside a scope modified by; ``#pragma clang fp eval_method``. .. _fp-constant-eval:. A note about Floating Point Constant Evaluation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In C, the only place floating point operations are guaranteed to be evaluated; during translation is in the initializers of variables of static storage; duration, which are all notionally initialized before the program begins; executing (and thus before a non-default floating point environment can be; entered). But C++ has many more contexts where floating point constant; evaluation occurs. Specifically: for static/thread-local variables,; first try evaluating the initializer in a constant context, including in the; constant floating point environment (just like in C), and then, if that fails,; fall back to emitting runtime code to perform the initialization (which might; in general be in a different floating point environment). Consider this example when compiled with ``-frounding-math``. .. code-block:: console. constexpr float func_01(float x, float y) {; return x + y;; }; float V1 = func_01(1.0F, 0x0.000001p0F);. The C++ rule is that initializers for static storage duration variables are; first evaluated during translation (therefore, in the default rounding mode),; and only evaluated at runtime (and therefore in the runtime rounding mode) if; the compile-time evaluation fails. This is in line with the C rules;; C11 F.8.5 says: *All computation for automatic initialization is done (as if); at execution time; thus, it is affected by any operative modes and raises; floating-point exceptions as required by IEC 60559 (provided the state for the; FENV_ACCESS pragma is ‘‘on’’). All computation for initialization of objects; that have static o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:73767,Modifiability,variab,variables,73767,"be evaluated; during translation is in the initializers of variables of static storage; duration, which are all notionally initialized before the program begins; executing (and thus before a non-default floating point environment can be; entered). But C++ has many more contexts where floating point constant; evaluation occurs. Specifically: for static/thread-local variables,; first try evaluating the initializer in a constant context, including in the; constant floating point environment (just like in C), and then, if that fails,; fall back to emitting runtime code to perform the initialization (which might; in general be in a different floating point environment). Consider this example when compiled with ``-frounding-math``. .. code-block:: console. constexpr float func_01(float x, float y) {; return x + y;; }; float V1 = func_01(1.0F, 0x0.000001p0F);. The C++ rule is that initializers for static storage duration variables are; first evaluated during translation (therefore, in the default rounding mode),; and only evaluated at runtime (and therefore in the runtime rounding mode) if; the compile-time evaluation fails. This is in line with the C rules;; C11 F.8.5 says: *All computation for automatic initialization is done (as if); at execution time; thus, it is affected by any operative modes and raises; floating-point exceptions as required by IEC 60559 (provided the state for the; FENV_ACCESS pragma is ‘‘on’’). All computation for initialization of objects; that have static or thread storage duration is done (as if) at translation; time.* C++ generalizes this by adding another phase of initialization; (at runtime) if the translation-time initialization fails, but the; translation-time evaluation of the initializer of succeeds, it will be; treated as a constant initializer. .. _controlling-code-generation:. Controlling Code Generation; ---------------------------. Clang provides a number of ways to control code generation. The options; are listed below. .. option:: ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:77297,Modifiability,config,configured,77297,"in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:78492,Modifiability,variab,variables,78492,"ith; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sanitizers.; See :doc:`SanitizerCoverage` for more details. .. option:: -f[no-]sanitize-address-outline-instrumentation. Controls how address sanitizer code is generated. If enabled will always use; a function call instead of inlining the code. Turning this option on could; reduce the binary size, but might result in a worse run-time performance. See :doc: `AddressSanitizer` for more details. .. option:: -f[no-]sanitize-stats. Enable simple statistics gathering for the enabled sanitizers.; See :doc:`SanitizerStats` for more details. .. option:: -fsanitize-undefined-trap-on-error. Deprecated alias for ``-fsanitize-trap=undefined``. .. option:: -fs",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:80305,Modifiability,polymorphi,polymorphic,80305,"r the enabled sanitizers.; See :doc:`SanitizerStats` for more details. .. option:: -fsanitize-undefined-trap-on-error. Deprecated alias for ``-fsanitize-trap=undefined``. .. option:: -fsanitize-cfi-cross-dso. Enable cross-DSO control flow integrity checks. This flag modifies; the behavior of sanitizers in the ``cfi`` group to allow checking; of cross-DSO virtual and indirect calls. .. option:: -fsanitize-cfi-icall-generalize-pointers. Generalize pointers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more details. .. option:: -fsanitize-cfi-icall-experimental-normalize-integers. Normalize integers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more details. This option is currently experimental. .. option:: -fstrict-vtable-pointers. Enable optimizations based on the strict rules for overwriting polymorphic; C++ objects, i.e. the vptr is invariant during an object's lifetime.; This enables better devirtualization. Turned off by default, because it is; still experimental. .. option:: -fwhole-program-vtables. Enable whole-program vtable optimizations, such as single-implementation; devirtualization and virtual constant propagation, for classes with; :doc:`hidden LTO visibility <LTOVisibility>`. Requires ``-flto``. .. option:: -f[no]split-lto-unit. Controls splitting the :doc:`LTO unit <LTOVisibility>` into regular LTO and; :doc:`ThinLTO` portions, when compiling with -flto=thin. Defaults to false; unless ``-fsanitize=cfi`` or ``-fwhole-program-vtables`` are specified, in; which case it defaults to true. Splitting is required with ``fsanitize=cfi``,; and it is an error to disable via ``-fno-split-lto-unit``. Splitting is; optional with ``-fwhole-program-vtables``, however, it enables more; aggressive whole program vtable optimizations (specifically virtual const",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:82558,Modifiability,variab,variables,82558," the LTO link time and memory requirements over; pure ThinLTO, as all split regular LTO modules are merged and LTO linked; with regular LTO. .. option:: -fforce-emit-vtables. In order to improve devirtualization, forces emitting of vtables even in; modules where it isn't necessary. It causes more inline virtual functions; to be emitted. .. option:: -fno-assume-sane-operator-new. Don't assume that the C++'s new operator is sane. This option tells the compiler to do not assume that C++'s global; new operator will always return a pointer that does not alias any; other pointer when the function returns. .. option:: -fassume-nothrow-exception-dtor. Assume that an exception object' destructor will not throw, and generate; less code for catch handlers. A throw expression of a type with a; potentially-throwing destructor will lead to an error. By default, Clang assumes that the exception object may have a throwing; destructor. For the Itanium C++ ABI, Clang generates a landing pad to; destroy local variables and call ``_Unwind_Resume`` for the code; ``catch (...) { ... }``. This option tells Clang that an exception object's; destructor will not throw and code simplification is possible. .. option:: -ftrap-function=[name]. Instruct code generator to emit a function call to the specified; function name for ``__builtin_trap()``. LLVM code generator translates ``__builtin_trap()`` to a trap; instruction if it is supported by the target ISA. Otherwise, the; builtin is translated into a call to ``abort``. If this option is; set, then the code generator will always lower the builtin to a call; to the specified function regardless of whether the target ISA has a; trap instruction. This option is useful for environments (e.g.; deeply embedded) where a trap cannot be properly handled, or when; some custom behavior is desired. .. option:: -ftls-model=[model]. Select which TLS model to use. Valid values are: ``global-dynamic``, ``local-dynamic``,; ``initial-exec`` and ``local-exec``. T",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:83767,Modifiability,variab,variable,83767,"function=[name]. Instruct code generator to emit a function call to the specified; function name for ``__builtin_trap()``. LLVM code generator translates ``__builtin_trap()`` to a trap; instruction if it is supported by the target ISA. Otherwise, the; builtin is translated into a call to ``abort``. If this option is; set, then the code generator will always lower the builtin to a call; to the specified function regardless of whether the target ISA has a; trap instruction. This option is useful for environments (e.g.; deeply embedded) where a trap cannot be properly handled, or when; some custom behavior is desired. .. option:: -ftls-model=[model]. Select which TLS model to use. Valid values are: ``global-dynamic``, ``local-dynamic``,; ``initial-exec`` and ``local-exec``. The default value is; ``global-dynamic``. The compiler may use a different model if the; selected model is not supported by the target, or if a more; efficient model can be used. The TLS model can be overridden per; variable using the ``tls_model`` attribute. .. option:: -femulated-tls. Select emulated TLS model, which overrides all -ftls-model choices. In emulated TLS mode, all access to TLS variables are converted to; calls to __emutls_get_address in the runtime library. .. option:: -mhwdiv=[values]. Select the ARM modes (arm or thumb) that support hardware division; instructions. Valid values are: ``arm``, ``thumb`` and ``arm,thumb``.; This option is used to indicate which mode (arm or thumb) supports; hardware division instructions. This only applies to the ARM; architecture. .. option:: -m[no-]crc. Enable or disable CRC instructions. This option is used to indicate whether CRC instructions are to; be generated. This only applies to the ARM architecture. CRC instructions are enabled by default on ARMv8. .. option:: -mgeneral-regs-only. Generate code which only uses the general purpose registers. This option restricts the generated code to use general registers; only. This only applies to the AArc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:83947,Modifiability,variab,variables,83947,"if it is supported by the target ISA. Otherwise, the; builtin is translated into a call to ``abort``. If this option is; set, then the code generator will always lower the builtin to a call; to the specified function regardless of whether the target ISA has a; trap instruction. This option is useful for environments (e.g.; deeply embedded) where a trap cannot be properly handled, or when; some custom behavior is desired. .. option:: -ftls-model=[model]. Select which TLS model to use. Valid values are: ``global-dynamic``, ``local-dynamic``,; ``initial-exec`` and ``local-exec``. The default value is; ``global-dynamic``. The compiler may use a different model if the; selected model is not supported by the target, or if a more; efficient model can be used. The TLS model can be overridden per; variable using the ``tls_model`` attribute. .. option:: -femulated-tls. Select emulated TLS model, which overrides all -ftls-model choices. In emulated TLS mode, all access to TLS variables are converted to; calls to __emutls_get_address in the runtime library. .. option:: -mhwdiv=[values]. Select the ARM modes (arm or thumb) that support hardware division; instructions. Valid values are: ``arm``, ``thumb`` and ``arm,thumb``.; This option is used to indicate which mode (arm or thumb) supports; hardware division instructions. This only applies to the ARM; architecture. .. option:: -m[no-]crc. Enable or disable CRC instructions. This option is used to indicate whether CRC instructions are to; be generated. This only applies to the ARM architecture. CRC instructions are enabled by default on ARMv8. .. option:: -mgeneral-regs-only. Generate code which only uses the general purpose registers. This option restricts the generated code to use general registers; only. This only applies to the AArch64 architecture. .. option:: -mcompact-branches=[values]. Control the usage of compact branches for MIPSR6. Valid values are: ``never``, ``optimal`` and ``always``.; The default value is ``optimal",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:85397,Modifiability,variab,variable,85397,"ption is used to indicate whether CRC instructions are to; be generated. This only applies to the ARM architecture. CRC instructions are enabled by default on ARMv8. .. option:: -mgeneral-regs-only. Generate code which only uses the general purpose registers. This option restricts the generated code to use general registers; only. This only applies to the AArch64 architecture. .. option:: -mcompact-branches=[values]. Control the usage of compact branches for MIPSR6. Valid values are: ``never``, ``optimal`` and ``always``.; The default value is ``optimal`` which generates compact branches; when a delay slot cannot be filled. ``never`` disables the usage of; compact branches and ``always`` generates compact branches whenever; possible. .. option:: -f[no-]max-type-align=[number]. Instruct the code generator to not enforce a higher alignment than the given; number (of bytes) when accessing memory via an opaque pointer or reference.; This cap is ignored when directly accessing a variable or when the pointee; type has an explicit “aligned” attribute. The value should usually be determined by the properties of the system allocator.; Some builtin types, especially vector types, have very high natural alignments;; when working with values of those types, Clang usually wants to use instructions; that take advantage of that alignment. However, many system allocators do; not promise to return memory that is more than 8-byte or 16-byte-aligned. Use; this option to limit the alignment that the compiler can assume for an arbitrary; pointer, which may point onto the heap. This option does not affect the ABI alignment of types; the layout of structs and; unions and the value returned by the alignof operator remain the same. This option can be overridden on a case-by-case basis by putting an explicit; “aligned” alignment on a struct, union, or typedef. For example:. .. code-block:: console. #include <immintrin.h>; // Make an aligned typedef of the AVX-512 16-int vector type.; typedef ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:103942,Modifiability,variab,variable,103942,"ller raw profile size, and; better runtime performance. Frontend-based instrumentation, on the other hand,; has better source correlation, so it should be used with source line-based; coverage testing. The flag ``-fcs-profile-generate`` also instruments programs using the same; instrumentation method as ``-fprofile-generate``. However, it performs a; post-inline late instrumentation and can produce context-sensitive profiles. Here are the steps for using profile guided optimization with; instrumentation:. 1. Build an instrumented version of the code by compiling and linking with the; ``-fprofile-generate`` or ``-fprofile-instr-generate`` option. .. code-block:: console. $ clang++ -O2 -fprofile-instr-generate code.cc -o code. 2. Run the instrumented executable with inputs that reflect the typical usage.; By default, the profile data will be written to a ``default.profraw`` file; in the current directory. You can override that default by using option; ``-fprofile-instr-generate=`` or by setting the ``LLVM_PROFILE_FILE``; environment variable to specify an alternate file. If non-default file name; is specified by both the environment variable and the command line option,; the environment variable takes precedence. The file name pattern specified; can include different modifiers: ``%p``, ``%h``, ``%m``, ``%t``, and ``%c``. Any instance of ``%p`` in that file name will be replaced by the process; ID, so that you can easily distinguish the profile output from multiple; runs. .. code-block:: console. $ LLVM_PROFILE_FILE=""code-%p.profraw"" ./code. The modifier ``%h`` can be used in scenarios where the same instrumented; binary is run in multiple different host machines dumping profile data; to a shared network based storage. The ``%h`` specifier will be substituted; with the hostname so that profiles collected from different hosts do not; clobber each other. While the use of ``%p`` specifier can reduce the likelihood for the profiles; dumped from different processes to clobbe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:104044,Modifiability,variab,variable,104044,"ed with source line-based; coverage testing. The flag ``-fcs-profile-generate`` also instruments programs using the same; instrumentation method as ``-fprofile-generate``. However, it performs a; post-inline late instrumentation and can produce context-sensitive profiles. Here are the steps for using profile guided optimization with; instrumentation:. 1. Build an instrumented version of the code by compiling and linking with the; ``-fprofile-generate`` or ``-fprofile-instr-generate`` option. .. code-block:: console. $ clang++ -O2 -fprofile-instr-generate code.cc -o code. 2. Run the instrumented executable with inputs that reflect the typical usage.; By default, the profile data will be written to a ``default.profraw`` file; in the current directory. You can override that default by using option; ``-fprofile-instr-generate=`` or by setting the ``LLVM_PROFILE_FILE``; environment variable to specify an alternate file. If non-default file name; is specified by both the environment variable and the command line option,; the environment variable takes precedence. The file name pattern specified; can include different modifiers: ``%p``, ``%h``, ``%m``, ``%t``, and ``%c``. Any instance of ``%p`` in that file name will be replaced by the process; ID, so that you can easily distinguish the profile output from multiple; runs. .. code-block:: console. $ LLVM_PROFILE_FILE=""code-%p.profraw"" ./code. The modifier ``%h`` can be used in scenarios where the same instrumented; binary is run in multiple different host machines dumping profile data; to a shared network based storage. The ``%h`` specifier will be substituted; with the hostname so that profiles collected from different hosts do not; clobber each other. While the use of ``%p`` specifier can reduce the likelihood for the profiles; dumped from different processes to clobber each other, such clobbering can still; happen because of the ``pid`` re-use by the OS. Another side-effect of using; ``%p`` is that the storage requirement",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:104099,Modifiability,variab,variable,104099,"ed with source line-based; coverage testing. The flag ``-fcs-profile-generate`` also instruments programs using the same; instrumentation method as ``-fprofile-generate``. However, it performs a; post-inline late instrumentation and can produce context-sensitive profiles. Here are the steps for using profile guided optimization with; instrumentation:. 1. Build an instrumented version of the code by compiling and linking with the; ``-fprofile-generate`` or ``-fprofile-instr-generate`` option. .. code-block:: console. $ clang++ -O2 -fprofile-instr-generate code.cc -o code. 2. Run the instrumented executable with inputs that reflect the typical usage.; By default, the profile data will be written to a ``default.profraw`` file; in the current directory. You can override that default by using option; ``-fprofile-instr-generate=`` or by setting the ``LLVM_PROFILE_FILE``; environment variable to specify an alternate file. If non-default file name; is specified by both the environment variable and the command line option,; the environment variable takes precedence. The file name pattern specified; can include different modifiers: ``%p``, ``%h``, ``%m``, ``%t``, and ``%c``. Any instance of ``%p`` in that file name will be replaced by the process; ID, so that you can easily distinguish the profile output from multiple; runs. .. code-block:: console. $ LLVM_PROFILE_FILE=""code-%p.profraw"" ./code. The modifier ``%h`` can be used in scenarios where the same instrumented; binary is run in multiple different host machines dumping profile data; to a shared network based storage. The ``%h`` specifier will be substituted; with the hostname so that profiles collected from different hosts do not; clobber each other. While the use of ``%p`` specifier can reduce the likelihood for the profiles; dumped from different processes to clobber each other, such clobbering can still; happen because of the ``pid`` re-use by the OS. Another side-effect of using; ``%p`` is that the storage requirement",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:108524,Modifiability,variab,variable,108524,"efault_%m.profraw`` in the directory named ``dirname`` if specified.; If ``dirname`` does not exist, it will be created at runtime. ``%m`` specifier; will be substituted with a unique id documented in step 2 above. In other words,; with ``-fprofile-generate[=<dirname>]`` option, the ""raw"" profile data automatic; merging is turned on by default, so there will no longer any risk of profile; clobbering from different running processes. For example,. .. code-block:: console. $ clang++ -O2 -fprofile-generate=yyy/zzz code.cc -o code. When ``code`` is executed, the profile will be written to the file; ``yyy/zzz/default_xxxx.profraw``. To generate the profile data file with the compiler readable format, the; ``llvm-profdata`` tool can be used with the profile directory as the input:. .. code-block:: console. $ llvm-profdata merge -output=code.profdata yyy/zzz/. If the user wants to turn off the auto-merging feature, or simply override the; the profile dumping path specified at command line, the environment variable; ``LLVM_PROFILE_FILE`` can still be used to override; the directory and filename for the profile file at runtime.; To override the path and filename at compile time, use; ``-Xclang -fprofile-instrument-path=/path/to/file_pattern.profraw``. .. option:: -fcs-profile-generate[=<dirname>]. The ``-fcs-profile-generate`` and ``-fcs-profile-generate=`` flags will use; the same instrumentation method, and generate the same profile as in the; ``-fprofile-generate`` and ``-fprofile-generate=`` flags. The difference is; that the instrumentation is performed after inlining so that the resulted; profile has a better context sensitive information. They cannot be used; together with ``-fprofile-generate`` and ``-fprofile-generate=`` flags.; They are typically used in conjunction with ``-fprofile-use`` flag.; The profile generated by ``-fcs-profile-generate`` and ``-fprofile-generate``; can be merged by llvm-profdata. A use example:. .. code-block:: console. $ clang++ -O2 -fprofi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:124882,Modifiability,variab,variables,124882,"d doesn't match all the regexes; from ``-fprofile-exclude-list``. .. code-block:: console. $ clang --coverage -fprofile-exclude-files=""^/usr/include/.*$"" \; -fprofile-filter-files=""^/usr/.*$"". In that case ``/usr/foo/oof.h`` is instrumented since it matches the filter regex and; doesn't match the exclude regex, but ``/usr/include/foo.h`` doesn't since it matches; the exclude regex. Controlling Debug Information; -----------------------------. Controlling Size of Debug Information; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Debug info kind generated by Clang can be set by one of the flags listed; below. If multiple flags are present, the last one is used. .. option:: -g0. Don't generate any debug info (default). .. option:: -gline-tables-only. Generate line number tables only. This kind of debug info allows to obtain stack traces with function names,; file names and line numbers (by such tools as ``gdb`` or ``addr2line``). It; doesn't contain any other data (e.g. description of local variables or; function parameters). .. option:: -fstandalone-debug. Clang supports a number of optimizations to reduce the size of debug; information in the binary. They work based on the assumption that; the debug type information can be spread out over multiple; compilation units. Specifically, the optimizations are:. - will not emit type definitions for types that are not needed by a; module and could be replaced with a forward declaration.; - will only emit type info for a dynamic C++ class in the module that; contains the vtable for the class.; - will only emit type info for a C++ class (non-trivial, non-aggregate); in the modules that contain a definition for one of its constructors.; - will only emit type definitions for types that are the subject of explicit; template instantiation declarations in the presence of an explicit; instantiation definition for the type. The **-fstandalone-debug** option turns off these optimizations.; This is useful when working with 3rd-party libraries tha",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:133746,Modifiability,variab,variables,133746,"``*23`` mode.; - ``ATOMIC_VAR_INIT`` is removed from ``*23`` mode.; - ``bool``, ``true``, ``false``, ``alignas``, ``alignof``, ``static_assert``,; and ``thread_local` are now first-class keywords, only in ``*23`` mode.; - ``typeof`` and ``typeof_unqual`` are supported, only ``*23`` mode.; - Bit-precise integers (``_BitInt(N)``) are supported by default in ``*23``; mode, and as an extension in ``*17`` and earlier modes.; - ``[[]]`` attributes are supported by default in ``*23`` mode, and as an; extension in ``*17`` and earlier modes. GCC extensions not implemented yet; ----------------------------------. clang tries to be compatible with gcc as much as possible, but some gcc; extensions are not implemented yet:. - clang does not support decimal floating point types (``_Decimal32`` and; friends) yet.; - clang does not support nested functions; this is a complex feature; which is infrequently used, so it is unlikely to be implemented; anytime soon. In C++11 it can be emulated by assigning lambda; functions to local variables, e.g:. .. code-block:: cpp. auto const local_function = [&](int parameter) {; // Do something; };; ...; local_function(1);. - clang only supports global register variables when the register specified; is non-allocatable (e.g. the stack pointer). Support for general global; register variables is unlikely to be implemented soon because it requires; additional LLVM backend support.; - clang does not support static initialization of flexible array; members. This appears to be a rarely used extension, but could be; implemented pending user demand.; - clang does not support; ``__builtin_va_arg_pack``/``__builtin_va_arg_pack_len``. This is; used rarely, but in some potentially interesting places, like the; glibc headers, so it may be implemented pending user demand. Note; that because clang pretends to be like GCC 4.2, and this extension; was introduced in 4.3, the glibc headers will not try to use this; extension with clang at the moment.; - clang does n",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:133918,Modifiability,variab,variables,133918,"` mode.; - ``typeof`` and ``typeof_unqual`` are supported, only ``*23`` mode.; - Bit-precise integers (``_BitInt(N)``) are supported by default in ``*23``; mode, and as an extension in ``*17`` and earlier modes.; - ``[[]]`` attributes are supported by default in ``*23`` mode, and as an; extension in ``*17`` and earlier modes. GCC extensions not implemented yet; ----------------------------------. clang tries to be compatible with gcc as much as possible, but some gcc; extensions are not implemented yet:. - clang does not support decimal floating point types (``_Decimal32`` and; friends) yet.; - clang does not support nested functions; this is a complex feature; which is infrequently used, so it is unlikely to be implemented; anytime soon. In C++11 it can be emulated by assigning lambda; functions to local variables, e.g:. .. code-block:: cpp. auto const local_function = [&](int parameter) {; // Do something; };; ...; local_function(1);. - clang only supports global register variables when the register specified; is non-allocatable (e.g. the stack pointer). Support for general global; register variables is unlikely to be implemented soon because it requires; additional LLVM backend support.; - clang does not support static initialization of flexible array; members. This appears to be a rarely used extension, but could be; implemented pending user demand.; - clang does not support; ``__builtin_va_arg_pack``/``__builtin_va_arg_pack_len``. This is; used rarely, but in some potentially interesting places, like the; glibc headers, so it may be implemented pending user demand. Note; that because clang pretends to be like GCC 4.2, and this extension; was introduced in 4.3, the glibc headers will not try to use this; extension with clang at the moment.; - clang does not support the gcc extension for forward-declaring; function parameters; this has not shown up in any real-world code; yet, though, so it might never be implemented. This is not a complete list; if you find an u",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:134039,Modifiability,variab,variables,134039,"ult in ``*23``; mode, and as an extension in ``*17`` and earlier modes.; - ``[[]]`` attributes are supported by default in ``*23`` mode, and as an; extension in ``*17`` and earlier modes. GCC extensions not implemented yet; ----------------------------------. clang tries to be compatible with gcc as much as possible, but some gcc; extensions are not implemented yet:. - clang does not support decimal floating point types (``_Decimal32`` and; friends) yet.; - clang does not support nested functions; this is a complex feature; which is infrequently used, so it is unlikely to be implemented; anytime soon. In C++11 it can be emulated by assigning lambda; functions to local variables, e.g:. .. code-block:: cpp. auto const local_function = [&](int parameter) {; // Do something; };; ...; local_function(1);. - clang only supports global register variables when the register specified; is non-allocatable (e.g. the stack pointer). Support for general global; register variables is unlikely to be implemented soon because it requires; additional LLVM backend support.; - clang does not support static initialization of flexible array; members. This appears to be a rarely used extension, but could be; implemented pending user demand.; - clang does not support; ``__builtin_va_arg_pack``/``__builtin_va_arg_pack_len``. This is; used rarely, but in some potentially interesting places, like the; glibc headers, so it may be implemented pending user demand. Note; that because clang pretends to be like GCC 4.2, and this extension; was introduced in 4.3, the glibc headers will not try to use this; extension with clang at the moment.; - clang does not support the gcc extension for forward-declaring; function parameters; this has not shown up in any real-world code; yet, though, so it might never be implemented. This is not a complete list; if you find an unsupported extension; missing from this list, please send an e-mail to cfe-dev. This list; currently excludes C++; see :ref:`C++ Language Fe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:134189,Modifiability,flexible,flexible,134189,"ed by default in ``*23`` mode, and as an; extension in ``*17`` and earlier modes. GCC extensions not implemented yet; ----------------------------------. clang tries to be compatible with gcc as much as possible, but some gcc; extensions are not implemented yet:. - clang does not support decimal floating point types (``_Decimal32`` and; friends) yet.; - clang does not support nested functions; this is a complex feature; which is infrequently used, so it is unlikely to be implemented; anytime soon. In C++11 it can be emulated by assigning lambda; functions to local variables, e.g:. .. code-block:: cpp. auto const local_function = [&](int parameter) {; // Do something; };; ...; local_function(1);. - clang only supports global register variables when the register specified; is non-allocatable (e.g. the stack pointer). Support for general global; register variables is unlikely to be implemented soon because it requires; additional LLVM backend support.; - clang does not support static initialization of flexible array; members. This appears to be a rarely used extension, but could be; implemented pending user demand.; - clang does not support; ``__builtin_va_arg_pack``/``__builtin_va_arg_pack_len``. This is; used rarely, but in some potentially interesting places, like the; glibc headers, so it may be implemented pending user demand. Note; that because clang pretends to be like GCC 4.2, and this extension; was introduced in 4.3, the glibc headers will not try to use this; extension with clang at the moment.; - clang does not support the gcc extension for forward-declaring; function parameters; this has not shown up in any real-world code; yet, though, so it might never be implemented. This is not a complete list; if you find an unsupported extension; missing from this list, please send an e-mail to cfe-dev. This list; currently excludes C++; see :ref:`C++ Language Features <cxx>`. Also, this; list does not include bugs in mostly-implemented features; please see; the `bug",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:135605,Modifiability,variab,variable-length,135605,"on; was introduced in 4.3, the glibc headers will not try to use this; extension with clang at the moment.; - clang does not support the gcc extension for forward-declaring; function parameters; this has not shown up in any real-world code; yet, though, so it might never be implemented. This is not a complete list; if you find an unsupported extension; missing from this list, please send an e-mail to cfe-dev. This list; currently excludes C++; see :ref:`C++ Language Features <cxx>`. Also, this; list does not include bugs in mostly-implemented features; please see; the `bug; tracker <https://bugs.llvm.org/buglist.cgi?quicksearch=product%3Aclang+component%3A-New%2BBugs%2CAST%2CBasic%2CDriver%2CHeaders%2CLLVM%2BCodeGen%2Cparser%2Cpreprocessor%2CSemantic%2BAnalyzer>`_; for known existing bugs (FIXME: Is there a section for bug-reporting; guidelines somewhere?). Intentionally unsupported GCC extensions; ----------------------------------------. - clang does not support the gcc extension that allows variable-length; arrays in structures. This is for a few reasons: one, it is tricky to; implement, two, the extension is completely undocumented, and three,; the extension appears to be rarely used. Note that clang *does*; support flexible array members (arrays with a zero or unspecified; size at the end of a structure).; - GCC accepts many expression forms that are not valid integer constant; expressions in bit-field widths, enumerator constants, case labels,; and in array bounds at global scope. Clang also accepts additional; expression forms in these contexts, but constructs that GCC accepts due to; simplifications GCC performs while parsing, such as ``x - x`` (where ``x`` is a; variable) will likely never be accepted by Clang.; - clang does not support ``__builtin_apply`` and friends; this extension; is extremely obscure and difficult to implement reliably. .. _c_ms:. Microsoft extensions; --------------------. clang has support for many extensions from Microsoft Visual C+",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:135836,Modifiability,flexible,flexible,135836,"er be implemented. This is not a complete list; if you find an unsupported extension; missing from this list, please send an e-mail to cfe-dev. This list; currently excludes C++; see :ref:`C++ Language Features <cxx>`. Also, this; list does not include bugs in mostly-implemented features; please see; the `bug; tracker <https://bugs.llvm.org/buglist.cgi?quicksearch=product%3Aclang+component%3A-New%2BBugs%2CAST%2CBasic%2CDriver%2CHeaders%2CLLVM%2BCodeGen%2Cparser%2Cpreprocessor%2CSemantic%2BAnalyzer>`_; for known existing bugs (FIXME: Is there a section for bug-reporting; guidelines somewhere?). Intentionally unsupported GCC extensions; ----------------------------------------. - clang does not support the gcc extension that allows variable-length; arrays in structures. This is for a few reasons: one, it is tricky to; implement, two, the extension is completely undocumented, and three,; the extension appears to be rarely used. Note that clang *does*; support flexible array members (arrays with a zero or unspecified; size at the end of a structure).; - GCC accepts many expression forms that are not valid integer constant; expressions in bit-field widths, enumerator constants, case labels,; and in array bounds at global scope. Clang also accepts additional; expression forms in these contexts, but constructs that GCC accepts due to; simplifications GCC performs while parsing, such as ``x - x`` (where ``x`` is a; variable) will likely never be accepted by Clang.; - clang does not support ``__builtin_apply`` and friends; this extension; is extremely obscure and difficult to implement reliably. .. _c_ms:. Microsoft extensions; --------------------. clang has support for many extensions from Microsoft Visual C++. To enable these; extensions, use the ``-fms-extensions`` command-line option. This is the default; for Windows targets. Clang does not implement every pragma or declspec provided; by MSVC, but the popular ones, such as ``__declspec(dllexport)`` and ``#pragma; commen",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:136296,Modifiability,variab,variable,136296,"earch=product%3Aclang+component%3A-New%2BBugs%2CAST%2CBasic%2CDriver%2CHeaders%2CLLVM%2BCodeGen%2Cparser%2Cpreprocessor%2CSemantic%2BAnalyzer>`_; for known existing bugs (FIXME: Is there a section for bug-reporting; guidelines somewhere?). Intentionally unsupported GCC extensions; ----------------------------------------. - clang does not support the gcc extension that allows variable-length; arrays in structures. This is for a few reasons: one, it is tricky to; implement, two, the extension is completely undocumented, and three,; the extension appears to be rarely used. Note that clang *does*; support flexible array members (arrays with a zero or unspecified; size at the end of a structure).; - GCC accepts many expression forms that are not valid integer constant; expressions in bit-field widths, enumerator constants, case labels,; and in array bounds at global scope. Clang also accepts additional; expression forms in these contexts, but constructs that GCC accepts due to; simplifications GCC performs while parsing, such as ``x - x`` (where ``x`` is a; variable) will likely never be accepted by Clang.; - clang does not support ``__builtin_apply`` and friends; this extension; is extremely obscure and difficult to implement reliably. .. _c_ms:. Microsoft extensions; --------------------. clang has support for many extensions from Microsoft Visual C++. To enable these; extensions, use the ``-fms-extensions`` command-line option. This is the default; for Windows targets. Clang does not implement every pragma or declspec provided; by MSVC, but the popular ones, such as ``__declspec(dllexport)`` and ``#pragma; comment(lib)`` are well supported. clang has a ``-fms-compatibility`` flag that makes clang accept enough; invalid C++ to be able to parse most Microsoft headers. For example, it; allows `unqualified lookup of dependent base class members; <https://clang.llvm.org/compatibility.html#dep_lookup_bases>`_, which is; a common compatibility issue with clang. This flag is",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:140064,Modifiability,variab,variables,140064,". Sets the limit for recursively nested template instantiations to N. The; default is 1024. .. option:: -foperator-arrow-depth=N. Sets the limit for iterative calls to 'operator->' functions to N. The; default is 256. .. _objc:. Objective-C Language Features; =============================. .. _objcxx:. Objective-C++ Language Features; ===============================. .. _openmp:. OpenMP Features; ===============. Clang supports all OpenMP 4.5 directives and clauses. See :doc:`OpenMPSupport`; for additional details. Use `-fopenmp` to enable OpenMP. Support for OpenMP can be disabled with; `-fno-openmp`. Use `-fopenmp-simd` to enable OpenMP simd features only, without linking; the runtime library; for combined constructs; (e.g. ``#pragma omp parallel for simd``) the non-simd directives and clauses; will be ignored. This can be disabled with `-fno-openmp-simd`. Controlling implementation limits; ---------------------------------. .. option:: -fopenmp-use-tls. Controls code generation for OpenMP threadprivate variables. In presence of; this option all threadprivate variables are generated the same way as thread; local variables, using TLS support. If `-fno-openmp-use-tls`; is provided or target does not support TLS, code generation for threadprivate; variables relies on OpenMP runtime library. .. _opencl:. OpenCL Features; ===============. Clang can be used to compile OpenCL kernels for execution on a device; (e.g. GPU). It is possible to compile the kernel into a binary (e.g. for AMDGPU); that can be uploaded to run directly on a device (e.g. using; `clCreateProgramWithBinary; <https://www.khronos.org/registry/OpenCL/specs/opencl-1.1.pdf#111>`_) or; into generic bitcode files loadable into other toolchains. Compiling to a binary using the default target from the installation can be done; as follows:. .. code-block:: console. $ echo ""kernel void k(){}"" > test.cl; $ clang test.cl. Compiling for a specific target can be done by specifying the triple corresponding; to the t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:140121,Modifiability,variab,variables,140121,"ption:: -foperator-arrow-depth=N. Sets the limit for iterative calls to 'operator->' functions to N. The; default is 256. .. _objc:. Objective-C Language Features; =============================. .. _objcxx:. Objective-C++ Language Features; ===============================. .. _openmp:. OpenMP Features; ===============. Clang supports all OpenMP 4.5 directives and clauses. See :doc:`OpenMPSupport`; for additional details. Use `-fopenmp` to enable OpenMP. Support for OpenMP can be disabled with; `-fno-openmp`. Use `-fopenmp-simd` to enable OpenMP simd features only, without linking; the runtime library; for combined constructs; (e.g. ``#pragma omp parallel for simd``) the non-simd directives and clauses; will be ignored. This can be disabled with `-fno-openmp-simd`. Controlling implementation limits; ---------------------------------. .. option:: -fopenmp-use-tls. Controls code generation for OpenMP threadprivate variables. In presence of; this option all threadprivate variables are generated the same way as thread; local variables, using TLS support. If `-fno-openmp-use-tls`; is provided or target does not support TLS, code generation for threadprivate; variables relies on OpenMP runtime library. .. _opencl:. OpenCL Features; ===============. Clang can be used to compile OpenCL kernels for execution on a device; (e.g. GPU). It is possible to compile the kernel into a binary (e.g. for AMDGPU); that can be uploaded to run directly on a device (e.g. using; `clCreateProgramWithBinary; <https://www.khronos.org/registry/OpenCL/specs/opencl-1.1.pdf#111>`_) or; into generic bitcode files loadable into other toolchains. Compiling to a binary using the default target from the installation can be done; as follows:. .. code-block:: console. $ echo ""kernel void k(){}"" > test.cl; $ clang test.cl. Compiling for a specific target can be done by specifying the triple corresponding; to the target, for example:. .. code-block:: console. $ clang --target=nvptx64-unknown-unknown test.cl;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:140175,Modifiability,variab,variables,140175,"ption:: -foperator-arrow-depth=N. Sets the limit for iterative calls to 'operator->' functions to N. The; default is 256. .. _objc:. Objective-C Language Features; =============================. .. _objcxx:. Objective-C++ Language Features; ===============================. .. _openmp:. OpenMP Features; ===============. Clang supports all OpenMP 4.5 directives and clauses. See :doc:`OpenMPSupport`; for additional details. Use `-fopenmp` to enable OpenMP. Support for OpenMP can be disabled with; `-fno-openmp`. Use `-fopenmp-simd` to enable OpenMP simd features only, without linking; the runtime library; for combined constructs; (e.g. ``#pragma omp parallel for simd``) the non-simd directives and clauses; will be ignored. This can be disabled with `-fno-openmp-simd`. Controlling implementation limits; ---------------------------------. .. option:: -fopenmp-use-tls. Controls code generation for OpenMP threadprivate variables. In presence of; this option all threadprivate variables are generated the same way as thread; local variables, using TLS support. If `-fno-openmp-use-tls`; is provided or target does not support TLS, code generation for threadprivate; variables relies on OpenMP runtime library. .. _opencl:. OpenCL Features; ===============. Clang can be used to compile OpenCL kernels for execution on a device; (e.g. GPU). It is possible to compile the kernel into a binary (e.g. for AMDGPU); that can be uploaded to run directly on a device (e.g. using; `clCreateProgramWithBinary; <https://www.khronos.org/registry/OpenCL/specs/opencl-1.1.pdf#111>`_) or; into generic bitcode files loadable into other toolchains. Compiling to a binary using the default target from the installation can be done; as follows:. .. code-block:: console. $ echo ""kernel void k(){}"" > test.cl; $ clang test.cl. Compiling for a specific target can be done by specifying the triple corresponding; to the target, for example:. .. code-block:: console. $ clang --target=nvptx64-unknown-unknown test.cl;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:140310,Modifiability,variab,variables,140310,"ive-C Language Features; =============================. .. _objcxx:. Objective-C++ Language Features; ===============================. .. _openmp:. OpenMP Features; ===============. Clang supports all OpenMP 4.5 directives and clauses. See :doc:`OpenMPSupport`; for additional details. Use `-fopenmp` to enable OpenMP. Support for OpenMP can be disabled with; `-fno-openmp`. Use `-fopenmp-simd` to enable OpenMP simd features only, without linking; the runtime library; for combined constructs; (e.g. ``#pragma omp parallel for simd``) the non-simd directives and clauses; will be ignored. This can be disabled with `-fno-openmp-simd`. Controlling implementation limits; ---------------------------------. .. option:: -fopenmp-use-tls. Controls code generation for OpenMP threadprivate variables. In presence of; this option all threadprivate variables are generated the same way as thread; local variables, using TLS support. If `-fno-openmp-use-tls`; is provided or target does not support TLS, code generation for threadprivate; variables relies on OpenMP runtime library. .. _opencl:. OpenCL Features; ===============. Clang can be used to compile OpenCL kernels for execution on a device; (e.g. GPU). It is possible to compile the kernel into a binary (e.g. for AMDGPU); that can be uploaded to run directly on a device (e.g. using; `clCreateProgramWithBinary; <https://www.khronos.org/registry/OpenCL/specs/opencl-1.1.pdf#111>`_) or; into generic bitcode files loadable into other toolchains. Compiling to a binary using the default target from the installation can be done; as follows:. .. code-block:: console. $ echo ""kernel void k(){}"" > test.cl; $ clang test.cl. Compiling for a specific target can be done by specifying the triple corresponding; to the target, for example:. .. code-block:: console. $ clang --target=nvptx64-unknown-unknown test.cl; $ clang --target=amdgcn-amd-amdhsa -mcpu=gfx900 test.cl. Compiling to bitcode can be done as follows:. .. code-block:: console. $ clang -c ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:141484,Modifiability,portab,portable,141484,"el into a binary (e.g. for AMDGPU); that can be uploaded to run directly on a device (e.g. using; `clCreateProgramWithBinary; <https://www.khronos.org/registry/OpenCL/specs/opencl-1.1.pdf#111>`_) or; into generic bitcode files loadable into other toolchains. Compiling to a binary using the default target from the installation can be done; as follows:. .. code-block:: console. $ echo ""kernel void k(){}"" > test.cl; $ clang test.cl. Compiling for a specific target can be done by specifying the triple corresponding; to the target, for example:. .. code-block:: console. $ clang --target=nvptx64-unknown-unknown test.cl; $ clang --target=amdgcn-amd-amdhsa -mcpu=gfx900 test.cl. Compiling to bitcode can be done as follows:. .. code-block:: console. $ clang -c -emit-llvm test.cl. This will produce a file `test.bc` that can be used in vendor toolchains; to perform machine code generation. Note that if compiled to bitcode for generic targets such as SPIR/SPIR-V,; portable IR is produced that can be used with various vendor; tools as well as open source tools such as `SPIRV-LLVM Translator; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator>`_; to produce SPIR-V binary. More details are provided in `the offline; compilation from OpenCL kernel sources into SPIR-V using open source; tools; <https://github.com/KhronosGroup/OpenCL-Guide/blob/main/chapters/os_tooling.md>`_.; From clang 14 onwards SPIR-V can be generated directly as detailed in; :ref:`the SPIR-V support section <spir-v>`. Clang currently supports OpenCL C language standards up to v2.0. Clang mainly; supports full profile. There is only very limited support of the embedded; profile.; From clang 9 a C++ mode is available for OpenCL (see; :ref:`C++ for OpenCL <cxx_for_opencl>`). OpenCL v3.0 support is complete but it remains in experimental state, see more; details about the experimental features and limitations in :doc:`OpenCLSupport`; page. OpenCL Specific Options; -----------------------. Most of the OpenCL build o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:145535,Modifiability,portab,portable,145535,"=-all,+cl_khr_fp16 test.cl. Note that some generic targets e.g. SPIR/SPIR-V enable all extensions/features in; clang by default. OpenCL Targets; --------------. OpenCL targets are derived from the regular Clang target classes. The OpenCL; specific parts of the target representation provide address space mapping as; well as a set of supported extensions. Specific Targets; ^^^^^^^^^^^^^^^^. There is a set of concrete HW architectures that OpenCL can be compiled for. - For AMD target:. .. code-block:: console. $ clang --target=amdgcn-amd-amdhsa -mcpu=gfx900 test.cl. - For Nvidia architectures:. .. code-block:: console. $ clang --target=nvptx64-unknown-unknown test.cl. Generic Targets; ^^^^^^^^^^^^^^^. - A SPIR-V binary can be produced for 32 or 64 bit targets. .. code-block:: console. $ clang --target=spirv32 -c test.cl; $ clang --target=spirv64 -c test.cl. More details can be found in :ref:`the SPIR-V support section <spir-v>`. - SPIR is available as a generic target to allow portable bitcode to be produced; that can be used across GPU toolchains. The implementation follows `the SPIR; specification <https://www.khronos.org/spir>`_. There are two flavors; available for 32 and 64 bits. .. code-block:: console. $ clang --target=spir test.cl -emit-llvm -c; $ clang --target=spir64 test.cl -emit-llvm -c. Clang will generate SPIR v1.2 compatible IR for OpenCL versions up to 2.0 and; SPIR v2.0 for OpenCL v2.0 or C++ for OpenCL. - x86 is used by some implementations that are x86 compatible and currently; remains for backwards compatibility (with older implementations prior to; SPIR target support). For ""non-SPMD"" targets which cannot spawn multiple; work-items on the fly using hardware, which covers practically all non-GPU; devices such as CPUs and DSPs, additional processing is needed for the kernels; to support multiple work-item execution. For this, a 3rd party toolchain,; such as for example `POCL <http://portablecl.org/>`_, can be used. This target does not support multip",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:146478,Modifiability,portab,portablecl,146478,"he SPIR-V support section <spir-v>`. - SPIR is available as a generic target to allow portable bitcode to be produced; that can be used across GPU toolchains. The implementation follows `the SPIR; specification <https://www.khronos.org/spir>`_. There are two flavors; available for 32 and 64 bits. .. code-block:: console. $ clang --target=spir test.cl -emit-llvm -c; $ clang --target=spir64 test.cl -emit-llvm -c. Clang will generate SPIR v1.2 compatible IR for OpenCL versions up to 2.0 and; SPIR v2.0 for OpenCL v2.0 or C++ for OpenCL. - x86 is used by some implementations that are x86 compatible and currently; remains for backwards compatibility (with older implementations prior to; SPIR target support). For ""non-SPMD"" targets which cannot spawn multiple; work-items on the fly using hardware, which covers practically all non-GPU; devices such as CPUs and DSPs, additional processing is needed for the kernels; to support multiple work-item execution. For this, a 3rd party toolchain,; such as for example `POCL <http://portablecl.org/>`_, can be used. This target does not support multiple memory segments and, therefore, the fake; address space map can be added using the :ref:`-ffake-address-space-map; <opencl_fake_address_space_map>` flag. All known OpenCL extensions and features are set to supported in the generic targets,; however :option:`-cl-ext` flag can be used to toggle individual extensions and; features. .. _opencl_header:. OpenCL Header; -------------. By default Clang will include standard headers and therefore most of OpenCL; builtin functions and types are available during compilation. The; default declarations of non-native compiler types and functions can be disabled; by using flag :option:`-cl-no-stdinc`. The following example demonstrates that OpenCL kernel sources with various; standard builtin functions can be compiled without the need for an explicit; includes or compiler flags. .. code-block:: console. $ echo ""bool is_wg_uniform(int i){return get_enqu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:147798,Modifiability,config,configured,147798," can be used to toggle individual extensions and; features. .. _opencl_header:. OpenCL Header; -------------. By default Clang will include standard headers and therefore most of OpenCL; builtin functions and types are available during compilation. The; default declarations of non-native compiler types and functions can be disabled; by using flag :option:`-cl-no-stdinc`. The following example demonstrates that OpenCL kernel sources with various; standard builtin functions can be compiled without the need for an explicit; includes or compiler flags. .. code-block:: console. $ echo ""bool is_wg_uniform(int i){return get_enqueued_local_size(i)==get_local_size(i);}"" > test.cl; $ clang -cl-std=CL2.0 test.cl. More information about the default headers is provided in :doc:`OpenCLSupport`. OpenCL Extensions; -----------------. Most of the ``cl_khr_*`` extensions to OpenCL C from `the official OpenCL; registry <https://www.khronos.org/registry/OpenCL/>`_ are available and; configured per target depending on the support available in the specific; architecture. It is possible to alter the default extensions setting per target using; ``-cl-ext`` flag. (See :ref:`flags description <opencl_cl_ext>` for more details). Vendor extensions can be added flexibly by declaring the list of types and; functions associated with each extensions enclosed within the following; compiler pragma directives:. .. code-block:: c. #pragma OPENCL EXTENSION the_new_extension_name : begin; // declare types and functions associated with the extension here; #pragma OPENCL EXTENSION the_new_extension_name : end. For example, parsing the following code adds ``my_t`` type and ``my_func``; function to the custom ``my_ext`` extension. .. code-block:: c. #pragma OPENCL EXTENSION my_ext : begin; typedef struct{; int a;; }my_t;; void my_func(my_t);; #pragma OPENCL EXTENSION my_ext : end. There is no conflict resolution for identifier clashes among extensions.; It is therefore recommended that the identifiers are p",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:165995,Modifiability,variab,variable,165995,"via an attribute) default visibility from the; source, including RTTI.; * ``-mdefault-visibility-export-mapping=all``: set XCOFF exported visibility; for all entities with default visibility from any source. This gives a; export behavior similar to ELF platforms where all entities with default; visibility are exported. .. _spir-v:. SPIR-V support; --------------. Clang supports generation of SPIR-V conformant to `the OpenCL Environment; Specification; <https://www.khronos.org/registry/OpenCL/specs/3.0-unified/html/OpenCL_Env.html>`_. To generate SPIR-V binaries, Clang uses the external ``llvm-spirv`` tool from the; `SPIRV-LLVM-Translator repo; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator>`_. Prior to the generation of SPIR-V binary with Clang, ``llvm-spirv``; should be built or installed. Please refer to `the following instructions; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator#build-instructions>`_; for more details. Clang will expect the ``llvm-spirv`` executable to; be present in the ``PATH`` environment variable. Clang uses ``llvm-spirv``; with `the widely adopted assembly syntax package; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator/#build-with-spirv-tools>`_. `The versioning; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator/releases>`_ of; ``llvm-spirv`` is aligned with Clang major releases. The same applies to the; main development branch. It is therefore important to ensure the ``llvm-spirv``; version is in alignment with the Clang version. For troubleshooting purposes; ``llvm-spirv`` can be `tested in isolation; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator#test-instructions>`_. Example usage for OpenCL kernel compilation:. .. code-block:: console. $ clang --target=spirv32 -c test.cl; $ clang --target=spirv64 -c test.cl. Both invocations of Clang will result in the generation of a SPIR-V binary file; `test.o` for 32 bit and 64 bit respectively. This file can be imported; by an OpenCL driver that support SPIR-V consu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:167648,Modifiability,config,configured,167648,".. code-block:: console. $ clang --target=spirv32 -c test.cl; $ clang --target=spirv64 -c test.cl. Both invocations of Clang will result in the generation of a SPIR-V binary file; `test.o` for 32 bit and 64 bit respectively. This file can be imported; by an OpenCL driver that support SPIR-V consumption or it can be compiled; further by offline SPIR-V consumer tools. Converting to SPIR-V produced with the optimization levels other than `-O0` is; currently available as an experimental feature and it is not guaranteed to work; in all cases. Clang also supports integrated generation of SPIR-V without use of ``llvm-spirv``; tool as an experimental feature when ``-fintegrated-objemitter`` flag is passed in; the command line. .. code-block:: console. $ clang --target=spirv32 -fintegrated-objemitter -c test.cl. Note that only very basic functionality is supported at this point and therefore; it is not suitable for arbitrary use cases. This feature is only enabled when clang; build is configured with ``-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=SPIRV`` option. Linking is done using ``spirv-link`` from `the SPIRV-Tools project; <https://github.com/KhronosGroup/SPIRV-Tools#linker>`_. Similar to other external; linkers, Clang will expect ``spirv-link`` to be installed separately and to be; present in the ``PATH`` environment variable. Please refer to `the build and; installation instructions; <https://github.com/KhronosGroup/SPIRV-Tools#build>`_. .. code-block:: console. $ clang --target=spirv64 test1.cl test2.cl. More information about the SPIR-V target settings and supported versions of SPIR-V; format can be found in `the SPIR-V target guide; <https://llvm.org/docs/SPIRVUsage.html>`__. .. _clang-cl:. clang-cl; ========. clang-cl is an alternative command-line interface to Clang, designed for; compatibility with the Visual C++ compiler, cl.exe. To enable clang-cl to find system headers, libraries, and the linker when run; from the command-line, it should be executed inside a Visual S",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:167986,Modifiability,variab,variable,167986,"nCL driver that support SPIR-V consumption or it can be compiled; further by offline SPIR-V consumer tools. Converting to SPIR-V produced with the optimization levels other than `-O0` is; currently available as an experimental feature and it is not guaranteed to work; in all cases. Clang also supports integrated generation of SPIR-V without use of ``llvm-spirv``; tool as an experimental feature when ``-fintegrated-objemitter`` flag is passed in; the command line. .. code-block:: console. $ clang --target=spirv32 -fintegrated-objemitter -c test.cl. Note that only very basic functionality is supported at this point and therefore; it is not suitable for arbitrary use cases. This feature is only enabled when clang; build is configured with ``-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=SPIRV`` option. Linking is done using ``spirv-link`` from `the SPIRV-Tools project; <https://github.com/KhronosGroup/SPIRV-Tools#linker>`_. Similar to other external; linkers, Clang will expect ``spirv-link`` to be installed separately and to be; present in the ``PATH`` environment variable. Please refer to `the build and; installation instructions; <https://github.com/KhronosGroup/SPIRV-Tools#build>`_. .. code-block:: console. $ clang --target=spirv64 test1.cl test2.cl. More information about the SPIR-V target settings and supported versions of SPIR-V; format can be found in `the SPIR-V target guide; <https://llvm.org/docs/SPIRVUsage.html>`__. .. _clang-cl:. clang-cl; ========. clang-cl is an alternative command-line interface to Clang, designed for; compatibility with the Visual C++ compiler, cl.exe. To enable clang-cl to find system headers, libraries, and the linker when run; from the command-line, it should be executed inside a Visual Studio Native Tools; Command Prompt or a regular Command Prompt where the environment has been set; up using e.g. `vcvarsall.bat <https://msdn.microsoft.com/en-us/library/f2ccy3wt.aspx>`_. clang-cl can also be used from inside Visual Studio by selecting the LLVM",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:169993,Modifiability,variab,variables,169993,"not part of the installer, but may be installed; separately from the; `Visual Studio Marketplace <https://marketplace.visualstudio.com/items?itemName=LLVMExtensions.llvm-toolchain>`_.; To use the toolset, select a project in Solution Explorer, open its Property; Page (Alt+F7), and in the ""General"" section of ""Configuration Properties""; change ""Platform Toolset"" to LLVM. Doing so enables an additional Property; Page for selecting the clang-cl executable to use for builds. To use the toolset with MSBuild directly, invoke it with e.g.; ``/p:PlatformToolset=LLVM``. This allows trying out the clang-cl toolchain; without modifying your project files. It's also possible to point MSBuild at clang-cl without changing toolset by; passing ``/p:CLToolPath=c:\llvm\bin /p:CLToolExe=clang-cl.exe``. When using CMake and the Visual Studio generators, the toolset can be set with the ``-T`` flag:. ::. cmake -G""Visual Studio 16 2019"" -T LLVM .. When using CMake with the Ninja generator, set the ``CMAKE_C_COMPILER`` and; ``CMAKE_CXX_COMPILER`` variables to clang-cl:. ::. cmake -GNinja -DCMAKE_C_COMPILER=""c:/Program Files (x86)/LLVM/bin/clang-cl.exe""; -DCMAKE_CXX_COMPILER=""c:/Program Files (x86)/LLVM/bin/clang-cl.exe"" .. Command-Line Options; --------------------. To be compatible with cl.exe, clang-cl supports most of the same command-line; options. Those options can start with either ``/`` or ``-``. It also supports; some of Clang's core options, such as the ``-W`` options. Options that are known to clang-cl, but not currently supported, are ignored; with a warning. For example:. ::. clang-cl.exe: warning: argument unused during compilation: '/AI'. To suppress warnings about unused arguments, use the ``-Qunused-arguments`` option. Options that are not known to clang-cl will be ignored by default. Use the; ``-Werror=unknown-argument`` option in order to treat them as errors. If these; options are spelled with a leading ``/``, they will be mistaken for a filename:. ::. clang-cl.exe: erro",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:172613,Modifiability,variab,variables,172613,"CL.EXE COMPATIBILITY OPTIONS:; /? Display available options; /arch:<value> Set architecture for code generation; /Brepro- Emit an object file which cannot be reproduced over time; /Brepro Emit an object file which can be reproduced over time; /clang:<arg> Pass <arg> to the clang driver; /C Don't discard comments when preprocessing; /c Compile only; /d1PP Retain macro definitions in /E mode; /d1reportAllClassLayout Dump record layout information; /diagnostics:caret Enable caret and column diagnostics (on by default); /diagnostics:classic Disable column and caret diagnostics; /diagnostics:column Disable caret diagnostics but keep column info; /D <macro[=value]> Define macro; /EH<value> Exception handling model; /EP Disable linemarker output and preprocess to stdout; /execution-charset:<value>; Runtime encoding, supports only UTF-8; /E Preprocess to stdout; /FA Output assembly code file during compilation; /Fa<file or directory> Output assembly code to this file during compilation (with /FA); /Fe<file or directory> Set output executable file or directory (ends in / or \); /FI <value> Include file before parsing; /Fi<file> Set preprocess output file name (with /P); /Fo<file or directory> Set output object file, or directory (ends in / or \) (with /c); /fp:except-; /fp:except; /fp:fast; /fp:precise; /fp:strict; /Fp<filename> Set pch filename (with /Yc and /Yu); /GA Assume thread-local variables are defined in the executable; /Gd Set __cdecl as a default calling convention; /GF- Disable string pooling; /GF Enable string pooling (default); /GR- Disable emission of RTTI data; /Gregcall Set __regcall as a default calling convention; /GR Enable emission of RTTI data; /Gr Set __fastcall as a default calling convention; /GS- Disable buffer security check; /GS Enable buffer security check (default); /Gs Use stack probes (default); /Gs<value> Set stack probe size (default 4096); /guard:<value> Enable Control Flow Guard with /guard:cf,; or only the table with /guard:cf,nochecks.; E",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:175658,Modifiability,inherit,inheritance,175658,,MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:175730,Modifiability,inherit,inheritance,175730,"r directory> Set output file or directory (ends in / or \); /P Preprocess to file; /Qvec- Disable the loop vectorization passes; /Qvec Enable the loop vectorization passes; /showFilenames- Don't print the name of each compiled file (default); /showFilenames Print the name of each compiled file; /showIncludes Print info about included files to stderr; /source-charset:<value> Source encoding, supports only UTF-8; /std:<value> Language standard to compile for; /TC Treat all source files as C; /Tc <filename> Specify a C source file; /TP Treat all source files as C++; /Tp <filename> Specify a C++ source file; /utf-8 Set source and runtime encoding to UTF-8 (default); /U <macro> Undefine macro; /vd<value> Control vtordisp placement; /vmb Use a best-case representation method for member pointers; /vmg Use a most-general representation for member pointers; /vmm Set the default most-general representation to multiple inheritance; /vms Set the default most-general representation to single inheritance; /vmv Set the default most-general representation to virtual inheritance; /volatile:iso Volatile loads and stores have standard semantics; /volatile:ms Volatile loads and stores have acquire and release semantics; /W0 Disable all warnings; /W1 Enable -Wall; /W2 Enable -Wall; /W3 Enable -Wall; /W4 Enable -Wall and -Wextra; /Wall Enable -Weverything; /WX- Do not treat warnings as errors; /WX Treat warnings as errors; /w Disable all warnings; /X Don't add %INCLUDE% to the include search path; /Y- Disable precompiled headers, overrides /Yc and /Yu; /Yc<filename> Generate a pch file for all code up to and including <filename>; /Yu<filename> Load a pch file and use it instead of all code up to and including <filename>; /Z7 Enable CodeView debug information in object files; /Zc:char8_t Enable C++20 char8_t type; /Zc:char8_t- Disable C++20 char8_t type; /Zc:dllexportInlines- Don't dllexport/dllimport inline member functions of dllexport/import classes; /Zc:dllexportInlines dllexport/dlli",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:175803,Modifiability,inherit,inheritance,175803," to file; /Qvec- Disable the loop vectorization passes; /Qvec Enable the loop vectorization passes; /showFilenames- Don't print the name of each compiled file (default); /showFilenames Print the name of each compiled file; /showIncludes Print info about included files to stderr; /source-charset:<value> Source encoding, supports only UTF-8; /std:<value> Language standard to compile for; /TC Treat all source files as C; /Tc <filename> Specify a C source file; /TP Treat all source files as C++; /Tp <filename> Specify a C++ source file; /utf-8 Set source and runtime encoding to UTF-8 (default); /U <macro> Undefine macro; /vd<value> Control vtordisp placement; /vmb Use a best-case representation method for member pointers; /vmg Use a most-general representation for member pointers; /vmm Set the default most-general representation to multiple inheritance; /vms Set the default most-general representation to single inheritance; /vmv Set the default most-general representation to virtual inheritance; /volatile:iso Volatile loads and stores have standard semantics; /volatile:ms Volatile loads and stores have acquire and release semantics; /W0 Disable all warnings; /W1 Enable -Wall; /W2 Enable -Wall; /W3 Enable -Wall; /W4 Enable -Wall and -Wextra; /Wall Enable -Weverything; /WX- Do not treat warnings as errors; /WX Treat warnings as errors; /w Disable all warnings; /X Don't add %INCLUDE% to the include search path; /Y- Disable precompiled headers, overrides /Yc and /Yu; /Yc<filename> Generate a pch file for all code up to and including <filename>; /Yu<filename> Load a pch file and use it instead of all code up to and including <filename>; /Z7 Enable CodeView debug information in object files; /Zc:char8_t Enable C++20 char8_t type; /Zc:char8_t- Disable C++20 char8_t type; /Zc:dllexportInlines- Don't dllexport/dllimport inline member functions of dllexport/import classes; /Zc:dllexportInlines dllexport/dllimport inline member functions of dllexport/import classes (default); /Zc:",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:177056,Modifiability,variab,variables,177056,"/utf-8 Set source and runtime encoding to UTF-8 (default); /U <macro> Undefine macro; /vd<value> Control vtordisp placement; /vmb Use a best-case representation method for member pointers; /vmg Use a most-general representation for member pointers; /vmm Set the default most-general representation to multiple inheritance; /vms Set the default most-general representation to single inheritance; /vmv Set the default most-general representation to virtual inheritance; /volatile:iso Volatile loads and stores have standard semantics; /volatile:ms Volatile loads and stores have acquire and release semantics; /W0 Disable all warnings; /W1 Enable -Wall; /W2 Enable -Wall; /W3 Enable -Wall; /W4 Enable -Wall and -Wextra; /Wall Enable -Weverything; /WX- Do not treat warnings as errors; /WX Treat warnings as errors; /w Disable all warnings; /X Don't add %INCLUDE% to the include search path; /Y- Disable precompiled headers, overrides /Yc and /Yu; /Yc<filename> Generate a pch file for all code up to and including <filename>; /Yu<filename> Load a pch file and use it instead of all code up to and including <filename>; /Z7 Enable CodeView debug information in object files; /Zc:char8_t Enable C++20 char8_t type; /Zc:char8_t- Disable C++20 char8_t type; /Zc:dllexportInlines- Don't dllexport/dllimport inline member functions of dllexport/import classes; /Zc:dllexportInlines dllexport/dllimport inline member functions of dllexport/import classes (default); /Zc:sizedDealloc- Disable C++14 sized global deallocation functions; /Zc:sizedDealloc Enable C++14 sized global deallocation functions; /Zc:strictStrings Treat string literals as const; /Zc:threadSafeInit- Disable thread-safe initialization of static variables; /Zc:threadSafeInit Enable thread-safe initialization of static variables; /Zc:trigraphs- Disable trigraphs (default); /Zc:trigraphs Enable trigraphs; /Zc:twoPhase- Disable two-phase name lookup in templates; /Zc:twoPhase Enable two-phase name lookup in templates; /Zi Alias for /Z7.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:177130,Modifiability,variab,variables,177130,"/utf-8 Set source and runtime encoding to UTF-8 (default); /U <macro> Undefine macro; /vd<value> Control vtordisp placement; /vmb Use a best-case representation method for member pointers; /vmg Use a most-general representation for member pointers; /vmm Set the default most-general representation to multiple inheritance; /vms Set the default most-general representation to single inheritance; /vmv Set the default most-general representation to virtual inheritance; /volatile:iso Volatile loads and stores have standard semantics; /volatile:ms Volatile loads and stores have acquire and release semantics; /W0 Disable all warnings; /W1 Enable -Wall; /W2 Enable -Wall; /W3 Enable -Wall; /W4 Enable -Wall and -Wextra; /Wall Enable -Weverything; /WX- Do not treat warnings as errors; /WX Treat warnings as errors; /w Disable all warnings; /X Don't add %INCLUDE% to the include search path; /Y- Disable precompiled headers, overrides /Yc and /Yu; /Yc<filename> Generate a pch file for all code up to and including <filename>; /Yu<filename> Load a pch file and use it instead of all code up to and including <filename>; /Z7 Enable CodeView debug information in object files; /Zc:char8_t Enable C++20 char8_t type; /Zc:char8_t- Disable C++20 char8_t type; /Zc:dllexportInlines- Don't dllexport/dllimport inline member functions of dllexport/import classes; /Zc:dllexportInlines dllexport/dllimport inline member functions of dllexport/import classes (default); /Zc:sizedDealloc- Disable C++14 sized global deallocation functions; /Zc:sizedDealloc Enable C++14 sized global deallocation functions; /Zc:strictStrings Treat string literals as const; /Zc:threadSafeInit- Disable thread-safe initialization of static variables; /Zc:threadSafeInit Enable thread-safe initialization of static variables; /Zc:trigraphs- Disable trigraphs (default); /Zc:trigraphs Enable trigraphs; /Zc:twoPhase- Disable two-phase name lookup in templates; /Zc:twoPhase Enable two-phase name lookup in templates; /Zi Alias for /Z7.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:189023,Modifiability,variab,variables,189023,"e compiled in the same way so that it doesn't attempt to dllimport; the inline member functions. The reverse scenario should generally work though:; a DLL compiled without this flag (such as a system library compiled with Visual; C++) can be referenced from code compiled using the flag, meaning that the; referencing code will use the inline definitions instead of importing them from; the DLL. Also note that like when using ``-fvisibility-inlines-hidden``, the address of; `S::foo()` will be different inside and outside the DLL, breaking the C/C++; standard requirement that functions have a unique address. The flag does not apply to explicit class template instantiation definitions or; declarations, as those are typically used to explicitly provide a single; definition in a DLL, (dllexported instantiation definition) or to signal that; the definition is available elsewhere (dllimport instantiation declaration). It; also doesn't apply to inline members with static local variables, to ensure; that the same instance of the variable is used inside and outside the DLL. Using this flag can cause problems when inline functions that would otherwise; be dllexported refer to internal symbols of a DLL. For example:. .. code-block:: c. void internal();. struct __declspec(dllimport) S {; void foo() { internal(); }; }. Normally, references to `S::foo()` would use the definition in the DLL from; which it was exported, and which presumably also has the definition of; `internal()`. However, when using ``/Zc:dllexportInlines-``, the inline; definition of `S::foo()` is used directly, resulting in a link error since; `internal()` is not available. Even worse, if there is an inline definition of; `internal()` containing a static local variable, we will now refer to a; different instance of that variable than in the DLL:. .. code-block:: c. inline int internal() { static int x; return x++; }. struct __declspec(dllimport) S {; int foo() { return internal(); }; }. This could lead to very sub",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:189075,Modifiability,variab,variable,189075,"e compiled in the same way so that it doesn't attempt to dllimport; the inline member functions. The reverse scenario should generally work though:; a DLL compiled without this flag (such as a system library compiled with Visual; C++) can be referenced from code compiled using the flag, meaning that the; referencing code will use the inline definitions instead of importing them from; the DLL. Also note that like when using ``-fvisibility-inlines-hidden``, the address of; `S::foo()` will be different inside and outside the DLL, breaking the C/C++; standard requirement that functions have a unique address. The flag does not apply to explicit class template instantiation definitions or; declarations, as those are typically used to explicitly provide a single; definition in a DLL, (dllexported instantiation definition) or to signal that; the definition is available elsewhere (dllimport instantiation declaration). It; also doesn't apply to inline members with static local variables, to ensure; that the same instance of the variable is used inside and outside the DLL. Using this flag can cause problems when inline functions that would otherwise; be dllexported refer to internal symbols of a DLL. For example:. .. code-block:: c. void internal();. struct __declspec(dllimport) S {; void foo() { internal(); }; }. Normally, references to `S::foo()` would use the definition in the DLL from; which it was exported, and which presumably also has the definition of; `internal()`. However, when using ``/Zc:dllexportInlines-``, the inline; definition of `S::foo()` is used directly, resulting in a link error since; `internal()` is not available. Even worse, if there is an inline definition of; `internal()` containing a static local variable, we will now refer to a; different instance of that variable than in the DLL:. .. code-block:: c. inline int internal() { static int x; return x++; }. struct __declspec(dllimport) S {; int foo() { return internal(); }; }. This could lead to very sub",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:189783,Modifiability,variab,variable,189783,"licitly provide a single; definition in a DLL, (dllexported instantiation definition) or to signal that; the definition is available elsewhere (dllimport instantiation declaration). It; also doesn't apply to inline members with static local variables, to ensure; that the same instance of the variable is used inside and outside the DLL. Using this flag can cause problems when inline functions that would otherwise; be dllexported refer to internal symbols of a DLL. For example:. .. code-block:: c. void internal();. struct __declspec(dllimport) S {; void foo() { internal(); }; }. Normally, references to `S::foo()` would use the definition in the DLL from; which it was exported, and which presumably also has the definition of; `internal()`. However, when using ``/Zc:dllexportInlines-``, the inline; definition of `S::foo()` is used directly, resulting in a link error since; `internal()` is not available. Even worse, if there is an inline definition of; `internal()` containing a static local variable, we will now refer to a; different instance of that variable than in the DLL:. .. code-block:: c. inline int internal() { static int x; return x++; }. struct __declspec(dllimport) S {; int foo() { return internal(); }; }. This could lead to very subtle bugs. Using ``-fvisibility-inlines-hidden`` can; lead to the same issue. To avoid it in this case, make `S::foo()` or; `internal()` non-inline, or mark them `dllimport/dllexport` explicitly. Finding Clang runtime libraries; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. clang-cl supports several features that require runtime library support:. - Address Sanitizer (ASan): ``-fsanitize=address``; - Undefined Behavior Sanitizer (UBSan): ``-fsanitize=undefined``; - Code coverage: ``-fprofile-instr-generate -fcoverage-mapping``; - Profile Guided Optimization (PGO): ``-fprofile-generate``; - Certain math operations (int128 division) require the builtins library. In order to use these features, the user must link the right runtime libraries; into th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:189844,Modifiability,variab,variable,189844,"licitly provide a single; definition in a DLL, (dllexported instantiation definition) or to signal that; the definition is available elsewhere (dllimport instantiation declaration). It; also doesn't apply to inline members with static local variables, to ensure; that the same instance of the variable is used inside and outside the DLL. Using this flag can cause problems when inline functions that would otherwise; be dllexported refer to internal symbols of a DLL. For example:. .. code-block:: c. void internal();. struct __declspec(dllimport) S {; void foo() { internal(); }; }. Normally, references to `S::foo()` would use the definition in the DLL from; which it was exported, and which presumably also has the definition of; `internal()`. However, when using ``/Zc:dllexportInlines-``, the inline; definition of `S::foo()` is used directly, resulting in a link error since; `internal()` is not available. Even worse, if there is an inline definition of; `internal()` containing a static local variable, we will now refer to a; different instance of that variable than in the DLL:. .. code-block:: c. inline int internal() { static int x; return x++; }. struct __declspec(dllimport) S {; int foo() { return internal(); }; }. This could lead to very subtle bugs. Using ``-fvisibility-inlines-hidden`` can; lead to the same issue. To avoid it in this case, make `S::foo()` or; `internal()` non-inline, or mark them `dllimport/dllexport` explicitly. Finding Clang runtime libraries; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. clang-cl supports several features that require runtime library support:. - Address Sanitizer (ASan): ``-fsanitize=address``; - Undefined Behavior Sanitizer (UBSan): ``-fsanitize=undefined``; - Code coverage: ``-fprofile-instr-generate -fcoverage-mapping``; - Profile Guided Optimization (PGO): ``-fprofile-generate``; - Certain math operations (int128 division) require the builtins library. In order to use these features, the user must link the right runtime libraries; into th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:195041,Modifiability,variab,variables,195041,"ven precedence. The following; extensions are part of the clang-cl toolset:. - `/winsysroot:`. The `/winsysroot:` is used as an equivalent to `-sysroot` on Unix; environments. It allows the control of an alternate location to be treated; as a system root. When specified, it will be used as the root where the; `Windows Kits` is located. - `/winsdkversion:`; - `/winsdkdir:`. If `/winsysroot:` is not specified, the `/winsdkdir:` argument is consulted; as a location to identify where the Windows SDK is located. Contrary to; `/winsysroot:`, `/winsdkdir:` is expected to be the complete path rather; than a root to locate `Windows Kits`. The `/winsdkversion:` flag allows the user to specify a version identifier; for the SDK to prefer. When this is specified, no additional validation is; performed and this version is preferred. If the version is not specified,; the highest detected version number will be used. 2. Consult the environment. TODO: This is not yet implemented. This will consult the environment variables:. - `WindowsSdkDir`; - `UCRTVersion`. 3. Fallback to the registry. If no arguments are used to indicate where the SDK is present, and the; compiler is running on Windows, the registry is consulted to locate the; installation. The Visual C++ Toolset has a slightly more elaborate mechanism for detection. 1. Consult the command line. - `/winsysroot:`. The `/winsysroot:` is used as an equivalent to `-sysroot` on Unix; environments. It allows the control of an alternate location to be treated; as a system root. When specified, it will be used as the root where the; `VC` directory is located. - `/vctoolsdir:`; - `/vctoolsversion:`. If `/winsysroot:` is not specified, the `/vctoolsdir:` argument is consulted; as a location to identify where the Visual C++ Tools are located. If; `/vctoolsversion:` is specified, that version is preferred, otherwise, the; highest version detected is used. 2. Consult the environment. - `/external:[VARIABLE]`. This specifies a user identified",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:196042,Modifiability,variab,variable,196042,"3. Fallback to the registry. If no arguments are used to indicate where the SDK is present, and the; compiler is running on Windows, the registry is consulted to locate the; installation. The Visual C++ Toolset has a slightly more elaborate mechanism for detection. 1. Consult the command line. - `/winsysroot:`. The `/winsysroot:` is used as an equivalent to `-sysroot` on Unix; environments. It allows the control of an alternate location to be treated; as a system root. When specified, it will be used as the root where the; `VC` directory is located. - `/vctoolsdir:`; - `/vctoolsversion:`. If `/winsysroot:` is not specified, the `/vctoolsdir:` argument is consulted; as a location to identify where the Visual C++ Tools are located. If; `/vctoolsversion:` is specified, that version is preferred, otherwise, the; highest version detected is used. 2. Consult the environment. - `/external:[VARIABLE]`. This specifies a user identified environment variable which is treated as; a path delimiter (`;`) separated list of paths to map into `-imsvc`; arguments which are treated as `-isystem`. - `INCLUDE` and `EXTERNAL_INCLUDE`. The path delimiter (`;`) separated list of paths will be mapped to; `-imsvc` arguments which are treated as `-isystem`. - `LIB` (indirectly). The linker `link.exe` or `lld-link.exe` will honour the environment; variable `LIB` which is a path delimiter (`;`) set of paths to consult for; the import libraries to use when linking the final target. The following environment variables will be consulted and used to form paths; to validate and load content from as appropriate:. - `VCToolsInstallDir`; - `VCINSTALLDIR`; - `Path`. 3. Consult `ISetupConfiguration` [Windows Only]. Assuming that the toolchain is built with `USE_MSVC_SETUP_API` defined and; is running on Windows, the Visual Studio COM interface `ISetupConfiguration`; will be used to locate the installation of the MSVC toolset. 4. Fallback to the registry [DEPRECATED]. The registry information is used to he",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:196431,Modifiability,variab,variable,196431,". It allows the control of an alternate location to be treated; as a system root. When specified, it will be used as the root where the; `VC` directory is located. - `/vctoolsdir:`; - `/vctoolsversion:`. If `/winsysroot:` is not specified, the `/vctoolsdir:` argument is consulted; as a location to identify where the Visual C++ Tools are located. If; `/vctoolsversion:` is specified, that version is preferred, otherwise, the; highest version detected is used. 2. Consult the environment. - `/external:[VARIABLE]`. This specifies a user identified environment variable which is treated as; a path delimiter (`;`) separated list of paths to map into `-imsvc`; arguments which are treated as `-isystem`. - `INCLUDE` and `EXTERNAL_INCLUDE`. The path delimiter (`;`) separated list of paths will be mapped to; `-imsvc` arguments which are treated as `-isystem`. - `LIB` (indirectly). The linker `link.exe` or `lld-link.exe` will honour the environment; variable `LIB` which is a path delimiter (`;`) set of paths to consult for; the import libraries to use when linking the final target. The following environment variables will be consulted and used to form paths; to validate and load content from as appropriate:. - `VCToolsInstallDir`; - `VCINSTALLDIR`; - `Path`. 3. Consult `ISetupConfiguration` [Windows Only]. Assuming that the toolchain is built with `USE_MSVC_SETUP_API` defined and; is running on Windows, the Visual Studio COM interface `ISetupConfiguration`; will be used to locate the installation of the MSVC toolset. 4. Fallback to the registry [DEPRECATED]. The registry information is used to help locate the installation as a final; fallback. This is only possible for pre-VS2017 installations and is; considered deprecated. Restrictions and Limitations compared to Clang; ----------------------------------------------. Strict Aliasing; ^^^^^^^^^^^^^^^. Strict aliasing (TBAA) is always off by default in clang-cl. Whereas in clang,; strict aliasing is turned on by default for all op",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:196592,Modifiability,variab,variables,196592,"ory is located. - `/vctoolsdir:`; - `/vctoolsversion:`. If `/winsysroot:` is not specified, the `/vctoolsdir:` argument is consulted; as a location to identify where the Visual C++ Tools are located. If; `/vctoolsversion:` is specified, that version is preferred, otherwise, the; highest version detected is used. 2. Consult the environment. - `/external:[VARIABLE]`. This specifies a user identified environment variable which is treated as; a path delimiter (`;`) separated list of paths to map into `-imsvc`; arguments which are treated as `-isystem`. - `INCLUDE` and `EXTERNAL_INCLUDE`. The path delimiter (`;`) separated list of paths will be mapped to; `-imsvc` arguments which are treated as `-isystem`. - `LIB` (indirectly). The linker `link.exe` or `lld-link.exe` will honour the environment; variable `LIB` which is a path delimiter (`;`) set of paths to consult for; the import libraries to use when linking the final target. The following environment variables will be consulted and used to form paths; to validate and load content from as appropriate:. - `VCToolsInstallDir`; - `VCINSTALLDIR`; - `Path`. 3. Consult `ISetupConfiguration` [Windows Only]. Assuming that the toolchain is built with `USE_MSVC_SETUP_API` defined and; is running on Windows, the Visual Studio COM interface `ISetupConfiguration`; will be used to locate the installation of the MSVC toolset. 4. Fallback to the registry [DEPRECATED]. The registry information is used to help locate the installation as a final; fallback. This is only possible for pre-VS2017 installations and is; considered deprecated. Restrictions and Limitations compared to Clang; ----------------------------------------------. Strict Aliasing; ^^^^^^^^^^^^^^^. Strict aliasing (TBAA) is always off by default in clang-cl. Whereas in clang,; strict aliasing is turned on by default for all optimization levels. To enable LLVM optimizations based on strict aliasing rules (e.g., optimizations; based on type of expressions in C/C++), user wil",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:351,Performance,optimiz,optimizer,351,"============================; Clang Compiler User's Manual; ============================. .. include:: <isonum.txt>. .. contents::; :local:. Introduction; ============. The Clang Compiler is an open-source compiler for the C family of; programming languages, aiming to be the best in class implementation of; these languages. Clang builds on the LLVM optimizer and code generator,; allowing it to provide high-quality optimization and code generation; support for many targets. For more general information, please see the; `Clang Web Site <https://clang.llvm.org>`_ or the `LLVM Web; Site <https://llvm.org>`_. This document describes important notes about using Clang as a compiler; for an end-user, documenting the supported features, command line; options, etc. If you are interested in using Clang to build a tool that; processes code, please see :doc:`InternalsManual`. If you are interested in the; `Clang Static Analyzer <https://clang-analyzer.llvm.org>`_, please see its web; page. Clang is one component in a complete toolchain for C family languages.; A separate document describes the other pieces necessary to; :doc:`assemble a complete toolchain <Toolchain>`. Clang is designed to support the C family of programming languages,; which includes :ref:`C <c>`, :ref:`Objective-C <objc>`, :ref:`C++ <cxx>`, and; :ref:`Objective-C++ <objcxx>` as well as many dialects of those. For; language-specific information, please see the corresponding language; specific section:. - :ref:`C Language <c>`: K&R C, ANSI C89, ISO C90, ISO C94 (C89+AMD1), ISO; C99 (+TC1, TC2, TC3).; - :ref:`Objective-C Language <objc>`: ObjC 1, ObjC 2, ObjC 2.1, plus; variants depending on base language.; - :ref:`C++ Language <cxx>`; - :ref:`Objective C++ Language <objcxx>`; - :ref:`OpenCL Kernel Language <opencl>`: OpenCL C 1.0, 1.1, 1.2, 2.0, 3.0,; and C++ for OpenCL 1.0 and 2021. In addition to these base languages and their dialects, Clang supports a; broad variety of language extensions, which are documente",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:418,Performance,optimiz,optimization,418,"============================; Clang Compiler User's Manual; ============================. .. include:: <isonum.txt>. .. contents::; :local:. Introduction; ============. The Clang Compiler is an open-source compiler for the C family of; programming languages, aiming to be the best in class implementation of; these languages. Clang builds on the LLVM optimizer and code generator,; allowing it to provide high-quality optimization and code generation; support for many targets. For more general information, please see the; `Clang Web Site <https://clang.llvm.org>`_ or the `LLVM Web; Site <https://llvm.org>`_. This document describes important notes about using Clang as a compiler; for an end-user, documenting the supported features, command line; options, etc. If you are interested in using Clang to build a tool that; processes code, please see :doc:`InternalsManual`. If you are interested in the; `Clang Static Analyzer <https://clang-analyzer.llvm.org>`_, please see its web; page. Clang is one component in a complete toolchain for C family languages.; A separate document describes the other pieces necessary to; :doc:`assemble a complete toolchain <Toolchain>`. Clang is designed to support the C family of programming languages,; which includes :ref:`C <c>`, :ref:`Objective-C <objc>`, :ref:`C++ <cxx>`, and; :ref:`Objective-C++ <objcxx>` as well as many dialects of those. For; language-specific information, please see the corresponding language; specific section:. - :ref:`C Language <c>`: K&R C, ANSI C89, ISO C90, ISO C94 (C89+AMD1), ISO; C99 (+TC1, TC2, TC3).; - :ref:`Objective-C Language <objc>`: ObjC 1, ObjC 2, ObjC 2.1, plus; variants depending on base language.; - :ref:`C++ Language <cxx>`; - :ref:`Objective C++ Language <objcxx>`; - :ref:`OpenCL Kernel Language <opencl>`: OpenCL C 1.0, 1.1, 1.2, 2.0, 3.0,; and C++ for OpenCL 1.0 and 2021. In addition to these base languages and their dialects, Clang supports a; broad variety of language extensions, which are documente",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:3170,Performance,optimiz,optimizer,3170,"pilers as well; as to improve functionality through Clang-specific features. The Clang; driver and language features are intentionally designed to be as; compatible with the GNU GCC compiler as reasonably possible, easing; migration from GCC to Clang. In most cases, code ""just works"".; Clang also provides an alternative driver, :ref:`clang-cl`, that is designed; to be compatible with the Visual C++ compiler, cl.exe. In addition to language specific features, Clang has a variety of; features that depend on what CPU architecture or operating system is; being compiled for. Please see the :ref:`Target-Specific Features and; Limitations <target_features>` section for more details. The rest of the introduction introduces some basic :ref:`compiler; terminology <terminology>` that is used throughout this manual and; contains a basic :ref:`introduction to using Clang <basicusage>` as a; command line compiler. .. _terminology:. Terminology; -----------. Front end, parser, backend, preprocessor, undefined behavior,; diagnostic, optimizer. .. _basicusage:. Basic Usage; -----------. Intro to how to use a C compiler for newbies. compile + link compile then link debug info enabling optimizations; picking a language to use, defaults to C17 by default. Autosenses based; on extension. using a makefile. Command Line Options; ====================. This section is generally an index into other sections. It does not go; into depth on the ones that are covered by other sections. However, the; first part introduces the language selection and other high level; options like :option:`-c`, :option:`-g`, etc. Options to Control Error and Warning Messages; ---------------------------------------------. .. option:: -Werror. Turn warnings into errors. .. This is in plain monospaced font because it generates the same label as; .. -Werror, and Sphinx complains. ``-Werror=foo``. Turn warning ""foo"" into an error. .. option:: -Wno-error=foo. Turn warning ""foo"" into a warning even if :option:`-Werror` i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:3323,Performance,optimiz,optimizations,3323," reasonably possible, easing; migration from GCC to Clang. In most cases, code ""just works"".; Clang also provides an alternative driver, :ref:`clang-cl`, that is designed; to be compatible with the Visual C++ compiler, cl.exe. In addition to language specific features, Clang has a variety of; features that depend on what CPU architecture or operating system is; being compiled for. Please see the :ref:`Target-Specific Features and; Limitations <target_features>` section for more details. The rest of the introduction introduces some basic :ref:`compiler; terminology <terminology>` that is used throughout this manual and; contains a basic :ref:`introduction to using Clang <basicusage>` as a; command line compiler. .. _terminology:. Terminology; -----------. Front end, parser, backend, preprocessor, undefined behavior,; diagnostic, optimizer. .. _basicusage:. Basic Usage; -----------. Intro to how to use a C compiler for newbies. compile + link compile then link debug info enabling optimizations; picking a language to use, defaults to C17 by default. Autosenses based; on extension. using a makefile. Command Line Options; ====================. This section is generally an index into other sections. It does not go; into depth on the ones that are covered by other sections. However, the; first part introduces the language selection and other high level; options like :option:`-c`, :option:`-g`, etc. Options to Control Error and Warning Messages; ---------------------------------------------. .. option:: -Werror. Turn warnings into errors. .. This is in plain monospaced font because it generates the same label as; .. -Werror, and Sphinx complains. ``-Werror=foo``. Turn warning ""foo"" into an error. .. option:: -Wno-error=foo. Turn warning ""foo"" into a warning even if :option:`-Werror` is specified. .. option:: -Wfoo. Enable warning ""foo"".; See the :doc:`diagnostics reference <DiagnosticsReference>` for a complete; list of the warning flags that can be specified in this way. ..",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:10785,Performance,optimiz,optimization-record,10785,"e/id/name. Enable printing category information in diagnostic line. This option, which defaults to ""none"", controls whether or not Clang; prints the category associated with a diagnostic when emitting it.; Each diagnostic may or many not have an associated category, if it; has one, it is listed in the diagnostic categorization field of the; diagnostic line (in the []'s). For example, a format string warning will produce these three; renditions based on the setting of this option:. ::. t.c:3:11: warning: conversion specifies type 'char *' but the argument has type 'int' [-Wformat]; t.c:3:11: warning: conversion specifies type 'char *' but the argument has type 'int' [-Wformat,1]; t.c:3:11: warning: conversion specifies type 'char *' but the argument has type 'int' [-Wformat,Format String]. This category can be used by clients that want to group diagnostics; by category, so it should be a high level category. We want dozens; of these, not hundreds or thousands of them. .. _opt_fsave-optimization-record:. .. option:: -f[no-]save-optimization-record[=<format>]. Enable optimization remarks during compilation and write them to a separate; file. This option, which defaults to off, controls whether Clang writes; optimization reports to a separate file. By recording diagnostics in a file,; users can parse or sort the remarks in a convenient way. By default, the serialization format is YAML. The supported serialization formats are:. - .. _opt_fsave_optimization_record_yaml:. ``-fsave-optimization-record=yaml``: A structured YAML format. - .. _opt_fsave_optimization_record_bitstream:. ``-fsave-optimization-record=bitstream``: A binary format based on LLVM; Bitstream. The output file is controlled by :option:`-foptimization-record-file`. In the absence of an explicit output file, the file is chosen using the; following scheme:. ``<base>.opt.<format>``. where ``<base>`` is based on the output file of the compilation (whether; it's explicitly specified through `-o` or not) when us",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:10831,Performance,optimiz,optimization-record,10831,"n in diagnostic line. This option, which defaults to ""none"", controls whether or not Clang; prints the category associated with a diagnostic when emitting it.; Each diagnostic may or many not have an associated category, if it; has one, it is listed in the diagnostic categorization field of the; diagnostic line (in the []'s). For example, a format string warning will produce these three; renditions based on the setting of this option:. ::. t.c:3:11: warning: conversion specifies type 'char *' but the argument has type 'int' [-Wformat]; t.c:3:11: warning: conversion specifies type 'char *' but the argument has type 'int' [-Wformat,1]; t.c:3:11: warning: conversion specifies type 'char *' but the argument has type 'int' [-Wformat,Format String]. This category can be used by clients that want to group diagnostics; by category, so it should be a high level category. We want dozens; of these, not hundreds or thousands of them. .. _opt_fsave-optimization-record:. .. option:: -f[no-]save-optimization-record[=<format>]. Enable optimization remarks during compilation and write them to a separate; file. This option, which defaults to off, controls whether Clang writes; optimization reports to a separate file. By recording diagnostics in a file,; users can parse or sort the remarks in a convenient way. By default, the serialization format is YAML. The supported serialization formats are:. - .. _opt_fsave_optimization_record_yaml:. ``-fsave-optimization-record=yaml``: A structured YAML format. - .. _opt_fsave_optimization_record_bitstream:. ``-fsave-optimization-record=bitstream``: A binary format based on LLVM; Bitstream. The output file is controlled by :option:`-foptimization-record-file`. In the absence of an explicit output file, the file is chosen using the; following scheme:. ``<base>.opt.<format>``. where ``<base>`` is based on the output file of the compilation (whether; it's explicitly specified through `-o` or not) when used with `-c` or `-S`.; For example:. * ``clang",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:10870,Performance,optimiz,optimization,10870,"s whether or not Clang; prints the category associated with a diagnostic when emitting it.; Each diagnostic may or many not have an associated category, if it; has one, it is listed in the diagnostic categorization field of the; diagnostic line (in the []'s). For example, a format string warning will produce these three; renditions based on the setting of this option:. ::. t.c:3:11: warning: conversion specifies type 'char *' but the argument has type 'int' [-Wformat]; t.c:3:11: warning: conversion specifies type 'char *' but the argument has type 'int' [-Wformat,1]; t.c:3:11: warning: conversion specifies type 'char *' but the argument has type 'int' [-Wformat,Format String]. This category can be used by clients that want to group diagnostics; by category, so it should be a high level category. We want dozens; of these, not hundreds or thousands of them. .. _opt_fsave-optimization-record:. .. option:: -f[no-]save-optimization-record[=<format>]. Enable optimization remarks during compilation and write them to a separate; file. This option, which defaults to off, controls whether Clang writes; optimization reports to a separate file. By recording diagnostics in a file,; users can parse or sort the remarks in a convenient way. By default, the serialization format is YAML. The supported serialization formats are:. - .. _opt_fsave_optimization_record_yaml:. ``-fsave-optimization-record=yaml``: A structured YAML format. - .. _opt_fsave_optimization_record_bitstream:. ``-fsave-optimization-record=bitstream``: A binary format based on LLVM; Bitstream. The output file is controlled by :option:`-foptimization-record-file`. In the absence of an explicit output file, the file is chosen using the; following scheme:. ``<base>.opt.<format>``. where ``<base>`` is based on the output file of the compilation (whether; it's explicitly specified through `-o` or not) when used with `-c` or `-S`.; For example:. * ``clang -fsave-optimization-record -c in.c -o out.o`` will generate; ``out.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:11013,Performance,optimiz,optimization,11013," diagnostic may or many not have an associated category, if it; has one, it is listed in the diagnostic categorization field of the; diagnostic line (in the []'s). For example, a format string warning will produce these three; renditions based on the setting of this option:. ::. t.c:3:11: warning: conversion specifies type 'char *' but the argument has type 'int' [-Wformat]; t.c:3:11: warning: conversion specifies type 'char *' but the argument has type 'int' [-Wformat,1]; t.c:3:11: warning: conversion specifies type 'char *' but the argument has type 'int' [-Wformat,Format String]. This category can be used by clients that want to group diagnostics; by category, so it should be a high level category. We want dozens; of these, not hundreds or thousands of them. .. _opt_fsave-optimization-record:. .. option:: -f[no-]save-optimization-record[=<format>]. Enable optimization remarks during compilation and write them to a separate; file. This option, which defaults to off, controls whether Clang writes; optimization reports to a separate file. By recording diagnostics in a file,; users can parse or sort the remarks in a convenient way. By default, the serialization format is YAML. The supported serialization formats are:. - .. _opt_fsave_optimization_record_yaml:. ``-fsave-optimization-record=yaml``: A structured YAML format. - .. _opt_fsave_optimization_record_bitstream:. ``-fsave-optimization-record=bitstream``: A binary format based on LLVM; Bitstream. The output file is controlled by :option:`-foptimization-record-file`. In the absence of an explicit output file, the file is chosen using the; following scheme:. ``<base>.opt.<format>``. where ``<base>`` is based on the output file of the compilation (whether; it's explicitly specified through `-o` or not) when used with `-c` or `-S`.; For example:. * ``clang -fsave-optimization-record -c in.c -o out.o`` will generate; ``out.opt.yaml``. * ``clang -fsave-optimization-record -c in.c`` will generate; ``in.opt.yaml``. When",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:11288,Performance,optimiz,optimization-record,11288,"specifies type 'char *' but the argument has type 'int' [-Wformat]; t.c:3:11: warning: conversion specifies type 'char *' but the argument has type 'int' [-Wformat,1]; t.c:3:11: warning: conversion specifies type 'char *' but the argument has type 'int' [-Wformat,Format String]. This category can be used by clients that want to group diagnostics; by category, so it should be a high level category. We want dozens; of these, not hundreds or thousands of them. .. _opt_fsave-optimization-record:. .. option:: -f[no-]save-optimization-record[=<format>]. Enable optimization remarks during compilation and write them to a separate; file. This option, which defaults to off, controls whether Clang writes; optimization reports to a separate file. By recording diagnostics in a file,; users can parse or sort the remarks in a convenient way. By default, the serialization format is YAML. The supported serialization formats are:. - .. _opt_fsave_optimization_record_yaml:. ``-fsave-optimization-record=yaml``: A structured YAML format. - .. _opt_fsave_optimization_record_bitstream:. ``-fsave-optimization-record=bitstream``: A binary format based on LLVM; Bitstream. The output file is controlled by :option:`-foptimization-record-file`. In the absence of an explicit output file, the file is chosen using the; following scheme:. ``<base>.opt.<format>``. where ``<base>`` is based on the output file of the compilation (whether; it's explicitly specified through `-o` or not) when used with `-c` or `-S`.; For example:. * ``clang -fsave-optimization-record -c in.c -o out.o`` will generate; ``out.opt.yaml``. * ``clang -fsave-optimization-record -c in.c`` will generate; ``in.opt.yaml``. When targeting (Thin)LTO, the base is derived from the output filename, and; the extension is not dropped. When targeting ThinLTO, the following scheme is used:. ``<base>.opt.<format>.thin.<num>.<format>``. Darwin-only: when used for generating a linked binary from a source file; (through an intermediate object fi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:11399,Performance,optimiz,optimization-record,11399,"but the argument has type 'int' [-Wformat,1]; t.c:3:11: warning: conversion specifies type 'char *' but the argument has type 'int' [-Wformat,Format String]. This category can be used by clients that want to group diagnostics; by category, so it should be a high level category. We want dozens; of these, not hundreds or thousands of them. .. _opt_fsave-optimization-record:. .. option:: -f[no-]save-optimization-record[=<format>]. Enable optimization remarks during compilation and write them to a separate; file. This option, which defaults to off, controls whether Clang writes; optimization reports to a separate file. By recording diagnostics in a file,; users can parse or sort the remarks in a convenient way. By default, the serialization format is YAML. The supported serialization formats are:. - .. _opt_fsave_optimization_record_yaml:. ``-fsave-optimization-record=yaml``: A structured YAML format. - .. _opt_fsave_optimization_record_bitstream:. ``-fsave-optimization-record=bitstream``: A binary format based on LLVM; Bitstream. The output file is controlled by :option:`-foptimization-record-file`. In the absence of an explicit output file, the file is chosen using the; following scheme:. ``<base>.opt.<format>``. where ``<base>`` is based on the output file of the compilation (whether; it's explicitly specified through `-o` or not) when used with `-c` or `-S`.; For example:. * ``clang -fsave-optimization-record -c in.c -o out.o`` will generate; ``out.opt.yaml``. * ``clang -fsave-optimization-record -c in.c`` will generate; ``in.opt.yaml``. When targeting (Thin)LTO, the base is derived from the output filename, and; the extension is not dropped. When targeting ThinLTO, the following scheme is used:. ``<base>.opt.<format>.thin.<num>.<format>``. Darwin-only: when used for generating a linked binary from a source file; (through an intermediate object file), the driver will invoke `cc1` to; generate a temporary object file. The temporary remark file will be emitted; next t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:11844,Performance,optimiz,optimization-record,11844,"rd[=<format>]. Enable optimization remarks during compilation and write them to a separate; file. This option, which defaults to off, controls whether Clang writes; optimization reports to a separate file. By recording diagnostics in a file,; users can parse or sort the remarks in a convenient way. By default, the serialization format is YAML. The supported serialization formats are:. - .. _opt_fsave_optimization_record_yaml:. ``-fsave-optimization-record=yaml``: A structured YAML format. - .. _opt_fsave_optimization_record_bitstream:. ``-fsave-optimization-record=bitstream``: A binary format based on LLVM; Bitstream. The output file is controlled by :option:`-foptimization-record-file`. In the absence of an explicit output file, the file is chosen using the; following scheme:. ``<base>.opt.<format>``. where ``<base>`` is based on the output file of the compilation (whether; it's explicitly specified through `-o` or not) when used with `-c` or `-S`.; For example:. * ``clang -fsave-optimization-record -c in.c -o out.o`` will generate; ``out.opt.yaml``. * ``clang -fsave-optimization-record -c in.c`` will generate; ``in.opt.yaml``. When targeting (Thin)LTO, the base is derived from the output filename, and; the extension is not dropped. When targeting ThinLTO, the following scheme is used:. ``<base>.opt.<format>.thin.<num>.<format>``. Darwin-only: when used for generating a linked binary from a source file; (through an intermediate object file), the driver will invoke `cc1` to; generate a temporary object file. The temporary remark file will be emitted; next to the object file, which will then be picked up by `dsymutil` and; emitted in the .dSYM bundle. This is available for all formats except YAML. For example:. ``clang -fsave-optimization-record=bitstream in.c -o out`` will generate. * ``/var/folders/43/9y164hh52tv_2nrdxrj31nyw0000gn/T/a-9be59b.o``. * ``/var/folders/43/9y164hh52tv_2nrdxrj31nyw0000gn/T/a-9be59b.opt.bitstream``. * ``out``. * ``out.dSYM/Contents/Resourc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:11933,Performance,optimiz,optimization-record,11933,"e; file. This option, which defaults to off, controls whether Clang writes; optimization reports to a separate file. By recording diagnostics in a file,; users can parse or sort the remarks in a convenient way. By default, the serialization format is YAML. The supported serialization formats are:. - .. _opt_fsave_optimization_record_yaml:. ``-fsave-optimization-record=yaml``: A structured YAML format. - .. _opt_fsave_optimization_record_bitstream:. ``-fsave-optimization-record=bitstream``: A binary format based on LLVM; Bitstream. The output file is controlled by :option:`-foptimization-record-file`. In the absence of an explicit output file, the file is chosen using the; following scheme:. ``<base>.opt.<format>``. where ``<base>`` is based on the output file of the compilation (whether; it's explicitly specified through `-o` or not) when used with `-c` or `-S`.; For example:. * ``clang -fsave-optimization-record -c in.c -o out.o`` will generate; ``out.opt.yaml``. * ``clang -fsave-optimization-record -c in.c`` will generate; ``in.opt.yaml``. When targeting (Thin)LTO, the base is derived from the output filename, and; the extension is not dropped. When targeting ThinLTO, the following scheme is used:. ``<base>.opt.<format>.thin.<num>.<format>``. Darwin-only: when used for generating a linked binary from a source file; (through an intermediate object file), the driver will invoke `cc1` to; generate a temporary object file. The temporary remark file will be emitted; next to the object file, which will then be picked up by `dsymutil` and; emitted in the .dSYM bundle. This is available for all formats except YAML. For example:. ``clang -fsave-optimization-record=bitstream in.c -o out`` will generate. * ``/var/folders/43/9y164hh52tv_2nrdxrj31nyw0000gn/T/a-9be59b.o``. * ``/var/folders/43/9y164hh52tv_2nrdxrj31nyw0000gn/T/a-9be59b.opt.bitstream``. * ``out``. * ``out.dSYM/Contents/Resources/Remarks/out``. Darwin-only: compiling for multiple architectures will use the followin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:12603,Performance,optimiz,optimization-record,12603,"g the; following scheme:. ``<base>.opt.<format>``. where ``<base>`` is based on the output file of the compilation (whether; it's explicitly specified through `-o` or not) when used with `-c` or `-S`.; For example:. * ``clang -fsave-optimization-record -c in.c -o out.o`` will generate; ``out.opt.yaml``. * ``clang -fsave-optimization-record -c in.c`` will generate; ``in.opt.yaml``. When targeting (Thin)LTO, the base is derived from the output filename, and; the extension is not dropped. When targeting ThinLTO, the following scheme is used:. ``<base>.opt.<format>.thin.<num>.<format>``. Darwin-only: when used for generating a linked binary from a source file; (through an intermediate object file), the driver will invoke `cc1` to; generate a temporary object file. The temporary remark file will be emitted; next to the object file, which will then be picked up by `dsymutil` and; emitted in the .dSYM bundle. This is available for all formats except YAML. For example:. ``clang -fsave-optimization-record=bitstream in.c -o out`` will generate. * ``/var/folders/43/9y164hh52tv_2nrdxrj31nyw0000gn/T/a-9be59b.o``. * ``/var/folders/43/9y164hh52tv_2nrdxrj31nyw0000gn/T/a-9be59b.opt.bitstream``. * ``out``. * ``out.dSYM/Contents/Resources/Remarks/out``. Darwin-only: compiling for multiple architectures will use the following; scheme:. ``<base>-<arch>.opt.<format>``. Note that this is incompatible with passing the; :option:`-foptimization-record-file` option. .. option:: -foptimization-record-file. Control the file to which optimization reports are written. This implies; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>`. On Darwin platforms, this is incompatible with passing multiple; ``-arch <arch>`` options. .. option:: -foptimization-record-passes. Only include passes which match a specified regular expression. When optimization reports are being output (see; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>`), this; option controls the passes that will",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:13141,Performance,optimiz,optimization,13141,"me is used:. ``<base>.opt.<format>.thin.<num>.<format>``. Darwin-only: when used for generating a linked binary from a source file; (through an intermediate object file), the driver will invoke `cc1` to; generate a temporary object file. The temporary remark file will be emitted; next to the object file, which will then be picked up by `dsymutil` and; emitted in the .dSYM bundle. This is available for all formats except YAML. For example:. ``clang -fsave-optimization-record=bitstream in.c -o out`` will generate. * ``/var/folders/43/9y164hh52tv_2nrdxrj31nyw0000gn/T/a-9be59b.o``. * ``/var/folders/43/9y164hh52tv_2nrdxrj31nyw0000gn/T/a-9be59b.opt.bitstream``. * ``out``. * ``out.dSYM/Contents/Resources/Remarks/out``. Darwin-only: compiling for multiple architectures will use the following; scheme:. ``<base>-<arch>.opt.<format>``. Note that this is incompatible with passing the; :option:`-foptimization-record-file` option. .. option:: -foptimization-record-file. Control the file to which optimization reports are written. This implies; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>`. On Darwin platforms, this is incompatible with passing multiple; ``-arch <arch>`` options. .. option:: -foptimization-record-passes. Only include passes which match a specified regular expression. When optimization reports are being output (see; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>`), this; option controls the passes that will be included in the final report. If this option is not used, all the passes are included in the optimization; record. .. _opt_fdiagnostics-show-hotness:. .. option:: -f[no-]diagnostics-show-hotness. Enable profile hotness information in diagnostic line. This option controls whether Clang prints the profile hotness associated; with diagnostics in the presence of profile-guided optimization information.; This is currently supported with optimization remarks (see; :ref:`Options to Emit Optimization Reports <rpass>`). The hotness",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:13202,Performance,optimiz,optimization-record,13202," when used for generating a linked binary from a source file; (through an intermediate object file), the driver will invoke `cc1` to; generate a temporary object file. The temporary remark file will be emitted; next to the object file, which will then be picked up by `dsymutil` and; emitted in the .dSYM bundle. This is available for all formats except YAML. For example:. ``clang -fsave-optimization-record=bitstream in.c -o out`` will generate. * ``/var/folders/43/9y164hh52tv_2nrdxrj31nyw0000gn/T/a-9be59b.o``. * ``/var/folders/43/9y164hh52tv_2nrdxrj31nyw0000gn/T/a-9be59b.opt.bitstream``. * ``out``. * ``out.dSYM/Contents/Resources/Remarks/out``. Darwin-only: compiling for multiple architectures will use the following; scheme:. ``<base>-<arch>.opt.<format>``. Note that this is incompatible with passing the; :option:`-foptimization-record-file` option. .. option:: -foptimization-record-file. Control the file to which optimization reports are written. This implies; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>`. On Darwin platforms, this is incompatible with passing multiple; ``-arch <arch>`` options. .. option:: -foptimization-record-passes. Only include passes which match a specified regular expression. When optimization reports are being output (see; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>`), this; option controls the passes that will be included in the final report. If this option is not used, all the passes are included in the optimization; record. .. _opt_fdiagnostics-show-hotness:. .. option:: -f[no-]diagnostics-show-hotness. Enable profile hotness information in diagnostic line. This option controls whether Clang prints the profile hotness associated; with diagnostics in the presence of profile-guided optimization information.; This is currently supported with optimization remarks (see; :ref:`Options to Emit Optimization Reports <rpass>`). The hotness information; allows users to focus on the hot optimization remarks tha",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:13233,Performance,optimiz,optimization-record,13233," when used for generating a linked binary from a source file; (through an intermediate object file), the driver will invoke `cc1` to; generate a temporary object file. The temporary remark file will be emitted; next to the object file, which will then be picked up by `dsymutil` and; emitted in the .dSYM bundle. This is available for all formats except YAML. For example:. ``clang -fsave-optimization-record=bitstream in.c -o out`` will generate. * ``/var/folders/43/9y164hh52tv_2nrdxrj31nyw0000gn/T/a-9be59b.o``. * ``/var/folders/43/9y164hh52tv_2nrdxrj31nyw0000gn/T/a-9be59b.opt.bitstream``. * ``out``. * ``out.dSYM/Contents/Resources/Remarks/out``. Darwin-only: compiling for multiple architectures will use the following; scheme:. ``<base>-<arch>.opt.<format>``. Note that this is incompatible with passing the; :option:`-foptimization-record-file` option. .. option:: -foptimization-record-file. Control the file to which optimization reports are written. This implies; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>`. On Darwin platforms, this is incompatible with passing multiple; ``-arch <arch>`` options. .. option:: -foptimization-record-passes. Only include passes which match a specified regular expression. When optimization reports are being output (see; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>`), this; option controls the passes that will be included in the final report. If this option is not used, all the passes are included in the optimization; record. .. _opt_fdiagnostics-show-hotness:. .. option:: -f[no-]diagnostics-show-hotness. Enable profile hotness information in diagnostic line. This option controls whether Clang prints the profile hotness associated; with diagnostics in the presence of profile-guided optimization information.; This is currently supported with optimization remarks (see; :ref:`Options to Emit Optimization Reports <rpass>`). The hotness information; allows users to focus on the hot optimization remarks tha",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:13458,Performance,optimiz,optimization,13458," all formats except YAML. For example:. ``clang -fsave-optimization-record=bitstream in.c -o out`` will generate. * ``/var/folders/43/9y164hh52tv_2nrdxrj31nyw0000gn/T/a-9be59b.o``. * ``/var/folders/43/9y164hh52tv_2nrdxrj31nyw0000gn/T/a-9be59b.opt.bitstream``. * ``out``. * ``out.dSYM/Contents/Resources/Remarks/out``. Darwin-only: compiling for multiple architectures will use the following; scheme:. ``<base>-<arch>.opt.<format>``. Note that this is incompatible with passing the; :option:`-foptimization-record-file` option. .. option:: -foptimization-record-file. Control the file to which optimization reports are written. This implies; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>`. On Darwin platforms, this is incompatible with passing multiple; ``-arch <arch>`` options. .. option:: -foptimization-record-passes. Only include passes which match a specified regular expression. When optimization reports are being output (see; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>`), this; option controls the passes that will be included in the final report. If this option is not used, all the passes are included in the optimization; record. .. _opt_fdiagnostics-show-hotness:. .. option:: -f[no-]diagnostics-show-hotness. Enable profile hotness information in diagnostic line. This option controls whether Clang prints the profile hotness associated; with diagnostics in the presence of profile-guided optimization information.; This is currently supported with optimization remarks (see; :ref:`Options to Emit Optimization Reports <rpass>`). The hotness information; allows users to focus on the hot optimization remarks that are likely to be; more relevant for run-time performance. For example, in this output, the block containing the callsite of `foo` was; executed 3000 times according to the profile data:. ::. s.c:7:10: remark: foo inlined into bar (hotness: 3000) [-Rpass-analysis=inline]; sum += foo(x, x - 2);; ^. This option is implied when; :ref:",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:13515,Performance,optimiz,optimization-record,13515," all formats except YAML. For example:. ``clang -fsave-optimization-record=bitstream in.c -o out`` will generate. * ``/var/folders/43/9y164hh52tv_2nrdxrj31nyw0000gn/T/a-9be59b.o``. * ``/var/folders/43/9y164hh52tv_2nrdxrj31nyw0000gn/T/a-9be59b.opt.bitstream``. * ``out``. * ``out.dSYM/Contents/Resources/Remarks/out``. Darwin-only: compiling for multiple architectures will use the following; scheme:. ``<base>-<arch>.opt.<format>``. Note that this is incompatible with passing the; :option:`-foptimization-record-file` option. .. option:: -foptimization-record-file. Control the file to which optimization reports are written. This implies; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>`. On Darwin platforms, this is incompatible with passing multiple; ``-arch <arch>`` options. .. option:: -foptimization-record-passes. Only include passes which match a specified regular expression. When optimization reports are being output (see; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>`), this; option controls the passes that will be included in the final report. If this option is not used, all the passes are included in the optimization; record. .. _opt_fdiagnostics-show-hotness:. .. option:: -f[no-]diagnostics-show-hotness. Enable profile hotness information in diagnostic line. This option controls whether Clang prints the profile hotness associated; with diagnostics in the presence of profile-guided optimization information.; This is currently supported with optimization remarks (see; :ref:`Options to Emit Optimization Reports <rpass>`). The hotness information; allows users to focus on the hot optimization remarks that are likely to be; more relevant for run-time performance. For example, in this output, the block containing the callsite of `foo` was; executed 3000 times according to the profile data:. ::. s.c:7:10: remark: foo inlined into bar (hotness: 3000) [-Rpass-analysis=inline]; sum += foo(x, x - 2);; ^. This option is implied when; :ref:",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:13546,Performance,optimiz,optimization-record,13546," all formats except YAML. For example:. ``clang -fsave-optimization-record=bitstream in.c -o out`` will generate. * ``/var/folders/43/9y164hh52tv_2nrdxrj31nyw0000gn/T/a-9be59b.o``. * ``/var/folders/43/9y164hh52tv_2nrdxrj31nyw0000gn/T/a-9be59b.opt.bitstream``. * ``out``. * ``out.dSYM/Contents/Resources/Remarks/out``. Darwin-only: compiling for multiple architectures will use the following; scheme:. ``<base>-<arch>.opt.<format>``. Note that this is incompatible with passing the; :option:`-foptimization-record-file` option. .. option:: -foptimization-record-file. Control the file to which optimization reports are written. This implies; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>`. On Darwin platforms, this is incompatible with passing multiple; ``-arch <arch>`` options. .. option:: -foptimization-record-passes. Only include passes which match a specified regular expression. When optimization reports are being output (see; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>`), this; option controls the passes that will be included in the final report. If this option is not used, all the passes are included in the optimization; record. .. _opt_fdiagnostics-show-hotness:. .. option:: -f[no-]diagnostics-show-hotness. Enable profile hotness information in diagnostic line. This option controls whether Clang prints the profile hotness associated; with diagnostics in the presence of profile-guided optimization information.; This is currently supported with optimization remarks (see; :ref:`Options to Emit Optimization Reports <rpass>`). The hotness information; allows users to focus on the hot optimization remarks that are likely to be; more relevant for run-time performance. For example, in this output, the block containing the callsite of `foo` was; executed 3000 times according to the profile data:. ::. s.c:7:10: remark: foo inlined into bar (hotness: 3000) [-Rpass-analysis=inline]; sum += foo(x, x - 2);; ^. This option is implied when; :ref:",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:13709,Performance,optimiz,optimization,13709,"hh52tv_2nrdxrj31nyw0000gn/T/a-9be59b.o``. * ``/var/folders/43/9y164hh52tv_2nrdxrj31nyw0000gn/T/a-9be59b.opt.bitstream``. * ``out``. * ``out.dSYM/Contents/Resources/Remarks/out``. Darwin-only: compiling for multiple architectures will use the following; scheme:. ``<base>-<arch>.opt.<format>``. Note that this is incompatible with passing the; :option:`-foptimization-record-file` option. .. option:: -foptimization-record-file. Control the file to which optimization reports are written. This implies; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>`. On Darwin platforms, this is incompatible with passing multiple; ``-arch <arch>`` options. .. option:: -foptimization-record-passes. Only include passes which match a specified regular expression. When optimization reports are being output (see; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>`), this; option controls the passes that will be included in the final report. If this option is not used, all the passes are included in the optimization; record. .. _opt_fdiagnostics-show-hotness:. .. option:: -f[no-]diagnostics-show-hotness. Enable profile hotness information in diagnostic line. This option controls whether Clang prints the profile hotness associated; with diagnostics in the presence of profile-guided optimization information.; This is currently supported with optimization remarks (see; :ref:`Options to Emit Optimization Reports <rpass>`). The hotness information; allows users to focus on the hot optimization remarks that are likely to be; more relevant for run-time performance. For example, in this output, the block containing the callsite of `foo` was; executed 3000 times according to the profile data:. ::. s.c:7:10: remark: foo inlined into bar (hotness: 3000) [-Rpass-analysis=inline]; sum += foo(x, x - 2);; ^. This option is implied when; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>` is used.; Otherwise, it defaults to off. .. option:: -fdiagnostics-hotness-thr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:13992,Performance,optimiz,optimization,13992,"cheme:. ``<base>-<arch>.opt.<format>``. Note that this is incompatible with passing the; :option:`-foptimization-record-file` option. .. option:: -foptimization-record-file. Control the file to which optimization reports are written. This implies; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>`. On Darwin platforms, this is incompatible with passing multiple; ``-arch <arch>`` options. .. option:: -foptimization-record-passes. Only include passes which match a specified regular expression. When optimization reports are being output (see; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>`), this; option controls the passes that will be included in the final report. If this option is not used, all the passes are included in the optimization; record. .. _opt_fdiagnostics-show-hotness:. .. option:: -f[no-]diagnostics-show-hotness. Enable profile hotness information in diagnostic line. This option controls whether Clang prints the profile hotness associated; with diagnostics in the presence of profile-guided optimization information.; This is currently supported with optimization remarks (see; :ref:`Options to Emit Optimization Reports <rpass>`). The hotness information; allows users to focus on the hot optimization remarks that are likely to be; more relevant for run-time performance. For example, in this output, the block containing the callsite of `foo` was; executed 3000 times according to the profile data:. ::. s.c:7:10: remark: foo inlined into bar (hotness: 3000) [-Rpass-analysis=inline]; sum += foo(x, x - 2);; ^. This option is implied when; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>` is used.; Otherwise, it defaults to off. .. option:: -fdiagnostics-hotness-threshold. Prevent optimization remarks from being output if they do not have at least; this hotness value. This option, which defaults to zero, controls the minimum hotness an; optimization remark would need in order to be output by Clang. This is; current",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:14052,Performance,optimiz,optimization,14052," .. option:: -foptimization-record-file. Control the file to which optimization reports are written. This implies; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>`. On Darwin platforms, this is incompatible with passing multiple; ``-arch <arch>`` options. .. option:: -foptimization-record-passes. Only include passes which match a specified regular expression. When optimization reports are being output (see; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>`), this; option controls the passes that will be included in the final report. If this option is not used, all the passes are included in the optimization; record. .. _opt_fdiagnostics-show-hotness:. .. option:: -f[no-]diagnostics-show-hotness. Enable profile hotness information in diagnostic line. This option controls whether Clang prints the profile hotness associated; with diagnostics in the presence of profile-guided optimization information.; This is currently supported with optimization remarks (see; :ref:`Options to Emit Optimization Reports <rpass>`). The hotness information; allows users to focus on the hot optimization remarks that are likely to be; more relevant for run-time performance. For example, in this output, the block containing the callsite of `foo` was; executed 3000 times according to the profile data:. ::. s.c:7:10: remark: foo inlined into bar (hotness: 3000) [-Rpass-analysis=inline]; sum += foo(x, x - 2);; ^. This option is implied when; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>` is used.; Otherwise, it defaults to off. .. option:: -fdiagnostics-hotness-threshold. Prevent optimization remarks from being output if they do not have at least; this hotness value. This option, which defaults to zero, controls the minimum hotness an; optimization remark would need in order to be output by Clang. This is; currently supported with optimization remarks (see :ref:`Options to Emit; Optimization Reports <rpass>`) when profile hotness information in",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:14191,Performance,optimiz,optimization,14191,"ptimization-record <opt_fsave-optimization-record>`. On Darwin platforms, this is incompatible with passing multiple; ``-arch <arch>`` options. .. option:: -foptimization-record-passes. Only include passes which match a specified regular expression. When optimization reports are being output (see; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>`), this; option controls the passes that will be included in the final report. If this option is not used, all the passes are included in the optimization; record. .. _opt_fdiagnostics-show-hotness:. .. option:: -f[no-]diagnostics-show-hotness. Enable profile hotness information in diagnostic line. This option controls whether Clang prints the profile hotness associated; with diagnostics in the presence of profile-guided optimization information.; This is currently supported with optimization remarks (see; :ref:`Options to Emit Optimization Reports <rpass>`). The hotness information; allows users to focus on the hot optimization remarks that are likely to be; more relevant for run-time performance. For example, in this output, the block containing the callsite of `foo` was; executed 3000 times according to the profile data:. ::. s.c:7:10: remark: foo inlined into bar (hotness: 3000) [-Rpass-analysis=inline]; sum += foo(x, x - 2);; ^. This option is implied when; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>` is used.; Otherwise, it defaults to off. .. option:: -fdiagnostics-hotness-threshold. Prevent optimization remarks from being output if they do not have at least; this hotness value. This option, which defaults to zero, controls the minimum hotness an; optimization remark would need in order to be output by Clang. This is; currently supported with optimization remarks (see :ref:`Options to Emit; Optimization Reports <rpass>`) when profile hotness information in; diagnostics is enabled (see; :ref:`-fdiagnostics-show-hotness <opt_fdiagnostics-show-hotness>`). .. _opt_fdiagnostics-fixit-in",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:14262,Performance,perform,performance,14262,"ptimization-record <opt_fsave-optimization-record>`. On Darwin platforms, this is incompatible with passing multiple; ``-arch <arch>`` options. .. option:: -foptimization-record-passes. Only include passes which match a specified regular expression. When optimization reports are being output (see; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>`), this; option controls the passes that will be included in the final report. If this option is not used, all the passes are included in the optimization; record. .. _opt_fdiagnostics-show-hotness:. .. option:: -f[no-]diagnostics-show-hotness. Enable profile hotness information in diagnostic line. This option controls whether Clang prints the profile hotness associated; with diagnostics in the presence of profile-guided optimization information.; This is currently supported with optimization remarks (see; :ref:`Options to Emit Optimization Reports <rpass>`). The hotness information; allows users to focus on the hot optimization remarks that are likely to be; more relevant for run-time performance. For example, in this output, the block containing the callsite of `foo` was; executed 3000 times according to the profile data:. ::. s.c:7:10: remark: foo inlined into bar (hotness: 3000) [-Rpass-analysis=inline]; sum += foo(x, x - 2);; ^. This option is implied when; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>` is used.; Otherwise, it defaults to off. .. option:: -fdiagnostics-hotness-threshold. Prevent optimization remarks from being output if they do not have at least; this hotness value. This option, which defaults to zero, controls the minimum hotness an; optimization remark would need in order to be output by Clang. This is; currently supported with optimization remarks (see :ref:`Options to Emit; Optimization Reports <rpass>`) when profile hotness information in; diagnostics is enabled (see; :ref:`-fdiagnostics-show-hotness <opt_fdiagnostics-show-hotness>`). .. _opt_fdiagnostics-fixit-in",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:14557,Performance,optimiz,optimization-record,14557,"`), this; option controls the passes that will be included in the final report. If this option is not used, all the passes are included in the optimization; record. .. _opt_fdiagnostics-show-hotness:. .. option:: -f[no-]diagnostics-show-hotness. Enable profile hotness information in diagnostic line. This option controls whether Clang prints the profile hotness associated; with diagnostics in the presence of profile-guided optimization information.; This is currently supported with optimization remarks (see; :ref:`Options to Emit Optimization Reports <rpass>`). The hotness information; allows users to focus on the hot optimization remarks that are likely to be; more relevant for run-time performance. For example, in this output, the block containing the callsite of `foo` was; executed 3000 times according to the profile data:. ::. s.c:7:10: remark: foo inlined into bar (hotness: 3000) [-Rpass-analysis=inline]; sum += foo(x, x - 2);; ^. This option is implied when; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>` is used.; Otherwise, it defaults to off. .. option:: -fdiagnostics-hotness-threshold. Prevent optimization remarks from being output if they do not have at least; this hotness value. This option, which defaults to zero, controls the minimum hotness an; optimization remark would need in order to be output by Clang. This is; currently supported with optimization remarks (see :ref:`Options to Emit; Optimization Reports <rpass>`) when profile hotness information in; diagnostics is enabled (see; :ref:`-fdiagnostics-show-hotness <opt_fdiagnostics-show-hotness>`). .. _opt_fdiagnostics-fixit-info:. .. option:: -f[no-]diagnostics-fixit-info. Enable ""FixIt"" information in the diagnostics output. This option, which defaults to on, controls whether or not Clang; prints the information on how to fix a specific diagnostic; underneath it when it knows. For example, in this output:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:14588,Performance,optimiz,optimization-record,14588,"`), this; option controls the passes that will be included in the final report. If this option is not used, all the passes are included in the optimization; record. .. _opt_fdiagnostics-show-hotness:. .. option:: -f[no-]diagnostics-show-hotness. Enable profile hotness information in diagnostic line. This option controls whether Clang prints the profile hotness associated; with diagnostics in the presence of profile-guided optimization information.; This is currently supported with optimization remarks (see; :ref:`Options to Emit Optimization Reports <rpass>`). The hotness information; allows users to focus on the hot optimization remarks that are likely to be; more relevant for run-time performance. For example, in this output, the block containing the callsite of `foo` was; executed 3000 times according to the profile data:. ::. s.c:7:10: remark: foo inlined into bar (hotness: 3000) [-Rpass-analysis=inline]; sum += foo(x, x - 2);; ^. This option is implied when; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>` is used.; Otherwise, it defaults to off. .. option:: -fdiagnostics-hotness-threshold. Prevent optimization remarks from being output if they do not have at least; this hotness value. This option, which defaults to zero, controls the minimum hotness an; optimization remark would need in order to be output by Clang. This is; currently supported with optimization remarks (see :ref:`Options to Emit; Optimization Reports <rpass>`) when profile hotness information in; diagnostics is enabled (see; :ref:`-fdiagnostics-show-hotness <opt_fdiagnostics-show-hotness>`). .. _opt_fdiagnostics-fixit-info:. .. option:: -f[no-]diagnostics-fixit-info. Enable ""FixIt"" information in the diagnostics output. This option, which defaults to on, controls whether or not Clang; prints the information on how to fix a specific diagnostic; underneath it when it knows. For example, in this output:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:14704,Performance,optimiz,optimization,14704,"gnostics-show-hotness:. .. option:: -f[no-]diagnostics-show-hotness. Enable profile hotness information in diagnostic line. This option controls whether Clang prints the profile hotness associated; with diagnostics in the presence of profile-guided optimization information.; This is currently supported with optimization remarks (see; :ref:`Options to Emit Optimization Reports <rpass>`). The hotness information; allows users to focus on the hot optimization remarks that are likely to be; more relevant for run-time performance. For example, in this output, the block containing the callsite of `foo` was; executed 3000 times according to the profile data:. ::. s.c:7:10: remark: foo inlined into bar (hotness: 3000) [-Rpass-analysis=inline]; sum += foo(x, x - 2);; ^. This option is implied when; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>` is used.; Otherwise, it defaults to off. .. option:: -fdiagnostics-hotness-threshold. Prevent optimization remarks from being output if they do not have at least; this hotness value. This option, which defaults to zero, controls the minimum hotness an; optimization remark would need in order to be output by Clang. This is; currently supported with optimization remarks (see :ref:`Options to Emit; Optimization Reports <rpass>`) when profile hotness information in; diagnostics is enabled (see; :ref:`-fdiagnostics-show-hotness <opt_fdiagnostics-show-hotness>`). .. _opt_fdiagnostics-fixit-info:. .. option:: -f[no-]diagnostics-fixit-info. Enable ""FixIt"" information in the diagnostics output. This option, which defaults to on, controls whether or not Clang; prints the information on how to fix a specific diagnostic; underneath it when it knows. For example, in this output:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. Passing **-fno-diagnostics-fixit-info** will prevent Clang from; printing the ""//"" line at the end of the message. This information; is useful for user",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:14863,Performance,optimiz,optimization,14863,"ic line. This option controls whether Clang prints the profile hotness associated; with diagnostics in the presence of profile-guided optimization information.; This is currently supported with optimization remarks (see; :ref:`Options to Emit Optimization Reports <rpass>`). The hotness information; allows users to focus on the hot optimization remarks that are likely to be; more relevant for run-time performance. For example, in this output, the block containing the callsite of `foo` was; executed 3000 times according to the profile data:. ::. s.c:7:10: remark: foo inlined into bar (hotness: 3000) [-Rpass-analysis=inline]; sum += foo(x, x - 2);; ^. This option is implied when; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>` is used.; Otherwise, it defaults to off. .. option:: -fdiagnostics-hotness-threshold. Prevent optimization remarks from being output if they do not have at least; this hotness value. This option, which defaults to zero, controls the minimum hotness an; optimization remark would need in order to be output by Clang. This is; currently supported with optimization remarks (see :ref:`Options to Emit; Optimization Reports <rpass>`) when profile hotness information in; diagnostics is enabled (see; :ref:`-fdiagnostics-show-hotness <opt_fdiagnostics-show-hotness>`). .. _opt_fdiagnostics-fixit-info:. .. option:: -f[no-]diagnostics-fixit-info. Enable ""FixIt"" information in the diagnostics output. This option, which defaults to on, controls whether or not Clang; prints the information on how to fix a specific diagnostic; underneath it when it knows. For example, in this output:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. Passing **-fno-diagnostics-fixit-info** will prevent Clang from; printing the ""//"" line at the end of the message. This information; is useful for users who may not understand what is wrong, but can be; confusing for machine parsing. .. _opt_fdiagnostics-print-sourc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:14960,Performance,optimiz,optimization,14960,"th optimization remarks (see; :ref:`Options to Emit Optimization Reports <rpass>`). The hotness information; allows users to focus on the hot optimization remarks that are likely to be; more relevant for run-time performance. For example, in this output, the block containing the callsite of `foo` was; executed 3000 times according to the profile data:. ::. s.c:7:10: remark: foo inlined into bar (hotness: 3000) [-Rpass-analysis=inline]; sum += foo(x, x - 2);; ^. This option is implied when; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>` is used.; Otherwise, it defaults to off. .. option:: -fdiagnostics-hotness-threshold. Prevent optimization remarks from being output if they do not have at least; this hotness value. This option, which defaults to zero, controls the minimum hotness an; optimization remark would need in order to be output by Clang. This is; currently supported with optimization remarks (see :ref:`Options to Emit; Optimization Reports <rpass>`) when profile hotness information in; diagnostics is enabled (see; :ref:`-fdiagnostics-show-hotness <opt_fdiagnostics-show-hotness>`). .. _opt_fdiagnostics-fixit-info:. .. option:: -f[no-]diagnostics-fixit-info. Enable ""FixIt"" information in the diagnostics output. This option, which defaults to on, controls whether or not Clang; prints the information on how to fix a specific diagnostic; underneath it when it knows. For example, in this output:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. Passing **-fno-diagnostics-fixit-info** will prevent Clang from; printing the ""//"" line at the end of the message. This information; is useful for users who may not understand what is wrong, but can be; confusing for machine parsing. .. _opt_fdiagnostics-print-source-range-info:. .. option:: -fdiagnostics-print-source-range-info. Print machine parsable information about source ranges.; This option makes Clang print information about source ranges in a ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:23393,Performance,cache,cache,23393,"agnostics for compiler crashes (default)); * ``all`` (Generate diagnostics for all tools which support it). .. option:: -fno-crash-diagnostics. Disable auto-generation of preprocessed source files during a clang crash. The -fno-crash-diagnostics flag can be helpful for speeding the process; of generating a delta reduced test case. .. option:: -fcrash-diagnostics-dir=<dir>. Specify where to write the crash diagnostics files; defaults to the; usual location for temporary files. .. envvar:: CLANG_CRASH_DIAGNOSTICS_DIR=<dir>. Like ``-fcrash-diagnostics-dir=<dir>``, specifies where to write the; crash diagnostics files, but with lower precedence than the option. Clang is also capable of generating preprocessed source file(s) and associated; run script(s) even without a crash. This is specially useful when trying to; generate a reproducer for warnings or errors while using modules. .. option:: -gen-reproducer. Generates preprocessed source files, a reproducer script and if relevant, a; cache containing: built module pcm's and all headers needed to rebuild the; same modules. .. _rpass:. Options to Emit Optimization Reports; ------------------------------------. Optimization reports trace, at a high-level, all the major decisions; done by compiler transformations. For instance, when the inliner; decides to inline function ``foo()`` into ``bar()``, or the loop unroller; decides to unroll a loop N times, or the vectorizer decides to; vectorize a loop body. Clang offers a family of flags which the optimizers can use to emit; a diagnostic in three cases:. 1. When the pass makes a transformation (`-Rpass`). 2. When the pass fails to make a transformation (`-Rpass-missed`). 3. When the pass determines whether or not to make a transformation; (`-Rpass-analysis`). NOTE: Although the discussion below focuses on `-Rpass`, the exact; same options apply to `-Rpass-missed` and `-Rpass-analysis`. Since there are dozens of passes inside the compiler, each of these flags; take a regular exp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:23910,Performance,optimiz,optimizers,23910,"R=<dir>. Like ``-fcrash-diagnostics-dir=<dir>``, specifies where to write the; crash diagnostics files, but with lower precedence than the option. Clang is also capable of generating preprocessed source file(s) and associated; run script(s) even without a crash. This is specially useful when trying to; generate a reproducer for warnings or errors while using modules. .. option:: -gen-reproducer. Generates preprocessed source files, a reproducer script and if relevant, a; cache containing: built module pcm's and all headers needed to rebuild the; same modules. .. _rpass:. Options to Emit Optimization Reports; ------------------------------------. Optimization reports trace, at a high-level, all the major decisions; done by compiler transformations. For instance, when the inliner; decides to inline function ``foo()`` into ``bar()``, or the loop unroller; decides to unroll a loop N times, or the vectorizer decides to; vectorize a loop body. Clang offers a family of flags which the optimizers can use to emit; a diagnostic in three cases:. 1. When the pass makes a transformation (`-Rpass`). 2. When the pass fails to make a transformation (`-Rpass-missed`). 3. When the pass determines whether or not to make a transformation; (`-Rpass-analysis`). NOTE: Although the discussion below focuses on `-Rpass`, the exact; same options apply to `-Rpass-missed` and `-Rpass-analysis`. Since there are dozens of passes inside the compiler, each of these flags; take a regular expression that identifies the name of the pass which should; emit the associated diagnostic. For example, to get a report from the inliner,; compile the code with:. .. code-block:: console. $ clang -O2 -Rpass=inline code.cc -o code; code.cc:4:25: remark: foo inlined into bar [-Rpass=inline]; int bar(int j) { return foo(j, j - 2); }; ^. Note that remarks from the inliner are identified with `[-Rpass=inline]`.; To request a report from every optimization pass, you should use; `-Rpass=.*` (in fact, you can use any vali",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:24841,Performance,optimiz,optimization,24841,"vectorize a loop body. Clang offers a family of flags which the optimizers can use to emit; a diagnostic in three cases:. 1. When the pass makes a transformation (`-Rpass`). 2. When the pass fails to make a transformation (`-Rpass-missed`). 3. When the pass determines whether or not to make a transformation; (`-Rpass-analysis`). NOTE: Although the discussion below focuses on `-Rpass`, the exact; same options apply to `-Rpass-missed` and `-Rpass-analysis`. Since there are dozens of passes inside the compiler, each of these flags; take a regular expression that identifies the name of the pass which should; emit the associated diagnostic. For example, to get a report from the inliner,; compile the code with:. .. code-block:: console. $ clang -O2 -Rpass=inline code.cc -o code; code.cc:4:25: remark: foo inlined into bar [-Rpass=inline]; int bar(int j) { return foo(j, j - 2); }; ^. Note that remarks from the inliner are identified with `[-Rpass=inline]`.; To request a report from every optimization pass, you should use; `-Rpass=.*` (in fact, you can use any valid POSIX regular; expression). However, do not expect a report from every transformation; made by the compiler. Optimization remarks do not really make sense; outside of the major transformations (e.g., inlining, vectorization,; loop optimizations) and not every optimization pass supports this; feature. Note that when using profile-guided optimization information, profile hotness; information can be included in the remarks (see; :ref:`-fdiagnostics-show-hotness <opt_fdiagnostics-show-hotness>`). Current limitations; ^^^^^^^^^^^^^^^^^^^. 1. Optimization remarks that refer to function names will display the; mangled name of the function. Since these remarks are emitted by the; back end of the compiler, it does not know anything about the input; language, nor its mangling rules. 2. Some source locations are not displayed correctly. The front end has; a more detailed source location tracking than the locations included; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:25151,Performance,optimiz,optimizations,25151,"ysis`). NOTE: Although the discussion below focuses on `-Rpass`, the exact; same options apply to `-Rpass-missed` and `-Rpass-analysis`. Since there are dozens of passes inside the compiler, each of these flags; take a regular expression that identifies the name of the pass which should; emit the associated diagnostic. For example, to get a report from the inliner,; compile the code with:. .. code-block:: console. $ clang -O2 -Rpass=inline code.cc -o code; code.cc:4:25: remark: foo inlined into bar [-Rpass=inline]; int bar(int j) { return foo(j, j - 2); }; ^. Note that remarks from the inliner are identified with `[-Rpass=inline]`.; To request a report from every optimization pass, you should use; `-Rpass=.*` (in fact, you can use any valid POSIX regular; expression). However, do not expect a report from every transformation; made by the compiler. Optimization remarks do not really make sense; outside of the major transformations (e.g., inlining, vectorization,; loop optimizations) and not every optimization pass supports this; feature. Note that when using profile-guided optimization information, profile hotness; information can be included in the remarks (see; :ref:`-fdiagnostics-show-hotness <opt_fdiagnostics-show-hotness>`). Current limitations; ^^^^^^^^^^^^^^^^^^^. 1. Optimization remarks that refer to function names will display the; mangled name of the function. Since these remarks are emitted by the; back end of the compiler, it does not know anything about the input; language, nor its mangling rules. 2. Some source locations are not displayed correctly. The front end has; a more detailed source location tracking than the locations included; in the debug info (e.g., the front end can locate code inside macro; expansions). However, the locations used by `-Rpass` are; translated from debug annotations. That translation can be lossy,; which results in some remarks having no location information. Options to Emit Resource Consumption Reports; ---------------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:25180,Performance,optimiz,optimization,25180,"ysis`). NOTE: Although the discussion below focuses on `-Rpass`, the exact; same options apply to `-Rpass-missed` and `-Rpass-analysis`. Since there are dozens of passes inside the compiler, each of these flags; take a regular expression that identifies the name of the pass which should; emit the associated diagnostic. For example, to get a report from the inliner,; compile the code with:. .. code-block:: console. $ clang -O2 -Rpass=inline code.cc -o code; code.cc:4:25: remark: foo inlined into bar [-Rpass=inline]; int bar(int j) { return foo(j, j - 2); }; ^. Note that remarks from the inliner are identified with `[-Rpass=inline]`.; To request a report from every optimization pass, you should use; `-Rpass=.*` (in fact, you can use any valid POSIX regular; expression). However, do not expect a report from every transformation; made by the compiler. Optimization remarks do not really make sense; outside of the major transformations (e.g., inlining, vectorization,; loop optimizations) and not every optimization pass supports this; feature. Note that when using profile-guided optimization information, profile hotness; information can be included in the remarks (see; :ref:`-fdiagnostics-show-hotness <opt_fdiagnostics-show-hotness>`). Current limitations; ^^^^^^^^^^^^^^^^^^^. 1. Optimization remarks that refer to function names will display the; mangled name of the function. Since these remarks are emitted by the; back end of the compiler, it does not know anything about the input; language, nor its mangling rules. 2. Some source locations are not displayed correctly. The front end has; a more detailed source location tracking than the locations included; in the debug info (e.g., the front end can locate code inside macro; expansions). However, the locations used by `-Rpass` are; translated from debug annotations. That translation can be lossy,; which results in some remarks having no location information. Options to Emit Resource Consumption Reports; ---------------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:25258,Performance,optimiz,optimization,25258,"re dozens of passes inside the compiler, each of these flags; take a regular expression that identifies the name of the pass which should; emit the associated diagnostic. For example, to get a report from the inliner,; compile the code with:. .. code-block:: console. $ clang -O2 -Rpass=inline code.cc -o code; code.cc:4:25: remark: foo inlined into bar [-Rpass=inline]; int bar(int j) { return foo(j, j - 2); }; ^. Note that remarks from the inliner are identified with `[-Rpass=inline]`.; To request a report from every optimization pass, you should use; `-Rpass=.*` (in fact, you can use any valid POSIX regular; expression). However, do not expect a report from every transformation; made by the compiler. Optimization remarks do not really make sense; outside of the major transformations (e.g., inlining, vectorization,; loop optimizations) and not every optimization pass supports this; feature. Note that when using profile-guided optimization information, profile hotness; information can be included in the remarks (see; :ref:`-fdiagnostics-show-hotness <opt_fdiagnostics-show-hotness>`). Current limitations; ^^^^^^^^^^^^^^^^^^^. 1. Optimization remarks that refer to function names will display the; mangled name of the function. Since these remarks are emitted by the; back end of the compiler, it does not know anything about the input; language, nor its mangling rules. 2. Some source locations are not displayed correctly. The front end has; a more detailed source location tracking than the locations included; in the debug info (e.g., the front end can locate code inside macro; expansions). However, the locations used by `-Rpass` are; translated from debug annotations. That translation can be lossy,; which results in some remarks having no location information. Options to Emit Resource Consumption Reports; --------------------------------------------. These are options that report execution time and consumed memory of different; compilations steps. .. option:: -fproc-stat-r",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:30269,Performance,perform,performance,30269,"u supplied the -M option); most filenames can be written to the file without any special formatting.; Different Make tools will treat different sets of characters as ""special""; and use different conventions for telling the Make tool that the character; is actually part of the filename. Normally Clang uses backslash to ""escape""; a special character, which is the convention used by GNU Make. The -MV; option tells Clang to put double-quotes around the entire filename, which; is the convention used by NMake and Jom. .. option:: -femit-dwarf-unwind=<value>. When to emit DWARF unwind (EH frame) info. This is a Mach-O-specific option. Valid values are:. * ``no-compact-unwind`` - Only emit DWARF unwind when compact unwind encodings; aren't available. This is the default for arm64.; * ``always`` - Always emit DWARF unwind regardless.; * ``default`` - Use the platform-specific default (``always`` for all; non-arm64-platforms). ``no-compact-unwind`` is a performance optimization -- Clang will emit smaller; object files that are more quickly processed by the linker. This may cause; binary compatibility issues on older x86_64 targets, however, so use it with; caution. .. _configuration-files:. Configuration files; -------------------. Configuration files group command-line options and allow all of them to be; specified just by referencing the configuration file. They may be used, for; example, to collect options required to tune compilation for particular; target, such as ``-L``, ``-I``, ``-l``, ``--sysroot``, codegen options, etc. Configuration files can be either specified on the command line or loaded; from default locations. If both variants are present, the default configuration; files are loaded first. The command line option ``--config=`` can be used to specify explicit; configuration files in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=deb",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:30281,Performance,optimiz,optimization,30281,"u supplied the -M option); most filenames can be written to the file without any special formatting.; Different Make tools will treat different sets of characters as ""special""; and use different conventions for telling the Make tool that the character; is actually part of the filename. Normally Clang uses backslash to ""escape""; a special character, which is the convention used by GNU Make. The -MV; option tells Clang to put double-quotes around the entire filename, which; is the convention used by NMake and Jom. .. option:: -femit-dwarf-unwind=<value>. When to emit DWARF unwind (EH frame) info. This is a Mach-O-specific option. Valid values are:. * ``no-compact-unwind`` - Only emit DWARF unwind when compact unwind encodings; aren't available. This is the default for arm64.; * ``always`` - Always emit DWARF unwind regardless.; * ``default`` - Use the platform-specific default (``always`` for all; non-arm64-platforms). ``no-compact-unwind`` is a performance optimization -- Clang will emit smaller; object files that are more quickly processed by the linker. This may cause; binary compatibility issues on older x86_64 targets, however, so use it with; caution. .. _configuration-files:. Configuration files; -------------------. Configuration files group command-line options and allow all of them to be; specified just by referencing the configuration file. They may be used, for; example, to collect options required to tune compilation for particular; target, such as ``-L``, ``-I``, ``-l``, ``--sysroot``, codegen options, etc. Configuration files can be either specified on the command line or loaded; from default locations. If both variants are present, the default configuration; files are loaded first. The command line option ``--config=`` can be used to specify explicit; configuration files in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=deb",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:30746,Performance,tune,tune,30746,"re filename, which; is the convention used by NMake and Jom. .. option:: -femit-dwarf-unwind=<value>. When to emit DWARF unwind (EH frame) info. This is a Mach-O-specific option. Valid values are:. * ``no-compact-unwind`` - Only emit DWARF unwind when compact unwind encodings; aren't available. This is the default for arm64.; * ``always`` - Always emit DWARF unwind regardless.; * ``default`` - Use the platform-specific default (``always`` for all; non-arm64-platforms). ``no-compact-unwind`` is a performance optimization -- Clang will emit smaller; object files that are more quickly processed by the linker. This may cause; binary compatibility issues on older x86_64 targets, however, so use it with; caution. .. _configuration-files:. Configuration files; -------------------. Configuration files group command-line options and allow all of them to be; specified just by referencing the configuration file. They may be used, for; example, to collect options required to tune compilation for particular; target, such as ``-L``, ``-I``, ``-l``, ``--sysroot``, codegen options, etc. Configuration files can be either specified on the command line or loaded; from default locations. If both variants are present, the default configuration; files are loaded first. The command line option ``--config=`` can be used to specify explicit; configuration files in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - the directory where Clang executable resides. Both user and system directories for configuration files are specified during; clang build using CMake param",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:30923,Performance,load,loaded,30923,"e) info. This is a Mach-O-specific option. Valid values are:. * ``no-compact-unwind`` - Only emit DWARF unwind when compact unwind encodings; aren't available. This is the default for arm64.; * ``always`` - Always emit DWARF unwind regardless.; * ``default`` - Use the platform-specific default (``always`` for all; non-arm64-platforms). ``no-compact-unwind`` is a performance optimization -- Clang will emit smaller; object files that are more quickly processed by the linker. This may cause; binary compatibility issues on older x86_64 targets, however, so use it with; caution. .. _configuration-files:. Configuration files; -------------------. Configuration files group command-line options and allow all of them to be; specified just by referencing the configuration file. They may be used, for; example, to collect options required to tune compilation for particular; target, such as ``-L``, ``-I``, ``-l``, ``--sysroot``, codegen options, etc. Configuration files can be either specified on the command line or loaded; from default locations. If both variants are present, the default configuration; files are loaded first. The command line option ``--config=`` can be used to specify explicit; configuration files in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - the directory where Clang executable resides. Both user and system directories for configuration files are specified during; clang build using CMake parameters, ``CLANG_CONFIG_FILE_USER_DIR`` and; ``CLANG_CONFIG_FILE_SYSTEM_DIR`` respectively. The first file found is used.; It is an error ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:31022,Performance,load,loaded,31022,"ly emit DWARF unwind when compact unwind encodings; aren't available. This is the default for arm64.; * ``always`` - Always emit DWARF unwind regardless.; * ``default`` - Use the platform-specific default (``always`` for all; non-arm64-platforms). ``no-compact-unwind`` is a performance optimization -- Clang will emit smaller; object files that are more quickly processed by the linker. This may cause; binary compatibility issues on older x86_64 targets, however, so use it with; caution. .. _configuration-files:. Configuration files; -------------------. Configuration files group command-line options and allow all of them to be; specified just by referencing the configuration file. They may be used, for; example, to collect options required to tune compilation for particular; target, such as ``-L``, ``-I``, ``-l``, ``--sysroot``, codegen options, etc. Configuration files can be either specified on the command line or loaded; from default locations. If both variants are present, the default configuration; files are loaded first. The command line option ``--config=`` can be used to specify explicit; configuration files in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - the directory where Clang executable resides. Both user and system directories for configuration files are specified during; clang build using CMake parameters, ``CLANG_CONFIG_FILE_USER_DIR`` and; ``CLANG_CONFIG_FILE_SYSTEM_DIR`` respectively. The first file found is used.; It is an error if the required file cannot be found. The default configuration files are searched for in ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:31213,Performance,load,loaded,31213,"c default (``always`` for all; non-arm64-platforms). ``no-compact-unwind`` is a performance optimization -- Clang will emit smaller; object files that are more quickly processed by the linker. This may cause; binary compatibility issues on older x86_64 targets, however, so use it with; caution. .. _configuration-files:. Configuration files; -------------------. Configuration files group command-line options and allow all of them to be; specified just by referencing the configuration file. They may be used, for; example, to collect options required to tune compilation for particular; target, such as ``-L``, ``-I``, ``-l``, ``--sysroot``, codegen options, etc. Configuration files can be either specified on the command line or loaded; from default locations. If both variants are present, the default configuration; files are loaded first. The command line option ``--config=`` can be used to specify explicit; configuration files in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - the directory where Clang executable resides. Both user and system directories for configuration files are specified during; clang build using CMake parameters, ``CLANG_CONFIG_FILE_USER_DIR`` and; ``CLANG_CONFIG_FILE_SYSTEM_DIR`` respectively. The first file found is used.; It is an error if the required file cannot be found. The default configuration files are searched for in the same directories; following the rules described in the next paragraphs. Loading default; configuration files can be disabled entirely via passing; the ``--no-default-config`` flag. First, the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:33549,Performance,load,load,33549," the one found in the executable name. The following canonical driver names are used:. - ``clang`` for the ``gcc`` driver (used to compile C programs); - ``clang++`` for the ``gxx`` driver (used to compile C++ programs); - ``clang-cpp`` for the ``cpp`` driver (pure preprocessor); - ``clang-cl`` for the ``cl`` driver; - ``flang`` for the ``flang`` driver; - ``clang-dxc`` for the ``dxc`` driver. For example, when calling ``x86_64-pc-linux-gnu-clang-g++``,; the driver will first attempt to use the configuration file named::. x86_64-pc-linux-gnu-clang++.cfg. If this file is not found, it will attempt to use the name found; in the executable instead::. x86_64-pc-linux-gnu-clang-g++.cfg. Note that options such as ``--driver-mode=``, ``--target=``, ``-m32`` affect; the search algorithm. For example, the aforementioned executable called with; ``-m32`` argument will instead search for::. i386-pc-linux-gnu-clang++.cfg. If none of the aforementioned files are found, the driver will instead search; for separate driver and target configuration files and attempt to load both.; The former is named ``<driver>.cfg`` while the latter is named; ``<triple>.cfg``. Similarly to the previous variants, the canonical driver name; will be preferred, and the compiler will fall back to the actual name. For example, ``x86_64-pc-linux-gnu-clang-g++`` will attempt to load two; configuration files named respectively::. clang++.cfg; x86_64-pc-linux-gnu.cfg. with fallback to trying::. clang-g++.cfg; x86_64-pc-linux-gnu.cfg. It is not an error if either of these files is not found. The configuration file consists of command-line options specified on one or; more lines. Lines composed of whitespace characters only are ignored as well as; lines in which the first non-blank character is ``#``. Long options may be split; between several lines by a trailing backslash. Here is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:33840,Performance,load,load,33840,"ver; - ``clang-dxc`` for the ``dxc`` driver. For example, when calling ``x86_64-pc-linux-gnu-clang-g++``,; the driver will first attempt to use the configuration file named::. x86_64-pc-linux-gnu-clang++.cfg. If this file is not found, it will attempt to use the name found; in the executable instead::. x86_64-pc-linux-gnu-clang-g++.cfg. Note that options such as ``--driver-mode=``, ``--target=``, ``-m32`` affect; the search algorithm. For example, the aforementioned executable called with; ``-m32`` argument will instead search for::. i386-pc-linux-gnu-clang++.cfg. If none of the aforementioned files are found, the driver will instead search; for separate driver and target configuration files and attempt to load both.; The former is named ``<driver>.cfg`` while the latter is named; ``<triple>.cfg``. Similarly to the previous variants, the canonical driver name; will be preferred, and the compiler will fall back to the actual name. For example, ``x86_64-pc-linux-gnu-clang-g++`` will attempt to load two; configuration files named respectively::. clang++.cfg; x86_64-pc-linux-gnu.cfg. with fallback to trying::. clang-g++.cfg; x86_64-pc-linux-gnu.cfg. It is not an error if either of these files is not found. The configuration file consists of command-line options specified on one or; more lines. Lines composed of whitespace characters only are ignored as well as; lines in which the first non-blank character is ``#``. Long options may be split; between several lines by a trailing backslash. Here is example of a; configuration file:. ::. # Several options on line; -c --target=x86_64-unknown-linux-gnu. # Long option split between lines; -I/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../../\; include/c++/5.4.0. # other config files may be included; @linux.options. Files included by ``@file`` directives in configuration files are resolved; relative to the including file. For example, if a configuration file; ``~/.llvm/target.cfg`` contains the directive ``@os/linux.opts``, the fil",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:46186,Performance,optimiz,optimization,46186," diagnostics from Clang's; `static analyzer <https://clang-analyzer.llvm.org>`_ can also be; influenced by the user via changes to the source code. See the available; `annotations <https://clang-analyzer.llvm.org/annotations.html>`_ and the; analyzer's `FAQ; page <https://clang-analyzer.llvm.org/faq.html#exclude_code>`_ for more; information. .. _usersmanual-precompiled-headers:. Precompiled Headers; -------------------. `Precompiled headers <https://en.wikipedia.org/wiki/Precompiled_header>`_; are a general approach employed by many compilers to reduce compilation; time. The underlying motivation of the approach is that it is common for; the same (and often large) header files to be included by multiple; source files. Consequently, compile times can often be greatly improved; by caching some of the (redundant) work done by a compiler to process; headers. Precompiled header files, which represent one of many ways to; implement this optimization, are literally files that represent an; on-disk cache that contains the vital information necessary to reduce; some of the work needed to process a corresponding header file. While; details of precompiled headers vary between compilers, precompiled; headers have been shown to be highly effective at speeding up program; compilation on systems with very large system headers (e.g., macOS). Generating a PCH File; ^^^^^^^^^^^^^^^^^^^^^. To generate a PCH file using Clang, one invokes Clang with the; `-x <language>-header` option. This mirrors the interface in GCC; for generating PCH files:. .. code-block:: console. $ gcc -x c-header test.h -o test.h.gch; $ clang -x c-header test.h -o test.h.pch. Using a PCH File; ^^^^^^^^^^^^^^^^. A PCH file can then be used as a prefix header when a ``-include-pch``; option is passed to ``clang``:. .. code-block:: console. $ clang -include-pch test.h.pch test.c -o test. The ``clang`` driver will check if the PCH file ``test.h.pch`` is; available; if so, the contents of ``test.h`` (and the files i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:46247,Performance,cache,cache,46247," diagnostics from Clang's; `static analyzer <https://clang-analyzer.llvm.org>`_ can also be; influenced by the user via changes to the source code. See the available; `annotations <https://clang-analyzer.llvm.org/annotations.html>`_ and the; analyzer's `FAQ; page <https://clang-analyzer.llvm.org/faq.html#exclude_code>`_ for more; information. .. _usersmanual-precompiled-headers:. Precompiled Headers; -------------------. `Precompiled headers <https://en.wikipedia.org/wiki/Precompiled_header>`_; are a general approach employed by many compilers to reduce compilation; time. The underlying motivation of the approach is that it is common for; the same (and often large) header files to be included by multiple; source files. Consequently, compile times can often be greatly improved; by caching some of the (redundant) work done by a compiler to process; headers. Precompiled header files, which represent one of many ways to; implement this optimization, are literally files that represent an; on-disk cache that contains the vital information necessary to reduce; some of the work needed to process a corresponding header file. While; details of precompiled headers vary between compilers, precompiled; headers have been shown to be highly effective at speeding up program; compilation on systems with very large system headers (e.g., macOS). Generating a PCH File; ^^^^^^^^^^^^^^^^^^^^^. To generate a PCH file using Clang, one invokes Clang with the; `-x <language>-header` option. This mirrors the interface in GCC; for generating PCH files:. .. code-block:: console. $ gcc -x c-header test.h -o test.h.gch; $ clang -x c-header test.h -o test.h.pch. Using a PCH File; ^^^^^^^^^^^^^^^^. A PCH file can then be used as a prefix header when a ``-include-pch``; option is passed to ``clang``:. .. code-block:: console. $ clang -include-pch test.h.pch test.c -o test. The ``clang`` driver will check if the PCH file ``test.h.pch`` is; available; if so, the contents of ``test.h`` (and the files i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:49260,Performance,load,loading,49260,"ld a relocatable precompiled header, place your headers into a; subdirectory whose structure mimics the installed location. For example,; if you want to build a precompiled header for the header ``mylib.h``; that will be installed into ``/usr/include``, create a subdirectory; ``build/usr/include`` and place the header ``mylib.h`` into that; subdirectory. If ``mylib.h`` depends on other headers, then they can be; stored within ``build/usr/include`` in a way that mimics the installed; location. Building a relocatable precompiled header requires two additional; arguments. First, pass the ``--relocatable-pch`` flag to indicate that; the resulting PCH file should be relocatable. Second, pass; ``-isysroot /path/to/build``, which makes all includes for your library; relative to the build directory. For example:. .. code-block:: console. # clang -x c-header --relocatable-pch -isysroot /path/to/build /path/to/build/mylib.h mylib.h.pch. When loading the relocatable PCH file, the various headers used in the; PCH file are found from the system header root. For example, ``mylib.h``; can be found in ``/usr/include/mylib.h``. If the headers are installed; in some other system root, the ``-isysroot`` option can be used provide; a different system root from which the headers will be based. For; example, ``-isysroot /Developer/SDKs/MacOSX10.4u.sdk`` will look for; ``mylib.h`` in ``/Developer/SDKs/MacOSX10.4u.sdk/usr/include/mylib.h``. Relocatable precompiled headers are intended to be used in a limited; number of cases where the compilation environment is tightly controlled; and the precompiled header cannot be generated after headers have been; installed. .. _controlling-fp-behavior:. Controlling Floating Point Behavior; -----------------------------------. Clang provides a number of ways to control floating point behavior, including; with command line options and source pragmas. This section; describes the various floating point semantic modes and the corresponding options. .. csv-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:52490,Performance,optimiz,optimizations,52490,"""IEEE""; ""support_math_errno"", ""on"", ""on"", ""off""; ""no_honor_nans"", ""off"", ""off"", ""on""; ""no_honor_infinities"", ""off"", ""off"", ""on""; ""no_signed_zeros"", ""off"", ""off"", ""on""; ""allow_reciprocal"", ""off"", ""off"", ""on""; ""allow_approximate_fns"", ""off"", ""off"", ""on""; ""allow_reassociation"", ""off"", ""off"", ""on"". .. option:: -ffast-math. Enable fast-math mode. This option lets the; compiler make aggressive, potentially-lossy assumptions about; floating-point math. These include:. * Floating-point math obeys regular algebraic rules for real numbers (e.g.; ``+`` and ``*`` are associative, ``x/y == x * (1/y)``, and; ``(a + b) * c == a * c + b * c``),; * Operands to floating-point operations are not equal to ``NaN`` and; ``Inf``, and; * ``+0`` and ``-0`` are interchangeable. ``-ffast-math`` also defines the ``__FAST_MATH__`` preprocessor; macro. Some math libraries recognize this macro and change their behavior.; With the exception of ``-ffp-contract=fast``, using any of the options; below to disable any of the individual optimizations in ``-ffast-math``; will cause ``__FAST_MATH__`` to no longer be set.; ``-ffast-math`` enables ``-fcx-limited-range``. This option implies:. * ``-fno-honor-infinities``. * ``-fno-honor-nans``. * ``-fapprox-func``. * ``-fno-math-errno``. * ``-ffinite-math-only``. * ``-fassociative-math``. * ``-freciprocal-math``. * ``-fno-signed-zeros``. * ``-fno-trapping-math``. * ``-fno-rounding-math``. * ``-ffp-contract=fast``. Note: ``-ffast-math`` causes ``crtfastmath.o`` to be linked with code. See; :ref:`crtfastmath.o` for more details. .. option:: -fno-fast-math. Disable fast-math mode. This options disables unsafe floating-point; optimizations by preventing the compiler from making any transformations that; could affect the results. This option implies:. * ``-fhonor-infinities``. * ``-fhonor-nans``. * ``-fno-approx-func``. * ``-fno-finite-math-only``. * ``-fno-associative-math``. * ``-fno-reciprocal-math``. * ``-fsigned-zeros``. * ``-ffp-contract=on``. Also, this op",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:53133,Performance,optimiz,optimizations,53133,"qual to ``NaN`` and; ``Inf``, and; * ``+0`` and ``-0`` are interchangeable. ``-ffast-math`` also defines the ``__FAST_MATH__`` preprocessor; macro. Some math libraries recognize this macro and change their behavior.; With the exception of ``-ffp-contract=fast``, using any of the options; below to disable any of the individual optimizations in ``-ffast-math``; will cause ``__FAST_MATH__`` to no longer be set.; ``-ffast-math`` enables ``-fcx-limited-range``. This option implies:. * ``-fno-honor-infinities``. * ``-fno-honor-nans``. * ``-fapprox-func``. * ``-fno-math-errno``. * ``-ffinite-math-only``. * ``-fassociative-math``. * ``-freciprocal-math``. * ``-fno-signed-zeros``. * ``-fno-trapping-math``. * ``-fno-rounding-math``. * ``-ffp-contract=fast``. Note: ``-ffast-math`` causes ``crtfastmath.o`` to be linked with code. See; :ref:`crtfastmath.o` for more details. .. option:: -fno-fast-math. Disable fast-math mode. This options disables unsafe floating-point; optimizations by preventing the compiler from making any transformations that; could affect the results. This option implies:. * ``-fhonor-infinities``. * ``-fhonor-nans``. * ``-fno-approx-func``. * ``-fno-finite-math-only``. * ``-fno-associative-math``. * ``-fno-reciprocal-math``. * ``-fsigned-zeros``. * ``-ffp-contract=on``. Also, this option resets following options to their target-dependent defaults. * ``-f[no-]math-errno``; * ``-fdenormal-fp-math=<value>``. There is ambiguity about how ``-ffp-contract``, ``-ffast-math``,; and ``-fno-fast-math`` behave when combined. To keep the value of; ``-ffp-contract`` consistent, we define this set of rules:. * ``-ffast-math`` sets ``ffp-contract`` to ``fast``. * ``-fno-fast-math`` sets ``-ffp-contract`` to ``on`` (``fast`` for CUDA and; HIP). * If ``-ffast-math`` and ``-ffp-contract`` are both seen, but; ``-ffast-math`` is not followed by ``-fno-fast-math``, ``ffp-contract``; will be given the value of whichever option was last seen. * If ``-fno-fast-math`` is seen and `",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:55612,Performance,optimiz,optimizations,55612,"t which denormal numbers the code is permitted to require. Valid values are:. * ``ieee`` - IEEE 754 denormal numbers; * ``preserve-sign`` - the sign of a flushed-to-zero number is preserved in the sign of 0; * ``positive-zero`` - denormals are flushed to positive zero. The default value depends on the target. For most targets, defaults to; ``ieee``. .. option:: -f[no-]strict-float-cast-overflow. When a floating-point value is not representable in a destination integer; type, the code has undefined behavior according to the language standard.; By default, Clang will not guarantee any particular result in that case.; With the 'no-strict' option, Clang will saturate towards the smallest and; largest representable integer values instead. NaNs will be converted to zero.; Defaults to ``-fstrict-float-cast-overflow``. .. option:: -f[no-]math-errno. Require math functions to indicate errors by setting errno.; The default varies by ToolChain. ``-fno-math-errno`` allows optimizations; that might cause standard C math functions to not set ``errno``.; For example, on some systems, the math function ``sqrt`` is specified; as setting ``errno`` to ``EDOM`` when the input is negative. On these; systems, the compiler cannot normally optimize a call to ``sqrt`` to use; inline code (e.g. the x86 ``sqrtsd`` instruction) without additional; checking to ensure that ``errno`` is set appropriately.; ``-fno-math-errno`` permits these transformations. On some targets, math library functions never set ``errno``, and so; ``-fno-math-errno`` is the default. This includes most BSD-derived; systems, including Darwin. .. option:: -f[no-]trapping-math. Control floating point exception behavior. ``-fno-trapping-math`` allows optimizations that assume that floating point operations cannot generate traps such as divide-by-zero, overflow and underflow. - The option ``-ftrapping-math`` behaves identically to ``-ffp-exception-behavior=strict``.; - The option ``-fno-trapping-math`` behaves identically to `",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:55873,Performance,optimiz,optimize,55873,"ls are flushed to positive zero. The default value depends on the target. For most targets, defaults to; ``ieee``. .. option:: -f[no-]strict-float-cast-overflow. When a floating-point value is not representable in a destination integer; type, the code has undefined behavior according to the language standard.; By default, Clang will not guarantee any particular result in that case.; With the 'no-strict' option, Clang will saturate towards the smallest and; largest representable integer values instead. NaNs will be converted to zero.; Defaults to ``-fstrict-float-cast-overflow``. .. option:: -f[no-]math-errno. Require math functions to indicate errors by setting errno.; The default varies by ToolChain. ``-fno-math-errno`` allows optimizations; that might cause standard C math functions to not set ``errno``.; For example, on some systems, the math function ``sqrt`` is specified; as setting ``errno`` to ``EDOM`` when the input is negative. On these; systems, the compiler cannot normally optimize a call to ``sqrt`` to use; inline code (e.g. the x86 ``sqrtsd`` instruction) without additional; checking to ensure that ``errno`` is set appropriately.; ``-fno-math-errno`` permits these transformations. On some targets, math library functions never set ``errno``, and so; ``-fno-math-errno`` is the default. This includes most BSD-derived; systems, including Darwin. .. option:: -f[no-]trapping-math. Control floating point exception behavior. ``-fno-trapping-math`` allows optimizations that assume that floating point operations cannot generate traps such as divide-by-zero, overflow and underflow. - The option ``-ftrapping-math`` behaves identically to ``-ffp-exception-behavior=strict``.; - The option ``-fno-trapping-math`` behaves identically to ``-ffp-exception-behavior=ignore``. This is the default. .. option:: -ffp-contract=<value>. Specify when the compiler is permitted to form fused floating-point; operations, such as fused multiply-add (FMA). Fused operations are; permitte",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:56358,Performance,optimiz,optimizations,56358,"o zero.; Defaults to ``-fstrict-float-cast-overflow``. .. option:: -f[no-]math-errno. Require math functions to indicate errors by setting errno.; The default varies by ToolChain. ``-fno-math-errno`` allows optimizations; that might cause standard C math functions to not set ``errno``.; For example, on some systems, the math function ``sqrt`` is specified; as setting ``errno`` to ``EDOM`` when the input is negative. On these; systems, the compiler cannot normally optimize a call to ``sqrt`` to use; inline code (e.g. the x86 ``sqrtsd`` instruction) without additional; checking to ensure that ``errno`` is set appropriately.; ``-fno-math-errno`` permits these transformations. On some targets, math library functions never set ``errno``, and so; ``-fno-math-errno`` is the default. This includes most BSD-derived; systems, including Darwin. .. option:: -f[no-]trapping-math. Control floating point exception behavior. ``-fno-trapping-math`` allows optimizations that assume that floating point operations cannot generate traps such as divide-by-zero, overflow and underflow. - The option ``-ftrapping-math`` behaves identically to ``-ffp-exception-behavior=strict``.; - The option ``-fno-trapping-math`` behaves identically to ``-ffp-exception-behavior=ignore``. This is the default. .. option:: -ffp-contract=<value>. Specify when the compiler is permitted to form fused floating-point; operations, such as fused multiply-add (FMA). Fused operations are; permitted to produce more precise results than performing the same; operations separately. The C standard permits intermediate floating-point results within an; expression to be computed with more precision than their type would; normally allow. This permits operation fusing, and Clang takes advantage; of this by default. This behavior can be controlled with the ``FP_CONTRACT``; and ``clang fp contract`` pragmas. Please refer to the pragma documentation; for a description of how the pragmas interact with this option. Valid values are:",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:56913,Performance,perform,performing,56913,"` to use; inline code (e.g. the x86 ``sqrtsd`` instruction) without additional; checking to ensure that ``errno`` is set appropriately.; ``-fno-math-errno`` permits these transformations. On some targets, math library functions never set ``errno``, and so; ``-fno-math-errno`` is the default. This includes most BSD-derived; systems, including Darwin. .. option:: -f[no-]trapping-math. Control floating point exception behavior. ``-fno-trapping-math`` allows optimizations that assume that floating point operations cannot generate traps such as divide-by-zero, overflow and underflow. - The option ``-ftrapping-math`` behaves identically to ``-ffp-exception-behavior=strict``.; - The option ``-fno-trapping-math`` behaves identically to ``-ffp-exception-behavior=ignore``. This is the default. .. option:: -ffp-contract=<value>. Specify when the compiler is permitted to form fused floating-point; operations, such as fused multiply-add (FMA). Fused operations are; permitted to produce more precise results than performing the same; operations separately. The C standard permits intermediate floating-point results within an; expression to be computed with more precision than their type would; normally allow. This permits operation fusing, and Clang takes advantage; of this by default. This behavior can be controlled with the ``FP_CONTRACT``; and ``clang fp contract`` pragmas. Please refer to the pragma documentation; for a description of how the pragmas interact with this option. Valid values are:. * ``fast`` (fuse across statements disregarding pragmas, default for CUDA); * ``on`` (fuse in the same statement unless dictated by pragmas, default for languages other than CUDA/HIP); * ``off`` (never fuse); * ``fast-honor-pragmas`` (fuse across statements unless dictated by pragmas, default for HIP). .. option:: -f[no-]honor-infinities. Allow floating-point optimizations that assume arguments and results are; not +-Inf.; Defaults to ``-fhonor-infinities``. If both ``-fno-honor-infiniti",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:57770,Performance,optimiz,optimizations,57770,"-point; operations, such as fused multiply-add (FMA). Fused operations are; permitted to produce more precise results than performing the same; operations separately. The C standard permits intermediate floating-point results within an; expression to be computed with more precision than their type would; normally allow. This permits operation fusing, and Clang takes advantage; of this by default. This behavior can be controlled with the ``FP_CONTRACT``; and ``clang fp contract`` pragmas. Please refer to the pragma documentation; for a description of how the pragmas interact with this option. Valid values are:. * ``fast`` (fuse across statements disregarding pragmas, default for CUDA); * ``on`` (fuse in the same statement unless dictated by pragmas, default for languages other than CUDA/HIP); * ``off`` (never fuse); * ``fast-honor-pragmas`` (fuse across statements unless dictated by pragmas, default for HIP). .. option:: -f[no-]honor-infinities. Allow floating-point optimizations that assume arguments and results are; not +-Inf.; Defaults to ``-fhonor-infinities``. If both ``-fno-honor-infinities`` and ``-fno-honor-nans`` are used,; has the same effect as specifying ``-ffinite-math-only``. .. option:: -f[no-]honor-nans. Allow floating-point optimizations that assume arguments and results are; not NaNs.; Defaults to ``-fhonor-nans``. If both ``-fno-honor-infinities`` and ``-fno-honor-nans`` are used,; has the same effect as specifying ``-ffinite-math-only``. .. option:: -f[no-]approx-func. Allow certain math function calls (such as ``log``, ``sqrt``, ``pow``, etc); to be replaced with an approximately equivalent set of instructions; or alternative math function calls. For example, a ``pow(x, 0.25)``; may be replaced with ``sqrt(sqrt(x))``, despite being an inexact result; in cases where ``x`` is ``-0.0`` or ``-inf``.; Defaults to ``-fno-approx-func``. .. option:: -f[no-]signed-zeros. Allow optimizations that ignore the sign of floating point zeros.; Defaults to ``-fsig",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:58050,Performance,optimiz,optimizations,58050,"on than their type would; normally allow. This permits operation fusing, and Clang takes advantage; of this by default. This behavior can be controlled with the ``FP_CONTRACT``; and ``clang fp contract`` pragmas. Please refer to the pragma documentation; for a description of how the pragmas interact with this option. Valid values are:. * ``fast`` (fuse across statements disregarding pragmas, default for CUDA); * ``on`` (fuse in the same statement unless dictated by pragmas, default for languages other than CUDA/HIP); * ``off`` (never fuse); * ``fast-honor-pragmas`` (fuse across statements unless dictated by pragmas, default for HIP). .. option:: -f[no-]honor-infinities. Allow floating-point optimizations that assume arguments and results are; not +-Inf.; Defaults to ``-fhonor-infinities``. If both ``-fno-honor-infinities`` and ``-fno-honor-nans`` are used,; has the same effect as specifying ``-ffinite-math-only``. .. option:: -f[no-]honor-nans. Allow floating-point optimizations that assume arguments and results are; not NaNs.; Defaults to ``-fhonor-nans``. If both ``-fno-honor-infinities`` and ``-fno-honor-nans`` are used,; has the same effect as specifying ``-ffinite-math-only``. .. option:: -f[no-]approx-func. Allow certain math function calls (such as ``log``, ``sqrt``, ``pow``, etc); to be replaced with an approximately equivalent set of instructions; or alternative math function calls. For example, a ``pow(x, 0.25)``; may be replaced with ``sqrt(sqrt(x))``, despite being an inexact result; in cases where ``x`` is ``-0.0`` or ``-inf``.; Defaults to ``-fno-approx-func``. .. option:: -f[no-]signed-zeros. Allow optimizations that ignore the sign of floating point zeros.; Defaults to ``-fsigned-zeros``. .. option:: -f[no-]associative-math. Allow floating point operations to be reassociated.; Defaults to ``-fno-associative-math``. .. option:: -f[no-]reciprocal-math. Allow division operations to be transformed into multiplication by a; reciprocal. This can be signifi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:58711,Performance,optimiz,optimizations,58711,"infinities. Allow floating-point optimizations that assume arguments and results are; not +-Inf.; Defaults to ``-fhonor-infinities``. If both ``-fno-honor-infinities`` and ``-fno-honor-nans`` are used,; has the same effect as specifying ``-ffinite-math-only``. .. option:: -f[no-]honor-nans. Allow floating-point optimizations that assume arguments and results are; not NaNs.; Defaults to ``-fhonor-nans``. If both ``-fno-honor-infinities`` and ``-fno-honor-nans`` are used,; has the same effect as specifying ``-ffinite-math-only``. .. option:: -f[no-]approx-func. Allow certain math function calls (such as ``log``, ``sqrt``, ``pow``, etc); to be replaced with an approximately equivalent set of instructions; or alternative math function calls. For example, a ``pow(x, 0.25)``; may be replaced with ``sqrt(sqrt(x))``, despite being an inexact result; in cases where ``x`` is ``-0.0`` or ``-inf``.; Defaults to ``-fno-approx-func``. .. option:: -f[no-]signed-zeros. Allow optimizations that ignore the sign of floating point zeros.; Defaults to ``-fsigned-zeros``. .. option:: -f[no-]associative-math. Allow floating point operations to be reassociated.; Defaults to ``-fno-associative-math``. .. option:: -f[no-]reciprocal-math. Allow division operations to be transformed into multiplication by a; reciprocal. This can be significantly faster than an ordinary division; but can also have significantly less precision. Defaults to; ``-fno-reciprocal-math``. .. option:: -f[no-]unsafe-math-optimizations. Allow unsafe floating-point optimizations.; ``-funsafe-math-optimizations`` also implies:. * ``-fapprox-func``; * ``-fassociative-math``; * ``-freciprocal-math``; * ``-fno-signed-zeros``; * ``-fno-trapping-math``; * ``-ffp-contract=fast``. ``-fno-unsafe-math-optimizations`` implies:. * ``-fno-approx-func``; * ``-fno-associative-math``; * ``-fno-reciprocal-math``; * ``-fsigned-zeros``; * ``-ftrapping-math``; * ``-ffp-contract=on``; * ``-fdenormal-fp-math=ieee``. There is ambiguity about ho",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:59229,Performance,optimiz,optimizations,59229,"same effect as specifying ``-ffinite-math-only``. .. option:: -f[no-]approx-func. Allow certain math function calls (such as ``log``, ``sqrt``, ``pow``, etc); to be replaced with an approximately equivalent set of instructions; or alternative math function calls. For example, a ``pow(x, 0.25)``; may be replaced with ``sqrt(sqrt(x))``, despite being an inexact result; in cases where ``x`` is ``-0.0`` or ``-inf``.; Defaults to ``-fno-approx-func``. .. option:: -f[no-]signed-zeros. Allow optimizations that ignore the sign of floating point zeros.; Defaults to ``-fsigned-zeros``. .. option:: -f[no-]associative-math. Allow floating point operations to be reassociated.; Defaults to ``-fno-associative-math``. .. option:: -f[no-]reciprocal-math. Allow division operations to be transformed into multiplication by a; reciprocal. This can be significantly faster than an ordinary division; but can also have significantly less precision. Defaults to; ``-fno-reciprocal-math``. .. option:: -f[no-]unsafe-math-optimizations. Allow unsafe floating-point optimizations.; ``-funsafe-math-optimizations`` also implies:. * ``-fapprox-func``; * ``-fassociative-math``; * ``-freciprocal-math``; * ``-fno-signed-zeros``; * ``-fno-trapping-math``; * ``-ffp-contract=fast``. ``-fno-unsafe-math-optimizations`` implies:. * ``-fno-approx-func``; * ``-fno-associative-math``; * ``-fno-reciprocal-math``; * ``-fsigned-zeros``; * ``-ftrapping-math``; * ``-ffp-contract=on``; * ``-fdenormal-fp-math=ieee``. There is ambiguity about how ``-ffp-contract``,; ``-funsafe-math-optimizations``, and ``-fno-unsafe-math-optimizations``; behave when combined. Explanation in :option:`-fno-fast-math` also applies; to these options. Defaults to ``-fno-unsafe-math-optimizations``. .. option:: -f[no-]finite-math-only. Allow floating-point optimizations that assume arguments and results are; not NaNs or +-Inf. ``-ffinite-math-only`` defines the; ``__FINITE_MATH_ONLY__`` preprocessor macro.; ``-ffinite-math-only`` implies:. * `",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:59272,Performance,optimiz,optimizations,59272,"nly``. .. option:: -f[no-]approx-func. Allow certain math function calls (such as ``log``, ``sqrt``, ``pow``, etc); to be replaced with an approximately equivalent set of instructions; or alternative math function calls. For example, a ``pow(x, 0.25)``; may be replaced with ``sqrt(sqrt(x))``, despite being an inexact result; in cases where ``x`` is ``-0.0`` or ``-inf``.; Defaults to ``-fno-approx-func``. .. option:: -f[no-]signed-zeros. Allow optimizations that ignore the sign of floating point zeros.; Defaults to ``-fsigned-zeros``. .. option:: -f[no-]associative-math. Allow floating point operations to be reassociated.; Defaults to ``-fno-associative-math``. .. option:: -f[no-]reciprocal-math. Allow division operations to be transformed into multiplication by a; reciprocal. This can be significantly faster than an ordinary division; but can also have significantly less precision. Defaults to; ``-fno-reciprocal-math``. .. option:: -f[no-]unsafe-math-optimizations. Allow unsafe floating-point optimizations.; ``-funsafe-math-optimizations`` also implies:. * ``-fapprox-func``; * ``-fassociative-math``; * ``-freciprocal-math``; * ``-fno-signed-zeros``; * ``-fno-trapping-math``; * ``-ffp-contract=fast``. ``-fno-unsafe-math-optimizations`` implies:. * ``-fno-approx-func``; * ``-fno-associative-math``; * ``-fno-reciprocal-math``; * ``-fsigned-zeros``; * ``-ftrapping-math``; * ``-ffp-contract=on``; * ``-fdenormal-fp-math=ieee``. There is ambiguity about how ``-ffp-contract``,; ``-funsafe-math-optimizations``, and ``-fno-unsafe-math-optimizations``; behave when combined. Explanation in :option:`-fno-fast-math` also applies; to these options. Defaults to ``-fno-unsafe-math-optimizations``. .. option:: -f[no-]finite-math-only. Allow floating-point optimizations that assume arguments and results are; not NaNs or +-Inf. ``-ffinite-math-only`` defines the; ``__FINITE_MATH_ONLY__`` preprocessor macro.; ``-ffinite-math-only`` implies:. * ``-fno-honor-infinities``; * ``-fno-honor-na",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:59304,Performance,optimiz,optimizations,59304,"ertain math function calls (such as ``log``, ``sqrt``, ``pow``, etc); to be replaced with an approximately equivalent set of instructions; or alternative math function calls. For example, a ``pow(x, 0.25)``; may be replaced with ``sqrt(sqrt(x))``, despite being an inexact result; in cases where ``x`` is ``-0.0`` or ``-inf``.; Defaults to ``-fno-approx-func``. .. option:: -f[no-]signed-zeros. Allow optimizations that ignore the sign of floating point zeros.; Defaults to ``-fsigned-zeros``. .. option:: -f[no-]associative-math. Allow floating point operations to be reassociated.; Defaults to ``-fno-associative-math``. .. option:: -f[no-]reciprocal-math. Allow division operations to be transformed into multiplication by a; reciprocal. This can be significantly faster than an ordinary division; but can also have significantly less precision. Defaults to; ``-fno-reciprocal-math``. .. option:: -f[no-]unsafe-math-optimizations. Allow unsafe floating-point optimizations.; ``-funsafe-math-optimizations`` also implies:. * ``-fapprox-func``; * ``-fassociative-math``; * ``-freciprocal-math``; * ``-fno-signed-zeros``; * ``-fno-trapping-math``; * ``-ffp-contract=fast``. ``-fno-unsafe-math-optimizations`` implies:. * ``-fno-approx-func``; * ``-fno-associative-math``; * ``-fno-reciprocal-math``; * ``-fsigned-zeros``; * ``-ftrapping-math``; * ``-ffp-contract=on``; * ``-fdenormal-fp-math=ieee``. There is ambiguity about how ``-ffp-contract``,; ``-funsafe-math-optimizations``, and ``-fno-unsafe-math-optimizations``; behave when combined. Explanation in :option:`-fno-fast-math` also applies; to these options. Defaults to ``-fno-unsafe-math-optimizations``. .. option:: -f[no-]finite-math-only. Allow floating-point optimizations that assume arguments and results are; not NaNs or +-Inf. ``-ffinite-math-only`` defines the; ``__FINITE_MATH_ONLY__`` preprocessor macro.; ``-ffinite-math-only`` implies:. * ``-fno-honor-infinities``; * ``-fno-honor-nans``. ``-ffno-inite-math-only`` implies:. * `",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:59503,Performance,optimiz,optimizations,59503,"(x, 0.25)``; may be replaced with ``sqrt(sqrt(x))``, despite being an inexact result; in cases where ``x`` is ``-0.0`` or ``-inf``.; Defaults to ``-fno-approx-func``. .. option:: -f[no-]signed-zeros. Allow optimizations that ignore the sign of floating point zeros.; Defaults to ``-fsigned-zeros``. .. option:: -f[no-]associative-math. Allow floating point operations to be reassociated.; Defaults to ``-fno-associative-math``. .. option:: -f[no-]reciprocal-math. Allow division operations to be transformed into multiplication by a; reciprocal. This can be significantly faster than an ordinary division; but can also have significantly less precision. Defaults to; ``-fno-reciprocal-math``. .. option:: -f[no-]unsafe-math-optimizations. Allow unsafe floating-point optimizations.; ``-funsafe-math-optimizations`` also implies:. * ``-fapprox-func``; * ``-fassociative-math``; * ``-freciprocal-math``; * ``-fno-signed-zeros``; * ``-fno-trapping-math``; * ``-ffp-contract=fast``. ``-fno-unsafe-math-optimizations`` implies:. * ``-fno-approx-func``; * ``-fno-associative-math``; * ``-fno-reciprocal-math``; * ``-fsigned-zeros``; * ``-ftrapping-math``; * ``-ffp-contract=on``; * ``-fdenormal-fp-math=ieee``. There is ambiguity about how ``-ffp-contract``,; ``-funsafe-math-optimizations``, and ``-fno-unsafe-math-optimizations``; behave when combined. Explanation in :option:`-fno-fast-math` also applies; to these options. Defaults to ``-fno-unsafe-math-optimizations``. .. option:: -f[no-]finite-math-only. Allow floating-point optimizations that assume arguments and results are; not NaNs or +-Inf. ``-ffinite-math-only`` defines the; ``__FINITE_MATH_ONLY__`` preprocessor macro.; ``-ffinite-math-only`` implies:. * ``-fno-honor-infinities``; * ``-fno-honor-nans``. ``-ffno-inite-math-only`` implies:. * ``-fhonor-infinities``; * ``-fhonor-nans``. Defaults to ``-fno-finite-math-only``. .. option:: -f[no-]rounding-math. Force floating-point operations to honor the dynamically-set rounding mode by de",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:59775,Performance,optimiz,optimizations,59775,"to ``-fsigned-zeros``. .. option:: -f[no-]associative-math. Allow floating point operations to be reassociated.; Defaults to ``-fno-associative-math``. .. option:: -f[no-]reciprocal-math. Allow division operations to be transformed into multiplication by a; reciprocal. This can be significantly faster than an ordinary division; but can also have significantly less precision. Defaults to; ``-fno-reciprocal-math``. .. option:: -f[no-]unsafe-math-optimizations. Allow unsafe floating-point optimizations.; ``-funsafe-math-optimizations`` also implies:. * ``-fapprox-func``; * ``-fassociative-math``; * ``-freciprocal-math``; * ``-fno-signed-zeros``; * ``-fno-trapping-math``; * ``-ffp-contract=fast``. ``-fno-unsafe-math-optimizations`` implies:. * ``-fno-approx-func``; * ``-fno-associative-math``; * ``-fno-reciprocal-math``; * ``-fsigned-zeros``; * ``-ftrapping-math``; * ``-ffp-contract=on``; * ``-fdenormal-fp-math=ieee``. There is ambiguity about how ``-ffp-contract``,; ``-funsafe-math-optimizations``, and ``-fno-unsafe-math-optimizations``; behave when combined. Explanation in :option:`-fno-fast-math` also applies; to these options. Defaults to ``-fno-unsafe-math-optimizations``. .. option:: -f[no-]finite-math-only. Allow floating-point optimizations that assume arguments and results are; not NaNs or +-Inf. ``-ffinite-math-only`` defines the; ``__FINITE_MATH_ONLY__`` preprocessor macro.; ``-ffinite-math-only`` implies:. * ``-fno-honor-infinities``; * ``-fno-honor-nans``. ``-ffno-inite-math-only`` implies:. * ``-fhonor-infinities``; * ``-fhonor-nans``. Defaults to ``-fno-finite-math-only``. .. option:: -f[no-]rounding-math. Force floating-point operations to honor the dynamically-set rounding mode by default. The result of a floating-point operation often cannot be exactly represented in the result type and therefore must be rounded. IEEE 754 describes different rounding modes that control how to perform this rounding, not all of which are supported by all implementations.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:59815,Performance,optimiz,optimizations,59815,"to ``-fsigned-zeros``. .. option:: -f[no-]associative-math. Allow floating point operations to be reassociated.; Defaults to ``-fno-associative-math``. .. option:: -f[no-]reciprocal-math. Allow division operations to be transformed into multiplication by a; reciprocal. This can be significantly faster than an ordinary division; but can also have significantly less precision. Defaults to; ``-fno-reciprocal-math``. .. option:: -f[no-]unsafe-math-optimizations. Allow unsafe floating-point optimizations.; ``-funsafe-math-optimizations`` also implies:. * ``-fapprox-func``; * ``-fassociative-math``; * ``-freciprocal-math``; * ``-fno-signed-zeros``; * ``-fno-trapping-math``; * ``-ffp-contract=fast``. ``-fno-unsafe-math-optimizations`` implies:. * ``-fno-approx-func``; * ``-fno-associative-math``; * ``-fno-reciprocal-math``; * ``-fsigned-zeros``; * ``-ftrapping-math``; * ``-ffp-contract=on``; * ``-fdenormal-fp-math=ieee``. There is ambiguity about how ``-ffp-contract``,; ``-funsafe-math-optimizations``, and ``-fno-unsafe-math-optimizations``; behave when combined. Explanation in :option:`-fno-fast-math` also applies; to these options. Defaults to ``-fno-unsafe-math-optimizations``. .. option:: -f[no-]finite-math-only. Allow floating-point optimizations that assume arguments and results are; not NaNs or +-Inf. ``-ffinite-math-only`` defines the; ``__FINITE_MATH_ONLY__`` preprocessor macro.; ``-ffinite-math-only`` implies:. * ``-fno-honor-infinities``; * ``-fno-honor-nans``. ``-ffno-inite-math-only`` implies:. * ``-fhonor-infinities``; * ``-fhonor-nans``. Defaults to ``-fno-finite-math-only``. .. option:: -f[no-]rounding-math. Force floating-point operations to honor the dynamically-set rounding mode by default. The result of a floating-point operation often cannot be exactly represented in the result type and therefore must be rounded. IEEE 754 describes different rounding modes that control how to perform this rounding, not all of which are supported by all implementations.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:59957,Performance,optimiz,optimizations,59957,"o-]reciprocal-math. Allow division operations to be transformed into multiplication by a; reciprocal. This can be significantly faster than an ordinary division; but can also have significantly less precision. Defaults to; ``-fno-reciprocal-math``. .. option:: -f[no-]unsafe-math-optimizations. Allow unsafe floating-point optimizations.; ``-funsafe-math-optimizations`` also implies:. * ``-fapprox-func``; * ``-fassociative-math``; * ``-freciprocal-math``; * ``-fno-signed-zeros``; * ``-fno-trapping-math``; * ``-ffp-contract=fast``. ``-fno-unsafe-math-optimizations`` implies:. * ``-fno-approx-func``; * ``-fno-associative-math``; * ``-fno-reciprocal-math``; * ``-fsigned-zeros``; * ``-ftrapping-math``; * ``-ffp-contract=on``; * ``-fdenormal-fp-math=ieee``. There is ambiguity about how ``-ffp-contract``,; ``-funsafe-math-optimizations``, and ``-fno-unsafe-math-optimizations``; behave when combined. Explanation in :option:`-fno-fast-math` also applies; to these options. Defaults to ``-fno-unsafe-math-optimizations``. .. option:: -f[no-]finite-math-only. Allow floating-point optimizations that assume arguments and results are; not NaNs or +-Inf. ``-ffinite-math-only`` defines the; ``__FINITE_MATH_ONLY__`` preprocessor macro.; ``-ffinite-math-only`` implies:. * ``-fno-honor-infinities``; * ``-fno-honor-nans``. ``-ffno-inite-math-only`` implies:. * ``-fhonor-infinities``; * ``-fhonor-nans``. Defaults to ``-fno-finite-math-only``. .. option:: -f[no-]rounding-math. Force floating-point operations to honor the dynamically-set rounding mode by default. The result of a floating-point operation often cannot be exactly represented in the result type and therefore must be rounded. IEEE 754 describes different rounding modes that control how to perform this rounding, not all of which are supported by all implementations. C provides interfaces (``fesetround`` and ``fesetenv``) for dynamically controlling the rounding mode, and while it also recommends certain conventions for changing th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:60032,Performance,optimiz,optimizations,60032,"can be significantly faster than an ordinary division; but can also have significantly less precision. Defaults to; ``-fno-reciprocal-math``. .. option:: -f[no-]unsafe-math-optimizations. Allow unsafe floating-point optimizations.; ``-funsafe-math-optimizations`` also implies:. * ``-fapprox-func``; * ``-fassociative-math``; * ``-freciprocal-math``; * ``-fno-signed-zeros``; * ``-fno-trapping-math``; * ``-ffp-contract=fast``. ``-fno-unsafe-math-optimizations`` implies:. * ``-fno-approx-func``; * ``-fno-associative-math``; * ``-fno-reciprocal-math``; * ``-fsigned-zeros``; * ``-ftrapping-math``; * ``-ffp-contract=on``; * ``-fdenormal-fp-math=ieee``. There is ambiguity about how ``-ffp-contract``,; ``-funsafe-math-optimizations``, and ``-fno-unsafe-math-optimizations``; behave when combined. Explanation in :option:`-fno-fast-math` also applies; to these options. Defaults to ``-fno-unsafe-math-optimizations``. .. option:: -f[no-]finite-math-only. Allow floating-point optimizations that assume arguments and results are; not NaNs or +-Inf. ``-ffinite-math-only`` defines the; ``__FINITE_MATH_ONLY__`` preprocessor macro.; ``-ffinite-math-only`` implies:. * ``-fno-honor-infinities``; * ``-fno-honor-nans``. ``-ffno-inite-math-only`` implies:. * ``-fhonor-infinities``; * ``-fhonor-nans``. Defaults to ``-fno-finite-math-only``. .. option:: -f[no-]rounding-math. Force floating-point operations to honor the dynamically-set rounding mode by default. The result of a floating-point operation often cannot be exactly represented in the result type and therefore must be rounded. IEEE 754 describes different rounding modes that control how to perform this rounding, not all of which are supported by all implementations. C provides interfaces (``fesetround`` and ``fesetenv``) for dynamically controlling the rounding mode, and while it also recommends certain conventions for changing the rounding mode, these conventions are not typically enforced in the ABI. Since the rounding mode changes th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:60704,Performance,perform,perform,60704,"There is ambiguity about how ``-ffp-contract``,; ``-funsafe-math-optimizations``, and ``-fno-unsafe-math-optimizations``; behave when combined. Explanation in :option:`-fno-fast-math` also applies; to these options. Defaults to ``-fno-unsafe-math-optimizations``. .. option:: -f[no-]finite-math-only. Allow floating-point optimizations that assume arguments and results are; not NaNs or +-Inf. ``-ffinite-math-only`` defines the; ``__FINITE_MATH_ONLY__`` preprocessor macro.; ``-ffinite-math-only`` implies:. * ``-fno-honor-infinities``; * ``-fno-honor-nans``. ``-ffno-inite-math-only`` implies:. * ``-fhonor-infinities``; * ``-fhonor-nans``. Defaults to ``-fno-finite-math-only``. .. option:: -f[no-]rounding-math. Force floating-point operations to honor the dynamically-set rounding mode by default. The result of a floating-point operation often cannot be exactly represented in the result type and therefore must be rounded. IEEE 754 describes different rounding modes that control how to perform this rounding, not all of which are supported by all implementations. C provides interfaces (``fesetround`` and ``fesetenv``) for dynamically controlling the rounding mode, and while it also recommends certain conventions for changing the rounding mode, these conventions are not typically enforced in the ABI. Since the rounding mode changes the numerical result of operations, the compiler must understand something about it in order to optimize floating point operations. Note that floating-point operations performed as part of constant initialization are formally performed prior to the start of the program and are therefore not subject to the current rounding mode. This includes the initialization of global variables and local ``static`` variables. Floating-point operations in these contexts will be rounded using ``FE_TONEAREST``. - The option ``-fno-rounding-math`` allows the compiler to assume that the rounding mode is set to ``FE_TONEAREST``. This is the default.; - The option ``-f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:61151,Performance,optimiz,optimize,61151,"``-ffinite-math-only`` defines the; ``__FINITE_MATH_ONLY__`` preprocessor macro.; ``-ffinite-math-only`` implies:. * ``-fno-honor-infinities``; * ``-fno-honor-nans``. ``-ffno-inite-math-only`` implies:. * ``-fhonor-infinities``; * ``-fhonor-nans``. Defaults to ``-fno-finite-math-only``. .. option:: -f[no-]rounding-math. Force floating-point operations to honor the dynamically-set rounding mode by default. The result of a floating-point operation often cannot be exactly represented in the result type and therefore must be rounded. IEEE 754 describes different rounding modes that control how to perform this rounding, not all of which are supported by all implementations. C provides interfaces (``fesetround`` and ``fesetenv``) for dynamically controlling the rounding mode, and while it also recommends certain conventions for changing the rounding mode, these conventions are not typically enforced in the ABI. Since the rounding mode changes the numerical result of operations, the compiler must understand something about it in order to optimize floating point operations. Note that floating-point operations performed as part of constant initialization are formally performed prior to the start of the program and are therefore not subject to the current rounding mode. This includes the initialization of global variables and local ``static`` variables. Floating-point operations in these contexts will be rounded using ``FE_TONEAREST``. - The option ``-fno-rounding-math`` allows the compiler to assume that the rounding mode is set to ``FE_TONEAREST``. This is the default.; - The option ``-frounding-math`` forces the compiler to honor the dynamically-set rounding mode. This prevents optimizations which might affect results if the rounding mode changes or is different from the default; for example, it prevents floating-point operations from being reordered across most calls and prevents constant-folding when the result is not exactly representable. .. option:: -ffp-model=<value>",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:61223,Performance,perform,performed,61223,"math-only`` implies:. * ``-fhonor-infinities``; * ``-fhonor-nans``. Defaults to ``-fno-finite-math-only``. .. option:: -f[no-]rounding-math. Force floating-point operations to honor the dynamically-set rounding mode by default. The result of a floating-point operation often cannot be exactly represented in the result type and therefore must be rounded. IEEE 754 describes different rounding modes that control how to perform this rounding, not all of which are supported by all implementations. C provides interfaces (``fesetround`` and ``fesetenv``) for dynamically controlling the rounding mode, and while it also recommends certain conventions for changing the rounding mode, these conventions are not typically enforced in the ABI. Since the rounding mode changes the numerical result of operations, the compiler must understand something about it in order to optimize floating point operations. Note that floating-point operations performed as part of constant initialization are formally performed prior to the start of the program and are therefore not subject to the current rounding mode. This includes the initialization of global variables and local ``static`` variables. Floating-point operations in these contexts will be rounded using ``FE_TONEAREST``. - The option ``-fno-rounding-math`` allows the compiler to assume that the rounding mode is set to ``FE_TONEAREST``. This is the default.; - The option ``-frounding-math`` forces the compiler to honor the dynamically-set rounding mode. This prevents optimizations which might affect results if the rounding mode changes or is different from the default; for example, it prevents floating-point operations from being reordered across most calls and prevents constant-folding when the result is not exactly representable. .. option:: -ffp-model=<value>. Specify floating point behavior. ``-ffp-model`` is an umbrella; option that encompasses functionality provided by other, single; purpose, floating point options. Valid values are:",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:61281,Performance,perform,performed,61281,"math-only`` implies:. * ``-fhonor-infinities``; * ``-fhonor-nans``. Defaults to ``-fno-finite-math-only``. .. option:: -f[no-]rounding-math. Force floating-point operations to honor the dynamically-set rounding mode by default. The result of a floating-point operation often cannot be exactly represented in the result type and therefore must be rounded. IEEE 754 describes different rounding modes that control how to perform this rounding, not all of which are supported by all implementations. C provides interfaces (``fesetround`` and ``fesetenv``) for dynamically controlling the rounding mode, and while it also recommends certain conventions for changing the rounding mode, these conventions are not typically enforced in the ABI. Since the rounding mode changes the numerical result of operations, the compiler must understand something about it in order to optimize floating point operations. Note that floating-point operations performed as part of constant initialization are formally performed prior to the start of the program and are therefore not subject to the current rounding mode. This includes the initialization of global variables and local ``static`` variables. Floating-point operations in these contexts will be rounded using ``FE_TONEAREST``. - The option ``-fno-rounding-math`` allows the compiler to assume that the rounding mode is set to ``FE_TONEAREST``. This is the default.; - The option ``-frounding-math`` forces the compiler to honor the dynamically-set rounding mode. This prevents optimizations which might affect results if the rounding mode changes or is different from the default; for example, it prevents floating-point operations from being reordered across most calls and prevents constant-folding when the result is not exactly representable. .. option:: -ffp-model=<value>. Specify floating point behavior. ``-ffp-model`` is an umbrella; option that encompasses functionality provided by other, single; purpose, floating point options. Valid values are:",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:61804,Performance,optimiz,optimizations,61804,"ns for changing the rounding mode, these conventions are not typically enforced in the ABI. Since the rounding mode changes the numerical result of operations, the compiler must understand something about it in order to optimize floating point operations. Note that floating-point operations performed as part of constant initialization are formally performed prior to the start of the program and are therefore not subject to the current rounding mode. This includes the initialization of global variables and local ``static`` variables. Floating-point operations in these contexts will be rounded using ``FE_TONEAREST``. - The option ``-fno-rounding-math`` allows the compiler to assume that the rounding mode is set to ``FE_TONEAREST``. This is the default.; - The option ``-frounding-math`` forces the compiler to honor the dynamically-set rounding mode. This prevents optimizations which might affect results if the rounding mode changes or is different from the default; for example, it prevents floating-point operations from being reordered across most calls and prevents constant-folding when the result is not exactly representable. .. option:: -ffp-model=<value>. Specify floating point behavior. ``-ffp-model`` is an umbrella; option that encompasses functionality provided by other, single; purpose, floating point options. Valid values are: ``precise``, ``strict``,; and ``fast``.; Details:. * ``precise`` Disables optimizations that are not value-safe on; floating-point data, although FP contraction (FMA) is enabled; (``-ffp-contract=on``). This is the default behavior. This value resets; ``-fmath-errno`` to its target-dependent default.; * ``strict`` Enables ``-frounding-math`` and; ``-ffp-exception-behavior=strict``, and disables contractions (FMA). All; of the ``-ffast-math`` enablements are disabled. Enables; ``STDC FENV_ACCESS``: by default ``FENV_ACCESS`` is disabled. This option; setting behaves as though ``#pragma STDC FENV_ACCESS ON`` appeared at the; top of the sou",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:62360,Performance,optimiz,optimizations,62360,"ation of global variables and local ``static`` variables. Floating-point operations in these contexts will be rounded using ``FE_TONEAREST``. - The option ``-fno-rounding-math`` allows the compiler to assume that the rounding mode is set to ``FE_TONEAREST``. This is the default.; - The option ``-frounding-math`` forces the compiler to honor the dynamically-set rounding mode. This prevents optimizations which might affect results if the rounding mode changes or is different from the default; for example, it prevents floating-point operations from being reordered across most calls and prevents constant-folding when the result is not exactly representable. .. option:: -ffp-model=<value>. Specify floating point behavior. ``-ffp-model`` is an umbrella; option that encompasses functionality provided by other, single; purpose, floating point options. Valid values are: ``precise``, ``strict``,; and ``fast``.; Details:. * ``precise`` Disables optimizations that are not value-safe on; floating-point data, although FP contraction (FMA) is enabled; (``-ffp-contract=on``). This is the default behavior. This value resets; ``-fmath-errno`` to its target-dependent default.; * ``strict`` Enables ``-frounding-math`` and; ``-ffp-exception-behavior=strict``, and disables contractions (FMA). All; of the ``-ffast-math`` enablements are disabled. Enables; ``STDC FENV_ACCESS``: by default ``FENV_ACCESS`` is disabled. This option; setting behaves as though ``#pragma STDC FENV_ACCESS ON`` appeared at the; top of the source file.; * ``fast`` Behaves identically to specifying both ``-ffast-math`` and; ``ffp-contract=fast``. Note: If your command line specifies multiple instances; of the ``-ffp-model`` option, or if your command line option specifies; ``-ffp-model`` and later on the command line selects a floating point; option that has the effect of negating part of the ``ffp-model`` that; has been selected, then the compiler will issue a diagnostic warning; that the override has occurred. .. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:63886,Performance,perform,performed,63886,"eared at the; top of the source file.; * ``fast`` Behaves identically to specifying both ``-ffast-math`` and; ``ffp-contract=fast``. Note: If your command line specifies multiple instances; of the ``-ffp-model`` option, or if your command line option specifies; ``-ffp-model`` and later on the command line selects a floating point; option that has the effect of negating part of the ``ffp-model`` that; has been selected, then the compiler will issue a diagnostic warning; that the override has occurred. .. option:: -ffp-exception-behavior=<value>. Specify the floating-point exception behavior. Valid values are: ``ignore``, ``maytrap``, and ``strict``.; The default value is ``ignore``. Details:. * ``ignore`` The compiler assumes that the exception status flags will not be read and that floating point exceptions will be masked.; * ``maytrap`` The compiler avoids transformations that may raise exceptions that would not have been raised by the original code. Constant folding performed by the compiler is exempt from this option.; * ``strict`` The compiler ensures that all transformations strictly preserve the floating point exception semantics of the original code. .. option:: -ffp-eval-method=<value>. Specify the floating-point evaluation method for intermediate results within; a single expression of the code. Valid values are: ``source``, ``double``, and ``extended``.; For 64-bit targets, the default value is ``source``. For 32-bit x86 targets; however, in the case of NETBSD 6.99.26 and under, the default value is; ``double``; in the case of NETBSD greater than 6.99.26, with NoSSE, the; default value is ``extended``, with SSE the default value is ``source``.; Details:. * ``source`` The compiler uses the floating-point type declared in the source program as the evaluation method.; * ``double`` The compiler uses ``double`` as the floating-point evaluation method for all float expressions of type that is narrower than ``double``.; * ``extended`` The compiler uses ``long doubl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:65428,Performance,optimiz,optimizer,65428,"default value is ``extended``, with SSE the default value is ``source``.; Details:. * ``source`` The compiler uses the floating-point type declared in the source program as the evaluation method.; * ``double`` The compiler uses ``double`` as the floating-point evaluation method for all float expressions of type that is narrower than ``double``.; * ``extended`` The compiler uses ``long double`` as the floating-point evaluation method for all float expressions of type that is narrower than ``long double``. .. option:: -f[no-]protect-parens. This option pertains to floating-point types, complex types with; floating-point components, and vectors of these types. Some arithmetic; expression transformations that are mathematically correct and permissible; according to the C and C++ language standards may be incorrect when dealing; with floating-point types, such as reassociation and distribution. Further,; the optimizer may ignore parentheses when computing arithmetic expressions; in circumstances where the parenthesized and unparenthesized expression; express the same mathematical value. For example (a+b)+c is the same; mathematical value as a+(b+c), but the optimizer is free to evaluate the; additions in any order regardless of the parentheses. When enabled, this; option forces the optimizer to honor the order of operations with respect; to parentheses in all circumstances.; Defaults to ``-fno-protect-parens``. Note that floating-point contraction (option `-ffp-contract=`) is disabled; when `-fprotect-parens` is enabled. Also note that in safe floating-point; modes, such as `-ffp-model=precise` or `-ffp-model=strict`, this option; has no effect because the optimizer is prohibited from making unsafe; transformations. .. option:: -fexcess-precision:. The C and C++ standards allow floating-point expressions to be computed as if; intermediate results had more precision (and/or a wider range) than the type; of the expression strictly allows. This is called excess precision; a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:65682,Performance,optimiz,optimizer,65682,"valuation method.; * ``double`` The compiler uses ``double`` as the floating-point evaluation method for all float expressions of type that is narrower than ``double``.; * ``extended`` The compiler uses ``long double`` as the floating-point evaluation method for all float expressions of type that is narrower than ``long double``. .. option:: -f[no-]protect-parens. This option pertains to floating-point types, complex types with; floating-point components, and vectors of these types. Some arithmetic; expression transformations that are mathematically correct and permissible; according to the C and C++ language standards may be incorrect when dealing; with floating-point types, such as reassociation and distribution. Further,; the optimizer may ignore parentheses when computing arithmetic expressions; in circumstances where the parenthesized and unparenthesized expression; express the same mathematical value. For example (a+b)+c is the same; mathematical value as a+(b+c), but the optimizer is free to evaluate the; additions in any order regardless of the parentheses. When enabled, this; option forces the optimizer to honor the order of operations with respect; to parentheses in all circumstances.; Defaults to ``-fno-protect-parens``. Note that floating-point contraction (option `-ffp-contract=`) is disabled; when `-fprotect-parens` is enabled. Also note that in safe floating-point; modes, such as `-ffp-model=precise` or `-ffp-model=strict`, this option; has no effect because the optimizer is prohibited from making unsafe; transformations. .. option:: -fexcess-precision:. The C and C++ standards allow floating-point expressions to be computed as if; intermediate results had more precision (and/or a wider range) than the type; of the expression strictly allows. This is called excess precision; arithmetic.; Excess precision arithmetic can improve the accuracy of results (although not; always), and it can make computation significantly faster if the target lacks; direct ha",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:65809,Performance,optimiz,optimizer,65809,"ower than ``double``.; * ``extended`` The compiler uses ``long double`` as the floating-point evaluation method for all float expressions of type that is narrower than ``long double``. .. option:: -f[no-]protect-parens. This option pertains to floating-point types, complex types with; floating-point components, and vectors of these types. Some arithmetic; expression transformations that are mathematically correct and permissible; according to the C and C++ language standards may be incorrect when dealing; with floating-point types, such as reassociation and distribution. Further,; the optimizer may ignore parentheses when computing arithmetic expressions; in circumstances where the parenthesized and unparenthesized expression; express the same mathematical value. For example (a+b)+c is the same; mathematical value as a+(b+c), but the optimizer is free to evaluate the; additions in any order regardless of the parentheses. When enabled, this; option forces the optimizer to honor the order of operations with respect; to parentheses in all circumstances.; Defaults to ``-fno-protect-parens``. Note that floating-point contraction (option `-ffp-contract=`) is disabled; when `-fprotect-parens` is enabled. Also note that in safe floating-point; modes, such as `-ffp-model=precise` or `-ffp-model=strict`, this option; has no effect because the optimizer is prohibited from making unsafe; transformations. .. option:: -fexcess-precision:. The C and C++ standards allow floating-point expressions to be computed as if; intermediate results had more precision (and/or a wider range) than the type; of the expression strictly allows. This is called excess precision; arithmetic.; Excess precision arithmetic can improve the accuracy of results (although not; always), and it can make computation significantly faster if the target lacks; direct hardware support for arithmetic in a particular type. However, it can; also undermine strict floating-point reproducibility. Under the standards, as",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:66191,Performance,optimiz,optimizer,66191,"d vectors of these types. Some arithmetic; expression transformations that are mathematically correct and permissible; according to the C and C++ language standards may be incorrect when dealing; with floating-point types, such as reassociation and distribution. Further,; the optimizer may ignore parentheses when computing arithmetic expressions; in circumstances where the parenthesized and unparenthesized expression; express the same mathematical value. For example (a+b)+c is the same; mathematical value as a+(b+c), but the optimizer is free to evaluate the; additions in any order regardless of the parentheses. When enabled, this; option forces the optimizer to honor the order of operations with respect; to parentheses in all circumstances.; Defaults to ``-fno-protect-parens``. Note that floating-point contraction (option `-ffp-contract=`) is disabled; when `-fprotect-parens` is enabled. Also note that in safe floating-point; modes, such as `-ffp-model=precise` or `-ffp-model=strict`, this option; has no effect because the optimizer is prohibited from making unsafe; transformations. .. option:: -fexcess-precision:. The C and C++ standards allow floating-point expressions to be computed as if; intermediate results had more precision (and/or a wider range) than the type; of the expression strictly allows. This is called excess precision; arithmetic.; Excess precision arithmetic can improve the accuracy of results (although not; always), and it can make computation significantly faster if the target lacks; direct hardware support for arithmetic in a particular type. However, it can; also undermine strict floating-point reproducibility. Under the standards, assignments and explicit casts force the operand to be; converted to its formal type, discarding any excess precision. Because data; can only flow between statements via an assignment, this means that the use; of excess precision arithmetic is a reliable local property of a single; statement, and results do not chang",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:67163,Performance,optimiz,optimization,67163,"hat in safe floating-point; modes, such as `-ffp-model=precise` or `-ffp-model=strict`, this option; has no effect because the optimizer is prohibited from making unsafe; transformations. .. option:: -fexcess-precision:. The C and C++ standards allow floating-point expressions to be computed as if; intermediate results had more precision (and/or a wider range) than the type; of the expression strictly allows. This is called excess precision; arithmetic.; Excess precision arithmetic can improve the accuracy of results (although not; always), and it can make computation significantly faster if the target lacks; direct hardware support for arithmetic in a particular type. However, it can; also undermine strict floating-point reproducibility. Under the standards, assignments and explicit casts force the operand to be; converted to its formal type, discarding any excess precision. Because data; can only flow between statements via an assignment, this means that the use; of excess precision arithmetic is a reliable local property of a single; statement, and results do not change based on optimization. However, when; excess precision arithmetic is in use, Clang does not guarantee strict; reproducibility, and future compiler releases may recognize more; opportunities to use excess precision arithmetic, e.g. with floating-point; builtins. Clang does not use excess precision arithmetic for most types or on most; targets. For example, even on pre-SSE X86 targets where ``float`` and; ``double`` computations must be performed in the 80-bit X87 format, Clang; rounds all intermediate results correctly for their type. Clang currently; uses excess precision arithmetic by default only for the following types and; targets:. * ``_Float16`` on X86 targets without ``AVX512-FP16``. The ``-fexcess-precision=<value>`` option can be used to control the use of; excess precision arithmetic. Valid values are:. * ``standard`` - The default. Allow the use of excess precision arithmetic; under the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:67593,Performance,perform,performed,67593,"h not; always), and it can make computation significantly faster if the target lacks; direct hardware support for arithmetic in a particular type. However, it can; also undermine strict floating-point reproducibility. Under the standards, assignments and explicit casts force the operand to be; converted to its formal type, discarding any excess precision. Because data; can only flow between statements via an assignment, this means that the use; of excess precision arithmetic is a reliable local property of a single; statement, and results do not change based on optimization. However, when; excess precision arithmetic is in use, Clang does not guarantee strict; reproducibility, and future compiler releases may recognize more; opportunities to use excess precision arithmetic, e.g. with floating-point; builtins. Clang does not use excess precision arithmetic for most types or on most; targets. For example, even on pre-SSE X86 targets where ``float`` and; ``double`` computations must be performed in the 80-bit X87 format, Clang; rounds all intermediate results correctly for their type. Clang currently; uses excess precision arithmetic by default only for the following types and; targets:. * ``_Float16`` on X86 targets without ``AVX512-FP16``. The ``-fexcess-precision=<value>`` option can be used to control the use of; excess precision arithmetic. Valid values are:. * ``standard`` - The default. Allow the use of excess precision arithmetic; under the constraints of the C and C++ standards. Has no effect except on; the types and targets listed above.; * ``fast`` - Accepted for GCC compatibility, but currently treated as an; alias for ``standard``.; * ``16`` - Forces ``_Float16`` operations to be emitted without using excess; precision arithmetic. .. option:: -fcx-limited-range:. This option enables the naive mathematical formulas for complex division and; multiplication with no NaN checking of results. The default is; ``-fno-cx-limited-range``, but this option is enabled b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:69418,Performance,perform,performed,69418," option:: -fcx-limited-range:. This option enables the naive mathematical formulas for complex division and; multiplication with no NaN checking of results. The default is; ``-fno-cx-limited-range``, but this option is enabled by the ``-ffast-math``; option. .. option:: -fcx-fortran-rules:. This option enables the naive mathematical formulas for complex; multiplication and enables application of Smith's algorithm for complex; division. See SMITH, R. L. Algorithm 116: Complex division. Commun.; ACM 5, 8 (1962). The default is ``-fno-cx-fortran-rules``. .. _floating-point-environment:. Accessing the floating point environment; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; Many targets allow floating point operations to be configured to control things; such as how inexact results should be rounded and how exceptional conditions; should be handled. This configuration is called the floating point environment.; C and C++ restrict access to the floating point environment by default, and the; compiler is allowed to assume that all operations are performed in the default; environment. When code is compiled in this default mode, operations that depend; on the environment (such as floating-point arithmetic and `FLT_ROUNDS`) may have; undefined behavior if the dynamic environment is not the default environment; for; example, `FLT_ROUNDS` may or may not simply return its default value for the target; instead of reading the dynamic environment, and floating-point operations may be; optimized as if the dynamic environment were the default. Similarly, it is undefined; behavior to change the floating point environment in this default mode, for example; by calling the `fesetround` function.; C provides two pragmas to allow code to dynamically modify the floating point environment:. - ``#pragma STDC FENV_ACCESS ON`` allows dynamic changes to the entire floating; point environment. - ``#pragma STDC FENV_ROUND FE_DYNAMIC`` allows dynamic changes to just the floating; point rounding mode. Thi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:69857,Performance,optimiz,optimized,69857,"aive mathematical formulas for complex; multiplication and enables application of Smith's algorithm for complex; division. See SMITH, R. L. Algorithm 116: Complex division. Commun.; ACM 5, 8 (1962). The default is ``-fno-cx-fortran-rules``. .. _floating-point-environment:. Accessing the floating point environment; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; Many targets allow floating point operations to be configured to control things; such as how inexact results should be rounded and how exceptional conditions; should be handled. This configuration is called the floating point environment.; C and C++ restrict access to the floating point environment by default, and the; compiler is allowed to assume that all operations are performed in the default; environment. When code is compiled in this default mode, operations that depend; on the environment (such as floating-point arithmetic and `FLT_ROUNDS`) may have; undefined behavior if the dynamic environment is not the default environment; for; example, `FLT_ROUNDS` may or may not simply return its default value for the target; instead of reading the dynamic environment, and floating-point operations may be; optimized as if the dynamic environment were the default. Similarly, it is undefined; behavior to change the floating point environment in this default mode, for example; by calling the `fesetround` function.; C provides two pragmas to allow code to dynamically modify the floating point environment:. - ``#pragma STDC FENV_ACCESS ON`` allows dynamic changes to the entire floating; point environment. - ``#pragma STDC FENV_ROUND FE_DYNAMIC`` allows dynamic changes to just the floating; point rounding mode. This may be more optimizable than ``FENV_ACCESS ON`` because; the compiler can still ignore the possibility of floating-point exceptions by default. Both of these can be used either at the start of a block scope, in which case; they cover all code in that scope (unless they're turned off in a child scope),; or at the ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:70383,Performance,optimiz,optimizable,70383,"ult; environment. When code is compiled in this default mode, operations that depend; on the environment (such as floating-point arithmetic and `FLT_ROUNDS`) may have; undefined behavior if the dynamic environment is not the default environment; for; example, `FLT_ROUNDS` may or may not simply return its default value for the target; instead of reading the dynamic environment, and floating-point operations may be; optimized as if the dynamic environment were the default. Similarly, it is undefined; behavior to change the floating point environment in this default mode, for example; by calling the `fesetround` function.; C provides two pragmas to allow code to dynamically modify the floating point environment:. - ``#pragma STDC FENV_ACCESS ON`` allows dynamic changes to the entire floating; point environment. - ``#pragma STDC FENV_ROUND FE_DYNAMIC`` allows dynamic changes to just the floating; point rounding mode. This may be more optimizable than ``FENV_ACCESS ON`` because; the compiler can still ignore the possibility of floating-point exceptions by default. Both of these can be used either at the start of a block scope, in which case; they cover all code in that scope (unless they're turned off in a child scope),; or at the top level in a file, in which case they cover all subsequent function; bodies until they're turned off. Note that it is undefined behavior to enter; code that is *not* covered by one of these pragmas from code that *is* covered; by one of these pragmas unless the floating point environment has been restored; to its default state. See the C standard for more information about these pragmas. The command line option ``-frounding-math`` behaves as if the translation unit; began with ``#pragma STDC FENV_ROUND FE_DYNAMIC``. The command line option; ``-ffp-model=strict`` behaves as if the translation unit began with ``#pragma STDC FENV_ACCESS ON``. Code that just wants to use a specific rounding mode for specific floating point; operations can avoid mo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:71698,Performance,optimiz,optimizations,71698,"t the top level in a file, in which case they cover all subsequent function; bodies until they're turned off. Note that it is undefined behavior to enter; code that is *not* covered by one of these pragmas from code that *is* covered; by one of these pragmas unless the floating point environment has been restored; to its default state. See the C standard for more information about these pragmas. The command line option ``-frounding-math`` behaves as if the translation unit; began with ``#pragma STDC FENV_ROUND FE_DYNAMIC``. The command line option; ``-ffp-model=strict`` behaves as if the translation unit began with ``#pragma STDC FENV_ACCESS ON``. Code that just wants to use a specific rounding mode for specific floating point; operations can avoid most of the hazards of the dynamic floating point environment; by using ``#pragma STDC FENV_ROUND`` with a value other than ``FE_DYNAMIC``. .. _crtfastmath.o:. A note about ``crtfastmath.o``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ``-ffast-math`` and ``-funsafe-math-optimizations`` cause ``crtfastmath.o`` to be; automatically linked, which adds a static constructor that sets the FTZ/DAZ; bits in MXCSR, affecting not only the current compilation unit but all static; and shared libraries included in the program. .. _FLT_EVAL_METHOD:. A note about ``__FLT_EVAL_METHOD__``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; The ``__FLT_EVAL_METHOD__`` is not defined as a traditional macro, and so it; will not appear when dumping preprocessor macros. Instead, the value; ``__FLT_EVAL_METHOD__`` expands to is determined at the point of expansion; either from the value set by the ``-ffp-eval-method`` command line option or; from the target. This is because the ``__FLT_EVAL_METHOD__`` macro; cannot expand to the correct evaluation method in the presence of a ``#pragma``; which alters the evaluation method. An error is issued if; ``__FLT_EVAL_METHOD__`` is expanded inside a scope modified by; ``#pragma clang fp eval_method``. .. _fp-constant-eval:. A no",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:73414,Performance,perform,perform,73414,"ion or; from the target. This is because the ``__FLT_EVAL_METHOD__`` macro; cannot expand to the correct evaluation method in the presence of a ``#pragma``; which alters the evaluation method. An error is issued if; ``__FLT_EVAL_METHOD__`` is expanded inside a scope modified by; ``#pragma clang fp eval_method``. .. _fp-constant-eval:. A note about Floating Point Constant Evaluation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. In C, the only place floating point operations are guaranteed to be evaluated; during translation is in the initializers of variables of static storage; duration, which are all notionally initialized before the program begins; executing (and thus before a non-default floating point environment can be; entered). But C++ has many more contexts where floating point constant; evaluation occurs. Specifically: for static/thread-local variables,; first try evaluating the initializer in a constant context, including in the; constant floating point environment (just like in C), and then, if that fails,; fall back to emitting runtime code to perform the initialization (which might; in general be in a different floating point environment). Consider this example when compiled with ``-frounding-math``. .. code-block:: console. constexpr float func_01(float x, float y) {; return x + y;; }; float V1 = func_01(1.0F, 0x0.000001p0F);. The C++ rule is that initializers for static storage duration variables are; first evaluated during translation (therefore, in the default rounding mode),; and only evaluated at runtime (and therefore in the runtime rounding mode) if; the compile-time evaluation fails. This is in line with the C rules;; C11 F.8.5 says: *All computation for automatic initialization is done (as if); at execution time; thus, it is affected by any operative modes and raises; floating-point exceptions as required by IEC 60559 (provided the state for the; FENV_ACCESS pragma is ‘‘on’’). All computation for initialization of objects; that have static o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:79155,Performance,perform,performance,79155,"a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sanitizers.; See :doc:`SanitizerCoverage` for more details. .. option:: -f[no-]sanitize-address-outline-instrumentation. Controls how address sanitizer code is generated. If enabled will always use; a function call instead of inlining the code. Turning this option on could; reduce the binary size, but might result in a worse run-time performance. See :doc: `AddressSanitizer` for more details. .. option:: -f[no-]sanitize-stats. Enable simple statistics gathering for the enabled sanitizers.; See :doc:`SanitizerStats` for more details. .. option:: -fsanitize-undefined-trap-on-error. Deprecated alias for ``-fsanitize-trap=undefined``. .. option:: -fsanitize-cfi-cross-dso. Enable cross-DSO control flow integrity checks. This flag modifies; the behavior of sanitizers in the ``cfi`` group to allow checking; of cross-DSO virtual and indirect calls. .. option:: -fsanitize-cfi-icall-generalize-pointers. Generalize pointers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more details. .. option:: -fsanitize-cfi-icall-experimental-normalize-integers. Normalize integers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. S",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:80249,Performance,optimiz,optimizations,80249,"r the enabled sanitizers.; See :doc:`SanitizerStats` for more details. .. option:: -fsanitize-undefined-trap-on-error. Deprecated alias for ``-fsanitize-trap=undefined``. .. option:: -fsanitize-cfi-cross-dso. Enable cross-DSO control flow integrity checks. This flag modifies; the behavior of sanitizers in the ``cfi`` group to allow checking; of cross-DSO virtual and indirect calls. .. option:: -fsanitize-cfi-icall-generalize-pointers. Generalize pointers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more details. .. option:: -fsanitize-cfi-icall-experimental-normalize-integers. Normalize integers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more details. This option is currently experimental. .. option:: -fstrict-vtable-pointers. Enable optimizations based on the strict rules for overwriting polymorphic; C++ objects, i.e. the vptr is invariant during an object's lifetime.; This enables better devirtualization. Turned off by default, because it is; still experimental. .. option:: -fwhole-program-vtables. Enable whole-program vtable optimizations, such as single-implementation; devirtualization and virtual constant propagation, for classes with; :doc:`hidden LTO visibility <LTOVisibility>`. Requires ``-flto``. .. option:: -f[no]split-lto-unit. Controls splitting the :doc:`LTO unit <LTOVisibility>` into regular LTO and; :doc:`ThinLTO` portions, when compiling with -flto=thin. Defaults to false; unless ``-fsanitize=cfi`` or ``-fwhole-program-vtables`` are specified, in; which case it defaults to true. Splitting is required with ``fsanitize=cfi``,; and it is an error to disable via ``-fno-split-lto-unit``. Splitting is; optional with ``-fwhole-program-vtables``, however, it enables more; aggressive whole program vtable optimizations (specifically virtual const",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:80549,Performance,optimiz,optimizations,80549," allow checking; of cross-DSO virtual and indirect calls. .. option:: -fsanitize-cfi-icall-generalize-pointers. Generalize pointers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more details. .. option:: -fsanitize-cfi-icall-experimental-normalize-integers. Normalize integers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more details. This option is currently experimental. .. option:: -fstrict-vtable-pointers. Enable optimizations based on the strict rules for overwriting polymorphic; C++ objects, i.e. the vptr is invariant during an object's lifetime.; This enables better devirtualization. Turned off by default, because it is; still experimental. .. option:: -fwhole-program-vtables. Enable whole-program vtable optimizations, such as single-implementation; devirtualization and virtual constant propagation, for classes with; :doc:`hidden LTO visibility <LTOVisibility>`. Requires ``-flto``. .. option:: -f[no]split-lto-unit. Controls splitting the :doc:`LTO unit <LTOVisibility>` into regular LTO and; :doc:`ThinLTO` portions, when compiling with -flto=thin. Defaults to false; unless ``-fsanitize=cfi`` or ``-fwhole-program-vtables`` are specified, in; which case it defaults to true. Splitting is required with ``fsanitize=cfi``,; and it is an error to disable via ``-fno-split-lto-unit``. Splitting is; optional with ``-fwhole-program-vtables``, however, it enables more; aggressive whole program vtable optimizations (specifically virtual constant; propagation). When enabled, vtable definitions and select virtual functions are placed; in the split regular LTO module, enabling more aggressive whole program; vtable optimizations required for CFI and virtual constant propagation.; However, this can increase the LTO link time and memory requirements over; pure ThinLTO, ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:81246,Performance,optimiz,optimizations,81246,"fstrict-vtable-pointers. Enable optimizations based on the strict rules for overwriting polymorphic; C++ objects, i.e. the vptr is invariant during an object's lifetime.; This enables better devirtualization. Turned off by default, because it is; still experimental. .. option:: -fwhole-program-vtables. Enable whole-program vtable optimizations, such as single-implementation; devirtualization and virtual constant propagation, for classes with; :doc:`hidden LTO visibility <LTOVisibility>`. Requires ``-flto``. .. option:: -f[no]split-lto-unit. Controls splitting the :doc:`LTO unit <LTOVisibility>` into regular LTO and; :doc:`ThinLTO` portions, when compiling with -flto=thin. Defaults to false; unless ``-fsanitize=cfi`` or ``-fwhole-program-vtables`` are specified, in; which case it defaults to true. Splitting is required with ``fsanitize=cfi``,; and it is an error to disable via ``-fno-split-lto-unit``. Splitting is; optional with ``-fwhole-program-vtables``, however, it enables more; aggressive whole program vtable optimizations (specifically virtual constant; propagation). When enabled, vtable definitions and select virtual functions are placed; in the split regular LTO module, enabling more aggressive whole program; vtable optimizations required for CFI and virtual constant propagation.; However, this can increase the LTO link time and memory requirements over; pure ThinLTO, as all split regular LTO modules are merged and LTO linked; with regular LTO. .. option:: -fforce-emit-vtables. In order to improve devirtualization, forces emitting of vtables even in; modules where it isn't necessary. It causes more inline virtual functions; to be emitted. .. option:: -fno-assume-sane-operator-new. Don't assume that the C++'s new operator is sane. This option tells the compiler to do not assume that C++'s global; new operator will always return a pointer that does not alias any; other pointer when the function returns. .. option:: -fassume-nothrow-exception-dtor. Assume that an",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:81460,Performance,optimiz,optimizations,81460,"ualization. Turned off by default, because it is; still experimental. .. option:: -fwhole-program-vtables. Enable whole-program vtable optimizations, such as single-implementation; devirtualization and virtual constant propagation, for classes with; :doc:`hidden LTO visibility <LTOVisibility>`. Requires ``-flto``. .. option:: -f[no]split-lto-unit. Controls splitting the :doc:`LTO unit <LTOVisibility>` into regular LTO and; :doc:`ThinLTO` portions, when compiling with -flto=thin. Defaults to false; unless ``-fsanitize=cfi`` or ``-fwhole-program-vtables`` are specified, in; which case it defaults to true. Splitting is required with ``fsanitize=cfi``,; and it is an error to disable via ``-fno-split-lto-unit``. Splitting is; optional with ``-fwhole-program-vtables``, however, it enables more; aggressive whole program vtable optimizations (specifically virtual constant; propagation). When enabled, vtable definitions and select virtual functions are placed; in the split regular LTO module, enabling more aggressive whole program; vtable optimizations required for CFI and virtual constant propagation.; However, this can increase the LTO link time and memory requirements over; pure ThinLTO, as all split regular LTO modules are merged and LTO linked; with regular LTO. .. option:: -fforce-emit-vtables. In order to improve devirtualization, forces emitting of vtables even in; modules where it isn't necessary. It causes more inline virtual functions; to be emitted. .. option:: -fno-assume-sane-operator-new. Don't assume that the C++'s new operator is sane. This option tells the compiler to do not assume that C++'s global; new operator will always return a pointer that does not alias any; other pointer when the function returns. .. option:: -fassume-nothrow-exception-dtor. Assume that an exception object' destructor will not throw, and generate; less code for catch handlers. A throw expression of a type with a; potentially-throwing destructor will lead to an error. By default, Cla",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:89483,Performance,optimiz,optimizations,89483,"ap`` section is emitted which includes address; offsets for each basic block in the program, relative to the parent function; address. With the ``list=<arg>`` option, a file containing the subset of basic blocks; that need to placed in unique sections can be specified. The format of the; file is as follows. For example, ``list=spec.txt`` where ``spec.txt`` is the; following:. ::. !foo; !!2; !_Z3barv. will place the machine basic block with ``id 2`` in function ``foo`` in a; unique section. It will also place all basic blocks of functions ``bar``; in unique sections. Further, section clusters can also be specified using the ``list=<arg>``; option. For example, ``list=spec.txt`` where ``spec.txt`` contains:. ::. !foo; !!1 !!3 !!5; !!2 !!4 !!6. will create two unique sections for function ``foo`` with the first; containing the odd numbered basic blocks and the second containing the; even numbered basic blocks. Basic block sections allow the linker to reorder basic blocks and enables; link-time optimizations like whole program inter-procedural basic block; reordering. Profile Guided Optimization; ---------------------------. Profile information enables better optimization. For example, knowing that a; branch is taken very frequently helps the compiler make better decisions when; ordering basic blocks. Knowing that a function ``foo`` is called more; frequently than another function ``bar`` helps the inliner. Optimization; levels ``-O2`` and above are recommended for use of profile guided optimization. Clang supports profile guided optimization with two different kinds of; profiling. A sampling profiler can generate a profile with very low runtime; overhead, or you can build an instrumented version of the code that collects; more detailed profile information. Both kinds of profiles can provide execution; counts for instructions in the code and information on branches taken and; function invocation. Regardless of which kind of profiling you use, be careful to collect profi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:89651,Performance,optimiz,optimization,89651,"ion, a file containing the subset of basic blocks; that need to placed in unique sections can be specified. The format of the; file is as follows. For example, ``list=spec.txt`` where ``spec.txt`` is the; following:. ::. !foo; !!2; !_Z3barv. will place the machine basic block with ``id 2`` in function ``foo`` in a; unique section. It will also place all basic blocks of functions ``bar``; in unique sections. Further, section clusters can also be specified using the ``list=<arg>``; option. For example, ``list=spec.txt`` where ``spec.txt`` contains:. ::. !foo; !!1 !!3 !!5; !!2 !!4 !!6. will create two unique sections for function ``foo`` with the first; containing the odd numbered basic blocks and the second containing the; even numbered basic blocks. Basic block sections allow the linker to reorder basic blocks and enables; link-time optimizations like whole program inter-procedural basic block; reordering. Profile Guided Optimization; ---------------------------. Profile information enables better optimization. For example, knowing that a; branch is taken very frequently helps the compiler make better decisions when; ordering basic blocks. Knowing that a function ``foo`` is called more; frequently than another function ``bar`` helps the inliner. Optimization; levels ``-O2`` and above are recommended for use of profile guided optimization. Clang supports profile guided optimization with two different kinds of; profiling. A sampling profiler can generate a profile with very low runtime; overhead, or you can build an instrumented version of the code that collects; more detailed profile information. Both kinds of profiles can provide execution; counts for instructions in the code and information on branches taken and; function invocation. Regardless of which kind of profiling you use, be careful to collect profiles; by running your code with inputs that are representative of the typical; behavior. Code that is not exercised in the profile will be optimized as if it; is un",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:89985,Performance,optimiz,optimization,89985,"in a; unique section. It will also place all basic blocks of functions ``bar``; in unique sections. Further, section clusters can also be specified using the ``list=<arg>``; option. For example, ``list=spec.txt`` where ``spec.txt`` contains:. ::. !foo; !!1 !!3 !!5; !!2 !!4 !!6. will create two unique sections for function ``foo`` with the first; containing the odd numbered basic blocks and the second containing the; even numbered basic blocks. Basic block sections allow the linker to reorder basic blocks and enables; link-time optimizations like whole program inter-procedural basic block; reordering. Profile Guided Optimization; ---------------------------. Profile information enables better optimization. For example, knowing that a; branch is taken very frequently helps the compiler make better decisions when; ordering basic blocks. Knowing that a function ``foo`` is called more; frequently than another function ``bar`` helps the inliner. Optimization; levels ``-O2`` and above are recommended for use of profile guided optimization. Clang supports profile guided optimization with two different kinds of; profiling. A sampling profiler can generate a profile with very low runtime; overhead, or you can build an instrumented version of the code that collects; more detailed profile information. Both kinds of profiles can provide execution; counts for instructions in the code and information on branches taken and; function invocation. Regardless of which kind of profiling you use, be careful to collect profiles; by running your code with inputs that are representative of the typical; behavior. Code that is not exercised in the profile will be optimized as if it; is unimportant, and the compiler may make poor optimization choices for code; that is disproportionately used while profiling. Differences Between Sampling and Instrumentation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Although both techniques are used for similar purposes, there are important; differences ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:90029,Performance,optimiz,optimization,90029," sections. Further, section clusters can also be specified using the ``list=<arg>``; option. For example, ``list=spec.txt`` where ``spec.txt`` contains:. ::. !foo; !!1 !!3 !!5; !!2 !!4 !!6. will create two unique sections for function ``foo`` with the first; containing the odd numbered basic blocks and the second containing the; even numbered basic blocks. Basic block sections allow the linker to reorder basic blocks and enables; link-time optimizations like whole program inter-procedural basic block; reordering. Profile Guided Optimization; ---------------------------. Profile information enables better optimization. For example, knowing that a; branch is taken very frequently helps the compiler make better decisions when; ordering basic blocks. Knowing that a function ``foo`` is called more; frequently than another function ``bar`` helps the inliner. Optimization; levels ``-O2`` and above are recommended for use of profile guided optimization. Clang supports profile guided optimization with two different kinds of; profiling. A sampling profiler can generate a profile with very low runtime; overhead, or you can build an instrumented version of the code that collects; more detailed profile information. Both kinds of profiles can provide execution; counts for instructions in the code and information on branches taken and; function invocation. Regardless of which kind of profiling you use, be careful to collect profiles; by running your code with inputs that are representative of the typical; behavior. Code that is not exercised in the profile will be optimized as if it; is unimportant, and the compiler may make poor optimization choices for code; that is disproportionately used while profiling. Differences Between Sampling and Instrumentation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Although both techniques are used for similar purposes, there are important; differences between the two:. 1. Profile data generated with one cannot be used by the other, and the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:90615,Performance,optimiz,optimized,90615,"n. For example, knowing that a; branch is taken very frequently helps the compiler make better decisions when; ordering basic blocks. Knowing that a function ``foo`` is called more; frequently than another function ``bar`` helps the inliner. Optimization; levels ``-O2`` and above are recommended for use of profile guided optimization. Clang supports profile guided optimization with two different kinds of; profiling. A sampling profiler can generate a profile with very low runtime; overhead, or you can build an instrumented version of the code that collects; more detailed profile information. Both kinds of profiles can provide execution; counts for instructions in the code and information on branches taken and; function invocation. Regardless of which kind of profiling you use, be careful to collect profiles; by running your code with inputs that are representative of the typical; behavior. Code that is not exercised in the profile will be optimized as if it; is unimportant, and the compiler may make poor optimization choices for code; that is disproportionately used while profiling. Differences Between Sampling and Instrumentation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Although both techniques are used for similar purposes, there are important; differences between the two:. 1. Profile data generated with one cannot be used by the other, and there is no; conversion tool that can convert one to the other. So, a profile generated; via ``-fprofile-generate`` or ``-fprofile-instr-generate`` must be used with; ``-fprofile-use`` or ``-fprofile-instr-use``. Similarly, sampling profiles; generated by external profilers must be converted and used with ``-fprofile-sample-use``; or ``-fauto-profile``. 2. Instrumentation profile data can be used for code coverage analysis and; optimization. 3. Sampling profiles can only be used for optimization. They cannot be used for; code coverage analysis. Although it would be technically possible to use; sampling profiles for cod",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:90682,Performance,optimiz,optimization,90682,"n. For example, knowing that a; branch is taken very frequently helps the compiler make better decisions when; ordering basic blocks. Knowing that a function ``foo`` is called more; frequently than another function ``bar`` helps the inliner. Optimization; levels ``-O2`` and above are recommended for use of profile guided optimization. Clang supports profile guided optimization with two different kinds of; profiling. A sampling profiler can generate a profile with very low runtime; overhead, or you can build an instrumented version of the code that collects; more detailed profile information. Both kinds of profiles can provide execution; counts for instructions in the code and information on branches taken and; function invocation. Regardless of which kind of profiling you use, be careful to collect profiles; by running your code with inputs that are representative of the typical; behavior. Code that is not exercised in the profile will be optimized as if it; is unimportant, and the compiler may make poor optimization choices for code; that is disproportionately used while profiling. Differences Between Sampling and Instrumentation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Although both techniques are used for similar purposes, there are important; differences between the two:. 1. Profile data generated with one cannot be used by the other, and there is no; conversion tool that can convert one to the other. So, a profile generated; via ``-fprofile-generate`` or ``-fprofile-instr-generate`` must be used with; ``-fprofile-use`` or ``-fprofile-instr-use``. Similarly, sampling profiles; generated by external profilers must be converted and used with ``-fprofile-sample-use``; or ``-fauto-profile``. 2. Instrumentation profile data can be used for code coverage analysis and; optimization. 3. Sampling profiles can only be used for optimization. They cannot be used for; code coverage analysis. Although it would be technically possible to use; sampling profiles for cod",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:91469,Performance,optimiz,optimization,91469,"ng you use, be careful to collect profiles; by running your code with inputs that are representative of the typical; behavior. Code that is not exercised in the profile will be optimized as if it; is unimportant, and the compiler may make poor optimization choices for code; that is disproportionately used while profiling. Differences Between Sampling and Instrumentation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Although both techniques are used for similar purposes, there are important; differences between the two:. 1. Profile data generated with one cannot be used by the other, and there is no; conversion tool that can convert one to the other. So, a profile generated; via ``-fprofile-generate`` or ``-fprofile-instr-generate`` must be used with; ``-fprofile-use`` or ``-fprofile-instr-use``. Similarly, sampling profiles; generated by external profilers must be converted and used with ``-fprofile-sample-use``; or ``-fauto-profile``. 2. Instrumentation profile data can be used for code coverage analysis and; optimization. 3. Sampling profiles can only be used for optimization. They cannot be used for; code coverage analysis. Although it would be technically possible to use; sampling profiles for code coverage, sample-based profiles are too; coarse-grained for code coverage purposes; it would yield poor results. 4. Sampling profiles must be generated by an external tool. The profile; generated by that tool must then be converted into a format that can be read; by LLVM. The section on sampling profilers describes one of the supported; sampling profile formats. Using Sampling Profilers; ^^^^^^^^^^^^^^^^^^^^^^^^. Sampling profilers are used to collect runtime information, such as; hardware counters, while your application executes. They are typically; very efficient and do not incur a large runtime overhead. The; sample data collected by the profiler can be used during compilation; to determine what the most executed areas of the code are. Using the data from a sa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:91525,Performance,optimiz,optimization,91525,"uts that are representative of the typical; behavior. Code that is not exercised in the profile will be optimized as if it; is unimportant, and the compiler may make poor optimization choices for code; that is disproportionately used while profiling. Differences Between Sampling and Instrumentation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Although both techniques are used for similar purposes, there are important; differences between the two:. 1. Profile data generated with one cannot be used by the other, and there is no; conversion tool that can convert one to the other. So, a profile generated; via ``-fprofile-generate`` or ``-fprofile-instr-generate`` must be used with; ``-fprofile-use`` or ``-fprofile-instr-use``. Similarly, sampling profiles; generated by external profilers must be converted and used with ``-fprofile-sample-use``; or ``-fauto-profile``. 2. Instrumentation profile data can be used for code coverage analysis and; optimization. 3. Sampling profiles can only be used for optimization. They cannot be used for; code coverage analysis. Although it would be technically possible to use; sampling profiles for code coverage, sample-based profiles are too; coarse-grained for code coverage purposes; it would yield poor results. 4. Sampling profiles must be generated by an external tool. The profile; generated by that tool must then be converted into a format that can be read; by LLVM. The section on sampling profilers describes one of the supported; sampling profile formats. Using Sampling Profilers; ^^^^^^^^^^^^^^^^^^^^^^^^. Sampling profilers are used to collect runtime information, such as; hardware counters, while your application executes. They are typically; very efficient and do not incur a large runtime overhead. The; sample data collected by the profiler can be used during compilation; to determine what the most executed areas of the code are. Using the data from a sample profiler requires some changes in the way; a program is built. Befor",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:92677,Performance,optimiz,optimization,92677,"profiles for code coverage, sample-based profiles are too; coarse-grained for code coverage purposes; it would yield poor results. 4. Sampling profiles must be generated by an external tool. The profile; generated by that tool must then be converted into a format that can be read; by LLVM. The section on sampling profilers describes one of the supported; sampling profile formats. Using Sampling Profilers; ^^^^^^^^^^^^^^^^^^^^^^^^. Sampling profilers are used to collect runtime information, such as; hardware counters, while your application executes. They are typically; very efficient and do not incur a large runtime overhead. The; sample data collected by the profiler can be used during compilation; to determine what the most executed areas of the code are. Using the data from a sample profiler requires some changes in the way; a program is built. Before the compiler can use profiling information,; the code needs to execute under the profiler. The following is the; usual build cycle when using sample profilers for optimization:. 1. Build the code with source line table information. You can use all the; usual build flags that you always build your application with. The only; requirement is that you add ``-gline-tables-only`` or ``-g`` to the; command line. This is important for the profiler to be able to map; instructions back to source line locations. .. code-block:: console. $ clang++ -O2 -gline-tables-only code.cc -o code. 2. Run the executable under a sampling profiler. The specific profiler; you use does not really matter, as long as its output can be converted; into the format that the LLVM optimizer understands. Currently, there; exists a conversion tool for the Linux Perf profiler; (https://perf.wiki.kernel.org/), so these examples assume that you; are using Linux Perf to profile your code. .. code-block:: console. $ perf record -b ./code. Note the use of the ``-b`` flag. This tells Perf to use the Last Branch; Record (LBR) to record call chains. While this is",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:93270,Performance,optimiz,optimizer,93270,"lly; very efficient and do not incur a large runtime overhead. The; sample data collected by the profiler can be used during compilation; to determine what the most executed areas of the code are. Using the data from a sample profiler requires some changes in the way; a program is built. Before the compiler can use profiling information,; the code needs to execute under the profiler. The following is the; usual build cycle when using sample profilers for optimization:. 1. Build the code with source line table information. You can use all the; usual build flags that you always build your application with. The only; requirement is that you add ``-gline-tables-only`` or ``-g`` to the; command line. This is important for the profiler to be able to map; instructions back to source line locations. .. code-block:: console. $ clang++ -O2 -gline-tables-only code.cc -o code. 2. Run the executable under a sampling profiler. The specific profiler; you use does not really matter, as long as its output can be converted; into the format that the LLVM optimizer understands. Currently, there; exists a conversion tool for the Linux Perf profiler; (https://perf.wiki.kernel.org/), so these examples assume that you; are using Linux Perf to profile your code. .. code-block:: console. $ perf record -b ./code. Note the use of the ``-b`` flag. This tells Perf to use the Last Branch; Record (LBR) to record call chains. While this is not strictly required,; it provides better call information, which improves the accuracy of; the profile data. 3. Convert the collected profile data to LLVM's sample profile format.; This is currently supported via the AutoFDO converter ``create_llvm_prof``.; It is available at https://github.com/google/autofdo. Once built and; installed, you can convert the ``perf.data`` file to LLVM using; the command:. .. code-block:: console. $ create_llvm_prof --binary=./code --out=code.prof. This will read ``perf.data`` and the binary file ``./code`` and emit; the profile d",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:94660,Performance,optimiz,optimizers,94660,"s is not strictly required,; it provides better call information, which improves the accuracy of; the profile data. 3. Convert the collected profile data to LLVM's sample profile format.; This is currently supported via the AutoFDO converter ``create_llvm_prof``.; It is available at https://github.com/google/autofdo. Once built and; installed, you can convert the ``perf.data`` file to LLVM using; the command:. .. code-block:: console. $ create_llvm_prof --binary=./code --out=code.prof. This will read ``perf.data`` and the binary file ``./code`` and emit; the profile data in ``code.prof``. Note that if you ran ``perf``; without the ``-b`` flag, you need to use ``--use_lbr=false`` when; calling ``create_llvm_prof``. Alternatively, the LLVM tool ``llvm-profgen`` can also be used to generate; the LLVM sample profile:. .. code-block:: console. $ llvm-profgen --binary=./code --output=code.prof--perfdata=perf.data. 4. Build the code again using the collected profile. This step feeds; the profile back to the optimizers. This should result in a binary; that executes faster than the original one. Note that you are not; required to build the code with the exact same arguments that you; used in the first step. The only requirement is that you build the code; with ``-gline-tables-only`` and ``-fprofile-sample-use``. .. code-block:: console. $ clang++ -O2 -gline-tables-only -fprofile-sample-use=code.prof code.cc -o code. [OPTIONAL] Sampling-based profiles can have inaccuracies or missing block/; edge counters. The profile inference algorithm (profi) can be used to infer; missing blocks and edge counts, and improve the quality of profile data.; Enable it with ``-fsample-profile-use-profi``. .. code-block:: console. $ clang++ -O2 -gline-tables-only -fprofile-sample-use=code.prof \; -fsample-profile-use-profi code.cc -o code. Sample Profile Formats; """""""""""""""""""""""""""""""""""""""""""". Since external profilers generate profile data in a variety of custom formats,; the data generated by the profil",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:98404,Performance,load,loader,98404,"...; offsetN[.discriminator]: number_of_samples [fn5:num fn6:num ... ]; offsetA[.discriminator]: fnA:num_of_total_samples; offsetA1[.discriminator]: number_of_samples [fn7:num fn8:num ... ]; offsetA1[.discriminator]: number_of_samples [fn9:num fn10:num ... ]; offsetB[.discriminator]: fnB:num_of_total_samples; offsetB1[.discriminator]: number_of_samples [fn11:num fn12:num ... ]. This is a nested tree in which the indentation represents the nesting level; of the inline stack. There are no blank lines in the file. And the spacing; within a single line is fixed. Additional spaces will result in an error; while reading the file. Any line starting with the '#' character is completely ignored. Inlined calls are represented with indentation. The Inline stack is a; stack of source locations in which the top of the stack represents the; leaf function, and the bottom of the stack represents the actual; symbol to which the instruction belongs. Function names must be mangled in order for the profile loader to; match them in the current translation unit. The two numbers in the; function header specify how many total samples were accumulated in the; function (first number), and the total number of samples accumulated; in the prologue of the function (second number). This head sample; count provides an indicator of how frequently the function is invoked. There are two types of lines in the function body. - Sampled line represents the profile information of a source location.; ``offsetN[.discriminator]: number_of_samples [fn5:num fn6:num ... ]``. - Callsite line represents the profile information of an inlined callsite.; ``offsetA[.discriminator]: fnA:num_of_total_samples``. Each sampled line may contain several items. Some are optional (marked; below):. a. Source line offset. This number represents the line number; in the function where the sample was collected. The line number is; always relative to the line where symbol of the function is; defined. So, if the function has its head",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:99793,Performance,optimiz,optimizers,99793,"re are two types of lines in the function body. - Sampled line represents the profile information of a source location.; ``offsetN[.discriminator]: number_of_samples [fn5:num fn6:num ... ]``. - Callsite line represents the profile information of an inlined callsite.; ``offsetA[.discriminator]: fnA:num_of_total_samples``. Each sampled line may contain several items. Some are optional (marked; below):. a. Source line offset. This number represents the line number; in the function where the sample was collected. The line number is; always relative to the line where symbol of the function is; defined. So, if the function has its header at line 280, the offset; 13 is at line 293 in the file. Note that this offset should never be a negative number. This could; happen in cases like macros. The debug machinery will register the; line number at the point of macro expansion. So, if the macro was; expanded in a line before the start of the function, the profile; converter should emit a 0 as the offset (this means that the optimizers; will not be able to associate a meaningful weight to the instructions; in the macro). b. [OPTIONAL] Discriminator. This is used if the sampled program; was compiled with DWARF discriminator support; (http://wiki.dwarfstd.org/index.php?title=Path_Discriminators).; DWARF discriminators are unsigned integer values that allow the; compiler to distinguish between multiple execution paths on the; same source line location. For example, consider the line of code ``if (cond) foo(); else bar();``.; If the predicate ``cond`` is true 80% of the time, then the edge; into function ``foo`` should be considered to be taken most of the; time. But both calls to ``foo`` and ``bar`` are at the same source; line, so a sample count at that line is not sufficient. The; compiler needs to know which part of that line is taken more; frequently. This is what discriminators provide. In this case, the calls to; ``foo`` and ``bar`` will be at the same line, but will have; diff",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:101525,Performance,optimiz,optimizations,101525,"ompiler needs to know which part of that line is taken more; frequently. This is what discriminators provide. In this case, the calls to; ``foo`` and ``bar`` will be at the same line, but will have; different discriminator values. This allows the compiler to correctly; set edge weights into ``foo`` and ``bar``. c. Number of samples. This is an integer quantity representing the; number of samples collected by the profiler at this source; location. d. [OPTIONAL] Potential call targets and samples. If present, this; line contains a call instruction. This models both direct and; number of samples. For example,. .. code-block:: console. 130: 7 foo:3 bar:2 baz:7. The above means that at relative line offset 130 there is a call; instruction that calls one of ``foo()``, ``bar()`` and ``baz()``,; with ``baz()`` being the relatively more frequently called target. As an example, consider a program with the call chain ``main -> foo -> bar``.; When built with optimizations enabled, the compiler may inline the; calls to ``bar`` and ``foo`` inside ``main``. The generated profile; could then be something like this:. .. code-block:: console. main:35504:0; 1: _Z3foov:35504; 2: _Z32bari:31977; 1.1: 31977; 2: 0. This profile indicates that there were a total of 35,504 samples; collected in main. All of those were at line 1 (the call to ``foo``).; Of those, 31,977 were spent inside the body of ``bar``. The last line; of the profile (``2: 0``) corresponds to line 2 inside ``main``. No; samples were collected there. .. _prof_instr:. Profiling with Instrumentation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Clang also supports profiling via instrumentation. This requires building a; special instrumented version of the code and has some runtime; overhead during the profiling, but it provides more detailed results than a; sampling profiler. It also provides reproducible results, at least to the; extent that the code behaves consistently across runs. Clang supports two types of instrumentation: frontend-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:102773,Performance,perform,performance,102773," that there were a total of 35,504 samples; collected in main. All of those were at line 1 (the call to ``foo``).; Of those, 31,977 were spent inside the body of ``bar``. The last line; of the profile (``2: 0``) corresponds to line 2 inside ``main``. No; samples were collected there. .. _prof_instr:. Profiling with Instrumentation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Clang also supports profiling via instrumentation. This requires building a; special instrumented version of the code and has some runtime; overhead during the profiling, but it provides more detailed results than a; sampling profiler. It also provides reproducible results, at least to the; extent that the code behaves consistently across runs. Clang supports two types of instrumentation: frontend-based and IR-based.; Frontend-based instrumentation can be enabled with the option ``-fprofile-instr-generate``,; and IR-based instrumentation can be enabled with the option ``-fprofile-generate``.; For best performance with PGO, IR-based instrumentation should be used. It has; the benefits of lower instrumentation overhead, smaller raw profile size, and; better runtime performance. Frontend-based instrumentation, on the other hand,; has better source correlation, so it should be used with source line-based; coverage testing. The flag ``-fcs-profile-generate`` also instruments programs using the same; instrumentation method as ``-fprofile-generate``. However, it performs a; post-inline late instrumentation and can produce context-sensitive profiles. Here are the steps for using profile guided optimization with; instrumentation:. 1. Build an instrumented version of the code by compiling and linking with the; ``-fprofile-generate`` or ``-fprofile-instr-generate`` option. .. code-block:: console. $ clang++ -O2 -fprofile-instr-generate code.cc -o code. 2. Run the instrumented executable with inputs that reflect the typical usage.; By default, the profile data will be written to a ``default.profraw`` file; in the curren",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:102938,Performance,perform,performance,102938,"e call to ``foo``).; Of those, 31,977 were spent inside the body of ``bar``. The last line; of the profile (``2: 0``) corresponds to line 2 inside ``main``. No; samples were collected there. .. _prof_instr:. Profiling with Instrumentation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Clang also supports profiling via instrumentation. This requires building a; special instrumented version of the code and has some runtime; overhead during the profiling, but it provides more detailed results than a; sampling profiler. It also provides reproducible results, at least to the; extent that the code behaves consistently across runs. Clang supports two types of instrumentation: frontend-based and IR-based.; Frontend-based instrumentation can be enabled with the option ``-fprofile-instr-generate``,; and IR-based instrumentation can be enabled with the option ``-fprofile-generate``.; For best performance with PGO, IR-based instrumentation should be used. It has; the benefits of lower instrumentation overhead, smaller raw profile size, and; better runtime performance. Frontend-based instrumentation, on the other hand,; has better source correlation, so it should be used with source line-based; coverage testing. The flag ``-fcs-profile-generate`` also instruments programs using the same; instrumentation method as ``-fprofile-generate``. However, it performs a; post-inline late instrumentation and can produce context-sensitive profiles. Here are the steps for using profile guided optimization with; instrumentation:. 1. Build an instrumented version of the code by compiling and linking with the; ``-fprofile-generate`` or ``-fprofile-instr-generate`` option. .. code-block:: console. $ clang++ -O2 -fprofile-instr-generate code.cc -o code. 2. Run the instrumented executable with inputs that reflect the typical usage.; By default, the profile data will be written to a ``default.profraw`` file; in the current directory. You can override that default by using option; ``-fprofile-instr-generate=`` or b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:103236,Performance,perform,performs,103236,"the code and has some runtime; overhead during the profiling, but it provides more detailed results than a; sampling profiler. It also provides reproducible results, at least to the; extent that the code behaves consistently across runs. Clang supports two types of instrumentation: frontend-based and IR-based.; Frontend-based instrumentation can be enabled with the option ``-fprofile-instr-generate``,; and IR-based instrumentation can be enabled with the option ``-fprofile-generate``.; For best performance with PGO, IR-based instrumentation should be used. It has; the benefits of lower instrumentation overhead, smaller raw profile size, and; better runtime performance. Frontend-based instrumentation, on the other hand,; has better source correlation, so it should be used with source line-based; coverage testing. The flag ``-fcs-profile-generate`` also instruments programs using the same; instrumentation method as ``-fprofile-generate``. However, it performs a; post-inline late instrumentation and can produce context-sensitive profiles. Here are the steps for using profile guided optimization with; instrumentation:. 1. Build an instrumented version of the code by compiling and linking with the; ``-fprofile-generate`` or ``-fprofile-instr-generate`` option. .. code-block:: console. $ clang++ -O2 -fprofile-instr-generate code.cc -o code. 2. Run the instrumented executable with inputs that reflect the typical usage.; By default, the profile data will be written to a ``default.profraw`` file; in the current directory. You can override that default by using option; ``-fprofile-instr-generate=`` or by setting the ``LLVM_PROFILE_FILE``; environment variable to specify an alternate file. If non-default file name; is specified by both the environment variable and the command line option,; the environment variable takes precedence. The file name pattern specified; can include different modifiers: ``%p``, ``%h``, ``%m``, ``%t``, and ``%c``. Any instance of ``%p`` in that file na",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:103369,Performance,optimiz,optimization,103369," results than a; sampling profiler. It also provides reproducible results, at least to the; extent that the code behaves consistently across runs. Clang supports two types of instrumentation: frontend-based and IR-based.; Frontend-based instrumentation can be enabled with the option ``-fprofile-instr-generate``,; and IR-based instrumentation can be enabled with the option ``-fprofile-generate``.; For best performance with PGO, IR-based instrumentation should be used. It has; the benefits of lower instrumentation overhead, smaller raw profile size, and; better runtime performance. Frontend-based instrumentation, on the other hand,; has better source correlation, so it should be used with source line-based; coverage testing. The flag ``-fcs-profile-generate`` also instruments programs using the same; instrumentation method as ``-fprofile-generate``. However, it performs a; post-inline late instrumentation and can produce context-sensitive profiles. Here are the steps for using profile guided optimization with; instrumentation:. 1. Build an instrumented version of the code by compiling and linking with the; ``-fprofile-generate`` or ``-fprofile-instr-generate`` option. .. code-block:: console. $ clang++ -O2 -fprofile-instr-generate code.cc -o code. 2. Run the instrumented executable with inputs that reflect the typical usage.; By default, the profile data will be written to a ``default.profraw`` file; in the current directory. You can override that default by using option; ``-fprofile-instr-generate=`` or by setting the ``LLVM_PROFILE_FILE``; environment variable to specify an alternate file. If non-default file name; is specified by both the environment variable and the command line option,; the environment variable takes precedence. The file name pattern specified; can include different modifiers: ``%p``, ``%h``, ``%m``, ``%t``, and ``%c``. Any instance of ``%p`` in that file name will be replaced by the process; ID, so that you can easily distinguish the profile outp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:109076,Performance,perform,performed,109076," the file; ``yyy/zzz/default_xxxx.profraw``. To generate the profile data file with the compiler readable format, the; ``llvm-profdata`` tool can be used with the profile directory as the input:. .. code-block:: console. $ llvm-profdata merge -output=code.profdata yyy/zzz/. If the user wants to turn off the auto-merging feature, or simply override the; the profile dumping path specified at command line, the environment variable; ``LLVM_PROFILE_FILE`` can still be used to override; the directory and filename for the profile file at runtime.; To override the path and filename at compile time, use; ``-Xclang -fprofile-instrument-path=/path/to/file_pattern.profraw``. .. option:: -fcs-profile-generate[=<dirname>]. The ``-fcs-profile-generate`` and ``-fcs-profile-generate=`` flags will use; the same instrumentation method, and generate the same profile as in the; ``-fprofile-generate`` and ``-fprofile-generate=`` flags. The difference is; that the instrumentation is performed after inlining so that the resulted; profile has a better context sensitive information. They cannot be used; together with ``-fprofile-generate`` and ``-fprofile-generate=`` flags.; They are typically used in conjunction with ``-fprofile-use`` flag.; The profile generated by ``-fcs-profile-generate`` and ``-fprofile-generate``; can be merged by llvm-profdata. A use example:. .. code-block:: console. $ clang++ -O2 -fprofile-generate=yyy/zzz code.cc -o code; $ ./code; $ llvm-profdata merge -output=code.profdata yyy/zzz/. The first few steps are the same as that in ``-fprofile-generate``; compilation. Then perform a second round of instrumentation. .. code-block:: console. $ clang++ -O2 -fprofile-use=code.profdata -fcs-profile-generate=sss/ttt \; -o cs_code; $ ./cs_code; $ llvm-profdata merge -output=cs_code.profdata sss/ttt code.profdata. The resulted ``cs_code.prodata`` combines ``code.profdata`` and the profile; generated from binary ``cs_code``. Profile ``cs_code.profata`` can be used by; ``-fprofi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:109698,Performance,perform,perform,109698,"profile-instrument-path=/path/to/file_pattern.profraw``. .. option:: -fcs-profile-generate[=<dirname>]. The ``-fcs-profile-generate`` and ``-fcs-profile-generate=`` flags will use; the same instrumentation method, and generate the same profile as in the; ``-fprofile-generate`` and ``-fprofile-generate=`` flags. The difference is; that the instrumentation is performed after inlining so that the resulted; profile has a better context sensitive information. They cannot be used; together with ``-fprofile-generate`` and ``-fprofile-generate=`` flags.; They are typically used in conjunction with ``-fprofile-use`` flag.; The profile generated by ``-fcs-profile-generate`` and ``-fprofile-generate``; can be merged by llvm-profdata. A use example:. .. code-block:: console. $ clang++ -O2 -fprofile-generate=yyy/zzz code.cc -o code; $ ./code; $ llvm-profdata merge -output=code.profdata yyy/zzz/. The first few steps are the same as that in ``-fprofile-generate``; compilation. Then perform a second round of instrumentation. .. code-block:: console. $ clang++ -O2 -fprofile-use=code.profdata -fcs-profile-generate=sss/ttt \; -o cs_code; $ ./cs_code; $ llvm-profdata merge -output=cs_code.profdata sss/ttt code.profdata. The resulted ``cs_code.prodata`` combines ``code.profdata`` and the profile; generated from binary ``cs_code``. Profile ``cs_code.profata`` can be used by; ``-fprofile-use`` compilation. .. code-block:: console. $ clang++ -O2 -fprofile-use=cs_code.profdata. The above command will read both profiles to the compiler at the identical; point of instrumentations. .. option:: -fprofile-use[=<pathname>]. Without any other arguments, ``-fprofile-use`` behaves identically to; ``-fprofile-instr-use``. Otherwise, if ``pathname`` is the full path to a; profile file, it reads from that file. If ``pathname`` is a directory name,; it reads from ``pathname/default.profdata``. .. option:: -fprofile-update[=<method>]. Unless ``-fsanitize=thread`` is specified, the default is ``single``, ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:111110,Performance,tune,tune,111110,"``-fprofile-use`` compilation. .. code-block:: console. $ clang++ -O2 -fprofile-use=cs_code.profdata. The above command will read both profiles to the compiler at the identical; point of instrumentations. .. option:: -fprofile-use[=<pathname>]. Without any other arguments, ``-fprofile-use`` behaves identically to; ``-fprofile-instr-use``. Otherwise, if ``pathname`` is the full path to a; profile file, it reads from that file. If ``pathname`` is a directory name,; it reads from ``pathname/default.profdata``. .. option:: -fprofile-update[=<method>]. Unless ``-fsanitize=thread`` is specified, the default is ``single``, which; uses non-atomic increments. The counters can be inaccurate under thread; contention. ``atomic`` uses atomic increments which is accurate but has; overhead. ``prefer-atomic`` will be transformed to ``atomic`` when supported; by the target, or ``single`` otherwise. Fine Tuning Profile Collection; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The PGO infrastructure provides user program knobs to fine tune profile; collection. Specifically, the PGO runtime provides the following functions; that can be used to control the regions in the program where profiles should; be collected. * ``void __llvm_profile_set_filename(const char *Name)``: changes the name of; the profile file to ``Name``.; * ``void __llvm_profile_reset_counters(void)``: resets all counters to zero.; * ``int __llvm_profile_dump(void)``: write the profile data to disk.; * ``int __llvm_orderfile_dump(void)``: write the order file to disk. For example, the following pattern can be used to skip profiling program; initialization, profile two specific hot regions, and skip profiling program; cleanup:. .. code-block:: c. int main() {; initialize();. // Reset all profile counters to 0 to omit profile collected during; // initialize()'s execution.; __llvm_profile_reset_counters();; ... hot region 1; // Dump the profile for hot region 1.; __llvm_profile_set_filename(""region1.profraw"");; __llvm_profile_dump();. /",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:114388,Performance,perform,performance,114388," The user code does not need to check if the API names are defined, because; these names are automatically replaced by ``(0)`` or the equivalence of noop; if the ``clang`` is not compiling for profile generation. Such replacement can happen because ``clang`` adds one of two macros depending; on the ``-fprofile-generate`` and the ``-fprofile-use`` flags. * ``__LLVM_INSTR_PROFILE_GENERATE``: defined when one of; ``-fprofile[-instr]-generate``/``-fcs-profile-generate`` is in effect.; * ``__LLVM_INSTR_PROFILE_USE``: defined when one of; ``-fprofile-use``/``-fprofile-instr-use`` is in effect. The two macros can be used to provide more flexibiilty so a user program; can execute code specifically intended for profile generate or profile use.; For example, a user program can have special logging during profile generate:. .. code-block:: c. #if __LLVM_INSTR_PROFILE_GENERATE; expensive_logging_of_full_program_state();; #endif. The logging is automatically excluded during a normal build of the program,; hence it does not impact performance during a normal execution. It is advised to use such fine tuning only in a program's cold regions. The weak; symbols can introduce extra control flow (the ``if`` checks), while the macros; (hence declarations they guard in ``profile/instr_prof_interface.h``); can change the control flow of the functions that use them between profile; generation and profile use (which can lead to discarded counters in such; functions). Using these APIs in the program's cold regions introduces less; overhead and leads to more optimized code. Disabling Instrumentation; ^^^^^^^^^^^^^^^^^^^^^^^^^. In certain situations, it may be useful to disable profile generation or use; for specific files in a build, without affecting the main compilation flags; used for the other files in the project. In these cases, you can use the flag ``-fno-profile-instr-generate`` (or; ``-fno-profile-generate``) to disable profile generation, and; ``-fno-profile-instr-use`` (or ``-fno-pr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:114913,Performance,optimiz,optimized,114913,"efined when one of; ``-fprofile-use``/``-fprofile-instr-use`` is in effect. The two macros can be used to provide more flexibiilty so a user program; can execute code specifically intended for profile generate or profile use.; For example, a user program can have special logging during profile generate:. .. code-block:: c. #if __LLVM_INSTR_PROFILE_GENERATE; expensive_logging_of_full_program_state();; #endif. The logging is automatically excluded during a normal build of the program,; hence it does not impact performance during a normal execution. It is advised to use such fine tuning only in a program's cold regions. The weak; symbols can introduce extra control flow (the ``if`` checks), while the macros; (hence declarations they guard in ``profile/instr_prof_interface.h``); can change the control flow of the functions that use them between profile; generation and profile use (which can lead to discarded counters in such; functions). Using these APIs in the program's cold regions introduces less; overhead and leads to more optimized code. Disabling Instrumentation; ^^^^^^^^^^^^^^^^^^^^^^^^^. In certain situations, it may be useful to disable profile generation or use; for specific files in a build, without affecting the main compilation flags; used for the other files in the project. In these cases, you can use the flag ``-fno-profile-instr-generate`` (or; ``-fno-profile-generate``) to disable profile generation, and; ``-fno-profile-instr-use`` (or ``-fno-profile-use``) to disable profile use. Note that these flags should appear after the corresponding profile; flags to have an effect. .. note::. When none of the translation units inside a binary is instrumented, in the; case of Fuchsia the profile runtime will not be linked into the binary and; no profile will be produced, while on other platforms the profile runtime; will be linked and profile will be produced but there will not be any; counters. Instrumenting only selected files or functions; ^^^^^^^^^^^^^^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:124977,Performance,optimiz,optimizations,124977," -fprofile-exclude-files=""^/usr/include/.*$"" \; -fprofile-filter-files=""^/usr/.*$"". In that case ``/usr/foo/oof.h`` is instrumented since it matches the filter regex and; doesn't match the exclude regex, but ``/usr/include/foo.h`` doesn't since it matches; the exclude regex. Controlling Debug Information; -----------------------------. Controlling Size of Debug Information; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Debug info kind generated by Clang can be set by one of the flags listed; below. If multiple flags are present, the last one is used. .. option:: -g0. Don't generate any debug info (default). .. option:: -gline-tables-only. Generate line number tables only. This kind of debug info allows to obtain stack traces with function names,; file names and line numbers (by such tools as ``gdb`` or ``addr2line``). It; doesn't contain any other data (e.g. description of local variables or; function parameters). .. option:: -fstandalone-debug. Clang supports a number of optimizations to reduce the size of debug; information in the binary. They work based on the assumption that; the debug type information can be spread out over multiple; compilation units. Specifically, the optimizations are:. - will not emit type definitions for types that are not needed by a; module and could be replaced with a forward declaration.; - will only emit type info for a dynamic C++ class in the module that; contains the vtable for the class.; - will only emit type info for a C++ class (non-trivial, non-aggregate); in the modules that contain a definition for one of its constructors.; - will only emit type definitions for types that are the subject of explicit; template instantiation declarations in the presence of an explicit; instantiation definition for the type. The **-fstandalone-debug** option turns off these optimizations.; This is useful when working with 3rd-party libraries that don't come; with debug information. Note that Clang will never emit type; information for types that are no",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:125184,Performance,optimiz,optimizations,125184,"e exclude regex, but ``/usr/include/foo.h`` doesn't since it matches; the exclude regex. Controlling Debug Information; -----------------------------. Controlling Size of Debug Information; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Debug info kind generated by Clang can be set by one of the flags listed; below. If multiple flags are present, the last one is used. .. option:: -g0. Don't generate any debug info (default). .. option:: -gline-tables-only. Generate line number tables only. This kind of debug info allows to obtain stack traces with function names,; file names and line numbers (by such tools as ``gdb`` or ``addr2line``). It; doesn't contain any other data (e.g. description of local variables or; function parameters). .. option:: -fstandalone-debug. Clang supports a number of optimizations to reduce the size of debug; information in the binary. They work based on the assumption that; the debug type information can be spread out over multiple; compilation units. Specifically, the optimizations are:. - will not emit type definitions for types that are not needed by a; module and could be replaced with a forward declaration.; - will only emit type info for a dynamic C++ class in the module that; contains the vtable for the class.; - will only emit type info for a C++ class (non-trivial, non-aggregate); in the modules that contain a definition for one of its constructors.; - will only emit type definitions for types that are the subject of explicit; template instantiation declarations in the presence of an explicit; instantiation definition for the type. The **-fstandalone-debug** option turns off these optimizations.; This is useful when working with 3rd-party libraries that don't come; with debug information. Note that Clang will never emit type; information for types that are not referenced at all by the program. .. option:: -fno-standalone-debug. On Darwin **-fstandalone-debug** is enabled by default. The; **-fno-standalone-debug** option can be used to get to",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:125817,Performance,optimiz,optimizations,125817,"`` or ``addr2line``). It; doesn't contain any other data (e.g. description of local variables or; function parameters). .. option:: -fstandalone-debug. Clang supports a number of optimizations to reduce the size of debug; information in the binary. They work based on the assumption that; the debug type information can be spread out over multiple; compilation units. Specifically, the optimizations are:. - will not emit type definitions for types that are not needed by a; module and could be replaced with a forward declaration.; - will only emit type info for a dynamic C++ class in the module that; contains the vtable for the class.; - will only emit type info for a C++ class (non-trivial, non-aggregate); in the modules that contain a definition for one of its constructors.; - will only emit type definitions for types that are the subject of explicit; template instantiation declarations in the presence of an explicit; instantiation definition for the type. The **-fstandalone-debug** option turns off these optimizations.; This is useful when working with 3rd-party libraries that don't come; with debug information. Note that Clang will never emit type; information for types that are not referenced at all by the program. .. option:: -fno-standalone-debug. On Darwin **-fstandalone-debug** is enabled by default. The; **-fno-standalone-debug** option can be used to get to turn on the; vtable-based optimization described above. .. option:: -g. Generate complete debug info. .. option:: -feliminate-unused-debug-types. By default, Clang does not emit type information for types that are defined; but not used in a program. To retain the debug info for these unused types,; the negation **-fno-eliminate-unused-debug-types** can be used. Controlling Macro Debug Info Generation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Debug info for C preprocessor macros increases the size of debug information in; the binary. Macro debug info generated by Clang can be controlled by the flags; listed ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:126211,Performance,optimiz,optimization,126211,"e optimizations are:. - will not emit type definitions for types that are not needed by a; module and could be replaced with a forward declaration.; - will only emit type info for a dynamic C++ class in the module that; contains the vtable for the class.; - will only emit type info for a C++ class (non-trivial, non-aggregate); in the modules that contain a definition for one of its constructors.; - will only emit type definitions for types that are the subject of explicit; template instantiation declarations in the presence of an explicit; instantiation definition for the type. The **-fstandalone-debug** option turns off these optimizations.; This is useful when working with 3rd-party libraries that don't come; with debug information. Note that Clang will never emit type; information for types that are not referenced at all by the program. .. option:: -fno-standalone-debug. On Darwin **-fstandalone-debug** is enabled by default. The; **-fno-standalone-debug** option can be used to get to turn on the; vtable-based optimization described above. .. option:: -g. Generate complete debug info. .. option:: -feliminate-unused-debug-types. By default, Clang does not emit type information for types that are defined; but not used in a program. To retain the debug info for these unused types,; the negation **-fno-eliminate-unused-debug-types** can be used. Controlling Macro Debug Info Generation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Debug info for C preprocessor macros increases the size of debug information in; the binary. Macro debug info generated by Clang can be controlled by the flags; listed below. .. option:: -fdebug-macro. Generate debug info for preprocessor macros. This flag is discarded when; **-g0** is enabled. .. option:: -fno-debug-macro. Do not generate debug info for preprocessor macros (default). Controlling Debugger ""Tuning""; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. While Clang generally emits standard DWARF debug info (http://dwarfstd.org),; different debuggers may",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:127258,Performance,tune,tune,127258,"fo. .. option:: -feliminate-unused-debug-types. By default, Clang does not emit type information for types that are defined; but not used in a program. To retain the debug info for these unused types,; the negation **-fno-eliminate-unused-debug-types** can be used. Controlling Macro Debug Info Generation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Debug info for C preprocessor macros increases the size of debug information in; the binary. Macro debug info generated by Clang can be controlled by the flags; listed below. .. option:: -fdebug-macro. Generate debug info for preprocessor macros. This flag is discarded when; **-g0** is enabled. .. option:: -fno-debug-macro. Do not generate debug info for preprocessor macros (default). Controlling Debugger ""Tuning""; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. While Clang generally emits standard DWARF debug info (http://dwarfstd.org),; different debuggers may know how to take advantage of different specific DWARF; features. You can ""tune"" the debug info for one of several different debuggers. .. option:: -ggdb, -glldb, -gsce, -gdbx. Tune the debug info for the ``gdb``, ``lldb``, Sony PlayStation\ |reg|; debugger, or ``dbx``, respectively. Each of these options implies **-g**.; (Therefore, if you want both **-gline-tables-only** and debugger tuning, the; tuning option must come first.). Controlling LLVM IR Output; --------------------------. Controlling Value Names in LLVM IR; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Emitting value names in LLVM IR increases the size and verbosity of the IR.; By default, value names are only emitted in assertion-enabled builds of Clang.; However, when reading IR it can be useful to re-enable the emission of value; names to improve readability. .. option:: -fdiscard-value-names. Discard value names when generating LLVM IR. .. option:: -fno-discard-value-names. Do not discard value names when generating LLVM IR. This option can be used; to re-enable names for release builds of Clang. Comment Parsing Options; ----",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:136235,Performance,perform,performs,136235,"earch=product%3Aclang+component%3A-New%2BBugs%2CAST%2CBasic%2CDriver%2CHeaders%2CLLVM%2BCodeGen%2Cparser%2Cpreprocessor%2CSemantic%2BAnalyzer>`_; for known existing bugs (FIXME: Is there a section for bug-reporting; guidelines somewhere?). Intentionally unsupported GCC extensions; ----------------------------------------. - clang does not support the gcc extension that allows variable-length; arrays in structures. This is for a few reasons: one, it is tricky to; implement, two, the extension is completely undocumented, and three,; the extension appears to be rarely used. Note that clang *does*; support flexible array members (arrays with a zero or unspecified; size at the end of a structure).; - GCC accepts many expression forms that are not valid integer constant; expressions in bit-field widths, enumerator constants, case labels,; and in array bounds at global scope. Clang also accepts additional; expression forms in these contexts, but constructs that GCC accepts due to; simplifications GCC performs while parsing, such as ``x - x`` (where ``x`` is a; variable) will likely never be accepted by Clang.; - clang does not support ``__builtin_apply`` and friends; this extension; is extremely obscure and difficult to implement reliably. .. _c_ms:. Microsoft extensions; --------------------. clang has support for many extensions from Microsoft Visual C++. To enable these; extensions, use the ``-fms-extensions`` command-line option. This is the default; for Windows targets. Clang does not implement every pragma or declspec provided; by MSVC, but the popular ones, such as ``__declspec(dllexport)`` and ``#pragma; comment(lib)`` are well supported. clang has a ``-fms-compatibility`` flag that makes clang accept enough; invalid C++ to be able to parse most Microsoft headers. For example, it; allows `unqualified lookup of dependent base class members; <https://clang.llvm.org/compatibility.html#dep_lookup_bases>`_, which is; a common compatibility issue with clang. This flag is",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:140745,Performance,load,loadable,140745,"library; for combined constructs; (e.g. ``#pragma omp parallel for simd``) the non-simd directives and clauses; will be ignored. This can be disabled with `-fno-openmp-simd`. Controlling implementation limits; ---------------------------------. .. option:: -fopenmp-use-tls. Controls code generation for OpenMP threadprivate variables. In presence of; this option all threadprivate variables are generated the same way as thread; local variables, using TLS support. If `-fno-openmp-use-tls`; is provided or target does not support TLS, code generation for threadprivate; variables relies on OpenMP runtime library. .. _opencl:. OpenCL Features; ===============. Clang can be used to compile OpenCL kernels for execution on a device; (e.g. GPU). It is possible to compile the kernel into a binary (e.g. for AMDGPU); that can be uploaded to run directly on a device (e.g. using; `clCreateProgramWithBinary; <https://www.khronos.org/registry/OpenCL/specs/opencl-1.1.pdf#111>`_) or; into generic bitcode files loadable into other toolchains. Compiling to a binary using the default target from the installation can be done; as follows:. .. code-block:: console. $ echo ""kernel void k(){}"" > test.cl; $ clang test.cl. Compiling for a specific target can be done by specifying the triple corresponding; to the target, for example:. .. code-block:: console. $ clang --target=nvptx64-unknown-unknown test.cl; $ clang --target=amdgcn-amd-amdhsa -mcpu=gfx900 test.cl. Compiling to bitcode can be done as follows:. .. code-block:: console. $ clang -c -emit-llvm test.cl. This will produce a file `test.bc` that can be used in vendor toolchains; to perform machine code generation. Note that if compiled to bitcode for generic targets such as SPIR/SPIR-V,; portable IR is produced that can be used with various vendor; tools as well as open source tools such as `SPIRV-LLVM Translator; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator>`_; to produce SPIR-V binary. More details are provided in `the offline",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:141376,Performance,perform,perform,141376,"enCL Features; ===============. Clang can be used to compile OpenCL kernels for execution on a device; (e.g. GPU). It is possible to compile the kernel into a binary (e.g. for AMDGPU); that can be uploaded to run directly on a device (e.g. using; `clCreateProgramWithBinary; <https://www.khronos.org/registry/OpenCL/specs/opencl-1.1.pdf#111>`_) or; into generic bitcode files loadable into other toolchains. Compiling to a binary using the default target from the installation can be done; as follows:. .. code-block:: console. $ echo ""kernel void k(){}"" > test.cl; $ clang test.cl. Compiling for a specific target can be done by specifying the triple corresponding; to the target, for example:. .. code-block:: console. $ clang --target=nvptx64-unknown-unknown test.cl; $ clang --target=amdgcn-amd-amdhsa -mcpu=gfx900 test.cl. Compiling to bitcode can be done as follows:. .. code-block:: console. $ clang -c -emit-llvm test.cl. This will produce a file `test.bc` that can be used in vendor toolchains; to perform machine code generation. Note that if compiled to bitcode for generic targets such as SPIR/SPIR-V,; portable IR is produced that can be used with various vendor; tools as well as open source tools such as `SPIRV-LLVM Translator; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator>`_; to produce SPIR-V binary. More details are provided in `the offline; compilation from OpenCL kernel sources into SPIR-V using open source; tools; <https://github.com/KhronosGroup/OpenCL-Guide/blob/main/chapters/os_tooling.md>`_.; From clang 14 onwards SPIR-V can be generated directly as detailed in; :ref:`the SPIR-V support section <spir-v>`. Clang currently supports OpenCL C language standards up to v2.0. Clang mainly; supports full profile. There is only very limited support of the embedded; profile.; From clang 9 a C++ mode is available for OpenCL (see; :ref:`C++ for OpenCL <cxx_for_opencl>`). OpenCL v3.0 support is complete but it remains in experimental state, see more; details about",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:149966,Performance,optimiz,optimizations,149966,"Extensions Documentation; <https://github.com/KhronosGroup/Khronosdotorg/blob/main/api/opencl/assets/OpenCL_LangExt.pdf>`_. OpenCL-Specific Attributes; --------------------------. OpenCL support in Clang contains a set of attribute taken directly from the; specification as well as additional attributes. See also :doc:`AttributeReference`. nosvm; ^^^^^. Clang supports this attribute to comply to OpenCL v2.0 conformance, but it; does not have any effect on the IR. For more details reffer to the specification; `section 6.7.2; <https://www.khronos.org/registry/cl/specs/opencl-2.0-openclc.pdf#49>`_. opencl_unroll_hint; ^^^^^^^^^^^^^^^^^^. The implementation of this feature mirrors the unroll hint for C.; More details on the syntax can be found in the specification; `section 6.11.5; <https://www.khronos.org/registry/cl/specs/opencl-2.0-openclc.pdf#61>`_. convergent; ^^^^^^^^^^. To make sure no invalid optimizations occur for single program multiple data; (SPMD) / single instruction multiple thread (SIMT) Clang provides attributes that; can be used for special functions that have cross work item semantics.; An example is the subgroup operations such as `intel_sub_group_shuffle; <https://www.khronos.org/registry/cl/extensions/intel/cl_intel_subgroups.txt>`_. .. code-block:: c. // Define custom my_sub_group_shuffle(data, c); // that makes use of intel_sub_group_shuffle; r1 = ...; if (r0) r1 = computeA();; // Shuffle data from r1 into r3; // of threads id r2.; r3 = my_sub_group_shuffle(r1, r2);; if (r0) r3 = computeB();. with non-SPMD semantics this is optimized to the following equivalent code:. .. code-block:: c. r1 = ...; if (!r0); // Incorrect functionality! The data in r1; // have not been computed by all threads yet.; r3 = my_sub_group_shuffle(r1, r2);; else {; r1 = computeA();; r3 = my_sub_group_shuffle(r1, r2);; r3 = computeB();; }. Declaring the function ``my_sub_group_shuffle`` with the convergent attribute; would prevent this:. .. code-block:: c. my_sub_group_shuff",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:150626,Performance,optimiz,optimized,150626,"encl-2.0-openclc.pdf#49>`_. opencl_unroll_hint; ^^^^^^^^^^^^^^^^^^. The implementation of this feature mirrors the unroll hint for C.; More details on the syntax can be found in the specification; `section 6.11.5; <https://www.khronos.org/registry/cl/specs/opencl-2.0-openclc.pdf#61>`_. convergent; ^^^^^^^^^^. To make sure no invalid optimizations occur for single program multiple data; (SPMD) / single instruction multiple thread (SIMT) Clang provides attributes that; can be used for special functions that have cross work item semantics.; An example is the subgroup operations such as `intel_sub_group_shuffle; <https://www.khronos.org/registry/cl/extensions/intel/cl_intel_subgroups.txt>`_. .. code-block:: c. // Define custom my_sub_group_shuffle(data, c); // that makes use of intel_sub_group_shuffle; r1 = ...; if (r0) r1 = computeA();; // Shuffle data from r1 into r3; // of threads id r2.; r3 = my_sub_group_shuffle(r1, r2);; if (r0) r3 = computeB();. with non-SPMD semantics this is optimized to the following equivalent code:. .. code-block:: c. r1 = ...; if (!r0); // Incorrect functionality! The data in r1; // have not been computed by all threads yet.; r3 = my_sub_group_shuffle(r1, r2);; else {; r1 = computeA();; r3 = my_sub_group_shuffle(r1, r2);; r3 = computeB();; }. Declaring the function ``my_sub_group_shuffle`` with the convergent attribute; would prevent this:. .. code-block:: c. my_sub_group_shuffle() __attribute__((convergent));. Using ``convergent`` guarantees correct execution by keeping CFG equivalence; wrt operations marked as ``convergent``. CFG ``G´`` is equivalent to ``G`` wrt; node ``Ni`` : ``iff ∀ Nj (i≠j)`` domination and post-domination relations with; respect to ``Ni`` remain the same in both ``G`` and ``G´``. noduplicate; ^^^^^^^^^^^. ``noduplicate`` is more restrictive with respect to optimizations than; ``convergent`` because a convergent function only preserves CFG equivalence.; This allows some optimizations to happen as long as the control fl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:151468,Performance,optimiz,optimizations,151468,"ata from r1 into r3; // of threads id r2.; r3 = my_sub_group_shuffle(r1, r2);; if (r0) r3 = computeB();. with non-SPMD semantics this is optimized to the following equivalent code:. .. code-block:: c. r1 = ...; if (!r0); // Incorrect functionality! The data in r1; // have not been computed by all threads yet.; r3 = my_sub_group_shuffle(r1, r2);; else {; r1 = computeA();; r3 = my_sub_group_shuffle(r1, r2);; r3 = computeB();; }. Declaring the function ``my_sub_group_shuffle`` with the convergent attribute; would prevent this:. .. code-block:: c. my_sub_group_shuffle() __attribute__((convergent));. Using ``convergent`` guarantees correct execution by keeping CFG equivalence; wrt operations marked as ``convergent``. CFG ``G´`` is equivalent to ``G`` wrt; node ``Ni`` : ``iff ∀ Nj (i≠j)`` domination and post-domination relations with; respect to ``Ni`` remain the same in both ``G`` and ``G´``. noduplicate; ^^^^^^^^^^^. ``noduplicate`` is more restrictive with respect to optimizations than; ``convergent`` because a convergent function only preserves CFG equivalence.; This allows some optimizations to happen as long as the control flow remains; unmodified. .. code-block:: c. for (int i=0; i<4; i++); my_sub_group_shuffle(). can be modified to:. .. code-block:: c. my_sub_group_shuffle();; my_sub_group_shuffle();; my_sub_group_shuffle();; my_sub_group_shuffle();. while using ``noduplicate`` would disallow this. Also ``noduplicate`` doesn't; have the same safe semantics of CFG as ``convergent`` and can cause changes in; CFG that modify semantics of the original program. ``noduplicate`` is kept for backwards compatibility only and it considered to be; deprecated for future uses. .. _cxx_for_opencl:. C++ for OpenCL; --------------. Starting from clang 9 kernel code can contain C++17 features: classes, templates,; function overloading, type deduction, etc. Please note that this is not an; implementation of `OpenCL C++; <https://www.khronos.org/registry/OpenCL/specs/2.2/pdf/OpenCL_C",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:151583,Performance,optimiz,optimizations,151583,"emantics this is optimized to the following equivalent code:. .. code-block:: c. r1 = ...; if (!r0); // Incorrect functionality! The data in r1; // have not been computed by all threads yet.; r3 = my_sub_group_shuffle(r1, r2);; else {; r1 = computeA();; r3 = my_sub_group_shuffle(r1, r2);; r3 = computeB();; }. Declaring the function ``my_sub_group_shuffle`` with the convergent attribute; would prevent this:. .. code-block:: c. my_sub_group_shuffle() __attribute__((convergent));. Using ``convergent`` guarantees correct execution by keeping CFG equivalence; wrt operations marked as ``convergent``. CFG ``G´`` is equivalent to ``G`` wrt; node ``Ni`` : ``iff ∀ Nj (i≠j)`` domination and post-domination relations with; respect to ``Ni`` remain the same in both ``G`` and ``G´``. noduplicate; ^^^^^^^^^^^. ``noduplicate`` is more restrictive with respect to optimizations than; ``convergent`` because a convergent function only preserves CFG equivalence.; This allows some optimizations to happen as long as the control flow remains; unmodified. .. code-block:: c. for (int i=0; i<4; i++); my_sub_group_shuffle(). can be modified to:. .. code-block:: c. my_sub_group_shuffle();; my_sub_group_shuffle();; my_sub_group_shuffle();; my_sub_group_shuffle();. while using ``noduplicate`` would disallow this. Also ``noduplicate`` doesn't; have the same safe semantics of CFG as ``convergent`` and can cause changes in; CFG that modify semantics of the original program. ``noduplicate`` is kept for backwards compatibility only and it considered to be; deprecated for future uses. .. _cxx_for_opencl:. C++ for OpenCL; --------------. Starting from clang 9 kernel code can contain C++17 features: classes, templates,; function overloading, type deduction, etc. Please note that this is not an; implementation of `OpenCL C++; <https://www.khronos.org/registry/OpenCL/specs/2.2/pdf/OpenCL_Cxx.pdf>`_ and; there is no plan to support it in clang in any new releases in the near future. Clang currently supports ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:167065,Performance,optimiz,optimization,167065,"up/SPIRV-LLVM-Translator/#build-with-spirv-tools>`_. `The versioning; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator/releases>`_ of; ``llvm-spirv`` is aligned with Clang major releases. The same applies to the; main development branch. It is therefore important to ensure the ``llvm-spirv``; version is in alignment with the Clang version. For troubleshooting purposes; ``llvm-spirv`` can be `tested in isolation; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator#test-instructions>`_. Example usage for OpenCL kernel compilation:. .. code-block:: console. $ clang --target=spirv32 -c test.cl; $ clang --target=spirv64 -c test.cl. Both invocations of Clang will result in the generation of a SPIR-V binary file; `test.o` for 32 bit and 64 bit respectively. This file can be imported; by an OpenCL driver that support SPIR-V consumption or it can be compiled; further by offline SPIR-V consumer tools. Converting to SPIR-V produced with the optimization levels other than `-O0` is; currently available as an experimental feature and it is not guaranteed to work; in all cases. Clang also supports integrated generation of SPIR-V without use of ``llvm-spirv``; tool as an experimental feature when ``-fintegrated-objemitter`` flag is passed in; the command line. .. code-block:: console. $ clang --target=spirv32 -fintegrated-objemitter -c test.cl. Note that only very basic functionality is supported at this point and therefore; it is not suitable for arbitrary use cases. This feature is only enabled when clang; build is configured with ``-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=SPIRV`` option. Linking is done using ``spirv-link`` from `the SPIRV-Tools project; <https://github.com/KhronosGroup/SPIRV-Tools#linker>`_. Similar to other external; linkers, Clang will expect ``spirv-link`` to be installed separately and to be; present in the ``PATH`` environment variable. Please refer to `the build and; installation instructions; <https://github.com/KhronosGroup/SPIRV-Tools#build>`_. .. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:174019,Performance,optimiz,optimization,174019,"Disable buffer security check; /GS Enable buffer security check (default); /Gs Use stack probes (default); /Gs<value> Set stack probe size (default 4096); /guard:<value> Enable Control Flow Guard with /guard:cf,; or only the table with /guard:cf,nochecks.; Enable EH Continuation Guard with /guard:ehcont; /Gv Set __vectorcall as a default calling convention; /Gw- Don't put each data item in its own section; /Gw Put each data item in its own section; /GX- Disable exception handling; /GX Enable exception handling; /Gy- Don't put each function in its own section (default); /Gy Put each function in its own section; /Gz Set __stdcall as a default calling convention; /help Display available options; /imsvc <dir> Add directory to system include search path, as if part of %INCLUDE%; /I <dir> Add directory to include search path; /J Make char type unsigned; /LDd Create debug DLL; /LD Create DLL; /link <options> Forward options to the linker; /MDd Use DLL debug run-time; /MD Use DLL run-time; /MTd Use static debug run-time; /MT Use static run-time; /O0 Disable optimization; /O1 Optimize for size (same as /Og /Os /Oy /Ob2 /GF /Gy); /O2 Optimize for speed (same as /Og /Oi /Ot /Oy /Ob2 /GF /Gy); /Ob0 Disable function inlining; /Ob1 Only inline functions which are (explicitly or implicitly) marked inline; /Ob2 Inline functions as deemed beneficial by the compiler; /Od Disable optimization; /Og No effect; /Oi- Disable use of builtin functions; /Oi Enable use of builtin functions; /Os Optimize for size; /Ot Optimize for speed; /Ox Deprecated (same as /Og /Oi /Ot /Oy /Ob2); use /O2 instead; /Oy- Disable frame pointer omission (x86 only, default); /Oy Enable frame pointer omission (x86 only); /O<flags> Set multiple /O flags at once; e.g. '/O2y-' for '/O2 /Oy-'; /o <file or directory> Set output file or directory (ends in / or \); /P Preprocess to file; /Qvec- Disable the loop vectorization passes; /Qvec Enable the loop vectorization passes; /showFilenames- Don't print the name of each ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:174337,Performance,optimiz,optimization,174337,"Disable buffer security check; /GS Enable buffer security check (default); /Gs Use stack probes (default); /Gs<value> Set stack probe size (default 4096); /guard:<value> Enable Control Flow Guard with /guard:cf,; or only the table with /guard:cf,nochecks.; Enable EH Continuation Guard with /guard:ehcont; /Gv Set __vectorcall as a default calling convention; /Gw- Don't put each data item in its own section; /Gw Put each data item in its own section; /GX- Disable exception handling; /GX Enable exception handling; /Gy- Don't put each function in its own section (default); /Gy Put each function in its own section; /Gz Set __stdcall as a default calling convention; /help Display available options; /imsvc <dir> Add directory to system include search path, as if part of %INCLUDE%; /I <dir> Add directory to include search path; /J Make char type unsigned; /LDd Create debug DLL; /LD Create DLL; /link <options> Forward options to the linker; /MDd Use DLL debug run-time; /MD Use DLL run-time; /MTd Use static debug run-time; /MT Use static run-time; /O0 Disable optimization; /O1 Optimize for size (same as /Og /Os /Oy /Ob2 /GF /Gy); /O2 Optimize for speed (same as /Og /Oi /Ot /Oy /Ob2 /GF /Gy); /Ob0 Disable function inlining; /Ob1 Only inline functions which are (explicitly or implicitly) marked inline; /Ob2 Inline functions as deemed beneficial by the compiler; /Od Disable optimization; /Og No effect; /Oi- Disable use of builtin functions; /Oi Enable use of builtin functions; /Os Optimize for size; /Ot Optimize for speed; /Ox Deprecated (same as /Og /Oi /Ot /Oy /Ob2); use /O2 instead; /Oy- Disable frame pointer omission (x86 only, default); /Oy Enable frame pointer omission (x86 only); /O<flags> Set multiple /O flags at once; e.g. '/O2y-' for '/O2 /Oy-'; /o <file or directory> Set output file or directory (ends in / or \); /P Preprocess to file; /Qvec- Disable the loop vectorization passes; /Qvec Enable the loop vectorization passes; /showFilenames- Don't print the name of each ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:175839,Performance,load,loads,175839," vectorization passes; /Qvec Enable the loop vectorization passes; /showFilenames- Don't print the name of each compiled file (default); /showFilenames Print the name of each compiled file; /showIncludes Print info about included files to stderr; /source-charset:<value> Source encoding, supports only UTF-8; /std:<value> Language standard to compile for; /TC Treat all source files as C; /Tc <filename> Specify a C source file; /TP Treat all source files as C++; /Tp <filename> Specify a C++ source file; /utf-8 Set source and runtime encoding to UTF-8 (default); /U <macro> Undefine macro; /vd<value> Control vtordisp placement; /vmb Use a best-case representation method for member pointers; /vmg Use a most-general representation for member pointers; /vmm Set the default most-general representation to multiple inheritance; /vms Set the default most-general representation to single inheritance; /vmv Set the default most-general representation to virtual inheritance; /volatile:iso Volatile loads and stores have standard semantics; /volatile:ms Volatile loads and stores have acquire and release semantics; /W0 Disable all warnings; /W1 Enable -Wall; /W2 Enable -Wall; /W3 Enable -Wall; /W4 Enable -Wall and -Wextra; /Wall Enable -Weverything; /WX- Do not treat warnings as errors; /WX Treat warnings as errors; /w Disable all warnings; /X Don't add %INCLUDE% to the include search path; /Y- Disable precompiled headers, overrides /Yc and /Yu; /Yc<filename> Generate a pch file for all code up to and including <filename>; /Yu<filename> Load a pch file and use it instead of all code up to and including <filename>; /Z7 Enable CodeView debug information in object files; /Zc:char8_t Enable C++20 char8_t type; /Zc:char8_t- Disable C++20 char8_t type; /Zc:dllexportInlines- Don't dllexport/dllimport inline member functions of dllexport/import classes; /Zc:dllexportInlines dllexport/dllimport inline member functions of dllexport/import classes (default); /Zc:sizedDealloc- Disable C++14 sized",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:175903,Performance,load,loads,175903,"s; /showFilenames- Don't print the name of each compiled file (default); /showFilenames Print the name of each compiled file; /showIncludes Print info about included files to stderr; /source-charset:<value> Source encoding, supports only UTF-8; /std:<value> Language standard to compile for; /TC Treat all source files as C; /Tc <filename> Specify a C source file; /TP Treat all source files as C++; /Tp <filename> Specify a C++ source file; /utf-8 Set source and runtime encoding to UTF-8 (default); /U <macro> Undefine macro; /vd<value> Control vtordisp placement; /vmb Use a best-case representation method for member pointers; /vmg Use a most-general representation for member pointers; /vmm Set the default most-general representation to multiple inheritance; /vms Set the default most-general representation to single inheritance; /vmv Set the default most-general representation to virtual inheritance; /volatile:iso Volatile loads and stores have standard semantics; /volatile:ms Volatile loads and stores have acquire and release semantics; /W0 Disable all warnings; /W1 Enable -Wall; /W2 Enable -Wall; /W3 Enable -Wall; /W4 Enable -Wall and -Wextra; /Wall Enable -Weverything; /WX- Do not treat warnings as errors; /WX Treat warnings as errors; /w Disable all warnings; /X Don't add %INCLUDE% to the include search path; /Y- Disable precompiled headers, overrides /Yc and /Yu; /Yc<filename> Generate a pch file for all code up to and including <filename>; /Yu<filename> Load a pch file and use it instead of all code up to and including <filename>; /Z7 Enable CodeView debug information in object files; /Zc:char8_t Enable C++20 char8_t type; /Zc:char8_t- Disable C++20 char8_t type; /Zc:dllexportInlines- Don't dllexport/dllimport inline member functions of dllexport/import classes; /Zc:dllexportInlines dllexport/dllimport inline member functions of dllexport/import classes (default); /Zc:sizedDealloc- Disable C++14 sized global deallocation functions; /Zc:sizedDealloc Enable C++14 si",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:181301,Performance,optimiz,optimizations,181301,cross-dso; Disable control flow integrity (CFI) checks for cross-DSO calls.; -fno-sanitize-coverage=<value>; Disable specified features of coverage instrumentation for Sanitizers; -fno-sanitize-memory-track-origins; Disable origins tracking in MemorySanitizer; -fno-sanitize-memory-use-after-dtor; Disable use-after-destroy detection in MemorySanitizer; -fno-sanitize-recover=<value>; Disable recovery for specified sanitizers; -fno-sanitize-stats Disable sanitizer statistics gathering.; -fno-sanitize-thread-atomics; Disable atomic operations instrumentation in ThreadSanitizer; -fno-sanitize-thread-func-entry-exit; Disable function entry/exit instrumentation in ThreadSanitizer; -fno-sanitize-thread-memory-access; Disable memory access instrumentation in ThreadSanitizer; -fno-sanitize-trap=<value>; Disable trapping for specified sanitizers; -fno-standalone-debug Limit debug information produced to reduce size of debug binary; -fno-strict-aliasing Disable optimizations based on strict aliasing rules (default); -fobjc-runtime=<value> Specify the target Objective-C runtime kind and version; -fprofile-exclude-files=<value>; Instrument only functions from files where names don't match all the regexes separated by a semi-colon; -fprofile-filter-files=<value>; Instrument only functions from files where names match any regex separated by a semi-colon; -fprofile-generate=<dirname>; Generate instrumented code to collect execution counts into a raw profile file in the directory specified by the argument. The filename uses default_%m.profraw pattern; (overridden by LLVM_PROFILE_FILE env var); -fprofile-generate; Generate instrumented code to collect execution counts into default_%m.profraw file; (overridden by '=' form of option or LLVM_PROFILE_FILE env var); -fprofile-instr-generate=<file_name_pattern>; Generate instrumented code to collect execution counts into the file whose name pattern is specified as the argument; (overridden by LLVM_PROFILE_FILE env var); -fprofile-instr-gene,MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:182583,Performance,optimiz,optimization,182583," var); -fprofile-instr-generate=<file_name_pattern>; Generate instrumented code to collect execution counts into the file whose name pattern is specified as the argument; (overridden by LLVM_PROFILE_FILE env var); -fprofile-instr-generate; Generate instrumented code to collect execution counts into default.profraw file; (overridden by '=' form of option or LLVM_PROFILE_FILE env var); -fprofile-instr-use=<value>; Use instrumentation data for coverage testing or profile-guided optimization; -fprofile-use=<value>; Use instrumentation data for profile-guided optimization; -fprofile-remapping-file=<file>; Use the remappings described in <file> to match the profile data against names in the program; -fprofile-list=<file>; Filename defining the list of functions/files to instrument; -fsanitize-address-field-padding=<value>; Level of field padding for AddressSanitizer; -fsanitize-address-globals-dead-stripping; Enable linker dead stripping of globals in AddressSanitizer; -fsanitize-address-poison-custom-array-cookie; Enable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fsanitize-address-use-after-return=<mode>; Select the mode of detecting stack use-after-return in AddressSanitizer: never | runtime (default) | always; -fsanitize-address-use-after-scope; Enable use-after-scope detection in AddressSanitizer; -fsanitize-address-use-odr-indicator; Enable ODR indicator globals to avoid false ODR violation reports in partially sanitized programs at the cost of an increase in binary size; -fsanitize-ignorelist=<value>; Path to ignorelist file for sanitizers; -fsanitize-cfi-cross-dso; Enable control flow integrity (CFI) checks for cross-DSO calls.; -fsanitize-cfi-icall-generalize-pointers; Generalize pointers in CFI indirect call type signature checks; -fsanitize-coverage=<value>; Specify the type of coverage instrumentation for Sanitizers; -fsanitize-hwaddress-abi=<value>; Select the HWAddressSanitizer ABI to target (interceptor or platform, defaul",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:182664,Performance,optimiz,optimization,182664," var); -fprofile-instr-generate=<file_name_pattern>; Generate instrumented code to collect execution counts into the file whose name pattern is specified as the argument; (overridden by LLVM_PROFILE_FILE env var); -fprofile-instr-generate; Generate instrumented code to collect execution counts into default.profraw file; (overridden by '=' form of option or LLVM_PROFILE_FILE env var); -fprofile-instr-use=<value>; Use instrumentation data for coverage testing or profile-guided optimization; -fprofile-use=<value>; Use instrumentation data for profile-guided optimization; -fprofile-remapping-file=<file>; Use the remappings described in <file> to match the profile data against names in the program; -fprofile-list=<file>; Filename defining the list of functions/files to instrument; -fsanitize-address-field-padding=<value>; Level of field padding for AddressSanitizer; -fsanitize-address-globals-dead-stripping; Enable linker dead stripping of globals in AddressSanitizer; -fsanitize-address-poison-custom-array-cookie; Enable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fsanitize-address-use-after-return=<mode>; Select the mode of detecting stack use-after-return in AddressSanitizer: never | runtime (default) | always; -fsanitize-address-use-after-scope; Enable use-after-scope detection in AddressSanitizer; -fsanitize-address-use-odr-indicator; Enable ODR indicator globals to avoid false ODR violation reports in partially sanitized programs at the cost of an increase in binary size; -fsanitize-ignorelist=<value>; Path to ignorelist file for sanitizers; -fsanitize-cfi-cross-dso; Enable control flow integrity (CFI) checks for cross-DSO calls.; -fsanitize-cfi-icall-generalize-pointers; Generalize pointers in CFI indirect call type signature checks; -fsanitize-coverage=<value>; Specify the type of coverage instrumentation for Sanitizers; -fsanitize-hwaddress-abi=<value>; Select the HWAddressSanitizer ABI to target (interceptor or platform, defaul",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:185311,Performance,optimiz,optimizations,185311," MemorySanitizer; -fsanitize-recover=<value>; Enable recovery for specified sanitizers; -fsanitize-stats Enable sanitizer statistics gathering.; -fsanitize-thread-atomics; Enable atomic operations instrumentation in ThreadSanitizer (default); -fsanitize-thread-func-entry-exit; Enable function entry/exit instrumentation in ThreadSanitizer (default); -fsanitize-thread-memory-access; Enable memory access instrumentation in ThreadSanitizer (default); -fsanitize-trap=<value> Enable trapping for specified sanitizers; -fsanitize-undefined-strip-path-components=<number>; Strip (or keep only, if negative) a given number of path components when emitting check metadata.; -fsanitize=<check> Turn on runtime checks for various forms of undefined or suspicious; behavior. See user manual for available checks; -fsplit-lto-unit Enables splitting of the LTO unit.; -fstandalone-debug Emit full debug info for all types used by the program; -fstrict-aliasing	 Enable optimizations based on strict aliasing rules; -fsyntax-only Run the preprocessor, parser and semantic analysis stages; -fwhole-program-vtables Enables whole-program vtable optimization. Requires -flto; -gcodeview-ghash Emit type record hashes in a .debug$H section; -gcodeview Generate CodeView debug information; -gline-directives-only Emit debug line info directives only; -gline-tables-only Emit debug line number tables only; -miamcu Use Intel MCU ABI; -mllvm <value> Additional arguments to forward to LLVM's option processing; -nobuiltininc Disable builtin #include directories; -Qunused-arguments Don't emit warning for unused driver arguments; -R<remark> Enable the specified remark; --target=<value> Generate code for the given target; --version Print version information; -v Show commands to run and use verbose output; -W<warning> Enable the specified warning; -Xclang <arg> Pass <arg> to the clang compiler. The /clang: Option; ^^^^^^^^^^^^^^^^^^. When clang-cl is run with a set of ``/clang:<arg>`` options, it will gather all; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:185483,Performance,optimiz,optimization,185483," MemorySanitizer; -fsanitize-recover=<value>; Enable recovery for specified sanitizers; -fsanitize-stats Enable sanitizer statistics gathering.; -fsanitize-thread-atomics; Enable atomic operations instrumentation in ThreadSanitizer (default); -fsanitize-thread-func-entry-exit; Enable function entry/exit instrumentation in ThreadSanitizer (default); -fsanitize-thread-memory-access; Enable memory access instrumentation in ThreadSanitizer (default); -fsanitize-trap=<value> Enable trapping for specified sanitizers; -fsanitize-undefined-strip-path-components=<number>; Strip (or keep only, if negative) a given number of path components when emitting check metadata.; -fsanitize=<check> Turn on runtime checks for various forms of undefined or suspicious; behavior. See user manual for available checks; -fsplit-lto-unit Enables splitting of the LTO unit.; -fstandalone-debug Emit full debug info for all types used by the program; -fstrict-aliasing	 Enable optimizations based on strict aliasing rules; -fsyntax-only Run the preprocessor, parser and semantic analysis stages; -fwhole-program-vtables Enables whole-program vtable optimization. Requires -flto; -gcodeview-ghash Emit type record hashes in a .debug$H section; -gcodeview Generate CodeView debug information; -gline-directives-only Emit debug line info directives only; -gline-tables-only Emit debug line number tables only; -miamcu Use Intel MCU ABI; -mllvm <value> Additional arguments to forward to LLVM's option processing; -nobuiltininc Disable builtin #include directories; -Qunused-arguments Don't emit warning for unused driver arguments; -R<remark> Enable the specified remark; --target=<value> Generate code for the given target; --version Print version information; -v Show commands to run and use verbose output; -W<warning> Enable the specified warning; -Xclang <arg> Pass <arg> to the clang compiler. The /clang: Option; ^^^^^^^^^^^^^^^^^^. When clang-cl is run with a set of ``/clang:<arg>`` options, it will gather all; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:194819,Performance,perform,performed,194819,"ols that allow the user control over where clang-cl will; locate these headers. The default behaviour for the Windows SDK and UCRT is as; follows:. 1. Consult the command line. Anything the user specifies is always given precedence. The following; extensions are part of the clang-cl toolset:. - `/winsysroot:`. The `/winsysroot:` is used as an equivalent to `-sysroot` on Unix; environments. It allows the control of an alternate location to be treated; as a system root. When specified, it will be used as the root where the; `Windows Kits` is located. - `/winsdkversion:`; - `/winsdkdir:`. If `/winsysroot:` is not specified, the `/winsdkdir:` argument is consulted; as a location to identify where the Windows SDK is located. Contrary to; `/winsysroot:`, `/winsdkdir:` is expected to be the complete path rather; than a root to locate `Windows Kits`. The `/winsdkversion:` flag allows the user to specify a version identifier; for the SDK to prefer. When this is specified, no additional validation is; performed and this version is preferred. If the version is not specified,; the highest detected version number will be used. 2. Consult the environment. TODO: This is not yet implemented. This will consult the environment variables:. - `WindowsSdkDir`; - `UCRTVersion`. 3. Fallback to the registry. If no arguments are used to indicate where the SDK is present, and the; compiler is running on Windows, the registry is consulted to locate the; installation. The Visual C++ Toolset has a slightly more elaborate mechanism for detection. 1. Consult the command line. - `/winsysroot:`. The `/winsysroot:` is used as an equivalent to `-sysroot` on Unix; environments. It allows the control of an alternate location to be treated; as a system root. When specified, it will be used as the root where the; `VC` directory is located. - `/vctoolsdir:`; - `/vctoolsversion:`. If `/winsysroot:` is not specified, the `/vctoolsdir:` argument is consulted; as a location to identify where the Visual C++ To",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:196660,Performance,load,load,196660,"ory is located. - `/vctoolsdir:`; - `/vctoolsversion:`. If `/winsysroot:` is not specified, the `/vctoolsdir:` argument is consulted; as a location to identify where the Visual C++ Tools are located. If; `/vctoolsversion:` is specified, that version is preferred, otherwise, the; highest version detected is used. 2. Consult the environment. - `/external:[VARIABLE]`. This specifies a user identified environment variable which is treated as; a path delimiter (`;`) separated list of paths to map into `-imsvc`; arguments which are treated as `-isystem`. - `INCLUDE` and `EXTERNAL_INCLUDE`. The path delimiter (`;`) separated list of paths will be mapped to; `-imsvc` arguments which are treated as `-isystem`. - `LIB` (indirectly). The linker `link.exe` or `lld-link.exe` will honour the environment; variable `LIB` which is a path delimiter (`;`) set of paths to consult for; the import libraries to use when linking the final target. The following environment variables will be consulted and used to form paths; to validate and load content from as appropriate:. - `VCToolsInstallDir`; - `VCINSTALLDIR`; - `Path`. 3. Consult `ISetupConfiguration` [Windows Only]. Assuming that the toolchain is built with `USE_MSVC_SETUP_API` defined and; is running on Windows, the Visual Studio COM interface `ISetupConfiguration`; will be used to locate the installation of the MSVC toolset. 4. Fallback to the registry [DEPRECATED]. The registry information is used to help locate the installation as a final; fallback. This is only possible for pre-VS2017 installations and is; considered deprecated. Restrictions and Limitations compared to Clang; ----------------------------------------------. Strict Aliasing; ^^^^^^^^^^^^^^^. Strict aliasing (TBAA) is always off by default in clang-cl. Whereas in clang,; strict aliasing is turned on by default for all optimization levels. To enable LLVM optimizations based on strict aliasing rules (e.g., optimizations; based on type of expressions in C/C++), user wil",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:197479,Performance,optimiz,optimization,197479,"insysroot:` is not specified, the `/vctoolsdir:` argument is consulted; as a location to identify where the Visual C++ Tools are located. If; `/vctoolsversion:` is specified, that version is preferred, otherwise, the; highest version detected is used. 2. Consult the environment. - `/external:[VARIABLE]`. This specifies a user identified environment variable which is treated as; a path delimiter (`;`) separated list of paths to map into `-imsvc`; arguments which are treated as `-isystem`. - `INCLUDE` and `EXTERNAL_INCLUDE`. The path delimiter (`;`) separated list of paths will be mapped to; `-imsvc` arguments which are treated as `-isystem`. - `LIB` (indirectly). The linker `link.exe` or `lld-link.exe` will honour the environment; variable `LIB` which is a path delimiter (`;`) set of paths to consult for; the import libraries to use when linking the final target. The following environment variables will be consulted and used to form paths; to validate and load content from as appropriate:. - `VCToolsInstallDir`; - `VCINSTALLDIR`; - `Path`. 3. Consult `ISetupConfiguration` [Windows Only]. Assuming that the toolchain is built with `USE_MSVC_SETUP_API` defined and; is running on Windows, the Visual Studio COM interface `ISetupConfiguration`; will be used to locate the installation of the MSVC toolset. 4. Fallback to the registry [DEPRECATED]. The registry information is used to help locate the installation as a final; fallback. This is only possible for pre-VS2017 installations and is; considered deprecated. Restrictions and Limitations compared to Clang; ----------------------------------------------. Strict Aliasing; ^^^^^^^^^^^^^^^. Strict aliasing (TBAA) is always off by default in clang-cl. Whereas in clang,; strict aliasing is turned on by default for all optimization levels. To enable LLVM optimizations based on strict aliasing rules (e.g., optimizations; based on type of expressions in C/C++), user will need to explicitly pass; `-fstrict-aliasing` to clang-cl.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:197515,Performance,optimiz,optimizations,197515,"insysroot:` is not specified, the `/vctoolsdir:` argument is consulted; as a location to identify where the Visual C++ Tools are located. If; `/vctoolsversion:` is specified, that version is preferred, otherwise, the; highest version detected is used. 2. Consult the environment. - `/external:[VARIABLE]`. This specifies a user identified environment variable which is treated as; a path delimiter (`;`) separated list of paths to map into `-imsvc`; arguments which are treated as `-isystem`. - `INCLUDE` and `EXTERNAL_INCLUDE`. The path delimiter (`;`) separated list of paths will be mapped to; `-imsvc` arguments which are treated as `-isystem`. - `LIB` (indirectly). The linker `link.exe` or `lld-link.exe` will honour the environment; variable `LIB` which is a path delimiter (`;`) set of paths to consult for; the import libraries to use when linking the final target. The following environment variables will be consulted and used to form paths; to validate and load content from as appropriate:. - `VCToolsInstallDir`; - `VCINSTALLDIR`; - `Path`. 3. Consult `ISetupConfiguration` [Windows Only]. Assuming that the toolchain is built with `USE_MSVC_SETUP_API` defined and; is running on Windows, the Visual Studio COM interface `ISetupConfiguration`; will be used to locate the installation of the MSVC toolset. 4. Fallback to the registry [DEPRECATED]. The registry information is used to help locate the installation as a final; fallback. This is only possible for pre-VS2017 installations and is; considered deprecated. Restrictions and Limitations compared to Clang; ----------------------------------------------. Strict Aliasing; ^^^^^^^^^^^^^^^. Strict aliasing (TBAA) is always off by default in clang-cl. Whereas in clang,; strict aliasing is turned on by default for all optimization levels. To enable LLVM optimizations based on strict aliasing rules (e.g., optimizations; based on type of expressions in C/C++), user will need to explicitly pass; `-fstrict-aliasing` to clang-cl.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:197567,Performance,optimiz,optimizations,197567,"insysroot:` is not specified, the `/vctoolsdir:` argument is consulted; as a location to identify where the Visual C++ Tools are located. If; `/vctoolsversion:` is specified, that version is preferred, otherwise, the; highest version detected is used. 2. Consult the environment. - `/external:[VARIABLE]`. This specifies a user identified environment variable which is treated as; a path delimiter (`;`) separated list of paths to map into `-imsvc`; arguments which are treated as `-isystem`. - `INCLUDE` and `EXTERNAL_INCLUDE`. The path delimiter (`;`) separated list of paths will be mapped to; `-imsvc` arguments which are treated as `-isystem`. - `LIB` (indirectly). The linker `link.exe` or `lld-link.exe` will honour the environment; variable `LIB` which is a path delimiter (`;`) set of paths to consult for; the import libraries to use when linking the final target. The following environment variables will be consulted and used to form paths; to validate and load content from as appropriate:. - `VCToolsInstallDir`; - `VCINSTALLDIR`; - `Path`. 3. Consult `ISetupConfiguration` [Windows Only]. Assuming that the toolchain is built with `USE_MSVC_SETUP_API` defined and; is running on Windows, the Visual Studio COM interface `ISetupConfiguration`; will be used to locate the installation of the MSVC toolset. 4. Fallback to the registry [DEPRECATED]. The registry information is used to help locate the installation as a final; fallback. This is only possible for pre-VS2017 installations and is; considered deprecated. Restrictions and Limitations compared to Clang; ----------------------------------------------. Strict Aliasing; ^^^^^^^^^^^^^^^. Strict aliasing (TBAA) is always off by default in clang-cl. Whereas in clang,; strict aliasing is turned on by default for all optimization levels. To enable LLVM optimizations based on strict aliasing rules (e.g., optimizations; based on type of expressions in C/C++), user will need to explicitly pass; `-fstrict-aliasing` to clang-cl.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:7250,Safety,detect,detected,7250,"rce-location. Print source file/line/column information in diagnostic. This option, which defaults to on, controls whether or not Clang; prints the filename, line number and column number of a diagnostic.; For example, when this is enabled, Clang will print something like:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. When this is disabled, Clang will not print the ""test.c:28:8: ""; part. .. _opt_fcaret-diagnostics:. .. option:: -f[no-]caret-diagnostics. Print source line and ranges from source code in diagnostic.; This option, which defaults to on, controls whether or not Clang; prints the source line, source ranges, and caret when emitting a; diagnostic. For example, when this is enabled, Clang will print; something like:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. .. option:: -f[no-]color-diagnostics. This option, which defaults to on when a color-capable terminal is; detected, controls whether or not Clang prints diagnostics in color. When this option is enabled, Clang will use colors to highlight; specific parts of the diagnostic, e.g.,. .. nasty hack to not lose our dignity. .. raw:: html. <pre>; <b><span style=""color:black"">test.c:28:8: <span style=""color:magenta"">warning</span>: extra tokens at end of #endif directive [-Wextra-tokens]</span></b>; #endif bad; <span style=""color:green"">^</span>; <span style=""color:green"">//</span>; </pre>. When this is disabled, Clang will just print:. ::. test.c:2:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. If the ``NO_COLOR`` environment variable is defined and not empty; (regardless of value), color diagnostics are disabled. If ``NO_COLOR`` is; defined and ``-fcolor-diagnostics`` is passed on the command line, Clang; will honor the command line argument. .. option:: -fansi-escape-codes. Controls whether ANSI escape codes are used instead of the Windows Console; API ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:46052,Safety,redund,redundant,46052,"th :option:`-w` (which disables all warnings),; disabling all warnings wins. Controlling Static Analyzer Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. While not strictly part of the compiler, the diagnostics from Clang's; `static analyzer <https://clang-analyzer.llvm.org>`_ can also be; influenced by the user via changes to the source code. See the available; `annotations <https://clang-analyzer.llvm.org/annotations.html>`_ and the; analyzer's `FAQ; page <https://clang-analyzer.llvm.org/faq.html#exclude_code>`_ for more; information. .. _usersmanual-precompiled-headers:. Precompiled Headers; -------------------. `Precompiled headers <https://en.wikipedia.org/wiki/Precompiled_header>`_; are a general approach employed by many compilers to reduce compilation; time. The underlying motivation of the approach is that it is common for; the same (and often large) header files to be included by multiple; source files. Consequently, compile times can often be greatly improved; by caching some of the (redundant) work done by a compiler to process; headers. Precompiled header files, which represent one of many ways to; implement this optimization, are literally files that represent an; on-disk cache that contains the vital information necessary to reduce; some of the work needed to process a corresponding header file. While; details of precompiled headers vary between compilers, precompiled; headers have been shown to be highly effective at speeding up program; compilation on systems with very large system headers (e.g., macOS). Generating a PCH File; ^^^^^^^^^^^^^^^^^^^^^. To generate a PCH file using Clang, one invokes Clang with the; `-x <language>-header` option. This mirrors the interface in GCC; for generating PCH files:. .. code-block:: console. $ gcc -x c-header test.h -o test.h.gch; $ clang -x c-header test.h -o test.h.pch. Using a PCH File; ^^^^^^^^^^^^^^^^. A PCH file can then be used as a prefix header when a ``-include-pch``; option is passed to ``clang``:.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:53110,Safety,unsafe,unsafe,53110,"qual to ``NaN`` and; ``Inf``, and; * ``+0`` and ``-0`` are interchangeable. ``-ffast-math`` also defines the ``__FAST_MATH__`` preprocessor; macro. Some math libraries recognize this macro and change their behavior.; With the exception of ``-ffp-contract=fast``, using any of the options; below to disable any of the individual optimizations in ``-ffast-math``; will cause ``__FAST_MATH__`` to no longer be set.; ``-ffast-math`` enables ``-fcx-limited-range``. This option implies:. * ``-fno-honor-infinities``. * ``-fno-honor-nans``. * ``-fapprox-func``. * ``-fno-math-errno``. * ``-ffinite-math-only``. * ``-fassociative-math``. * ``-freciprocal-math``. * ``-fno-signed-zeros``. * ``-fno-trapping-math``. * ``-fno-rounding-math``. * ``-ffp-contract=fast``. Note: ``-ffast-math`` causes ``crtfastmath.o`` to be linked with code. See; :ref:`crtfastmath.o` for more details. .. option:: -fno-fast-math. Disable fast-math mode. This options disables unsafe floating-point; optimizations by preventing the compiler from making any transformations that; could affect the results. This option implies:. * ``-fhonor-infinities``. * ``-fhonor-nans``. * ``-fno-approx-func``. * ``-fno-finite-math-only``. * ``-fno-associative-math``. * ``-fno-reciprocal-math``. * ``-fsigned-zeros``. * ``-ffp-contract=on``. Also, this option resets following options to their target-dependent defaults. * ``-f[no-]math-errno``; * ``-fdenormal-fp-math=<value>``. There is ambiguity about how ``-ffp-contract``, ``-ffast-math``,; and ``-fno-fast-math`` behave when combined. To keep the value of; ``-ffp-contract`` consistent, we define this set of rules:. * ``-ffast-math`` sets ``ffp-contract`` to ``fast``. * ``-fno-fast-math`` sets ``-ffp-contract`` to ``on`` (``fast`` for CUDA and; HIP). * If ``-ffast-math`` and ``-ffp-contract`` are both seen, but; ``-ffast-math`` is not followed by ``-fno-fast-math``, ``ffp-contract``; will be given the value of whichever option was last seen. * If ``-fno-fast-math`` is seen and `",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:59217,Safety,unsafe,unsafe-math-optimizations,59217,"same effect as specifying ``-ffinite-math-only``. .. option:: -f[no-]approx-func. Allow certain math function calls (such as ``log``, ``sqrt``, ``pow``, etc); to be replaced with an approximately equivalent set of instructions; or alternative math function calls. For example, a ``pow(x, 0.25)``; may be replaced with ``sqrt(sqrt(x))``, despite being an inexact result; in cases where ``x`` is ``-0.0`` or ``-inf``.; Defaults to ``-fno-approx-func``. .. option:: -f[no-]signed-zeros. Allow optimizations that ignore the sign of floating point zeros.; Defaults to ``-fsigned-zeros``. .. option:: -f[no-]associative-math. Allow floating point operations to be reassociated.; Defaults to ``-fno-associative-math``. .. option:: -f[no-]reciprocal-math. Allow division operations to be transformed into multiplication by a; reciprocal. This can be significantly faster than an ordinary division; but can also have significantly less precision. Defaults to; ``-fno-reciprocal-math``. .. option:: -f[no-]unsafe-math-optimizations. Allow unsafe floating-point optimizations.; ``-funsafe-math-optimizations`` also implies:. * ``-fapprox-func``; * ``-fassociative-math``; * ``-freciprocal-math``; * ``-fno-signed-zeros``; * ``-fno-trapping-math``; * ``-ffp-contract=fast``. ``-fno-unsafe-math-optimizations`` implies:. * ``-fno-approx-func``; * ``-fno-associative-math``; * ``-fno-reciprocal-math``; * ``-fsigned-zeros``; * ``-ftrapping-math``; * ``-ffp-contract=on``; * ``-fdenormal-fp-math=ieee``. There is ambiguity about how ``-ffp-contract``,; ``-funsafe-math-optimizations``, and ``-fno-unsafe-math-optimizations``; behave when combined. Explanation in :option:`-fno-fast-math` also applies; to these options. Defaults to ``-fno-unsafe-math-optimizations``. .. option:: -f[no-]finite-math-only. Allow floating-point optimizations that assume arguments and results are; not NaNs or +-Inf. ``-ffinite-math-only`` defines the; ``__FINITE_MATH_ONLY__`` preprocessor macro.; ``-ffinite-math-only`` implies:. * `",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:59250,Safety,unsafe,unsafe,59250,"nly``. .. option:: -f[no-]approx-func. Allow certain math function calls (such as ``log``, ``sqrt``, ``pow``, etc); to be replaced with an approximately equivalent set of instructions; or alternative math function calls. For example, a ``pow(x, 0.25)``; may be replaced with ``sqrt(sqrt(x))``, despite being an inexact result; in cases where ``x`` is ``-0.0`` or ``-inf``.; Defaults to ``-fno-approx-func``. .. option:: -f[no-]signed-zeros. Allow optimizations that ignore the sign of floating point zeros.; Defaults to ``-fsigned-zeros``. .. option:: -f[no-]associative-math. Allow floating point operations to be reassociated.; Defaults to ``-fno-associative-math``. .. option:: -f[no-]reciprocal-math. Allow division operations to be transformed into multiplication by a; reciprocal. This can be significantly faster than an ordinary division; but can also have significantly less precision. Defaults to; ``-fno-reciprocal-math``. .. option:: -f[no-]unsafe-math-optimizations. Allow unsafe floating-point optimizations.; ``-funsafe-math-optimizations`` also implies:. * ``-fapprox-func``; * ``-fassociative-math``; * ``-freciprocal-math``; * ``-fno-signed-zeros``; * ``-fno-trapping-math``; * ``-ffp-contract=fast``. ``-fno-unsafe-math-optimizations`` implies:. * ``-fno-approx-func``; * ``-fno-associative-math``; * ``-fno-reciprocal-math``; * ``-fsigned-zeros``; * ``-ftrapping-math``; * ``-ffp-contract=on``; * ``-fdenormal-fp-math=ieee``. There is ambiguity about how ``-ffp-contract``,; ``-funsafe-math-optimizations``, and ``-fno-unsafe-math-optimizations``; behave when combined. Explanation in :option:`-fno-fast-math` also applies; to these options. Defaults to ``-fno-unsafe-math-optimizations``. .. option:: -f[no-]finite-math-only. Allow floating-point optimizations that assume arguments and results are; not NaNs or +-Inf. ``-ffinite-math-only`` defines the; ``__FINITE_MATH_ONLY__`` preprocessor macro.; ``-ffinite-math-only`` implies:. * ``-fno-honor-infinities``; * ``-fno-honor-na",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:59491,Safety,unsafe,unsafe-math-optimizations,59491,"(x, 0.25)``; may be replaced with ``sqrt(sqrt(x))``, despite being an inexact result; in cases where ``x`` is ``-0.0`` or ``-inf``.; Defaults to ``-fno-approx-func``. .. option:: -f[no-]signed-zeros. Allow optimizations that ignore the sign of floating point zeros.; Defaults to ``-fsigned-zeros``. .. option:: -f[no-]associative-math. Allow floating point operations to be reassociated.; Defaults to ``-fno-associative-math``. .. option:: -f[no-]reciprocal-math. Allow division operations to be transformed into multiplication by a; reciprocal. This can be significantly faster than an ordinary division; but can also have significantly less precision. Defaults to; ``-fno-reciprocal-math``. .. option:: -f[no-]unsafe-math-optimizations. Allow unsafe floating-point optimizations.; ``-funsafe-math-optimizations`` also implies:. * ``-fapprox-func``; * ``-fassociative-math``; * ``-freciprocal-math``; * ``-fno-signed-zeros``; * ``-fno-trapping-math``; * ``-ffp-contract=fast``. ``-fno-unsafe-math-optimizations`` implies:. * ``-fno-approx-func``; * ``-fno-associative-math``; * ``-fno-reciprocal-math``; * ``-fsigned-zeros``; * ``-ftrapping-math``; * ``-ffp-contract=on``; * ``-fdenormal-fp-math=ieee``. There is ambiguity about how ``-ffp-contract``,; ``-funsafe-math-optimizations``, and ``-fno-unsafe-math-optimizations``; behave when combined. Explanation in :option:`-fno-fast-math` also applies; to these options. Defaults to ``-fno-unsafe-math-optimizations``. .. option:: -f[no-]finite-math-only. Allow floating-point optimizations that assume arguments and results are; not NaNs or +-Inf. ``-ffinite-math-only`` defines the; ``__FINITE_MATH_ONLY__`` preprocessor macro.; ``-ffinite-math-only`` implies:. * ``-fno-honor-infinities``; * ``-fno-honor-nans``. ``-ffno-inite-math-only`` implies:. * ``-fhonor-infinities``; * ``-fhonor-nans``. Defaults to ``-fno-finite-math-only``. .. option:: -f[no-]rounding-math. Force floating-point operations to honor the dynamically-set rounding mode by de",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:59803,Safety,unsafe,unsafe-math-optimizations,59803,"to ``-fsigned-zeros``. .. option:: -f[no-]associative-math. Allow floating point operations to be reassociated.; Defaults to ``-fno-associative-math``. .. option:: -f[no-]reciprocal-math. Allow division operations to be transformed into multiplication by a; reciprocal. This can be significantly faster than an ordinary division; but can also have significantly less precision. Defaults to; ``-fno-reciprocal-math``. .. option:: -f[no-]unsafe-math-optimizations. Allow unsafe floating-point optimizations.; ``-funsafe-math-optimizations`` also implies:. * ``-fapprox-func``; * ``-fassociative-math``; * ``-freciprocal-math``; * ``-fno-signed-zeros``; * ``-fno-trapping-math``; * ``-ffp-contract=fast``. ``-fno-unsafe-math-optimizations`` implies:. * ``-fno-approx-func``; * ``-fno-associative-math``; * ``-fno-reciprocal-math``; * ``-fsigned-zeros``; * ``-ftrapping-math``; * ``-ffp-contract=on``; * ``-fdenormal-fp-math=ieee``. There is ambiguity about how ``-ffp-contract``,; ``-funsafe-math-optimizations``, and ``-fno-unsafe-math-optimizations``; behave when combined. Explanation in :option:`-fno-fast-math` also applies; to these options. Defaults to ``-fno-unsafe-math-optimizations``. .. option:: -f[no-]finite-math-only. Allow floating-point optimizations that assume arguments and results are; not NaNs or +-Inf. ``-ffinite-math-only`` defines the; ``__FINITE_MATH_ONLY__`` preprocessor macro.; ``-ffinite-math-only`` implies:. * ``-fno-honor-infinities``; * ``-fno-honor-nans``. ``-ffno-inite-math-only`` implies:. * ``-fhonor-infinities``; * ``-fhonor-nans``. Defaults to ``-fno-finite-math-only``. .. option:: -f[no-]rounding-math. Force floating-point operations to honor the dynamically-set rounding mode by default. The result of a floating-point operation often cannot be exactly represented in the result type and therefore must be rounded. IEEE 754 describes different rounding modes that control how to perform this rounding, not all of which are supported by all implementations.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:59945,Safety,unsafe,unsafe-math-optimizations,59945,"o-]reciprocal-math. Allow division operations to be transformed into multiplication by a; reciprocal. This can be significantly faster than an ordinary division; but can also have significantly less precision. Defaults to; ``-fno-reciprocal-math``. .. option:: -f[no-]unsafe-math-optimizations. Allow unsafe floating-point optimizations.; ``-funsafe-math-optimizations`` also implies:. * ``-fapprox-func``; * ``-fassociative-math``; * ``-freciprocal-math``; * ``-fno-signed-zeros``; * ``-fno-trapping-math``; * ``-ffp-contract=fast``. ``-fno-unsafe-math-optimizations`` implies:. * ``-fno-approx-func``; * ``-fno-associative-math``; * ``-fno-reciprocal-math``; * ``-fsigned-zeros``; * ``-ftrapping-math``; * ``-ffp-contract=on``; * ``-fdenormal-fp-math=ieee``. There is ambiguity about how ``-ffp-contract``,; ``-funsafe-math-optimizations``, and ``-fno-unsafe-math-optimizations``; behave when combined. Explanation in :option:`-fno-fast-math` also applies; to these options. Defaults to ``-fno-unsafe-math-optimizations``. .. option:: -f[no-]finite-math-only. Allow floating-point optimizations that assume arguments and results are; not NaNs or +-Inf. ``-ffinite-math-only`` defines the; ``__FINITE_MATH_ONLY__`` preprocessor macro.; ``-ffinite-math-only`` implies:. * ``-fno-honor-infinities``; * ``-fno-honor-nans``. ``-ffno-inite-math-only`` implies:. * ``-fhonor-infinities``; * ``-fhonor-nans``. Defaults to ``-fno-finite-math-only``. .. option:: -f[no-]rounding-math. Force floating-point operations to honor the dynamically-set rounding mode by default. The result of a floating-point operation often cannot be exactly represented in the result type and therefore must be rounded. IEEE 754 describes different rounding modes that control how to perform this rounding, not all of which are supported by all implementations. C provides interfaces (``fesetround`` and ``fesetenv``) for dynamically controlling the rounding mode, and while it also recommends certain conventions for changing th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:62393,Safety,safe,safe,62393,"ation of global variables and local ``static`` variables. Floating-point operations in these contexts will be rounded using ``FE_TONEAREST``. - The option ``-fno-rounding-math`` allows the compiler to assume that the rounding mode is set to ``FE_TONEAREST``. This is the default.; - The option ``-frounding-math`` forces the compiler to honor the dynamically-set rounding mode. This prevents optimizations which might affect results if the rounding mode changes or is different from the default; for example, it prevents floating-point operations from being reordered across most calls and prevents constant-folding when the result is not exactly representable. .. option:: -ffp-model=<value>. Specify floating point behavior. ``-ffp-model`` is an umbrella; option that encompasses functionality provided by other, single; purpose, floating point options. Valid values are: ``precise``, ``strict``,; and ``fast``.; Details:. * ``precise`` Disables optimizations that are not value-safe on; floating-point data, although FP contraction (FMA) is enabled; (``-ffp-contract=on``). This is the default behavior. This value resets; ``-fmath-errno`` to its target-dependent default.; * ``strict`` Enables ``-frounding-math`` and; ``-ffp-exception-behavior=strict``, and disables contractions (FMA). All; of the ``-ffast-math`` enablements are disabled. Enables; ``STDC FENV_ACCESS``: by default ``FENV_ACCESS`` is disabled. This option; setting behaves as though ``#pragma STDC FENV_ACCESS ON`` appeared at the; top of the source file.; * ``fast`` Behaves identically to specifying both ``-ffast-math`` and; ``ffp-contract=fast``. Note: If your command line specifies multiple instances; of the ``-ffp-model`` option, or if your command line option specifies; ``-ffp-model`` and later on the command line selects a floating point; option that has the effect of negating part of the ``ffp-model`` that; has been selected, then the compiler will issue a diagnostic warning; that the override has occurred. .. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:63766,Safety,avoid,avoids,63766,"FENV_ACCESS`` is disabled. This option; setting behaves as though ``#pragma STDC FENV_ACCESS ON`` appeared at the; top of the source file.; * ``fast`` Behaves identically to specifying both ``-ffast-math`` and; ``ffp-contract=fast``. Note: If your command line specifies multiple instances; of the ``-ffp-model`` option, or if your command line option specifies; ``-ffp-model`` and later on the command line selects a floating point; option that has the effect of negating part of the ``ffp-model`` that; has been selected, then the compiler will issue a diagnostic warning; that the override has occurred. .. option:: -ffp-exception-behavior=<value>. Specify the floating-point exception behavior. Valid values are: ``ignore``, ``maytrap``, and ``strict``.; The default value is ``ignore``. Details:. * ``ignore`` The compiler assumes that the exception status flags will not be read and that floating point exceptions will be masked.; * ``maytrap`` The compiler avoids transformations that may raise exceptions that would not have been raised by the original code. Constant folding performed by the compiler is exempt from this option.; * ``strict`` The compiler ensures that all transformations strictly preserve the floating point exception semantics of the original code. .. option:: -ffp-eval-method=<value>. Specify the floating-point evaluation method for intermediate results within; a single expression of the code. Valid values are: ``source``, ``double``, and ``extended``.; For 64-bit targets, the default value is ``source``. For 32-bit x86 targets; however, in the case of NETBSD 6.99.26 and under, the default value is; ``double``; in the case of NETBSD greater than 6.99.26, with NoSSE, the; default value is ``extended``, with SSE the default value is ``source``.; Details:. * ``source`` The compiler uses the floating-point type declared in the source program as the evaluation method.; * ``double`` The compiler uses ``double`` as the floating-point evaluation method for all float",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:66071,Safety,safe,safe,66071,"d vectors of these types. Some arithmetic; expression transformations that are mathematically correct and permissible; according to the C and C++ language standards may be incorrect when dealing; with floating-point types, such as reassociation and distribution. Further,; the optimizer may ignore parentheses when computing arithmetic expressions; in circumstances where the parenthesized and unparenthesized expression; express the same mathematical value. For example (a+b)+c is the same; mathematical value as a+(b+c), but the optimizer is free to evaluate the; additions in any order regardless of the parentheses. When enabled, this; option forces the optimizer to honor the order of operations with respect; to parentheses in all circumstances.; Defaults to ``-fno-protect-parens``. Note that floating-point contraction (option `-ffp-contract=`) is disabled; when `-fprotect-parens` is enabled. Also note that in safe floating-point; modes, such as `-ffp-model=precise` or `-ffp-model=strict`, this option; has no effect because the optimizer is prohibited from making unsafe; transformations. .. option:: -fexcess-precision:. The C and C++ standards allow floating-point expressions to be computed as if; intermediate results had more precision (and/or a wider range) than the type; of the expression strictly allows. This is called excess precision; arithmetic.; Excess precision arithmetic can improve the accuracy of results (although not; always), and it can make computation significantly faster if the target lacks; direct hardware support for arithmetic in a particular type. However, it can; also undermine strict floating-point reproducibility. Under the standards, assignments and explicit casts force the operand to be; converted to its formal type, discarding any excess precision. Because data; can only flow between statements via an assignment, this means that the use; of excess precision arithmetic is a reliable local property of a single; statement, and results do not chang",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:66227,Safety,unsafe,unsafe,66227,"d vectors of these types. Some arithmetic; expression transformations that are mathematically correct and permissible; according to the C and C++ language standards may be incorrect when dealing; with floating-point types, such as reassociation and distribution. Further,; the optimizer may ignore parentheses when computing arithmetic expressions; in circumstances where the parenthesized and unparenthesized expression; express the same mathematical value. For example (a+b)+c is the same; mathematical value as a+(b+c), but the optimizer is free to evaluate the; additions in any order regardless of the parentheses. When enabled, this; option forces the optimizer to honor the order of operations with respect; to parentheses in all circumstances.; Defaults to ``-fno-protect-parens``. Note that floating-point contraction (option `-ffp-contract=`) is disabled; when `-fprotect-parens` is enabled. Also note that in safe floating-point; modes, such as `-ffp-model=precise` or `-ffp-model=strict`, this option; has no effect because the optimizer is prohibited from making unsafe; transformations. .. option:: -fexcess-precision:. The C and C++ standards allow floating-point expressions to be computed as if; intermediate results had more precision (and/or a wider range) than the type; of the expression strictly allows. This is called excess precision; arithmetic.; Excess precision arithmetic can improve the accuracy of results (although not; always), and it can make computation significantly faster if the target lacks; direct hardware support for arithmetic in a particular type. However, it can; also undermine strict floating-point reproducibility. Under the standards, assignments and explicit casts force the operand to be; converted to its formal type, discarding any excess precision. Because data; can only flow between statements via an assignment, this means that the use; of excess precision arithmetic is a reliable local property of a single; statement, and results do not chang",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:71432,Safety,avoid,avoid,71432,"re the possibility of floating-point exceptions by default. Both of these can be used either at the start of a block scope, in which case; they cover all code in that scope (unless they're turned off in a child scope),; or at the top level in a file, in which case they cover all subsequent function; bodies until they're turned off. Note that it is undefined behavior to enter; code that is *not* covered by one of these pragmas from code that *is* covered; by one of these pragmas unless the floating point environment has been restored; to its default state. See the C standard for more information about these pragmas. The command line option ``-frounding-math`` behaves as if the translation unit; began with ``#pragma STDC FENV_ROUND FE_DYNAMIC``. The command line option; ``-ffp-model=strict`` behaves as if the translation unit began with ``#pragma STDC FENV_ACCESS ON``. Code that just wants to use a specific rounding mode for specific floating point; operations can avoid most of the hazards of the dynamic floating point environment; by using ``#pragma STDC FENV_ROUND`` with a value other than ``FE_DYNAMIC``. .. _crtfastmath.o:. A note about ``crtfastmath.o``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ``-ffast-math`` and ``-funsafe-math-optimizations`` cause ``crtfastmath.o`` to be; automatically linked, which adds a static constructor that sets the FTZ/DAZ; bits in MXCSR, affecting not only the current compilation unit but all static; and shared libraries included in the program. .. _FLT_EVAL_METHOD:. A note about ``__FLT_EVAL_METHOD__``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; The ``__FLT_EVAL_METHOD__`` is not defined as a traditional macro, and so it; will not appear when dumping preprocessor macros. Instead, the value; ``__FLT_EVAL_METHOD__`` expands to is determined at the point of expansion; either from the value set by the ``-ffp-eval-method`` command line option or; from the target. This is because the ``__FLT_EVAL_METHOD__`` macro; cannot expand to the correct evaluation m",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:71450,Safety,hazard,hazards,71450,"re the possibility of floating-point exceptions by default. Both of these can be used either at the start of a block scope, in which case; they cover all code in that scope (unless they're turned off in a child scope),; or at the top level in a file, in which case they cover all subsequent function; bodies until they're turned off. Note that it is undefined behavior to enter; code that is *not* covered by one of these pragmas from code that *is* covered; by one of these pragmas unless the floating point environment has been restored; to its default state. See the C standard for more information about these pragmas. The command line option ``-frounding-math`` behaves as if the translation unit; began with ``#pragma STDC FENV_ROUND FE_DYNAMIC``. The command line option; ``-ffp-model=strict`` behaves as if the translation unit began with ``#pragma STDC FENV_ACCESS ON``. Code that just wants to use a specific rounding mode for specific floating point; operations can avoid most of the hazards of the dynamic floating point environment; by using ``#pragma STDC FENV_ROUND`` with a value other than ``FE_DYNAMIC``. .. _crtfastmath.o:. A note about ``crtfastmath.o``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; ``-ffast-math`` and ``-funsafe-math-optimizations`` cause ``crtfastmath.o`` to be; automatically linked, which adds a static constructor that sets the FTZ/DAZ; bits in MXCSR, affecting not only the current compilation unit but all static; and shared libraries included in the program. .. _FLT_EVAL_METHOD:. A note about ``__FLT_EVAL_METHOD__``; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; The ``__FLT_EVAL_METHOD__`` is not defined as a traditional macro, and so it; will not appear when dumping preprocessor macros. Instead, the value; ``__FLT_EVAL_METHOD__`` expands to is determined at the point of expansion; either from the value set by the ``-ffp-eval-method`` command line option or; from the target. This is because the ``__FLT_EVAL_METHOD__`` macro; cannot expand to the correct evaluation m",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:75297,Safety,detect,detector,75297,"on’’). All computation for initialization of objects; that have static or thread storage duration is done (as if) at translation; time.* C++ generalizes this by adding another phase of initialization; (at runtime) if the translation-time initialization fails, but the; translation-time evaluation of the initializer of succeeds, it will be; treated as a constant initializer. .. _controlling-code-generation:. Controlling Code Generation; ---------------------------. Clang provides a number of ways to control code generation. The options; are listed below. .. option:: -f[no-]sanitize=check1,check2,... Turn on runtime checks for various forms of undefined or suspicious; behavior. This option controls whether Clang adds runtime checks for various; forms of undefined or suspicious behavior, and is disabled by; default. If a check fails, a diagnostic message is produced at; runtime explaining the problem. The main checks are:. - .. _opt_fsanitize_address:. ``-fsanitize=address``:; :doc:`AddressSanitizer`, a memory error; detector.; - .. _opt_fsanitize_thread:. ``-fsanitize=thread``: :doc:`ThreadSanitizer`, a data race detector.; - .. _opt_fsanitize_memory:. ``-fsanitize=memory``: :doc:`MemorySanitizer`,; a detector of uninitialized reads. Requires instrumentation of all; program code.; - .. _opt_fsanitize_undefined:. ``-fsanitize=undefined``: :doc:`UndefinedBehaviorSanitizer`,; a fast and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:75396,Safety,detect,detector,75396,"one (as if) at translation; time.* C++ generalizes this by adding another phase of initialization; (at runtime) if the translation-time initialization fails, but the; translation-time evaluation of the initializer of succeeds, it will be; treated as a constant initializer. .. _controlling-code-generation:. Controlling Code Generation; ---------------------------. Clang provides a number of ways to control code generation. The options; are listed below. .. option:: -f[no-]sanitize=check1,check2,... Turn on runtime checks for various forms of undefined or suspicious; behavior. This option controls whether Clang adds runtime checks for various; forms of undefined or suspicious behavior, and is disabled by; default. If a check fails, a diagnostic message is produced at; runtime explaining the problem. The main checks are:. - .. _opt_fsanitize_address:. ``-fsanitize=address``:; :doc:`AddressSanitizer`, a memory error; detector.; - .. _opt_fsanitize_thread:. ``-fsanitize=thread``: :doc:`ThreadSanitizer`, a data race detector.; - .. _opt_fsanitize_memory:. ``-fsanitize=memory``: :doc:`MemorySanitizer`,; a detector of uninitialized reads. Requires instrumentation of all; program code.; - .. _opt_fsanitize_undefined:. ``-fsanitize=undefined``: :doc:`UndefinedBehaviorSanitizer`,; a fast and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:75486,Safety,detect,detector,75486,"time) if the translation-time initialization fails, but the; translation-time evaluation of the initializer of succeeds, it will be; treated as a constant initializer. .. _controlling-code-generation:. Controlling Code Generation; ---------------------------. Clang provides a number of ways to control code generation. The options; are listed below. .. option:: -f[no-]sanitize=check1,check2,... Turn on runtime checks for various forms of undefined or suspicious; behavior. This option controls whether Clang adds runtime checks for various; forms of undefined or suspicious behavior, and is disabled by; default. If a check fails, a diagnostic message is produced at; runtime explaining the problem. The main checks are:. - .. _opt_fsanitize_address:. ``-fsanitize=address``:; :doc:`AddressSanitizer`, a memory error; detector.; - .. _opt_fsanitize_thread:. ``-fsanitize=thread``: :doc:`ThreadSanitizer`, a data race detector.; - .. _opt_fsanitize_memory:. ``-fsanitize=memory``: :doc:`MemorySanitizer`,; a detector of uninitialized reads. Requires instrumentation of all; program code.; - .. _opt_fsanitize_undefined:. ``-fsanitize=undefined``: :doc:`UndefinedBehaviorSanitizer`,; a fast and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:75999,Safety,safe,safe-stack,75999," suspicious behavior, and is disabled by; default. If a check fails, a diagnostic message is produced at; runtime explaining the problem. The main checks are:. - .. _opt_fsanitize_address:. ``-fsanitize=address``:; :doc:`AddressSanitizer`, a memory error; detector.; - .. _opt_fsanitize_thread:. ``-fsanitize=thread``: :doc:`ThreadSanitizer`, a data race detector.; - .. _opt_fsanitize_memory:. ``-fsanitize=memory``: :doc:`MemorySanitizer`,; a detector of uninitialized reads. Requires instrumentation of all; program code.; - .. _opt_fsanitize_undefined:. ``-fsanitize=undefined``: :doc:`UndefinedBehaviorSanitizer`,; a fast and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitize",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:76019,Safety,safe,safe,76019," suspicious behavior, and is disabled by; default. If a check fails, a diagnostic message is produced at; runtime explaining the problem. The main checks are:. - .. _opt_fsanitize_address:. ``-fsanitize=address``:; :doc:`AddressSanitizer`, a memory error; detector.; - .. _opt_fsanitize_thread:. ``-fsanitize=thread``: :doc:`ThreadSanitizer`, a data race detector.; - .. _opt_fsanitize_memory:. ``-fsanitize=memory``: :doc:`MemorySanitizer`,; a detector of uninitialized reads. Requires instrumentation of all; program code.; - .. _opt_fsanitize_undefined:. ``-fsanitize=undefined``: :doc:`UndefinedBehaviorSanitizer`,; a fast and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitize",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:76236,Safety,detect,detected,76236,"opt_fsanitize_address:. ``-fsanitize=address``:; :doc:`AddressSanitizer`, a memory error; detector.; - .. _opt_fsanitize_thread:. ``-fsanitize=thread``: :doc:`ThreadSanitizer`, a data race detector.; - .. _opt_fsanitize_memory:. ``-fsanitize=memory``: :doc:`MemorySanitizer`,; a detector of uninitialized reads. Requires instrumentation of all; program code.; - .. _opt_fsanitize_undefined:. ``-fsanitize=undefined``: :doc:`UndefinedBehaviorSanitizer`,; a fast and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:76618,Safety,recover,recover,76618,"fined``: :doc:`UndefinedBehaviorSanitizer`,; a fast and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:76672,Safety,recover,recover,76672,"t and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effec",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:76837,Safety,detect,detected,76837,"``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:77060,Safety,recover,recovery,77060,"tack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binar",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:77180,Safety,detect,detected,77180," see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only com",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:77627,Safety,recover,recover,77627,"r=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ign",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:83060,Safety,abort,abort,83060," C++'s global; new operator will always return a pointer that does not alias any; other pointer when the function returns. .. option:: -fassume-nothrow-exception-dtor. Assume that an exception object' destructor will not throw, and generate; less code for catch handlers. A throw expression of a type with a; potentially-throwing destructor will lead to an error. By default, Clang assumes that the exception object may have a throwing; destructor. For the Itanium C++ ABI, Clang generates a landing pad to; destroy local variables and call ``_Unwind_Resume`` for the code; ``catch (...) { ... }``. This option tells Clang that an exception object's; destructor will not throw and code simplification is possible. .. option:: -ftrap-function=[name]. Instruct code generator to emit a function call to the specified; function name for ``__builtin_trap()``. LLVM code generator translates ``__builtin_trap()`` to a trap; instruction if it is supported by the target ISA. Otherwise, the; builtin is translated into a call to ``abort``. If this option is; set, then the code generator will always lower the builtin to a call; to the specified function regardless of whether the target ISA has a; trap instruction. This option is useful for environments (e.g.; deeply embedded) where a trap cannot be properly handled, or when; some custom behavior is desired. .. option:: -ftls-model=[model]. Select which TLS model to use. Valid values are: ``global-dynamic``, ``local-dynamic``,; ``initial-exec`` and ``local-exec``. The default value is; ``global-dynamic``. The compiler may use a different model if the; selected model is not supported by the target, or if a more; efficient model can be used. The TLS model can be overridden per; variable using the ``tls_model`` attribute. .. option:: -femulated-tls. Select emulated TLS model, which overrides all -ftls-model choices. In emulated TLS mode, all access to TLS variables are converted to; calls to __emutls_get_address in the runtime library. .. opti",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:86794,Safety,safe,safe,86794,"cators do; not promise to return memory that is more than 8-byte or 16-byte-aligned. Use; this option to limit the alignment that the compiler can assume for an arbitrary; pointer, which may point onto the heap. This option does not affect the ABI alignment of types; the layout of structs and; unions and the value returned by the alignof operator remain the same. This option can be overridden on a case-by-case basis by putting an explicit; “aligned” alignment on a struct, union, or typedef. For example:. .. code-block:: console. #include <immintrin.h>; // Make an aligned typedef of the AVX-512 16-int vector type.; typedef __v16si __aligned_v16si __attribute__((aligned(64)));. void initialize_vector(__aligned_v16si *v) {; // The compiler may assume that ‘v’ is 64-byte aligned, regardless of the; // value of -fmax-type-align.; }. .. option:: -faddrsig, -fno-addrsig. Controls whether Clang emits an address-significance table into the object; file. Address-significance tables allow linkers to implement `safe ICF; <https://research.google.com/pubs/archive/36912.pdf>`_ without the false; positives that can result from other implementation techniques such as; relocation scanning. Address-significance tables are enabled by default; on ELF targets when using the integrated assembler. This flag currently; only has an effect on ELF targets. .. option:: -f[no]-unique-internal-linkage-names. Controls whether Clang emits a unique (best-effort) symbol name for internal; linkage symbols. When this option is set, compiler hashes the main source; file path from the command line and appends it to all internal symbols. If a; program contains multiple objects compiled with the same command-line source; file path, the symbols are not guaranteed to be unique. This option is; particularly useful in attributing profile information to the correct; function when multiple functions with the same private linkage name exist; in the binary. It should be noted that this option cannot guarantee uniq",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:105107,Safety,avoid,avoid,105107,"ttern specified; can include different modifiers: ``%p``, ``%h``, ``%m``, ``%t``, and ``%c``. Any instance of ``%p`` in that file name will be replaced by the process; ID, so that you can easily distinguish the profile output from multiple; runs. .. code-block:: console. $ LLVM_PROFILE_FILE=""code-%p.profraw"" ./code. The modifier ``%h`` can be used in scenarios where the same instrumented; binary is run in multiple different host machines dumping profile data; to a shared network based storage. The ``%h`` specifier will be substituted; with the hostname so that profiles collected from different hosts do not; clobber each other. While the use of ``%p`` specifier can reduce the likelihood for the profiles; dumped from different processes to clobber each other, such clobbering can still; happen because of the ``pid`` re-use by the OS. Another side-effect of using; ``%p`` is that the storage requirement for raw profile data files is greatly; increased. To avoid issues like this, the ``%m`` specifier can used in the profile; name. When this specifier is used, the profiler runtime will substitute ``%m``; with a unique integer identifier associated with the instrumented binary. Additionally,; multiple raw profiles dumped from different processes that share a file system (can be; on different hosts) will be automatically merged by the profiler runtime during the; dumping. If the program links in multiple instrumented shared libraries, each library; will dump the profile data into its own profile data file (with its unique integer; id embedded in the profile name). Note that the merging enabled by ``%m`` is for raw; profile data generated by profiler runtime. The resulting merged ""raw"" profile data; file still needs to be converted to a different format expected by the compiler (; see step 3 below). .. code-block:: console. $ LLVM_PROFILE_FILE=""code-%m.profraw"" ./code. See `this <SourceBasedCodeCoverage.html#running-the-instrumented-program>`_ section; about the ``%t``, and ``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:107885,Safety,risk,risk,107885,"the; profile. As you make changes to your code, clang may no longer be able to; use the profile data. It will warn you when this happens. Note that ``-fprofile-use`` option is semantically equivalent to; its GCC counterpart, it *does not* handle profile formats produced by GCC.; Both ``-fprofile-use`` and ``-fprofile-instr-use`` accept profiles in the; indexed format, regardeless whether it is produced by frontend or the IR pass. .. option:: -fprofile-generate[=<dirname>]. The ``-fprofile-generate`` and ``-fprofile-generate=`` flags will use; an alternative instrumentation method for profile generation. When; given a directory name, it generates the profile file; ``default_%m.profraw`` in the directory named ``dirname`` if specified.; If ``dirname`` does not exist, it will be created at runtime. ``%m`` specifier; will be substituted with a unique id documented in step 2 above. In other words,; with ``-fprofile-generate[=<dirname>]`` option, the ""raw"" profile data automatic; merging is turned on by default, so there will no longer any risk of profile; clobbering from different running processes. For example,. .. code-block:: console. $ clang++ -O2 -fprofile-generate=yyy/zzz code.cc -o code. When ``code`` is executed, the profile will be written to the file; ``yyy/zzz/default_xxxx.profraw``. To generate the profile data file with the compiler readable format, the; ``llvm-profdata`` tool can be used with the profile directory as the input:. .. code-block:: console. $ llvm-profdata merge -output=code.profdata yyy/zzz/. If the user wants to turn off the auto-merging feature, or simply override the; the profile dumping path specified at command line, the environment variable; ``LLVM_PROFILE_FILE`` can still be used to override; the directory and filename for the profile file at runtime.; To override the path and filename at compile time, use; ``-Xclang -fprofile-instrument-path=/path/to/file_pattern.profraw``. .. option:: -fcs-profile-generate[=<dirname>]. The ``-fcs-prof",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:117525,Safety,unsafe,unsafe,117525,"ng++ -O2 -fprofile-instr-generate -fprofile-list=fun.list code.cc -o code. The option can be specified multiple times to pass multiple files. .. code-block:: console. $ clang++ -O2 -fprofile-instr-generate -fcoverage-mapping -fprofile-list=fun.list -fprofile-list=code.list code.cc -o code. Supported sections are ``[clang]``, ``[llvm]``, and ``[csllvm]`` representing; clang PGO, IRPGO, and CSIRPGO, respectively. Supported prefixes are ``function``; and ``source``. Supported categories are ``allow``, ``skip``, and ``forbid``.; ``skip`` adds the ``skipprofile`` attribute while ``forbid`` adds the; ``noprofile`` attribute to the appropriate function. Use; ``default:<allow|skip|forbid>`` to specify the default category. .. code-block:: console. $ cat fun.list; # The following cases are for clang instrumentation.; [clang]. # We might not want to profile functions that are inlined in many places.; function:inlinedLots=skip. # We want to forbid profiling where it might be dangerous.; source:lib/unsafe/*.cc=forbid. # Otherwise we allow profiling.; default:allow. Older Prefixes; """"""""""""""""""""""""""""; An older format is also supported, but it is only able to add the; ``noprofile`` attribute.; To filter individual functions or entire source files use ``fun:<name>`` or; ``src:<file>`` respectively. To exclude a function or a source file, use; ``!fun:<name>`` or ``!src:<file>`` respectively. The format also supports; wildcard expansion. The compiler generated functions are assumed to be located; in the main source file. It is also possible to restrict the filter to a; particular instrumentation type by using a named section. .. code-block:: none. # all functions whose name starts with foo will be instrumented.; fun:foo*. # except for foo1 which will be excluded from instrumentation.; !fun:foo1. # every function in path/to/foo.cc will be instrumented.; src:path/to/foo.cc. # bar will be instrumented only when using backend instrumentation.; # Recognized section names are clang, llvm and ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:148857,Safety,avoid,avoid,148857," the support available in the specific; architecture. It is possible to alter the default extensions setting per target using; ``-cl-ext`` flag. (See :ref:`flags description <opencl_cl_ext>` for more details). Vendor extensions can be added flexibly by declaring the list of types and; functions associated with each extensions enclosed within the following; compiler pragma directives:. .. code-block:: c. #pragma OPENCL EXTENSION the_new_extension_name : begin; // declare types and functions associated with the extension here; #pragma OPENCL EXTENSION the_new_extension_name : end. For example, parsing the following code adds ``my_t`` type and ``my_func``; function to the custom ``my_ext`` extension. .. code-block:: c. #pragma OPENCL EXTENSION my_ext : begin; typedef struct{; int a;; }my_t;; void my_func(my_t);; #pragma OPENCL EXTENSION my_ext : end. There is no conflict resolution for identifier clashes among extensions.; It is therefore recommended that the identifiers are prefixed with a; double underscore to avoid clashing with user space identifiers. Vendor; extension should use reserved identifier prefix e.g. amd, arm, intel. Clang also supports language extensions documented in `The OpenCL C Language; Extensions Documentation; <https://github.com/KhronosGroup/Khronosdotorg/blob/main/api/opencl/assets/OpenCL_LangExt.pdf>`_. OpenCL-Specific Attributes; --------------------------. OpenCL support in Clang contains a set of attribute taken directly from the; specification as well as additional attributes. See also :doc:`AttributeReference`. nosvm; ^^^^^. Clang supports this attribute to comply to OpenCL v2.0 conformance, but it; does not have any effect on the IR. For more details reffer to the specification; `section 6.7.2; <https://www.khronos.org/registry/cl/specs/opencl-2.0-openclc.pdf#49>`_. opencl_unroll_hint; ^^^^^^^^^^^^^^^^^^. The implementation of this feature mirrors the unroll hint for C.; More details on the syntax can be found in the specification; `sec",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:151957,Safety,safe,safe,151957,"ibute; would prevent this:. .. code-block:: c. my_sub_group_shuffle() __attribute__((convergent));. Using ``convergent`` guarantees correct execution by keeping CFG equivalence; wrt operations marked as ``convergent``. CFG ``G´`` is equivalent to ``G`` wrt; node ``Ni`` : ``iff ∀ Nj (i≠j)`` domination and post-domination relations with; respect to ``Ni`` remain the same in both ``G`` and ``G´``. noduplicate; ^^^^^^^^^^^. ``noduplicate`` is more restrictive with respect to optimizations than; ``convergent`` because a convergent function only preserves CFG equivalence.; This allows some optimizations to happen as long as the control flow remains; unmodified. .. code-block:: c. for (int i=0; i<4; i++); my_sub_group_shuffle(). can be modified to:. .. code-block:: c. my_sub_group_shuffle();; my_sub_group_shuffle();; my_sub_group_shuffle();; my_sub_group_shuffle();. while using ``noduplicate`` would disallow this. Also ``noduplicate`` doesn't; have the same safe semantics of CFG as ``convergent`` and can cause changes in; CFG that modify semantics of the original program. ``noduplicate`` is kept for backwards compatibility only and it considered to be; deprecated for future uses. .. _cxx_for_opencl:. C++ for OpenCL; --------------. Starting from clang 9 kernel code can contain C++17 features: classes, templates,; function overloading, type deduction, etc. Please note that this is not an; implementation of `OpenCL C++; <https://www.khronos.org/registry/OpenCL/specs/2.2/pdf/OpenCL_Cxx.pdf>`_ and; there is no plan to support it in clang in any new releases in the near future. Clang currently supports C++ for OpenCL 1.0 and 2021.; For detailed information about this language refer to the C++ for OpenCL; Programming Language Documentation available; in `the latest build; <https://www.khronos.org/opencl/assets/CXX_for_OpenCL.html>`_; or in `the official release; <https://github.com/KhronosGroup/OpenCL-Docs/releases/tag/cxxforopencl-docrev2021.12>`_. To enable the C++ for OpenCL m",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:159561,Safety,avoid,avoid,159561,"tructions at a maximum vector; length of 512 bits, which is a superset of instructions ``-mavx10.N`` enabled. Current binaries built with AVX512 features can run on Intel AVX10/512 capable; processors without re-compile, but cannot run on AVX10/256 capable processors.; Users need to re-compile their code with ``-mavx10.N``, and maybe update some; code that calling to 512-bit X86 specific intrinsics and passing or returning; 512-bit vector types in function call, if they want to run on AVX10/256 capable; processors. Binaries built with ``-mavx10.N`` can run on both AVX10/256 and; AVX10/512 capable processors. Users can add a ``-mno-evex512`` in the command line with AVX512 options if; they want to run the binary on both legacy AVX512 and new AVX10/256 capable; processors. The option has the same constraints as ``-mavx10.N``, i.e.,; cannot call to 512-bit X86 specific intrinsics and pass or return 512-bit vector; types in function call. Users should avoid using AVX512 features in function target attributes when; developing code for AVX10. If they have to do so, they need to add an explicit; ``evex512`` or ``no-evex512`` together with AVX512 features for 512-bit or; non-512-bit functions respectively to avoid unexpected code generation. Both; command line option and target attribute of EVEX512 feature can only be used; with AVX512. They don't affect vector size of AVX10. User should not mix the use AVX10 and AVX512 options together at any time,; because the option combinations are conflicting sometimes. For example, a; combination of ``-mavx512f -mavx10.1-256`` doesn't show a clear intention to; compiler, since instructions in AVX512F and AVX10.1/256 intersect but do not; overlap. In this case, compiler will emit warning for it, but the behavior; is determined. It will generate the same code as option ``-mavx10.1-512``.; A similar case is ``-mavx512f -mavx10.2-256``, which equals to; ``-mavx10.1-512 -mavx10.2-256``, because ``avx10.2-256`` implies ``avx10.1-256``; and ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:159819,Safety,avoid,avoid,159819,"s can run on Intel AVX10/512 capable; processors without re-compile, but cannot run on AVX10/256 capable processors.; Users need to re-compile their code with ``-mavx10.N``, and maybe update some; code that calling to 512-bit X86 specific intrinsics and passing or returning; 512-bit vector types in function call, if they want to run on AVX10/256 capable; processors. Binaries built with ``-mavx10.N`` can run on both AVX10/256 and; AVX10/512 capable processors. Users can add a ``-mno-evex512`` in the command line with AVX512 options if; they want to run the binary on both legacy AVX512 and new AVX10/256 capable; processors. The option has the same constraints as ``-mavx10.N``, i.e.,; cannot call to 512-bit X86 specific intrinsics and pass or return 512-bit vector; types in function call. Users should avoid using AVX512 features in function target attributes when; developing code for AVX10. If they have to do so, they need to add an explicit; ``evex512`` or ``no-evex512`` together with AVX512 features for 512-bit or; non-512-bit functions respectively to avoid unexpected code generation. Both; command line option and target attribute of EVEX512 feature can only be used; with AVX512. They don't affect vector size of AVX10. User should not mix the use AVX10 and AVX512 options together at any time,; because the option combinations are conflicting sometimes. For example, a; combination of ``-mavx512f -mavx10.1-256`` doesn't show a clear intention to; compiler, since instructions in AVX512F and AVX10.1/256 intersect but do not; overlap. In this case, compiler will emit warning for it, but the behavior; is determined. It will generate the same code as option ``-mavx10.1-512``.; A similar case is ``-mavx512f -mavx10.2-256``, which equals to; ``-mavx10.1-512 -mavx10.2-256``, because ``avx10.2-256`` implies ``avx10.1-256``; and ``-mavx512f -mavx10.1-256`` equals to ``-mavx10.1-512``. There are some new macros introduced with AVX10 support. ``-mavx10.1-256`` will; enable ``__AVX1",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:177026,Safety,safe,safe,177026,"/utf-8 Set source and runtime encoding to UTF-8 (default); /U <macro> Undefine macro; /vd<value> Control vtordisp placement; /vmb Use a best-case representation method for member pointers; /vmg Use a most-general representation for member pointers; /vmm Set the default most-general representation to multiple inheritance; /vms Set the default most-general representation to single inheritance; /vmv Set the default most-general representation to virtual inheritance; /volatile:iso Volatile loads and stores have standard semantics; /volatile:ms Volatile loads and stores have acquire and release semantics; /W0 Disable all warnings; /W1 Enable -Wall; /W2 Enable -Wall; /W3 Enable -Wall; /W4 Enable -Wall and -Wextra; /Wall Enable -Weverything; /WX- Do not treat warnings as errors; /WX Treat warnings as errors; /w Disable all warnings; /X Don't add %INCLUDE% to the include search path; /Y- Disable precompiled headers, overrides /Yc and /Yu; /Yc<filename> Generate a pch file for all code up to and including <filename>; /Yu<filename> Load a pch file and use it instead of all code up to and including <filename>; /Z7 Enable CodeView debug information in object files; /Zc:char8_t Enable C++20 char8_t type; /Zc:char8_t- Disable C++20 char8_t type; /Zc:dllexportInlines- Don't dllexport/dllimport inline member functions of dllexport/import classes; /Zc:dllexportInlines dllexport/dllimport inline member functions of dllexport/import classes (default); /Zc:sizedDealloc- Disable C++14 sized global deallocation functions; /Zc:sizedDealloc Enable C++14 sized global deallocation functions; /Zc:strictStrings Treat string literals as const; /Zc:threadSafeInit- Disable thread-safe initialization of static variables; /Zc:threadSafeInit Enable thread-safe initialization of static variables; /Zc:trigraphs- Disable trigraphs (default); /Zc:trigraphs Enable trigraphs; /Zc:twoPhase- Disable two-phase name lookup in templates; /Zc:twoPhase Enable two-phase name lookup in templates; /Zi Alias for /Z7.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:177100,Safety,safe,safe,177100,"/utf-8 Set source and runtime encoding to UTF-8 (default); /U <macro> Undefine macro; /vd<value> Control vtordisp placement; /vmb Use a best-case representation method for member pointers; /vmg Use a most-general representation for member pointers; /vmm Set the default most-general representation to multiple inheritance; /vms Set the default most-general representation to single inheritance; /vmv Set the default most-general representation to virtual inheritance; /volatile:iso Volatile loads and stores have standard semantics; /volatile:ms Volatile loads and stores have acquire and release semantics; /W0 Disable all warnings; /W1 Enable -Wall; /W2 Enable -Wall; /W3 Enable -Wall; /W4 Enable -Wall and -Wextra; /Wall Enable -Weverything; /WX- Do not treat warnings as errors; /WX Treat warnings as errors; /w Disable all warnings; /X Don't add %INCLUDE% to the include search path; /Y- Disable precompiled headers, overrides /Yc and /Yu; /Yc<filename> Generate a pch file for all code up to and including <filename>; /Yu<filename> Load a pch file and use it instead of all code up to and including <filename>; /Z7 Enable CodeView debug information in object files; /Zc:char8_t Enable C++20 char8_t type; /Zc:char8_t- Disable C++20 char8_t type; /Zc:dllexportInlines- Don't dllexport/dllimport inline member functions of dllexport/import classes; /Zc:dllexportInlines dllexport/dllimport inline member functions of dllexport/import classes (default); /Zc:sizedDealloc- Disable C++14 sized global deallocation functions; /Zc:sizedDealloc Enable C++14 sized global deallocation functions; /Zc:strictStrings Treat string literals as const; /Zc:threadSafeInit- Disable thread-safe initialization of static variables; /Zc:threadSafeInit Enable thread-safe initialization of static variables; /Zc:trigraphs- Disable trigraphs (default); /Zc:trigraphs Enable trigraphs; /Zc:twoPhase- Disable two-phase name lookup in templates; /Zc:twoPhase Enable two-phase name lookup in templates; /Zi Alias for /Z7.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:180149,Safety,detect,detection,180149,"presenting the Microsoft compiler version; number to report in _MSC_VER (0 = don't define it; default is same value as installed cl.exe, or 1933); -fms-compatibility Enable full Microsoft Visual C++ compatibility; -fms-extensions Accept some non-standard constructs supported by the Microsoft compiler; -fmsc-version=<value> Microsoft compiler version number to report in _MSC_VER; (0 = don't define it; default is same value as installed cl.exe, or 1933); -fno-addrsig Don't emit an address-significance table; -fno-builtin-<value> Disable implicit builtin knowledge of a specific function; -fno-builtin Disable implicit builtin knowledge of functions; -fno-complete-member-pointers; Do not require member pointer base types to be complete if they would be significant under the Microsoft ABI; -fno-coverage-mapping Disable code coverage analysis; -fno-crash-diagnostics Disable auto-generation of preprocessed source files and a script for reproduction during a clang crash; -fno-debug-macro Do not emit macro debug information; -fno-delayed-template-parsing; Disable delayed template parsing; -fno-sanitize-address-poison-custom-array-cookie; Disable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fno-sanitize-address-use-after-scope; Disable use-after-scope detection in AddressSanitizer; -fno-sanitize-address-use-odr-indicator; Disable ODR indicator globals; -fno-sanitize-ignorelist Don't use ignorelist file for sanitizers; -fno-sanitize-cfi-cross-dso; Disable control flow integrity (CFI) checks for cross-DSO calls.; -fno-sanitize-coverage=<value>; Disable specified features of coverage instrumentation for Sanitizers; -fno-sanitize-memory-track-origins; Disable origins tracking in MemorySanitizer; -fno-sanitize-memory-use-after-dtor; Disable use-after-destroy detection in MemorySanitizer; -fno-sanitize-recover=<value>; Disable recovery for specified sanitizers; -fno-sanitize-stats Disable sanitizer statistics gathering.; -fno-sanitize-thread-atomics",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:180661,Safety,detect,detection,180661,icant under the Microsoft ABI; -fno-coverage-mapping Disable code coverage analysis; -fno-crash-diagnostics Disable auto-generation of preprocessed source files and a script for reproduction during a clang crash; -fno-debug-macro Do not emit macro debug information; -fno-delayed-template-parsing; Disable delayed template parsing; -fno-sanitize-address-poison-custom-array-cookie; Disable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fno-sanitize-address-use-after-scope; Disable use-after-scope detection in AddressSanitizer; -fno-sanitize-address-use-odr-indicator; Disable ODR indicator globals; -fno-sanitize-ignorelist Don't use ignorelist file for sanitizers; -fno-sanitize-cfi-cross-dso; Disable control flow integrity (CFI) checks for cross-DSO calls.; -fno-sanitize-coverage=<value>; Disable specified features of coverage instrumentation for Sanitizers; -fno-sanitize-memory-track-origins; Disable origins tracking in MemorySanitizer; -fno-sanitize-memory-use-after-dtor; Disable use-after-destroy detection in MemorySanitizer; -fno-sanitize-recover=<value>; Disable recovery for specified sanitizers; -fno-sanitize-stats Disable sanitizer statistics gathering.; -fno-sanitize-thread-atomics; Disable atomic operations instrumentation in ThreadSanitizer; -fno-sanitize-thread-func-entry-exit; Disable function entry/exit instrumentation in ThreadSanitizer; -fno-sanitize-thread-memory-access; Disable memory access instrumentation in ThreadSanitizer; -fno-sanitize-trap=<value>; Disable trapping for specified sanitizers; -fno-standalone-debug Limit debug information produced to reduce size of debug binary; -fno-strict-aliasing Disable optimizations based on strict aliasing rules (default); -fobjc-runtime=<value> Specify the target Objective-C runtime kind and version; -fprofile-exclude-files=<value>; Instrument only functions from files where names don't match all the regexes separated by a semi-colon; -fprofile-filter-files=<value>; Instrument o,MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:180705,Safety,recover,recover,180705,icant under the Microsoft ABI; -fno-coverage-mapping Disable code coverage analysis; -fno-crash-diagnostics Disable auto-generation of preprocessed source files and a script for reproduction during a clang crash; -fno-debug-macro Do not emit macro debug information; -fno-delayed-template-parsing; Disable delayed template parsing; -fno-sanitize-address-poison-custom-array-cookie; Disable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fno-sanitize-address-use-after-scope; Disable use-after-scope detection in AddressSanitizer; -fno-sanitize-address-use-odr-indicator; Disable ODR indicator globals; -fno-sanitize-ignorelist Don't use ignorelist file for sanitizers; -fno-sanitize-cfi-cross-dso; Disable control flow integrity (CFI) checks for cross-DSO calls.; -fno-sanitize-coverage=<value>; Disable specified features of coverage instrumentation for Sanitizers; -fno-sanitize-memory-track-origins; Disable origins tracking in MemorySanitizer; -fno-sanitize-memory-use-after-dtor; Disable use-after-destroy detection in MemorySanitizer; -fno-sanitize-recover=<value>; Disable recovery for specified sanitizers; -fno-sanitize-stats Disable sanitizer statistics gathering.; -fno-sanitize-thread-atomics; Disable atomic operations instrumentation in ThreadSanitizer; -fno-sanitize-thread-func-entry-exit; Disable function entry/exit instrumentation in ThreadSanitizer; -fno-sanitize-thread-memory-access; Disable memory access instrumentation in ThreadSanitizer; -fno-sanitize-trap=<value>; Disable trapping for specified sanitizers; -fno-standalone-debug Limit debug information produced to reduce size of debug binary; -fno-strict-aliasing Disable optimizations based on strict aliasing rules (default); -fobjc-runtime=<value> Specify the target Objective-C runtime kind and version; -fprofile-exclude-files=<value>; Instrument only functions from files where names don't match all the regexes separated by a semi-colon; -fprofile-filter-files=<value>; Instrument o,MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:180730,Safety,recover,recovery,180730,icant under the Microsoft ABI; -fno-coverage-mapping Disable code coverage analysis; -fno-crash-diagnostics Disable auto-generation of preprocessed source files and a script for reproduction during a clang crash; -fno-debug-macro Do not emit macro debug information; -fno-delayed-template-parsing; Disable delayed template parsing; -fno-sanitize-address-poison-custom-array-cookie; Disable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fno-sanitize-address-use-after-scope; Disable use-after-scope detection in AddressSanitizer; -fno-sanitize-address-use-odr-indicator; Disable ODR indicator globals; -fno-sanitize-ignorelist Don't use ignorelist file for sanitizers; -fno-sanitize-cfi-cross-dso; Disable control flow integrity (CFI) checks for cross-DSO calls.; -fno-sanitize-coverage=<value>; Disable specified features of coverage instrumentation for Sanitizers; -fno-sanitize-memory-track-origins; Disable origins tracking in MemorySanitizer; -fno-sanitize-memory-use-after-dtor; Disable use-after-destroy detection in MemorySanitizer; -fno-sanitize-recover=<value>; Disable recovery for specified sanitizers; -fno-sanitize-stats Disable sanitizer statistics gathering.; -fno-sanitize-thread-atomics; Disable atomic operations instrumentation in ThreadSanitizer; -fno-sanitize-thread-func-entry-exit; Disable function entry/exit instrumentation in ThreadSanitizer; -fno-sanitize-thread-memory-access; Disable memory access instrumentation in ThreadSanitizer; -fno-sanitize-trap=<value>; Disable trapping for specified sanitizers; -fno-standalone-debug Limit debug information produced to reduce size of debug binary; -fno-strict-aliasing Disable optimizations based on strict aliasing rules (default); -fobjc-runtime=<value> Specify the target Objective-C runtime kind and version; -fprofile-exclude-files=<value>; Instrument only functions from files where names don't match all the regexes separated by a semi-colon; -fprofile-filter-files=<value>; Instrument o,MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:183276,Safety,detect,detecting,183276," var); -fprofile-instr-generate=<file_name_pattern>; Generate instrumented code to collect execution counts into the file whose name pattern is specified as the argument; (overridden by LLVM_PROFILE_FILE env var); -fprofile-instr-generate; Generate instrumented code to collect execution counts into default.profraw file; (overridden by '=' form of option or LLVM_PROFILE_FILE env var); -fprofile-instr-use=<value>; Use instrumentation data for coverage testing or profile-guided optimization; -fprofile-use=<value>; Use instrumentation data for profile-guided optimization; -fprofile-remapping-file=<file>; Use the remappings described in <file> to match the profile data against names in the program; -fprofile-list=<file>; Filename defining the list of functions/files to instrument; -fsanitize-address-field-padding=<value>; Level of field padding for AddressSanitizer; -fsanitize-address-globals-dead-stripping; Enable linker dead stripping of globals in AddressSanitizer; -fsanitize-address-poison-custom-array-cookie; Enable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fsanitize-address-use-after-return=<mode>; Select the mode of detecting stack use-after-return in AddressSanitizer: never | runtime (default) | always; -fsanitize-address-use-after-scope; Enable use-after-scope detection in AddressSanitizer; -fsanitize-address-use-odr-indicator; Enable ODR indicator globals to avoid false ODR violation reports in partially sanitized programs at the cost of an increase in binary size; -fsanitize-ignorelist=<value>; Path to ignorelist file for sanitizers; -fsanitize-cfi-cross-dso; Enable control flow integrity (CFI) checks for cross-DSO calls.; -fsanitize-cfi-icall-generalize-pointers; Generalize pointers in CFI indirect call type signature checks; -fsanitize-coverage=<value>; Specify the type of coverage instrumentation for Sanitizers; -fsanitize-hwaddress-abi=<value>; Select the HWAddressSanitizer ABI to target (interceptor or platform, defaul",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:183425,Safety,detect,detection,183425," var); -fprofile-instr-generate=<file_name_pattern>; Generate instrumented code to collect execution counts into the file whose name pattern is specified as the argument; (overridden by LLVM_PROFILE_FILE env var); -fprofile-instr-generate; Generate instrumented code to collect execution counts into default.profraw file; (overridden by '=' form of option or LLVM_PROFILE_FILE env var); -fprofile-instr-use=<value>; Use instrumentation data for coverage testing or profile-guided optimization; -fprofile-use=<value>; Use instrumentation data for profile-guided optimization; -fprofile-remapping-file=<file>; Use the remappings described in <file> to match the profile data against names in the program; -fprofile-list=<file>; Filename defining the list of functions/files to instrument; -fsanitize-address-field-padding=<value>; Level of field padding for AddressSanitizer; -fsanitize-address-globals-dead-stripping; Enable linker dead stripping of globals in AddressSanitizer; -fsanitize-address-poison-custom-array-cookie; Enable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fsanitize-address-use-after-return=<mode>; Select the mode of detecting stack use-after-return in AddressSanitizer: never | runtime (default) | always; -fsanitize-address-use-after-scope; Enable use-after-scope detection in AddressSanitizer; -fsanitize-address-use-odr-indicator; Enable ODR indicator globals to avoid false ODR violation reports in partially sanitized programs at the cost of an increase in binary size; -fsanitize-ignorelist=<value>; Path to ignorelist file for sanitizers; -fsanitize-cfi-cross-dso; Enable control flow integrity (CFI) checks for cross-DSO calls.; -fsanitize-cfi-icall-generalize-pointers; Generalize pointers in CFI indirect call type signature checks; -fsanitize-coverage=<value>; Specify the type of coverage instrumentation for Sanitizers; -fsanitize-hwaddress-abi=<value>; Select the HWAddressSanitizer ABI to target (interceptor or platform, defaul",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:183526,Safety,avoid,avoid,183526," var); -fprofile-instr-generate=<file_name_pattern>; Generate instrumented code to collect execution counts into the file whose name pattern is specified as the argument; (overridden by LLVM_PROFILE_FILE env var); -fprofile-instr-generate; Generate instrumented code to collect execution counts into default.profraw file; (overridden by '=' form of option or LLVM_PROFILE_FILE env var); -fprofile-instr-use=<value>; Use instrumentation data for coverage testing or profile-guided optimization; -fprofile-use=<value>; Use instrumentation data for profile-guided optimization; -fprofile-remapping-file=<file>; Use the remappings described in <file> to match the profile data against names in the program; -fprofile-list=<file>; Filename defining the list of functions/files to instrument; -fsanitize-address-field-padding=<value>; Level of field padding for AddressSanitizer; -fsanitize-address-globals-dead-stripping; Enable linker dead stripping of globals in AddressSanitizer; -fsanitize-address-poison-custom-array-cookie; Enable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fsanitize-address-use-after-return=<mode>; Select the mode of detecting stack use-after-return in AddressSanitizer: never | runtime (default) | always; -fsanitize-address-use-after-scope; Enable use-after-scope detection in AddressSanitizer; -fsanitize-address-use-odr-indicator; Enable ODR indicator globals to avoid false ODR violation reports in partially sanitized programs at the cost of an increase in binary size; -fsanitize-ignorelist=<value>; Path to ignorelist file for sanitizers; -fsanitize-cfi-cross-dso; Enable control flow integrity (CFI) checks for cross-DSO calls.; -fsanitize-cfi-icall-generalize-pointers; Generalize pointers in CFI indirect call type signature checks; -fsanitize-coverage=<value>; Specify the type of coverage instrumentation for Sanitizers; -fsanitize-hwaddress-abi=<value>; Select the HWAddressSanitizer ABI to target (interceptor or platform, defaul",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:184340,Safety,detect,detection,184340,"array cookies when using custom operator new[] in AddressSanitizer; -fsanitize-address-use-after-return=<mode>; Select the mode of detecting stack use-after-return in AddressSanitizer: never | runtime (default) | always; -fsanitize-address-use-after-scope; Enable use-after-scope detection in AddressSanitizer; -fsanitize-address-use-odr-indicator; Enable ODR indicator globals to avoid false ODR violation reports in partially sanitized programs at the cost of an increase in binary size; -fsanitize-ignorelist=<value>; Path to ignorelist file for sanitizers; -fsanitize-cfi-cross-dso; Enable control flow integrity (CFI) checks for cross-DSO calls.; -fsanitize-cfi-icall-generalize-pointers; Generalize pointers in CFI indirect call type signature checks; -fsanitize-coverage=<value>; Specify the type of coverage instrumentation for Sanitizers; -fsanitize-hwaddress-abi=<value>; Select the HWAddressSanitizer ABI to target (interceptor or platform, default interceptor); -fsanitize-memory-track-origins=<value>; Enable origins tracking in MemorySanitizer; -fsanitize-memory-track-origins; Enable origins tracking in MemorySanitizer; -fsanitize-memory-use-after-dtor; Enable use-after-destroy detection in MemorySanitizer; -fsanitize-recover=<value>; Enable recovery for specified sanitizers; -fsanitize-stats Enable sanitizer statistics gathering.; -fsanitize-thread-atomics; Enable atomic operations instrumentation in ThreadSanitizer (default); -fsanitize-thread-func-entry-exit; Enable function entry/exit instrumentation in ThreadSanitizer (default); -fsanitize-thread-memory-access; Enable memory access instrumentation in ThreadSanitizer (default); -fsanitize-trap=<value> Enable trapping for specified sanitizers; -fsanitize-undefined-strip-path-components=<number>; Strip (or keep only, if negative) a given number of path components when emitting check metadata.; -fsanitize=<check> Turn on runtime checks for various forms of undefined or suspicious; behavior. See user manual for availa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:184381,Safety,recover,recover,184381,"array cookies when using custom operator new[] in AddressSanitizer; -fsanitize-address-use-after-return=<mode>; Select the mode of detecting stack use-after-return in AddressSanitizer: never | runtime (default) | always; -fsanitize-address-use-after-scope; Enable use-after-scope detection in AddressSanitizer; -fsanitize-address-use-odr-indicator; Enable ODR indicator globals to avoid false ODR violation reports in partially sanitized programs at the cost of an increase in binary size; -fsanitize-ignorelist=<value>; Path to ignorelist file for sanitizers; -fsanitize-cfi-cross-dso; Enable control flow integrity (CFI) checks for cross-DSO calls.; -fsanitize-cfi-icall-generalize-pointers; Generalize pointers in CFI indirect call type signature checks; -fsanitize-coverage=<value>; Specify the type of coverage instrumentation for Sanitizers; -fsanitize-hwaddress-abi=<value>; Select the HWAddressSanitizer ABI to target (interceptor or platform, default interceptor); -fsanitize-memory-track-origins=<value>; Enable origins tracking in MemorySanitizer; -fsanitize-memory-track-origins; Enable origins tracking in MemorySanitizer; -fsanitize-memory-use-after-dtor; Enable use-after-destroy detection in MemorySanitizer; -fsanitize-recover=<value>; Enable recovery for specified sanitizers; -fsanitize-stats Enable sanitizer statistics gathering.; -fsanitize-thread-atomics; Enable atomic operations instrumentation in ThreadSanitizer (default); -fsanitize-thread-func-entry-exit; Enable function entry/exit instrumentation in ThreadSanitizer (default); -fsanitize-thread-memory-access; Enable memory access instrumentation in ThreadSanitizer (default); -fsanitize-trap=<value> Enable trapping for specified sanitizers; -fsanitize-undefined-strip-path-components=<number>; Strip (or keep only, if negative) a given number of path components when emitting check metadata.; -fsanitize=<check> Turn on runtime checks for various forms of undefined or suspicious; behavior. See user manual for availa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:184405,Safety,recover,recovery,184405,"array cookies when using custom operator new[] in AddressSanitizer; -fsanitize-address-use-after-return=<mode>; Select the mode of detecting stack use-after-return in AddressSanitizer: never | runtime (default) | always; -fsanitize-address-use-after-scope; Enable use-after-scope detection in AddressSanitizer; -fsanitize-address-use-odr-indicator; Enable ODR indicator globals to avoid false ODR violation reports in partially sanitized programs at the cost of an increase in binary size; -fsanitize-ignorelist=<value>; Path to ignorelist file for sanitizers; -fsanitize-cfi-cross-dso; Enable control flow integrity (CFI) checks for cross-DSO calls.; -fsanitize-cfi-icall-generalize-pointers; Generalize pointers in CFI indirect call type signature checks; -fsanitize-coverage=<value>; Specify the type of coverage instrumentation for Sanitizers; -fsanitize-hwaddress-abi=<value>; Select the HWAddressSanitizer ABI to target (interceptor or platform, default interceptor); -fsanitize-memory-track-origins=<value>; Enable origins tracking in MemorySanitizer; -fsanitize-memory-track-origins; Enable origins tracking in MemorySanitizer; -fsanitize-memory-use-after-dtor; Enable use-after-destroy detection in MemorySanitizer; -fsanitize-recover=<value>; Enable recovery for specified sanitizers; -fsanitize-stats Enable sanitizer statistics gathering.; -fsanitize-thread-atomics; Enable atomic operations instrumentation in ThreadSanitizer (default); -fsanitize-thread-func-entry-exit; Enable function entry/exit instrumentation in ThreadSanitizer (default); -fsanitize-thread-memory-access; Enable memory access instrumentation in ThreadSanitizer (default); -fsanitize-trap=<value> Enable trapping for specified sanitizers; -fsanitize-undefined-strip-path-components=<number>; Strip (or keep only, if negative) a given number of path components when emitting check metadata.; -fsanitize=<check> Turn on runtime checks for various forms of undefined or suspicious; behavior. See user manual for availa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:190121,Safety,avoid,avoid,190121," that would otherwise; be dllexported refer to internal symbols of a DLL. For example:. .. code-block:: c. void internal();. struct __declspec(dllimport) S {; void foo() { internal(); }; }. Normally, references to `S::foo()` would use the definition in the DLL from; which it was exported, and which presumably also has the definition of; `internal()`. However, when using ``/Zc:dllexportInlines-``, the inline; definition of `S::foo()` is used directly, resulting in a link error since; `internal()` is not available. Even worse, if there is an inline definition of; `internal()` containing a static local variable, we will now refer to a; different instance of that variable than in the DLL:. .. code-block:: c. inline int internal() { static int x; return x++; }. struct __declspec(dllimport) S {; int foo() { return internal(); }; }. This could lead to very subtle bugs. Using ``-fvisibility-inlines-hidden`` can; lead to the same issue. To avoid it in this case, make `S::foo()` or; `internal()` non-inline, or mark them `dllimport/dllexport` explicitly. Finding Clang runtime libraries; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. clang-cl supports several features that require runtime library support:. - Address Sanitizer (ASan): ``-fsanitize=address``; - Undefined Behavior Sanitizer (UBSan): ``-fsanitize=undefined``; - Code coverage: ``-fprofile-instr-generate -fcoverage-mapping``; - Profile Guided Optimization (PGO): ``-fprofile-generate``; - Certain math operations (int128 division) require the builtins library. In order to use these features, the user must link the right runtime libraries; into their program. These libraries are distributed alongside Clang in the; library resource directory. Clang searches for the resource directory by; searching relative to the Clang executable. For example, if LLVM is installed; in ``C:\Program Files\LLVM``, then the profile runtime library will be located; at the path; ``C:\Program Files\LLVM\lib\clang\11.0.0\lib\windows\clang_rt.profile-x86_64.li",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:194906,Safety,detect,detected,194906,"lt behaviour for the Windows SDK and UCRT is as; follows:. 1. Consult the command line. Anything the user specifies is always given precedence. The following; extensions are part of the clang-cl toolset:. - `/winsysroot:`. The `/winsysroot:` is used as an equivalent to `-sysroot` on Unix; environments. It allows the control of an alternate location to be treated; as a system root. When specified, it will be used as the root where the; `Windows Kits` is located. - `/winsdkversion:`; - `/winsdkdir:`. If `/winsysroot:` is not specified, the `/winsdkdir:` argument is consulted; as a location to identify where the Windows SDK is located. Contrary to; `/winsysroot:`, `/winsdkdir:` is expected to be the complete path rather; than a root to locate `Windows Kits`. The `/winsdkversion:` flag allows the user to specify a version identifier; for the SDK to prefer. When this is specified, no additional validation is; performed and this version is preferred. If the version is not specified,; the highest detected version number will be used. 2. Consult the environment. TODO: This is not yet implemented. This will consult the environment variables:. - `WindowsSdkDir`; - `UCRTVersion`. 3. Fallback to the registry. If no arguments are used to indicate where the SDK is present, and the; compiler is running on Windows, the registry is consulted to locate the; installation. The Visual C++ Toolset has a slightly more elaborate mechanism for detection. 1. Consult the command line. - `/winsysroot:`. The `/winsysroot:` is used as an equivalent to `-sysroot` on Unix; environments. It allows the control of an alternate location to be treated; as a system root. When specified, it will be used as the root where the; `VC` directory is located. - `/vctoolsdir:`; - `/vctoolsversion:`. If `/winsysroot:` is not specified, the `/vctoolsdir:` argument is consulted; as a location to identify where the Visual C++ Tools are located. If; `/vctoolsversion:` is specified, that version is preferred, otherwis",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:195344,Safety,detect,detection,195344,"d as the root where the; `Windows Kits` is located. - `/winsdkversion:`; - `/winsdkdir:`. If `/winsysroot:` is not specified, the `/winsdkdir:` argument is consulted; as a location to identify where the Windows SDK is located. Contrary to; `/winsysroot:`, `/winsdkdir:` is expected to be the complete path rather; than a root to locate `Windows Kits`. The `/winsdkversion:` flag allows the user to specify a version identifier; for the SDK to prefer. When this is specified, no additional validation is; performed and this version is preferred. If the version is not specified,; the highest detected version number will be used. 2. Consult the environment. TODO: This is not yet implemented. This will consult the environment variables:. - `WindowsSdkDir`; - `UCRTVersion`. 3. Fallback to the registry. If no arguments are used to indicate where the SDK is present, and the; compiler is running on Windows, the registry is consulted to locate the; installation. The Visual C++ Toolset has a slightly more elaborate mechanism for detection. 1. Consult the command line. - `/winsysroot:`. The `/winsysroot:` is used as an equivalent to `-sysroot` on Unix; environments. It allows the control of an alternate location to be treated; as a system root. When specified, it will be used as the root where the; `VC` directory is located. - `/vctoolsdir:`; - `/vctoolsversion:`. If `/winsysroot:` is not specified, the `/vctoolsdir:` argument is consulted; as a location to identify where the Visual C++ Tools are located. If; `/vctoolsversion:` is specified, that version is preferred, otherwise, the; highest version detected is used. 2. Consult the environment. - `/external:[VARIABLE]`. This specifies a user identified environment variable which is treated as; a path delimiter (`;`) separated list of paths to map into `-imsvc`; arguments which are treated as `-isystem`. - `INCLUDE` and `EXTERNAL_INCLUDE`. The path delimiter (`;`) separated list of paths will be mapped to; `-imsvc` arguments which ar",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:195925,Safety,detect,detected,195925,"cified,; the highest detected version number will be used. 2. Consult the environment. TODO: This is not yet implemented. This will consult the environment variables:. - `WindowsSdkDir`; - `UCRTVersion`. 3. Fallback to the registry. If no arguments are used to indicate where the SDK is present, and the; compiler is running on Windows, the registry is consulted to locate the; installation. The Visual C++ Toolset has a slightly more elaborate mechanism for detection. 1. Consult the command line. - `/winsysroot:`. The `/winsysroot:` is used as an equivalent to `-sysroot` on Unix; environments. It allows the control of an alternate location to be treated; as a system root. When specified, it will be used as the root where the; `VC` directory is located. - `/vctoolsdir:`; - `/vctoolsversion:`. If `/winsysroot:` is not specified, the `/vctoolsdir:` argument is consulted; as a location to identify where the Visual C++ Tools are located. If; `/vctoolsversion:` is specified, that version is preferred, otherwise, the; highest version detected is used. 2. Consult the environment. - `/external:[VARIABLE]`. This specifies a user identified environment variable which is treated as; a path delimiter (`;`) separated list of paths to map into `-imsvc`; arguments which are treated as `-isystem`. - `INCLUDE` and `EXTERNAL_INCLUDE`. The path delimiter (`;`) separated list of paths will be mapped to; `-imsvc` arguments which are treated as `-isystem`. - `LIB` (indirectly). The linker `link.exe` or `lld-link.exe` will honour the environment; variable `LIB` which is a path delimiter (`;`) set of paths to consult for; the import libraries to use when linking the final target. The following environment variables will be consulted and used to form paths; to validate and load content from as appropriate:. - `VCToolsInstallDir`; - `VCINSTALLDIR`; - `Path`. 3. Consult `ISetupConfiguration` [Windows Only]. Assuming that the toolchain is built with `USE_MSVC_SETUP_API` defined and; is running on ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:44674,Security,expose,exposed,44674,"n the translation unit. .. code-block:: c. #define _CLANG_DISABLE_CRT_DEPRECATION_WARNINGS; #include <stdint.h> // Clang CRT deprecation warnings are disabled.; #include <stdatomic.h> // Clang CRT deprecation warnings are disabled. .. _diagnostics_enable_everything:. Enabling All Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^. In addition to the traditional ``-W`` flags, one can enable **all** diagnostics; by passing :option:`-Weverything`. This works as expected with; :option:`-Werror`, and also includes the warnings from :option:`-pedantic`. Some; diagnostics contradict each other, therefore, users of :option:`-Weverything`; often disable many diagnostics such as `-Wno-c++98-compat` and `-Wno-c++-compat`; because they contradict recent C++ standards. Since :option:`-Weverything` enables every diagnostic, we generally don't; recommend using it. `-Wall` `-Wextra` are a better choice for most projects.; Using :option:`-Weverything` means that updating your compiler is more difficult; because you're exposed to experimental diagnostics which might be of lower; quality than the default ones. If you do use :option:`-Weverything` then we; advise that you address all new compiler diagnostics as they get added to Clang,; either by fixing everything they find or explicitly disabling that diagnostic; with its corresponding `Wno-` option. Note that when combined with :option:`-w` (which disables all warnings),; disabling all warnings wins. Controlling Static Analyzer Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. While not strictly part of the compiler, the diagnostics from Clang's; `static analyzer <https://clang-analyzer.llvm.org>`_ can also be; influenced by the user via changes to the source code. See the available; `annotations <https://clang-analyzer.llvm.org/annotations.html>`_ and the; analyzer's `FAQ; page <https://clang-analyzer.llvm.org/faq.html#exclude_code>`_ for more; information. .. _usersmanual-precompiled-headers:. Precompiled Headers; -------------------. `Prec",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:69302,Security,access,access,69302," option:: -fcx-limited-range:. This option enables the naive mathematical formulas for complex division and; multiplication with no NaN checking of results. The default is; ``-fno-cx-limited-range``, but this option is enabled by the ``-ffast-math``; option. .. option:: -fcx-fortran-rules:. This option enables the naive mathematical formulas for complex; multiplication and enables application of Smith's algorithm for complex; division. See SMITH, R. L. Algorithm 116: Complex division. Commun.; ACM 5, 8 (1962). The default is ``-fno-cx-fortran-rules``. .. _floating-point-environment:. Accessing the floating point environment; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; Many targets allow floating point operations to be configured to control things; such as how inexact results should be rounded and how exceptional conditions; should be handled. This configuration is called the floating point environment.; C and C++ restrict access to the floating point environment by default, and the; compiler is allowed to assume that all operations are performed in the default; environment. When code is compiled in this default mode, operations that depend; on the environment (such as floating-point arithmetic and `FLT_ROUNDS`) may have; undefined behavior if the dynamic environment is not the default environment; for; example, `FLT_ROUNDS` may or may not simply return its default value for the target; instead of reading the dynamic environment, and floating-point operations may be; optimized as if the dynamic environment were the default. Similarly, it is undefined; behavior to change the floating point environment in this default mode, for example; by calling the `fesetround` function.; C provides two pragmas to allow code to dynamically modify the floating point environment:. - ``#pragma STDC FENV_ACCESS ON`` allows dynamic changes to the entire floating; point environment. - ``#pragma STDC FENV_ROUND FE_DYNAMIC`` allows dynamic changes to just the floating; point rounding mode. Thi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:74846,Security,sanitiz,sanitize,74846,"ing mode),; and only evaluated at runtime (and therefore in the runtime rounding mode) if; the compile-time evaluation fails. This is in line with the C rules;; C11 F.8.5 says: *All computation for automatic initialization is done (as if); at execution time; thus, it is affected by any operative modes and raises; floating-point exceptions as required by IEC 60559 (provided the state for the; FENV_ACCESS pragma is ‘‘on’’). All computation for initialization of objects; that have static or thread storage duration is done (as if) at translation; time.* C++ generalizes this by adding another phase of initialization; (at runtime) if the translation-time initialization fails, but the; translation-time evaluation of the initializer of succeeds, it will be; treated as a constant initializer. .. _controlling-code-generation:. Controlling Code Generation; ---------------------------. Clang provides a number of ways to control code generation. The options; are listed below. .. option:: -f[no-]sanitize=check1,check2,... Turn on runtime checks for various forms of undefined or suspicious; behavior. This option controls whether Clang adds runtime checks for various; forms of undefined or suspicious behavior, and is disabled by; default. If a check fails, a diagnostic message is produced at; runtime explaining the problem. The main checks are:. - .. _opt_fsanitize_address:. ``-fsanitize=address``:; :doc:`AddressSanitizer`, a memory error; detector.; - .. _opt_fsanitize_thread:. ``-fsanitize=thread``: :doc:`ThreadSanitizer`, a data race detector.; - .. _opt_fsanitize_memory:. ``-fsanitize=memory``: :doc:`MemorySanitizer`,; a detector of uninitialized reads. Requires instrumentation of all; program code.; - .. _opt_fsanitize_undefined:. ``-fsanitize=undefined``: :doc:`UndefinedBehaviorSanitizer`,; a fast and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <Co",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:75837,Security,integrity,integrity,75837,":: -f[no-]sanitize=check1,check2,... Turn on runtime checks for various forms of undefined or suspicious; behavior. This option controls whether Clang adds runtime checks for various; forms of undefined or suspicious behavior, and is disabled by; default. If a check fails, a diagnostic message is produced at; runtime explaining the problem. The main checks are:. - .. _opt_fsanitize_address:. ``-fsanitize=address``:; :doc:`AddressSanitizer`, a memory error; detector.; - .. _opt_fsanitize_thread:. ``-fsanitize=thread``: :doc:`ThreadSanitizer`, a data race detector.; - .. _opt_fsanitize_memory:. ``-fsanitize=memory``: :doc:`MemorySanitizer`,; a detector of uninitialized reads. Requires instrumentation of all; program code.; - .. _opt_fsanitize_undefined:. ``-fsanitize=undefined``: :doc:`UndefinedBehaviorSanitizer`,; a fast and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:75972,Security,integrity,integrity,75972,"; behavior. This option controls whether Clang adds runtime checks for various; forms of undefined or suspicious behavior, and is disabled by; default. If a check fails, a diagnostic message is produced at; runtime explaining the problem. The main checks are:. - .. _opt_fsanitize_address:. ``-fsanitize=address``:; :doc:`AddressSanitizer`, a memory error; detector.; - .. _opt_fsanitize_thread:. ``-fsanitize=thread``: :doc:`ThreadSanitizer`, a data race detector.; - .. _opt_fsanitize_memory:. ``-fsanitize=memory``: :doc:`MemorySanitizer`,; a detector of uninitialized reads. Requires instrumentation of all; program code.; - .. _opt_fsanitize_undefined:. ``-fsanitize=undefined``: :doc:`UndefinedBehaviorSanitizer`,; a fast and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`Undefined",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:76296,Security,integrity,integrity,76296,"opt_fsanitize_address:. ``-fsanitize=address``:; :doc:`AddressSanitizer`, a memory error; detector.; - .. _opt_fsanitize_thread:. ``-fsanitize=thread``: :doc:`ThreadSanitizer`, a data race detector.; - .. _opt_fsanitize_memory:. ``-fsanitize=memory``: :doc:`MemorySanitizer`,; a detector of uninitialized reads. Requires instrumentation of all; program code.; - .. _opt_fsanitize_undefined:. ``-fsanitize=undefined``: :doc:`UndefinedBehaviorSanitizer`,; a fast and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:76609,Security,sanitiz,sanitize-recover,76609,"fined``: :doc:`UndefinedBehaviorSanitizer`,; a fast and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:76663,Security,sanitiz,sanitize-recover,76663,"t and compatible undefined behavior checker. - ``-fsanitize=dataflow``: :doc:`DataFlowSanitizer`, a general data; flow analysis.; - ``-fsanitize=cfi``: :doc:`control flow integrity <ControlFlowIntegrity>`; checks. Requires ``-flto``.; - ``-fsanitize=kcfi``: kernel indirect call forward-edge control flow; integrity.; - ``-fsanitize=safe-stack``: :doc:`safe stack <SafeStack>`; protection against stack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effec",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:77033,Security,sanitiz,sanitizers,77033,"tack-based memory corruption errors. There are more fine-grained checks available: see; the :ref:`list <ubsan-checks>` of specific kinds of; undefined behavior that can be detected and the :ref:`list <cfi-schemes>`; of control flow integrity schemes. The ``-fsanitize=`` argument must also be provided when linking, in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binar",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:77430,Security,sanitiz,sanitizer,77430,"in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:77485,Security,sanitiz,sanitize-trap,77485,"in; order to link to the appropriate runtime library. It is not possible to combine more than one of the ``-fsanitize=address``,; ``-fsanitize=thread``, and ``-fsanitize=memory`` checkers in the same; program. .. option:: -f[no-]sanitize-recover=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:77722,Security,sanitiz,sanitize-trap,77722,"r=check1,check2,... .. option:: -f[no-]sanitize-recover[=all]. Controls which checks enabled by ``-fsanitize=`` flag are non-fatal.; If the check is fatal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ign",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:77768,Security,sanitiz,sanitize-trap,77768,"atal, program will halt after the first error; of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:77819,Security,sanitiz,sanitize-trap,77819," of this kind is detected and error report is printed. By default, non-fatal checks are those enabled by; :doc:`UndefinedBehaviorSanitizer`,; except for ``-fsanitize=return`` and ``-fsanitize=unreachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:77956,Security,sanitiz,sanitizer,77956,"reachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sanitizers.; See :doc:`SanitizerCoverage` for more details. .. option:: -f[no-]sanitize-address-outline-instrumentation. Controls how address sanitizer code is generated. If enabled will always u",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:78094,Security,sanitiz,sanitizer,78094,"reachable``. Some; sanitizers may not support recovery (or not support it by default; e.g. :doc:`AddressSanitizer`), and always crash the program after the issue; is detected. Note that the ``-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sanitizers.; See :doc:`SanitizerCoverage` for more details. .. option:: -f[no-]sanitize-address-outline-instrumentation. Controls how address sanitizer code is generated. If enabled will always u",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:78179,Security,integrity,integrity,78179,"-fsanitize-trap`` flag has precedence over this flag.; This means that if a check has been configured to trap elsewhere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sanitizers.; See :doc:`SanitizerCoverage` for more details. .. option:: -f[no-]sanitize-address-outline-instrumentation. Controls how address sanitizer code is generated. If enabled will always use; a function call instead of inlining the code. Turning this option on could; reduce the binary size, but might result in a worse run-time performance. See :doc: `AddressSanitizer` for more d",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:78325,Security,sanitiz,sanitizers,78325,"ere on the; command line, or if the check traps by default, this flag will not have; any effect unless that sanitizer's trapping behavior is disabled with; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sanitizers.; See :doc:`SanitizerCoverage` for more details. .. option:: -f[no-]sanitize-address-outline-instrumentation. Controls how address sanitizer code is generated. If enabled will always use; a function call instead of inlining the code. Turning this option on could; reduce the binary size, but might result in a worse run-time performance. See :doc: `AddressSanitizer` for more details. .. option:: -f[no-]sanitize-stats. Enable simple statistics gathering for the enabled sanitizers.; See :doc:",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:78436,Security,sanitiz,sanitizer,78436,"ith; ``-fno-sanitize-trap``. For example, if a command line contains the flags ``-fsanitize=undefined; -fsanitize-trap=undefined``, the flag ``-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sanitizers.; See :doc:`SanitizerCoverage` for more details. .. option:: -f[no-]sanitize-address-outline-instrumentation. Controls how address sanitizer code is generated. If enabled will always use; a function call instead of inlining the code. Turning this option on could; reduce the binary size, but might result in a worse run-time performance. See :doc: `AddressSanitizer` for more details. .. option:: -f[no-]sanitize-stats. Enable simple statistics gathering for the enabled sanitizers.; See :doc:`SanitizerStats` for more details. .. option:: -fsanitize-undefined-trap-on-error. Deprecated alias for ``-fsanitize-trap=undefined``. .. option:: -fs",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:78613,Security,sanitiz,sanitize-ignorelist,78613,"`-fsanitize-recover=alignment``; will have no effect on its own; it will need to be accompanied by; ``-fno-sanitize-trap=alignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sanitizers.; See :doc:`SanitizerCoverage` for more details. .. option:: -f[no-]sanitize-address-outline-instrumentation. Controls how address sanitizer code is generated. If enabled will always use; a function call instead of inlining the code. Turning this option on could; reduce the binary size, but might result in a worse run-time performance. See :doc: `AddressSanitizer` for more details. .. option:: -f[no-]sanitize-stats. Enable simple statistics gathering for the enabled sanitizers.; See :doc:`SanitizerStats` for more details. .. option:: -fsanitize-undefined-trap-on-error. Deprecated alias for ``-fsanitize-trap=undefined``. .. option:: -fsanitize-cfi-cross-dso. Enable cross-DSO control flow integrity checks. This flag modifies; the behavior of sanitizers in the ``cfi`` group to a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:78729,Security,sanitiz,sanitize-coverage,78729,"lignment``. .. option:: -f[no-]sanitize-trap=check1,check2,... .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sanitizers.; See :doc:`SanitizerCoverage` for more details. .. option:: -f[no-]sanitize-address-outline-instrumentation. Controls how address sanitizer code is generated. If enabled will always use; a function call instead of inlining the code. Turning this option on could; reduce the binary size, but might result in a worse run-time performance. See :doc: `AddressSanitizer` for more details. .. option:: -f[no-]sanitize-stats. Enable simple statistics gathering for the enabled sanitizers.; See :doc:`SanitizerStats` for more details. .. option:: -fsanitize-undefined-trap-on-error. Deprecated alias for ``-fsanitize-trap=undefined``. .. option:: -fsanitize-cfi-cross-dso. Enable cross-DSO control flow integrity checks. This flag modifies; the behavior of sanitizers in the ``cfi`` group to allow checking; of cross-DSO virtual and indirect calls. .. option:: -fsanitize-cfi-icall-generalize-pointers. Generalize p",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:78819,Security,sanitiz,sanitizers,78819,". .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sanitizers.; See :doc:`SanitizerCoverage` for more details. .. option:: -f[no-]sanitize-address-outline-instrumentation. Controls how address sanitizer code is generated. If enabled will always use; a function call instead of inlining the code. Turning this option on could; reduce the binary size, but might result in a worse run-time performance. See :doc: `AddressSanitizer` for more details. .. option:: -f[no-]sanitize-stats. Enable simple statistics gathering for the enabled sanitizers.; See :doc:`SanitizerStats` for more details. .. option:: -fsanitize-undefined-trap-on-error. Deprecated alias for ``-fsanitize-trap=undefined``. .. option:: -fsanitize-cfi-cross-dso. Enable cross-DSO control flow integrity checks. This flag modifies; the behavior of sanitizers in the ``cfi`` group to allow checking; of cross-DSO virtual and indirect calls. .. option:: -fsanitize-cfi-icall-generalize-pointers. Generalize pointers in return and argument types in function type signatu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:78898,Security,sanitiz,sanitize-address-outline-instrumentation,78898,"option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sanitizers.; See :doc:`SanitizerCoverage` for more details. .. option:: -f[no-]sanitize-address-outline-instrumentation. Controls how address sanitizer code is generated. If enabled will always use; a function call instead of inlining the code. Turning this option on could; reduce the binary size, but might result in a worse run-time performance. See :doc: `AddressSanitizer` for more details. .. option:: -f[no-]sanitize-stats. Enable simple statistics gathering for the enabled sanitizers.; See :doc:`SanitizerStats` for more details. .. option:: -fsanitize-undefined-trap-on-error. Deprecated alias for ``-fsanitize-trap=undefined``. .. option:: -fsanitize-cfi-cross-dso. Enable cross-DSO control flow integrity checks. This flag modifies; the behavior of sanitizers in the ``cfi`` group to allow checking; of cross-DSO virtual and indirect calls. .. option:: -fsanitize-cfi-icall-generalize-pointers. Generalize pointers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more detail",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:78961,Security,sanitiz,sanitizer,78961,"r runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sanitizers.; See :doc:`SanitizerCoverage` for more details. .. option:: -f[no-]sanitize-address-outline-instrumentation. Controls how address sanitizer code is generated. If enabled will always use; a function call instead of inlining the code. Turning this option on could; reduce the binary size, but might result in a worse run-time performance. See :doc: `AddressSanitizer` for more details. .. option:: -f[no-]sanitize-stats. Enable simple statistics gathering for the enabled sanitizers.; See :doc:`SanitizerStats` for more details. .. option:: -fsanitize-undefined-trap-on-error. Deprecated alias for ``-fsanitize-trap=undefined``. .. option:: -fsanitize-cfi-cross-dso. Enable cross-DSO control flow integrity checks. This flag modifies; the behavior of sanitizers in the ``cfi`` group to allow checking; of cross-DSO virtual and indirect calls. .. option:: -fsanitize-cfi-icall-generalize-pointers. Generalize pointers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more details. .. option:: -fsanitize-cfi-icall-experimental-norma",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:79234,Security,sanitiz,sanitize-stats,79234,"ndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sanitizers.; See :doc:`SanitizerCoverage` for more details. .. option:: -f[no-]sanitize-address-outline-instrumentation. Controls how address sanitizer code is generated. If enabled will always use; a function call instead of inlining the code. Turning this option on could; reduce the binary size, but might result in a worse run-time performance. See :doc: `AddressSanitizer` for more details. .. option:: -f[no-]sanitize-stats. Enable simple statistics gathering for the enabled sanitizers.; See :doc:`SanitizerStats` for more details. .. option:: -fsanitize-undefined-trap-on-error. Deprecated alias for ``-fsanitize-trap=undefined``. .. option:: -fsanitize-cfi-cross-dso. Enable cross-DSO control flow integrity checks. This flag modifies; the behavior of sanitizers in the ``cfi`` group to allow checking; of cross-DSO virtual and indirect calls. .. option:: -fsanitize-cfi-icall-generalize-pointers. Generalize pointers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more details. .. option:: -fsanitize-cfi-icall-experimental-normalize-integers. Normalize integers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more details. This option is currently experimental. .. option:: -fstrict-vtable-p",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:79301,Security,sanitiz,sanitizers,79301,"`vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sanitizers.; See :doc:`SanitizerCoverage` for more details. .. option:: -f[no-]sanitize-address-outline-instrumentation. Controls how address sanitizer code is generated. If enabled will always use; a function call instead of inlining the code. Turning this option on could; reduce the binary size, but might result in a worse run-time performance. See :doc: `AddressSanitizer` for more details. .. option:: -f[no-]sanitize-stats. Enable simple statistics gathering for the enabled sanitizers.; See :doc:`SanitizerStats` for more details. .. option:: -fsanitize-undefined-trap-on-error. Deprecated alias for ``-fsanitize-trap=undefined``. .. option:: -fsanitize-cfi-cross-dso. Enable cross-DSO control flow integrity checks. This flag modifies; the behavior of sanitizers in the ``cfi`` group to allow checking; of cross-DSO virtual and indirect calls. .. option:: -fsanitize-cfi-icall-generalize-pointers. Generalize pointers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more details. .. option:: -fsanitize-cfi-icall-experimental-normalize-integers. Normalize integers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more details. This option is currently experimental. .. option:: -fstrict-vtable-pointers. Enable optimizations based on the stric",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:79526,Security,integrity,integrity,79526," the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sanitizers.; See :doc:`SanitizerCoverage` for more details. .. option:: -f[no-]sanitize-address-outline-instrumentation. Controls how address sanitizer code is generated. If enabled will always use; a function call instead of inlining the code. Turning this option on could; reduce the binary size, but might result in a worse run-time performance. See :doc: `AddressSanitizer` for more details. .. option:: -f[no-]sanitize-stats. Enable simple statistics gathering for the enabled sanitizers.; See :doc:`SanitizerStats` for more details. .. option:: -fsanitize-undefined-trap-on-error. Deprecated alias for ``-fsanitize-trap=undefined``. .. option:: -fsanitize-cfi-cross-dso. Enable cross-DSO control flow integrity checks. This flag modifies; the behavior of sanitizers in the ``cfi`` group to allow checking; of cross-DSO virtual and indirect calls. .. option:: -fsanitize-cfi-icall-generalize-pointers. Generalize pointers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more details. .. option:: -fsanitize-cfi-icall-experimental-normalize-integers. Normalize integers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more details. This option is currently experimental. .. option:: -fstrict-vtable-pointers. Enable optimizations based on the strict rules for overwriting polymorphic; C++ objects, i.e. the vptr is invariant during an object's lifetime.; This enables better devirtualization. Turned off by default, because it is; still experimental. .. option:: -fwhole-program-vtables",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:79580,Security,sanitiz,sanitizers,79580," -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sanitizers.; See :doc:`SanitizerCoverage` for more details. .. option:: -f[no-]sanitize-address-outline-instrumentation. Controls how address sanitizer code is generated. If enabled will always use; a function call instead of inlining the code. Turning this option on could; reduce the binary size, but might result in a worse run-time performance. See :doc: `AddressSanitizer` for more details. .. option:: -f[no-]sanitize-stats. Enable simple statistics gathering for the enabled sanitizers.; See :doc:`SanitizerStats` for more details. .. option:: -fsanitize-undefined-trap-on-error. Deprecated alias for ``-fsanitize-trap=undefined``. .. option:: -fsanitize-cfi-cross-dso. Enable cross-DSO control flow integrity checks. This flag modifies; the behavior of sanitizers in the ``cfi`` group to allow checking; of cross-DSO virtual and indirect calls. .. option:: -fsanitize-cfi-icall-generalize-pointers. Generalize pointers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more details. .. option:: -fsanitize-cfi-icall-experimental-normalize-integers. Normalize integers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more details. This option is currently experimental. .. option:: -fstrict-vtable-pointers. Enable optimizations based on the strict rules for overwriting polymorphic; C++ objects, i.e. the vptr is invariant during an object's lifetime.; This enables better devirtualization. Turned off by default, because it is; still experimental. .. option:: -fwhole-program-vtables. Enable whole-program vtable optimizations, such as single-implementation; devirtualiza",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:83933,Security,access,access,83933,"if it is supported by the target ISA. Otherwise, the; builtin is translated into a call to ``abort``. If this option is; set, then the code generator will always lower the builtin to a call; to the specified function regardless of whether the target ISA has a; trap instruction. This option is useful for environments (e.g.; deeply embedded) where a trap cannot be properly handled, or when; some custom behavior is desired. .. option:: -ftls-model=[model]. Select which TLS model to use. Valid values are: ``global-dynamic``, ``local-dynamic``,; ``initial-exec`` and ``local-exec``. The default value is; ``global-dynamic``. The compiler may use a different model if the; selected model is not supported by the target, or if a more; efficient model can be used. The TLS model can be overridden per; variable using the ``tls_model`` attribute. .. option:: -femulated-tls. Select emulated TLS model, which overrides all -ftls-model choices. In emulated TLS mode, all access to TLS variables are converted to; calls to __emutls_get_address in the runtime library. .. option:: -mhwdiv=[values]. Select the ARM modes (arm or thumb) that support hardware division; instructions. Valid values are: ``arm``, ``thumb`` and ``arm,thumb``.; This option is used to indicate which mode (arm or thumb) supports; hardware division instructions. This only applies to the ARM; architecture. .. option:: -m[no-]crc. Enable or disable CRC instructions. This option is used to indicate whether CRC instructions are to; be generated. This only applies to the ARM architecture. CRC instructions are enabled by default on ARMv8. .. option:: -mgeneral-regs-only. Generate code which only uses the general purpose registers. This option restricts the generated code to use general registers; only. This only applies to the AArch64 architecture. .. option:: -mcompact-branches=[values]. Control the usage of compact branches for MIPSR6. Valid values are: ``never``, ``optimal`` and ``always``.; The default value is ``optimal",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:85297,Security,access,accessing,85297,"re division instructions. This only applies to the ARM; architecture. .. option:: -m[no-]crc. Enable or disable CRC instructions. This option is used to indicate whether CRC instructions are to; be generated. This only applies to the ARM architecture. CRC instructions are enabled by default on ARMv8. .. option:: -mgeneral-regs-only. Generate code which only uses the general purpose registers. This option restricts the generated code to use general registers; only. This only applies to the AArch64 architecture. .. option:: -mcompact-branches=[values]. Control the usage of compact branches for MIPSR6. Valid values are: ``never``, ``optimal`` and ``always``.; The default value is ``optimal`` which generates compact branches; when a delay slot cannot be filled. ``never`` disables the usage of; compact branches and ``always`` generates compact branches whenever; possible. .. option:: -f[no-]max-type-align=[number]. Instruct the code generator to not enforce a higher alignment than the given; number (of bytes) when accessing memory via an opaque pointer or reference.; This cap is ignored when directly accessing a variable or when the pointee; type has an explicit “aligned” attribute. The value should usually be determined by the properties of the system allocator.; Some builtin types, especially vector types, have very high natural alignments;; when working with values of those types, Clang usually wants to use instructions; that take advantage of that alignment. However, many system allocators do; not promise to return memory that is more than 8-byte or 16-byte-aligned. Use; this option to limit the alignment that the compiler can assume for an arbitrary; pointer, which may point onto the heap. This option does not affect the ABI alignment of types; the layout of structs and; unions and the value returned by the alignof operator remain the same. This option can be overridden on a case-by-case basis by putting an explicit; “aligned” alignment on a struct, union, or typede",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:85385,Security,access,accessing,85385,"ption is used to indicate whether CRC instructions are to; be generated. This only applies to the ARM architecture. CRC instructions are enabled by default on ARMv8. .. option:: -mgeneral-regs-only. Generate code which only uses the general purpose registers. This option restricts the generated code to use general registers; only. This only applies to the AArch64 architecture. .. option:: -mcompact-branches=[values]. Control the usage of compact branches for MIPSR6. Valid values are: ``never``, ``optimal`` and ``always``.; The default value is ``optimal`` which generates compact branches; when a delay slot cannot be filled. ``never`` disables the usage of; compact branches and ``always`` generates compact branches whenever; possible. .. option:: -f[no-]max-type-align=[number]. Instruct the code generator to not enforce a higher alignment than the given; number (of bytes) when accessing memory via an opaque pointer or reference.; This cap is ignored when directly accessing a variable or when the pointee; type has an explicit “aligned” attribute. The value should usually be determined by the properties of the system allocator.; Some builtin types, especially vector types, have very high natural alignments;; when working with values of those types, Clang usually wants to use instructions; that take advantage of that alignment. However, many system allocators do; not promise to return memory that is more than 8-byte or 16-byte-aligned. Use; this option to limit the alignment that the compiler can assume for an arbitrary; pointer, which may point onto the heap. This option does not affect the ABI alignment of types; the layout of structs and; unions and the value returned by the alignof operator remain the same. This option can be overridden on a case-by-case basis by putting an explicit; “aligned” alignment on a struct, union, or typedef. For example:. .. code-block:: console. #include <immintrin.h>; // Make an aligned typedef of the AVX-512 16-int vector type.; typedef ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:87310,Security,hash,hashes,87310," Make an aligned typedef of the AVX-512 16-int vector type.; typedef __v16si __aligned_v16si __attribute__((aligned(64)));. void initialize_vector(__aligned_v16si *v) {; // The compiler may assume that ‘v’ is 64-byte aligned, regardless of the; // value of -fmax-type-align.; }. .. option:: -faddrsig, -fno-addrsig. Controls whether Clang emits an address-significance table into the object; file. Address-significance tables allow linkers to implement `safe ICF; <https://research.google.com/pubs/archive/36912.pdf>`_ without the false; positives that can result from other implementation techniques such as; relocation scanning. Address-significance tables are enabled by default; on ELF targets when using the integrated assembler. This flag currently; only has an effect on ELF targets. .. option:: -f[no]-unique-internal-linkage-names. Controls whether Clang emits a unique (best-effort) symbol name for internal; linkage symbols. When this option is set, compiler hashes the main source; file path from the command line and appends it to all internal symbols. If a; program contains multiple objects compiled with the same command-line source; file path, the symbols are not guaranteed to be unique. This option is; particularly useful in attributing profile information to the correct; function when multiple functions with the same private linkage name exist; in the binary. It should be noted that this option cannot guarantee uniqueness and the; following is an example where it is not unique when two modules contain; symbols with the same private linkage name:. .. code-block:: console. $ cd $P/foo && clang -c -funique-internal-linkage-names name_conflict.c; $ cd $P/bar && clang -c -funique-internal-linkage-names name_conflict.c; $ cd $P && clang foo/name_conflict.o && bar/name_conflict.o. .. option:: -fbasic-block-sections=[labels, all, list=<arg>, none]. Controls how Clang emits text sections for basic blocks. With values ``all``; and ``list=<arg>``, each basic block or a subset",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:143200,Security,access,accessible,143200,"port of the embedded; profile.; From clang 9 a C++ mode is available for OpenCL (see; :ref:`C++ for OpenCL <cxx_for_opencl>`). OpenCL v3.0 support is complete but it remains in experimental state, see more; details about the experimental features and limitations in :doc:`OpenCLSupport`; page. OpenCL Specific Options; -----------------------. Most of the OpenCL build options from `the specification v2.0 section 5.8.4; <https://www.khronos.org/registry/cl/specs/opencl-2.0.pdf#200>`_ are available. Examples:. .. code-block:: console. $ clang -cl-std=CL2.0 -cl-single-precision-constant test.cl. Many flags used for the compilation for C sources can also be passed while; compiling for OpenCL, examples: ``-c``, ``-O<1-4|s>``, ``-o``, ``-emit-llvm``, etc. Some extra options are available to support special OpenCL features. .. option:: -cl-no-stdinc. Allows to disable all extra types and functions that are not native to the compiler.; This might reduce the compilation speed marginally but many declarations from the; OpenCL standard will not be accessible. For example, the following will fail to; compile. .. code-block:: console. $ echo ""bool is_wg_uniform(int i){return get_enqueued_local_size(i)==get_local_size(i);}"" > test.cl; $ clang -cl-std=CL2.0 -cl-no-stdinc test.cl; error: use of undeclared identifier 'get_enqueued_local_size'; error: use of undeclared identifier 'get_local_size'. More information about the standard types and functions is provided in :ref:`the; section on the OpenCL Header <opencl_header>`. .. _opencl_cl_ext:. .. option:: -cl-ext. Enables/Disables support of OpenCL extensions and optional features. All OpenCL; targets set a list of extensions that they support. Clang allows to amend this using; the ``-cl-ext`` flag with a comma-separated list of extensions prefixed with; ``'+'`` or ``'-'``. The syntax: ``-cl-ext=<(['-'|'+']<extension>[,])+>``, where; extensions can be either one of `the OpenCL published extensions; <https://www.khronos.org/registry/Ope",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:172968,Security,secur,security,172968,"CL.EXE COMPATIBILITY OPTIONS:; /? Display available options; /arch:<value> Set architecture for code generation; /Brepro- Emit an object file which cannot be reproduced over time; /Brepro Emit an object file which can be reproduced over time; /clang:<arg> Pass <arg> to the clang driver; /C Don't discard comments when preprocessing; /c Compile only; /d1PP Retain macro definitions in /E mode; /d1reportAllClassLayout Dump record layout information; /diagnostics:caret Enable caret and column diagnostics (on by default); /diagnostics:classic Disable column and caret diagnostics; /diagnostics:column Disable caret diagnostics but keep column info; /D <macro[=value]> Define macro; /EH<value> Exception handling model; /EP Disable linemarker output and preprocess to stdout; /execution-charset:<value>; Runtime encoding, supports only UTF-8; /E Preprocess to stdout; /FA Output assembly code file during compilation; /Fa<file or directory> Output assembly code to this file during compilation (with /FA); /Fe<file or directory> Set output executable file or directory (ends in / or \); /FI <value> Include file before parsing; /Fi<file> Set preprocess output file name (with /P); /Fo<file or directory> Set output object file, or directory (ends in / or \) (with /c); /fp:except-; /fp:except; /fp:fast; /fp:precise; /fp:strict; /Fp<filename> Set pch filename (with /Yc and /Yu); /GA Assume thread-local variables are defined in the executable; /Gd Set __cdecl as a default calling convention; /GF- Disable string pooling; /GF Enable string pooling (default); /GR- Disable emission of RTTI data; /Gregcall Set __regcall as a default calling convention; /GR Enable emission of RTTI data; /Gr Set __fastcall as a default calling convention; /GS- Disable buffer security check; /GS Enable buffer security check (default); /Gs Use stack probes (default); /Gs<value> Set stack probe size (default 4096); /guard:<value> Enable Control Flow Guard with /guard:cf,; or only the table with /guard:cf,nochecks.; E",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:173002,Security,secur,security,173002,"CL.EXE COMPATIBILITY OPTIONS:; /? Display available options; /arch:<value> Set architecture for code generation; /Brepro- Emit an object file which cannot be reproduced over time; /Brepro Emit an object file which can be reproduced over time; /clang:<arg> Pass <arg> to the clang driver; /C Don't discard comments when preprocessing; /c Compile only; /d1PP Retain macro definitions in /E mode; /d1reportAllClassLayout Dump record layout information; /diagnostics:caret Enable caret and column diagnostics (on by default); /diagnostics:classic Disable column and caret diagnostics; /diagnostics:column Disable caret diagnostics but keep column info; /D <macro[=value]> Define macro; /EH<value> Exception handling model; /EP Disable linemarker output and preprocess to stdout; /execution-charset:<value>; Runtime encoding, supports only UTF-8; /E Preprocess to stdout; /FA Output assembly code file during compilation; /Fa<file or directory> Output assembly code to this file during compilation (with /FA); /Fe<file or directory> Set output executable file or directory (ends in / or \); /FI <value> Include file before parsing; /Fi<file> Set preprocess output file name (with /P); /Fo<file or directory> Set output object file, or directory (ends in / or \) (with /c); /fp:except-; /fp:except; /fp:fast; /fp:precise; /fp:strict; /Fp<filename> Set pch filename (with /Yc and /Yu); /GA Assume thread-local variables are defined in the executable; /Gd Set __cdecl as a default calling convention; /GF- Disable string pooling; /GF Enable string pooling (default); /GR- Disable emission of RTTI data; /Gregcall Set __regcall as a default calling convention; /GR Enable emission of RTTI data; /Gr Set __fastcall as a default calling convention; /GS- Disable buffer security check; /GS Enable buffer security check (default); /Gs Use stack probes (default); /Gs<value> Set stack probe size (default 4096); /guard:<value> Enable Control Flow Guard with /guard:cf,; or only the table with /guard:cf,nochecks.; E",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:179955,Security,sanitiz,sanitize-address-poison-custom-array-cookie,179955,"presenting the Microsoft compiler version; number to report in _MSC_VER (0 = don't define it; default is same value as installed cl.exe, or 1933); -fms-compatibility Enable full Microsoft Visual C++ compatibility; -fms-extensions Accept some non-standard constructs supported by the Microsoft compiler; -fmsc-version=<value> Microsoft compiler version number to report in _MSC_VER; (0 = don't define it; default is same value as installed cl.exe, or 1933); -fno-addrsig Don't emit an address-significance table; -fno-builtin-<value> Disable implicit builtin knowledge of a specific function; -fno-builtin Disable implicit builtin knowledge of functions; -fno-complete-member-pointers; Do not require member pointer base types to be complete if they would be significant under the Microsoft ABI; -fno-coverage-mapping Disable code coverage analysis; -fno-crash-diagnostics Disable auto-generation of preprocessed source files and a script for reproduction during a clang crash; -fno-debug-macro Do not emit macro debug information; -fno-delayed-template-parsing; Disable delayed template parsing; -fno-sanitize-address-poison-custom-array-cookie; Disable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fno-sanitize-address-use-after-scope; Disable use-after-scope detection in AddressSanitizer; -fno-sanitize-address-use-odr-indicator; Disable ODR indicator globals; -fno-sanitize-ignorelist Don't use ignorelist file for sanitizers; -fno-sanitize-cfi-cross-dso; Disable control flow integrity (CFI) checks for cross-DSO calls.; -fno-sanitize-coverage=<value>; Disable specified features of coverage instrumentation for Sanitizers; -fno-sanitize-memory-track-origins; Disable origins tracking in MemorySanitizer; -fno-sanitize-memory-use-after-dtor; Disable use-after-destroy detection in MemorySanitizer; -fno-sanitize-recover=<value>; Disable recovery for specified sanitizers; -fno-sanitize-stats Disable sanitizer statistics gathering.; -fno-sanitize-thread-atomics",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:180091,Security,sanitiz,sanitize-address-use-after-scope,180091,"presenting the Microsoft compiler version; number to report in _MSC_VER (0 = don't define it; default is same value as installed cl.exe, or 1933); -fms-compatibility Enable full Microsoft Visual C++ compatibility; -fms-extensions Accept some non-standard constructs supported by the Microsoft compiler; -fmsc-version=<value> Microsoft compiler version number to report in _MSC_VER; (0 = don't define it; default is same value as installed cl.exe, or 1933); -fno-addrsig Don't emit an address-significance table; -fno-builtin-<value> Disable implicit builtin knowledge of a specific function; -fno-builtin Disable implicit builtin knowledge of functions; -fno-complete-member-pointers; Do not require member pointer base types to be complete if they would be significant under the Microsoft ABI; -fno-coverage-mapping Disable code coverage analysis; -fno-crash-diagnostics Disable auto-generation of preprocessed source files and a script for reproduction during a clang crash; -fno-debug-macro Do not emit macro debug information; -fno-delayed-template-parsing; Disable delayed template parsing; -fno-sanitize-address-poison-custom-array-cookie; Disable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fno-sanitize-address-use-after-scope; Disable use-after-scope detection in AddressSanitizer; -fno-sanitize-address-use-odr-indicator; Disable ODR indicator globals; -fno-sanitize-ignorelist Don't use ignorelist file for sanitizers; -fno-sanitize-cfi-cross-dso; Disable control flow integrity (CFI) checks for cross-DSO calls.; -fno-sanitize-coverage=<value>; Disable specified features of coverage instrumentation for Sanitizers; -fno-sanitize-memory-track-origins; Disable origins tracking in MemorySanitizer; -fno-sanitize-memory-use-after-dtor; Disable use-after-destroy detection in MemorySanitizer; -fno-sanitize-recover=<value>; Disable recovery for specified sanitizers; -fno-sanitize-stats Disable sanitizer statistics gathering.; -fno-sanitize-thread-atomics",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:180185,Security,sanitiz,sanitize-address-use-odr-indicator,180185,"presenting the Microsoft compiler version; number to report in _MSC_VER (0 = don't define it; default is same value as installed cl.exe, or 1933); -fms-compatibility Enable full Microsoft Visual C++ compatibility; -fms-extensions Accept some non-standard constructs supported by the Microsoft compiler; -fmsc-version=<value> Microsoft compiler version number to report in _MSC_VER; (0 = don't define it; default is same value as installed cl.exe, or 1933); -fno-addrsig Don't emit an address-significance table; -fno-builtin-<value> Disable implicit builtin knowledge of a specific function; -fno-builtin Disable implicit builtin knowledge of functions; -fno-complete-member-pointers; Do not require member pointer base types to be complete if they would be significant under the Microsoft ABI; -fno-coverage-mapping Disable code coverage analysis; -fno-crash-diagnostics Disable auto-generation of preprocessed source files and a script for reproduction during a clang crash; -fno-debug-macro Do not emit macro debug information; -fno-delayed-template-parsing; Disable delayed template parsing; -fno-sanitize-address-poison-custom-array-cookie; Disable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fno-sanitize-address-use-after-scope; Disable use-after-scope detection in AddressSanitizer; -fno-sanitize-address-use-odr-indicator; Disable ODR indicator globals; -fno-sanitize-ignorelist Don't use ignorelist file for sanitizers; -fno-sanitize-cfi-cross-dso; Disable control flow integrity (CFI) checks for cross-DSO calls.; -fno-sanitize-coverage=<value>; Disable specified features of coverage instrumentation for Sanitizers; -fno-sanitize-memory-track-origins; Disable origins tracking in MemorySanitizer; -fno-sanitize-memory-use-after-dtor; Disable use-after-destroy detection in MemorySanitizer; -fno-sanitize-recover=<value>; Disable recovery for specified sanitizers; -fno-sanitize-stats Disable sanitizer statistics gathering.; -fno-sanitize-thread-atomics",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:180257,Security,sanitiz,sanitize-ignorelist,180257,"presenting the Microsoft compiler version; number to report in _MSC_VER (0 = don't define it; default is same value as installed cl.exe, or 1933); -fms-compatibility Enable full Microsoft Visual C++ compatibility; -fms-extensions Accept some non-standard constructs supported by the Microsoft compiler; -fmsc-version=<value> Microsoft compiler version number to report in _MSC_VER; (0 = don't define it; default is same value as installed cl.exe, or 1933); -fno-addrsig Don't emit an address-significance table; -fno-builtin-<value> Disable implicit builtin knowledge of a specific function; -fno-builtin Disable implicit builtin knowledge of functions; -fno-complete-member-pointers; Do not require member pointer base types to be complete if they would be significant under the Microsoft ABI; -fno-coverage-mapping Disable code coverage analysis; -fno-crash-diagnostics Disable auto-generation of preprocessed source files and a script for reproduction during a clang crash; -fno-debug-macro Do not emit macro debug information; -fno-delayed-template-parsing; Disable delayed template parsing; -fno-sanitize-address-poison-custom-array-cookie; Disable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fno-sanitize-address-use-after-scope; Disable use-after-scope detection in AddressSanitizer; -fno-sanitize-address-use-odr-indicator; Disable ODR indicator globals; -fno-sanitize-ignorelist Don't use ignorelist file for sanitizers; -fno-sanitize-cfi-cross-dso; Disable control flow integrity (CFI) checks for cross-DSO calls.; -fno-sanitize-coverage=<value>; Disable specified features of coverage instrumentation for Sanitizers; -fno-sanitize-memory-track-origins; Disable origins tracking in MemorySanitizer; -fno-sanitize-memory-use-after-dtor; Disable use-after-destroy detection in MemorySanitizer; -fno-sanitize-recover=<value>; Disable recovery for specified sanitizers; -fno-sanitize-stats Disable sanitizer statistics gathering.; -fno-sanitize-thread-atomics",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:180307,Security,sanitiz,sanitizers,180307,"presenting the Microsoft compiler version; number to report in _MSC_VER (0 = don't define it; default is same value as installed cl.exe, or 1933); -fms-compatibility Enable full Microsoft Visual C++ compatibility; -fms-extensions Accept some non-standard constructs supported by the Microsoft compiler; -fmsc-version=<value> Microsoft compiler version number to report in _MSC_VER; (0 = don't define it; default is same value as installed cl.exe, or 1933); -fno-addrsig Don't emit an address-significance table; -fno-builtin-<value> Disable implicit builtin knowledge of a specific function; -fno-builtin Disable implicit builtin knowledge of functions; -fno-complete-member-pointers; Do not require member pointer base types to be complete if they would be significant under the Microsoft ABI; -fno-coverage-mapping Disable code coverage analysis; -fno-crash-diagnostics Disable auto-generation of preprocessed source files and a script for reproduction during a clang crash; -fno-debug-macro Do not emit macro debug information; -fno-delayed-template-parsing; Disable delayed template parsing; -fno-sanitize-address-poison-custom-array-cookie; Disable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fno-sanitize-address-use-after-scope; Disable use-after-scope detection in AddressSanitizer; -fno-sanitize-address-use-odr-indicator; Disable ODR indicator globals; -fno-sanitize-ignorelist Don't use ignorelist file for sanitizers; -fno-sanitize-cfi-cross-dso; Disable control flow integrity (CFI) checks for cross-DSO calls.; -fno-sanitize-coverage=<value>; Disable specified features of coverage instrumentation for Sanitizers; -fno-sanitize-memory-track-origins; Disable origins tracking in MemorySanitizer; -fno-sanitize-memory-use-after-dtor; Disable use-after-destroy detection in MemorySanitizer; -fno-sanitize-recover=<value>; Disable recovery for specified sanitizers; -fno-sanitize-stats Disable sanitizer statistics gathering.; -fno-sanitize-thread-atomics",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:180324,Security,sanitiz,sanitize-cfi-cross-dso,180324,"presenting the Microsoft compiler version; number to report in _MSC_VER (0 = don't define it; default is same value as installed cl.exe, or 1933); -fms-compatibility Enable full Microsoft Visual C++ compatibility; -fms-extensions Accept some non-standard constructs supported by the Microsoft compiler; -fmsc-version=<value> Microsoft compiler version number to report in _MSC_VER; (0 = don't define it; default is same value as installed cl.exe, or 1933); -fno-addrsig Don't emit an address-significance table; -fno-builtin-<value> Disable implicit builtin knowledge of a specific function; -fno-builtin Disable implicit builtin knowledge of functions; -fno-complete-member-pointers; Do not require member pointer base types to be complete if they would be significant under the Microsoft ABI; -fno-coverage-mapping Disable code coverage analysis; -fno-crash-diagnostics Disable auto-generation of preprocessed source files and a script for reproduction during a clang crash; -fno-debug-macro Do not emit macro debug information; -fno-delayed-template-parsing; Disable delayed template parsing; -fno-sanitize-address-poison-custom-array-cookie; Disable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fno-sanitize-address-use-after-scope; Disable use-after-scope detection in AddressSanitizer; -fno-sanitize-address-use-odr-indicator; Disable ODR indicator globals; -fno-sanitize-ignorelist Don't use ignorelist file for sanitizers; -fno-sanitize-cfi-cross-dso; Disable control flow integrity (CFI) checks for cross-DSO calls.; -fno-sanitize-coverage=<value>; Disable specified features of coverage instrumentation for Sanitizers; -fno-sanitize-memory-track-origins; Disable origins tracking in MemorySanitizer; -fno-sanitize-memory-use-after-dtor; Disable use-after-destroy detection in MemorySanitizer; -fno-sanitize-recover=<value>; Disable recovery for specified sanitizers; -fno-sanitize-stats Disable sanitizer statistics gathering.; -fno-sanitize-thread-atomics",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:180369,Security,integrity,integrity,180369,"presenting the Microsoft compiler version; number to report in _MSC_VER (0 = don't define it; default is same value as installed cl.exe, or 1933); -fms-compatibility Enable full Microsoft Visual C++ compatibility; -fms-extensions Accept some non-standard constructs supported by the Microsoft compiler; -fmsc-version=<value> Microsoft compiler version number to report in _MSC_VER; (0 = don't define it; default is same value as installed cl.exe, or 1933); -fno-addrsig Don't emit an address-significance table; -fno-builtin-<value> Disable implicit builtin knowledge of a specific function; -fno-builtin Disable implicit builtin knowledge of functions; -fno-complete-member-pointers; Do not require member pointer base types to be complete if they would be significant under the Microsoft ABI; -fno-coverage-mapping Disable code coverage analysis; -fno-crash-diagnostics Disable auto-generation of preprocessed source files and a script for reproduction during a clang crash; -fno-debug-macro Do not emit macro debug information; -fno-delayed-template-parsing; Disable delayed template parsing; -fno-sanitize-address-poison-custom-array-cookie; Disable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fno-sanitize-address-use-after-scope; Disable use-after-scope detection in AddressSanitizer; -fno-sanitize-address-use-odr-indicator; Disable ODR indicator globals; -fno-sanitize-ignorelist Don't use ignorelist file for sanitizers; -fno-sanitize-cfi-cross-dso; Disable control flow integrity (CFI) checks for cross-DSO calls.; -fno-sanitize-coverage=<value>; Disable specified features of coverage instrumentation for Sanitizers; -fno-sanitize-memory-track-origins; Disable origins tracking in MemorySanitizer; -fno-sanitize-memory-use-after-dtor; Disable use-after-destroy detection in MemorySanitizer; -fno-sanitize-recover=<value>; Disable recovery for specified sanitizers; -fno-sanitize-stats Disable sanitizer statistics gathering.; -fno-sanitize-thread-atomics",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:180419,Security,sanitiz,sanitize-coverage,180419,icant under the Microsoft ABI; -fno-coverage-mapping Disable code coverage analysis; -fno-crash-diagnostics Disable auto-generation of preprocessed source files and a script for reproduction during a clang crash; -fno-debug-macro Do not emit macro debug information; -fno-delayed-template-parsing; Disable delayed template parsing; -fno-sanitize-address-poison-custom-array-cookie; Disable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fno-sanitize-address-use-after-scope; Disable use-after-scope detection in AddressSanitizer; -fno-sanitize-address-use-odr-indicator; Disable ODR indicator globals; -fno-sanitize-ignorelist Don't use ignorelist file for sanitizers; -fno-sanitize-cfi-cross-dso; Disable control flow integrity (CFI) checks for cross-DSO calls.; -fno-sanitize-coverage=<value>; Disable specified features of coverage instrumentation for Sanitizers; -fno-sanitize-memory-track-origins; Disable origins tracking in MemorySanitizer; -fno-sanitize-memory-use-after-dtor; Disable use-after-destroy detection in MemorySanitizer; -fno-sanitize-recover=<value>; Disable recovery for specified sanitizers; -fno-sanitize-stats Disable sanitizer statistics gathering.; -fno-sanitize-thread-atomics; Disable atomic operations instrumentation in ThreadSanitizer; -fno-sanitize-thread-func-entry-exit; Disable function entry/exit instrumentation in ThreadSanitizer; -fno-sanitize-thread-memory-access; Disable memory access instrumentation in ThreadSanitizer; -fno-sanitize-trap=<value>; Disable trapping for specified sanitizers; -fno-standalone-debug Limit debug information produced to reduce size of debug binary; -fno-strict-aliasing Disable optimizations based on strict aliasing rules (default); -fobjc-runtime=<value> Specify the target Objective-C runtime kind and version; -fprofile-exclude-files=<value>; Instrument only functions from files where names don't match all the regexes separated by a semi-colon; -fprofile-filter-files=<value>; Instrument o,MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:180522,Security,sanitiz,sanitize-memory-track-origins,180522,icant under the Microsoft ABI; -fno-coverage-mapping Disable code coverage analysis; -fno-crash-diagnostics Disable auto-generation of preprocessed source files and a script for reproduction during a clang crash; -fno-debug-macro Do not emit macro debug information; -fno-delayed-template-parsing; Disable delayed template parsing; -fno-sanitize-address-poison-custom-array-cookie; Disable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fno-sanitize-address-use-after-scope; Disable use-after-scope detection in AddressSanitizer; -fno-sanitize-address-use-odr-indicator; Disable ODR indicator globals; -fno-sanitize-ignorelist Don't use ignorelist file for sanitizers; -fno-sanitize-cfi-cross-dso; Disable control flow integrity (CFI) checks for cross-DSO calls.; -fno-sanitize-coverage=<value>; Disable specified features of coverage instrumentation for Sanitizers; -fno-sanitize-memory-track-origins; Disable origins tracking in MemorySanitizer; -fno-sanitize-memory-use-after-dtor; Disable use-after-destroy detection in MemorySanitizer; -fno-sanitize-recover=<value>; Disable recovery for specified sanitizers; -fno-sanitize-stats Disable sanitizer statistics gathering.; -fno-sanitize-thread-atomics; Disable atomic operations instrumentation in ThreadSanitizer; -fno-sanitize-thread-func-entry-exit; Disable function entry/exit instrumentation in ThreadSanitizer; -fno-sanitize-thread-memory-access; Disable memory access instrumentation in ThreadSanitizer; -fno-sanitize-trap=<value>; Disable trapping for specified sanitizers; -fno-standalone-debug Limit debug information produced to reduce size of debug binary; -fno-strict-aliasing Disable optimizations based on strict aliasing rules (default); -fobjc-runtime=<value> Specify the target Objective-C runtime kind and version; -fprofile-exclude-files=<value>; Instrument only functions from files where names don't match all the regexes separated by a semi-colon; -fprofile-filter-files=<value>; Instrument o,MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:180603,Security,sanitiz,sanitize-memory-use-after-dtor,180603,icant under the Microsoft ABI; -fno-coverage-mapping Disable code coverage analysis; -fno-crash-diagnostics Disable auto-generation of preprocessed source files and a script for reproduction during a clang crash; -fno-debug-macro Do not emit macro debug information; -fno-delayed-template-parsing; Disable delayed template parsing; -fno-sanitize-address-poison-custom-array-cookie; Disable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fno-sanitize-address-use-after-scope; Disable use-after-scope detection in AddressSanitizer; -fno-sanitize-address-use-odr-indicator; Disable ODR indicator globals; -fno-sanitize-ignorelist Don't use ignorelist file for sanitizers; -fno-sanitize-cfi-cross-dso; Disable control flow integrity (CFI) checks for cross-DSO calls.; -fno-sanitize-coverage=<value>; Disable specified features of coverage instrumentation for Sanitizers; -fno-sanitize-memory-track-origins; Disable origins tracking in MemorySanitizer; -fno-sanitize-memory-use-after-dtor; Disable use-after-destroy detection in MemorySanitizer; -fno-sanitize-recover=<value>; Disable recovery for specified sanitizers; -fno-sanitize-stats Disable sanitizer statistics gathering.; -fno-sanitize-thread-atomics; Disable atomic operations instrumentation in ThreadSanitizer; -fno-sanitize-thread-func-entry-exit; Disable function entry/exit instrumentation in ThreadSanitizer; -fno-sanitize-thread-memory-access; Disable memory access instrumentation in ThreadSanitizer; -fno-sanitize-trap=<value>; Disable trapping for specified sanitizers; -fno-standalone-debug Limit debug information produced to reduce size of debug binary; -fno-strict-aliasing Disable optimizations based on strict aliasing rules (default); -fobjc-runtime=<value> Specify the target Objective-C runtime kind and version; -fprofile-exclude-files=<value>; Instrument only functions from files where names don't match all the regexes separated by a semi-colon; -fprofile-filter-files=<value>; Instrument o,MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:180696,Security,sanitiz,sanitize-recover,180696,icant under the Microsoft ABI; -fno-coverage-mapping Disable code coverage analysis; -fno-crash-diagnostics Disable auto-generation of preprocessed source files and a script for reproduction during a clang crash; -fno-debug-macro Do not emit macro debug information; -fno-delayed-template-parsing; Disable delayed template parsing; -fno-sanitize-address-poison-custom-array-cookie; Disable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fno-sanitize-address-use-after-scope; Disable use-after-scope detection in AddressSanitizer; -fno-sanitize-address-use-odr-indicator; Disable ODR indicator globals; -fno-sanitize-ignorelist Don't use ignorelist file for sanitizers; -fno-sanitize-cfi-cross-dso; Disable control flow integrity (CFI) checks for cross-DSO calls.; -fno-sanitize-coverage=<value>; Disable specified features of coverage instrumentation for Sanitizers; -fno-sanitize-memory-track-origins; Disable origins tracking in MemorySanitizer; -fno-sanitize-memory-use-after-dtor; Disable use-after-destroy detection in MemorySanitizer; -fno-sanitize-recover=<value>; Disable recovery for specified sanitizers; -fno-sanitize-stats Disable sanitizer statistics gathering.; -fno-sanitize-thread-atomics; Disable atomic operations instrumentation in ThreadSanitizer; -fno-sanitize-thread-func-entry-exit; Disable function entry/exit instrumentation in ThreadSanitizer; -fno-sanitize-thread-memory-access; Disable memory access instrumentation in ThreadSanitizer; -fno-sanitize-trap=<value>; Disable trapping for specified sanitizers; -fno-standalone-debug Limit debug information produced to reduce size of debug binary; -fno-strict-aliasing Disable optimizations based on strict aliasing rules (default); -fobjc-runtime=<value> Specify the target Objective-C runtime kind and version; -fprofile-exclude-files=<value>; Instrument only functions from files where names don't match all the regexes separated by a semi-colon; -fprofile-filter-files=<value>; Instrument o,MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:180753,Security,sanitiz,sanitizers,180753,icant under the Microsoft ABI; -fno-coverage-mapping Disable code coverage analysis; -fno-crash-diagnostics Disable auto-generation of preprocessed source files and a script for reproduction during a clang crash; -fno-debug-macro Do not emit macro debug information; -fno-delayed-template-parsing; Disable delayed template parsing; -fno-sanitize-address-poison-custom-array-cookie; Disable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fno-sanitize-address-use-after-scope; Disable use-after-scope detection in AddressSanitizer; -fno-sanitize-address-use-odr-indicator; Disable ODR indicator globals; -fno-sanitize-ignorelist Don't use ignorelist file for sanitizers; -fno-sanitize-cfi-cross-dso; Disable control flow integrity (CFI) checks for cross-DSO calls.; -fno-sanitize-coverage=<value>; Disable specified features of coverage instrumentation for Sanitizers; -fno-sanitize-memory-track-origins; Disable origins tracking in MemorySanitizer; -fno-sanitize-memory-use-after-dtor; Disable use-after-destroy detection in MemorySanitizer; -fno-sanitize-recover=<value>; Disable recovery for specified sanitizers; -fno-sanitize-stats Disable sanitizer statistics gathering.; -fno-sanitize-thread-atomics; Disable atomic operations instrumentation in ThreadSanitizer; -fno-sanitize-thread-func-entry-exit; Disable function entry/exit instrumentation in ThreadSanitizer; -fno-sanitize-thread-memory-access; Disable memory access instrumentation in ThreadSanitizer; -fno-sanitize-trap=<value>; Disable trapping for specified sanitizers; -fno-standalone-debug Limit debug information produced to reduce size of debug binary; -fno-strict-aliasing Disable optimizations based on strict aliasing rules (default); -fobjc-runtime=<value> Specify the target Objective-C runtime kind and version; -fprofile-exclude-files=<value>; Instrument only functions from files where names don't match all the regexes separated by a semi-colon; -fprofile-filter-files=<value>; Instrument o,MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:180770,Security,sanitiz,sanitize-stats,180770,icant under the Microsoft ABI; -fno-coverage-mapping Disable code coverage analysis; -fno-crash-diagnostics Disable auto-generation of preprocessed source files and a script for reproduction during a clang crash; -fno-debug-macro Do not emit macro debug information; -fno-delayed-template-parsing; Disable delayed template parsing; -fno-sanitize-address-poison-custom-array-cookie; Disable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fno-sanitize-address-use-after-scope; Disable use-after-scope detection in AddressSanitizer; -fno-sanitize-address-use-odr-indicator; Disable ODR indicator globals; -fno-sanitize-ignorelist Don't use ignorelist file for sanitizers; -fno-sanitize-cfi-cross-dso; Disable control flow integrity (CFI) checks for cross-DSO calls.; -fno-sanitize-coverage=<value>; Disable specified features of coverage instrumentation for Sanitizers; -fno-sanitize-memory-track-origins; Disable origins tracking in MemorySanitizer; -fno-sanitize-memory-use-after-dtor; Disable use-after-destroy detection in MemorySanitizer; -fno-sanitize-recover=<value>; Disable recovery for specified sanitizers; -fno-sanitize-stats Disable sanitizer statistics gathering.; -fno-sanitize-thread-atomics; Disable atomic operations instrumentation in ThreadSanitizer; -fno-sanitize-thread-func-entry-exit; Disable function entry/exit instrumentation in ThreadSanitizer; -fno-sanitize-thread-memory-access; Disable memory access instrumentation in ThreadSanitizer; -fno-sanitize-trap=<value>; Disable trapping for specified sanitizers; -fno-standalone-debug Limit debug information produced to reduce size of debug binary; -fno-strict-aliasing Disable optimizations based on strict aliasing rules (default); -fobjc-runtime=<value> Specify the target Objective-C runtime kind and version; -fprofile-exclude-files=<value>; Instrument only functions from files where names don't match all the regexes separated by a semi-colon; -fprofile-filter-files=<value>; Instrument o,MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:180793,Security,sanitiz,sanitizer,180793,icant under the Microsoft ABI; -fno-coverage-mapping Disable code coverage analysis; -fno-crash-diagnostics Disable auto-generation of preprocessed source files and a script for reproduction during a clang crash; -fno-debug-macro Do not emit macro debug information; -fno-delayed-template-parsing; Disable delayed template parsing; -fno-sanitize-address-poison-custom-array-cookie; Disable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fno-sanitize-address-use-after-scope; Disable use-after-scope detection in AddressSanitizer; -fno-sanitize-address-use-odr-indicator; Disable ODR indicator globals; -fno-sanitize-ignorelist Don't use ignorelist file for sanitizers; -fno-sanitize-cfi-cross-dso; Disable control flow integrity (CFI) checks for cross-DSO calls.; -fno-sanitize-coverage=<value>; Disable specified features of coverage instrumentation for Sanitizers; -fno-sanitize-memory-track-origins; Disable origins tracking in MemorySanitizer; -fno-sanitize-memory-use-after-dtor; Disable use-after-destroy detection in MemorySanitizer; -fno-sanitize-recover=<value>; Disable recovery for specified sanitizers; -fno-sanitize-stats Disable sanitizer statistics gathering.; -fno-sanitize-thread-atomics; Disable atomic operations instrumentation in ThreadSanitizer; -fno-sanitize-thread-func-entry-exit; Disable function entry/exit instrumentation in ThreadSanitizer; -fno-sanitize-thread-memory-access; Disable memory access instrumentation in ThreadSanitizer; -fno-sanitize-trap=<value>; Disable trapping for specified sanitizers; -fno-standalone-debug Limit debug information produced to reduce size of debug binary; -fno-strict-aliasing Disable optimizations based on strict aliasing rules (default); -fobjc-runtime=<value> Specify the target Objective-C runtime kind and version; -fprofile-exclude-files=<value>; Instrument only functions from files where names don't match all the regexes separated by a semi-colon; -fprofile-filter-files=<value>; Instrument o,MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:180831,Security,sanitiz,sanitize-thread-atomics,180831,cross-dso; Disable control flow integrity (CFI) checks for cross-DSO calls.; -fno-sanitize-coverage=<value>; Disable specified features of coverage instrumentation for Sanitizers; -fno-sanitize-memory-track-origins; Disable origins tracking in MemorySanitizer; -fno-sanitize-memory-use-after-dtor; Disable use-after-destroy detection in MemorySanitizer; -fno-sanitize-recover=<value>; Disable recovery for specified sanitizers; -fno-sanitize-stats Disable sanitizer statistics gathering.; -fno-sanitize-thread-atomics; Disable atomic operations instrumentation in ThreadSanitizer; -fno-sanitize-thread-func-entry-exit; Disable function entry/exit instrumentation in ThreadSanitizer; -fno-sanitize-thread-memory-access; Disable memory access instrumentation in ThreadSanitizer; -fno-sanitize-trap=<value>; Disable trapping for specified sanitizers; -fno-standalone-debug Limit debug information produced to reduce size of debug binary; -fno-strict-aliasing Disable optimizations based on strict aliasing rules (default); -fobjc-runtime=<value> Specify the target Objective-C runtime kind and version; -fprofile-exclude-files=<value>; Instrument only functions from files where names don't match all the regexes separated by a semi-colon; -fprofile-filter-files=<value>; Instrument only functions from files where names match any regex separated by a semi-colon; -fprofile-generate=<dirname>; Generate instrumented code to collect execution counts into a raw profile file in the directory specified by the argument. The filename uses default_%m.profraw pattern; (overridden by LLVM_PROFILE_FILE env var); -fprofile-generate; Generate instrumented code to collect execution counts into default_%m.profraw file; (overridden by '=' form of option or LLVM_PROFILE_FILE env var); -fprofile-instr-generate=<file_name_pattern>; Generate instrumented code to collect execution counts into the file whose name pattern is specified as the argument; (overridden by LLVM_PROFILE_FILE env var); -fprofile-instr-gene,MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:180923,Security,sanitiz,sanitize-thread-func-entry-exit,180923,cross-dso; Disable control flow integrity (CFI) checks for cross-DSO calls.; -fno-sanitize-coverage=<value>; Disable specified features of coverage instrumentation for Sanitizers; -fno-sanitize-memory-track-origins; Disable origins tracking in MemorySanitizer; -fno-sanitize-memory-use-after-dtor; Disable use-after-destroy detection in MemorySanitizer; -fno-sanitize-recover=<value>; Disable recovery for specified sanitizers; -fno-sanitize-stats Disable sanitizer statistics gathering.; -fno-sanitize-thread-atomics; Disable atomic operations instrumentation in ThreadSanitizer; -fno-sanitize-thread-func-entry-exit; Disable function entry/exit instrumentation in ThreadSanitizer; -fno-sanitize-thread-memory-access; Disable memory access instrumentation in ThreadSanitizer; -fno-sanitize-trap=<value>; Disable trapping for specified sanitizers; -fno-standalone-debug Limit debug information produced to reduce size of debug binary; -fno-strict-aliasing Disable optimizations based on strict aliasing rules (default); -fobjc-runtime=<value> Specify the target Objective-C runtime kind and version; -fprofile-exclude-files=<value>; Instrument only functions from files where names don't match all the regexes separated by a semi-colon; -fprofile-filter-files=<value>; Instrument only functions from files where names match any regex separated by a semi-colon; -fprofile-generate=<dirname>; Generate instrumented code to collect execution counts into a raw profile file in the directory specified by the argument. The filename uses default_%m.profraw pattern; (overridden by LLVM_PROFILE_FILE env var); -fprofile-generate; Generate instrumented code to collect execution counts into default_%m.profraw file; (overridden by '=' form of option or LLVM_PROFILE_FILE env var); -fprofile-instr-generate=<file_name_pattern>; Generate instrumented code to collect execution counts into the file whose name pattern is specified as the argument; (overridden by LLVM_PROFILE_FILE env var); -fprofile-instr-gene,MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:181025,Security,sanitiz,sanitize-thread-memory-access,181025,cross-dso; Disable control flow integrity (CFI) checks for cross-DSO calls.; -fno-sanitize-coverage=<value>; Disable specified features of coverage instrumentation for Sanitizers; -fno-sanitize-memory-track-origins; Disable origins tracking in MemorySanitizer; -fno-sanitize-memory-use-after-dtor; Disable use-after-destroy detection in MemorySanitizer; -fno-sanitize-recover=<value>; Disable recovery for specified sanitizers; -fno-sanitize-stats Disable sanitizer statistics gathering.; -fno-sanitize-thread-atomics; Disable atomic operations instrumentation in ThreadSanitizer; -fno-sanitize-thread-func-entry-exit; Disable function entry/exit instrumentation in ThreadSanitizer; -fno-sanitize-thread-memory-access; Disable memory access instrumentation in ThreadSanitizer; -fno-sanitize-trap=<value>; Disable trapping for specified sanitizers; -fno-standalone-debug Limit debug information produced to reduce size of debug binary; -fno-strict-aliasing Disable optimizations based on strict aliasing rules (default); -fobjc-runtime=<value> Specify the target Objective-C runtime kind and version; -fprofile-exclude-files=<value>; Instrument only functions from files where names don't match all the regexes separated by a semi-colon; -fprofile-filter-files=<value>; Instrument only functions from files where names match any regex separated by a semi-colon; -fprofile-generate=<dirname>; Generate instrumented code to collect execution counts into a raw profile file in the directory specified by the argument. The filename uses default_%m.profraw pattern; (overridden by LLVM_PROFILE_FILE env var); -fprofile-generate; Generate instrumented code to collect execution counts into default_%m.profraw file; (overridden by '=' form of option or LLVM_PROFILE_FILE env var); -fprofile-instr-generate=<file_name_pattern>; Generate instrumented code to collect execution counts into the file whose name pattern is specified as the argument; (overridden by LLVM_PROFILE_FILE env var); -fprofile-instr-gene,MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:181071,Security,access,access,181071,cross-dso; Disable control flow integrity (CFI) checks for cross-DSO calls.; -fno-sanitize-coverage=<value>; Disable specified features of coverage instrumentation for Sanitizers; -fno-sanitize-memory-track-origins; Disable origins tracking in MemorySanitizer; -fno-sanitize-memory-use-after-dtor; Disable use-after-destroy detection in MemorySanitizer; -fno-sanitize-recover=<value>; Disable recovery for specified sanitizers; -fno-sanitize-stats Disable sanitizer statistics gathering.; -fno-sanitize-thread-atomics; Disable atomic operations instrumentation in ThreadSanitizer; -fno-sanitize-thread-func-entry-exit; Disable function entry/exit instrumentation in ThreadSanitizer; -fno-sanitize-thread-memory-access; Disable memory access instrumentation in ThreadSanitizer; -fno-sanitize-trap=<value>; Disable trapping for specified sanitizers; -fno-standalone-debug Limit debug information produced to reduce size of debug binary; -fno-strict-aliasing Disable optimizations based on strict aliasing rules (default); -fobjc-runtime=<value> Specify the target Objective-C runtime kind and version; -fprofile-exclude-files=<value>; Instrument only functions from files where names don't match all the regexes separated by a semi-colon; -fprofile-filter-files=<value>; Instrument only functions from files where names match any regex separated by a semi-colon; -fprofile-generate=<dirname>; Generate instrumented code to collect execution counts into a raw profile file in the directory specified by the argument. The filename uses default_%m.profraw pattern; (overridden by LLVM_PROFILE_FILE env var); -fprofile-generate; Generate instrumented code to collect execution counts into default_%m.profraw file; (overridden by '=' form of option or LLVM_PROFILE_FILE env var); -fprofile-instr-generate=<file_name_pattern>; Generate instrumented code to collect execution counts into the file whose name pattern is specified as the argument; (overridden by LLVM_PROFILE_FILE env var); -fprofile-instr-gene,MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:181119,Security,sanitiz,sanitize-trap,181119,cross-dso; Disable control flow integrity (CFI) checks for cross-DSO calls.; -fno-sanitize-coverage=<value>; Disable specified features of coverage instrumentation for Sanitizers; -fno-sanitize-memory-track-origins; Disable origins tracking in MemorySanitizer; -fno-sanitize-memory-use-after-dtor; Disable use-after-destroy detection in MemorySanitizer; -fno-sanitize-recover=<value>; Disable recovery for specified sanitizers; -fno-sanitize-stats Disable sanitizer statistics gathering.; -fno-sanitize-thread-atomics; Disable atomic operations instrumentation in ThreadSanitizer; -fno-sanitize-thread-func-entry-exit; Disable function entry/exit instrumentation in ThreadSanitizer; -fno-sanitize-thread-memory-access; Disable memory access instrumentation in ThreadSanitizer; -fno-sanitize-trap=<value>; Disable trapping for specified sanitizers; -fno-standalone-debug Limit debug information produced to reduce size of debug binary; -fno-strict-aliasing Disable optimizations based on strict aliasing rules (default); -fobjc-runtime=<value> Specify the target Objective-C runtime kind and version; -fprofile-exclude-files=<value>; Instrument only functions from files where names don't match all the regexes separated by a semi-colon; -fprofile-filter-files=<value>; Instrument only functions from files where names match any regex separated by a semi-colon; -fprofile-generate=<dirname>; Generate instrumented code to collect execution counts into a raw profile file in the directory specified by the argument. The filename uses default_%m.profraw pattern; (overridden by LLVM_PROFILE_FILE env var); -fprofile-generate; Generate instrumented code to collect execution counts into default_%m.profraw file; (overridden by '=' form of option or LLVM_PROFILE_FILE env var); -fprofile-instr-generate=<file_name_pattern>; Generate instrumented code to collect execution counts into the file whose name pattern is specified as the argument; (overridden by LLVM_PROFILE_FILE env var); -fprofile-instr-gene,MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:181173,Security,sanitiz,sanitizers,181173,cross-dso; Disable control flow integrity (CFI) checks for cross-DSO calls.; -fno-sanitize-coverage=<value>; Disable specified features of coverage instrumentation for Sanitizers; -fno-sanitize-memory-track-origins; Disable origins tracking in MemorySanitizer; -fno-sanitize-memory-use-after-dtor; Disable use-after-destroy detection in MemorySanitizer; -fno-sanitize-recover=<value>; Disable recovery for specified sanitizers; -fno-sanitize-stats Disable sanitizer statistics gathering.; -fno-sanitize-thread-atomics; Disable atomic operations instrumentation in ThreadSanitizer; -fno-sanitize-thread-func-entry-exit; Disable function entry/exit instrumentation in ThreadSanitizer; -fno-sanitize-thread-memory-access; Disable memory access instrumentation in ThreadSanitizer; -fno-sanitize-trap=<value>; Disable trapping for specified sanitizers; -fno-standalone-debug Limit debug information produced to reduce size of debug binary; -fno-strict-aliasing Disable optimizations based on strict aliasing rules (default); -fobjc-runtime=<value> Specify the target Objective-C runtime kind and version; -fprofile-exclude-files=<value>; Instrument only functions from files where names don't match all the regexes separated by a semi-colon; -fprofile-filter-files=<value>; Instrument only functions from files where names match any regex separated by a semi-colon; -fprofile-generate=<dirname>; Generate instrumented code to collect execution counts into a raw profile file in the directory specified by the argument. The filename uses default_%m.profraw pattern; (overridden by LLVM_PROFILE_FILE env var); -fprofile-generate; Generate instrumented code to collect execution counts into default_%m.profraw file; (overridden by '=' form of option or LLVM_PROFILE_FILE env var); -fprofile-instr-generate=<file_name_pattern>; Generate instrumented code to collect execution counts into the file whose name pattern is specified as the argument; (overridden by LLVM_PROFILE_FILE env var); -fprofile-instr-gene,MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:183573,Security,sanitiz,sanitized,183573," var); -fprofile-instr-generate=<file_name_pattern>; Generate instrumented code to collect execution counts into the file whose name pattern is specified as the argument; (overridden by LLVM_PROFILE_FILE env var); -fprofile-instr-generate; Generate instrumented code to collect execution counts into default.profraw file; (overridden by '=' form of option or LLVM_PROFILE_FILE env var); -fprofile-instr-use=<value>; Use instrumentation data for coverage testing or profile-guided optimization; -fprofile-use=<value>; Use instrumentation data for profile-guided optimization; -fprofile-remapping-file=<file>; Use the remappings described in <file> to match the profile data against names in the program; -fprofile-list=<file>; Filename defining the list of functions/files to instrument; -fsanitize-address-field-padding=<value>; Level of field padding for AddressSanitizer; -fsanitize-address-globals-dead-stripping; Enable linker dead stripping of globals in AddressSanitizer; -fsanitize-address-poison-custom-array-cookie; Enable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fsanitize-address-use-after-return=<mode>; Select the mode of detecting stack use-after-return in AddressSanitizer: never | runtime (default) | always; -fsanitize-address-use-after-scope; Enable use-after-scope detection in AddressSanitizer; -fsanitize-address-use-odr-indicator; Enable ODR indicator globals to avoid false ODR violation reports in partially sanitized programs at the cost of an increase in binary size; -fsanitize-ignorelist=<value>; Path to ignorelist file for sanitizers; -fsanitize-cfi-cross-dso; Enable control flow integrity (CFI) checks for cross-DSO calls.; -fsanitize-cfi-icall-generalize-pointers; Generalize pointers in CFI indirect call type signature checks; -fsanitize-coverage=<value>; Specify the type of coverage instrumentation for Sanitizers; -fsanitize-hwaddress-abi=<value>; Select the HWAddressSanitizer ABI to target (interceptor or platform, defaul",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:183694,Security,sanitiz,sanitizers,183694," var); -fprofile-instr-generate=<file_name_pattern>; Generate instrumented code to collect execution counts into the file whose name pattern is specified as the argument; (overridden by LLVM_PROFILE_FILE env var); -fprofile-instr-generate; Generate instrumented code to collect execution counts into default.profraw file; (overridden by '=' form of option or LLVM_PROFILE_FILE env var); -fprofile-instr-use=<value>; Use instrumentation data for coverage testing or profile-guided optimization; -fprofile-use=<value>; Use instrumentation data for profile-guided optimization; -fprofile-remapping-file=<file>; Use the remappings described in <file> to match the profile data against names in the program; -fprofile-list=<file>; Filename defining the list of functions/files to instrument; -fsanitize-address-field-padding=<value>; Level of field padding for AddressSanitizer; -fsanitize-address-globals-dead-stripping; Enable linker dead stripping of globals in AddressSanitizer; -fsanitize-address-poison-custom-array-cookie; Enable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fsanitize-address-use-after-return=<mode>; Select the mode of detecting stack use-after-return in AddressSanitizer: never | runtime (default) | always; -fsanitize-address-use-after-scope; Enable use-after-scope detection in AddressSanitizer; -fsanitize-address-use-odr-indicator; Enable ODR indicator globals to avoid false ODR violation reports in partially sanitized programs at the cost of an increase in binary size; -fsanitize-ignorelist=<value>; Path to ignorelist file for sanitizers; -fsanitize-cfi-cross-dso; Enable control flow integrity (CFI) checks for cross-DSO calls.; -fsanitize-cfi-icall-generalize-pointers; Generalize pointers in CFI indirect call type signature checks; -fsanitize-coverage=<value>; Specify the type of coverage instrumentation for Sanitizers; -fsanitize-hwaddress-abi=<value>; Select the HWAddressSanitizer ABI to target (interceptor or platform, defaul",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:183752,Security,integrity,integrity,183752," var); -fprofile-instr-generate=<file_name_pattern>; Generate instrumented code to collect execution counts into the file whose name pattern is specified as the argument; (overridden by LLVM_PROFILE_FILE env var); -fprofile-instr-generate; Generate instrumented code to collect execution counts into default.profraw file; (overridden by '=' form of option or LLVM_PROFILE_FILE env var); -fprofile-instr-use=<value>; Use instrumentation data for coverage testing or profile-guided optimization; -fprofile-use=<value>; Use instrumentation data for profile-guided optimization; -fprofile-remapping-file=<file>; Use the remappings described in <file> to match the profile data against names in the program; -fprofile-list=<file>; Filename defining the list of functions/files to instrument; -fsanitize-address-field-padding=<value>; Level of field padding for AddressSanitizer; -fsanitize-address-globals-dead-stripping; Enable linker dead stripping of globals in AddressSanitizer; -fsanitize-address-poison-custom-array-cookie; Enable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fsanitize-address-use-after-return=<mode>; Select the mode of detecting stack use-after-return in AddressSanitizer: never | runtime (default) | always; -fsanitize-address-use-after-scope; Enable use-after-scope detection in AddressSanitizer; -fsanitize-address-use-odr-indicator; Enable ODR indicator globals to avoid false ODR violation reports in partially sanitized programs at the cost of an increase in binary size; -fsanitize-ignorelist=<value>; Path to ignorelist file for sanitizers; -fsanitize-cfi-cross-dso; Enable control flow integrity (CFI) checks for cross-DSO calls.; -fsanitize-cfi-icall-generalize-pointers; Generalize pointers in CFI indirect call type signature checks; -fsanitize-coverage=<value>; Specify the type of coverage instrumentation for Sanitizers; -fsanitize-hwaddress-abi=<value>; Select the HWAddressSanitizer ABI to target (interceptor or platform, defaul",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:184428,Security,sanitiz,sanitizers,184428,"array cookies when using custom operator new[] in AddressSanitizer; -fsanitize-address-use-after-return=<mode>; Select the mode of detecting stack use-after-return in AddressSanitizer: never | runtime (default) | always; -fsanitize-address-use-after-scope; Enable use-after-scope detection in AddressSanitizer; -fsanitize-address-use-odr-indicator; Enable ODR indicator globals to avoid false ODR violation reports in partially sanitized programs at the cost of an increase in binary size; -fsanitize-ignorelist=<value>; Path to ignorelist file for sanitizers; -fsanitize-cfi-cross-dso; Enable control flow integrity (CFI) checks for cross-DSO calls.; -fsanitize-cfi-icall-generalize-pointers; Generalize pointers in CFI indirect call type signature checks; -fsanitize-coverage=<value>; Specify the type of coverage instrumentation for Sanitizers; -fsanitize-hwaddress-abi=<value>; Select the HWAddressSanitizer ABI to target (interceptor or platform, default interceptor); -fsanitize-memory-track-origins=<value>; Enable origins tracking in MemorySanitizer; -fsanitize-memory-track-origins; Enable origins tracking in MemorySanitizer; -fsanitize-memory-use-after-dtor; Enable use-after-destroy detection in MemorySanitizer; -fsanitize-recover=<value>; Enable recovery for specified sanitizers; -fsanitize-stats Enable sanitizer statistics gathering.; -fsanitize-thread-atomics; Enable atomic operations instrumentation in ThreadSanitizer (default); -fsanitize-thread-func-entry-exit; Enable function entry/exit instrumentation in ThreadSanitizer (default); -fsanitize-thread-memory-access; Enable memory access instrumentation in ThreadSanitizer (default); -fsanitize-trap=<value> Enable trapping for specified sanitizers; -fsanitize-undefined-strip-path-components=<number>; Strip (or keep only, if negative) a given number of path components when emitting check metadata.; -fsanitize=<check> Turn on runtime checks for various forms of undefined or suspicious; behavior. See user manual for availa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:184464,Security,sanitiz,sanitizer,184464,"array cookies when using custom operator new[] in AddressSanitizer; -fsanitize-address-use-after-return=<mode>; Select the mode of detecting stack use-after-return in AddressSanitizer: never | runtime (default) | always; -fsanitize-address-use-after-scope; Enable use-after-scope detection in AddressSanitizer; -fsanitize-address-use-odr-indicator; Enable ODR indicator globals to avoid false ODR violation reports in partially sanitized programs at the cost of an increase in binary size; -fsanitize-ignorelist=<value>; Path to ignorelist file for sanitizers; -fsanitize-cfi-cross-dso; Enable control flow integrity (CFI) checks for cross-DSO calls.; -fsanitize-cfi-icall-generalize-pointers; Generalize pointers in CFI indirect call type signature checks; -fsanitize-coverage=<value>; Specify the type of coverage instrumentation for Sanitizers; -fsanitize-hwaddress-abi=<value>; Select the HWAddressSanitizer ABI to target (interceptor or platform, default interceptor); -fsanitize-memory-track-origins=<value>; Enable origins tracking in MemorySanitizer; -fsanitize-memory-track-origins; Enable origins tracking in MemorySanitizer; -fsanitize-memory-use-after-dtor; Enable use-after-destroy detection in MemorySanitizer; -fsanitize-recover=<value>; Enable recovery for specified sanitizers; -fsanitize-stats Enable sanitizer statistics gathering.; -fsanitize-thread-atomics; Enable atomic operations instrumentation in ThreadSanitizer (default); -fsanitize-thread-func-entry-exit; Enable function entry/exit instrumentation in ThreadSanitizer (default); -fsanitize-thread-memory-access; Enable memory access instrumentation in ThreadSanitizer (default); -fsanitize-trap=<value> Enable trapping for specified sanitizers; -fsanitize-undefined-strip-path-components=<number>; Strip (or keep only, if negative) a given number of path components when emitting check metadata.; -fsanitize=<check> Turn on runtime checks for various forms of undefined or suspicious; behavior. See user manual for availa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:184728,Security,access,access,184728,"rity (CFI) checks for cross-DSO calls.; -fsanitize-cfi-icall-generalize-pointers; Generalize pointers in CFI indirect call type signature checks; -fsanitize-coverage=<value>; Specify the type of coverage instrumentation for Sanitizers; -fsanitize-hwaddress-abi=<value>; Select the HWAddressSanitizer ABI to target (interceptor or platform, default interceptor); -fsanitize-memory-track-origins=<value>; Enable origins tracking in MemorySanitizer; -fsanitize-memory-track-origins; Enable origins tracking in MemorySanitizer; -fsanitize-memory-use-after-dtor; Enable use-after-destroy detection in MemorySanitizer; -fsanitize-recover=<value>; Enable recovery for specified sanitizers; -fsanitize-stats Enable sanitizer statistics gathering.; -fsanitize-thread-atomics; Enable atomic operations instrumentation in ThreadSanitizer (default); -fsanitize-thread-func-entry-exit; Enable function entry/exit instrumentation in ThreadSanitizer (default); -fsanitize-thread-memory-access; Enable memory access instrumentation in ThreadSanitizer (default); -fsanitize-trap=<value> Enable trapping for specified sanitizers; -fsanitize-undefined-strip-path-components=<number>; Strip (or keep only, if negative) a given number of path components when emitting check metadata.; -fsanitize=<check> Turn on runtime checks for various forms of undefined or suspicious; behavior. See user manual for available checks; -fsplit-lto-unit Enables splitting of the LTO unit.; -fstandalone-debug Emit full debug info for all types used by the program; -fstrict-aliasing	 Enable optimizations based on strict aliasing rules; -fsyntax-only Run the preprocessor, parser and semantic analysis stages; -fwhole-program-vtables Enables whole-program vtable optimization. Requires -flto; -gcodeview-ghash Emit type record hashes in a .debug$H section; -gcodeview Generate CodeView debug information; -gline-directives-only Emit debug line info directives only; -gline-tables-only Emit debug line number tables only; -miamcu Use Inte",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:184750,Security,access,access,184750,"rity (CFI) checks for cross-DSO calls.; -fsanitize-cfi-icall-generalize-pointers; Generalize pointers in CFI indirect call type signature checks; -fsanitize-coverage=<value>; Specify the type of coverage instrumentation for Sanitizers; -fsanitize-hwaddress-abi=<value>; Select the HWAddressSanitizer ABI to target (interceptor or platform, default interceptor); -fsanitize-memory-track-origins=<value>; Enable origins tracking in MemorySanitizer; -fsanitize-memory-track-origins; Enable origins tracking in MemorySanitizer; -fsanitize-memory-use-after-dtor; Enable use-after-destroy detection in MemorySanitizer; -fsanitize-recover=<value>; Enable recovery for specified sanitizers; -fsanitize-stats Enable sanitizer statistics gathering.; -fsanitize-thread-atomics; Enable atomic operations instrumentation in ThreadSanitizer (default); -fsanitize-thread-func-entry-exit; Enable function entry/exit instrumentation in ThreadSanitizer (default); -fsanitize-thread-memory-access; Enable memory access instrumentation in ThreadSanitizer (default); -fsanitize-trap=<value> Enable trapping for specified sanitizers; -fsanitize-undefined-strip-path-components=<number>; Strip (or keep only, if negative) a given number of path components when emitting check metadata.; -fsanitize=<check> Turn on runtime checks for various forms of undefined or suspicious; behavior. See user manual for available checks; -fsplit-lto-unit Enables splitting of the LTO unit.; -fstandalone-debug Emit full debug info for all types used by the program; -fstrict-aliasing	 Enable optimizations based on strict aliasing rules; -fsyntax-only Run the preprocessor, parser and semantic analysis stages; -fwhole-program-vtables Enables whole-program vtable optimization. Requires -flto; -gcodeview-ghash Emit type record hashes in a .debug$H section; -gcodeview Generate CodeView debug information; -gline-directives-only Emit debug line info directives only; -gline-tables-only Emit debug line number tables only; -miamcu Use Inte",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:184857,Security,sanitiz,sanitizers,184857,"rity (CFI) checks for cross-DSO calls.; -fsanitize-cfi-icall-generalize-pointers; Generalize pointers in CFI indirect call type signature checks; -fsanitize-coverage=<value>; Specify the type of coverage instrumentation for Sanitizers; -fsanitize-hwaddress-abi=<value>; Select the HWAddressSanitizer ABI to target (interceptor or platform, default interceptor); -fsanitize-memory-track-origins=<value>; Enable origins tracking in MemorySanitizer; -fsanitize-memory-track-origins; Enable origins tracking in MemorySanitizer; -fsanitize-memory-use-after-dtor; Enable use-after-destroy detection in MemorySanitizer; -fsanitize-recover=<value>; Enable recovery for specified sanitizers; -fsanitize-stats Enable sanitizer statistics gathering.; -fsanitize-thread-atomics; Enable atomic operations instrumentation in ThreadSanitizer (default); -fsanitize-thread-func-entry-exit; Enable function entry/exit instrumentation in ThreadSanitizer (default); -fsanitize-thread-memory-access; Enable memory access instrumentation in ThreadSanitizer (default); -fsanitize-trap=<value> Enable trapping for specified sanitizers; -fsanitize-undefined-strip-path-components=<number>; Strip (or keep only, if negative) a given number of path components when emitting check metadata.; -fsanitize=<check> Turn on runtime checks for various forms of undefined or suspicious; behavior. See user manual for available checks; -fsplit-lto-unit Enables splitting of the LTO unit.; -fstandalone-debug Emit full debug info for all types used by the program; -fstrict-aliasing	 Enable optimizations based on strict aliasing rules; -fsyntax-only Run the preprocessor, parser and semantic analysis stages; -fwhole-program-vtables Enables whole-program vtable optimization. Requires -flto; -gcodeview-ghash Emit type record hashes in a .debug$H section; -gcodeview Generate CodeView debug information; -gline-directives-only Emit debug line info directives only; -gline-tables-only Emit debug line number tables only; -miamcu Use Inte",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:185547,Security,hash,hashes,185547,"le atomic operations instrumentation in ThreadSanitizer (default); -fsanitize-thread-func-entry-exit; Enable function entry/exit instrumentation in ThreadSanitizer (default); -fsanitize-thread-memory-access; Enable memory access instrumentation in ThreadSanitizer (default); -fsanitize-trap=<value> Enable trapping for specified sanitizers; -fsanitize-undefined-strip-path-components=<number>; Strip (or keep only, if negative) a given number of path components when emitting check metadata.; -fsanitize=<check> Turn on runtime checks for various forms of undefined or suspicious; behavior. See user manual for available checks; -fsplit-lto-unit Enables splitting of the LTO unit.; -fstandalone-debug Emit full debug info for all types used by the program; -fstrict-aliasing	 Enable optimizations based on strict aliasing rules; -fsyntax-only Run the preprocessor, parser and semantic analysis stages; -fwhole-program-vtables Enables whole-program vtable optimization. Requires -flto; -gcodeview-ghash Emit type record hashes in a .debug$H section; -gcodeview Generate CodeView debug information; -gline-directives-only Emit debug line info directives only; -gline-tables-only Emit debug line number tables only; -miamcu Use Intel MCU ABI; -mllvm <value> Additional arguments to forward to LLVM's option processing; -nobuiltininc Disable builtin #include directories; -Qunused-arguments Don't emit warning for unused driver arguments; -R<remark> Enable the specified remark; --target=<value> Generate code for the given target; --version Print version information; -v Show commands to run and use verbose output; -W<warning> Enable the specified warning; -Xclang <arg> Pass <arg> to the clang compiler. The /clang: Option; ^^^^^^^^^^^^^^^^^^. When clang-cl is run with a set of ``/clang:<arg>`` options, it will gather all; of the ``<arg>`` arguments and process them as if they were passed to the clang; driver. This mechanism allows you to pass flags that are not exposed in the; clang-cl options o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:186494,Security,expose,exposed,186494,"view-ghash Emit type record hashes in a .debug$H section; -gcodeview Generate CodeView debug information; -gline-directives-only Emit debug line info directives only; -gline-tables-only Emit debug line number tables only; -miamcu Use Intel MCU ABI; -mllvm <value> Additional arguments to forward to LLVM's option processing; -nobuiltininc Disable builtin #include directories; -Qunused-arguments Don't emit warning for unused driver arguments; -R<remark> Enable the specified remark; --target=<value> Generate code for the given target; --version Print version information; -v Show commands to run and use verbose output; -W<warning> Enable the specified warning; -Xclang <arg> Pass <arg> to the clang compiler. The /clang: Option; ^^^^^^^^^^^^^^^^^^. When clang-cl is run with a set of ``/clang:<arg>`` options, it will gather all; of the ``<arg>`` arguments and process them as if they were passed to the clang; driver. This mechanism allows you to pass flags that are not exposed in the; clang-cl options or flags that have a different meaning when passed to the clang; driver. Regardless of where they appear in the command line, the ``/clang:``; arguments are treated as if they were passed at the end of the clang-cl command; line. The /Zc:dllexportInlines- Option; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This causes the class-level `dllexport` and `dllimport` attributes to not apply; to inline member functions, as they otherwise would. For example, in the code; below `S::foo()` would normally be defined and exported by the DLL, but when; using the ``/Zc:dllexportInlines-`` flag it is not:. .. code-block:: c. struct __declspec(dllexport) S {; void foo() {}; }. This has the benefit that the compiler doesn't need to emit a definition of; `S::foo()` in every translation unit where the declaration is included, as it; would otherwise do to ensure there's a definition in the DLL even if it's not; used there. If the declaration occurs in a header file that's widely used, this; can save signific",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:194804,Security,validat,validation,194804,"ols that allow the user control over where clang-cl will; locate these headers. The default behaviour for the Windows SDK and UCRT is as; follows:. 1. Consult the command line. Anything the user specifies is always given precedence. The following; extensions are part of the clang-cl toolset:. - `/winsysroot:`. The `/winsysroot:` is used as an equivalent to `-sysroot` on Unix; environments. It allows the control of an alternate location to be treated; as a system root. When specified, it will be used as the root where the; `Windows Kits` is located. - `/winsdkversion:`; - `/winsdkdir:`. If `/winsysroot:` is not specified, the `/winsdkdir:` argument is consulted; as a location to identify where the Windows SDK is located. Contrary to; `/winsysroot:`, `/winsdkdir:` is expected to be the complete path rather; than a root to locate `Windows Kits`. The `/winsdkversion:` flag allows the user to specify a version identifier; for the SDK to prefer. When this is specified, no additional validation is; performed and this version is preferred. If the version is not specified,; the highest detected version number will be used. 2. Consult the environment. TODO: This is not yet implemented. This will consult the environment variables:. - `WindowsSdkDir`; - `UCRTVersion`. 3. Fallback to the registry. If no arguments are used to indicate where the SDK is present, and the; compiler is running on Windows, the registry is consulted to locate the; installation. The Visual C++ Toolset has a slightly more elaborate mechanism for detection. 1. Consult the command line. - `/winsysroot:`. The `/winsysroot:` is used as an equivalent to `-sysroot` on Unix; environments. It allows the control of an alternate location to be treated; as a system root. When specified, it will be used as the root where the; `VC` directory is located. - `/vctoolsdir:`; - `/vctoolsversion:`. If `/winsysroot:` is not specified, the `/vctoolsdir:` argument is consulted; as a location to identify where the Visual C++ To",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:196647,Security,validat,validate,196647,"ory is located. - `/vctoolsdir:`; - `/vctoolsversion:`. If `/winsysroot:` is not specified, the `/vctoolsdir:` argument is consulted; as a location to identify where the Visual C++ Tools are located. If; `/vctoolsversion:` is specified, that version is preferred, otherwise, the; highest version detected is used. 2. Consult the environment. - `/external:[VARIABLE]`. This specifies a user identified environment variable which is treated as; a path delimiter (`;`) separated list of paths to map into `-imsvc`; arguments which are treated as `-isystem`. - `INCLUDE` and `EXTERNAL_INCLUDE`. The path delimiter (`;`) separated list of paths will be mapped to; `-imsvc` arguments which are treated as `-isystem`. - `LIB` (indirectly). The linker `link.exe` or `lld-link.exe` will honour the environment; variable `LIB` which is a path delimiter (`;`) set of paths to consult for; the import libraries to use when linking the final target. The following environment variables will be consulted and used to form paths; to validate and load content from as appropriate:. - `VCToolsInstallDir`; - `VCINSTALLDIR`; - `Path`. 3. Consult `ISetupConfiguration` [Windows Only]. Assuming that the toolchain is built with `USE_MSVC_SETUP_API` defined and; is running on Windows, the Visual Studio COM interface `ISetupConfiguration`; will be used to locate the installation of the MSVC toolset. 4. Fallback to the registry [DEPRECATED]. The registry information is used to help locate the installation as a final; fallback. This is only possible for pre-VS2017 installations and is; considered deprecated. Restrictions and Limitations compared to Clang; ----------------------------------------------. Strict Aliasing; ^^^^^^^^^^^^^^^. Strict aliasing (TBAA) is always off by default in clang-cl. Whereas in clang,; strict aliasing is turned on by default for all optimization levels. To enable LLVM optimizations based on strict aliasing rules (e.g., optimizations; based on type of expressions in C/C++), user wil",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:5875,Testability,test,test,5875,"ate-backtrace-limit=123. Only emit up to 123 template instantiation notes within the template; instantiation backtrace for a single warning or error. The default is 10, and; the limit can be disabled with `-ftemplate-backtrace-limit=0`. .. _cl_diag_formatting:. Formatting of Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^^. Clang aims to produce beautiful diagnostics by default, particularly for; new users that first come to Clang. However, different people have; different preferences, and sometimes Clang is driven not by a human,; but by a program that wants consistent and easily parsable output. For; these cases, Clang provides a wide range of options to control the exact; output format of the diagnostics that it generates. .. _opt_fshow-column:. .. option:: -f[no-]show-column. Print column number in diagnostic. This option, which defaults to on, controls whether or not Clang; prints the column number of a diagnostic. For example, when this is; enabled, Clang will print something like:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. When this is disabled, Clang will print ""test.c:28: warning..."" with; no column number. The printed column numbers count bytes from the beginning of the; line; take care if your source contains multibyte characters. .. _opt_fshow-source-location:. .. option:: -f[no-]show-source-location. Print source file/line/column information in diagnostic. This option, which defaults to on, controls whether or not Clang; prints the filename, line number and column number of a diagnostic.; For example, when this is enabled, Clang will print something like:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. When this is disabled, Clang will not print the ""test.c:28:8: ""; part. .. _opt_fcaret-diagnostics:. .. option:: -f[no-]caret-diagnostics. Print source line and ranges from source code in diagnostic.; This option, which defaults to on, controls whethe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:6015,Testability,test,test,6015,"for a single warning or error. The default is 10, and; the limit can be disabled with `-ftemplate-backtrace-limit=0`. .. _cl_diag_formatting:. Formatting of Diagnostics; ^^^^^^^^^^^^^^^^^^^^^^^^^. Clang aims to produce beautiful diagnostics by default, particularly for; new users that first come to Clang. However, different people have; different preferences, and sometimes Clang is driven not by a human,; but by a program that wants consistent and easily parsable output. For; these cases, Clang provides a wide range of options to control the exact; output format of the diagnostics that it generates. .. _opt_fshow-column:. .. option:: -f[no-]show-column. Print column number in diagnostic. This option, which defaults to on, controls whether or not Clang; prints the column number of a diagnostic. For example, when this is; enabled, Clang will print something like:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. When this is disabled, Clang will print ""test.c:28: warning..."" with; no column number. The printed column numbers count bytes from the beginning of the; line; take care if your source contains multibyte characters. .. _opt_fshow-source-location:. .. option:: -f[no-]show-source-location. Print source file/line/column information in diagnostic. This option, which defaults to on, controls whether or not Clang; prints the filename, line number and column number of a diagnostic.; For example, when this is enabled, Clang will print something like:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. When this is disabled, Clang will not print the ""test.c:28:8: ""; part. .. _opt_fcaret-diagnostics:. .. option:: -f[no-]caret-diagnostics. Print source line and ranges from source code in diagnostic.; This option, which defaults to on, controls whether or not Clang; prints the source line, source ranges, and caret when emitting a; diagnostic. For example, when this is ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:6528,Testability,test,test,6528,"o control the exact; output format of the diagnostics that it generates. .. _opt_fshow-column:. .. option:: -f[no-]show-column. Print column number in diagnostic. This option, which defaults to on, controls whether or not Clang; prints the column number of a diagnostic. For example, when this is; enabled, Clang will print something like:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. When this is disabled, Clang will print ""test.c:28: warning..."" with; no column number. The printed column numbers count bytes from the beginning of the; line; take care if your source contains multibyte characters. .. _opt_fshow-source-location:. .. option:: -f[no-]show-source-location. Print source file/line/column information in diagnostic. This option, which defaults to on, controls whether or not Clang; prints the filename, line number and column number of a diagnostic.; For example, when this is enabled, Clang will print something like:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. When this is disabled, Clang will not print the ""test.c:28:8: ""; part. .. _opt_fcaret-diagnostics:. .. option:: -f[no-]caret-diagnostics. Print source line and ranges from source code in diagnostic.; This option, which defaults to on, controls whether or not Clang; prints the source line, source ranges, and caret when emitting a; diagnostic. For example, when this is enabled, Clang will print; something like:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. .. option:: -f[no-]color-diagnostics. This option, which defaults to on when a color-capable terminal is; detected, controls whether or not Clang prints diagnostics in color. When this option is enabled, Clang will use colors to highlight; specific parts of the diagnostic, e.g.,. .. nasty hack to not lose our dignity. .. raw:: html. <pre>; <b><span style=""color:black"">test.c:28:8: <s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:6676,Testability,test,test,6676,"umn. Print column number in diagnostic. This option, which defaults to on, controls whether or not Clang; prints the column number of a diagnostic. For example, when this is; enabled, Clang will print something like:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. When this is disabled, Clang will print ""test.c:28: warning..."" with; no column number. The printed column numbers count bytes from the beginning of the; line; take care if your source contains multibyte characters. .. _opt_fshow-source-location:. .. option:: -f[no-]show-source-location. Print source file/line/column information in diagnostic. This option, which defaults to on, controls whether or not Clang; prints the filename, line number and column number of a diagnostic.; For example, when this is enabled, Clang will print something like:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. When this is disabled, Clang will not print the ""test.c:28:8: ""; part. .. _opt_fcaret-diagnostics:. .. option:: -f[no-]caret-diagnostics. Print source line and ranges from source code in diagnostic.; This option, which defaults to on, controls whether or not Clang; prints the source line, source ranges, and caret when emitting a; diagnostic. For example, when this is enabled, Clang will print; something like:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. .. option:: -f[no-]color-diagnostics. This option, which defaults to on when a color-capable terminal is; detected, controls whether or not Clang prints diagnostics in color. When this option is enabled, Clang will use colors to highlight; specific parts of the diagnostic, e.g.,. .. nasty hack to not lose our dignity. .. raw:: html. <pre>; <b><span style=""color:black"">test.c:28:8: <span style=""color:magenta"">warning</span>: extra tokens at end of #endif directive [-Wextra-tokens]</span></b>; #endif bad; <",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:7045,Testability,test,test,7045,"column number. The printed column numbers count bytes from the beginning of the; line; take care if your source contains multibyte characters. .. _opt_fshow-source-location:. .. option:: -f[no-]show-source-location. Print source file/line/column information in diagnostic. This option, which defaults to on, controls whether or not Clang; prints the filename, line number and column number of a diagnostic.; For example, when this is enabled, Clang will print something like:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. When this is disabled, Clang will not print the ""test.c:28:8: ""; part. .. _opt_fcaret-diagnostics:. .. option:: -f[no-]caret-diagnostics. Print source line and ranges from source code in diagnostic.; This option, which defaults to on, controls whether or not Clang; prints the source line, source ranges, and caret when emitting a; diagnostic. For example, when this is enabled, Clang will print; something like:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. .. option:: -f[no-]color-diagnostics. This option, which defaults to on when a color-capable terminal is; detected, controls whether or not Clang prints diagnostics in color. When this option is enabled, Clang will use colors to highlight; specific parts of the diagnostic, e.g.,. .. nasty hack to not lose our dignity. .. raw:: html. <pre>; <b><span style=""color:black"">test.c:28:8: <span style=""color:magenta"">warning</span>: extra tokens at end of #endif directive [-Wextra-tokens]</span></b>; #endif bad; <span style=""color:green"">^</span>; <span style=""color:green"">//</span>; </pre>. When this is disabled, Clang will just print:. ::. test.c:2:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. If the ``NO_COLOR`` environment variable is defined and not empty; (regardless of value), color diagnostics are disabled. If ``NO_COLOR`` is; defined and ``-fcolor-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:7515,Testability,test,test,7515,"l print something like:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. When this is disabled, Clang will not print the ""test.c:28:8: ""; part. .. _opt_fcaret-diagnostics:. .. option:: -f[no-]caret-diagnostics. Print source line and ranges from source code in diagnostic.; This option, which defaults to on, controls whether or not Clang; prints the source line, source ranges, and caret when emitting a; diagnostic. For example, when this is enabled, Clang will print; something like:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. .. option:: -f[no-]color-diagnostics. This option, which defaults to on when a color-capable terminal is; detected, controls whether or not Clang prints diagnostics in color. When this option is enabled, Clang will use colors to highlight; specific parts of the diagnostic, e.g.,. .. nasty hack to not lose our dignity. .. raw:: html. <pre>; <b><span style=""color:black"">test.c:28:8: <span style=""color:magenta"">warning</span>: extra tokens at end of #endif directive [-Wextra-tokens]</span></b>; #endif bad; <span style=""color:green"">^</span>; <span style=""color:green"">//</span>; </pre>. When this is disabled, Clang will just print:. ::. test.c:2:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. If the ``NO_COLOR`` environment variable is defined and not empty; (regardless of value), color diagnostics are disabled. If ``NO_COLOR`` is; defined and ``-fcolor-diagnostics`` is passed on the command line, Clang; will honor the command line argument. .. option:: -fansi-escape-codes. Controls whether ANSI escape codes are used instead of the Windows Console; API to output colored diagnostics. This option is only used on Windows and; defaults to off. .. option:: -fdiagnostics-format=clang/msvc/vi. Changes diagnostic output format to better match IDEs and command line tools. This option controls the output fo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:7785,Testability,test,test,7785,"ranges from source code in diagnostic.; This option, which defaults to on, controls whether or not Clang; prints the source line, source ranges, and caret when emitting a; diagnostic. For example, when this is enabled, Clang will print; something like:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. .. option:: -f[no-]color-diagnostics. This option, which defaults to on when a color-capable terminal is; detected, controls whether or not Clang prints diagnostics in color. When this option is enabled, Clang will use colors to highlight; specific parts of the diagnostic, e.g.,. .. nasty hack to not lose our dignity. .. raw:: html. <pre>; <b><span style=""color:black"">test.c:28:8: <span style=""color:magenta"">warning</span>: extra tokens at end of #endif directive [-Wextra-tokens]</span></b>; #endif bad; <span style=""color:green"">^</span>; <span style=""color:green"">//</span>; </pre>. When this is disabled, Clang will just print:. ::. test.c:2:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. If the ``NO_COLOR`` environment variable is defined and not empty; (regardless of value), color diagnostics are disabled. If ``NO_COLOR`` is; defined and ``-fcolor-diagnostics`` is passed on the command line, Clang; will honor the command line argument. .. option:: -fansi-escape-codes. Controls whether ANSI escape codes are used instead of the Windows Console; API to output colored diagnostics. This option is only used on Windows and; defaults to off. .. option:: -fdiagnostics-format=clang/msvc/vi. Changes diagnostic output format to better match IDEs and command line tools. This option controls the output format of the filename, line number,; and column printed in diagnostic messages. The options, and their; affect on formatting a simple conversion diagnostic, follow:. **clang** (default); ::. t.c:3:11: warning: conversion specifies type 'char *' but the argument has type 'int'. **msvc**; :",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:9332,Testability,test,test,9332,"off. .. option:: -fdiagnostics-format=clang/msvc/vi. Changes diagnostic output format to better match IDEs and command line tools. This option controls the output format of the filename, line number,; and column printed in diagnostic messages. The options, and their; affect on formatting a simple conversion diagnostic, follow:. **clang** (default); ::. t.c:3:11: warning: conversion specifies type 'char *' but the argument has type 'int'. **msvc**; ::. t.c(3,11) : warning: conversion specifies type 'char *' but the argument has type 'int'. **vi**; ::. t.c +3:11: warning: conversion specifies type 'char *' but the argument has type 'int'. .. _opt_fdiagnostics-show-option:. .. option:: -f[no-]diagnostics-show-option. Enable ``[-Woption]`` information in diagnostic line. This option, which defaults to on, controls whether or not Clang; prints the associated :ref:`warning group <cl_diag_warning_groups>`; option name when outputting a warning diagnostic. For example, in; this output:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. Passing **-fno-diagnostics-show-option** will prevent Clang from; printing the [:option:`-Wextra-tokens`] information in; the diagnostic. This information tells you the flag needed to enable; or disable the diagnostic, either from the command line or through; :ref:`#pragma GCC diagnostic <pragma_GCC_diagnostic>`. .. option:: -fdiagnostics-show-category=none/id/name. Enable printing category information in diagnostic line. This option, which defaults to ""none"", controls whether or not Clang; prints the category associated with a diagnostic when emitting it.; Each diagnostic may or many not have an associated category, if it; has one, it is listed in the diagnostic categorization field of the; diagnostic line (in the []'s). For example, a format string warning will produce these three; renditions based on the setting of this option:. ::. t.c:3:11: warning: conversion specifies type 'char *' b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:15494,Testability,test,test,15494,"foo(x, x - 2);; ^. This option is implied when; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>` is used.; Otherwise, it defaults to off. .. option:: -fdiagnostics-hotness-threshold. Prevent optimization remarks from being output if they do not have at least; this hotness value. This option, which defaults to zero, controls the minimum hotness an; optimization remark would need in order to be output by Clang. This is; currently supported with optimization remarks (see :ref:`Options to Emit; Optimization Reports <rpass>`) when profile hotness information in; diagnostics is enabled (see; :ref:`-fdiagnostics-show-hotness <opt_fdiagnostics-show-hotness>`). .. _opt_fdiagnostics-fixit-info:. .. option:: -f[no-]diagnostics-fixit-info. Enable ""FixIt"" information in the diagnostics output. This option, which defaults to on, controls whether or not Clang; prints the information on how to fix a specific diagnostic; underneath it when it knows. For example, in this output:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. Passing **-fno-diagnostics-fixit-info** will prevent Clang from; printing the ""//"" line at the end of the message. This information; is useful for users who may not understand what is wrong, but can be; confusing for machine parsing. .. _opt_fdiagnostics-print-source-range-info:. .. option:: -fdiagnostics-print-source-range-info. Print machine parsable information about source ranges.; This option makes Clang print information about source ranges in a machine; parsable format after the file/line/column number information. The; information is a simple sequence of brace enclosed ranges, where each range; lists the start and end line/column locations. For example, in this output:. ::. exprs.c:47:15:{47:8-47:14}{47:17-47:24}: error: invalid operands to binary expression ('int *' and '_Complex float'); P = (P-42) + Gamma*4;; ~~~~~~ ^ ~~~~~~~. The {}'s are generated by -fdiagnostics-print-source-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:19365,Testability,test,test,19365,"Template type diffing prints a text tree. For diffing large templated types, this option will cause Clang to; display the templates as an indented text tree, one argument per; line, with differences marked inline. This is compatible with; -fno-elide-type. Default:. ::. t.cc:4:5: note: candidate function not viable: no known conversion from 'vector<map<[...], map<float, [...]>>>' to 'vector<map<[...], map<double, [...]>>>' for 1st argument;. With :option:`-fdiagnostics-show-template-tree`:. ::. t.cc:4:5: note: candidate function not viable: no known conversion for 1st argument;; vector<; map<; [...],; map<; [float != double],; [...]>>>. .. option:: -fcaret-diagnostics-max-lines:. Controls how many lines of code clang prints for diagnostics. By default,; clang prints a maximum of 16 lines of code. .. option:: -fdiagnostics-show-line-numbers:. Controls whether clang will print a margin containing the line number on; the left of each line of code it prints for diagnostics. Default:. ::. test.cpp:5:1: error: 'main' must return 'int'; 5 | void main() {}; | ^~~~; | int. With -fno-diagnostics-show-line-numbers:. ::. test.cpp:5:1: error: 'main' must return 'int'; void main() {}; ^~~~; int. .. _cl_diag_warning_groups:. Individual Warning Groups; ^^^^^^^^^^^^^^^^^^^^^^^^^. TODO: Generate this from tblgen. Define one anchor per warning group. .. option:: -Wextra-tokens. Warn about excess tokens at the end of a preprocessor directive. This option, which defaults to on, enables warnings about extra; tokens at the end of preprocessor directives. For example:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^. These extra tokens are not strictly conforming, and are usually best; handled by commenting them out. .. option:: -Wambiguous-member-template. Warn about unqualified uses of a member template whose name resolves to; another template at the location of the use. This option, which defaults to on, enables a warning in the; followin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:19493,Testability,test,test,19493,"tes as an indented text tree, one argument per; line, with differences marked inline. This is compatible with; -fno-elide-type. Default:. ::. t.cc:4:5: note: candidate function not viable: no known conversion from 'vector<map<[...], map<float, [...]>>>' to 'vector<map<[...], map<double, [...]>>>' for 1st argument;. With :option:`-fdiagnostics-show-template-tree`:. ::. t.cc:4:5: note: candidate function not viable: no known conversion for 1st argument;; vector<; map<; [...],; map<; [float != double],; [...]>>>. .. option:: -fcaret-diagnostics-max-lines:. Controls how many lines of code clang prints for diagnostics. By default,; clang prints a maximum of 16 lines of code. .. option:: -fdiagnostics-show-line-numbers:. Controls whether clang will print a margin containing the line number on; the left of each line of code it prints for diagnostics. Default:. ::. test.cpp:5:1: error: 'main' must return 'int'; 5 | void main() {}; | ^~~~; | int. With -fno-diagnostics-show-line-numbers:. ::. test.cpp:5:1: error: 'main' must return 'int'; void main() {}; ^~~~; int. .. _cl_diag_warning_groups:. Individual Warning Groups; ^^^^^^^^^^^^^^^^^^^^^^^^^. TODO: Generate this from tblgen. Define one anchor per warning group. .. option:: -Wextra-tokens. Warn about excess tokens at the end of a preprocessor directive. This option, which defaults to on, enables warnings about extra; tokens at the end of preprocessor directives. For example:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^. These extra tokens are not strictly conforming, and are usually best; handled by commenting them out. .. option:: -Wambiguous-member-template. Warn about unqualified uses of a member template whose name resolves to; another template at the location of the use. This option, which defaults to on, enables a warning in the; following code:. ::. template<typename T> struct set{};; template<typename T> struct trait { typedef const T& type; };; struct Value {; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:19942,Testability,test,test,19942,"ument;; vector<; map<; [...],; map<; [float != double],; [...]>>>. .. option:: -fcaret-diagnostics-max-lines:. Controls how many lines of code clang prints for diagnostics. By default,; clang prints a maximum of 16 lines of code. .. option:: -fdiagnostics-show-line-numbers:. Controls whether clang will print a margin containing the line number on; the left of each line of code it prints for diagnostics. Default:. ::. test.cpp:5:1: error: 'main' must return 'int'; 5 | void main() {}; | ^~~~; | int. With -fno-diagnostics-show-line-numbers:. ::. test.cpp:5:1: error: 'main' must return 'int'; void main() {}; ^~~~; int. .. _cl_diag_warning_groups:. Individual Warning Groups; ^^^^^^^^^^^^^^^^^^^^^^^^^. TODO: Generate this from tblgen. Define one anchor per warning group. .. option:: -Wextra-tokens. Warn about excess tokens at the end of a preprocessor directive. This option, which defaults to on, enables warnings about extra; tokens at the end of preprocessor directives. For example:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^. These extra tokens are not strictly conforming, and are usually best; handled by commenting them out. .. option:: -Wambiguous-member-template. Warn about unqualified uses of a member template whose name resolves to; another template at the location of the use. This option, which defaults to on, enables a warning in the; following code:. ::. template<typename T> struct set{};; template<typename T> struct trait { typedef const T& type; };; struct Value {; template<typename T> void set(typename trait<T>::type value) {}; };; void foo() {; Value v;; v.set<double>(3.2);; }. C++ [basic.lookup.classref] requires this to be an error, but,; because it's hard to work around, Clang downgrades it to a warning; as an extension. .. option:: -Wbind-to-temporary-copy. Warn about an unusable copy constructor when binding a reference to a; temporary. This option enables warnings about binding a; reference to a te",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:22720,Testability,test,test,22720,"------------------------------------. As unbelievable as it may sound, Clang does crash from time to time.; Generally, this only occurs to those living on the `bleeding; edge <https://llvm.org/releases/download.html#svn>`_. Clang goes to great; lengths to assist you in filing a bug report. Specifically, Clang; generates preprocessed source file(s) and associated run script(s) upon; a crash. These files should be attached to a bug report to ease; reproducibility of the failure. Below are the command line options to; control the crash diagnostics. .. option:: -fcrash-diagnostics=<val>. Valid values are:. * ``off`` (Disable auto-generation of preprocessed source files during a clang crash.); * ``compiler`` (Generate diagnostics for compiler crashes (default)); * ``all`` (Generate diagnostics for all tools which support it). .. option:: -fno-crash-diagnostics. Disable auto-generation of preprocessed source files during a clang crash. The -fno-crash-diagnostics flag can be helpful for speeding the process; of generating a delta reduced test case. .. option:: -fcrash-diagnostics-dir=<dir>. Specify where to write the crash diagnostics files; defaults to the; usual location for temporary files. .. envvar:: CLANG_CRASH_DIAGNOSTICS_DIR=<dir>. Like ``-fcrash-diagnostics-dir=<dir>``, specifies where to write the; crash diagnostics files, but with lower precedence than the option. Clang is also capable of generating preprocessed source file(s) and associated; run script(s) even without a crash. This is specially useful when trying to; generate a reproducer for warnings or errors while using modules. .. option:: -gen-reproducer. Generates preprocessed source files, a reproducer script and if relevant, a; cache containing: built module pcm's and all headers needed to rebuild the; same modules. .. _rpass:. Options to Emit Optimization Reports; ------------------------------------. Optimization reports trace, at a high-level, all the major decisions; done by compiler transformations",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:31280,Testability,test,testing,31280," performance optimization -- Clang will emit smaller; object files that are more quickly processed by the linker. This may cause; binary compatibility issues on older x86_64 targets, however, so use it with; caution. .. _configuration-files:. Configuration files; -------------------. Configuration files group command-line options and allow all of them to be; specified just by referencing the configuration file. They may be used, for; example, to collect options required to tune compilation for particular; target, such as ``-L``, ``-I``, ``-l``, ``--sysroot``, codegen options, etc. Configuration files can be either specified on the command line or loaded; from default locations. If both variants are present, the default configuration; files are loaded first. The command line option ``--config=`` can be used to specify explicit; configuration files in a Clang invocation. If the option is used multiple times,; all specified files are loaded, in order. For example:. ::. clang --config=/home/user/cfgs/testing.txt; clang --config=debug.cfg --config=runtimes.cfg. If the provided argument contains a directory separator, it is considered as; a file path, and options are read from that file. Otherwise the argument is; treated as a file name and is searched for sequentially in the directories:. - user directory,; - system directory,; - the directory where Clang executable resides. Both user and system directories for configuration files are specified during; clang build using CMake parameters, ``CLANG_CONFIG_FILE_USER_DIR`` and; ``CLANG_CONFIG_FILE_SYSTEM_DIR`` respectively. The first file found is used.; It is an error if the required file cannot be found. The default configuration files are searched for in the same directories; following the rules described in the next paragraphs. Loading default; configuration files can be disabled entirely via passing; the ``--no-default-config`` flag. First, the algorithm searches for a configuration file named; ``<triple>-<driver>.cfg`` ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:46835,Testability,test,test,46835,"lying motivation of the approach is that it is common for; the same (and often large) header files to be included by multiple; source files. Consequently, compile times can often be greatly improved; by caching some of the (redundant) work done by a compiler to process; headers. Precompiled header files, which represent one of many ways to; implement this optimization, are literally files that represent an; on-disk cache that contains the vital information necessary to reduce; some of the work needed to process a corresponding header file. While; details of precompiled headers vary between compilers, precompiled; headers have been shown to be highly effective at speeding up program; compilation on systems with very large system headers (e.g., macOS). Generating a PCH File; ^^^^^^^^^^^^^^^^^^^^^. To generate a PCH file using Clang, one invokes Clang with the; `-x <language>-header` option. This mirrors the interface in GCC; for generating PCH files:. .. code-block:: console. $ gcc -x c-header test.h -o test.h.gch; $ clang -x c-header test.h -o test.h.pch. Using a PCH File; ^^^^^^^^^^^^^^^^. A PCH file can then be used as a prefix header when a ``-include-pch``; option is passed to ``clang``:. .. code-block:: console. $ clang -include-pch test.h.pch test.c -o test. The ``clang`` driver will check if the PCH file ``test.h.pch`` is; available; if so, the contents of ``test.h`` (and the files it includes); will be processed from the PCH file. Otherwise, Clang will report an error. .. note::. Clang does *not* automatically use PCH files for headers that are directly; included within a source file or indirectly via :option:`-include`.; For example:. .. code-block:: console. $ clang -x c-header test.h -o test.h.pch; $ cat test.c; #include ""test.h""; $ clang test.c -o test. In this example, ``clang`` will not automatically use the PCH file for; ``test.h`` since ``test.h`` was included directly in the source file and not; specified on the command line using ``-include-pch``. R",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:46845,Testability,test,test,46845,"of the approach is that it is common for; the same (and often large) header files to be included by multiple; source files. Consequently, compile times can often be greatly improved; by caching some of the (redundant) work done by a compiler to process; headers. Precompiled header files, which represent one of many ways to; implement this optimization, are literally files that represent an; on-disk cache that contains the vital information necessary to reduce; some of the work needed to process a corresponding header file. While; details of precompiled headers vary between compilers, precompiled; headers have been shown to be highly effective at speeding up program; compilation on systems with very large system headers (e.g., macOS). Generating a PCH File; ^^^^^^^^^^^^^^^^^^^^^. To generate a PCH file using Clang, one invokes Clang with the; `-x <language>-header` option. This mirrors the interface in GCC; for generating PCH files:. .. code-block:: console. $ gcc -x c-header test.h -o test.h.gch; $ clang -x c-header test.h -o test.h.pch. Using a PCH File; ^^^^^^^^^^^^^^^^. A PCH file can then be used as a prefix header when a ``-include-pch``; option is passed to ``clang``:. .. code-block:: console. $ clang -include-pch test.h.pch test.c -o test. The ``clang`` driver will check if the PCH file ``test.h.pch`` is; available; if so, the contents of ``test.h`` (and the files it includes); will be processed from the PCH file. Otherwise, Clang will report an error. .. note::. Clang does *not* automatically use PCH files for headers that are directly; included within a source file or indirectly via :option:`-include`.; For example:. .. code-block:: console. $ clang -x c-header test.h -o test.h.pch; $ cat test.c; #include ""test.h""; $ clang test.c -o test. In this example, ``clang`` will not automatically use the PCH file for; ``test.h`` since ``test.h`` was included directly in the source file and not; specified on the command line using ``-include-pch``. Relocatable PCH Fi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:46877,Testability,test,test,46877,"t it is common for; the same (and often large) header files to be included by multiple; source files. Consequently, compile times can often be greatly improved; by caching some of the (redundant) work done by a compiler to process; headers. Precompiled header files, which represent one of many ways to; implement this optimization, are literally files that represent an; on-disk cache that contains the vital information necessary to reduce; some of the work needed to process a corresponding header file. While; details of precompiled headers vary between compilers, precompiled; headers have been shown to be highly effective at speeding up program; compilation on systems with very large system headers (e.g., macOS). Generating a PCH File; ^^^^^^^^^^^^^^^^^^^^^. To generate a PCH file using Clang, one invokes Clang with the; `-x <language>-header` option. This mirrors the interface in GCC; for generating PCH files:. .. code-block:: console. $ gcc -x c-header test.h -o test.h.gch; $ clang -x c-header test.h -o test.h.pch. Using a PCH File; ^^^^^^^^^^^^^^^^. A PCH file can then be used as a prefix header when a ``-include-pch``; option is passed to ``clang``:. .. code-block:: console. $ clang -include-pch test.h.pch test.c -o test. The ``clang`` driver will check if the PCH file ``test.h.pch`` is; available; if so, the contents of ``test.h`` (and the files it includes); will be processed from the PCH file. Otherwise, Clang will report an error. .. note::. Clang does *not* automatically use PCH files for headers that are directly; included within a source file or indirectly via :option:`-include`.; For example:. .. code-block:: console. $ clang -x c-header test.h -o test.h.pch; $ cat test.c; #include ""test.h""; $ clang test.c -o test. In this example, ``clang`` will not automatically use the PCH file for; ``test.h`` since ``test.h`` was included directly in the source file and not; specified on the command line using ``-include-pch``. Relocatable PCH Files; ^^^^^^^^^^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:46887,Testability,test,test,46887,"the same (and often large) header files to be included by multiple; source files. Consequently, compile times can often be greatly improved; by caching some of the (redundant) work done by a compiler to process; headers. Precompiled header files, which represent one of many ways to; implement this optimization, are literally files that represent an; on-disk cache that contains the vital information necessary to reduce; some of the work needed to process a corresponding header file. While; details of precompiled headers vary between compilers, precompiled; headers have been shown to be highly effective at speeding up program; compilation on systems with very large system headers (e.g., macOS). Generating a PCH File; ^^^^^^^^^^^^^^^^^^^^^. To generate a PCH file using Clang, one invokes Clang with the; `-x <language>-header` option. This mirrors the interface in GCC; for generating PCH files:. .. code-block:: console. $ gcc -x c-header test.h -o test.h.gch; $ clang -x c-header test.h -o test.h.pch. Using a PCH File; ^^^^^^^^^^^^^^^^. A PCH file can then be used as a prefix header when a ``-include-pch``; option is passed to ``clang``:. .. code-block:: console. $ clang -include-pch test.h.pch test.c -o test. The ``clang`` driver will check if the PCH file ``test.h.pch`` is; available; if so, the contents of ``test.h`` (and the files it includes); will be processed from the PCH file. Otherwise, Clang will report an error. .. note::. Clang does *not* automatically use PCH files for headers that are directly; included within a source file or indirectly via :option:`-include`.; For example:. .. code-block:: console. $ clang -x c-header test.h -o test.h.pch; $ cat test.c; #include ""test.h""; $ clang test.c -o test. In this example, ``clang`` will not automatically use the PCH file for; ``test.h`` since ``test.h`` was included directly in the source file and not; specified on the command line using ``-include-pch``. Relocatable PCH Files; ^^^^^^^^^^^^^^^^^^^^^. It is sometime",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:47085,Testability,test,test,47085,"a compiler to process; headers. Precompiled header files, which represent one of many ways to; implement this optimization, are literally files that represent an; on-disk cache that contains the vital information necessary to reduce; some of the work needed to process a corresponding header file. While; details of precompiled headers vary between compilers, precompiled; headers have been shown to be highly effective at speeding up program; compilation on systems with very large system headers (e.g., macOS). Generating a PCH File; ^^^^^^^^^^^^^^^^^^^^^. To generate a PCH file using Clang, one invokes Clang with the; `-x <language>-header` option. This mirrors the interface in GCC; for generating PCH files:. .. code-block:: console. $ gcc -x c-header test.h -o test.h.gch; $ clang -x c-header test.h -o test.h.pch. Using a PCH File; ^^^^^^^^^^^^^^^^. A PCH file can then be used as a prefix header when a ``-include-pch``; option is passed to ``clang``:. .. code-block:: console. $ clang -include-pch test.h.pch test.c -o test. The ``clang`` driver will check if the PCH file ``test.h.pch`` is; available; if so, the contents of ``test.h`` (and the files it includes); will be processed from the PCH file. Otherwise, Clang will report an error. .. note::. Clang does *not* automatically use PCH files for headers that are directly; included within a source file or indirectly via :option:`-include`.; For example:. .. code-block:: console. $ clang -x c-header test.h -o test.h.pch; $ cat test.c; #include ""test.h""; $ clang test.c -o test. In this example, ``clang`` will not automatically use the PCH file for; ``test.h`` since ``test.h`` was included directly in the source file and not; specified on the command line using ``-include-pch``. Relocatable PCH Files; ^^^^^^^^^^^^^^^^^^^^^. It is sometimes necessary to build a precompiled header from headers; that are not yet in their final, installed locations. For example, one; might build a precompiled header within the build tree that is",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:47096,Testability,test,test,47096,"s; headers. Precompiled header files, which represent one of many ways to; implement this optimization, are literally files that represent an; on-disk cache that contains the vital information necessary to reduce; some of the work needed to process a corresponding header file. While; details of precompiled headers vary between compilers, precompiled; headers have been shown to be highly effective at speeding up program; compilation on systems with very large system headers (e.g., macOS). Generating a PCH File; ^^^^^^^^^^^^^^^^^^^^^. To generate a PCH file using Clang, one invokes Clang with the; `-x <language>-header` option. This mirrors the interface in GCC; for generating PCH files:. .. code-block:: console. $ gcc -x c-header test.h -o test.h.gch; $ clang -x c-header test.h -o test.h.pch. Using a PCH File; ^^^^^^^^^^^^^^^^. A PCH file can then be used as a prefix header when a ``-include-pch``; option is passed to ``clang``:. .. code-block:: console. $ clang -include-pch test.h.pch test.c -o test. The ``clang`` driver will check if the PCH file ``test.h.pch`` is; available; if so, the contents of ``test.h`` (and the files it includes); will be processed from the PCH file. Otherwise, Clang will report an error. .. note::. Clang does *not* automatically use PCH files for headers that are directly; included within a source file or indirectly via :option:`-include`.; For example:. .. code-block:: console. $ clang -x c-header test.h -o test.h.pch; $ cat test.c; #include ""test.h""; $ clang test.c -o test. In this example, ``clang`` will not automatically use the PCH file for; ``test.h`` since ``test.h`` was included directly in the source file and not; specified on the command line using ``-include-pch``. Relocatable PCH Files; ^^^^^^^^^^^^^^^^^^^^^. It is sometimes necessary to build a precompiled header from headers; that are not yet in their final, installed locations. For example, one; might build a precompiled header within the build tree that is then; meant to be i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:47106,Testability,test,test,47106,". Precompiled header files, which represent one of many ways to; implement this optimization, are literally files that represent an; on-disk cache that contains the vital information necessary to reduce; some of the work needed to process a corresponding header file. While; details of precompiled headers vary between compilers, precompiled; headers have been shown to be highly effective at speeding up program; compilation on systems with very large system headers (e.g., macOS). Generating a PCH File; ^^^^^^^^^^^^^^^^^^^^^. To generate a PCH file using Clang, one invokes Clang with the; `-x <language>-header` option. This mirrors the interface in GCC; for generating PCH files:. .. code-block:: console. $ gcc -x c-header test.h -o test.h.gch; $ clang -x c-header test.h -o test.h.pch. Using a PCH File; ^^^^^^^^^^^^^^^^. A PCH file can then be used as a prefix header when a ``-include-pch``; option is passed to ``clang``:. .. code-block:: console. $ clang -include-pch test.h.pch test.c -o test. The ``clang`` driver will check if the PCH file ``test.h.pch`` is; available; if so, the contents of ``test.h`` (and the files it includes); will be processed from the PCH file. Otherwise, Clang will report an error. .. note::. Clang does *not* automatically use PCH files for headers that are directly; included within a source file or indirectly via :option:`-include`.; For example:. .. code-block:: console. $ clang -x c-header test.h -o test.h.pch; $ cat test.c; #include ""test.h""; $ clang test.c -o test. In this example, ``clang`` will not automatically use the PCH file for; ``test.h`` since ``test.h`` was included directly in the source file and not; specified on the command line using ``-include-pch``. Relocatable PCH Files; ^^^^^^^^^^^^^^^^^^^^^. It is sometimes necessary to build a precompiled header from headers; that are not yet in their final, installed locations. For example, one; might build a precompiled header within the build tree that is then; meant to be installed ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:47162,Testability,test,test,47162," represent one of many ways to; implement this optimization, are literally files that represent an; on-disk cache that contains the vital information necessary to reduce; some of the work needed to process a corresponding header file. While; details of precompiled headers vary between compilers, precompiled; headers have been shown to be highly effective at speeding up program; compilation on systems with very large system headers (e.g., macOS). Generating a PCH File; ^^^^^^^^^^^^^^^^^^^^^. To generate a PCH file using Clang, one invokes Clang with the; `-x <language>-header` option. This mirrors the interface in GCC; for generating PCH files:. .. code-block:: console. $ gcc -x c-header test.h -o test.h.gch; $ clang -x c-header test.h -o test.h.pch. Using a PCH File; ^^^^^^^^^^^^^^^^. A PCH file can then be used as a prefix header when a ``-include-pch``; option is passed to ``clang``:. .. code-block:: console. $ clang -include-pch test.h.pch test.c -o test. The ``clang`` driver will check if the PCH file ``test.h.pch`` is; available; if so, the contents of ``test.h`` (and the files it includes); will be processed from the PCH file. Otherwise, Clang will report an error. .. note::. Clang does *not* automatically use PCH files for headers that are directly; included within a source file or indirectly via :option:`-include`.; For example:. .. code-block:: console. $ clang -x c-header test.h -o test.h.pch; $ cat test.c; #include ""test.h""; $ clang test.c -o test. In this example, ``clang`` will not automatically use the PCH file for; ``test.h`` since ``test.h`` was included directly in the source file and not; specified on the command line using ``-include-pch``. Relocatable PCH Files; ^^^^^^^^^^^^^^^^^^^^^. It is sometimes necessary to build a precompiled header from headers; that are not yet in their final, installed locations. For example, one; might build a precompiled header within the build tree that is then; meant to be installed alongside the headers. Clang perm",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:47215,Testability,test,test,47215,"tion, are literally files that represent an; on-disk cache that contains the vital information necessary to reduce; some of the work needed to process a corresponding header file. While; details of precompiled headers vary between compilers, precompiled; headers have been shown to be highly effective at speeding up program; compilation on systems with very large system headers (e.g., macOS). Generating a PCH File; ^^^^^^^^^^^^^^^^^^^^^. To generate a PCH file using Clang, one invokes Clang with the; `-x <language>-header` option. This mirrors the interface in GCC; for generating PCH files:. .. code-block:: console. $ gcc -x c-header test.h -o test.h.gch; $ clang -x c-header test.h -o test.h.pch. Using a PCH File; ^^^^^^^^^^^^^^^^. A PCH file can then be used as a prefix header when a ``-include-pch``; option is passed to ``clang``:. .. code-block:: console. $ clang -include-pch test.h.pch test.c -o test. The ``clang`` driver will check if the PCH file ``test.h.pch`` is; available; if so, the contents of ``test.h`` (and the files it includes); will be processed from the PCH file. Otherwise, Clang will report an error. .. note::. Clang does *not* automatically use PCH files for headers that are directly; included within a source file or indirectly via :option:`-include`.; For example:. .. code-block:: console. $ clang -x c-header test.h -o test.h.pch; $ cat test.c; #include ""test.h""; $ clang test.c -o test. In this example, ``clang`` will not automatically use the PCH file for; ``test.h`` since ``test.h`` was included directly in the source file and not; specified on the command line using ``-include-pch``. Relocatable PCH Files; ^^^^^^^^^^^^^^^^^^^^^. It is sometimes necessary to build a precompiled header from headers; that are not yet in their final, installed locations. For example, one; might build a precompiled header within the build tree that is then; meant to be installed alongside the headers. Clang permits the creation; of ""relocatable"" precompiled headers, ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:47544,Testability,test,test,47544,"ystems with very large system headers (e.g., macOS). Generating a PCH File; ^^^^^^^^^^^^^^^^^^^^^. To generate a PCH file using Clang, one invokes Clang with the; `-x <language>-header` option. This mirrors the interface in GCC; for generating PCH files:. .. code-block:: console. $ gcc -x c-header test.h -o test.h.gch; $ clang -x c-header test.h -o test.h.pch. Using a PCH File; ^^^^^^^^^^^^^^^^. A PCH file can then be used as a prefix header when a ``-include-pch``; option is passed to ``clang``:. .. code-block:: console. $ clang -include-pch test.h.pch test.c -o test. The ``clang`` driver will check if the PCH file ``test.h.pch`` is; available; if so, the contents of ``test.h`` (and the files it includes); will be processed from the PCH file. Otherwise, Clang will report an error. .. note::. Clang does *not* automatically use PCH files for headers that are directly; included within a source file or indirectly via :option:`-include`.; For example:. .. code-block:: console. $ clang -x c-header test.h -o test.h.pch; $ cat test.c; #include ""test.h""; $ clang test.c -o test. In this example, ``clang`` will not automatically use the PCH file for; ``test.h`` since ``test.h`` was included directly in the source file and not; specified on the command line using ``-include-pch``. Relocatable PCH Files; ^^^^^^^^^^^^^^^^^^^^^. It is sometimes necessary to build a precompiled header from headers; that are not yet in their final, installed locations. For example, one; might build a precompiled header within the build tree that is then; meant to be installed alongside the headers. Clang permits the creation; of ""relocatable"" precompiled headers, which are built with a given path; (into the build directory) and can later be used from an installed; location. To build a relocatable precompiled header, place your headers into a; subdirectory whose structure mimics the installed location. For example,; if you want to build a precompiled header for the header ``mylib.h``; that will be i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:47554,Testability,test,test,47554,"arge system headers (e.g., macOS). Generating a PCH File; ^^^^^^^^^^^^^^^^^^^^^. To generate a PCH file using Clang, one invokes Clang with the; `-x <language>-header` option. This mirrors the interface in GCC; for generating PCH files:. .. code-block:: console. $ gcc -x c-header test.h -o test.h.gch; $ clang -x c-header test.h -o test.h.pch. Using a PCH File; ^^^^^^^^^^^^^^^^. A PCH file can then be used as a prefix header when a ``-include-pch``; option is passed to ``clang``:. .. code-block:: console. $ clang -include-pch test.h.pch test.c -o test. The ``clang`` driver will check if the PCH file ``test.h.pch`` is; available; if so, the contents of ``test.h`` (and the files it includes); will be processed from the PCH file. Otherwise, Clang will report an error. .. note::. Clang does *not* automatically use PCH files for headers that are directly; included within a source file or indirectly via :option:`-include`.; For example:. .. code-block:: console. $ clang -x c-header test.h -o test.h.pch; $ cat test.c; #include ""test.h""; $ clang test.c -o test. In this example, ``clang`` will not automatically use the PCH file for; ``test.h`` since ``test.h`` was included directly in the source file and not; specified on the command line using ``-include-pch``. Relocatable PCH Files; ^^^^^^^^^^^^^^^^^^^^^. It is sometimes necessary to build a precompiled header from headers; that are not yet in their final, installed locations. For example, one; might build a precompiled header within the build tree that is then; meant to be installed alongside the headers. Clang permits the creation; of ""relocatable"" precompiled headers, which are built with a given path; (into the build directory) and can later be used from an installed; location. To build a relocatable precompiled header, place your headers into a; subdirectory whose structure mimics the installed location. For example,; if you want to build a precompiled header for the header ``mylib.h``; that will be installed into ``/u",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:47572,Testability,test,test,47572,"ders (e.g., macOS). Generating a PCH File; ^^^^^^^^^^^^^^^^^^^^^. To generate a PCH file using Clang, one invokes Clang with the; `-x <language>-header` option. This mirrors the interface in GCC; for generating PCH files:. .. code-block:: console. $ gcc -x c-header test.h -o test.h.gch; $ clang -x c-header test.h -o test.h.pch. Using a PCH File; ^^^^^^^^^^^^^^^^. A PCH file can then be used as a prefix header when a ``-include-pch``; option is passed to ``clang``:. .. code-block:: console. $ clang -include-pch test.h.pch test.c -o test. The ``clang`` driver will check if the PCH file ``test.h.pch`` is; available; if so, the contents of ``test.h`` (and the files it includes); will be processed from the PCH file. Otherwise, Clang will report an error. .. note::. Clang does *not* automatically use PCH files for headers that are directly; included within a source file or indirectly via :option:`-include`.; For example:. .. code-block:: console. $ clang -x c-header test.h -o test.h.pch; $ cat test.c; #include ""test.h""; $ clang test.c -o test. In this example, ``clang`` will not automatically use the PCH file for; ``test.h`` since ``test.h`` was included directly in the source file and not; specified on the command line using ``-include-pch``. Relocatable PCH Files; ^^^^^^^^^^^^^^^^^^^^^. It is sometimes necessary to build a precompiled header from headers; that are not yet in their final, installed locations. For example, one; might build a precompiled header within the build tree that is then; meant to be installed alongside the headers. Clang permits the creation; of ""relocatable"" precompiled headers, which are built with a given path; (into the build directory) and can later be used from an installed; location. To build a relocatable precompiled header, place your headers into a; subdirectory whose structure mimics the installed location. For example,; if you want to build a precompiled header for the header ``mylib.h``; that will be installed into ``/usr/include``, c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:47590,Testability,test,test,47590,"). Generating a PCH File; ^^^^^^^^^^^^^^^^^^^^^. To generate a PCH file using Clang, one invokes Clang with the; `-x <language>-header` option. This mirrors the interface in GCC; for generating PCH files:. .. code-block:: console. $ gcc -x c-header test.h -o test.h.gch; $ clang -x c-header test.h -o test.h.pch. Using a PCH File; ^^^^^^^^^^^^^^^^. A PCH file can then be used as a prefix header when a ``-include-pch``; option is passed to ``clang``:. .. code-block:: console. $ clang -include-pch test.h.pch test.c -o test. The ``clang`` driver will check if the PCH file ``test.h.pch`` is; available; if so, the contents of ``test.h`` (and the files it includes); will be processed from the PCH file. Otherwise, Clang will report an error. .. note::. Clang does *not* automatically use PCH files for headers that are directly; included within a source file or indirectly via :option:`-include`.; For example:. .. code-block:: console. $ clang -x c-header test.h -o test.h.pch; $ cat test.c; #include ""test.h""; $ clang test.c -o test. In this example, ``clang`` will not automatically use the PCH file for; ``test.h`` since ``test.h`` was included directly in the source file and not; specified on the command line using ``-include-pch``. Relocatable PCH Files; ^^^^^^^^^^^^^^^^^^^^^. It is sometimes necessary to build a precompiled header from headers; that are not yet in their final, installed locations. For example, one; might build a precompiled header within the build tree that is then; meant to be installed alongside the headers. Clang permits the creation; of ""relocatable"" precompiled headers, which are built with a given path; (into the build directory) and can later be used from an installed; location. To build a relocatable precompiled header, place your headers into a; subdirectory whose structure mimics the installed location. For example,; if you want to build a precompiled header for the header ``mylib.h``; that will be installed into ``/usr/include``, create a subdirect",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:47607,Testability,test,test,47607,"CH File; ^^^^^^^^^^^^^^^^^^^^^. To generate a PCH file using Clang, one invokes Clang with the; `-x <language>-header` option. This mirrors the interface in GCC; for generating PCH files:. .. code-block:: console. $ gcc -x c-header test.h -o test.h.gch; $ clang -x c-header test.h -o test.h.pch. Using a PCH File; ^^^^^^^^^^^^^^^^. A PCH file can then be used as a prefix header when a ``-include-pch``; option is passed to ``clang``:. .. code-block:: console. $ clang -include-pch test.h.pch test.c -o test. The ``clang`` driver will check if the PCH file ``test.h.pch`` is; available; if so, the contents of ``test.h`` (and the files it includes); will be processed from the PCH file. Otherwise, Clang will report an error. .. note::. Clang does *not* automatically use PCH files for headers that are directly; included within a source file or indirectly via :option:`-include`.; For example:. .. code-block:: console. $ clang -x c-header test.h -o test.h.pch; $ cat test.c; #include ""test.h""; $ clang test.c -o test. In this example, ``clang`` will not automatically use the PCH file for; ``test.h`` since ``test.h`` was included directly in the source file and not; specified on the command line using ``-include-pch``. Relocatable PCH Files; ^^^^^^^^^^^^^^^^^^^^^. It is sometimes necessary to build a precompiled header from headers; that are not yet in their final, installed locations. For example, one; might build a precompiled header within the build tree that is then; meant to be installed alongside the headers. Clang permits the creation; of ""relocatable"" precompiled headers, which are built with a given path; (into the build directory) and can later be used from an installed; location. To build a relocatable precompiled header, place your headers into a; subdirectory whose structure mimics the installed location. For example,; if you want to build a precompiled header for the header ``mylib.h``; that will be installed into ``/usr/include``, create a subdirectory; ``build/usr/i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:47617,Testability,test,test,47617,"^^^^^^^^^^^^^^^^. To generate a PCH file using Clang, one invokes Clang with the; `-x <language>-header` option. This mirrors the interface in GCC; for generating PCH files:. .. code-block:: console. $ gcc -x c-header test.h -o test.h.gch; $ clang -x c-header test.h -o test.h.pch. Using a PCH File; ^^^^^^^^^^^^^^^^. A PCH file can then be used as a prefix header when a ``-include-pch``; option is passed to ``clang``:. .. code-block:: console. $ clang -include-pch test.h.pch test.c -o test. The ``clang`` driver will check if the PCH file ``test.h.pch`` is; available; if so, the contents of ``test.h`` (and the files it includes); will be processed from the PCH file. Otherwise, Clang will report an error. .. note::. Clang does *not* automatically use PCH files for headers that are directly; included within a source file or indirectly via :option:`-include`.; For example:. .. code-block:: console. $ clang -x c-header test.h -o test.h.pch; $ cat test.c; #include ""test.h""; $ clang test.c -o test. In this example, ``clang`` will not automatically use the PCH file for; ``test.h`` since ``test.h`` was included directly in the source file and not; specified on the command line using ``-include-pch``. Relocatable PCH Files; ^^^^^^^^^^^^^^^^^^^^^. It is sometimes necessary to build a precompiled header from headers; that are not yet in their final, installed locations. For example, one; might build a precompiled header within the build tree that is then; meant to be installed alongside the headers. Clang permits the creation; of ""relocatable"" precompiled headers, which are built with a given path; (into the build directory) and can later be used from an installed; location. To build a relocatable precompiled header, place your headers into a; subdirectory whose structure mimics the installed location. For example,; if you want to build a precompiled header for the header ``mylib.h``; that will be installed into ``/usr/include``, create a subdirectory; ``build/usr/include`` and ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:47697,Testability,test,test,47697,"g Clang, one invokes Clang with the; `-x <language>-header` option. This mirrors the interface in GCC; for generating PCH files:. .. code-block:: console. $ gcc -x c-header test.h -o test.h.gch; $ clang -x c-header test.h -o test.h.pch. Using a PCH File; ^^^^^^^^^^^^^^^^. A PCH file can then be used as a prefix header when a ``-include-pch``; option is passed to ``clang``:. .. code-block:: console. $ clang -include-pch test.h.pch test.c -o test. The ``clang`` driver will check if the PCH file ``test.h.pch`` is; available; if so, the contents of ``test.h`` (and the files it includes); will be processed from the PCH file. Otherwise, Clang will report an error. .. note::. Clang does *not* automatically use PCH files for headers that are directly; included within a source file or indirectly via :option:`-include`.; For example:. .. code-block:: console. $ clang -x c-header test.h -o test.h.pch; $ cat test.c; #include ""test.h""; $ clang test.c -o test. In this example, ``clang`` will not automatically use the PCH file for; ``test.h`` since ``test.h`` was included directly in the source file and not; specified on the command line using ``-include-pch``. Relocatable PCH Files; ^^^^^^^^^^^^^^^^^^^^^. It is sometimes necessary to build a precompiled header from headers; that are not yet in their final, installed locations. For example, one; might build a precompiled header within the build tree that is then; meant to be installed alongside the headers. Clang permits the creation; of ""relocatable"" precompiled headers, which are built with a given path; (into the build directory) and can later be used from an installed; location. To build a relocatable precompiled header, place your headers into a; subdirectory whose structure mimics the installed location. For example,; if you want to build a precompiled header for the header ``mylib.h``; that will be installed into ``/usr/include``, create a subdirectory; ``build/usr/include`` and place the header ``mylib.h`` into that; subdi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:47714,Testability,test,test,47714,"ge>-header` option. This mirrors the interface in GCC; for generating PCH files:. .. code-block:: console. $ gcc -x c-header test.h -o test.h.gch; $ clang -x c-header test.h -o test.h.pch. Using a PCH File; ^^^^^^^^^^^^^^^^. A PCH file can then be used as a prefix header when a ``-include-pch``; option is passed to ``clang``:. .. code-block:: console. $ clang -include-pch test.h.pch test.c -o test. The ``clang`` driver will check if the PCH file ``test.h.pch`` is; available; if so, the contents of ``test.h`` (and the files it includes); will be processed from the PCH file. Otherwise, Clang will report an error. .. note::. Clang does *not* automatically use PCH files for headers that are directly; included within a source file or indirectly via :option:`-include`.; For example:. .. code-block:: console. $ clang -x c-header test.h -o test.h.pch; $ cat test.c; #include ""test.h""; $ clang test.c -o test. In this example, ``clang`` will not automatically use the PCH file for; ``test.h`` since ``test.h`` was included directly in the source file and not; specified on the command line using ``-include-pch``. Relocatable PCH Files; ^^^^^^^^^^^^^^^^^^^^^. It is sometimes necessary to build a precompiled header from headers; that are not yet in their final, installed locations. For example, one; might build a precompiled header within the build tree that is then; meant to be installed alongside the headers. Clang permits the creation; of ""relocatable"" precompiled headers, which are built with a given path; (into the build directory) and can later be used from an installed; location. To build a relocatable precompiled header, place your headers into a; subdirectory whose structure mimics the installed location. For example,; if you want to build a precompiled header for the header ``mylib.h``; that will be installed into ``/usr/include``, create a subdirectory; ``build/usr/include`` and place the header ``mylib.h`` into that; subdirectory. If ``mylib.h`` depends on other headers,",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:58348,Testability,log,log,58348,"d values are:. * ``fast`` (fuse across statements disregarding pragmas, default for CUDA); * ``on`` (fuse in the same statement unless dictated by pragmas, default for languages other than CUDA/HIP); * ``off`` (never fuse); * ``fast-honor-pragmas`` (fuse across statements unless dictated by pragmas, default for HIP). .. option:: -f[no-]honor-infinities. Allow floating-point optimizations that assume arguments and results are; not +-Inf.; Defaults to ``-fhonor-infinities``. If both ``-fno-honor-infinities`` and ``-fno-honor-nans`` are used,; has the same effect as specifying ``-ffinite-math-only``. .. option:: -f[no-]honor-nans. Allow floating-point optimizations that assume arguments and results are; not NaNs.; Defaults to ``-fhonor-nans``. If both ``-fno-honor-infinities`` and ``-fno-honor-nans`` are used,; has the same effect as specifying ``-ffinite-math-only``. .. option:: -f[no-]approx-func. Allow certain math function calls (such as ``log``, ``sqrt``, ``pow``, etc); to be replaced with an approximately equivalent set of instructions; or alternative math function calls. For example, a ``pow(x, 0.25)``; may be replaced with ``sqrt(sqrt(x))``, despite being an inexact result; in cases where ``x`` is ``-0.0`` or ``-inf``.; Defaults to ``-fno-approx-func``. .. option:: -f[no-]signed-zeros. Allow optimizations that ignore the sign of floating point zeros.; Defaults to ``-fsigned-zeros``. .. option:: -f[no-]associative-math. Allow floating point operations to be reassociated.; Defaults to ``-fno-associative-math``. .. option:: -f[no-]reciprocal-math. Allow division operations to be transformed into multiplication by a; reciprocal. This can be significantly faster than an ordinary division; but can also have significantly less precision. Defaults to; ``-fno-reciprocal-math``. .. option:: -f[no-]unsafe-math-optimizations. Allow unsafe floating-point optimizations.; ``-funsafe-math-optimizations`` also implies:. * ``-fapprox-func``; * ``-fassociative-math``; * ``-frecip",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:103088,Testability,test,testing,103088,"o line 2 inside ``main``. No; samples were collected there. .. _prof_instr:. Profiling with Instrumentation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Clang also supports profiling via instrumentation. This requires building a; special instrumented version of the code and has some runtime; overhead during the profiling, but it provides more detailed results than a; sampling profiler. It also provides reproducible results, at least to the; extent that the code behaves consistently across runs. Clang supports two types of instrumentation: frontend-based and IR-based.; Frontend-based instrumentation can be enabled with the option ``-fprofile-instr-generate``,; and IR-based instrumentation can be enabled with the option ``-fprofile-generate``.; For best performance with PGO, IR-based instrumentation should be used. It has; the benefits of lower instrumentation overhead, smaller raw profile size, and; better runtime performance. Frontend-based instrumentation, on the other hand,; has better source correlation, so it should be used with source line-based; coverage testing. The flag ``-fcs-profile-generate`` also instruments programs using the same; instrumentation method as ``-fprofile-generate``. However, it performs a; post-inline late instrumentation and can produce context-sensitive profiles. Here are the steps for using profile guided optimization with; instrumentation:. 1. Build an instrumented version of the code by compiling and linking with the; ``-fprofile-generate`` or ``-fprofile-instr-generate`` option. .. code-block:: console. $ clang++ -O2 -fprofile-instr-generate code.cc -o code. 2. Run the instrumented executable with inputs that reflect the typical usage.; By default, the profile data will be written to a ``default.profraw`` file; in the current directory. You can override that default by using option; ``-fprofile-instr-generate=`` or by setting the ``LLVM_PROFILE_FILE``; environment variable to specify an alternate file. If non-default file name; is specified by ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:112881,Testability,test,tests,112881,"ted during; // initialize()'s execution.; __llvm_profile_reset_counters();; ... hot region 1; // Dump the profile for hot region 1.; __llvm_profile_set_filename(""region1.profraw"");; __llvm_profile_dump();. // Reset counters before proceeding to hot region 2.; __llvm_profile_reset_counters();; ... hot region 2; // Dump the profile for hot region 2.; __llvm_profile_set_filename(""region2.profraw"");; __llvm_profile_dump();. // Since the profile has been dumped, no further profile data; // will be collected beyond the above __llvm_profile_dump().; cleanup();; return 0;; }. These APIs' names can be introduced to user programs in two ways.; They can be declared as weak symbols on platforms which support; treating weak symbols as ``null`` during linking. For example, the user can; have. .. code-block:: c. __attribute__((weak)) int __llvm_profile_dump(void);. // Then later in the same source file; if (__llvm_profile_dump); if (__llvm_profile_dump() != 0) { ... }; // The first if condition tests if the symbol is actually defined.; // Profile dumping only happens if the symbol is defined. Hence,; // the user program works correctly during normal (not profile-generate); // executions. Alternatively, the user program can include the header; ``profile/instr_prof_interface.h``, which contains the API names. For example,. .. code-block:: c. #include ""profile/instr_prof_interface.h"". // Then later in the same source file; if (__llvm_profile_dump() != 0) { ... }. The user code does not need to check if the API names are defined, because; these names are automatically replaced by ``(0)`` or the equivalence of noop; if the ``clang`` is not compiling for profile generation. Such replacement can happen because ``clang`` adds one of two macros depending; on the ``-fprofile-generate`` and the ``-fprofile-use`` flags. * ``__LLVM_INSTR_PROFILE_GENERATE``: defined when one of; ``-fprofile[-instr]-generate``/``-fcs-profile-generate`` is in effect.; * ``__LLVM_INSTR_PROFILE_USE``: defined when ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:114146,Testability,log,logging,114146,"file/instr_prof_interface.h``, which contains the API names. For example,. .. code-block:: c. #include ""profile/instr_prof_interface.h"". // Then later in the same source file; if (__llvm_profile_dump() != 0) { ... }. The user code does not need to check if the API names are defined, because; these names are automatically replaced by ``(0)`` or the equivalence of noop; if the ``clang`` is not compiling for profile generation. Such replacement can happen because ``clang`` adds one of two macros depending; on the ``-fprofile-generate`` and the ``-fprofile-use`` flags. * ``__LLVM_INSTR_PROFILE_GENERATE``: defined when one of; ``-fprofile[-instr]-generate``/``-fcs-profile-generate`` is in effect.; * ``__LLVM_INSTR_PROFILE_USE``: defined when one of; ``-fprofile-use``/``-fprofile-instr-use`` is in effect. The two macros can be used to provide more flexibiilty so a user program; can execute code specifically intended for profile generate or profile use.; For example, a user program can have special logging during profile generate:. .. code-block:: c. #if __LLVM_INSTR_PROFILE_GENERATE; expensive_logging_of_full_program_state();; #endif. The logging is automatically excluded during a normal build of the program,; hence it does not impact performance during a normal execution. It is advised to use such fine tuning only in a program's cold regions. The weak; symbols can introduce extra control flow (the ``if`` checks), while the macros; (hence declarations they guard in ``profile/instr_prof_interface.h``); can change the control flow of the functions that use them between profile; generation and profile use (which can lead to discarded counters in such; functions). Using these APIs in the program's cold regions introduces less; overhead and leads to more optimized code. Disabling Instrumentation; ^^^^^^^^^^^^^^^^^^^^^^^^^. In certain situations, it may be useful to disable profile generation or use; for specific files in a build, without affecting the main compilation flags; u",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:114290,Testability,log,logging,114290," The user code does not need to check if the API names are defined, because; these names are automatically replaced by ``(0)`` or the equivalence of noop; if the ``clang`` is not compiling for profile generation. Such replacement can happen because ``clang`` adds one of two macros depending; on the ``-fprofile-generate`` and the ``-fprofile-use`` flags. * ``__LLVM_INSTR_PROFILE_GENERATE``: defined when one of; ``-fprofile[-instr]-generate``/``-fcs-profile-generate`` is in effect.; * ``__LLVM_INSTR_PROFILE_USE``: defined when one of; ``-fprofile-use``/``-fprofile-instr-use`` is in effect. The two macros can be used to provide more flexibiilty so a user program; can execute code specifically intended for profile generate or profile use.; For example, a user program can have special logging during profile generate:. .. code-block:: c. #if __LLVM_INSTR_PROFILE_GENERATE; expensive_logging_of_full_program_state();; #endif. The logging is automatically excluded during a normal build of the program,; hence it does not impact performance during a normal execution. It is advised to use such fine tuning only in a program's cold regions. The weak; symbols can introduce extra control flow (the ``if`` checks), while the macros; (hence declarations they guard in ``profile/instr_prof_interface.h``); can change the control flow of the functions that use them between profile; generation and profile use (which can lead to discarded counters in such; functions). Using these APIs in the program's cold regions introduces less; overhead and leads to more optimized code. Disabling Instrumentation; ^^^^^^^^^^^^^^^^^^^^^^^^^. In certain situations, it may be useful to disable profile generation or use; for specific files in a build, without affecting the main compilation flags; used for the other files in the project. In these cases, you can use the flag ``-fno-profile-instr-generate`` (or; ``-fno-profile-generate``) to disable profile generation, and; ``-fno-profile-instr-use`` (or ``-fno-pr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:115997,Testability,test,testing,115997,"ecific files in a build, without affecting the main compilation flags; used for the other files in the project. In these cases, you can use the flag ``-fno-profile-instr-generate`` (or; ``-fno-profile-generate``) to disable profile generation, and; ``-fno-profile-instr-use`` (or ``-fno-profile-use``) to disable profile use. Note that these flags should appear after the corresponding profile; flags to have an effect. .. note::. When none of the translation units inside a binary is instrumented, in the; case of Fuchsia the profile runtime will not be linked into the binary and; no profile will be produced, while on other platforms the profile runtime; will be linked and profile will be produced but there will not be any; counters. Instrumenting only selected files or functions; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Sometimes it's useful to only instrument certain files or functions. For; example in automated testing infrastructure, it may be desirable to only; instrument files or functions that were modified by a patch to reduce the; overhead of instrumenting a full system. This can be done using the ``-fprofile-list`` option. .. option:: -fprofile-list=<pathname>. This option can be used to apply profile instrumentation only to selected; files or functions. ``pathname`` should point to a file in the; :doc:`SanitizerSpecialCaseList` format which selects which files and; functions to instrument. .. code-block:: console. $ clang++ -O2 -fprofile-instr-generate -fprofile-list=fun.list code.cc -o code. The option can be specified multiple times to pass multiple files. .. code-block:: console. $ clang++ -O2 -fprofile-instr-generate -fcoverage-mapping -fprofile-list=fun.list -fprofile-list=code.list code.cc -o code. Supported sections are ``[clang]``, ``[llvm]``, and ``[csllvm]`` representing; clang PGO, IRPGO, and CSIRPGO, respectively. Supported prefixes are ``function``; and ``source``. Supported categories are ``allow``, ``skip``, and ``forbid``.; ``skip`` adds ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:122568,Testability,test,test,122568,"valent when matching profile data, the following; remapping file could be used:. .. code-block:: text. # absl::string_view is considered equivalent to std::string_view; type N4absl11string_viewE St17basic_string_viewIcSt11char_traitsIcEE. # std:: might be std::__1:: in libc++ or std::__cxx11:: in libstdc++; name 3std St3__1; name 3std St7__cxx11. Matching profile data using a profile remapping file is supported on a; best-effort basis. For example, information regarding indirect call targets is; currently not remapped. For best results, you are encouraged to generate new; profile data matching the updated program, or to remap the profile data; using the ``llvm-cxxmap`` and ``llvm-profdata merge`` tools. .. note::. Profile data remapping is currently only supported for C++ mangled names; following the Itanium C++ ABI mangling scheme. This covers all C++ targets; supported by Clang other than Windows. GCOV-based Profiling; --------------------. GCOV is a test coverage program, it helps to know how often a line of code; is executed. When instrumenting the code with ``--coverage`` option, some; counters are added for each edge linking basic blocks. At compile time, gcno files are generated containing information about; blocks and edges between them. At runtime the counters are incremented and at; exit the counters are dumped in gcda files. The tool ``llvm-cov gcov`` will parse gcno, gcda and source files to generate; a report ``.c.gcov``. .. option:: -fprofile-filter-files=[regexes]. Define a list of regexes separated by a semi-colon.; If a file name matches any of the regexes then the file is instrumented. .. code-block:: console. $ clang --coverage -fprofile-filter-files="".*\.c$"" foo.c. For example, this will only instrument files finishing with ``.c``, skipping ``.h`` files. .. option:: -fprofile-exclude-files=[regexes]. Define a list of regexes separated by a semi-colon.; If a file name doesn't match all the regexes then the file is instrumented. .. code-block:: cons",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:127867,Testability,assert,assertion-enabled,127867,"rocessor macros. This flag is discarded when; **-g0** is enabled. .. option:: -fno-debug-macro. Do not generate debug info for preprocessor macros (default). Controlling Debugger ""Tuning""; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. While Clang generally emits standard DWARF debug info (http://dwarfstd.org),; different debuggers may know how to take advantage of different specific DWARF; features. You can ""tune"" the debug info for one of several different debuggers. .. option:: -ggdb, -glldb, -gsce, -gdbx. Tune the debug info for the ``gdb``, ``lldb``, Sony PlayStation\ |reg|; debugger, or ``dbx``, respectively. Each of these options implies **-g**.; (Therefore, if you want both **-gline-tables-only** and debugger tuning, the; tuning option must come first.). Controlling LLVM IR Output; --------------------------. Controlling Value Names in LLVM IR; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Emitting value names in LLVM IR increases the size and verbosity of the IR.; By default, value names are only emitted in assertion-enabled builds of Clang.; However, when reading IR it can be useful to re-enable the emission of value; names to improve readability. .. option:: -fdiscard-value-names. Discard value names when generating LLVM IR. .. option:: -fno-discard-value-names. Do not discard value names when generating LLVM IR. This option can be used; to re-enable names for release builds of Clang. Comment Parsing Options; -----------------------. Clang parses Doxygen and non-Doxygen style documentation comments and attaches; them to the appropriate declaration nodes. By default, it only parses; Doxygen-style comments and ignores ordinary comments starting with ``//`` and; ``/*``. .. option:: -Wdocumentation. Emit warnings about use of documentation comments. This warning group is off; by default. This includes checking that ``\param`` commands name parameters that actually; present in the function signature, checking that ``\returns`` is used only on; functions that actually return a value etc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:140926,Testability,test,test,140926," Controlling implementation limits; ---------------------------------. .. option:: -fopenmp-use-tls. Controls code generation for OpenMP threadprivate variables. In presence of; this option all threadprivate variables are generated the same way as thread; local variables, using TLS support. If `-fno-openmp-use-tls`; is provided or target does not support TLS, code generation for threadprivate; variables relies on OpenMP runtime library. .. _opencl:. OpenCL Features; ===============. Clang can be used to compile OpenCL kernels for execution on a device; (e.g. GPU). It is possible to compile the kernel into a binary (e.g. for AMDGPU); that can be uploaded to run directly on a device (e.g. using; `clCreateProgramWithBinary; <https://www.khronos.org/registry/OpenCL/specs/opencl-1.1.pdf#111>`_) or; into generic bitcode files loadable into other toolchains. Compiling to a binary using the default target from the installation can be done; as follows:. .. code-block:: console. $ echo ""kernel void k(){}"" > test.cl; $ clang test.cl. Compiling for a specific target can be done by specifying the triple corresponding; to the target, for example:. .. code-block:: console. $ clang --target=nvptx64-unknown-unknown test.cl; $ clang --target=amdgcn-amd-amdhsa -mcpu=gfx900 test.cl. Compiling to bitcode can be done as follows:. .. code-block:: console. $ clang -c -emit-llvm test.cl. This will produce a file `test.bc` that can be used in vendor toolchains; to perform machine code generation. Note that if compiled to bitcode for generic targets such as SPIR/SPIR-V,; portable IR is produced that can be used with various vendor; tools as well as open source tools such as `SPIRV-LLVM Translator; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator>`_; to produce SPIR-V binary. More details are provided in `the offline; compilation from OpenCL kernel sources into SPIR-V using open source; tools; <https://github.com/KhronosGroup/OpenCL-Guide/blob/main/chapters/os_tooling.md>`_.; From clang 1",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:140943,Testability,test,test,140943,"n limits; ---------------------------------. .. option:: -fopenmp-use-tls. Controls code generation for OpenMP threadprivate variables. In presence of; this option all threadprivate variables are generated the same way as thread; local variables, using TLS support. If `-fno-openmp-use-tls`; is provided or target does not support TLS, code generation for threadprivate; variables relies on OpenMP runtime library. .. _opencl:. OpenCL Features; ===============. Clang can be used to compile OpenCL kernels for execution on a device; (e.g. GPU). It is possible to compile the kernel into a binary (e.g. for AMDGPU); that can be uploaded to run directly on a device (e.g. using; `clCreateProgramWithBinary; <https://www.khronos.org/registry/OpenCL/specs/opencl-1.1.pdf#111>`_) or; into generic bitcode files loadable into other toolchains. Compiling to a binary using the default target from the installation can be done; as follows:. .. code-block:: console. $ echo ""kernel void k(){}"" > test.cl; $ clang test.cl. Compiling for a specific target can be done by specifying the triple corresponding; to the target, for example:. .. code-block:: console. $ clang --target=nvptx64-unknown-unknown test.cl; $ clang --target=amdgcn-amd-amdhsa -mcpu=gfx900 test.cl. Compiling to bitcode can be done as follows:. .. code-block:: console. $ clang -c -emit-llvm test.cl. This will produce a file `test.bc` that can be used in vendor toolchains; to perform machine code generation. Note that if compiled to bitcode for generic targets such as SPIR/SPIR-V,; portable IR is produced that can be used with various vendor; tools as well as open source tools such as `SPIRV-LLVM Translator; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator>`_; to produce SPIR-V binary. More details are provided in `the offline; compilation from OpenCL kernel sources into SPIR-V using open source; tools; <https://github.com/KhronosGroup/OpenCL-Guide/blob/main/chapters/os_tooling.md>`_.; From clang 14 onwards SPIR-V can be ge",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:141131,Testability,test,test,141131,"dprivate variables are generated the same way as thread; local variables, using TLS support. If `-fno-openmp-use-tls`; is provided or target does not support TLS, code generation for threadprivate; variables relies on OpenMP runtime library. .. _opencl:. OpenCL Features; ===============. Clang can be used to compile OpenCL kernels for execution on a device; (e.g. GPU). It is possible to compile the kernel into a binary (e.g. for AMDGPU); that can be uploaded to run directly on a device (e.g. using; `clCreateProgramWithBinary; <https://www.khronos.org/registry/OpenCL/specs/opencl-1.1.pdf#111>`_) or; into generic bitcode files loadable into other toolchains. Compiling to a binary using the default target from the installation can be done; as follows:. .. code-block:: console. $ echo ""kernel void k(){}"" > test.cl; $ clang test.cl. Compiling for a specific target can be done by specifying the triple corresponding; to the target, for example:. .. code-block:: console. $ clang --target=nvptx64-unknown-unknown test.cl; $ clang --target=amdgcn-amd-amdhsa -mcpu=gfx900 test.cl. Compiling to bitcode can be done as follows:. .. code-block:: console. $ clang -c -emit-llvm test.cl. This will produce a file `test.bc` that can be used in vendor toolchains; to perform machine code generation. Note that if compiled to bitcode for generic targets such as SPIR/SPIR-V,; portable IR is produced that can be used with various vendor; tools as well as open source tools such as `SPIRV-LLVM Translator; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator>`_; to produce SPIR-V binary. More details are provided in `the offline; compilation from OpenCL kernel sources into SPIR-V using open source; tools; <https://github.com/KhronosGroup/OpenCL-Guide/blob/main/chapters/os_tooling.md>`_.; From clang 14 onwards SPIR-V can be generated directly as detailed in; :ref:`the SPIR-V support section <spir-v>`. Clang currently supports OpenCL C language standards up to v2.0. Clang mainly; supports full pro",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:141188,Testability,test,test,141188,"ead; local variables, using TLS support. If `-fno-openmp-use-tls`; is provided or target does not support TLS, code generation for threadprivate; variables relies on OpenMP runtime library. .. _opencl:. OpenCL Features; ===============. Clang can be used to compile OpenCL kernels for execution on a device; (e.g. GPU). It is possible to compile the kernel into a binary (e.g. for AMDGPU); that can be uploaded to run directly on a device (e.g. using; `clCreateProgramWithBinary; <https://www.khronos.org/registry/OpenCL/specs/opencl-1.1.pdf#111>`_) or; into generic bitcode files loadable into other toolchains. Compiling to a binary using the default target from the installation can be done; as follows:. .. code-block:: console. $ echo ""kernel void k(){}"" > test.cl; $ clang test.cl. Compiling for a specific target can be done by specifying the triple corresponding; to the target, for example:. .. code-block:: console. $ clang --target=nvptx64-unknown-unknown test.cl; $ clang --target=amdgcn-amd-amdhsa -mcpu=gfx900 test.cl. Compiling to bitcode can be done as follows:. .. code-block:: console. $ clang -c -emit-llvm test.cl. This will produce a file `test.bc` that can be used in vendor toolchains; to perform machine code generation. Note that if compiled to bitcode for generic targets such as SPIR/SPIR-V,; portable IR is produced that can be used with various vendor; tools as well as open source tools such as `SPIRV-LLVM Translator; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator>`_; to produce SPIR-V binary. More details are provided in `the offline; compilation from OpenCL kernel sources into SPIR-V using open source; tools; <https://github.com/KhronosGroup/OpenCL-Guide/blob/main/chapters/os_tooling.md>`_.; From clang 14 onwards SPIR-V can be generated directly as detailed in; :ref:`the SPIR-V support section <spir-v>`. Clang currently supports OpenCL C language standards up to v2.0. Clang mainly; supports full profile. There is only very limited support of the embe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:141290,Testability,test,test,141290,"eneration for threadprivate; variables relies on OpenMP runtime library. .. _opencl:. OpenCL Features; ===============. Clang can be used to compile OpenCL kernels for execution on a device; (e.g. GPU). It is possible to compile the kernel into a binary (e.g. for AMDGPU); that can be uploaded to run directly on a device (e.g. using; `clCreateProgramWithBinary; <https://www.khronos.org/registry/OpenCL/specs/opencl-1.1.pdf#111>`_) or; into generic bitcode files loadable into other toolchains. Compiling to a binary using the default target from the installation can be done; as follows:. .. code-block:: console. $ echo ""kernel void k(){}"" > test.cl; $ clang test.cl. Compiling for a specific target can be done by specifying the triple corresponding; to the target, for example:. .. code-block:: console. $ clang --target=nvptx64-unknown-unknown test.cl; $ clang --target=amdgcn-amd-amdhsa -mcpu=gfx900 test.cl. Compiling to bitcode can be done as follows:. .. code-block:: console. $ clang -c -emit-llvm test.cl. This will produce a file `test.bc` that can be used in vendor toolchains; to perform machine code generation. Note that if compiled to bitcode for generic targets such as SPIR/SPIR-V,; portable IR is produced that can be used with various vendor; tools as well as open source tools such as `SPIRV-LLVM Translator; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator>`_; to produce SPIR-V binary. More details are provided in `the offline; compilation from OpenCL kernel sources into SPIR-V using open source; tools; <https://github.com/KhronosGroup/OpenCL-Guide/blob/main/chapters/os_tooling.md>`_.; From clang 14 onwards SPIR-V can be generated directly as detailed in; :ref:`the SPIR-V support section <spir-v>`. Clang currently supports OpenCL C language standards up to v2.0. Clang mainly; supports full profile. There is only very limited support of the embedded; profile.; From clang 9 a C++ mode is available for OpenCL (see; :ref:`C++ for OpenCL <cxx_for_opencl>`). OpenC",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:141325,Testability,test,test,141325,"ables relies on OpenMP runtime library. .. _opencl:. OpenCL Features; ===============. Clang can be used to compile OpenCL kernels for execution on a device; (e.g. GPU). It is possible to compile the kernel into a binary (e.g. for AMDGPU); that can be uploaded to run directly on a device (e.g. using; `clCreateProgramWithBinary; <https://www.khronos.org/registry/OpenCL/specs/opencl-1.1.pdf#111>`_) or; into generic bitcode files loadable into other toolchains. Compiling to a binary using the default target from the installation can be done; as follows:. .. code-block:: console. $ echo ""kernel void k(){}"" > test.cl; $ clang test.cl. Compiling for a specific target can be done by specifying the triple corresponding; to the target, for example:. .. code-block:: console. $ clang --target=nvptx64-unknown-unknown test.cl; $ clang --target=amdgcn-amd-amdhsa -mcpu=gfx900 test.cl. Compiling to bitcode can be done as follows:. .. code-block:: console. $ clang -c -emit-llvm test.cl. This will produce a file `test.bc` that can be used in vendor toolchains; to perform machine code generation. Note that if compiled to bitcode for generic targets such as SPIR/SPIR-V,; portable IR is produced that can be used with various vendor; tools as well as open source tools such as `SPIRV-LLVM Translator; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator>`_; to produce SPIR-V binary. More details are provided in `the offline; compilation from OpenCL kernel sources into SPIR-V using open source; tools; <https://github.com/KhronosGroup/OpenCL-Guide/blob/main/chapters/os_tooling.md>`_.; From clang 14 onwards SPIR-V can be generated directly as detailed in; :ref:`the SPIR-V support section <spir-v>`. Clang currently supports OpenCL C language standards up to v2.0. Clang mainly; supports full profile. There is only very limited support of the embedded; profile.; From clang 9 a C++ mode is available for OpenCL (see; :ref:`C++ for OpenCL <cxx_for_opencl>`). OpenCL v3.0 support is complete but it",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:142738,Testability,test,test,142738,"in `the offline; compilation from OpenCL kernel sources into SPIR-V using open source; tools; <https://github.com/KhronosGroup/OpenCL-Guide/blob/main/chapters/os_tooling.md>`_.; From clang 14 onwards SPIR-V can be generated directly as detailed in; :ref:`the SPIR-V support section <spir-v>`. Clang currently supports OpenCL C language standards up to v2.0. Clang mainly; supports full profile. There is only very limited support of the embedded; profile.; From clang 9 a C++ mode is available for OpenCL (see; :ref:`C++ for OpenCL <cxx_for_opencl>`). OpenCL v3.0 support is complete but it remains in experimental state, see more; details about the experimental features and limitations in :doc:`OpenCLSupport`; page. OpenCL Specific Options; -----------------------. Most of the OpenCL build options from `the specification v2.0 section 5.8.4; <https://www.khronos.org/registry/cl/specs/opencl-2.0.pdf#200>`_ are available. Examples:. .. code-block:: console. $ clang -cl-std=CL2.0 -cl-single-precision-constant test.cl. Many flags used for the compilation for C sources can also be passed while; compiling for OpenCL, examples: ``-c``, ``-O<1-4|s>``, ``-o``, ``-emit-llvm``, etc. Some extra options are available to support special OpenCL features. .. option:: -cl-no-stdinc. Allows to disable all extra types and functions that are not native to the compiler.; This might reduce the compilation speed marginally but many declarations from the; OpenCL standard will not be accessible. For example, the following will fail to; compile. .. code-block:: console. $ echo ""bool is_wg_uniform(int i){return get_enqueued_local_size(i)==get_local_size(i);}"" > test.cl; $ clang -cl-std=CL2.0 -cl-no-stdinc test.cl; error: use of undeclared identifier 'get_enqueued_local_size'; error: use of undeclared identifier 'get_local_size'. More information about the standard types and functions is provided in :ref:`the; section on the OpenCL Header <opencl_header>`. .. _opencl_cl_ext:. .. option:: -cl-ext. Enabl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:143379,Testability,test,test,143379,"tal state, see more; details about the experimental features and limitations in :doc:`OpenCLSupport`; page. OpenCL Specific Options; -----------------------. Most of the OpenCL build options from `the specification v2.0 section 5.8.4; <https://www.khronos.org/registry/cl/specs/opencl-2.0.pdf#200>`_ are available. Examples:. .. code-block:: console. $ clang -cl-std=CL2.0 -cl-single-precision-constant test.cl. Many flags used for the compilation for C sources can also be passed while; compiling for OpenCL, examples: ``-c``, ``-O<1-4|s>``, ``-o``, ``-emit-llvm``, etc. Some extra options are available to support special OpenCL features. .. option:: -cl-no-stdinc. Allows to disable all extra types and functions that are not native to the compiler.; This might reduce the compilation speed marginally but many declarations from the; OpenCL standard will not be accessible. For example, the following will fail to; compile. .. code-block:: console. $ echo ""bool is_wg_uniform(int i){return get_enqueued_local_size(i)==get_local_size(i);}"" > test.cl; $ clang -cl-std=CL2.0 -cl-no-stdinc test.cl; error: use of undeclared identifier 'get_enqueued_local_size'; error: use of undeclared identifier 'get_local_size'. More information about the standard types and functions is provided in :ref:`the; section on the OpenCL Header <opencl_header>`. .. _opencl_cl_ext:. .. option:: -cl-ext. Enables/Disables support of OpenCL extensions and optional features. All OpenCL; targets set a list of extensions that they support. Clang allows to amend this using; the ``-cl-ext`` flag with a comma-separated list of extensions prefixed with; ``'+'`` or ``'-'``. The syntax: ``-cl-ext=<(['-'|'+']<extension>[,])+>``, where; extensions can be either one of `the OpenCL published extensions; <https://www.khronos.org/registry/OpenCL>`_; or any vendor extension. Alternatively, ``'all'`` can be used to enable; or disable all known extensions. Example disabling double support for the 64-bit SPIR-V target:. .. code-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:143424,Testability,test,test,143424,"c:`OpenCLSupport`; page. OpenCL Specific Options; -----------------------. Most of the OpenCL build options from `the specification v2.0 section 5.8.4; <https://www.khronos.org/registry/cl/specs/opencl-2.0.pdf#200>`_ are available. Examples:. .. code-block:: console. $ clang -cl-std=CL2.0 -cl-single-precision-constant test.cl. Many flags used for the compilation for C sources can also be passed while; compiling for OpenCL, examples: ``-c``, ``-O<1-4|s>``, ``-o``, ``-emit-llvm``, etc. Some extra options are available to support special OpenCL features. .. option:: -cl-no-stdinc. Allows to disable all extra types and functions that are not native to the compiler.; This might reduce the compilation speed marginally but many declarations from the; OpenCL standard will not be accessible. For example, the following will fail to; compile. .. code-block:: console. $ echo ""bool is_wg_uniform(int i){return get_enqueued_local_size(i)==get_local_size(i);}"" > test.cl; $ clang -cl-std=CL2.0 -cl-no-stdinc test.cl; error: use of undeclared identifier 'get_enqueued_local_size'; error: use of undeclared identifier 'get_local_size'. More information about the standard types and functions is provided in :ref:`the; section on the OpenCL Header <opencl_header>`. .. _opencl_cl_ext:. .. option:: -cl-ext. Enables/Disables support of OpenCL extensions and optional features. All OpenCL; targets set a list of extensions that they support. Clang allows to amend this using; the ``-cl-ext`` flag with a comma-separated list of extensions prefixed with; ``'+'`` or ``'-'``. The syntax: ``-cl-ext=<(['-'|'+']<extension>[,])+>``, where; extensions can be either one of `the OpenCL published extensions; <https://www.khronos.org/registry/OpenCL>`_; or any vendor extension. Alternatively, ``'all'`` can be used to enable; or disable all known extensions. Example disabling double support for the 64-bit SPIR-V target:. .. code-block:: console. $ clang -c --target=spirv64 -cl-ext=-cl_khr_fp64 test.cl. Enabling ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:144401,Testability,test,test,144401," test.cl; $ clang -cl-std=CL2.0 -cl-no-stdinc test.cl; error: use of undeclared identifier 'get_enqueued_local_size'; error: use of undeclared identifier 'get_local_size'. More information about the standard types and functions is provided in :ref:`the; section on the OpenCL Header <opencl_header>`. .. _opencl_cl_ext:. .. option:: -cl-ext. Enables/Disables support of OpenCL extensions and optional features. All OpenCL; targets set a list of extensions that they support. Clang allows to amend this using; the ``-cl-ext`` flag with a comma-separated list of extensions prefixed with; ``'+'`` or ``'-'``. The syntax: ``-cl-ext=<(['-'|'+']<extension>[,])+>``, where; extensions can be either one of `the OpenCL published extensions; <https://www.khronos.org/registry/OpenCL>`_; or any vendor extension. Alternatively, ``'all'`` can be used to enable; or disable all known extensions. Example disabling double support for the 64-bit SPIR-V target:. .. code-block:: console. $ clang -c --target=spirv64 -cl-ext=-cl_khr_fp64 test.cl. Enabling all extensions except double support in R600 AMD GPU can be done using:. .. code-block:: console. $ clang --target=r600 -cl-ext=-all,+cl_khr_fp16 test.cl. Note that some generic targets e.g. SPIR/SPIR-V enable all extensions/features in; clang by default. OpenCL Targets; --------------. OpenCL targets are derived from the regular Clang target classes. The OpenCL; specific parts of the target representation provide address space mapping as; well as a set of supported extensions. Specific Targets; ^^^^^^^^^^^^^^^^. There is a set of concrete HW architectures that OpenCL can be compiled for. - For AMD target:. .. code-block:: console. $ clang --target=amdgcn-amd-amdhsa -mcpu=gfx900 test.cl. - For Nvidia architectures:. .. code-block:: console. $ clang --target=nvptx64-unknown-unknown test.cl. Generic Targets; ^^^^^^^^^^^^^^^. - A SPIR-V binary can be produced for 32 or 64 bit targets. .. code-block:: console. $ clang --target=spirv32 -c test.cl; $ c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:144565,Testability,test,test,144565,"size'. More information about the standard types and functions is provided in :ref:`the; section on the OpenCL Header <opencl_header>`. .. _opencl_cl_ext:. .. option:: -cl-ext. Enables/Disables support of OpenCL extensions and optional features. All OpenCL; targets set a list of extensions that they support. Clang allows to amend this using; the ``-cl-ext`` flag with a comma-separated list of extensions prefixed with; ``'+'`` or ``'-'``. The syntax: ``-cl-ext=<(['-'|'+']<extension>[,])+>``, where; extensions can be either one of `the OpenCL published extensions; <https://www.khronos.org/registry/OpenCL>`_; or any vendor extension. Alternatively, ``'all'`` can be used to enable; or disable all known extensions. Example disabling double support for the 64-bit SPIR-V target:. .. code-block:: console. $ clang -c --target=spirv64 -cl-ext=-cl_khr_fp64 test.cl. Enabling all extensions except double support in R600 AMD GPU can be done using:. .. code-block:: console. $ clang --target=r600 -cl-ext=-all,+cl_khr_fp16 test.cl. Note that some generic targets e.g. SPIR/SPIR-V enable all extensions/features in; clang by default. OpenCL Targets; --------------. OpenCL targets are derived from the regular Clang target classes. The OpenCL; specific parts of the target representation provide address space mapping as; well as a set of supported extensions. Specific Targets; ^^^^^^^^^^^^^^^^. There is a set of concrete HW architectures that OpenCL can be compiled for. - For AMD target:. .. code-block:: console. $ clang --target=amdgcn-amd-amdhsa -mcpu=gfx900 test.cl. - For Nvidia architectures:. .. code-block:: console. $ clang --target=nvptx64-unknown-unknown test.cl. Generic Targets; ^^^^^^^^^^^^^^^. - A SPIR-V binary can be produced for 32 or 64 bit targets. .. code-block:: console. $ clang --target=spirv32 -c test.cl; $ clang --target=spirv64 -c test.cl. More details can be found in :ref:`the SPIR-V support section <spir-v>`. - SPIR is available as a generic target to allow portable",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:145107,Testability,test,test,145107,"enCL published extensions; <https://www.khronos.org/registry/OpenCL>`_; or any vendor extension. Alternatively, ``'all'`` can be used to enable; or disable all known extensions. Example disabling double support for the 64-bit SPIR-V target:. .. code-block:: console. $ clang -c --target=spirv64 -cl-ext=-cl_khr_fp64 test.cl. Enabling all extensions except double support in R600 AMD GPU can be done using:. .. code-block:: console. $ clang --target=r600 -cl-ext=-all,+cl_khr_fp16 test.cl. Note that some generic targets e.g. SPIR/SPIR-V enable all extensions/features in; clang by default. OpenCL Targets; --------------. OpenCL targets are derived from the regular Clang target classes. The OpenCL; specific parts of the target representation provide address space mapping as; well as a set of supported extensions. Specific Targets; ^^^^^^^^^^^^^^^^. There is a set of concrete HW architectures that OpenCL can be compiled for. - For AMD target:. .. code-block:: console. $ clang --target=amdgcn-amd-amdhsa -mcpu=gfx900 test.cl. - For Nvidia architectures:. .. code-block:: console. $ clang --target=nvptx64-unknown-unknown test.cl. Generic Targets; ^^^^^^^^^^^^^^^. - A SPIR-V binary can be produced for 32 or 64 bit targets. .. code-block:: console. $ clang --target=spirv32 -c test.cl; $ clang --target=spirv64 -c test.cl. More details can be found in :ref:`the SPIR-V support section <spir-v>`. - SPIR is available as a generic target to allow portable bitcode to be produced; that can be used across GPU toolchains. The implementation follows `the SPIR; specification <https://www.khronos.org/spir>`_. There are two flavors; available for 32 and 64 bits. .. code-block:: console. $ clang --target=spir test.cl -emit-llvm -c; $ clang --target=spir64 test.cl -emit-llvm -c. Clang will generate SPIR v1.2 compatible IR for OpenCL versions up to 2.0 and; SPIR v2.0 for OpenCL v2.0 or C++ for OpenCL. - x86 is used by some implementations that are x86 compatible and currently; remains for backward",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:145211,Testability,test,test,145211,"ely, ``'all'`` can be used to enable; or disable all known extensions. Example disabling double support for the 64-bit SPIR-V target:. .. code-block:: console. $ clang -c --target=spirv64 -cl-ext=-cl_khr_fp64 test.cl. Enabling all extensions except double support in R600 AMD GPU can be done using:. .. code-block:: console. $ clang --target=r600 -cl-ext=-all,+cl_khr_fp16 test.cl. Note that some generic targets e.g. SPIR/SPIR-V enable all extensions/features in; clang by default. OpenCL Targets; --------------. OpenCL targets are derived from the regular Clang target classes. The OpenCL; specific parts of the target representation provide address space mapping as; well as a set of supported extensions. Specific Targets; ^^^^^^^^^^^^^^^^. There is a set of concrete HW architectures that OpenCL can be compiled for. - For AMD target:. .. code-block:: console. $ clang --target=amdgcn-amd-amdhsa -mcpu=gfx900 test.cl. - For Nvidia architectures:. .. code-block:: console. $ clang --target=nvptx64-unknown-unknown test.cl. Generic Targets; ^^^^^^^^^^^^^^^. - A SPIR-V binary can be produced for 32 or 64 bit targets. .. code-block:: console. $ clang --target=spirv32 -c test.cl; $ clang --target=spirv64 -c test.cl. More details can be found in :ref:`the SPIR-V support section <spir-v>`. - SPIR is available as a generic target to allow portable bitcode to be produced; that can be used across GPU toolchains. The implementation follows `the SPIR; specification <https://www.khronos.org/spir>`_. There are two flavors; available for 32 and 64 bits. .. code-block:: console. $ clang --target=spir test.cl -emit-llvm -c; $ clang --target=spir64 test.cl -emit-llvm -c. Clang will generate SPIR v1.2 compatible IR for OpenCL versions up to 2.0 and; SPIR v2.0 for OpenCL v2.0 or C++ for OpenCL. - x86 is used by some implementations that are x86 compatible and currently; remains for backwards compatibility (with older implementations prior to; SPIR target support). For ""non-SPMD"" targets which can",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:145367,Testability,test,test,145367,"lang -c --target=spirv64 -cl-ext=-cl_khr_fp64 test.cl. Enabling all extensions except double support in R600 AMD GPU can be done using:. .. code-block:: console. $ clang --target=r600 -cl-ext=-all,+cl_khr_fp16 test.cl. Note that some generic targets e.g. SPIR/SPIR-V enable all extensions/features in; clang by default. OpenCL Targets; --------------. OpenCL targets are derived from the regular Clang target classes. The OpenCL; specific parts of the target representation provide address space mapping as; well as a set of supported extensions. Specific Targets; ^^^^^^^^^^^^^^^^. There is a set of concrete HW architectures that OpenCL can be compiled for. - For AMD target:. .. code-block:: console. $ clang --target=amdgcn-amd-amdhsa -mcpu=gfx900 test.cl. - For Nvidia architectures:. .. code-block:: console. $ clang --target=nvptx64-unknown-unknown test.cl. Generic Targets; ^^^^^^^^^^^^^^^. - A SPIR-V binary can be produced for 32 or 64 bit targets. .. code-block:: console. $ clang --target=spirv32 -c test.cl; $ clang --target=spirv64 -c test.cl. More details can be found in :ref:`the SPIR-V support section <spir-v>`. - SPIR is available as a generic target to allow portable bitcode to be produced; that can be used across GPU toolchains. The implementation follows `the SPIR; specification <https://www.khronos.org/spir>`_. There are two flavors; available for 32 and 64 bits. .. code-block:: console. $ clang --target=spir test.cl -emit-llvm -c; $ clang --target=spir64 test.cl -emit-llvm -c. Clang will generate SPIR v1.2 compatible IR for OpenCL versions up to 2.0 and; SPIR v2.0 for OpenCL v2.0 or C++ for OpenCL. - x86 is used by some implementations that are x86 compatible and currently; remains for backwards compatibility (with older implementations prior to; SPIR target support). For ""non-SPMD"" targets which cannot spawn multiple; work-items on the fly using hardware, which covers practically all non-GPU; devices such as CPUs and DSPs, additional processing is needed for",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:145404,Testability,test,test,145404,"l_khr_fp64 test.cl. Enabling all extensions except double support in R600 AMD GPU can be done using:. .. code-block:: console. $ clang --target=r600 -cl-ext=-all,+cl_khr_fp16 test.cl. Note that some generic targets e.g. SPIR/SPIR-V enable all extensions/features in; clang by default. OpenCL Targets; --------------. OpenCL targets are derived from the regular Clang target classes. The OpenCL; specific parts of the target representation provide address space mapping as; well as a set of supported extensions. Specific Targets; ^^^^^^^^^^^^^^^^. There is a set of concrete HW architectures that OpenCL can be compiled for. - For AMD target:. .. code-block:: console. $ clang --target=amdgcn-amd-amdhsa -mcpu=gfx900 test.cl. - For Nvidia architectures:. .. code-block:: console. $ clang --target=nvptx64-unknown-unknown test.cl. Generic Targets; ^^^^^^^^^^^^^^^. - A SPIR-V binary can be produced for 32 or 64 bit targets. .. code-block:: console. $ clang --target=spirv32 -c test.cl; $ clang --target=spirv64 -c test.cl. More details can be found in :ref:`the SPIR-V support section <spir-v>`. - SPIR is available as a generic target to allow portable bitcode to be produced; that can be used across GPU toolchains. The implementation follows `the SPIR; specification <https://www.khronos.org/spir>`_. There are two flavors; available for 32 and 64 bits. .. code-block:: console. $ clang --target=spir test.cl -emit-llvm -c; $ clang --target=spir64 test.cl -emit-llvm -c. Clang will generate SPIR v1.2 compatible IR for OpenCL versions up to 2.0 and; SPIR v2.0 for OpenCL v2.0 or C++ for OpenCL. - x86 is used by some implementations that are x86 compatible and currently; remains for backwards compatibility (with older implementations prior to; SPIR target support). For ""non-SPMD"" targets which cannot spawn multiple; work-items on the fly using hardware, which covers practically all non-GPU; devices such as CPUs and DSPs, additional processing is needed for the kernels; to support multiple wo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:145794,Testability,test,test,145794,"specific parts of the target representation provide address space mapping as; well as a set of supported extensions. Specific Targets; ^^^^^^^^^^^^^^^^. There is a set of concrete HW architectures that OpenCL can be compiled for. - For AMD target:. .. code-block:: console. $ clang --target=amdgcn-amd-amdhsa -mcpu=gfx900 test.cl. - For Nvidia architectures:. .. code-block:: console. $ clang --target=nvptx64-unknown-unknown test.cl. Generic Targets; ^^^^^^^^^^^^^^^. - A SPIR-V binary can be produced for 32 or 64 bit targets. .. code-block:: console. $ clang --target=spirv32 -c test.cl; $ clang --target=spirv64 -c test.cl. More details can be found in :ref:`the SPIR-V support section <spir-v>`. - SPIR is available as a generic target to allow portable bitcode to be produced; that can be used across GPU toolchains. The implementation follows `the SPIR; specification <https://www.khronos.org/spir>`_. There are two flavors; available for 32 and 64 bits. .. code-block:: console. $ clang --target=spir test.cl -emit-llvm -c; $ clang --target=spir64 test.cl -emit-llvm -c. Clang will generate SPIR v1.2 compatible IR for OpenCL versions up to 2.0 and; SPIR v2.0 for OpenCL v2.0 or C++ for OpenCL. - x86 is used by some implementations that are x86 compatible and currently; remains for backwards compatibility (with older implementations prior to; SPIR target support). For ""non-SPMD"" targets which cannot spawn multiple; work-items on the fly using hardware, which covers practically all non-GPU; devices such as CPUs and DSPs, additional processing is needed for the kernels; to support multiple work-item execution. For this, a 3rd party toolchain,; such as for example `POCL <http://portablecl.org/>`_, can be used. This target does not support multiple memory segments and, therefore, the fake; address space map can be added using the :ref:`-ffake-address-space-map; <opencl_fake_address_space_map>` flag. All known OpenCL extensions and features are set to supported in the generic targe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:145841,Testability,test,test,145841,"tation provide address space mapping as; well as a set of supported extensions. Specific Targets; ^^^^^^^^^^^^^^^^. There is a set of concrete HW architectures that OpenCL can be compiled for. - For AMD target:. .. code-block:: console. $ clang --target=amdgcn-amd-amdhsa -mcpu=gfx900 test.cl. - For Nvidia architectures:. .. code-block:: console. $ clang --target=nvptx64-unknown-unknown test.cl. Generic Targets; ^^^^^^^^^^^^^^^. - A SPIR-V binary can be produced for 32 or 64 bit targets. .. code-block:: console. $ clang --target=spirv32 -c test.cl; $ clang --target=spirv64 -c test.cl. More details can be found in :ref:`the SPIR-V support section <spir-v>`. - SPIR is available as a generic target to allow portable bitcode to be produced; that can be used across GPU toolchains. The implementation follows `the SPIR; specification <https://www.khronos.org/spir>`_. There are two flavors; available for 32 and 64 bits. .. code-block:: console. $ clang --target=spir test.cl -emit-llvm -c; $ clang --target=spir64 test.cl -emit-llvm -c. Clang will generate SPIR v1.2 compatible IR for OpenCL versions up to 2.0 and; SPIR v2.0 for OpenCL v2.0 or C++ for OpenCL. - x86 is used by some implementations that are x86 compatible and currently; remains for backwards compatibility (with older implementations prior to; SPIR target support). For ""non-SPMD"" targets which cannot spawn multiple; work-items on the fly using hardware, which covers practically all non-GPU; devices such as CPUs and DSPs, additional processing is needed for the kernels; to support multiple work-item execution. For this, a 3rd party toolchain,; such as for example `POCL <http://portablecl.org/>`_, can be used. This target does not support multiple memory segments and, therefore, the fake; address space map can be added using the :ref:`-ffake-address-space-map; <opencl_fake_address_space_map>` flag. All known OpenCL extensions and features are set to supported in the generic targets,; however :option:`-cl-ext` flag ca",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:147492,Testability,test,test,147492," as for example `POCL <http://portablecl.org/>`_, can be used. This target does not support multiple memory segments and, therefore, the fake; address space map can be added using the :ref:`-ffake-address-space-map; <opencl_fake_address_space_map>` flag. All known OpenCL extensions and features are set to supported in the generic targets,; however :option:`-cl-ext` flag can be used to toggle individual extensions and; features. .. _opencl_header:. OpenCL Header; -------------. By default Clang will include standard headers and therefore most of OpenCL; builtin functions and types are available during compilation. The; default declarations of non-native compiler types and functions can be disabled; by using flag :option:`-cl-no-stdinc`. The following example demonstrates that OpenCL kernel sources with various; standard builtin functions can be compiled without the need for an explicit; includes or compiler flags. .. code-block:: console. $ echo ""bool is_wg_uniform(int i){return get_enqueued_local_size(i)==get_local_size(i);}"" > test.cl; $ clang -cl-std=CL2.0 test.cl. More information about the default headers is provided in :doc:`OpenCLSupport`. OpenCL Extensions; -----------------. Most of the ``cl_khr_*`` extensions to OpenCL C from `the official OpenCL; registry <https://www.khronos.org/registry/OpenCL/>`_ are available and; configured per target depending on the support available in the specific; architecture. It is possible to alter the default extensions setting per target using; ``-cl-ext`` flag. (See :ref:`flags description <opencl_cl_ext>` for more details). Vendor extensions can be added flexibly by declaring the list of types and; functions associated with each extensions enclosed within the following; compiler pragma directives:. .. code-block:: c. #pragma OPENCL EXTENSION the_new_extension_name : begin; // declare types and functions associated with the extension here; #pragma OPENCL EXTENSION the_new_extension_name : end. For example, parsing the follo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:147523,Testability,test,test,147523,"oes not support multiple memory segments and, therefore, the fake; address space map can be added using the :ref:`-ffake-address-space-map; <opencl_fake_address_space_map>` flag. All known OpenCL extensions and features are set to supported in the generic targets,; however :option:`-cl-ext` flag can be used to toggle individual extensions and; features. .. _opencl_header:. OpenCL Header; -------------. By default Clang will include standard headers and therefore most of OpenCL; builtin functions and types are available during compilation. The; default declarations of non-native compiler types and functions can be disabled; by using flag :option:`-cl-no-stdinc`. The following example demonstrates that OpenCL kernel sources with various; standard builtin functions can be compiled without the need for an explicit; includes or compiler flags. .. code-block:: console. $ echo ""bool is_wg_uniform(int i){return get_enqueued_local_size(i)==get_local_size(i);}"" > test.cl; $ clang -cl-std=CL2.0 test.cl. More information about the default headers is provided in :doc:`OpenCLSupport`. OpenCL Extensions; -----------------. Most of the ``cl_khr_*`` extensions to OpenCL C from `the official OpenCL; registry <https://www.khronos.org/registry/OpenCL/>`_ are available and; configured per target depending on the support available in the specific; architecture. It is possible to alter the default extensions setting per target using; ``-cl-ext`` flag. (See :ref:`flags description <opencl_cl_ext>` for more details). Vendor extensions can be added flexibly by declaring the list of types and; functions associated with each extensions enclosed within the following; compiler pragma directives:. .. code-block:: c. #pragma OPENCL EXTENSION the_new_extension_name : begin; // declare types and functions associated with the extension here; #pragma OPENCL EXTENSION the_new_extension_name : end. For example, parsing the following code adds ``my_t`` type and ``my_func``; function to the custom ``my_ext",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:153473,Testability,test,test,153473,"upport it in clang in any new releases in the near future. Clang currently supports C++ for OpenCL 1.0 and 2021.; For detailed information about this language refer to the C++ for OpenCL; Programming Language Documentation available; in `the latest build; <https://www.khronos.org/opencl/assets/CXX_for_OpenCL.html>`_; or in `the official release; <https://github.com/KhronosGroup/OpenCL-Docs/releases/tag/cxxforopencl-docrev2021.12>`_. To enable the C++ for OpenCL mode, pass one of following command line options when; compiling ``.clcpp`` file:. - C++ for OpenCL 1.0: ``-cl-std=clc++``, ``-cl-std=CLC++``, ``-cl-std=clc++1.0``,; ``-cl-std=CLC++1.0``, ``-std=clc++``, ``-std=CLC++``, ``-std=clc++1.0`` or; ``-std=CLC++1.0``. - C++ for OpenCL 2021: ``-cl-std=clc++2021``, ``-cl-std=CLC++2021``,; ``-std=clc++2021``, ``-std=CLC++2021``. Example of use:; .. code-block:: c++. template<class T> T add( T x, T y ); {; return x + y;; }. __kernel void test( __global float* a, __global float* b); {; auto index = get_global_id(0);; a[index] = add(b[index], b[index+1]);; }. .. code-block:: console. clang -cl-std=clc++1.0 test.clcpp; clang -cl-std=clc++ -c --target=spirv64 test.cl. By default, files with ``.clcpp`` extension are compiled with the C++ for; OpenCL 1.0 mode. .. code-block:: console. clang test.clcpp. For backward compatibility files with ``.cl`` extensions can also be compiled; in C++ for OpenCL mode but the desirable language mode must be activated with; a flag. .. code-block:: console. clang -cl-std=clc++ test.cl. Support of C++ for OpenCL 2021 is currently in experimental phase, refer to; :doc:`OpenCLSupport` for more details. C++ for OpenCL kernel sources can also be compiled online in drivers supporting; `cl_ext_cxx_for_opencl; <https://www.khronos.org/registry/OpenCL/extensions/ext/cl_ext_cxx_for_opencl.html>`_; extension. Constructing and destroying global objects; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Global objects with non-trivial constructors require the con",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:153643,Testability,test,test,153643,"detailed information about this language refer to the C++ for OpenCL; Programming Language Documentation available; in `the latest build; <https://www.khronos.org/opencl/assets/CXX_for_OpenCL.html>`_; or in `the official release; <https://github.com/KhronosGroup/OpenCL-Docs/releases/tag/cxxforopencl-docrev2021.12>`_. To enable the C++ for OpenCL mode, pass one of following command line options when; compiling ``.clcpp`` file:. - C++ for OpenCL 1.0: ``-cl-std=clc++``, ``-cl-std=CLC++``, ``-cl-std=clc++1.0``,; ``-cl-std=CLC++1.0``, ``-std=clc++``, ``-std=CLC++``, ``-std=clc++1.0`` or; ``-std=CLC++1.0``. - C++ for OpenCL 2021: ``-cl-std=clc++2021``, ``-cl-std=CLC++2021``,; ``-std=clc++2021``, ``-std=CLC++2021``. Example of use:; .. code-block:: c++. template<class T> T add( T x, T y ); {; return x + y;; }. __kernel void test( __global float* a, __global float* b); {; auto index = get_global_id(0);; a[index] = add(b[index], b[index+1]);; }. .. code-block:: console. clang -cl-std=clc++1.0 test.clcpp; clang -cl-std=clc++ -c --target=spirv64 test.cl. By default, files with ``.clcpp`` extension are compiled with the C++ for; OpenCL 1.0 mode. .. code-block:: console. clang test.clcpp. For backward compatibility files with ``.cl`` extensions can also be compiled; in C++ for OpenCL mode but the desirable language mode must be activated with; a flag. .. code-block:: console. clang -cl-std=clc++ test.cl. Support of C++ for OpenCL 2021 is currently in experimental phase, refer to; :doc:`OpenCLSupport` for more details. C++ for OpenCL kernel sources can also be compiled online in drivers supporting; `cl_ext_cxx_for_opencl; <https://www.khronos.org/registry/OpenCL/extensions/ext/cl_ext_cxx_for_opencl.html>`_; extension. Constructing and destroying global objects; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Global objects with non-trivial constructors require the constructors to be run; before the first kernel using the global objects is executed. Similarly global; objects with non-t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:153695,Testability,test,test,153695,"s language refer to the C++ for OpenCL; Programming Language Documentation available; in `the latest build; <https://www.khronos.org/opencl/assets/CXX_for_OpenCL.html>`_; or in `the official release; <https://github.com/KhronosGroup/OpenCL-Docs/releases/tag/cxxforopencl-docrev2021.12>`_. To enable the C++ for OpenCL mode, pass one of following command line options when; compiling ``.clcpp`` file:. - C++ for OpenCL 1.0: ``-cl-std=clc++``, ``-cl-std=CLC++``, ``-cl-std=clc++1.0``,; ``-cl-std=CLC++1.0``, ``-std=clc++``, ``-std=CLC++``, ``-std=clc++1.0`` or; ``-std=CLC++1.0``. - C++ for OpenCL 2021: ``-cl-std=clc++2021``, ``-cl-std=CLC++2021``,; ``-std=clc++2021``, ``-std=CLC++2021``. Example of use:; .. code-block:: c++. template<class T> T add( T x, T y ); {; return x + y;; }. __kernel void test( __global float* a, __global float* b); {; auto index = get_global_id(0);; a[index] = add(b[index], b[index+1]);; }. .. code-block:: console. clang -cl-std=clc++1.0 test.clcpp; clang -cl-std=clc++ -c --target=spirv64 test.cl. By default, files with ``.clcpp`` extension are compiled with the C++ for; OpenCL 1.0 mode. .. code-block:: console. clang test.clcpp. For backward compatibility files with ``.cl`` extensions can also be compiled; in C++ for OpenCL mode but the desirable language mode must be activated with; a flag. .. code-block:: console. clang -cl-std=clc++ test.cl. Support of C++ for OpenCL 2021 is currently in experimental phase, refer to; :doc:`OpenCLSupport` for more details. C++ for OpenCL kernel sources can also be compiled online in drivers supporting; `cl_ext_cxx_for_opencl; <https://www.khronos.org/registry/OpenCL/extensions/ext/cl_ext_cxx_for_opencl.html>`_; extension. Constructing and destroying global objects; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Global objects with non-trivial constructors require the constructors to be run; before the first kernel using the global objects is executed. Similarly global; objects with non-trivial destructors require de",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:153827,Testability,test,test,153827,"or_OpenCL.html>`_; or in `the official release; <https://github.com/KhronosGroup/OpenCL-Docs/releases/tag/cxxforopencl-docrev2021.12>`_. To enable the C++ for OpenCL mode, pass one of following command line options when; compiling ``.clcpp`` file:. - C++ for OpenCL 1.0: ``-cl-std=clc++``, ``-cl-std=CLC++``, ``-cl-std=clc++1.0``,; ``-cl-std=CLC++1.0``, ``-std=clc++``, ``-std=CLC++``, ``-std=clc++1.0`` or; ``-std=CLC++1.0``. - C++ for OpenCL 2021: ``-cl-std=clc++2021``, ``-cl-std=CLC++2021``,; ``-std=clc++2021``, ``-std=CLC++2021``. Example of use:; .. code-block:: c++. template<class T> T add( T x, T y ); {; return x + y;; }. __kernel void test( __global float* a, __global float* b); {; auto index = get_global_id(0);; a[index] = add(b[index], b[index+1]);; }. .. code-block:: console. clang -cl-std=clc++1.0 test.clcpp; clang -cl-std=clc++ -c --target=spirv64 test.cl. By default, files with ``.clcpp`` extension are compiled with the C++ for; OpenCL 1.0 mode. .. code-block:: console. clang test.clcpp. For backward compatibility files with ``.cl`` extensions can also be compiled; in C++ for OpenCL mode but the desirable language mode must be activated with; a flag. .. code-block:: console. clang -cl-std=clc++ test.cl. Support of C++ for OpenCL 2021 is currently in experimental phase, refer to; :doc:`OpenCLSupport` for more details. C++ for OpenCL kernel sources can also be compiled online in drivers supporting; `cl_ext_cxx_for_opencl; <https://www.khronos.org/registry/OpenCL/extensions/ext/cl_ext_cxx_for_opencl.html>`_; extension. Constructing and destroying global objects; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Global objects with non-trivial constructors require the constructors to be run; before the first kernel using the global objects is executed. Similarly global; objects with non-trivial destructors require destructor invocation just after; the last kernel using the program objects is executed.; In OpenCL versions earlier than v2.2 there is no support for inv",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:154050,Testability,test,test,154050,"hen; compiling ``.clcpp`` file:. - C++ for OpenCL 1.0: ``-cl-std=clc++``, ``-cl-std=CLC++``, ``-cl-std=clc++1.0``,; ``-cl-std=CLC++1.0``, ``-std=clc++``, ``-std=CLC++``, ``-std=clc++1.0`` or; ``-std=CLC++1.0``. - C++ for OpenCL 2021: ``-cl-std=clc++2021``, ``-cl-std=CLC++2021``,; ``-std=clc++2021``, ``-std=CLC++2021``. Example of use:; .. code-block:: c++. template<class T> T add( T x, T y ); {; return x + y;; }. __kernel void test( __global float* a, __global float* b); {; auto index = get_global_id(0);; a[index] = add(b[index], b[index+1]);; }. .. code-block:: console. clang -cl-std=clc++1.0 test.clcpp; clang -cl-std=clc++ -c --target=spirv64 test.cl. By default, files with ``.clcpp`` extension are compiled with the C++ for; OpenCL 1.0 mode. .. code-block:: console. clang test.clcpp. For backward compatibility files with ``.cl`` extensions can also be compiled; in C++ for OpenCL mode but the desirable language mode must be activated with; a flag. .. code-block:: console. clang -cl-std=clc++ test.cl. Support of C++ for OpenCL 2021 is currently in experimental phase, refer to; :doc:`OpenCLSupport` for more details. C++ for OpenCL kernel sources can also be compiled online in drivers supporting; `cl_ext_cxx_for_opencl; <https://www.khronos.org/registry/OpenCL/extensions/ext/cl_ext_cxx_for_opencl.html>`_; extension. Constructing and destroying global objects; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Global objects with non-trivial constructors require the constructors to be run; before the first kernel using the global objects is executed. Similarly global; objects with non-trivial destructors require destructor invocation just after; the last kernel using the program objects is executed.; In OpenCL versions earlier than v2.2 there is no support for invoking global; constructors. However, an easy workaround is to manually enqueue the; constructor initialization kernel that has the following name scheme; ``_GLOBAL__sub_I_<compiled file name>``.; This kernel is only ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:155726,Testability,test,test,155726,"nel using the program objects is executed.; In OpenCL versions earlier than v2.2 there is no support for invoking global; constructors. However, an easy workaround is to manually enqueue the; constructor initialization kernel that has the following name scheme; ``_GLOBAL__sub_I_<compiled file name>``.; This kernel is only present if there are global objects with non-trivial; constructors present in the compiled binary. One way to check this is by; passing ``CL_PROGRAM_KERNEL_NAMES`` to ``clGetProgramInfo`` (OpenCL v2.0; s5.8.7) and then checking whether any kernel name matches the naming scheme of; global constructor initialization kernel above. Note that if multiple files are compiled and linked into libraries, multiple; kernels that initialize global objects for multiple modules would have to be; invoked. Applications are currently required to run initialization of global objects; manually before running any kernels in which the objects are used. .. code-block:: console. clang -cl-std=clc++ test.cl. If there are any global objects to be initialized, the final binary will; contain the ``_GLOBAL__sub_I_test.cl`` kernel to be enqueued. Note that the manual workaround only applies to objects declared at the; program scope. There is no manual workaround for the construction of static; objects with non-trivial constructors inside functions. Global destructors can not be invoked manually in the OpenCL v2.0 drivers.; However, all memory used for program scope objects should be released on; ``clReleaseProgram``. Libraries; ^^^^^^^^^; Limited experimental support of C++ standard libraries for OpenCL is; described in :doc:`OpenCLSupport` page. .. _target_features:. Target-Specific Features and Limitations; ========================================. CPU Architectures Features and Limitations; ------------------------------------------. X86; ^^^. The support for X86 (both 32-bit and 64-bit) is considered stable on; Darwin (macOS), Linux, FreeBSD, and Dragonfly BSD: it has been ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:156718,Testability,test,tested,156718," console. clang -cl-std=clc++ test.cl. If there are any global objects to be initialized, the final binary will; contain the ``_GLOBAL__sub_I_test.cl`` kernel to be enqueued. Note that the manual workaround only applies to objects declared at the; program scope. There is no manual workaround for the construction of static; objects with non-trivial constructors inside functions. Global destructors can not be invoked manually in the OpenCL v2.0 drivers.; However, all memory used for program scope objects should be released on; ``clReleaseProgram``. Libraries; ^^^^^^^^^; Limited experimental support of C++ standard libraries for OpenCL is; described in :doc:`OpenCLSupport` page. .. _target_features:. Target-Specific Features and Limitations; ========================================. CPU Architectures Features and Limitations; ------------------------------------------. X86; ^^^. The support for X86 (both 32-bit and 64-bit) is considered stable on; Darwin (macOS), Linux, FreeBSD, and Dragonfly BSD: it has been tested; to correctly compile many large C, C++, Objective-C, and Objective-C++; codebases. On ``x86_64-mingw32``, passing i128(by value) is incompatible with the; Microsoft x64 calling convention. You might need to tweak; ``WinX86_64ABIInfo::classify()`` in lib/CodeGen/Targets/X86.cpp. For the X86 target, clang supports the `-m16` command line; argument which enables 16-bit code output. This is broadly similar to; using ``asm("".code16gcc"")`` with the GNU toolchain. The generated code; and the ABI remains 32-bit but the assembler emits instructions; appropriate for a CPU running in 16-bit mode, with address-size and; operand-size prefixes to enable 32-bit addressing and operations. Several micro-architecture levels as specified by the x86-64 psABI are defined.; They are cumulative in the sense that features from previous levels are; implicitly included in later levels. - ``-march=x86-64``: CMOV, CMPXCHG8B, FPU, FXSR, MMX, FXSR, SCE, SSE, SSE2; - ``-march=x86-64-v2`",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:161540,Testability,test,tested,161540,"x10.2-256``, because ``avx10.2-256`` implies ``avx10.1-256``; and ``-mavx512f -mavx10.1-256`` equals to ``-mavx10.1-512``. There are some new macros introduced with AVX10 support. ``-mavx10.1-256`` will; enable ``__AVX10_1__`` and ``__EVEX256__``, while ``-mavx10.1-512`` enables; ``__AVX10_1__``, ``__EVEX256__``, ``__EVEX512__`` and ``__AVX10_1_512__``.; Besides, both ``-mavx10.1-256`` and ``-mavx10.1-512`` will enable all AVX512; feature specific macros. A AVX512 feature will enable both ``__EVEX256__``,; ``__EVEX512__`` and its own macro. So ``__EVEX512__`` can be used to guard code; that can run on both legacy AVX512 and AVX10/512 capable processors but cannot; run on AVX10/256, while a AVX512 macro like ``__AVX512F__`` cannot tell the; difference among the three options. Users need to check additional macros; ``__AVX10_1__`` and ``__EVEX512__`` if they want to make distinction. ARM; ^^^. The support for ARM (specifically ARMv6 and ARMv7) is considered stable; on Darwin (iOS): it has been tested to correctly compile many large C,; C++, Objective-C, and Objective-C++ codebases. Clang only supports a; limited number of ARM architectures. It does not yet fully support; ARMv5, for example. PowerPC; ^^^^^^^. The support for PowerPC (especially PowerPC64) is considered stable; on Linux and FreeBSD: it has been tested to correctly compile many; large C and C++ codebases. PowerPC (32bit) is still missing certain; features (e.g. PIC code on ELF platforms). Other platforms; ^^^^^^^^^^^^^^^. clang currently contains some support for other architectures (e.g. Sparc);; however, significant pieces of code generation are still missing, and they; haven't undergone significant testing. clang contains limited support for the MSP430 embedded processor, but; both the clang support and the LLVM backend support are highly; experimental. Other platforms are completely unsupported at the moment. Adding the; minimal support needed for parsing and semantic analysis on a new; platform is q",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:161862,Testability,test,tested,161862,"56__``, ``__EVEX512__`` and ``__AVX10_1_512__``.; Besides, both ``-mavx10.1-256`` and ``-mavx10.1-512`` will enable all AVX512; feature specific macros. A AVX512 feature will enable both ``__EVEX256__``,; ``__EVEX512__`` and its own macro. So ``__EVEX512__`` can be used to guard code; that can run on both legacy AVX512 and AVX10/512 capable processors but cannot; run on AVX10/256, while a AVX512 macro like ``__AVX512F__`` cannot tell the; difference among the three options. Users need to check additional macros; ``__AVX10_1__`` and ``__EVEX512__`` if they want to make distinction. ARM; ^^^. The support for ARM (specifically ARMv6 and ARMv7) is considered stable; on Darwin (iOS): it has been tested to correctly compile many large C,; C++, Objective-C, and Objective-C++ codebases. Clang only supports a; limited number of ARM architectures. It does not yet fully support; ARMv5, for example. PowerPC; ^^^^^^^. The support for PowerPC (especially PowerPC64) is considered stable; on Linux and FreeBSD: it has been tested to correctly compile many; large C and C++ codebases. PowerPC (32bit) is still missing certain; features (e.g. PIC code on ELF platforms). Other platforms; ^^^^^^^^^^^^^^^. clang currently contains some support for other architectures (e.g. Sparc);; however, significant pieces of code generation are still missing, and they; haven't undergone significant testing. clang contains limited support for the MSP430 embedded processor, but; both the clang support and the LLVM backend support are highly; experimental. Other platforms are completely unsupported at the moment. Adding the; minimal support needed for parsing and semantic analysis on a new; platform is quite easy; see ``lib/Basic/Targets.cpp`` in the clang source; tree. This level of support is also sufficient for conversion to LLVM IR; for simple programs. Proper support for conversion to LLVM IR requires; adding code to ``lib/CodeGen/CGCall.cpp`` at the moment; this is likely to; change soon, though. Ge",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:162225,Testability,test,testing,162225,"512 capable processors but cannot; run on AVX10/256, while a AVX512 macro like ``__AVX512F__`` cannot tell the; difference among the three options. Users need to check additional macros; ``__AVX10_1__`` and ``__EVEX512__`` if they want to make distinction. ARM; ^^^. The support for ARM (specifically ARMv6 and ARMv7) is considered stable; on Darwin (iOS): it has been tested to correctly compile many large C,; C++, Objective-C, and Objective-C++ codebases. Clang only supports a; limited number of ARM architectures. It does not yet fully support; ARMv5, for example. PowerPC; ^^^^^^^. The support for PowerPC (especially PowerPC64) is considered stable; on Linux and FreeBSD: it has been tested to correctly compile many; large C and C++ codebases. PowerPC (32bit) is still missing certain; features (e.g. PIC code on ELF platforms). Other platforms; ^^^^^^^^^^^^^^^. clang currently contains some support for other architectures (e.g. Sparc);; however, significant pieces of code generation are still missing, and they; haven't undergone significant testing. clang contains limited support for the MSP430 embedded processor, but; both the clang support and the LLVM backend support are highly; experimental. Other platforms are completely unsupported at the moment. Adding the; minimal support needed for parsing and semantic analysis on a new; platform is quite easy; see ``lib/Basic/Targets.cpp`` in the clang source; tree. This level of support is also sufficient for conversion to LLVM IR; for simple programs. Proper support for conversion to LLVM IR requires; adding code to ``lib/CodeGen/CGCall.cpp`` at the moment; this is likely to; change soon, though. Generating assembly requires a suitable LLVM; backend. Operating System Features and Limitations; -----------------------------------------. Windows; ^^^^^^^. Clang has experimental support for targeting ""Cygming"" (Cygwin / MinGW); platforms. See also :ref:`Microsoft Extensions <c_ms>`. Cygwin; """""""""""". Clang works on Cygwin-1.7. Mi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:163381,Testability,test,tests,163381,". Other platforms are completely unsupported at the moment. Adding the; minimal support needed for parsing and semantic analysis on a new; platform is quite easy; see ``lib/Basic/Targets.cpp`` in the clang source; tree. This level of support is also sufficient for conversion to LLVM IR; for simple programs. Proper support for conversion to LLVM IR requires; adding code to ``lib/CodeGen/CGCall.cpp`` at the moment; this is likely to; change soon, though. Generating assembly requires a suitable LLVM; backend. Operating System Features and Limitations; -----------------------------------------. Windows; ^^^^^^^. Clang has experimental support for targeting ""Cygming"" (Cygwin / MinGW); platforms. See also :ref:`Microsoft Extensions <c_ms>`. Cygwin; """""""""""". Clang works on Cygwin-1.7. MinGW32; """""""""""""". Clang works on some mingw32 distributions. Clang assumes directories as; below;. - ``C:/mingw/include``; - ``C:/mingw/lib``; - ``C:/mingw/lib/gcc/mingw32/4.[3-5].0/include/c++``. On MSYS, a few tests might fail. MinGW-w64; """""""""""""""""". For 32-bit (i686-w64-mingw32), and 64-bit (x86\_64-w64-mingw32), Clang; assumes as below;. - ``GCC versions 4.5.0 to 4.5.3, 4.6.0 to 4.6.2, or 4.7.0 (for the C++ header search path)``; - ``some_directory/bin/gcc.exe``; - ``some_directory/bin/clang.exe``; - ``some_directory/bin/clang++.exe``; - ``some_directory/bin/../include/c++/GCC_version``; - ``some_directory/bin/../include/c++/GCC_version/x86_64-w64-mingw32``; - ``some_directory/bin/../include/c++/GCC_version/i686-w64-mingw32``; - ``some_directory/bin/../include/c++/GCC_version/backward``; - ``some_directory/bin/../x86_64-w64-mingw32/include``; - ``some_directory/bin/../i686-w64-mingw32/include``; - ``some_directory/bin/../include``. This directory layout is standard for any toolchain you will find on the; official `MinGW-w64 website <http://mingw-w64.sourceforge.net>`_. Clang expects the GCC executable ""gcc.exe"" compiled for; ``i686-w64-mingw32`` (or ``x86_64-w64-mingw32``) to be present on P",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:164393,Testability,test,tests,164393,"w64; """""""""""""""""". For 32-bit (i686-w64-mingw32), and 64-bit (x86\_64-w64-mingw32), Clang; assumes as below;. - ``GCC versions 4.5.0 to 4.5.3, 4.6.0 to 4.6.2, or 4.7.0 (for the C++ header search path)``; - ``some_directory/bin/gcc.exe``; - ``some_directory/bin/clang.exe``; - ``some_directory/bin/clang++.exe``; - ``some_directory/bin/../include/c++/GCC_version``; - ``some_directory/bin/../include/c++/GCC_version/x86_64-w64-mingw32``; - ``some_directory/bin/../include/c++/GCC_version/i686-w64-mingw32``; - ``some_directory/bin/../include/c++/GCC_version/backward``; - ``some_directory/bin/../x86_64-w64-mingw32/include``; - ``some_directory/bin/../i686-w64-mingw32/include``; - ``some_directory/bin/../include``. This directory layout is standard for any toolchain you will find on the; official `MinGW-w64 website <http://mingw-w64.sourceforge.net>`_. Clang expects the GCC executable ""gcc.exe"" compiled for; ``i686-w64-mingw32`` (or ``x86_64-w64-mingw32``) to be present on PATH. `Some tests might fail <https://bugs.llvm.org/show_bug.cgi?id=9072>`_ on; ``x86_64-w64-mingw32``. AIX; ^^^. The ``-mdefault-visibility-export-mapping=`` option can be used to control; mapping of default visibility to an explicit shared object export; (i.e. XCOFF exported visibility). Three values are provided for the option:. * ``-mdefault-visibility-export-mapping=none``: no additional export; information is created for entities with default visibility.; * ``-mdefault-visibility-export-mapping=explicit``: mark entities for export; if they have explicit (e.g. via an attribute) default visibility from the; source, including RTTI.; * ``-mdefault-visibility-export-mapping=all``: set XCOFF exported visibility; for all entities with default visibility from any source. This gives a; export behavior similar to ELF platforms where all entities with default; visibility are exported. .. _spir-v:. SPIR-V support; --------------. Clang supports generation of SPIR-V conformant to `the OpenCL Environment; Specificati",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:166513,Testability,test,tested,166513," SPIR-V binaries, Clang uses the external ``llvm-spirv`` tool from the; `SPIRV-LLVM-Translator repo; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator>`_. Prior to the generation of SPIR-V binary with Clang, ``llvm-spirv``; should be built or installed. Please refer to `the following instructions; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator#build-instructions>`_; for more details. Clang will expect the ``llvm-spirv`` executable to; be present in the ``PATH`` environment variable. Clang uses ``llvm-spirv``; with `the widely adopted assembly syntax package; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator/#build-with-spirv-tools>`_. `The versioning; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator/releases>`_ of; ``llvm-spirv`` is aligned with Clang major releases. The same applies to the; main development branch. It is therefore important to ensure the ``llvm-spirv``; version is in alignment with the Clang version. For troubleshooting purposes; ``llvm-spirv`` can be `tested in isolation; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator#test-instructions>`_. Example usage for OpenCL kernel compilation:. .. code-block:: console. $ clang --target=spirv32 -c test.cl; $ clang --target=spirv64 -c test.cl. Both invocations of Clang will result in the generation of a SPIR-V binary file; `test.o` for 32 bit and 64 bit respectively. This file can be imported; by an OpenCL driver that support SPIR-V consumption or it can be compiled; further by offline SPIR-V consumer tools. Converting to SPIR-V produced with the optimization levels other than `-O0` is; currently available as an experimental feature and it is not guaranteed to work; in all cases. Clang also supports integrated generation of SPIR-V without use of ``llvm-spirv``; tool as an experimental feature when ``-fintegrated-objemitter`` flag is passed in; the command line. .. code-block:: console. $ clang --target=spirv32 -fintegrated-objemitter -c test.cl. Note that only very basic functio",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:166589,Testability,test,test-instructions,166589,"RV-LLVM-Translator repo; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator>`_. Prior to the generation of SPIR-V binary with Clang, ``llvm-spirv``; should be built or installed. Please refer to `the following instructions; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator#build-instructions>`_; for more details. Clang will expect the ``llvm-spirv`` executable to; be present in the ``PATH`` environment variable. Clang uses ``llvm-spirv``; with `the widely adopted assembly syntax package; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator/#build-with-spirv-tools>`_. `The versioning; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator/releases>`_ of; ``llvm-spirv`` is aligned with Clang major releases. The same applies to the; main development branch. It is therefore important to ensure the ``llvm-spirv``; version is in alignment with the Clang version. For troubleshooting purposes; ``llvm-spirv`` can be `tested in isolation; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator#test-instructions>`_. Example usage for OpenCL kernel compilation:. .. code-block:: console. $ clang --target=spirv32 -c test.cl; $ clang --target=spirv64 -c test.cl. Both invocations of Clang will result in the generation of a SPIR-V binary file; `test.o` for 32 bit and 64 bit respectively. This file can be imported; by an OpenCL driver that support SPIR-V consumption or it can be compiled; further by offline SPIR-V consumer tools. Converting to SPIR-V produced with the optimization levels other than `-O0` is; currently available as an experimental feature and it is not guaranteed to work; in all cases. Clang also supports integrated generation of SPIR-V without use of ``llvm-spirv``; tool as an experimental feature when ``-fintegrated-objemitter`` flag is passed in; the command line. .. code-block:: console. $ clang --target=spirv32 -fintegrated-objemitter -c test.cl. Note that only very basic functionality is supported at this point and therefore; it is not suitable for arb",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:166710,Testability,test,test,166710,"binary with Clang, ``llvm-spirv``; should be built or installed. Please refer to `the following instructions; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator#build-instructions>`_; for more details. Clang will expect the ``llvm-spirv`` executable to; be present in the ``PATH`` environment variable. Clang uses ``llvm-spirv``; with `the widely adopted assembly syntax package; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator/#build-with-spirv-tools>`_. `The versioning; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator/releases>`_ of; ``llvm-spirv`` is aligned with Clang major releases. The same applies to the; main development branch. It is therefore important to ensure the ``llvm-spirv``; version is in alignment with the Clang version. For troubleshooting purposes; ``llvm-spirv`` can be `tested in isolation; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator#test-instructions>`_. Example usage for OpenCL kernel compilation:. .. code-block:: console. $ clang --target=spirv32 -c test.cl; $ clang --target=spirv64 -c test.cl. Both invocations of Clang will result in the generation of a SPIR-V binary file; `test.o` for 32 bit and 64 bit respectively. This file can be imported; by an OpenCL driver that support SPIR-V consumption or it can be compiled; further by offline SPIR-V consumer tools. Converting to SPIR-V produced with the optimization levels other than `-O0` is; currently available as an experimental feature and it is not guaranteed to work; in all cases. Clang also supports integrated generation of SPIR-V without use of ``llvm-spirv``; tool as an experimental feature when ``-fintegrated-objemitter`` flag is passed in; the command line. .. code-block:: console. $ clang --target=spirv32 -fintegrated-objemitter -c test.cl. Note that only very basic functionality is supported at this point and therefore; it is not suitable for arbitrary use cases. This feature is only enabled when clang; build is configured with ``-DLLVM_EXPERIMENTAL_TARGETS_TO_B",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:166747,Testability,test,test,166747,should be built or installed. Please refer to `the following instructions; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator#build-instructions>`_; for more details. Clang will expect the ``llvm-spirv`` executable to; be present in the ``PATH`` environment variable. Clang uses ``llvm-spirv``; with `the widely adopted assembly syntax package; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator/#build-with-spirv-tools>`_. `The versioning; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator/releases>`_ of; ``llvm-spirv`` is aligned with Clang major releases. The same applies to the; main development branch. It is therefore important to ensure the ``llvm-spirv``; version is in alignment with the Clang version. For troubleshooting purposes; ``llvm-spirv`` can be `tested in isolation; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator#test-instructions>`_. Example usage for OpenCL kernel compilation:. .. code-block:: console. $ clang --target=spirv32 -c test.cl; $ clang --target=spirv64 -c test.cl. Both invocations of Clang will result in the generation of a SPIR-V binary file; `test.o` for 32 bit and 64 bit respectively. This file can be imported; by an OpenCL driver that support SPIR-V consumption or it can be compiled; further by offline SPIR-V consumer tools. Converting to SPIR-V produced with the optimization levels other than `-O0` is; currently available as an experimental feature and it is not guaranteed to work; in all cases. Clang also supports integrated generation of SPIR-V without use of ``llvm-spirv``; tool as an experimental feature when ``-fintegrated-objemitter`` flag is passed in; the command line. .. code-block:: console. $ clang --target=spirv32 -fintegrated-objemitter -c test.cl. Note that only very basic functionality is supported at this point and therefore; it is not suitable for arbitrary use cases. This feature is only enabled when clang; build is configured with ``-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=SPIRV`` option. Linking is done,MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:166838,Testability,test,test,166838,uctions; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator#build-instructions>`_; for more details. Clang will expect the ``llvm-spirv`` executable to; be present in the ``PATH`` environment variable. Clang uses ``llvm-spirv``; with `the widely adopted assembly syntax package; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator/#build-with-spirv-tools>`_. `The versioning; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator/releases>`_ of; ``llvm-spirv`` is aligned with Clang major releases. The same applies to the; main development branch. It is therefore important to ensure the ``llvm-spirv``; version is in alignment with the Clang version. For troubleshooting purposes; ``llvm-spirv`` can be `tested in isolation; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator#test-instructions>`_. Example usage for OpenCL kernel compilation:. .. code-block:: console. $ clang --target=spirv32 -c test.cl; $ clang --target=spirv64 -c test.cl. Both invocations of Clang will result in the generation of a SPIR-V binary file; `test.o` for 32 bit and 64 bit respectively. This file can be imported; by an OpenCL driver that support SPIR-V consumption or it can be compiled; further by offline SPIR-V consumer tools. Converting to SPIR-V produced with the optimization levels other than `-O0` is; currently available as an experimental feature and it is not guaranteed to work; in all cases. Clang also supports integrated generation of SPIR-V without use of ``llvm-spirv``; tool as an experimental feature when ``-fintegrated-objemitter`` flag is passed in; the command line. .. code-block:: console. $ clang --target=spirv32 -fintegrated-objemitter -c test.cl. Note that only very basic functionality is supported at this point and therefore; it is not suitable for arbitrary use cases. This feature is only enabled when clang; build is configured with ``-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=SPIRV`` option. Linking is done using ``spirv-link`` from `the SPIRV-Tools project; <https://git,MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:167463,Testability,test,test,167463,"h the Clang version. For troubleshooting purposes; ``llvm-spirv`` can be `tested in isolation; <https://github.com/KhronosGroup/SPIRV-LLVM-Translator#test-instructions>`_. Example usage for OpenCL kernel compilation:. .. code-block:: console. $ clang --target=spirv32 -c test.cl; $ clang --target=spirv64 -c test.cl. Both invocations of Clang will result in the generation of a SPIR-V binary file; `test.o` for 32 bit and 64 bit respectively. This file can be imported; by an OpenCL driver that support SPIR-V consumption or it can be compiled; further by offline SPIR-V consumer tools. Converting to SPIR-V produced with the optimization levels other than `-O0` is; currently available as an experimental feature and it is not guaranteed to work; in all cases. Clang also supports integrated generation of SPIR-V without use of ``llvm-spirv``; tool as an experimental feature when ``-fintegrated-objemitter`` flag is passed in; the command line. .. code-block:: console. $ clang --target=spirv32 -fintegrated-objemitter -c test.cl. Note that only very basic functionality is supported at this point and therefore; it is not suitable for arbitrary use cases. This feature is only enabled when clang; build is configured with ``-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=SPIRV`` option. Linking is done using ``spirv-link`` from `the SPIRV-Tools project; <https://github.com/KhronosGroup/SPIRV-Tools#linker>`_. Similar to other external; linkers, Clang will expect ``spirv-link`` to be installed separately and to be; present in the ``PATH`` environment variable. Please refer to `the build and; installation instructions; <https://github.com/KhronosGroup/SPIRV-Tools#build>`_. .. code-block:: console. $ clang --target=spirv64 test1.cl test2.cl. More information about the SPIR-V target settings and supported versions of SPIR-V; format can be found in `the SPIR-V target guide; <https://llvm.org/docs/SPIRVUsage.html>`__. .. _clang-cl:. clang-cl; ========. clang-cl is an alternative command-line interfac",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:182557,Testability,test,testing,182557," var); -fprofile-instr-generate=<file_name_pattern>; Generate instrumented code to collect execution counts into the file whose name pattern is specified as the argument; (overridden by LLVM_PROFILE_FILE env var); -fprofile-instr-generate; Generate instrumented code to collect execution counts into default.profraw file; (overridden by '=' form of option or LLVM_PROFILE_FILE env var); -fprofile-instr-use=<value>; Use instrumentation data for coverage testing or profile-guided optimization; -fprofile-use=<value>; Use instrumentation data for profile-guided optimization; -fprofile-remapping-file=<file>; Use the remappings described in <file> to match the profile data against names in the program; -fprofile-list=<file>; Filename defining the list of functions/files to instrument; -fsanitize-address-field-padding=<value>; Level of field padding for AddressSanitizer; -fsanitize-address-globals-dead-stripping; Enable linker dead stripping of globals in AddressSanitizer; -fsanitize-address-poison-custom-array-cookie; Enable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fsanitize-address-use-after-return=<mode>; Select the mode of detecting stack use-after-return in AddressSanitizer: never | runtime (default) | always; -fsanitize-address-use-after-scope; Enable use-after-scope detection in AddressSanitizer; -fsanitize-address-use-odr-indicator; Enable ODR indicator globals to avoid false ODR violation reports in partially sanitized programs at the cost of an increase in binary size; -fsanitize-ignorelist=<value>; Path to ignorelist file for sanitizers; -fsanitize-cfi-cross-dso; Enable control flow integrity (CFI) checks for cross-DSO calls.; -fsanitize-cfi-icall-generalize-pointers; Generalize pointers in CFI indirect call type signature checks; -fsanitize-coverage=<value>; Specify the type of coverage instrumentation for Sanitizers; -fsanitize-hwaddress-abi=<value>; Select the HWAddressSanitizer ABI to target (interceptor or platform, defaul",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:8625,Usability,simpl,simple,8625,"-tokens]</span></b>; #endif bad; <span style=""color:green"">^</span>; <span style=""color:green"">//</span>; </pre>. When this is disabled, Clang will just print:. ::. test.c:2:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. If the ``NO_COLOR`` environment variable is defined and not empty; (regardless of value), color diagnostics are disabled. If ``NO_COLOR`` is; defined and ``-fcolor-diagnostics`` is passed on the command line, Clang; will honor the command line argument. .. option:: -fansi-escape-codes. Controls whether ANSI escape codes are used instead of the Windows Console; API to output colored diagnostics. This option is only used on Windows and; defaults to off. .. option:: -fdiagnostics-format=clang/msvc/vi. Changes diagnostic output format to better match IDEs and command line tools. This option controls the output format of the filename, line number,; and column printed in diagnostic messages. The options, and their; affect on formatting a simple conversion diagnostic, follow:. **clang** (default); ::. t.c:3:11: warning: conversion specifies type 'char *' but the argument has type 'int'. **msvc**; ::. t.c(3,11) : warning: conversion specifies type 'char *' but the argument has type 'int'. **vi**; ::. t.c +3:11: warning: conversion specifies type 'char *' but the argument has type 'int'. .. _opt_fdiagnostics-show-option:. .. option:: -f[no-]diagnostics-show-option. Enable ``[-Woption]`` information in diagnostic line. This option, which defaults to on, controls whether or not Clang; prints the associated :ref:`warning group <cl_diag_warning_groups>`; option name when outputting a warning diagnostic. For example, in; this output:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. Passing **-fno-diagnostics-show-option** will prevent Clang from; printing the [:option:`-Wextra-tokens`] information in; the diagnostic. This information tells you the flag needed to enabl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:13985,Usability,guid,guided,13985,"cheme:. ``<base>-<arch>.opt.<format>``. Note that this is incompatible with passing the; :option:`-foptimization-record-file` option. .. option:: -foptimization-record-file. Control the file to which optimization reports are written. This implies; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>`. On Darwin platforms, this is incompatible with passing multiple; ``-arch <arch>`` options. .. option:: -foptimization-record-passes. Only include passes which match a specified regular expression. When optimization reports are being output (see; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>`), this; option controls the passes that will be included in the final report. If this option is not used, all the passes are included in the optimization; record. .. _opt_fdiagnostics-show-hotness:. .. option:: -f[no-]diagnostics-show-hotness. Enable profile hotness information in diagnostic line. This option controls whether Clang prints the profile hotness associated; with diagnostics in the presence of profile-guided optimization information.; This is currently supported with optimization remarks (see; :ref:`Options to Emit Optimization Reports <rpass>`). The hotness information; allows users to focus on the hot optimization remarks that are likely to be; more relevant for run-time performance. For example, in this output, the block containing the callsite of `foo` was; executed 3000 times according to the profile data:. ::. s.c:7:10: remark: foo inlined into bar (hotness: 3000) [-Rpass-analysis=inline]; sum += foo(x, x - 2);; ^. This option is implied when; :ref:`-fsave-optimization-record <opt_fsave-optimization-record>` is used.; Otherwise, it defaults to off. .. option:: -fdiagnostics-hotness-threshold. Prevent optimization remarks from being output if they do not have at least; this hotness value. This option, which defaults to zero, controls the minimum hotness an; optimization remark would need in order to be output by Clang. This is; current",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:16143,Usability,simpl,simple,16143,"iagnostics-fixit-info:. .. option:: -f[no-]diagnostics-fixit-info. Enable ""FixIt"" information in the diagnostics output. This option, which defaults to on, controls whether or not Clang; prints the information on how to fix a specific diagnostic; underneath it when it knows. For example, in this output:. ::. test.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^; //. Passing **-fno-diagnostics-fixit-info** will prevent Clang from; printing the ""//"" line at the end of the message. This information; is useful for users who may not understand what is wrong, but can be; confusing for machine parsing. .. _opt_fdiagnostics-print-source-range-info:. .. option:: -fdiagnostics-print-source-range-info. Print machine parsable information about source ranges.; This option makes Clang print information about source ranges in a machine; parsable format after the file/line/column number information. The; information is a simple sequence of brace enclosed ranges, where each range; lists the start and end line/column locations. For example, in this output:. ::. exprs.c:47:15:{47:8-47:14}{47:17-47:24}: error: invalid operands to binary expression ('int *' and '_Complex float'); P = (P-42) + Gamma*4;; ~~~~~~ ^ ~~~~~~~. The {}'s are generated by -fdiagnostics-print-source-range-info. The printed column numbers count bytes from the beginning of the; line; take care if your source contains multibyte characters. .. option:: -fdiagnostics-parseable-fixits. Print Fix-Its in a machine parseable form. This option makes Clang print available Fix-Its in a machine; parseable format at the end of diagnostics. The following example; illustrates the format:. ::. fix-it:""t.cpp"":{7:25-7:29}:""Gamma"". The range printed is a half-open range, so in this example the; characters at column 25 up to but not including column 29 on line 7; in t.cpp should be replaced with the string ""Gamma"". Either the; range or the replacement string may be empty (representing strict; ins",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:20986,Usability,usab,usable,20986,"t.c:28:8: warning: extra tokens at end of #endif directive [-Wextra-tokens]; #endif bad; ^. These extra tokens are not strictly conforming, and are usually best; handled by commenting them out. .. option:: -Wambiguous-member-template. Warn about unqualified uses of a member template whose name resolves to; another template at the location of the use. This option, which defaults to on, enables a warning in the; following code:. ::. template<typename T> struct set{};; template<typename T> struct trait { typedef const T& type; };; struct Value {; template<typename T> void set(typename trait<T>::type value) {}; };; void foo() {; Value v;; v.set<double>(3.2);; }. C++ [basic.lookup.classref] requires this to be an error, but,; because it's hard to work around, Clang downgrades it to a warning; as an extension. .. option:: -Wbind-to-temporary-copy. Warn about an unusable copy constructor when binding a reference to a; temporary. This option enables warnings about binding a; reference to a temporary when the temporary doesn't have a usable; copy constructor. For example:. ::. struct NonCopyable {; NonCopyable();; private:; NonCopyable(const NonCopyable&);; };; void foo(const NonCopyable&);; void bar() {; foo(NonCopyable()); // Disallowed in C++98; allowed in C++11.; }. ::. struct NonCopyable2 {; NonCopyable2();; NonCopyable2(NonCopyable2&);; };; void foo(const NonCopyable2&);; void bar() {; foo(NonCopyable2()); // Disallowed in C++98; allowed in C++11.; }. Note that if ``NonCopyable2::NonCopyable2()`` has a default argument; whose instantiation produces a compile error, that error will still; be a hard error in C++98 mode even if this warning is turned off. Options to Control Clang Crash Diagnostics; ------------------------------------------. As unbelievable as it may sound, Clang does crash from time to time.; Generally, this only occurs to those living on the `bleeding; edge <https://llvm.org/releases/download.html#svn>`_. Clang goes to great; lengths to assist you in fil",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:25251,Usability,guid,guided,25251,"re dozens of passes inside the compiler, each of these flags; take a regular expression that identifies the name of the pass which should; emit the associated diagnostic. For example, to get a report from the inliner,; compile the code with:. .. code-block:: console. $ clang -O2 -Rpass=inline code.cc -o code; code.cc:4:25: remark: foo inlined into bar [-Rpass=inline]; int bar(int j) { return foo(j, j - 2); }; ^. Note that remarks from the inliner are identified with `[-Rpass=inline]`.; To request a report from every optimization pass, you should use; `-Rpass=.*` (in fact, you can use any valid POSIX regular; expression). However, do not expect a report from every transformation; made by the compiler. Optimization remarks do not really make sense; outside of the major transformations (e.g., inlining, vectorization,; loop optimizations) and not every optimization pass supports this; feature. Note that when using profile-guided optimization information, profile hotness; information can be included in the remarks (see; :ref:`-fdiagnostics-show-hotness <opt_fdiagnostics-show-hotness>`). Current limitations; ^^^^^^^^^^^^^^^^^^^. 1. Optimization remarks that refer to function names will display the; mangled name of the function. Since these remarks are emitted by the; back end of the compiler, it does not know anything about the input; language, nor its mangling rules. 2. Some source locations are not displayed correctly. The front end has; a more detailed source location tracking than the locations included; in the debug info (e.g., the front end can locate code inside macro; expansions). However, the locations used by `-Rpass` are; translated from debug annotations. That translation can be lossy,; which results in some remarks having no location information. Options to Emit Resource Consumption Reports; --------------------------------------------. These are options that report execution time and consumed memory of different; compilations steps. .. option:: -fproc-stat-r",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:27674,Usability,clear,cleared,27674," report; is sent to. If it specifies a regular file, the data are saved to this file in; CSV format:. .. code-block:: console. $ clang -fproc-stat-report=abc foo.c; $ cat abc; clang-11,""/tmp/foo-123456.o"",92000,84000,87536; ld,""a.out"",900,8000,53568. The data on each row represent:. * file name of the tool executable,; * output file name in quotes,; * total execution time in microseconds,; * execution time in user mode in microseconds,; * peak memory usage in Kb. It is possible to specify this option without any value. In this case statistics; are printed on standard output in human readable format:. .. code-block:: console. $ clang -fproc-stat-report foo.c; clang-11: output=/tmp/foo-855a8e.o, total=68.000 ms, user=60.000 ms, mem=86920 Kb; ld: output=a.out, total=8.000 ms, user=4.000 ms, mem=52320 Kb. The report file specified in the option is locked for write, so this option; can be used to collect statistics in parallel builds. The report file is not; cleared, new data is appended to it, thus making possible to accumulate build; statistics. You can also use environment variables to control the process statistics reporting.; Setting ``CC_PRINT_PROC_STAT`` to ``1`` enables the feature, the report goes to; stdout in human readable format.; Setting ``CC_PRINT_PROC_STAT_FILE`` to a fully qualified file path makes it report; process statistics to the given file in the CSV format. Specifying a relative; path will likely lead to multiple files with the same name created in different; directories, since the path is relative to a changing working directory. These environment variables are handy when you need to request the statistics; report without changing your build scripts or alter the existing set of compiler; options. Note that ``-fproc-stat-report`` take precedence over ``CC_PRINT_PROC_STAT``; and ``CC_PRINT_PROC_STAT_FILE``. .. code-block:: console. $ export CC_PRINT_PROC_STAT=1; $ export CC_PRINT_PROC_STAT_FILE=~/project-build-proc-stat.csv; $ make. Other Options; -",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:69727,Usability,simpl,simply,69727,"aive mathematical formulas for complex; multiplication and enables application of Smith's algorithm for complex; division. See SMITH, R. L. Algorithm 116: Complex division. Commun.; ACM 5, 8 (1962). The default is ``-fno-cx-fortran-rules``. .. _floating-point-environment:. Accessing the floating point environment; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^; Many targets allow floating point operations to be configured to control things; such as how inexact results should be rounded and how exceptional conditions; should be handled. This configuration is called the floating point environment.; C and C++ restrict access to the floating point environment by default, and the; compiler is allowed to assume that all operations are performed in the default; environment. When code is compiled in this default mode, operations that depend; on the environment (such as floating-point arithmetic and `FLT_ROUNDS`) may have; undefined behavior if the dynamic environment is not the default environment; for; example, `FLT_ROUNDS` may or may not simply return its default value for the target; instead of reading the dynamic environment, and floating-point operations may be; optimized as if the dynamic environment were the default. Similarly, it is undefined; behavior to change the floating point environment in this default mode, for example; by calling the `fesetround` function.; C provides two pragmas to allow code to dynamically modify the floating point environment:. - ``#pragma STDC FENV_ACCESS ON`` allows dynamic changes to the entire floating; point environment. - ``#pragma STDC FENV_ROUND FE_DYNAMIC`` allows dynamic changes to just the floating; point rounding mode. This may be more optimizable than ``FENV_ACCESS ON`` because; the compiler can still ignore the possibility of floating-point exceptions by default. Both of these can be used either at the start of a block scope, in which case; they cover all code in that scope (unless they're turned off in a child scope),; or at the ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:78775,Usability,simpl,simple,78775,". .. option:: -f[no-]sanitize-trap[=all]. Controls which checks enabled by the ``-fsanitize=`` flag trap. This; option is intended for use in cases where the sanitizer runtime cannot; be used (for instance, when building libc or a kernel module), or where; the binary size increase caused by the sanitizer runtime is a concern. This flag is only compatible with :doc:`control flow integrity; <ControlFlowIntegrity>` schemes and :doc:`UndefinedBehaviorSanitizer`; checks other than ``vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sanitizers.; See :doc:`SanitizerCoverage` for more details. .. option:: -f[no-]sanitize-address-outline-instrumentation. Controls how address sanitizer code is generated. If enabled will always use; a function call instead of inlining the code. Turning this option on could; reduce the binary size, but might result in a worse run-time performance. See :doc: `AddressSanitizer` for more details. .. option:: -f[no-]sanitize-stats. Enable simple statistics gathering for the enabled sanitizers.; See :doc:`SanitizerStats` for more details. .. option:: -fsanitize-undefined-trap-on-error. Deprecated alias for ``-fsanitize-trap=undefined``. .. option:: -fsanitize-cfi-cross-dso. Enable cross-DSO control flow integrity checks. This flag modifies; the behavior of sanitizers in the ``cfi`` group to allow checking; of cross-DSO virtual and indirect calls. .. option:: -fsanitize-cfi-icall-generalize-pointers. Generalize pointers in return and argument types in function type signatu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:79257,Usability,simpl,simple,79257,"`vptr``. This flag is enabled by default for sanitizers in the ``cfi`` group. .. option:: -fsanitize-ignorelist=/path/to/ignorelist/file. Disable or modify sanitizer checks for objects (source files, functions,; variables, types) listed in the file. See; :doc:`SanitizerSpecialCaseList` for file format description. .. option:: -fno-sanitize-ignorelist. Don't use ignorelist file, if it was specified earlier in the command line. .. option:: -f[no-]sanitize-coverage=[type,features,...]. Enable simple code coverage in addition to certain sanitizers.; See :doc:`SanitizerCoverage` for more details. .. option:: -f[no-]sanitize-address-outline-instrumentation. Controls how address sanitizer code is generated. If enabled will always use; a function call instead of inlining the code. Turning this option on could; reduce the binary size, but might result in a worse run-time performance. See :doc: `AddressSanitizer` for more details. .. option:: -f[no-]sanitize-stats. Enable simple statistics gathering for the enabled sanitizers.; See :doc:`SanitizerStats` for more details. .. option:: -fsanitize-undefined-trap-on-error. Deprecated alias for ``-fsanitize-trap=undefined``. .. option:: -fsanitize-cfi-cross-dso. Enable cross-DSO control flow integrity checks. This flag modifies; the behavior of sanitizers in the ``cfi`` group to allow checking; of cross-DSO virtual and indirect calls. .. option:: -fsanitize-cfi-icall-generalize-pointers. Generalize pointers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more details. .. option:: -fsanitize-cfi-icall-experimental-normalize-integers. Normalize integers in return and argument types in function type signatures; checked by Control Flow Integrity indirect call checking. See; :doc:`ControlFlowIntegrity` for more details. This option is currently experimental. .. option:: -fstrict-vtable-pointers. Enable optimizations based on the stric",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:82722,Usability,simpl,simplification,82722,". .. option:: -fforce-emit-vtables. In order to improve devirtualization, forces emitting of vtables even in; modules where it isn't necessary. It causes more inline virtual functions; to be emitted. .. option:: -fno-assume-sane-operator-new. Don't assume that the C++'s new operator is sane. This option tells the compiler to do not assume that C++'s global; new operator will always return a pointer that does not alias any; other pointer when the function returns. .. option:: -fassume-nothrow-exception-dtor. Assume that an exception object' destructor will not throw, and generate; less code for catch handlers. A throw expression of a type with a; potentially-throwing destructor will lead to an error. By default, Clang assumes that the exception object may have a throwing; destructor. For the Itanium C++ ABI, Clang generates a landing pad to; destroy local variables and call ``_Unwind_Resume`` for the code; ``catch (...) { ... }``. This option tells Clang that an exception object's; destructor will not throw and code simplification is possible. .. option:: -ftrap-function=[name]. Instruct code generator to emit a function call to the specified; function name for ``__builtin_trap()``. LLVM code generator translates ``__builtin_trap()`` to a trap; instruction if it is supported by the target ISA. Otherwise, the; builtin is translated into a call to ``abort``. If this option is; set, then the code generator will always lower the builtin to a call; to the specified function regardless of whether the target ISA has a; trap instruction. This option is useful for environments (e.g.; deeply embedded) where a trap cannot be properly handled, or when; some custom behavior is desired. .. option:: -ftls-model=[model]. Select which TLS model to use. Valid values are: ``global-dynamic``, ``local-dynamic``,; ``initial-exec`` and ``local-exec``. The default value is; ``global-dynamic``. The compiler may use a different model if the; selected model is not supported by the target, or if",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:89978,Usability,guid,guided,89978,"in a; unique section. It will also place all basic blocks of functions ``bar``; in unique sections. Further, section clusters can also be specified using the ``list=<arg>``; option. For example, ``list=spec.txt`` where ``spec.txt`` contains:. ::. !foo; !!1 !!3 !!5; !!2 !!4 !!6. will create two unique sections for function ``foo`` with the first; containing the odd numbered basic blocks and the second containing the; even numbered basic blocks. Basic block sections allow the linker to reorder basic blocks and enables; link-time optimizations like whole program inter-procedural basic block; reordering. Profile Guided Optimization; ---------------------------. Profile information enables better optimization. For example, knowing that a; branch is taken very frequently helps the compiler make better decisions when; ordering basic blocks. Knowing that a function ``foo`` is called more; frequently than another function ``bar`` helps the inliner. Optimization; levels ``-O2`` and above are recommended for use of profile guided optimization. Clang supports profile guided optimization with two different kinds of; profiling. A sampling profiler can generate a profile with very low runtime; overhead, or you can build an instrumented version of the code that collects; more detailed profile information. Both kinds of profiles can provide execution; counts for instructions in the code and information on branches taken and; function invocation. Regardless of which kind of profiling you use, be careful to collect profiles; by running your code with inputs that are representative of the typical; behavior. Code that is not exercised in the profile will be optimized as if it; is unimportant, and the compiler may make poor optimization choices for code; that is disproportionately used while profiling. Differences Between Sampling and Instrumentation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Although both techniques are used for similar purposes, there are important; differences ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:90022,Usability,guid,guided,90022," sections. Further, section clusters can also be specified using the ``list=<arg>``; option. For example, ``list=spec.txt`` where ``spec.txt`` contains:. ::. !foo; !!1 !!3 !!5; !!2 !!4 !!6. will create two unique sections for function ``foo`` with the first; containing the odd numbered basic blocks and the second containing the; even numbered basic blocks. Basic block sections allow the linker to reorder basic blocks and enables; link-time optimizations like whole program inter-procedural basic block; reordering. Profile Guided Optimization; ---------------------------. Profile information enables better optimization. For example, knowing that a; branch is taken very frequently helps the compiler make better decisions when; ordering basic blocks. Knowing that a function ``foo`` is called more; frequently than another function ``bar`` helps the inliner. Optimization; levels ``-O2`` and above are recommended for use of profile guided optimization. Clang supports profile guided optimization with two different kinds of; profiling. A sampling profiler can generate a profile with very low runtime; overhead, or you can build an instrumented version of the code that collects; more detailed profile information. Both kinds of profiles can provide execution; counts for instructions in the code and information on branches taken and; function invocation. Regardless of which kind of profiling you use, be careful to collect profiles; by running your code with inputs that are representative of the typical; behavior. Code that is not exercised in the profile will be optimized as if it; is unimportant, and the compiler may make poor optimization choices for code; that is disproportionately used while profiling. Differences Between Sampling and Instrumentation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. Although both techniques are used for similar purposes, there are important; differences between the two:. 1. Profile data generated with one cannot be used by the other, and the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:103362,Usability,guid,guided,103362," results than a; sampling profiler. It also provides reproducible results, at least to the; extent that the code behaves consistently across runs. Clang supports two types of instrumentation: frontend-based and IR-based.; Frontend-based instrumentation can be enabled with the option ``-fprofile-instr-generate``,; and IR-based instrumentation can be enabled with the option ``-fprofile-generate``.; For best performance with PGO, IR-based instrumentation should be used. It has; the benefits of lower instrumentation overhead, smaller raw profile size, and; better runtime performance. Frontend-based instrumentation, on the other hand,; has better source correlation, so it should be used with source line-based; coverage testing. The flag ``-fcs-profile-generate`` also instruments programs using the same; instrumentation method as ``-fprofile-generate``. However, it performs a; post-inline late instrumentation and can produce context-sensitive profiles. Here are the steps for using profile guided optimization with; instrumentation:. 1. Build an instrumented version of the code by compiling and linking with the; ``-fprofile-generate`` or ``-fprofile-instr-generate`` option. .. code-block:: console. $ clang++ -O2 -fprofile-instr-generate code.cc -o code. 2. Run the instrumented executable with inputs that reflect the typical usage.; By default, the profile data will be written to a ``default.profraw`` file; in the current directory. You can override that default by using option; ``-fprofile-instr-generate=`` or by setting the ``LLVM_PROFILE_FILE``; environment variable to specify an alternate file. If non-default file name; is specified by both the environment variable and the command line option,; the environment variable takes precedence. The file name pattern specified; can include different modifiers: ``%p``, ``%h``, ``%m``, ``%t``, and ``%c``. Any instance of ``%p`` in that file name will be replaced by the process; ID, so that you can easily distinguish the profile outp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:108435,Usability,simpl,simply,108435,"efault_%m.profraw`` in the directory named ``dirname`` if specified.; If ``dirname`` does not exist, it will be created at runtime. ``%m`` specifier; will be substituted with a unique id documented in step 2 above. In other words,; with ``-fprofile-generate[=<dirname>]`` option, the ""raw"" profile data automatic; merging is turned on by default, so there will no longer any risk of profile; clobbering from different running processes. For example,. .. code-block:: console. $ clang++ -O2 -fprofile-generate=yyy/zzz code.cc -o code. When ``code`` is executed, the profile will be written to the file; ``yyy/zzz/default_xxxx.profraw``. To generate the profile data file with the compiler readable format, the; ``llvm-profdata`` tool can be used with the profile directory as the input:. .. code-block:: console. $ llvm-profdata merge -output=code.profdata yyy/zzz/. If the user wants to turn off the auto-merging feature, or simply override the; the profile dumping path specified at command line, the environment variable; ``LLVM_PROFILE_FILE`` can still be used to override; the directory and filename for the profile file at runtime.; To override the path and filename at compile time, use; ``-Xclang -fprofile-instrument-path=/path/to/file_pattern.profraw``. .. option:: -fcs-profile-generate[=<dirname>]. The ``-fcs-profile-generate`` and ``-fcs-profile-generate=`` flags will use; the same instrumentation method, and generate the same profile as in the; ``-fprofile-generate`` and ``-fprofile-generate=`` flags. The difference is; that the instrumentation is performed after inlining so that the resulted; profile has a better context sensitive information. They cannot be used; together with ``-fprofile-generate`` and ``-fprofile-generate=`` flags.; They are typically used in conjunction with ``-fprofile-use`` flag.; The profile generated by ``-fcs-profile-generate`` and ``-fprofile-generate``; can be merged by llvm-profdata. A use example:. .. code-block:: console. $ clang++ -O2 -fprofi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:135442,Usability,guid,guidelines,135442,"tin_va_arg_pack``/``__builtin_va_arg_pack_len``. This is; used rarely, but in some potentially interesting places, like the; glibc headers, so it may be implemented pending user demand. Note; that because clang pretends to be like GCC 4.2, and this extension; was introduced in 4.3, the glibc headers will not try to use this; extension with clang at the moment.; - clang does not support the gcc extension for forward-declaring; function parameters; this has not shown up in any real-world code; yet, though, so it might never be implemented. This is not a complete list; if you find an unsupported extension; missing from this list, please send an e-mail to cfe-dev. This list; currently excludes C++; see :ref:`C++ Language Features <cxx>`. Also, this; list does not include bugs in mostly-implemented features; please see; the `bug; tracker <https://bugs.llvm.org/buglist.cgi?quicksearch=product%3Aclang+component%3A-New%2BBugs%2CAST%2CBasic%2CDriver%2CHeaders%2CLLVM%2BCodeGen%2Cparser%2Cpreprocessor%2CSemantic%2BAnalyzer>`_; for known existing bugs (FIXME: Is there a section for bug-reporting; guidelines somewhere?). Intentionally unsupported GCC extensions; ----------------------------------------. - clang does not support the gcc extension that allows variable-length; arrays in structures. This is for a few reasons: one, it is tricky to; implement, two, the extension is completely undocumented, and three,; the extension appears to be rarely used. Note that clang *does*; support flexible array members (arrays with a zero or unspecified; size at the end of a structure).; - GCC accepts many expression forms that are not valid integer constant; expressions in bit-field widths, enumerator constants, case labels,; and in array bounds at global scope. Clang also accepts additional; expression forms in these contexts, but constructs that GCC accepts due to; simplifications GCC performs while parsing, such as ``x - x`` (where ``x`` is a; variable) will likely never be accepted by Cl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:135737,Usability,undo,undocumented,135737,"pport the gcc extension for forward-declaring; function parameters; this has not shown up in any real-world code; yet, though, so it might never be implemented. This is not a complete list; if you find an unsupported extension; missing from this list, please send an e-mail to cfe-dev. This list; currently excludes C++; see :ref:`C++ Language Features <cxx>`. Also, this; list does not include bugs in mostly-implemented features; please see; the `bug; tracker <https://bugs.llvm.org/buglist.cgi?quicksearch=product%3Aclang+component%3A-New%2BBugs%2CAST%2CBasic%2CDriver%2CHeaders%2CLLVM%2BCodeGen%2Cparser%2Cpreprocessor%2CSemantic%2BAnalyzer>`_; for known existing bugs (FIXME: Is there a section for bug-reporting; guidelines somewhere?). Intentionally unsupported GCC extensions; ----------------------------------------. - clang does not support the gcc extension that allows variable-length; arrays in structures. This is for a few reasons: one, it is tricky to; implement, two, the extension is completely undocumented, and three,; the extension appears to be rarely used. Note that clang *does*; support flexible array members (arrays with a zero or unspecified; size at the end of a structure).; - GCC accepts many expression forms that are not valid integer constant; expressions in bit-field widths, enumerator constants, case labels,; and in array bounds at global scope. Clang also accepts additional; expression forms in these contexts, but constructs that GCC accepts due to; simplifications GCC performs while parsing, such as ``x - x`` (where ``x`` is a; variable) will likely never be accepted by Clang.; - clang does not support ``__builtin_apply`` and friends; this extension; is extremely obscure and difficult to implement reliably. .. _c_ms:. Microsoft extensions; --------------------. clang has support for many extensions from Microsoft Visual C++. To enable these; extensions, use the ``-fms-extensions`` command-line option. This is the default; for Windows targets. Clan",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:136215,Usability,simpl,simplifications,136215,"earch=product%3Aclang+component%3A-New%2BBugs%2CAST%2CBasic%2CDriver%2CHeaders%2CLLVM%2BCodeGen%2Cparser%2Cpreprocessor%2CSemantic%2BAnalyzer>`_; for known existing bugs (FIXME: Is there a section for bug-reporting; guidelines somewhere?). Intentionally unsupported GCC extensions; ----------------------------------------. - clang does not support the gcc extension that allows variable-length; arrays in structures. This is for a few reasons: one, it is tricky to; implement, two, the extension is completely undocumented, and three,; the extension appears to be rarely used. Note that clang *does*; support flexible array members (arrays with a zero or unspecified; size at the end of a structure).; - GCC accepts many expression forms that are not valid integer constant; expressions in bit-field widths, enumerator constants, case labels,; and in array bounds at global scope. Clang also accepts additional; expression forms in these contexts, but constructs that GCC accepts due to; simplifications GCC performs while parsing, such as ``x - x`` (where ``x`` is a; variable) will likely never be accepted by Clang.; - clang does not support ``__builtin_apply`` and friends; this extension; is extremely obscure and difficult to implement reliably. .. _c_ms:. Microsoft extensions; --------------------. clang has support for many extensions from Microsoft Visual C++. To enable these; extensions, use the ``-fms-extensions`` command-line option. This is the default; for Windows targets. Clang does not implement every pragma or declspec provided; by MSVC, but the popular ones, such as ``__declspec(dllexport)`` and ``#pragma; comment(lib)`` are well supported. clang has a ``-fms-compatibility`` flag that makes clang accept enough; invalid C++ to be able to parse most Microsoft headers. For example, it; allows `unqualified lookup of dependent base class members; <https://clang.llvm.org/compatibility.html#dep_lookup_bases>`_, which is; a common compatibility issue with clang. This flag is",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:160199,Usability,clear,clear,160199,"an add a ``-mno-evex512`` in the command line with AVX512 options if; they want to run the binary on both legacy AVX512 and new AVX10/256 capable; processors. The option has the same constraints as ``-mavx10.N``, i.e.,; cannot call to 512-bit X86 specific intrinsics and pass or return 512-bit vector; types in function call. Users should avoid using AVX512 features in function target attributes when; developing code for AVX10. If they have to do so, they need to add an explicit; ``evex512`` or ``no-evex512`` together with AVX512 features for 512-bit or; non-512-bit functions respectively to avoid unexpected code generation. Both; command line option and target attribute of EVEX512 feature can only be used; with AVX512. They don't affect vector size of AVX10. User should not mix the use AVX10 and AVX512 options together at any time,; because the option combinations are conflicting sometimes. For example, a; combination of ``-mavx512f -mavx10.1-256`` doesn't show a clear intention to; compiler, since instructions in AVX512F and AVX10.1/256 intersect but do not; overlap. In this case, compiler will emit warning for it, but the behavior; is determined. It will generate the same code as option ``-mavx10.1-512``.; A similar case is ``-mavx512f -mavx10.2-256``, which equals to; ``-mavx10.1-512 -mavx10.2-256``, because ``avx10.2-256`` implies ``avx10.1-256``; and ``-mavx512f -mavx10.1-256`` equals to ``-mavx10.1-512``. There are some new macros introduced with AVX10 support. ``-mavx10.1-256`` will; enable ``__AVX10_1__`` and ``__EVEX256__``, while ``-mavx10.1-512`` enables; ``__AVX10_1__``, ``__EVEX256__``, ``__EVEX512__`` and ``__AVX10_1_512__``.; Besides, both ``-mavx10.1-256`` and ``-mavx10.1-512`` will enable all AVX512; feature specific macros. A AVX512 feature will enable both ``__EVEX256__``,; ``__EVEX512__`` and its own macro. So ``__EVEX512__`` can be used to guard code; that can run on both legacy AVX512 and AVX10/512 capable processors but cannot; run on AVX10/256,",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:162673,Usability,simpl,simple,162673,"ports a; limited number of ARM architectures. It does not yet fully support; ARMv5, for example. PowerPC; ^^^^^^^. The support for PowerPC (especially PowerPC64) is considered stable; on Linux and FreeBSD: it has been tested to correctly compile many; large C and C++ codebases. PowerPC (32bit) is still missing certain; features (e.g. PIC code on ELF platforms). Other platforms; ^^^^^^^^^^^^^^^. clang currently contains some support for other architectures (e.g. Sparc);; however, significant pieces of code generation are still missing, and they; haven't undergone significant testing. clang contains limited support for the MSP430 embedded processor, but; both the clang support and the LLVM backend support are highly; experimental. Other platforms are completely unsupported at the moment. Adding the; minimal support needed for parsing and semantic analysis on a new; platform is quite easy; see ``lib/Basic/Targets.cpp`` in the clang source; tree. This level of support is also sufficient for conversion to LLVM IR; for simple programs. Proper support for conversion to LLVM IR requires; adding code to ``lib/CodeGen/CGCall.cpp`` at the moment; this is likely to; change soon, though. Generating assembly requires a suitable LLVM; backend. Operating System Features and Limitations; -----------------------------------------. Windows; ^^^^^^^. Clang has experimental support for targeting ""Cygming"" (Cygwin / MinGW); platforms. See also :ref:`Microsoft Extensions <c_ms>`. Cygwin; """""""""""". Clang works on Cygwin-1.7. MinGW32; """""""""""""". Clang works on some mingw32 distributions. Clang assumes directories as; below;. - ``C:/mingw/include``; - ``C:/mingw/lib``; - ``C:/mingw/lib/gcc/mingw32/4.[3-5].0/include/c++``. On MSYS, a few tests might fail. MinGW-w64; """""""""""""""""". For 32-bit (i686-w64-mingw32), and 64-bit (x86\_64-w64-mingw32), Clang; assumes as below;. - ``GCC versions 4.5.0 to 4.5.3, 4.6.0 to 4.6.2, or 4.7.0 (for the C++ header search path)``; - ``some_directory/bin/gcc.exe``; - ``s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:168305,Usability,guid,guide,168305," without use of ``llvm-spirv``; tool as an experimental feature when ``-fintegrated-objemitter`` flag is passed in; the command line. .. code-block:: console. $ clang --target=spirv32 -fintegrated-objemitter -c test.cl. Note that only very basic functionality is supported at this point and therefore; it is not suitable for arbitrary use cases. This feature is only enabled when clang; build is configured with ``-DLLVM_EXPERIMENTAL_TARGETS_TO_BUILD=SPIRV`` option. Linking is done using ``spirv-link`` from `the SPIRV-Tools project; <https://github.com/KhronosGroup/SPIRV-Tools#linker>`_. Similar to other external; linkers, Clang will expect ``spirv-link`` to be installed separately and to be; present in the ``PATH`` environment variable. Please refer to `the build and; installation instructions; <https://github.com/KhronosGroup/SPIRV-Tools#build>`_. .. code-block:: console. $ clang --target=spirv64 test1.cl test2.cl. More information about the SPIR-V target settings and supported versions of SPIR-V; format can be found in `the SPIR-V target guide; <https://llvm.org/docs/SPIRVUsage.html>`__. .. _clang-cl:. clang-cl; ========. clang-cl is an alternative command-line interface to Clang, designed for; compatibility with the Visual C++ compiler, cl.exe. To enable clang-cl to find system headers, libraries, and the linker when run; from the command-line, it should be executed inside a Visual Studio Native Tools; Command Prompt or a regular Command Prompt where the environment has been set; up using e.g. `vcvarsall.bat <https://msdn.microsoft.com/en-us/library/f2ccy3wt.aspx>`_. clang-cl can also be used from inside Visual Studio by selecting the LLVM; Platform Toolset. The toolset is not part of the installer, but may be installed; separately from the; `Visual Studio Marketplace <https://marketplace.visualstudio.com/items?itemName=LLVMExtensions.llvm-toolchain>`_.; To use the toolset, select a project in Solution Explorer, open its Property; Page (Alt+F7), and in the ""General""",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:182576,Usability,guid,guided,182576," var); -fprofile-instr-generate=<file_name_pattern>; Generate instrumented code to collect execution counts into the file whose name pattern is specified as the argument; (overridden by LLVM_PROFILE_FILE env var); -fprofile-instr-generate; Generate instrumented code to collect execution counts into default.profraw file; (overridden by '=' form of option or LLVM_PROFILE_FILE env var); -fprofile-instr-use=<value>; Use instrumentation data for coverage testing or profile-guided optimization; -fprofile-use=<value>; Use instrumentation data for profile-guided optimization; -fprofile-remapping-file=<file>; Use the remappings described in <file> to match the profile data against names in the program; -fprofile-list=<file>; Filename defining the list of functions/files to instrument; -fsanitize-address-field-padding=<value>; Level of field padding for AddressSanitizer; -fsanitize-address-globals-dead-stripping; Enable linker dead stripping of globals in AddressSanitizer; -fsanitize-address-poison-custom-array-cookie; Enable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fsanitize-address-use-after-return=<mode>; Select the mode of detecting stack use-after-return in AddressSanitizer: never | runtime (default) | always; -fsanitize-address-use-after-scope; Enable use-after-scope detection in AddressSanitizer; -fsanitize-address-use-odr-indicator; Enable ODR indicator globals to avoid false ODR violation reports in partially sanitized programs at the cost of an increase in binary size; -fsanitize-ignorelist=<value>; Path to ignorelist file for sanitizers; -fsanitize-cfi-cross-dso; Enable control flow integrity (CFI) checks for cross-DSO calls.; -fsanitize-cfi-icall-generalize-pointers; Generalize pointers in CFI indirect call type signature checks; -fsanitize-coverage=<value>; Specify the type of coverage instrumentation for Sanitizers; -fsanitize-hwaddress-abi=<value>; Select the HWAddressSanitizer ABI to target (interceptor or platform, defaul",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst:182657,Usability,guid,guided,182657," var); -fprofile-instr-generate=<file_name_pattern>; Generate instrumented code to collect execution counts into the file whose name pattern is specified as the argument; (overridden by LLVM_PROFILE_FILE env var); -fprofile-instr-generate; Generate instrumented code to collect execution counts into default.profraw file; (overridden by '=' form of option or LLVM_PROFILE_FILE env var); -fprofile-instr-use=<value>; Use instrumentation data for coverage testing or profile-guided optimization; -fprofile-use=<value>; Use instrumentation data for profile-guided optimization; -fprofile-remapping-file=<file>; Use the remappings described in <file> to match the profile data against names in the program; -fprofile-list=<file>; Filename defining the list of functions/files to instrument; -fsanitize-address-field-padding=<value>; Level of field padding for AddressSanitizer; -fsanitize-address-globals-dead-stripping; Enable linker dead stripping of globals in AddressSanitizer; -fsanitize-address-poison-custom-array-cookie; Enable poisoning array cookies when using custom operator new[] in AddressSanitizer; -fsanitize-address-use-after-return=<mode>; Select the mode of detecting stack use-after-return in AddressSanitizer: never | runtime (default) | always; -fsanitize-address-use-after-scope; Enable use-after-scope detection in AddressSanitizer; -fsanitize-address-use-odr-indicator; Enable ODR indicator globals to avoid false ODR violation reports in partially sanitized programs at the cost of an increase in binary size; -fsanitize-ignorelist=<value>; Path to ignorelist file for sanitizers; -fsanitize-cfi-cross-dso; Enable control flow integrity (CFI) checks for cross-DSO calls.; -fsanitize-cfi-icall-generalize-pointers; Generalize pointers in CFI indirect call type signature checks; -fsanitize-coverage=<value>; Specify the type of coverage instrumentation for Sanitizers; -fsanitize-hwaddress-abi=<value>; Select the HWAddressSanitizer ABI to target (interceptor or platform, defaul",MatchSource.DOCS,interpreter/llvm-project/clang/docs/UsersManual.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/UsersManual.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:271,Availability,error,errors,271,"==================; Available Checkers; ==================. The analyzer performs checks that are categorized into families or ""checkers"". The default set of checkers covers a variety of checks targeted at finding security and API usage bugs,; dead code, and other logic errors. See the :ref:`default-checkers` checkers list below. In addition to these, the analyzer contains a number of :ref:`alpha-checkers` (aka *alpha* checkers).; These checkers are under development and are switched off by default. They may crash or emit a higher number of false positives. The :ref:`debug-checkers` package contains checkers for analyzer developers for debugging purposes. .. contents:: Table of Contents; :depth: 4. .. _default-checkers:. Default Checkers; ----------------. .. _core-checkers:. core; ^^^^; Models core language features and contains general-purpose checkers such as division by zero,; null pointer dereference, usage of uninitialized values, etc.; *These checkers must be always switched on as other checker rely on them.*. .. _core-BitwiseShift:. core.BitwiseShift (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""". Finds undefined behavior caused by the bitwise left- and right-shift operator; operating on integer types. By default, this checker only reports situations when the right operand is; either negative or larger than the bit width of the type of the left operand;; these are logically unsound. Moreover, if the pedantic mode is activated by; ``-analyzer-config core.BitwiseShift:Pedantic=true``, then this checker also; reports situations where the _left_ operand of a shift operator is negative or; overflow occurs during the right shift of a signed value. (Most compilers; handle these predictably, but the C standard and the C++ standards before C++20; say that they're undefined behavior. In the C++20 standard these constructs are; well-defined, so activating pedantic mode in C++20 has no effect.). **Examples**. .. code-block:: cpp. static_assert(sizeof(int) == 4, ""assuming 32-bit in",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
