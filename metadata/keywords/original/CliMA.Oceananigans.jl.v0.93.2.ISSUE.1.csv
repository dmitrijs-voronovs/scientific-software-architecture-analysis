id,quality_attribute,keyword,matched_word,match_idx,sentence,source,author,repo,version,wiki,url
https://github.com/CliMA/Oceananigans.jl/pull/806:471,Testability,test,tests,471,"This PR generalizes `ConstantIsotropicDiffusivity` and `ConstantAnisotropicDiffusivity` to accept functions of `x, y, z, t` as well as constants. It also generalizes `AnisotropicDiffusivity` to allow different diffusivities in `x`, `y`, and `z`, rather than 'horizontal' and 'vertical'. It preserves backward compatibility by providing constructors, `ConstantIsotropicDiffusivity` and `ConstantAnisotropicDiffusivity` with the same syntax as previously. Todo:. - [x] add tests. Resolves #781 . cc @sandreza @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/806
https://github.com/CliMA/Oceananigans.jl/issues/808:40,Deployability,deploy,deploy,40,Seems like there is some issue with SSH deploy keys and travis can't deploy the docs to [OceananigansDocumentation](https://github.com/CliMA/OceananigansDocumentation). See:; https://travis-ci.com/github/CliMA/Oceananigans.jl/jobs/362580712#L1729,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/808
https://github.com/CliMA/Oceananigans.jl/issues/808:69,Deployability,deploy,deploy,69,Seems like there is some issue with SSH deploy keys and travis can't deploy the docs to [OceananigansDocumentation](https://github.com/CliMA/OceananigansDocumentation). See:; https://travis-ci.com/github/CliMA/Oceananigans.jl/jobs/362580712#L1729,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/808
https://github.com/CliMA/Oceananigans.jl/pull/810:38,Deployability,Release,Release,38,"We should merge this after PR #805. # Release notes. This release fixes a major bug where you couldn't run GPU models so if you're using GPUs you should upgrade to this version. **Oceananigans.jl now requires Julia 1.4+.**. Major changes:; * Updated the backend to use [KernelAbstractions.jl](https://github.com/JuliaGPU/KernelAbstractions.jl) instead of [GPUifyLoops.jl](https://github.com/vchuravy/GPUifyLoops.jl).; * Updated to using [CUDA.jl](https://github.com/JuliaGPU/CUDA.jl) instead of CuArrays.jl, CUDAnative.jl, and CUDAdrv.jl.; * Updated and slightly expanded the model setup documentation.; * Added a bibliography and citations to the documentation.; * Generalized `ConstantIsotropicDiffusivity` and `ConstantAnisotropicDiffusivity` to accept functions of `x, y, z, t` as well as constants. These types are called `IsotropicDiffusivity` and `AnisotropicDiffusivity`; `ConstantIsotropicDiffusivity` and `ConstantAnisotropicDiffusivity` aliases are provided for backwards compatibility.; * Lots of new convergence tests confirming the accuracy of the model!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/810
https://github.com/CliMA/Oceananigans.jl/pull/810:58,Deployability,release,release,58,"We should merge this after PR #805. # Release notes. This release fixes a major bug where you couldn't run GPU models so if you're using GPUs you should upgrade to this version. **Oceananigans.jl now requires Julia 1.4+.**. Major changes:; * Updated the backend to use [KernelAbstractions.jl](https://github.com/JuliaGPU/KernelAbstractions.jl) instead of [GPUifyLoops.jl](https://github.com/vchuravy/GPUifyLoops.jl).; * Updated to using [CUDA.jl](https://github.com/JuliaGPU/CUDA.jl) instead of CuArrays.jl, CUDAnative.jl, and CUDAdrv.jl.; * Updated and slightly expanded the model setup documentation.; * Added a bibliography and citations to the documentation.; * Generalized `ConstantIsotropicDiffusivity` and `ConstantAnisotropicDiffusivity` to accept functions of `x, y, z, t` as well as constants. These types are called `IsotropicDiffusivity` and `AnisotropicDiffusivity`; `ConstantIsotropicDiffusivity` and `ConstantAnisotropicDiffusivity` aliases are provided for backwards compatibility.; * Lots of new convergence tests confirming the accuracy of the model!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/810
https://github.com/CliMA/Oceananigans.jl/pull/810:153,Deployability,upgrade,upgrade,153,"We should merge this after PR #805. # Release notes. This release fixes a major bug where you couldn't run GPU models so if you're using GPUs you should upgrade to this version. **Oceananigans.jl now requires Julia 1.4+.**. Major changes:; * Updated the backend to use [KernelAbstractions.jl](https://github.com/JuliaGPU/KernelAbstractions.jl) instead of [GPUifyLoops.jl](https://github.com/vchuravy/GPUifyLoops.jl).; * Updated to using [CUDA.jl](https://github.com/JuliaGPU/CUDA.jl) instead of CuArrays.jl, CUDAnative.jl, and CUDAdrv.jl.; * Updated and slightly expanded the model setup documentation.; * Added a bibliography and citations to the documentation.; * Generalized `ConstantIsotropicDiffusivity` and `ConstantAnisotropicDiffusivity` to accept functions of `x, y, z, t` as well as constants. These types are called `IsotropicDiffusivity` and `AnisotropicDiffusivity`; `ConstantIsotropicDiffusivity` and `ConstantAnisotropicDiffusivity` aliases are provided for backwards compatibility.; * Lots of new convergence tests confirming the accuracy of the model!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/810
https://github.com/CliMA/Oceananigans.jl/pull/810:242,Deployability,Update,Updated,242,"We should merge this after PR #805. # Release notes. This release fixes a major bug where you couldn't run GPU models so if you're using GPUs you should upgrade to this version. **Oceananigans.jl now requires Julia 1.4+.**. Major changes:; * Updated the backend to use [KernelAbstractions.jl](https://github.com/JuliaGPU/KernelAbstractions.jl) instead of [GPUifyLoops.jl](https://github.com/vchuravy/GPUifyLoops.jl).; * Updated to using [CUDA.jl](https://github.com/JuliaGPU/CUDA.jl) instead of CuArrays.jl, CUDAnative.jl, and CUDAdrv.jl.; * Updated and slightly expanded the model setup documentation.; * Added a bibliography and citations to the documentation.; * Generalized `ConstantIsotropicDiffusivity` and `ConstantAnisotropicDiffusivity` to accept functions of `x, y, z, t` as well as constants. These types are called `IsotropicDiffusivity` and `AnisotropicDiffusivity`; `ConstantIsotropicDiffusivity` and `ConstantAnisotropicDiffusivity` aliases are provided for backwards compatibility.; * Lots of new convergence tests confirming the accuracy of the model!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/810
https://github.com/CliMA/Oceananigans.jl/pull/810:420,Deployability,Update,Updated,420,"We should merge this after PR #805. # Release notes. This release fixes a major bug where you couldn't run GPU models so if you're using GPUs you should upgrade to this version. **Oceananigans.jl now requires Julia 1.4+.**. Major changes:; * Updated the backend to use [KernelAbstractions.jl](https://github.com/JuliaGPU/KernelAbstractions.jl) instead of [GPUifyLoops.jl](https://github.com/vchuravy/GPUifyLoops.jl).; * Updated to using [CUDA.jl](https://github.com/JuliaGPU/CUDA.jl) instead of CuArrays.jl, CUDAnative.jl, and CUDAdrv.jl.; * Updated and slightly expanded the model setup documentation.; * Added a bibliography and citations to the documentation.; * Generalized `ConstantIsotropicDiffusivity` and `ConstantAnisotropicDiffusivity` to accept functions of `x, y, z, t` as well as constants. These types are called `IsotropicDiffusivity` and `AnisotropicDiffusivity`; `ConstantIsotropicDiffusivity` and `ConstantAnisotropicDiffusivity` aliases are provided for backwards compatibility.; * Lots of new convergence tests confirming the accuracy of the model!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/810
https://github.com/CliMA/Oceananigans.jl/pull/810:542,Deployability,Update,Updated,542,"We should merge this after PR #805. # Release notes. This release fixes a major bug where you couldn't run GPU models so if you're using GPUs you should upgrade to this version. **Oceananigans.jl now requires Julia 1.4+.**. Major changes:; * Updated the backend to use [KernelAbstractions.jl](https://github.com/JuliaGPU/KernelAbstractions.jl) instead of [GPUifyLoops.jl](https://github.com/vchuravy/GPUifyLoops.jl).; * Updated to using [CUDA.jl](https://github.com/JuliaGPU/CUDA.jl) instead of CuArrays.jl, CUDAnative.jl, and CUDAdrv.jl.; * Updated and slightly expanded the model setup documentation.; * Added a bibliography and citations to the documentation.; * Generalized `ConstantIsotropicDiffusivity` and `ConstantAnisotropicDiffusivity` to accept functions of `x, y, z, t` as well as constants. These types are called `IsotropicDiffusivity` and `AnisotropicDiffusivity`; `ConstantIsotropicDiffusivity` and `ConstantAnisotropicDiffusivity` aliases are provided for backwards compatibility.; * Lots of new convergence tests confirming the accuracy of the model!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/810
https://github.com/CliMA/Oceananigans.jl/pull/810:1025,Testability,test,tests,1025,"We should merge this after PR #805. # Release notes. This release fixes a major bug where you couldn't run GPU models so if you're using GPUs you should upgrade to this version. **Oceananigans.jl now requires Julia 1.4+.**. Major changes:; * Updated the backend to use [KernelAbstractions.jl](https://github.com/JuliaGPU/KernelAbstractions.jl) instead of [GPUifyLoops.jl](https://github.com/vchuravy/GPUifyLoops.jl).; * Updated to using [CUDA.jl](https://github.com/JuliaGPU/CUDA.jl) instead of CuArrays.jl, CUDAnative.jl, and CUDAdrv.jl.; * Updated and slightly expanded the model setup documentation.; * Added a bibliography and citations to the documentation.; * Generalized `ConstantIsotropicDiffusivity` and `ConstantAnisotropicDiffusivity` to accept functions of `x, y, z, t` as well as constants. These types are called `IsotropicDiffusivity` and `AnisotropicDiffusivity`; `ConstantIsotropicDiffusivity` and `ConstantAnisotropicDiffusivity` aliases are provided for backwards compatibility.; * Lots of new convergence tests confirming the accuracy of the model!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/810
https://github.com/CliMA/Oceananigans.jl/issues/811:581,Integrability,rout,routines,581,"These kernels:. https://github.com/CliMA/Oceananigans.jl/blob/1dbe86c49e1d4e013c5ea595f837b4c226b1561e/src/BoundaryConditions/fill_halo_regions.jl#L51-L66. use broadcasting and are thus executed on the default CUDA stream. We should rewrite these kernels using the `KernelAbstractions.jl` kernel language so that we can control when they are executed. In particular, kernel filling for periodic directions must be filled after non-periodic directions to ensure that corner points are set properly. We can potentially solve this problem by asking *only* the west, east halo-filling routines to fill corner points. This ensures the corner points will be filled if _at least_ one direction is periodic. In the case that no directions are periodic, the corner points do not need to be filled.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/811
https://github.com/CliMA/Oceananigans.jl/issues/811:233,Modifiability,rewrite,rewrite,233,"These kernels:. https://github.com/CliMA/Oceananigans.jl/blob/1dbe86c49e1d4e013c5ea595f837b4c226b1561e/src/BoundaryConditions/fill_halo_regions.jl#L51-L66. use broadcasting and are thus executed on the default CUDA stream. We should rewrite these kernels using the `KernelAbstractions.jl` kernel language so that we can control when they are executed. In particular, kernel filling for periodic directions must be filled after non-periodic directions to ensure that corner points are set properly. We can potentially solve this problem by asking *only* the west, east halo-filling routines to fill corner points. This ensures the corner points will be filled if _at least_ one direction is periodic. In the case that no directions are periodic, the corner points do not need to be filled.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/811
https://github.com/CliMA/Oceananigans.jl/pull/815:350,Testability,test,tests,350,"This PR adds a new submodule called `Oceananigans.Advection`. The advection scheme for a model is chosen by using the advection keyword in the constructor for `IncompressibleModel`. For example,. ```julia; model = IncompressibleModel(advection=CenteredSecondOrder(), ...); ```. This PR also adds a `CenteredFourthOrder` advection scheme. Convergence tests and instantiation tests are forthcoming.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/815
https://github.com/CliMA/Oceananigans.jl/pull/815:374,Testability,test,tests,374,"This PR adds a new submodule called `Oceananigans.Advection`. The advection scheme for a model is chosen by using the advection keyword in the constructor for `IncompressibleModel`. For example,. ```julia; model = IncompressibleModel(advection=CenteredSecondOrder(), ...); ```. This PR also adds a `CenteredFourthOrder` advection scheme. Convergence tests and instantiation tests are forthcoming.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/815
https://github.com/CliMA/Oceananigans.jl/issues/816:246,Performance,race condition,race condition,246,@sandreza and Adeline have a script that explodes into NaNs almost immediately at 128³ but takes many thousands of iterations to produce a NaN at 32³. Reverting to Oceananigans v0.27.0 the script runs fine. @sandreza suggested that it might be a race condition between kernels since KernelAbstractions.jl allows for multiple streams. Race conditions get much more (exponentially?) frequent as the number of threads increase I guess. I'm trying to reproduce this issue with a minimal working example.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/816
https://github.com/CliMA/Oceananigans.jl/issues/816:334,Performance,Race condition,Race conditions,334,@sandreza and Adeline have a script that explodes into NaNs almost immediately at 128³ but takes many thousands of iterations to produce a NaN at 32³. Reverting to Oceananigans v0.27.0 the script runs fine. @sandreza suggested that it might be a race condition between kernels since KernelAbstractions.jl allows for multiple streams. Race conditions get much more (exponentially?) frequent as the number of threads increase I guess. I'm trying to reproduce this issue with a minimal working example.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/816
https://github.com/CliMA/Oceananigans.jl/pull/821:0,Deployability,Release,Release,0,"Release notes:. **Everyone should stop using Oceananigans v0.31.0 and upgrade to this version. Oceananigans now requires Julia 1.4 or later.**. This release fixes a major bug concerning a race condition making GPU simulation, especially large models, explode into NaNs in v0.31.0. It also restores the ""Examples"" section in the documentation and adds experimental support for higher order advection schemes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/821
https://github.com/CliMA/Oceananigans.jl/pull/821:70,Deployability,upgrade,upgrade,70,"Release notes:. **Everyone should stop using Oceananigans v0.31.0 and upgrade to this version. Oceananigans now requires Julia 1.4 or later.**. This release fixes a major bug concerning a race condition making GPU simulation, especially large models, explode into NaNs in v0.31.0. It also restores the ""Examples"" section in the documentation and adds experimental support for higher order advection schemes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/821
https://github.com/CliMA/Oceananigans.jl/pull/821:149,Deployability,release,release,149,"Release notes:. **Everyone should stop using Oceananigans v0.31.0 and upgrade to this version. Oceananigans now requires Julia 1.4 or later.**. This release fixes a major bug concerning a race condition making GPU simulation, especially large models, explode into NaNs in v0.31.0. It also restores the ""Examples"" section in the documentation and adds experimental support for higher order advection schemes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/821
https://github.com/CliMA/Oceananigans.jl/pull/821:188,Performance,race condition,race condition,188,"Release notes:. **Everyone should stop using Oceananigans v0.31.0 and upgrade to this version. Oceananigans now requires Julia 1.4 or later.**. This release fixes a major bug concerning a race condition making GPU simulation, especially large models, explode into NaNs in v0.31.0. It also restores the ""Examples"" section in the documentation and adds experimental support for higher order advection schemes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/821
https://github.com/CliMA/Oceananigans.jl/pull/823:562,Testability,test,tests,562,"This PR adds new features to the `NetCDFOutputWriter` and fixes some bugs. 1. It now always writes useful metadata to all NetCDF files (the date the file was generated, the Julia version, and the Oceananigans version used). This is essential for reproducibility.; 2. Add a `verbose` flag (default is `false`) in case you want to track what's being to disk and how long it takes for each output to be computed.; 3. Add an `include_halos` flag (default is `false`) in case you want to use the full grid including halos to write fields and custom output. Added new tests for this.; 4. Test that the x, y, z coordinates being written to NetCDF files are correct. They were not (I think this happened when we switched to using offset arrays for `grid.xC`, etc.). This has been fixed.; 5. Added jldoctest examples showing how to write fields and custom output to NetCDF.; 6. There was a bug in showing/printing grid domains for bounded dimensions, e.g.; ```julia; julia> grid = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1)); RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0625]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (16, 16, 16); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (0.0625, 0.0625, 0.0625); ```; Notice that `z ∈ [-1.0, 0.0625]` should be `z ∈ [-1.0, 0.0]`. This has been fixed now. I'd like to start using these features in LESbrary.jl (and in PR #572) so I'll tag v0.33.0 once this PR is merged. Resolves #683",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/823
https://github.com/CliMA/Oceananigans.jl/pull/823:582,Testability,Test,Test,582,"This PR adds new features to the `NetCDFOutputWriter` and fixes some bugs. 1. It now always writes useful metadata to all NetCDF files (the date the file was generated, the Julia version, and the Oceananigans version used). This is essential for reproducibility.; 2. Add a `verbose` flag (default is `false`) in case you want to track what's being to disk and how long it takes for each output to be computed.; 3. Add an `include_halos` flag (default is `false`) in case you want to use the full grid including halos to write fields and custom output. Added new tests for this.; 4. Test that the x, y, z coordinates being written to NetCDF files are correct. They were not (I think this happened when we switched to using offset arrays for `grid.xC`, etc.). This has been fixed.; 5. Added jldoctest examples showing how to write fields and custom output to NetCDF.; 6. There was a bug in showing/printing grid domains for bounded dimensions, e.g.; ```julia; julia> grid = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1)); RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0625]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (16, 16, 16); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (0.0625, 0.0625, 0.0625); ```; Notice that `z ∈ [-1.0, 0.0625]` should be `z ∈ [-1.0, 0.0]`. This has been fixed now. I'd like to start using these features in LESbrary.jl (and in PR #572) so I'll tag v0.33.0 once this PR is merged. Resolves #683",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/823
https://github.com/CliMA/Oceananigans.jl/pull/825:0,Deployability,Release,Release,0,"Release notes:. This release adds new features to the `NetCDFOutputWriter` and fixes some bugs.; * The date the file was generated, the Julia version, and the Oceananigans version used are always written as global attributes (metadata) to all NetCDF files.; * Added `with_halos` and `verbose` keyword arguments to `NetCDFOutputWriter`.; * Fixed bug in writing grid coordinates to NetCDF (they were previously offset).; * Fixed bug in printing of grid coordinate ranges for `Bounded` dimensions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/825
https://github.com/CliMA/Oceananigans.jl/pull/825:21,Deployability,release,release,21,"Release notes:. This release adds new features to the `NetCDFOutputWriter` and fixes some bugs.; * The date the file was generated, the Julia version, and the Oceananigans version used are always written as global attributes (metadata) to all NetCDF files.; * Added `with_halos` and `verbose` keyword arguments to `NetCDFOutputWriter`.; * Fixed bug in writing grid coordinates to NetCDF (they were previously offset).; * Fixed bug in printing of grid coordinate ranges for `Bounded` dimensions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/825
https://github.com/CliMA/Oceananigans.jl/issues/828:5,Availability,ERROR,ERROR,5,"```; ERROR: InvalidIRError: compiling kernel gpu_calculate_pressure_right_hand_side!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!), CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global}, Oceananigans.Solvers.HorizontallyPeriodic, GPU, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, Int64, NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}) resulted in invalid LLVM IR ; Reason: unsupported call to the Julia runtime (call to jl_f_tuple); ```. Might have something to do with the new tuple/named tuple syntax but I thought Julia 1.4 -> 1.5 wasn't supposed to introduce any breaking changes? https://julialang.org/blog/2020/08/julia-1.5-highlights/#implicit_keyword_argument_values. # Julia 1.4.2. ```; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.4.2 (2020-05-23); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; grid = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1)); model = IncompressibleModel(architecture=GPU(), grid=grid); time_step!(model, 1); [ Info: Precompiling Oceananigans [9e8cae",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828
https://github.com/CliMA/Oceananigans.jl/issues/828:3037,Availability,ERROR,ERROR,3037,"(0); CUDA.CuDevice(1); CUDA.CuDevice(2); CUDA.CuDevice(3); ┌ Warning: Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)`; └ @ GPUArrays ~/.julia/packages/GPUArrays/4W5rW/src/host/indexing.jl:43; ```. # Julia 1.5.0. ```; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.0 (2020-08-01); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; grid = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1)); model = IncompressibleModel(architecture=GPU(), grid=grid); time_step!(model, 1); ┌ Warning: Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)`; └ @ GPUArrays ~/.julia/packages/GPUArrays/4W5rW/src/host/indexing.jl:43; ERROR: InvalidIRError: compiling kernel gpu_calculate_pressure_right_hand_side!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!), CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global}, Oceananigans.Solvers.HorizontallyPeriodic, GPU, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, Int64, NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828
https://github.com/CliMA/Oceananigans.jl/issues/828:1768,Deployability,release,release,1768,"loat64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, Int64, NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}) resulted in invalid LLVM IR ; Reason: unsupported call to the Julia runtime (call to jl_f_tuple); ```. Might have something to do with the new tuple/named tuple syntax but I thought Julia 1.4 -> 1.5 wasn't supposed to introduce any breaking changes? https://julialang.org/blog/2020/08/julia-1.5-highlights/#implicit_keyword_argument_values. # Julia 1.4.2. ```; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.4.2 (2020-05-23); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; grid = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1)); model = IncompressibleModel(architecture=GPU(), grid=grid); time_step!(model, 1); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; CUDA-enabled GPU(s) detected:; CUDA.CuDevice(0); CUDA.CuDevice(1); CUDA.CuDevice(2); CUDA.CuDevice(3); ┌ Warning: Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)`; └ @ GPUArrays ~/.julia/packages/GPUArrays/4W5rW/src/host/indexing.jl:43; ```. # Julia 1.5.0. ```; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.0 (2020-08-01); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; grid = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1)); model = IncompressibleModel(arc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828
https://github.com/CliMA/Oceananigans.jl/issues/828:2633,Deployability,release,release,2633,"; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.4.2 (2020-05-23); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; grid = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1)); model = IncompressibleModel(architecture=GPU(), grid=grid); time_step!(model, 1); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; CUDA-enabled GPU(s) detected:; CUDA.CuDevice(0); CUDA.CuDevice(1); CUDA.CuDevice(2); CUDA.CuDevice(3); ┌ Warning: Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)`; └ @ GPUArrays ~/.julia/packages/GPUArrays/4W5rW/src/host/indexing.jl:43; ```. # Julia 1.5.0. ```; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.0 (2020-08-01); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; grid = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1)); model = IncompressibleModel(architecture=GPU(), grid=grid); time_step!(model, 1); ┌ Warning: Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)`; └ @ GPUArrays ~/.julia/packages/GPUArrays/4W5rW/src/host/indexing.jl:43; ERROR: InvalidIRError: compiling kernel gpu_calculate_pressure_right_hand_side!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!), CUDA.CuDeviceArray",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828
https://github.com/CliMA/Oceananigans.jl/issues/828:11922,Integrability,depend,dependencies,11922,"4,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:0; [18] cufunction(::Function, ::Type{T} where T; name::String, kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/alir/.julia/packages/CUDA/h38pe/src/compiler/execution.jl:296; [19] macro expansion at /home/alir/.julia/packages/CUDA/h38pe/src/compiler/execution.jl:108 [inlined]; [20] (::KernelAbstractions.Kernel{KernelAbstractions.CUDADevice,KernelAbstractions.NDIteration.StaticSize{(16, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!)})(::CUDA.CuArray{Complex{Float64},3,Nothing}, ::Vararg{Any,N} where N; ndrange::Nothing, dependencies::KernelAbstractions.CudaEvent, workgroupsize::Nothing, progress::Function) at /home/alir/.julia/packages/KernelAbstractions/yw9SF/src/backends/cuda.jl:211; [21] launch!(::GPU, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Symbol, ::typeof(Oceananigans.Solvers.calculate_pressure_right_hand_side!), ::CUDA.CuArray{Complex{Float64},3,Nothing}, ::Vararg{Any,N} where N; dependencies::KernelAbstractions.CudaEvent, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /home/alir/Oceananigans.jl/src/Utils/kernel_launching.jl:67; [22] solve_for_pressure!(::OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3,Nothing}}, ::Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CUDA.CuArray{Float64,3,Nothing},CUDA.CuArray{Float64,3,Nothing},",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828
https://github.com/CliMA/Oceananigans.jl/issues/828:12433,Integrability,depend,dependencies,12433,"t /home/alir/.julia/packages/CUDA/h38pe/src/compiler/execution.jl:296; [19] macro expansion at /home/alir/.julia/packages/CUDA/h38pe/src/compiler/execution.jl:108 [inlined]; [20] (::KernelAbstractions.Kernel{KernelAbstractions.CUDADevice,KernelAbstractions.NDIteration.StaticSize{(16, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!)})(::CUDA.CuArray{Complex{Float64},3,Nothing}, ::Vararg{Any,N} where N; ndrange::Nothing, dependencies::KernelAbstractions.CudaEvent, workgroupsize::Nothing, progress::Function) at /home/alir/.julia/packages/KernelAbstractions/yw9SF/src/backends/cuda.jl:211; [21] launch!(::GPU, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Symbol, ::typeof(Oceananigans.Solvers.calculate_pressure_right_hand_side!), ::CUDA.CuArray{Complex{Float64},3,Nothing}, ::Vararg{Any,N} where N; dependencies::KernelAbstractions.CudaEvent, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /home/alir/Oceananigans.jl/src/Utils/kernel_launching.jl:67; [22] solve_for_pressure!(::OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3,Nothing}}, ::Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CUDA.CuArray{Float64,3,Nothing},CUDA.CuArray{Float64,3,Nothing},CUDA.CuArray{Float64,3,Nothing}}},CUDA.CuArray{Complex{Float64},3,Nothing},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CUDA.CuArray{Complex{Float64},3,Nothing},CUDA.CuArray{C",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828
https://github.com/CliMA/Oceananigans.jl/issues/828:2148,Performance,Perform,Performing,2148,"e Julia runtime (call to jl_f_tuple); ```. Might have something to do with the new tuple/named tuple syntax but I thought Julia 1.4 -> 1.5 wasn't supposed to introduce any breaking changes? https://julialang.org/blog/2020/08/julia-1.5-highlights/#implicit_keyword_argument_values. # Julia 1.4.2. ```; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.4.2 (2020-05-23); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; grid = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1)); model = IncompressibleModel(architecture=GPU(), grid=grid); time_step!(model, 1); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; CUDA-enabled GPU(s) detected:; CUDA.CuDevice(0); CUDA.CuDevice(1); CUDA.CuDevice(2); CUDA.CuDevice(3); ┌ Warning: Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)`; └ @ GPUArrays ~/.julia/packages/GPUArrays/4W5rW/src/host/indexing.jl:43; ```. # Julia 1.5.0. ```; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.0 (2020-08-01); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; grid = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1)); model = IncompressibleModel(architecture=GPU(), grid=grid); time_step!(model, 1); ┌ Warning: Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)`; └ @ GPUArrays ~/.julia/packages/GPUArrays/4W5rW/src/host/indexing.jl:43; ERROR: InvalidIRError: compiling kernel gpu_calculate_pressure_right_hand_side!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.ND",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828
https://github.com/CliMA/Oceananigans.jl/issues/828:2836,Performance,Perform,Performing,2836,"d = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1)); model = IncompressibleModel(architecture=GPU(), grid=grid); time_step!(model, 1); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; CUDA-enabled GPU(s) detected:; CUDA.CuDevice(0); CUDA.CuDevice(1); CUDA.CuDevice(2); CUDA.CuDevice(3); ┌ Warning: Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)`; └ @ GPUArrays ~/.julia/packages/GPUArrays/4W5rW/src/host/indexing.jl:43; ```. # Julia 1.5.0. ```; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.0 (2020-08-01); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; grid = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1)); model = IncompressibleModel(architecture=GPU(), grid=grid); time_step!(model, 1); ┌ Warning: Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)`; └ @ GPUArrays ~/.julia/packages/GPUArrays/4W5rW/src/host/indexing.jl:43; ERROR: InvalidIRError: compiling kernel gpu_calculate_pressure_right_hand_side!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!), CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global}, Oceananigans.Solvers.HorizontallyPeriodic, GPU, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,S",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828
https://github.com/CliMA/Oceananigans.jl/issues/828:5144,Performance,optimiz,optimize,5144,"oat64,3,CUDA.AS.Global}}}}) resulted in invalid LLVM IR ; Reason: unsupported call to the Julia runtime (call to jl_f_tuple); Stacktrace:; [1] overdub at /home/alir/.julia/packages/Cassette/158rp/src/overdub.jl:586; [2] multiple call sites at unknown:0; Reason: unsupported call to the Julia runtime (call to jl_f_getfield); Stacktrace:; [1] overdub at /home/alir/.julia/packages/Cassette/158rp/src/overdub.jl:586; [2] multiple call sites at unknown:0; Stacktrace:; [1] check_ir(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Module) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/validation.jl:123; [2] macro expansion at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:241 [inlined]; [3] macro expansion at /home/alir/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:239; [5] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [6] compile at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [7] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828
https://github.com/CliMA/Oceananigans.jl/issues/828:5419,Performance,optimiz,optimize,5419,"all to the Julia runtime (call to jl_f_getfield); Stacktrace:; [1] overdub at /home/alir/.julia/packages/Cassette/158rp/src/overdub.jl:586; [2] multiple call sites at unknown:0; Stacktrace:; [1] check_ir(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Module) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/validation.jl:123; [2] macro expansion at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:241 [inlined]; [3] macro expansion at /home/alir/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:239; [5] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [6] compile at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [7] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828
https://github.com/CliMA/Oceananigans.jl/issues/828:6998,Performance,cache,cache,6998,", 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Int64,NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}}}; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/alir/.julia/packages/CUDA/h38pe/src/compiler/execution.jl:308; [8] #87 at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:21 [inlined]; [9] get!(::GPUCompiler.var""#87#88""{Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}},typeof(CUDA._cufunction),GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePreci",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828
https://github.com/CliMA/Oceananigans.jl/issues/828:9703,Performance,cache,cache,9703,"ons.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Int64,NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [12] + at ./int.jl:86 [inlined]; [13] hash_64_64 at ./hashing.jl:35 [inlined]; [14] hash_uint64 at ./hashing.jl:62 [inlined]; [15] hx at ./float.jl:568 [inlined]; [16] hash at ./float.jl:571 [inlined]; [17] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,Off",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828
https://github.com/CliMA/Oceananigans.jl/issues/828:11246,Performance,cache,cache,11246,"ons.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Int64,NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:0; [18] cufunction(::Function, ::Type{T} where T; name::String, kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/alir/.julia/packages/CUDA/h38pe/src/compiler/execution.jl:296; [19] macro expansion at /home/alir/.julia/packages/CUDA/h38pe/src/compiler/execution.jl:108 [inlined]; [20] (::KernelAbstractions.Kernel{KernelAbstractions.CUDADevice,KernelAbstractions.NDIteration.StaticSize{(16, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!)})(::CUDA.CuArray{Complex{Float64},3,Nothing}, ::Vararg{Any,N} where N; ndrange::Nothing, dependencies::KernelAbstractions.CudaEvent, workgroupsize::Nothing, progress::Function) at /home/alir/.julia/packages/KernelAbstractions/yw9SF/src/backends/cuda.jl:211; [21] launch!(::GPU, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.Tw",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828
https://github.com/CliMA/Oceananigans.jl/issues/828:2054,Safety,detect,detected,2054,"Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}) resulted in invalid LLVM IR ; Reason: unsupported call to the Julia runtime (call to jl_f_tuple); ```. Might have something to do with the new tuple/named tuple syntax but I thought Julia 1.4 -> 1.5 wasn't supposed to introduce any breaking changes? https://julialang.org/blog/2020/08/julia-1.5-highlights/#implicit_keyword_argument_values. # Julia 1.4.2. ```; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.4.2 (2020-05-23); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; grid = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1)); model = IncompressibleModel(architecture=GPU(), grid=grid); time_step!(model, 1); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; CUDA-enabled GPU(s) detected:; CUDA.CuDevice(0); CUDA.CuDevice(1); CUDA.CuDevice(2); CUDA.CuDevice(3); ┌ Warning: Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)`; └ @ GPUArrays ~/.julia/packages/GPUArrays/4W5rW/src/host/indexing.jl:43; ```. # Julia 1.5.0. ```; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.0 (2020-08-01); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; grid = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1)); model = IncompressibleModel(architecture=GPU(), grid=grid); time_step!(model, 1); ┌ Warning: Performing scalar operations on GPU arrays: This is very slow, consider disallowing these o",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828
https://github.com/CliMA/Oceananigans.jl/issues/828:4780,Security,validat,validation,4780,"dic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, Int64, NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}) resulted in invalid LLVM IR ; Reason: unsupported call to the Julia runtime (call to jl_f_tuple); Stacktrace:; [1] overdub at /home/alir/.julia/packages/Cassette/158rp/src/overdub.jl:586; [2] multiple call sites at unknown:0; Reason: unsupported call to the Julia runtime (call to jl_f_getfield); Stacktrace:; [1] overdub at /home/alir/.julia/packages/Cassette/158rp/src/overdub.jl:586; [2] multiple call sites at unknown:0; Stacktrace:; [1] check_ir(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Module) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/validation.jl:123; [2] macro expansion at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:241 [inlined]; [3] macro expansion at /home/alir/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:239; [5] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [6] compile at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [7] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.Com",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828
https://github.com/CliMA/Oceananigans.jl/issues/828:5173,Security,validat,validate,5173,"oat64,3,CUDA.AS.Global}}}}) resulted in invalid LLVM IR ; Reason: unsupported call to the Julia runtime (call to jl_f_tuple); Stacktrace:; [1] overdub at /home/alir/.julia/packages/Cassette/158rp/src/overdub.jl:586; [2] multiple call sites at unknown:0; Reason: unsupported call to the Julia runtime (call to jl_f_getfield); Stacktrace:; [1] overdub at /home/alir/.julia/packages/Cassette/158rp/src/overdub.jl:586; [2] multiple call sites at unknown:0; Stacktrace:; [1] check_ir(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Module) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/validation.jl:123; [2] macro expansion at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:241 [inlined]; [3] macro expansion at /home/alir/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:239; [5] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [6] compile at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [7] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828
https://github.com/CliMA/Oceananigans.jl/issues/828:5448,Security,validat,validate,5448,"all to the Julia runtime (call to jl_f_getfield); Stacktrace:; [1] overdub at /home/alir/.julia/packages/Cassette/158rp/src/overdub.jl:586; [2] multiple call sites at unknown:0; Stacktrace:; [1] check_ir(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Module) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/validation.jl:123; [2] macro expansion at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:241 [inlined]; [3] macro expansion at /home/alir/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:239; [5] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [6] compile at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [7] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828
https://github.com/CliMA/Oceananigans.jl/issues/828:9770,Security,hash,hashing,9770,"Abstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Int64,NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [12] + at ./int.jl:86 [inlined]; [13] hash_64_64 at ./hashing.jl:35 [inlined]; [14] hash_uint64 at ./hashing.jl:62 [inlined]; [15] hx at ./float.jl:568 [inlined]; [16] hash at ./float.jl:571 [inlined]; [17] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828
https://github.com/CliMA/Oceananigans.jl/issues/828:9817,Security,hash,hashing,9817,"},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Int64,NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [12] + at ./int.jl:86 [inlined]; [13] hash_64_64 at ./hashing.jl:35 [inlined]; [14] hash_uint64 at ./hashing.jl:62 [inlined]; [15] hx at ./float.jl:568 [inlined]; [16] hash at ./float.jl:571 [inlined]; [17] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Int64,NamedTuple{(:",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828
https://github.com/CliMA/Oceananigans.jl/issues/828:9884,Security,hash,hash,9884,"Type#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Int64,NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [12] + at ./int.jl:86 [inlined]; [13] hash_64_64 at ./hashing.jl:35 [inlined]; [14] hash_uint64 at ./hashing.jl:62 [inlined]; [15] hx at ./float.jl:568 [inlined]; [16] hash at ./float.jl:571 [inlined]; [17] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Int64,NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828
https://github.com/CliMA/Oceananigans.jl/issues/833:405,Availability,down,download,405,"It'd be nice to implement the 'Orlanski' boundary condition for open boundaries:. https://www.sciencedirect.com/science/article/pii/0021999183901274. For this to work properly, we need to modify the pressure solver to work for time-dependent inflows. We may also need to implement a correction that ensures mass conservation, as described just before section 5 here:. http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.70.3860&rep=rep1&type=pdf. This would allow us to simulate the spatial development of a boundary layer, a la . https://iopscience.iop.org/article/10.1088/1742-6596/318/2/022023/meta",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/833
https://github.com/CliMA/Oceananigans.jl/issues/833:232,Integrability,depend,dependent,232,"It'd be nice to implement the 'Orlanski' boundary condition for open boundaries:. https://www.sciencedirect.com/science/article/pii/0021999183901274. For this to work properly, we need to modify the pressure solver to work for time-dependent inflows. We may also need to implement a correction that ensures mass conservation, as described just before section 5 here:. http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.70.3860&rep=rep1&type=pdf. This would allow us to simulate the spatial development of a boundary layer, a la . https://iopscience.iop.org/article/10.1088/1742-6596/318/2/022023/meta",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/833
https://github.com/CliMA/Oceananigans.jl/pull/834:122,Testability,test,test,122,@glwagner and I found a factor of 2 bug in the triply periodic pressure solver which now works and passes the convergence test. I also added and cleaned up some pressure solver tests. In doing so I ended up doing a bit of reorganizing and cleanup. Helps with #586,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/834
https://github.com/CliMA/Oceananigans.jl/pull/834:177,Testability,test,tests,177,@glwagner and I found a factor of 2 bug in the triply periodic pressure solver which now works and passes the convergence test. I also added and cleaned up some pressure solver tests. In doing so I ended up doing a bit of reorganizing and cleanup. Helps with #586,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/834
https://github.com/CliMA/Oceananigans.jl/pull/836:105,Usability,clear,clearer,105,This PR changes the confusing names `frequency` and `interval` for diagnostics and output writers to the clearer `iteration_interval` and `time_interval`. It also changes `progress_frequency` to `iteration_interval` for simulations. It also converts some examples to doctests. Resolves #672,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/836
https://github.com/CliMA/Oceananigans.jl/pull/839:19,Availability,checkpoint,checkpointer,19,"This PR fixes some checkpointer bugs and improves the `restore_from_checkpoint` interface. The checkpointer has more comprehensive tests now. This PR was originally @sandreza's PR #797 but was accidently merged prematurely then reverted. * `restore_from_checkpoint` now takes kwargs like a model constructor instead of a dictionary. This should be more intuitive and easier to use.; * Checkpointing and restoring from a checkpoint with function boundary conditions works now. If function boundary conditions are not manually restored, they are replaced with `missing`. They are restored correctly if passed via the `boundary_conditions` kwarg to `restore_from_checkpoint` and the model can be time stepped.; * Checkpointing and restoring between architectures works now. I've tested CPU -> GPU and GPU -> CPU restoration.; * Added more comprehensive checkpointing tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/839
https://github.com/CliMA/Oceananigans.jl/pull/839:95,Availability,checkpoint,checkpointer,95,"This PR fixes some checkpointer bugs and improves the `restore_from_checkpoint` interface. The checkpointer has more comprehensive tests now. This PR was originally @sandreza's PR #797 but was accidently merged prematurely then reverted. * `restore_from_checkpoint` now takes kwargs like a model constructor instead of a dictionary. This should be more intuitive and easier to use.; * Checkpointing and restoring from a checkpoint with function boundary conditions works now. If function boundary conditions are not manually restored, they are replaced with `missing`. They are restored correctly if passed via the `boundary_conditions` kwarg to `restore_from_checkpoint` and the model can be time stepped.; * Checkpointing and restoring between architectures works now. I've tested CPU -> GPU and GPU -> CPU restoration.; * Added more comprehensive checkpointing tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/839
https://github.com/CliMA/Oceananigans.jl/pull/839:385,Availability,Checkpoint,Checkpointing,385,"This PR fixes some checkpointer bugs and improves the `restore_from_checkpoint` interface. The checkpointer has more comprehensive tests now. This PR was originally @sandreza's PR #797 but was accidently merged prematurely then reverted. * `restore_from_checkpoint` now takes kwargs like a model constructor instead of a dictionary. This should be more intuitive and easier to use.; * Checkpointing and restoring from a checkpoint with function boundary conditions works now. If function boundary conditions are not manually restored, they are replaced with `missing`. They are restored correctly if passed via the `boundary_conditions` kwarg to `restore_from_checkpoint` and the model can be time stepped.; * Checkpointing and restoring between architectures works now. I've tested CPU -> GPU and GPU -> CPU restoration.; * Added more comprehensive checkpointing tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/839
https://github.com/CliMA/Oceananigans.jl/pull/839:420,Availability,checkpoint,checkpoint,420,"This PR fixes some checkpointer bugs and improves the `restore_from_checkpoint` interface. The checkpointer has more comprehensive tests now. This PR was originally @sandreza's PR #797 but was accidently merged prematurely then reverted. * `restore_from_checkpoint` now takes kwargs like a model constructor instead of a dictionary. This should be more intuitive and easier to use.; * Checkpointing and restoring from a checkpoint with function boundary conditions works now. If function boundary conditions are not manually restored, they are replaced with `missing`. They are restored correctly if passed via the `boundary_conditions` kwarg to `restore_from_checkpoint` and the model can be time stepped.; * Checkpointing and restoring between architectures works now. I've tested CPU -> GPU and GPU -> CPU restoration.; * Added more comprehensive checkpointing tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/839
https://github.com/CliMA/Oceananigans.jl/pull/839:710,Availability,Checkpoint,Checkpointing,710,"This PR fixes some checkpointer bugs and improves the `restore_from_checkpoint` interface. The checkpointer has more comprehensive tests now. This PR was originally @sandreza's PR #797 but was accidently merged prematurely then reverted. * `restore_from_checkpoint` now takes kwargs like a model constructor instead of a dictionary. This should be more intuitive and easier to use.; * Checkpointing and restoring from a checkpoint with function boundary conditions works now. If function boundary conditions are not manually restored, they are replaced with `missing`. They are restored correctly if passed via the `boundary_conditions` kwarg to `restore_from_checkpoint` and the model can be time stepped.; * Checkpointing and restoring between architectures works now. I've tested CPU -> GPU and GPU -> CPU restoration.; * Added more comprehensive checkpointing tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/839
https://github.com/CliMA/Oceananigans.jl/pull/839:850,Availability,checkpoint,checkpointing,850,"This PR fixes some checkpointer bugs and improves the `restore_from_checkpoint` interface. The checkpointer has more comprehensive tests now. This PR was originally @sandreza's PR #797 but was accidently merged prematurely then reverted. * `restore_from_checkpoint` now takes kwargs like a model constructor instead of a dictionary. This should be more intuitive and easier to use.; * Checkpointing and restoring from a checkpoint with function boundary conditions works now. If function boundary conditions are not manually restored, they are replaced with `missing`. They are restored correctly if passed via the `boundary_conditions` kwarg to `restore_from_checkpoint` and the model can be time stepped.; * Checkpointing and restoring between architectures works now. I've tested CPU -> GPU and GPU -> CPU restoration.; * Added more comprehensive checkpointing tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/839
https://github.com/CliMA/Oceananigans.jl/pull/839:80,Integrability,interface,interface,80,"This PR fixes some checkpointer bugs and improves the `restore_from_checkpoint` interface. The checkpointer has more comprehensive tests now. This PR was originally @sandreza's PR #797 but was accidently merged prematurely then reverted. * `restore_from_checkpoint` now takes kwargs like a model constructor instead of a dictionary. This should be more intuitive and easier to use.; * Checkpointing and restoring from a checkpoint with function boundary conditions works now. If function boundary conditions are not manually restored, they are replaced with `missing`. They are restored correctly if passed via the `boundary_conditions` kwarg to `restore_from_checkpoint` and the model can be time stepped.; * Checkpointing and restoring between architectures works now. I've tested CPU -> GPU and GPU -> CPU restoration.; * Added more comprehensive checkpointing tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/839
https://github.com/CliMA/Oceananigans.jl/pull/839:131,Testability,test,tests,131,"This PR fixes some checkpointer bugs and improves the `restore_from_checkpoint` interface. The checkpointer has more comprehensive tests now. This PR was originally @sandreza's PR #797 but was accidently merged prematurely then reverted. * `restore_from_checkpoint` now takes kwargs like a model constructor instead of a dictionary. This should be more intuitive and easier to use.; * Checkpointing and restoring from a checkpoint with function boundary conditions works now. If function boundary conditions are not manually restored, they are replaced with `missing`. They are restored correctly if passed via the `boundary_conditions` kwarg to `restore_from_checkpoint` and the model can be time stepped.; * Checkpointing and restoring between architectures works now. I've tested CPU -> GPU and GPU -> CPU restoration.; * Added more comprehensive checkpointing tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/839
https://github.com/CliMA/Oceananigans.jl/pull/839:776,Testability,test,tested,776,"This PR fixes some checkpointer bugs and improves the `restore_from_checkpoint` interface. The checkpointer has more comprehensive tests now. This PR was originally @sandreza's PR #797 but was accidently merged prematurely then reverted. * `restore_from_checkpoint` now takes kwargs like a model constructor instead of a dictionary. This should be more intuitive and easier to use.; * Checkpointing and restoring from a checkpoint with function boundary conditions works now. If function boundary conditions are not manually restored, they are replaced with `missing`. They are restored correctly if passed via the `boundary_conditions` kwarg to `restore_from_checkpoint` and the model can be time stepped.; * Checkpointing and restoring between architectures works now. I've tested CPU -> GPU and GPU -> CPU restoration.; * Added more comprehensive checkpointing tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/839
https://github.com/CliMA/Oceananigans.jl/pull/839:864,Testability,test,tests,864,"This PR fixes some checkpointer bugs and improves the `restore_from_checkpoint` interface. The checkpointer has more comprehensive tests now. This PR was originally @sandreza's PR #797 but was accidently merged prematurely then reverted. * `restore_from_checkpoint` now takes kwargs like a model constructor instead of a dictionary. This should be more intuitive and easier to use.; * Checkpointing and restoring from a checkpoint with function boundary conditions works now. If function boundary conditions are not manually restored, they are replaced with `missing`. They are restored correctly if passed via the `boundary_conditions` kwarg to `restore_from_checkpoint` and the model can be time stepped.; * Checkpointing and restoring between architectures works now. I've tested CPU -> GPU and GPU -> CPU restoration.; * Added more comprehensive checkpointing tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/839
https://github.com/CliMA/Oceananigans.jl/pull/839:353,Usability,intuit,intuitive,353,"This PR fixes some checkpointer bugs and improves the `restore_from_checkpoint` interface. The checkpointer has more comprehensive tests now. This PR was originally @sandreza's PR #797 but was accidently merged prematurely then reverted. * `restore_from_checkpoint` now takes kwargs like a model constructor instead of a dictionary. This should be more intuitive and easier to use.; * Checkpointing and restoring from a checkpoint with function boundary conditions works now. If function boundary conditions are not manually restored, they are replaced with `missing`. They are restored correctly if passed via the `boundary_conditions` kwarg to `restore_from_checkpoint` and the model can be time stepped.; * Checkpointing and restoring between architectures works now. I've tested CPU -> GPU and GPU -> CPU restoration.; * Added more comprehensive checkpointing tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/839
https://github.com/CliMA/Oceananigans.jl/issues/841:339,Usability,user-friendly,user-friendly,339,"If you pass something like `global_attributes = Dict(""Re"" => Re)` into the `NetCDFOutputWriter` constructor then it's type will be `Dict{String,Int}` and the constructor will fail as it tries to add `{String,String}` metadata entries. The user could explicitly specify `global_attributes = Dict{String,Any}(""Re"" => Re)` but I think a more user-friendly solution would be for the constructor to recast the type of `global_attributes` into `Dict{String,Any}`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/841
https://github.com/CliMA/Oceananigans.jl/issues/845:351,Integrability,depend,depend,351,"We commonly need to specify criteria that triggers an action; eg saving of data. For example, the `OutputWriter`s have the keyword arguments `time_interval` (for saving after fixed intervals of time) and `iteration_interval` (for saving after a fixed number of iterations). This method is a big clunky and doesn't allow for more general criteria that depend on, for example, flow features, wall clock time, etc. It'd be nice to have a general system for specifying `AbstractCriteria` that must be met for an action to occur. We can have types like `TimeInterval` and `IterationInterval`, or `WallTimeInterval`, for example, which will return true (given some argument like `model`) when saving / action needs to occur. A similar problem exists for the printing of progress statements by `Simulation`, and also for calling ""callback"" functions during the time-stepping loop of `run!(simulation)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/845
https://github.com/CliMA/Oceananigans.jl/pull/847:192,Availability,avail,available,192,"Release notes:. This release adds some new features, fixes some bugs, and improves the API (so there are some breaking changes, listed below). Major changes:; * Triply periodic models are now available by passing the `topology = (Periodic, Periodic, Periodic)` keyword argument to grids.; * All 1D, 2D, and 3D averages are now available through the `Average` diagnostic with the `dims` keyword argument.; * Fixed some checkpointing bugs.; * **BREAKING:** Use `Average(..., dims=(1, 2))` instead of `HorizontalAverage(...)`.; * **BREAKING:** Use `iteration_interval` and `time_interval` instead of `frequency` and `interval` for diagnostics and output writers.; * **BREAKING:** Use `iteration_interval` instead of `progress_frequency` for simulations.; * **BREAKING:** Use `IsotropicDiffusivity` and `AnisotropicDiffusivity` instead of `ConstantIsotropicDiffusivity` and `ConstantAnisotropicDiffusivity`. Also, use `νz` instead of `νv` and `κz` instead of `κv`.; * **BREAKING:** To `restore_from_checkpoint`, pass model constructor arguments as you would to a normal constructor, e.g. `restore_from_checkpoint(""my_checkpoint.jld2"", boundary_conditions=custom_bcs)`. Previous behavior was to pass a dictionary which was less user friendly.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/847
https://github.com/CliMA/Oceananigans.jl/pull/847:327,Availability,avail,available,327,"Release notes:. This release adds some new features, fixes some bugs, and improves the API (so there are some breaking changes, listed below). Major changes:; * Triply periodic models are now available by passing the `topology = (Periodic, Periodic, Periodic)` keyword argument to grids.; * All 1D, 2D, and 3D averages are now available through the `Average` diagnostic with the `dims` keyword argument.; * Fixed some checkpointing bugs.; * **BREAKING:** Use `Average(..., dims=(1, 2))` instead of `HorizontalAverage(...)`.; * **BREAKING:** Use `iteration_interval` and `time_interval` instead of `frequency` and `interval` for diagnostics and output writers.; * **BREAKING:** Use `iteration_interval` instead of `progress_frequency` for simulations.; * **BREAKING:** Use `IsotropicDiffusivity` and `AnisotropicDiffusivity` instead of `ConstantIsotropicDiffusivity` and `ConstantAnisotropicDiffusivity`. Also, use `νz` instead of `νv` and `κz` instead of `κv`.; * **BREAKING:** To `restore_from_checkpoint`, pass model constructor arguments as you would to a normal constructor, e.g. `restore_from_checkpoint(""my_checkpoint.jld2"", boundary_conditions=custom_bcs)`. Previous behavior was to pass a dictionary which was less user friendly.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/847
https://github.com/CliMA/Oceananigans.jl/pull/847:418,Availability,checkpoint,checkpointing,418,"Release notes:. This release adds some new features, fixes some bugs, and improves the API (so there are some breaking changes, listed below). Major changes:; * Triply periodic models are now available by passing the `topology = (Periodic, Periodic, Periodic)` keyword argument to grids.; * All 1D, 2D, and 3D averages are now available through the `Average` diagnostic with the `dims` keyword argument.; * Fixed some checkpointing bugs.; * **BREAKING:** Use `Average(..., dims=(1, 2))` instead of `HorizontalAverage(...)`.; * **BREAKING:** Use `iteration_interval` and `time_interval` instead of `frequency` and `interval` for diagnostics and output writers.; * **BREAKING:** Use `iteration_interval` instead of `progress_frequency` for simulations.; * **BREAKING:** Use `IsotropicDiffusivity` and `AnisotropicDiffusivity` instead of `ConstantIsotropicDiffusivity` and `ConstantAnisotropicDiffusivity`. Also, use `νz` instead of `νv` and `κz` instead of `κv`.; * **BREAKING:** To `restore_from_checkpoint`, pass model constructor arguments as you would to a normal constructor, e.g. `restore_from_checkpoint(""my_checkpoint.jld2"", boundary_conditions=custom_bcs)`. Previous behavior was to pass a dictionary which was less user friendly.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/847
https://github.com/CliMA/Oceananigans.jl/pull/847:0,Deployability,Release,Release,0,"Release notes:. This release adds some new features, fixes some bugs, and improves the API (so there are some breaking changes, listed below). Major changes:; * Triply periodic models are now available by passing the `topology = (Periodic, Periodic, Periodic)` keyword argument to grids.; * All 1D, 2D, and 3D averages are now available through the `Average` diagnostic with the `dims` keyword argument.; * Fixed some checkpointing bugs.; * **BREAKING:** Use `Average(..., dims=(1, 2))` instead of `HorizontalAverage(...)`.; * **BREAKING:** Use `iteration_interval` and `time_interval` instead of `frequency` and `interval` for diagnostics and output writers.; * **BREAKING:** Use `iteration_interval` instead of `progress_frequency` for simulations.; * **BREAKING:** Use `IsotropicDiffusivity` and `AnisotropicDiffusivity` instead of `ConstantIsotropicDiffusivity` and `ConstantAnisotropicDiffusivity`. Also, use `νz` instead of `νv` and `κz` instead of `κv`.; * **BREAKING:** To `restore_from_checkpoint`, pass model constructor arguments as you would to a normal constructor, e.g. `restore_from_checkpoint(""my_checkpoint.jld2"", boundary_conditions=custom_bcs)`. Previous behavior was to pass a dictionary which was less user friendly.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/847
https://github.com/CliMA/Oceananigans.jl/pull/847:21,Deployability,release,release,21,"Release notes:. This release adds some new features, fixes some bugs, and improves the API (so there are some breaking changes, listed below). Major changes:; * Triply periodic models are now available by passing the `topology = (Periodic, Periodic, Periodic)` keyword argument to grids.; * All 1D, 2D, and 3D averages are now available through the `Average` diagnostic with the `dims` keyword argument.; * Fixed some checkpointing bugs.; * **BREAKING:** Use `Average(..., dims=(1, 2))` instead of `HorizontalAverage(...)`.; * **BREAKING:** Use `iteration_interval` and `time_interval` instead of `frequency` and `interval` for diagnostics and output writers.; * **BREAKING:** Use `iteration_interval` instead of `progress_frequency` for simulations.; * **BREAKING:** Use `IsotropicDiffusivity` and `AnisotropicDiffusivity` instead of `ConstantIsotropicDiffusivity` and `ConstantAnisotropicDiffusivity`. Also, use `νz` instead of `νv` and `κz` instead of `κv`.; * **BREAKING:** To `restore_from_checkpoint`, pass model constructor arguments as you would to a normal constructor, e.g. `restore_from_checkpoint(""my_checkpoint.jld2"", boundary_conditions=custom_bcs)`. Previous behavior was to pass a dictionary which was less user friendly.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/847
https://github.com/CliMA/Oceananigans.jl/pull/850:224,Availability,down,down,224,"Last minute benchmarks update for JOSS. Resolves #607. The performance benchmarks have been updated from v0.18.0 to v0.34.0. While it seems that CPU models have gotten faster by about ~32% while large GPU models have slowed down by ~15%, I think that's just because the v0.18.0 benchmarks were run on Supercloud or somewhere with a V100 while the v0.34.0 benchmarks were run on Tartarus where the TITAN V is marginally slower but the CPUs are beefier. No noticeable regression is pretty great considering how many features and improvements we've added since v0.18.0 and the fact that we haven't really done any profiling and targeted performance optimization. What seems to have gotten worse is constant overhead costs so small models are slower because of it, but this is something we can tackle when we focus on performance optimization in the future. ![benchmark_plots](https://user-images.githubusercontent.com/20099589/89906791-d2c85b00-dbb9-11ea-969a-4b8db2c31680.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/850
https://github.com/CliMA/Oceananigans.jl/pull/850:23,Deployability,update,update,23,"Last minute benchmarks update for JOSS. Resolves #607. The performance benchmarks have been updated from v0.18.0 to v0.34.0. While it seems that CPU models have gotten faster by about ~32% while large GPU models have slowed down by ~15%, I think that's just because the v0.18.0 benchmarks were run on Supercloud or somewhere with a V100 while the v0.34.0 benchmarks were run on Tartarus where the TITAN V is marginally slower but the CPUs are beefier. No noticeable regression is pretty great considering how many features and improvements we've added since v0.18.0 and the fact that we haven't really done any profiling and targeted performance optimization. What seems to have gotten worse is constant overhead costs so small models are slower because of it, but this is something we can tackle when we focus on performance optimization in the future. ![benchmark_plots](https://user-images.githubusercontent.com/20099589/89906791-d2c85b00-dbb9-11ea-969a-4b8db2c31680.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/850
https://github.com/CliMA/Oceananigans.jl/pull/850:92,Deployability,update,updated,92,"Last minute benchmarks update for JOSS. Resolves #607. The performance benchmarks have been updated from v0.18.0 to v0.34.0. While it seems that CPU models have gotten faster by about ~32% while large GPU models have slowed down by ~15%, I think that's just because the v0.18.0 benchmarks were run on Supercloud or somewhere with a V100 while the v0.34.0 benchmarks were run on Tartarus where the TITAN V is marginally slower but the CPUs are beefier. No noticeable regression is pretty great considering how many features and improvements we've added since v0.18.0 and the fact that we haven't really done any profiling and targeted performance optimization. What seems to have gotten worse is constant overhead costs so small models are slower because of it, but this is something we can tackle when we focus on performance optimization in the future. ![benchmark_plots](https://user-images.githubusercontent.com/20099589/89906791-d2c85b00-dbb9-11ea-969a-4b8db2c31680.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/850
https://github.com/CliMA/Oceananigans.jl/pull/850:59,Performance,perform,performance,59,"Last minute benchmarks update for JOSS. Resolves #607. The performance benchmarks have been updated from v0.18.0 to v0.34.0. While it seems that CPU models have gotten faster by about ~32% while large GPU models have slowed down by ~15%, I think that's just because the v0.18.0 benchmarks were run on Supercloud or somewhere with a V100 while the v0.34.0 benchmarks were run on Tartarus where the TITAN V is marginally slower but the CPUs are beefier. No noticeable regression is pretty great considering how many features and improvements we've added since v0.18.0 and the fact that we haven't really done any profiling and targeted performance optimization. What seems to have gotten worse is constant overhead costs so small models are slower because of it, but this is something we can tackle when we focus on performance optimization in the future. ![benchmark_plots](https://user-images.githubusercontent.com/20099589/89906791-d2c85b00-dbb9-11ea-969a-4b8db2c31680.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/850
https://github.com/CliMA/Oceananigans.jl/pull/850:634,Performance,perform,performance,634,"Last minute benchmarks update for JOSS. Resolves #607. The performance benchmarks have been updated from v0.18.0 to v0.34.0. While it seems that CPU models have gotten faster by about ~32% while large GPU models have slowed down by ~15%, I think that's just because the v0.18.0 benchmarks were run on Supercloud or somewhere with a V100 while the v0.34.0 benchmarks were run on Tartarus where the TITAN V is marginally slower but the CPUs are beefier. No noticeable regression is pretty great considering how many features and improvements we've added since v0.18.0 and the fact that we haven't really done any profiling and targeted performance optimization. What seems to have gotten worse is constant overhead costs so small models are slower because of it, but this is something we can tackle when we focus on performance optimization in the future. ![benchmark_plots](https://user-images.githubusercontent.com/20099589/89906791-d2c85b00-dbb9-11ea-969a-4b8db2c31680.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/850
https://github.com/CliMA/Oceananigans.jl/pull/850:646,Performance,optimiz,optimization,646,"Last minute benchmarks update for JOSS. Resolves #607. The performance benchmarks have been updated from v0.18.0 to v0.34.0. While it seems that CPU models have gotten faster by about ~32% while large GPU models have slowed down by ~15%, I think that's just because the v0.18.0 benchmarks were run on Supercloud or somewhere with a V100 while the v0.34.0 benchmarks were run on Tartarus where the TITAN V is marginally slower but the CPUs are beefier. No noticeable regression is pretty great considering how many features and improvements we've added since v0.18.0 and the fact that we haven't really done any profiling and targeted performance optimization. What seems to have gotten worse is constant overhead costs so small models are slower because of it, but this is something we can tackle when we focus on performance optimization in the future. ![benchmark_plots](https://user-images.githubusercontent.com/20099589/89906791-d2c85b00-dbb9-11ea-969a-4b8db2c31680.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/850
https://github.com/CliMA/Oceananigans.jl/pull/850:814,Performance,perform,performance,814,"Last minute benchmarks update for JOSS. Resolves #607. The performance benchmarks have been updated from v0.18.0 to v0.34.0. While it seems that CPU models have gotten faster by about ~32% while large GPU models have slowed down by ~15%, I think that's just because the v0.18.0 benchmarks were run on Supercloud or somewhere with a V100 while the v0.34.0 benchmarks were run on Tartarus where the TITAN V is marginally slower but the CPUs are beefier. No noticeable regression is pretty great considering how many features and improvements we've added since v0.18.0 and the fact that we haven't really done any profiling and targeted performance optimization. What seems to have gotten worse is constant overhead costs so small models are slower because of it, but this is something we can tackle when we focus on performance optimization in the future. ![benchmark_plots](https://user-images.githubusercontent.com/20099589/89906791-d2c85b00-dbb9-11ea-969a-4b8db2c31680.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/850
https://github.com/CliMA/Oceananigans.jl/pull/850:826,Performance,optimiz,optimization,826,"Last minute benchmarks update for JOSS. Resolves #607. The performance benchmarks have been updated from v0.18.0 to v0.34.0. While it seems that CPU models have gotten faster by about ~32% while large GPU models have slowed down by ~15%, I think that's just because the v0.18.0 benchmarks were run on Supercloud or somewhere with a V100 while the v0.34.0 benchmarks were run on Tartarus where the TITAN V is marginally slower but the CPUs are beefier. No noticeable regression is pretty great considering how many features and improvements we've added since v0.18.0 and the fact that we haven't really done any profiling and targeted performance optimization. What seems to have gotten worse is constant overhead costs so small models are slower because of it, but this is something we can tackle when we focus on performance optimization in the future. ![benchmark_plots](https://user-images.githubusercontent.com/20099589/89906791-d2c85b00-dbb9-11ea-969a-4b8db2c31680.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/850
https://github.com/CliMA/Oceananigans.jl/pull/850:12,Testability,benchmark,benchmarks,12,"Last minute benchmarks update for JOSS. Resolves #607. The performance benchmarks have been updated from v0.18.0 to v0.34.0. While it seems that CPU models have gotten faster by about ~32% while large GPU models have slowed down by ~15%, I think that's just because the v0.18.0 benchmarks were run on Supercloud or somewhere with a V100 while the v0.34.0 benchmarks were run on Tartarus where the TITAN V is marginally slower but the CPUs are beefier. No noticeable regression is pretty great considering how many features and improvements we've added since v0.18.0 and the fact that we haven't really done any profiling and targeted performance optimization. What seems to have gotten worse is constant overhead costs so small models are slower because of it, but this is something we can tackle when we focus on performance optimization in the future. ![benchmark_plots](https://user-images.githubusercontent.com/20099589/89906791-d2c85b00-dbb9-11ea-969a-4b8db2c31680.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/850
https://github.com/CliMA/Oceananigans.jl/pull/850:71,Testability,benchmark,benchmarks,71,"Last minute benchmarks update for JOSS. Resolves #607. The performance benchmarks have been updated from v0.18.0 to v0.34.0. While it seems that CPU models have gotten faster by about ~32% while large GPU models have slowed down by ~15%, I think that's just because the v0.18.0 benchmarks were run on Supercloud or somewhere with a V100 while the v0.34.0 benchmarks were run on Tartarus where the TITAN V is marginally slower but the CPUs are beefier. No noticeable regression is pretty great considering how many features and improvements we've added since v0.18.0 and the fact that we haven't really done any profiling and targeted performance optimization. What seems to have gotten worse is constant overhead costs so small models are slower because of it, but this is something we can tackle when we focus on performance optimization in the future. ![benchmark_plots](https://user-images.githubusercontent.com/20099589/89906791-d2c85b00-dbb9-11ea-969a-4b8db2c31680.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/850
https://github.com/CliMA/Oceananigans.jl/pull/850:278,Testability,benchmark,benchmarks,278,"Last minute benchmarks update for JOSS. Resolves #607. The performance benchmarks have been updated from v0.18.0 to v0.34.0. While it seems that CPU models have gotten faster by about ~32% while large GPU models have slowed down by ~15%, I think that's just because the v0.18.0 benchmarks were run on Supercloud or somewhere with a V100 while the v0.34.0 benchmarks were run on Tartarus where the TITAN V is marginally slower but the CPUs are beefier. No noticeable regression is pretty great considering how many features and improvements we've added since v0.18.0 and the fact that we haven't really done any profiling and targeted performance optimization. What seems to have gotten worse is constant overhead costs so small models are slower because of it, but this is something we can tackle when we focus on performance optimization in the future. ![benchmark_plots](https://user-images.githubusercontent.com/20099589/89906791-d2c85b00-dbb9-11ea-969a-4b8db2c31680.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/850
https://github.com/CliMA/Oceananigans.jl/pull/850:355,Testability,benchmark,benchmarks,355,"Last minute benchmarks update for JOSS. Resolves #607. The performance benchmarks have been updated from v0.18.0 to v0.34.0. While it seems that CPU models have gotten faster by about ~32% while large GPU models have slowed down by ~15%, I think that's just because the v0.18.0 benchmarks were run on Supercloud or somewhere with a V100 while the v0.34.0 benchmarks were run on Tartarus where the TITAN V is marginally slower but the CPUs are beefier. No noticeable regression is pretty great considering how many features and improvements we've added since v0.18.0 and the fact that we haven't really done any profiling and targeted performance optimization. What seems to have gotten worse is constant overhead costs so small models are slower because of it, but this is something we can tackle when we focus on performance optimization in the future. ![benchmark_plots](https://user-images.githubusercontent.com/20099589/89906791-d2c85b00-dbb9-11ea-969a-4b8db2c31680.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/850
https://github.com/CliMA/Oceananigans.jl/pull/851:348,Availability,error,error,348,"Got bitten by CuArray scalar operations while debugging some Europa runs so this PR adds an `__init__()` function to the Oceananigans module that disables CuArray scalar operations once the module has been loaded and only allows scalar ops via the `CUDA.@allowscalar` macro. Now when we accidentally perform scalar ops on CuArrays we should get an error, which is much better than having silent performance regressions which has happened multiple times in the past. Two remaining problems:; 1. `set!(u::Field, v::Number) = @. u.data = v` actually incurs scalar ops because `a::CuArray .= 1.5` does not but `a::OffsetArray{CuArray .= 1.5` does, so it's probably something we have to fix by adapting broadcasting over offsetarrays?; 2. For similar broadcasting reasons I think; ```julia; data = cpudata(output); ds[name][:, :, :, time_index] = view(data, ow.slices[name]...); ```; also incurs scalar ops during NetCDF output so I will try changing back to the old behavior where we used something like `	 ; ```julia; data = interiorparent(output); !isa(output, Array) && (data = Array(data)); ds[name][:, :, :, time_index] = view(data, ow.slices[name]...); ```. Resolves #276",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/851
https://github.com/CliMA/Oceananigans.jl/pull/851:689,Energy Efficiency,adapt,adapting,689,"Got bitten by CuArray scalar operations while debugging some Europa runs so this PR adds an `__init__()` function to the Oceananigans module that disables CuArray scalar operations once the module has been loaded and only allows scalar ops via the `CUDA.@allowscalar` macro. Now when we accidentally perform scalar ops on CuArrays we should get an error, which is much better than having silent performance regressions which has happened multiple times in the past. Two remaining problems:; 1. `set!(u::Field, v::Number) = @. u.data = v` actually incurs scalar ops because `a::CuArray .= 1.5` does not but `a::OffsetArray{CuArray .= 1.5` does, so it's probably something we have to fix by adapting broadcasting over offsetarrays?; 2. For similar broadcasting reasons I think; ```julia; data = cpudata(output); ds[name][:, :, :, time_index] = view(data, ow.slices[name]...); ```; also incurs scalar ops during NetCDF output so I will try changing back to the old behavior where we used something like `	 ; ```julia; data = interiorparent(output); !isa(output, Array) && (data = Array(data)); ds[name][:, :, :, time_index] = view(data, ow.slices[name]...); ```. Resolves #276",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/851
https://github.com/CliMA/Oceananigans.jl/pull/851:689,Modifiability,adapt,adapting,689,"Got bitten by CuArray scalar operations while debugging some Europa runs so this PR adds an `__init__()` function to the Oceananigans module that disables CuArray scalar operations once the module has been loaded and only allows scalar ops via the `CUDA.@allowscalar` macro. Now when we accidentally perform scalar ops on CuArrays we should get an error, which is much better than having silent performance regressions which has happened multiple times in the past. Two remaining problems:; 1. `set!(u::Field, v::Number) = @. u.data = v` actually incurs scalar ops because `a::CuArray .= 1.5` does not but `a::OffsetArray{CuArray .= 1.5` does, so it's probably something we have to fix by adapting broadcasting over offsetarrays?; 2. For similar broadcasting reasons I think; ```julia; data = cpudata(output); ds[name][:, :, :, time_index] = view(data, ow.slices[name]...); ```; also incurs scalar ops during NetCDF output so I will try changing back to the old behavior where we used something like `	 ; ```julia; data = interiorparent(output); !isa(output, Array) && (data = Array(data)); ds[name][:, :, :, time_index] = view(data, ow.slices[name]...); ```. Resolves #276",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/851
https://github.com/CliMA/Oceananigans.jl/pull/851:206,Performance,load,loaded,206,"Got bitten by CuArray scalar operations while debugging some Europa runs so this PR adds an `__init__()` function to the Oceananigans module that disables CuArray scalar operations once the module has been loaded and only allows scalar ops via the `CUDA.@allowscalar` macro. Now when we accidentally perform scalar ops on CuArrays we should get an error, which is much better than having silent performance regressions which has happened multiple times in the past. Two remaining problems:; 1. `set!(u::Field, v::Number) = @. u.data = v` actually incurs scalar ops because `a::CuArray .= 1.5` does not but `a::OffsetArray{CuArray .= 1.5` does, so it's probably something we have to fix by adapting broadcasting over offsetarrays?; 2. For similar broadcasting reasons I think; ```julia; data = cpudata(output); ds[name][:, :, :, time_index] = view(data, ow.slices[name]...); ```; also incurs scalar ops during NetCDF output so I will try changing back to the old behavior where we used something like `	 ; ```julia; data = interiorparent(output); !isa(output, Array) && (data = Array(data)); ds[name][:, :, :, time_index] = view(data, ow.slices[name]...); ```. Resolves #276",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/851
https://github.com/CliMA/Oceananigans.jl/pull/851:300,Performance,perform,perform,300,"Got bitten by CuArray scalar operations while debugging some Europa runs so this PR adds an `__init__()` function to the Oceananigans module that disables CuArray scalar operations once the module has been loaded and only allows scalar ops via the `CUDA.@allowscalar` macro. Now when we accidentally perform scalar ops on CuArrays we should get an error, which is much better than having silent performance regressions which has happened multiple times in the past. Two remaining problems:; 1. `set!(u::Field, v::Number) = @. u.data = v` actually incurs scalar ops because `a::CuArray .= 1.5` does not but `a::OffsetArray{CuArray .= 1.5` does, so it's probably something we have to fix by adapting broadcasting over offsetarrays?; 2. For similar broadcasting reasons I think; ```julia; data = cpudata(output); ds[name][:, :, :, time_index] = view(data, ow.slices[name]...); ```; also incurs scalar ops during NetCDF output so I will try changing back to the old behavior where we used something like `	 ; ```julia; data = interiorparent(output); !isa(output, Array) && (data = Array(data)); ds[name][:, :, :, time_index] = view(data, ow.slices[name]...); ```. Resolves #276",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/851
https://github.com/CliMA/Oceananigans.jl/pull/851:395,Performance,perform,performance,395,"Got bitten by CuArray scalar operations while debugging some Europa runs so this PR adds an `__init__()` function to the Oceananigans module that disables CuArray scalar operations once the module has been loaded and only allows scalar ops via the `CUDA.@allowscalar` macro. Now when we accidentally perform scalar ops on CuArrays we should get an error, which is much better than having silent performance regressions which has happened multiple times in the past. Two remaining problems:; 1. `set!(u::Field, v::Number) = @. u.data = v` actually incurs scalar ops because `a::CuArray .= 1.5` does not but `a::OffsetArray{CuArray .= 1.5` does, so it's probably something we have to fix by adapting broadcasting over offsetarrays?; 2. For similar broadcasting reasons I think; ```julia; data = cpudata(output); ds[name][:, :, :, time_index] = view(data, ow.slices[name]...); ```; also incurs scalar ops during NetCDF output so I will try changing back to the old behavior where we used something like `	 ; ```julia; data = interiorparent(output); !isa(output, Array) && (data = Array(data)); ds[name][:, :, :, time_index] = view(data, ow.slices[name]...); ```. Resolves #276",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/851
https://github.com/CliMA/Oceananigans.jl/pull/852:0,Deployability,Release,Release,0,Release notes:. This is a bugfix release that disables CuArray scalar operations by default (to avoid surprise scalar operations that can cause huge slowdowns) and **fixes a related bug where writing GPU fields to NetCDF was very slow**. Also includes small updates to the documentation.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/852
https://github.com/CliMA/Oceananigans.jl/pull/852:33,Deployability,release,release,33,Release notes:. This is a bugfix release that disables CuArray scalar operations by default (to avoid surprise scalar operations that can cause huge slowdowns) and **fixes a related bug where writing GPU fields to NetCDF was very slow**. Also includes small updates to the documentation.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/852
https://github.com/CliMA/Oceananigans.jl/pull/852:258,Deployability,update,updates,258,Release notes:. This is a bugfix release that disables CuArray scalar operations by default (to avoid surprise scalar operations that can cause huge slowdowns) and **fixes a related bug where writing GPU fields to NetCDF was very slow**. Also includes small updates to the documentation.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/852
https://github.com/CliMA/Oceananigans.jl/pull/852:96,Safety,avoid,avoid,96,Release notes:. This is a bugfix release that disables CuArray scalar operations by default (to avoid surprise scalar operations that can cause huge slowdowns) and **fixes a related bug where writing GPU fields to NetCDF was very slow**. Also includes small updates to the documentation.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/852
https://github.com/CliMA/Oceananigans.jl/issues/853:898,Usability,simpl,simple,898,"Currently, output writers accept two types of criterion for writing output: a `time_interval`, and an `iteration_interval`. For example, a user might instantiate a `JLD2OutputWriter` with. ```julia; field_outputs = FieldOutputs(merge(model.velocities, model.tracers)). simulation.output_writers[:fields] = JLD2OutputWriter(model, field_outputs, prefix=""fields"", time_interval=2minute); ```. which specifies output every 2 minutes of simulation time. `iteration_interval` is used similarly. These criteria are triggered by the function `time_to_run`:. https://github.com/CliMA/Oceananigans.jl/blob/994eae3d4550898914309e535ccbfd4655854646/src/Utils/output_writer_diagnostic_utils.jl#L55-L65. The function `time_interval_is_ripe` is, for example,. https://github.com/CliMA/Oceananigans.jl/blob/994eae3d4550898914309e535ccbfd4655854646/src/Utils/output_writer_diagnostic_utils.jl#L46-L53. This API is simple and effective for many purposes. However, it is not general or extensible. For example, a user cannot specify output to be saved based on other criteria, like some property of the flow, or on the elapsed wall time. A more general method might use types. For example, we can define `AbstractCriterion` like `TimeInterval` and `IterationInterval`. The above example would become. ```julia; field_outputs = FieldOutputs(merge(model.velocities, model.tracers)). simulation.output_writers[:fields] = JLD2OutputWriter(model, field_outputs, prefix=""fields"", write_criterion=TimeInterval(2minute)); ```. By making the criteria callable objects, we could use syntax like `output_writer.write_criteria(model)` as a replacement for `time_to_run(clock, output_writer)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/853
https://github.com/CliMA/Oceananigans.jl/issues/854:102,Availability,error,error,102,"I was just trying to precompile Oceananigans 0.34.1 on my macOS 10.15.6 machine and got the following error:. ```; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: LoadError: too many parameters for type; Stacktrace:; [1] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; [2] include(::Function, ::Module, ::String) at ./Base.jl:380; [3] include at ./Base.jl:368 [inlined]; [4] include(::String) at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:1; [5] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854
https://github.com/CliMA/Oceananigans.jl/issues/854:216,Availability,ERROR,ERROR,216,"I was just trying to precompile Oceananigans 0.34.1 on my macOS 10.15.6 machine and got the following error:. ```; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: LoadError: too many parameters for type; Stacktrace:; [1] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; [2] include(::Function, ::Module, ::String) at ./Base.jl:380; [3] include at ./Base.jl:368 [inlined]; [4] include(::String) at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:1; [5] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854
https://github.com/CliMA/Oceananigans.jl/issues/854:1152,Availability,ERROR,ERROR,1152,"9d6e9a09]; ERROR: LoadError: LoadError: too many parameters for type; Stacktrace:; [1] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; [2] include(::Function, ::Module, ::String) at ./Base.jl:380; [3] include at ./Base.jl:368 [inlined]; [4] include(::String) at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:1; [5] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854
https://github.com/CliMA/Oceananigans.jl/issues/854:1329,Availability,error,error,1329,"my/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; [2] include(::Function, ::Module, ::String) at ./Base.jl:380; [3] include at ./Base.jl:368 [inlined]; [4] include(::String) at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:1; [5] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854
https://github.com/CliMA/Oceananigans.jl/issues/854:1350,Availability,error,error,1350,"rrays/PkHCM/src/host/abstractarray.jl:24; [2] include(::Function, ::Module, ::String) at ./Base.jl:380; [3] include at ./Base.jl:368 [inlined]; [4] include(::String) at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:1; [5] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854
https://github.com/CliMA/Oceananigans.jl/issues/854:1916,Availability,ERROR,ERROR,1916,"t /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/Oceananigans/LW3v4/src/Oceananigans.jl:70; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/truedichotomy/.julia/compiled/v1.5/Oceananigans/hU93i_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _requir",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854
https://github.com/CliMA/Oceananigans.jl/issues/854:2083,Availability,error,error,2083,"s/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/Oceananigans/LW3v4/src/Oceananigans.jl:70; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/truedichotomy/.julia/compiled/v1.5/Oceananigans/hU93i_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854
https://github.com/CliMA/Oceananigans.jl/issues/854:2104,Availability,error,error,2104,"packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/Oceananigans/LW3v4/src/Oceananigans.jl:70; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/truedichotomy/.julia/compiled/v1.5/Oceananigans/hU93i_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; ``",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854
https://github.com/CliMA/Oceananigans.jl/issues/854:2687,Availability,ERROR,ERROR,2687,"ckages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/Oceananigans/LW3v4/src/Oceananigans.jl:70; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/truedichotomy/.julia/compiled/v1.5/Oceananigans/hU93i_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854
https://github.com/CliMA/Oceananigans.jl/issues/854:2859,Availability,error,error,2859,"ckages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/Oceananigans/LW3v4/src/Oceananigans.jl:70; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/truedichotomy/.julia/compiled/v1.5/Oceananigans/hU93i_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854
https://github.com/CliMA/Oceananigans.jl/issues/854:2880,Availability,error,error,2880,"ckages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/Oceananigans/LW3v4/src/Oceananigans.jl:70; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/truedichotomy/.julia/compiled/v1.5/Oceananigans/hU93i_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854
https://github.com/CliMA/Oceananigans.jl/issues/854:223,Performance,Load,LoadError,223,"I was just trying to precompile Oceananigans 0.34.1 on my macOS 10.15.6 machine and got the following error:. ```; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: LoadError: too many parameters for type; Stacktrace:; [1] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; [2] include(::Function, ::Module, ::String) at ./Base.jl:380; [3] include at ./Base.jl:368 [inlined]; [4] include(::String) at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:1; [5] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854
https://github.com/CliMA/Oceananigans.jl/issues/854:234,Performance,Load,LoadError,234,"I was just trying to precompile Oceananigans 0.34.1 on my macOS 10.15.6 machine and got the following error:. ```; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: LoadError: too many parameters for type; Stacktrace:; [1] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; [2] include(::Function, ::Module, ::String) at ./Base.jl:380; [3] include at ./Base.jl:368 [inlined]; [4] include(::String) at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:1; [5] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854
https://github.com/CliMA/Oceananigans.jl/issues/854:1159,Performance,Load,LoadError,1159,"9d6e9a09]; ERROR: LoadError: LoadError: too many parameters for type; Stacktrace:; [1] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; [2] include(::Function, ::Module, ::String) at ./Base.jl:380; [3] include at ./Base.jl:368 [inlined]; [4] include(::String) at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:1; [5] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854
https://github.com/CliMA/Oceananigans.jl/issues/854:1409,Performance,load,loading,1409,"tion, ::Module, ::String) at ./Base.jl:380; [3] include at ./Base.jl:368 [inlined]; [4] include(::String) at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:1; [5] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854
https://github.com/CliMA/Oceananigans.jl/issues/854:1458,Performance,load,loading,1458,"nclude at ./Base.jl:368 [inlined]; [4] include(::String) at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:1; [5] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope a",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854
https://github.com/CliMA/Oceananigans.jl/issues/854:1506,Performance,load,loading,1506,":String) at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:1; [5] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854
https://github.com/CliMA/Oceananigans.jl/issues/854:1559,Performance,load,loading,1559,"rrays/PkHCM/src/GPUArrays.jl:1; [5] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854
https://github.com/CliMA/Oceananigans.jl/issues/854:1923,Performance,Load,LoadError,1923,"t /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/Oceananigans/LW3v4/src/Oceananigans.jl:70; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/truedichotomy/.julia/compiled/v1.5/Oceananigans/hU93i_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _requir",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854
https://github.com/CliMA/Oceananigans.jl/issues/854:2163,Performance,load,loading,2163,"ckages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/Oceananigans/LW3v4/src/Oceananigans.jl:70; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/truedichotomy/.julia/compiled/v1.5/Oceananigans/hU93i_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854
https://github.com/CliMA/Oceananigans.jl/issues/854:2212,Performance,load,loading,2212,"ckages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/Oceananigans/LW3v4/src/Oceananigans.jl:70; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/truedichotomy/.julia/compiled/v1.5/Oceananigans/hU93i_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854
https://github.com/CliMA/Oceananigans.jl/issues/854:2260,Performance,load,loading,2260,"ckages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/Oceananigans/LW3v4/src/Oceananigans.jl:70; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/truedichotomy/.julia/compiled/v1.5/Oceananigans/hU93i_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854
https://github.com/CliMA/Oceananigans.jl/issues/854:2313,Performance,load,loading,2313,"ckages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/Oceananigans/LW3v4/src/Oceananigans.jl:70; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/truedichotomy/.julia/compiled/v1.5/Oceananigans/hU93i_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854
https://github.com/CliMA/Oceananigans.jl/issues/854:2939,Performance,load,loading,2939,"ckages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/Oceananigans/LW3v4/src/Oceananigans.jl:70; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/truedichotomy/.julia/compiled/v1.5/Oceananigans/hU93i_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854
https://github.com/CliMA/Oceananigans.jl/issues/854:2988,Performance,load,loading,2988,"ckages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/Oceananigans/LW3v4/src/Oceananigans.jl:70; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/truedichotomy/.julia/compiled/v1.5/Oceananigans/hU93i_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854
https://github.com/CliMA/Oceananigans.jl/issues/854:3036,Performance,load,loading,3036,"ckages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/Oceananigans/LW3v4/src/Oceananigans.jl:70; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/truedichotomy/.julia/compiled/v1.5/Oceananigans/hU93i_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854
https://github.com/CliMA/Oceananigans.jl/issues/854:3089,Performance,load,loading,3089,"ckages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/Oceananigans/LW3v4/src/Oceananigans.jl:70; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/truedichotomy/.julia/compiled/v1.5/Oceananigans/hU93i_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854
https://github.com/CliMA/Oceananigans.jl/pull/855:340,Availability,error,error,340,"Somewhat of a small frivolous PR but it improves logging in Oceananigans with some fancy formatting which includes using colors for timestamps and log levels (using the same colors as the base logger) and the source of the message is underlined (see screenshot below). It can be used via the usual macros (`@debug`, `@info`, `@warn`, and `@error`) once Oceananigans is loaded via `using` or `import`. Although this might actually be undesirable as it hijacks the global logger... The logger is now turned on globally in the `Oceananigans.__init__` function. I'd like to start using it for new simulations as it's useful to have timestamps. ![image](https://user-images.githubusercontent.com/20099589/90137955-51510400-dd44-11ea-9bb9-9c407db19b99.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/855
https://github.com/CliMA/Oceananigans.jl/pull/855:223,Integrability,message,message,223,"Somewhat of a small frivolous PR but it improves logging in Oceananigans with some fancy formatting which includes using colors for timestamps and log levels (using the same colors as the base logger) and the source of the message is underlined (see screenshot below). It can be used via the usual macros (`@debug`, `@info`, `@warn`, and `@error`) once Oceananigans is loaded via `using` or `import`. Although this might actually be undesirable as it hijacks the global logger... The logger is now turned on globally in the `Oceananigans.__init__` function. I'd like to start using it for new simulations as it's useful to have timestamps. ![image](https://user-images.githubusercontent.com/20099589/90137955-51510400-dd44-11ea-9bb9-9c407db19b99.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/855
https://github.com/CliMA/Oceananigans.jl/pull/855:369,Performance,load,loaded,369,"Somewhat of a small frivolous PR but it improves logging in Oceananigans with some fancy formatting which includes using colors for timestamps and log levels (using the same colors as the base logger) and the source of the message is underlined (see screenshot below). It can be used via the usual macros (`@debug`, `@info`, `@warn`, and `@error`) once Oceananigans is loaded via `using` or `import`. Although this might actually be undesirable as it hijacks the global logger... The logger is now turned on globally in the `Oceananigans.__init__` function. I'd like to start using it for new simulations as it's useful to have timestamps. ![image](https://user-images.githubusercontent.com/20099589/90137955-51510400-dd44-11ea-9bb9-9c407db19b99.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/855
https://github.com/CliMA/Oceananigans.jl/pull/855:49,Testability,log,logging,49,"Somewhat of a small frivolous PR but it improves logging in Oceananigans with some fancy formatting which includes using colors for timestamps and log levels (using the same colors as the base logger) and the source of the message is underlined (see screenshot below). It can be used via the usual macros (`@debug`, `@info`, `@warn`, and `@error`) once Oceananigans is loaded via `using` or `import`. Although this might actually be undesirable as it hijacks the global logger... The logger is now turned on globally in the `Oceananigans.__init__` function. I'd like to start using it for new simulations as it's useful to have timestamps. ![image](https://user-images.githubusercontent.com/20099589/90137955-51510400-dd44-11ea-9bb9-9c407db19b99.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/855
https://github.com/CliMA/Oceananigans.jl/pull/855:147,Testability,log,log,147,"Somewhat of a small frivolous PR but it improves logging in Oceananigans with some fancy formatting which includes using colors for timestamps and log levels (using the same colors as the base logger) and the source of the message is underlined (see screenshot below). It can be used via the usual macros (`@debug`, `@info`, `@warn`, and `@error`) once Oceananigans is loaded via `using` or `import`. Although this might actually be undesirable as it hijacks the global logger... The logger is now turned on globally in the `Oceananigans.__init__` function. I'd like to start using it for new simulations as it's useful to have timestamps. ![image](https://user-images.githubusercontent.com/20099589/90137955-51510400-dd44-11ea-9bb9-9c407db19b99.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/855
https://github.com/CliMA/Oceananigans.jl/pull/855:193,Testability,log,logger,193,"Somewhat of a small frivolous PR but it improves logging in Oceananigans with some fancy formatting which includes using colors for timestamps and log levels (using the same colors as the base logger) and the source of the message is underlined (see screenshot below). It can be used via the usual macros (`@debug`, `@info`, `@warn`, and `@error`) once Oceananigans is loaded via `using` or `import`. Although this might actually be undesirable as it hijacks the global logger... The logger is now turned on globally in the `Oceananigans.__init__` function. I'd like to start using it for new simulations as it's useful to have timestamps. ![image](https://user-images.githubusercontent.com/20099589/90137955-51510400-dd44-11ea-9bb9-9c407db19b99.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/855
https://github.com/CliMA/Oceananigans.jl/pull/855:470,Testability,log,logger,470,"Somewhat of a small frivolous PR but it improves logging in Oceananigans with some fancy formatting which includes using colors for timestamps and log levels (using the same colors as the base logger) and the source of the message is underlined (see screenshot below). It can be used via the usual macros (`@debug`, `@info`, `@warn`, and `@error`) once Oceananigans is loaded via `using` or `import`. Although this might actually be undesirable as it hijacks the global logger... The logger is now turned on globally in the `Oceananigans.__init__` function. I'd like to start using it for new simulations as it's useful to have timestamps. ![image](https://user-images.githubusercontent.com/20099589/90137955-51510400-dd44-11ea-9bb9-9c407db19b99.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/855
https://github.com/CliMA/Oceananigans.jl/pull/855:484,Testability,log,logger,484,"Somewhat of a small frivolous PR but it improves logging in Oceananigans with some fancy formatting which includes using colors for timestamps and log levels (using the same colors as the base logger) and the source of the message is underlined (see screenshot below). It can be used via the usual macros (`@debug`, `@info`, `@warn`, and `@error`) once Oceananigans is loaded via `using` or `import`. Although this might actually be undesirable as it hijacks the global logger... The logger is now turned on globally in the `Oceananigans.__init__` function. I'd like to start using it for new simulations as it's useful to have timestamps. ![image](https://user-images.githubusercontent.com/20099589/90137955-51510400-dd44-11ea-9bb9-9c407db19b99.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/855
https://github.com/CliMA/Oceananigans.jl/pull/856:323,Integrability,interface,interface,323,This PR adds `Oceananigans.Diagnostics.WindowedTimeAverage` for computing the average of a quantity or 'kernel' over a specified time window. The design of `WindowedTimeAverage` is discussed extensively on #501 . . This PR only implements the basic functionality needed to compute `WindowedTimeAverage`. A streamlined user interface through `JLD2OutputWriter` and `NetCDFOutputWriter` will be implemented in a future PR. Todo:. - [x] tests. Resolves #501,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/856
https://github.com/CliMA/Oceananigans.jl/pull/856:434,Testability,test,tests,434,This PR adds `Oceananigans.Diagnostics.WindowedTimeAverage` for computing the average of a quantity or 'kernel' over a specified time window. The design of `WindowedTimeAverage` is discussed extensively on #501 . . This PR only implements the basic functionality needed to compute `WindowedTimeAverage`. A streamlined user interface through `JLD2OutputWriter` and `NetCDFOutputWriter` will be implemented in a future PR. Todo:. - [x] tests. Resolves #501,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/856
https://github.com/CliMA/Oceananigans.jl/issues/857:323,Availability,ERROR,ERROR,323,"```julia; using Oceananigans, Oceananigans.Diagnostics, Oceananigans.AbstractOperations; grid = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1)); model = IncompressibleModel(architecture=CPU(), grid=grid) # Same with GPU(); u, v, w = model.velocities; ∫uv = Average(u*v, dims=(1, 2), return_type=Array); ```. ```; ERROR: MethodError: no method matching architecture(::Oceananigans.AbstractOperations.MultiaryOperation{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,2,typeof(*),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}},Tuple{typeof(identity),typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ)},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}); Closest candidates are:; architecture(::Array) at /home/alir/Oceananigans.jl/src/Architectures.jl:46; architecture(::CUDA.CuArray) at /home/alir/Oceananigans.jl/src/Architectures.jl:47; architecture(::Field) at /home/alir/Oceananigans.jl/src/Fields/field.jl:167; ...; Stacktrace:; [1] Average(::Oceananigans.AbstractOperations.MultiaryOperation{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,2,typeof(*),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}},Tuple{typeof(identity),typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ)},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}; dims::Tuple{Int64,Int64}, iteration_interval::Nothing, time_interval::Nothing, return_type::Type{T} where T) at /home/alir/Oceananigans.jl/src/Diagnostics/average.jl:52; [2] top-level scope at REPL[17]:1. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/857
https://github.com/CliMA/Oceananigans.jl/pull/858:364,Availability,error,error,364,"Resolves #857 . Minimal working example:; ```julia; using Oceananigans, Oceananigans.Diagnostics, Oceananigans.AbstractOperations; grid = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1)); model = IncompressibleModel(architecture=CPU(), grid=grid) # Same with GPU(); u, v, w = model.velocities; ∫uv = Average(u*v, dims=(1, 2), return_type=Array); ```. Old error (obscure and not useful to users):; ```; ERROR: MethodError: no method matching architecture(::Oceananigans.AbstractOperations.MultiaryOperation{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,2,typeof(*),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}},Tuple{typeof(identity),typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ)},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}); Closest candidates are:; architecture(::Array) at /home/alir/Oceananigans.jl/src/Architectures.jl:46; architecture(::CUDA.CuArray) at /home/alir/Oceananigans.jl/src/Architectures.jl:47; architecture(::Field) at /home/alir/Oceananigans.jl/src/Fields/field.jl:167; ...; Stacktrace:; [1] Average(::Oceananigans.AbstractOperations.MultiaryOperation{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,2,typeof(*),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}},Tuple{typeof(identity),typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ)},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}; dims::Tuple{Int64,Int64}, iteration_interval::Nothing, time_interval::Nothing, return_type::Type{T} where T) at /home/alir/Oceananigans.jl/src/Diagnostics/average.jl:52; [2] top-level scope at REPL[17]:1; ```. New error (more useful):; ```; ERROR: MethodError: no method mat",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/858
https://github.com/CliMA/Oceananigans.jl/pull/858:411,Availability,ERROR,ERROR,411,"Resolves #857 . Minimal working example:; ```julia; using Oceananigans, Oceananigans.Diagnostics, Oceananigans.AbstractOperations; grid = RegularCartesianGrid(size=(16, 16, 16), extent=(1, 1, 1)); model = IncompressibleModel(architecture=CPU(), grid=grid) # Same with GPU(); u, v, w = model.velocities; ∫uv = Average(u*v, dims=(1, 2), return_type=Array); ```. Old error (obscure and not useful to users):; ```; ERROR: MethodError: no method matching architecture(::Oceananigans.AbstractOperations.MultiaryOperation{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,2,typeof(*),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}},Tuple{typeof(identity),typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ)},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}); Closest candidates are:; architecture(::Array) at /home/alir/Oceananigans.jl/src/Architectures.jl:46; architecture(::CUDA.CuArray) at /home/alir/Oceananigans.jl/src/Architectures.jl:47; architecture(::Field) at /home/alir/Oceananigans.jl/src/Fields/field.jl:167; ...; Stacktrace:; [1] Average(::Oceananigans.AbstractOperations.MultiaryOperation{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,2,typeof(*),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}},Tuple{typeof(identity),typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ)},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}; dims::Tuple{Int64,Int64}, iteration_interval::Nothing, time_interval::Nothing, return_type::Type{T} where T) at /home/alir/Oceananigans.jl/src/Diagnostics/average.jl:52; [2] top-level scope at REPL[17]:1; ```. New error (more useful):; ```; ERROR: MethodError: no method mat",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/858
https://github.com/CliMA/Oceananigans.jl/pull/858:1941,Availability,error,error,1941,"ure(::Array) at /home/alir/Oceananigans.jl/src/Architectures.jl:46; architecture(::CUDA.CuArray) at /home/alir/Oceananigans.jl/src/Architectures.jl:47; architecture(::Field) at /home/alir/Oceananigans.jl/src/Fields/field.jl:167; ...; Stacktrace:; [1] Average(::Oceananigans.AbstractOperations.MultiaryOperation{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,2,typeof(*),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}},Tuple{typeof(identity),typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ)},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}; dims::Tuple{Int64,Int64}, iteration_interval::Nothing, time_interval::Nothing, return_type::Type{T} where T) at /home/alir/Oceananigans.jl/src/Diagnostics/average.jl:52; [2] top-level scope at REPL[17]:1; ```. New error (more useful):; ```; ERROR: MethodError: no method matching Average(::Oceananigans.AbstractOperations.MultiaryOperation{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,2,typeof(*),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}},Tuple{typeof(identity),typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ)},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}; dims=(1, 2), return_type=Array); Closest candidates are:; Average(::Oceananigans.AbstractOperations.AbstractOperation, ::Oceananigans.Models.AbstractModel; dims, kwargs...) at /home/alir/Oceananigans.jl/src/AbstractOperations/computations.jl:98; Average(::Oceananigans.AbstractOperations.AbstractOperation, ::Any; dims, kwargs...) at /home/alir/Oceananigans.jl/src/AbstractOperations/computations.jl:86; Average(::F, ::D, ::P, ::I, ::T, ::Float64, ::R) where {F, R, D, P, I, T} at /h",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/858
https://github.com/CliMA/Oceananigans.jl/pull/858:1968,Availability,ERROR,ERROR,1968,"ure(::Array) at /home/alir/Oceananigans.jl/src/Architectures.jl:46; architecture(::CUDA.CuArray) at /home/alir/Oceananigans.jl/src/Architectures.jl:47; architecture(::Field) at /home/alir/Oceananigans.jl/src/Fields/field.jl:167; ...; Stacktrace:; [1] Average(::Oceananigans.AbstractOperations.MultiaryOperation{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,2,typeof(*),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}},Tuple{typeof(identity),typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ)},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}; dims::Tuple{Int64,Int64}, iteration_interval::Nothing, time_interval::Nothing, return_type::Type{T} where T) at /home/alir/Oceananigans.jl/src/Diagnostics/average.jl:52; [2] top-level scope at REPL[17]:1; ```. New error (more useful):; ```; ERROR: MethodError: no method matching Average(::Oceananigans.AbstractOperations.MultiaryOperation{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,2,typeof(*),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}},Tuple{typeof(identity),typeof(Oceananigans.Operators.ℑxyᶠᶜᵃ)},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}; dims=(1, 2), return_type=Array); Closest candidates are:; Average(::Oceananigans.AbstractOperations.AbstractOperation, ::Oceananigans.Models.AbstractModel; dims, kwargs...) at /home/alir/Oceananigans.jl/src/AbstractOperations/computations.jl:98; Average(::Oceananigans.AbstractOperations.AbstractOperation, ::Any; dims, kwargs...) at /home/alir/Oceananigans.jl/src/AbstractOperations/computations.jl:86; Average(::F, ::D, ::P, ::I, ::T, ::Float64, ::R) where {F, R, D, P, I, T} at /h",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/858
https://github.com/CliMA/Oceananigans.jl/pull/859:215,Testability,test,test,215,This PR adds a `with_halos` option to the `Average` diagnostic. By default `with_halos = false`. Previously `with_halos` was always `true` which was awkward as most use cases did not warrant halos in the output. PR test `Average` with halos and add result size tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/859
https://github.com/CliMA/Oceananigans.jl/pull/859:261,Testability,test,tests,261,This PR adds a `with_halos` option to the `Average` diagnostic. By default `with_halos = false`. Previously `with_halos` was always `true` which was awkward as most use cases did not warrant halos in the output. PR test `Average` with halos and add result size tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/859
https://github.com/CliMA/Oceananigans.jl/pull/860:13,Availability,mainten,maintenance,13,Some regular maintenance,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/860
https://github.com/CliMA/Oceananigans.jl/issues/862:337,Availability,error,error,337,"I set up my netcdf writer as follows:. `fields = Dict(""u"" => model.velocities.u,""v"" => model.velocities.v,""w"" => model.velocities.w,""T"" => model.tracers.T)`; `my_writer = NetCDFOutputWriter(model, fields, filename=""data/turb_box_test.nc"", time_interval=60)`; `simulation.output_writers[:field_writer] = my_writer`. and got the following error:. NetCDF error: Variable 'time' not found in file <unknown> (NetCDF error code: -33)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/862
https://github.com/CliMA/Oceananigans.jl/issues/862:352,Availability,error,error,352,"I set up my netcdf writer as follows:. `fields = Dict(""u"" => model.velocities.u,""v"" => model.velocities.v,""w"" => model.velocities.w,""T"" => model.tracers.T)`; `my_writer = NetCDFOutputWriter(model, fields, filename=""data/turb_box_test.nc"", time_interval=60)`; `simulation.output_writers[:field_writer] = my_writer`. and got the following error:. NetCDF error: Variable 'time' not found in file <unknown> (NetCDF error code: -33)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/862
https://github.com/CliMA/Oceananigans.jl/issues/862:411,Availability,error,error,411,"I set up my netcdf writer as follows:. `fields = Dict(""u"" => model.velocities.u,""v"" => model.velocities.v,""w"" => model.velocities.w,""T"" => model.tracers.T)`; `my_writer = NetCDFOutputWriter(model, fields, filename=""data/turb_box_test.nc"", time_interval=60)`; `simulation.output_writers[:field_writer] = my_writer`. and got the following error:. NetCDF error: Variable 'time' not found in file <unknown> (NetCDF error code: -33)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/862
https://github.com/CliMA/Oceananigans.jl/issues/862:359,Modifiability,Variab,Variable,359,"I set up my netcdf writer as follows:. `fields = Dict(""u"" => model.velocities.u,""v"" => model.velocities.v,""w"" => model.velocities.w,""T"" => model.tracers.T)`; `my_writer = NetCDFOutputWriter(model, fields, filename=""data/turb_box_test.nc"", time_interval=60)`; `simulation.output_writers[:field_writer] = my_writer`. and got the following error:. NetCDF error: Variable 'time' not found in file <unknown> (NetCDF error code: -33)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/862
https://github.com/CliMA/Oceananigans.jl/issues/864:50,Testability,test,tests,50,"Reported by @sandreza . Must have missed this (or tests didn't cover this case) in PR https://github.com/CliMA/Oceananigans.jl/pull/851. <img width=""1324"" alt=""Screen Shot 2020-08-21 at 5 45 54 PM"" src=""https://user-images.githubusercontent.com/20099589/90943555-4ce1b680-e3e8-11ea-8831-e3d66509adf6.png"">",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/864
https://github.com/CliMA/Oceananigans.jl/issues/866:55,Deployability,update,update,55,"Reported by @sandreza. Not a problem yet but we should update `versioninfo_with_gpu()` in PR #860. I think we change `CUDA.context() |> CUDA.device |> CUDA.name` to just `CUDA.device() |> CUDA.name`. Even better, we could start making use of the new `CUDA.versioninfo()` which has lots more CUDA and GPU info. <img width=""1126"" alt=""Screen Shot 2020-08-21 at 10 11 58 PM"" src=""https://user-images.githubusercontent.com/20099589/91040039-92b2a080-e5db-11ea-8d72-d1bdfb2d7210.png"">",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/866
https://github.com/CliMA/Oceananigans.jl/pull/869:1022,Energy Efficiency,Power,Power,1022,"Converted `benchmark_static_ocean.jl` to do a strong scaling test on a 256³ simulation when `Threads.nthreads() > 1`. Results are pretty sweet for multithreading that we basically got for free from KernelAbstractions.jl. Not sure what kind of speedups to expect for multithreading though. Maybe @leios, @christophernhill, or @vchuravy have a better idea. Some results on number of threads and wall clock time per time step:. # Tartarus. ```zsh; #!/bin/zsh; for threads in 1 4 8 16 24 32 40; ~/julia-1.5.0/bin/julia --project -t $threads benchmark_static_ocean.jl; ```. ```; Julia 1.5.0 + Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz. 1 thread: 3.78 s; 4 threads: 1.35 s (2.8x); 8 threads: 839 ms (4.5x); 16 threads: 585 ms (6.5x); 24 threads: 551 ms (6.9x); 32 threads: 539 ms (7.0x); 40 threads: 483 ms (10.6x); 48 threads: 479 ms (10.7x); ```. # Satori. ```bash; #!/bin/bash; for threads in 1 4 8 16 32 64 128 160; do JULIA_NUM_THREADS=$threads julia --project benchmark_static_ocean.jl; done; ```. ```; Julia 1.4.1 + IBM Power System AC922 (8335-GTH). 1 thread: 5.13 s; 4 threads: 2.44 s (2.1x); 8 threads: 1.35 s (3.8x); 16 threads: 796 ms (6.4x); 32 threads: 637 ms (8.0x); 64 threads: 503 ms (10.2x); 128 threads: 501 ms (10.2x); 160 threads: 511 ms (10.0x); ```. A beautiful scene from Satori:. ![image](https://user-images.githubusercontent.com/20099589/91370150-96ad1100-e7db-11ea-9bf2-12e40de5ff93.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/869
https://github.com/CliMA/Oceananigans.jl/pull/869:61,Testability,test,test,61,"Converted `benchmark_static_ocean.jl` to do a strong scaling test on a 256³ simulation when `Threads.nthreads() > 1`. Results are pretty sweet for multithreading that we basically got for free from KernelAbstractions.jl. Not sure what kind of speedups to expect for multithreading though. Maybe @leios, @christophernhill, or @vchuravy have a better idea. Some results on number of threads and wall clock time per time step:. # Tartarus. ```zsh; #!/bin/zsh; for threads in 1 4 8 16 24 32 40; ~/julia-1.5.0/bin/julia --project -t $threads benchmark_static_ocean.jl; ```. ```; Julia 1.5.0 + Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz. 1 thread: 3.78 s; 4 threads: 1.35 s (2.8x); 8 threads: 839 ms (4.5x); 16 threads: 585 ms (6.5x); 24 threads: 551 ms (6.9x); 32 threads: 539 ms (7.0x); 40 threads: 483 ms (10.6x); 48 threads: 479 ms (10.7x); ```. # Satori. ```bash; #!/bin/bash; for threads in 1 4 8 16 32 64 128 160; do JULIA_NUM_THREADS=$threads julia --project benchmark_static_ocean.jl; done; ```. ```; Julia 1.4.1 + IBM Power System AC922 (8335-GTH). 1 thread: 5.13 s; 4 threads: 2.44 s (2.1x); 8 threads: 1.35 s (3.8x); 16 threads: 796 ms (6.4x); 32 threads: 637 ms (8.0x); 64 threads: 503 ms (10.2x); 128 threads: 501 ms (10.2x); 160 threads: 511 ms (10.0x); ```. A beautiful scene from Satori:. ![image](https://user-images.githubusercontent.com/20099589/91370150-96ad1100-e7db-11ea-9bf2-12e40de5ff93.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/869
https://github.com/CliMA/Oceananigans.jl/pull/870:60,Testability,benchmark,benchmarked,60,"Had some time to burn while waiting for stuff to train so I benchmarked some abstract operations:. Some outliers in there like `α * β - γ * δ / ζ` and `(u^2 + v^2 + w^2) / 2` so there should be some useful info. Tried to run on GPU but it wouldn't compile `α + β` even though it worked for me in the REPL :shrug: Worth trying again after #860. ```; Oceananigans v0.34.1 (DEVELOPMENT BRANCH); Julia Version 1.5.0; Commit 96786e22cc (2020-08-01 23:44 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Core(TM) i7-6700HQ CPU @ 2.60GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-9.0.1 (ORCJIT, skylake); ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────; Abstract operations benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 7.66s / 69.8% 6.85GiB / 89.5% ; Section ncalls time %tot avg alloc %tot avg; ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────; 32× 32× 32 [01] -α [CPU] 10 526μs 0.01% 52.6μs 29.2KiB 0.00% 2.92KiB; 32× 32× 32 [02] √ζ [CPU] 10 987μs 0.02% 98.7μs 29.2KiB 0.00% 2.92KiB; 32× 32× 32 [03] sin(β) [CPU] 10 6.97ms 0.13% 697μs 29.2KiB 0.00% 2.92KiB; 32× 32× 32 [04] cos(γ) [CPU] 10 8.24ms 0.15% 824μs 29.2KiB 0.00% 2.92KiB; 32× 32× 32 [05] exp(δ) [CPU] 10 7.06ms 0.13% 706μs 29.2KiB 0.00% 2.92KiB; 32× 32× 32 [06] tanh(ζ) [CPU] 10 13.9ms 0.26% 1.39ms 29.2KiB 0.00% 2.92KiB; 32× 32× 32 [07] α + β [CPU] 10 737μs 0.01% 73.7μs 29.2KiB 0.00% 2.92KiB; 32× 32× 32 [08] α + β - γ [CPU] 10 191ms 3.58% 19.1ms 370MiB 5.90% 37.0MiB; 32× 32× 32 [09] α * β * γ * δ [CPU] 10 857μs 0.02% 85.7μs 29.2KiB 0.00% 2.92KiB; 32× 32× 32 [10] α * β - γ * δ / ζ [CPU] 10 299ms 5.59% 29.9ms 340MiB 5.42% 34.0MiB; 32× 32× 32 [11] u^2 + v^2 [CPU] 10 1.30ms 0.02% 130μs 29.2KiB 0.00% 2.92KiB; ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/870
https://github.com/CliMA/Oceananigans.jl/pull/870:822,Testability,benchmark,benchmarks,822,"Had some time to burn while waiting for stuff to train so I benchmarked some abstract operations:. Some outliers in there like `α * β - γ * δ / ζ` and `(u^2 + v^2 + w^2) / 2` so there should be some useful info. Tried to run on GPU but it wouldn't compile `α + β` even though it worked for me in the REPL :shrug: Worth trying again after #860. ```; Oceananigans v0.34.1 (DEVELOPMENT BRANCH); Julia Version 1.5.0; Commit 96786e22cc (2020-08-01 23:44 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Core(TM) i7-6700HQ CPU @ 2.60GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-9.0.1 (ORCJIT, skylake); ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────; Abstract operations benchmarks Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 7.66s / 69.8% 6.85GiB / 89.5% ; Section ncalls time %tot avg alloc %tot avg; ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────; 32× 32× 32 [01] -α [CPU] 10 526μs 0.01% 52.6μs 29.2KiB 0.00% 2.92KiB; 32× 32× 32 [02] √ζ [CPU] 10 987μs 0.02% 98.7μs 29.2KiB 0.00% 2.92KiB; 32× 32× 32 [03] sin(β) [CPU] 10 6.97ms 0.13% 697μs 29.2KiB 0.00% 2.92KiB; 32× 32× 32 [04] cos(γ) [CPU] 10 8.24ms 0.15% 824μs 29.2KiB 0.00% 2.92KiB; 32× 32× 32 [05] exp(δ) [CPU] 10 7.06ms 0.13% 706μs 29.2KiB 0.00% 2.92KiB; 32× 32× 32 [06] tanh(ζ) [CPU] 10 13.9ms 0.26% 1.39ms 29.2KiB 0.00% 2.92KiB; 32× 32× 32 [07] α + β [CPU] 10 737μs 0.01% 73.7μs 29.2KiB 0.00% 2.92KiB; 32× 32× 32 [08] α + β - γ [CPU] 10 191ms 3.58% 19.1ms 370MiB 5.90% 37.0MiB; 32× 32× 32 [09] α * β * γ * δ [CPU] 10 857μs 0.02% 85.7μs 29.2KiB 0.00% 2.92KiB; 32× 32× 32 [10] α * β - γ * δ / ζ [CPU] 10 299ms 5.59% 29.9ms 340MiB 5.42% 34.0MiB; 32× 32× 32 [11] u^2 + v^2 [CPU] 10 1.30ms 0.02% 130μs 29.2KiB 0.00% 2.92KiB; ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/870
https://github.com/CliMA/Oceananigans.jl/issues/871:49,Testability,test,test,49,"Following what seems to be the convention, e.g. `test/test_grids.jl` should probably just be called `test/grids.jl`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/871
https://github.com/CliMA/Oceananigans.jl/issues/871:101,Testability,test,test,101,"Following what seems to be the convention, e.g. `test/test_grids.jl` should probably just be called `test/grids.jl`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/871
https://github.com/CliMA/Oceananigans.jl/pull/872:112,Deployability,integrat,integration,112,"This PR splits the tests into four test groups, selectable with the `TEST_GROUP` environment variable: `unit`, `integration`, `regression`, and `scripts`. Using `TEST_GROUP=all` (the default if `TEST_GROUP` is not defined) will run all tests. The purpose of this PR is to address long test build times (see #860) that time out at 50 minutes on Travis CI and at 60 minutes on GitLab CI by splitting tests into multiple jobs (i.e. building a job matrix) that each should individually run much faster. If the different jobs could be run in parallel this would speed up our test builds significantly, but alas we are stuck with free-tier CI pipelines so we can't run too many jobs in parallel and will probably end up waiting longer. But at least our jobs won't time out. In working on this PR I was also able to revive the Appveyor and Docker CI pipelines (I think Appveyor will only show up for future PRs). Resolves #139",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/872
https://github.com/CliMA/Oceananigans.jl/pull/872:637,Deployability,pipeline,pipelines,637,"This PR splits the tests into four test groups, selectable with the `TEST_GROUP` environment variable: `unit`, `integration`, `regression`, and `scripts`. Using `TEST_GROUP=all` (the default if `TEST_GROUP` is not defined) will run all tests. The purpose of this PR is to address long test build times (see #860) that time out at 50 minutes on Travis CI and at 60 minutes on GitLab CI by splitting tests into multiple jobs (i.e. building a job matrix) that each should individually run much faster. If the different jobs could be run in parallel this would speed up our test builds significantly, but alas we are stuck with free-tier CI pipelines so we can't run too many jobs in parallel and will probably end up waiting longer. But at least our jobs won't time out. In working on this PR I was also able to revive the Appveyor and Docker CI pipelines (I think Appveyor will only show up for future PRs). Resolves #139",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/872
https://github.com/CliMA/Oceananigans.jl/pull/872:843,Deployability,pipeline,pipelines,843,"This PR splits the tests into four test groups, selectable with the `TEST_GROUP` environment variable: `unit`, `integration`, `regression`, and `scripts`. Using `TEST_GROUP=all` (the default if `TEST_GROUP` is not defined) will run all tests. The purpose of this PR is to address long test build times (see #860) that time out at 50 minutes on Travis CI and at 60 minutes on GitLab CI by splitting tests into multiple jobs (i.e. building a job matrix) that each should individually run much faster. If the different jobs could be run in parallel this would speed up our test builds significantly, but alas we are stuck with free-tier CI pipelines so we can't run too many jobs in parallel and will probably end up waiting longer. But at least our jobs won't time out. In working on this PR I was also able to revive the Appveyor and Docker CI pipelines (I think Appveyor will only show up for future PRs). Resolves #139",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/872
https://github.com/CliMA/Oceananigans.jl/pull/872:112,Integrability,integrat,integration,112,"This PR splits the tests into four test groups, selectable with the `TEST_GROUP` environment variable: `unit`, `integration`, `regression`, and `scripts`. Using `TEST_GROUP=all` (the default if `TEST_GROUP` is not defined) will run all tests. The purpose of this PR is to address long test build times (see #860) that time out at 50 minutes on Travis CI and at 60 minutes on GitLab CI by splitting tests into multiple jobs (i.e. building a job matrix) that each should individually run much faster. If the different jobs could be run in parallel this would speed up our test builds significantly, but alas we are stuck with free-tier CI pipelines so we can't run too many jobs in parallel and will probably end up waiting longer. But at least our jobs won't time out. In working on this PR I was also able to revive the Appveyor and Docker CI pipelines (I think Appveyor will only show up for future PRs). Resolves #139",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/872
https://github.com/CliMA/Oceananigans.jl/pull/872:93,Modifiability,variab,variable,93,"This PR splits the tests into four test groups, selectable with the `TEST_GROUP` environment variable: `unit`, `integration`, `regression`, and `scripts`. Using `TEST_GROUP=all` (the default if `TEST_GROUP` is not defined) will run all tests. The purpose of this PR is to address long test build times (see #860) that time out at 50 minutes on Travis CI and at 60 minutes on GitLab CI by splitting tests into multiple jobs (i.e. building a job matrix) that each should individually run much faster. If the different jobs could be run in parallel this would speed up our test builds significantly, but alas we are stuck with free-tier CI pipelines so we can't run too many jobs in parallel and will probably end up waiting longer. But at least our jobs won't time out. In working on this PR I was also able to revive the Appveyor and Docker CI pipelines (I think Appveyor will only show up for future PRs). Resolves #139",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/872
https://github.com/CliMA/Oceananigans.jl/pull/872:19,Testability,test,tests,19,"This PR splits the tests into four test groups, selectable with the `TEST_GROUP` environment variable: `unit`, `integration`, `regression`, and `scripts`. Using `TEST_GROUP=all` (the default if `TEST_GROUP` is not defined) will run all tests. The purpose of this PR is to address long test build times (see #860) that time out at 50 minutes on Travis CI and at 60 minutes on GitLab CI by splitting tests into multiple jobs (i.e. building a job matrix) that each should individually run much faster. If the different jobs could be run in parallel this would speed up our test builds significantly, but alas we are stuck with free-tier CI pipelines so we can't run too many jobs in parallel and will probably end up waiting longer. But at least our jobs won't time out. In working on this PR I was also able to revive the Appveyor and Docker CI pipelines (I think Appveyor will only show up for future PRs). Resolves #139",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/872
https://github.com/CliMA/Oceananigans.jl/pull/872:35,Testability,test,test,35,"This PR splits the tests into four test groups, selectable with the `TEST_GROUP` environment variable: `unit`, `integration`, `regression`, and `scripts`. Using `TEST_GROUP=all` (the default if `TEST_GROUP` is not defined) will run all tests. The purpose of this PR is to address long test build times (see #860) that time out at 50 minutes on Travis CI and at 60 minutes on GitLab CI by splitting tests into multiple jobs (i.e. building a job matrix) that each should individually run much faster. If the different jobs could be run in parallel this would speed up our test builds significantly, but alas we are stuck with free-tier CI pipelines so we can't run too many jobs in parallel and will probably end up waiting longer. But at least our jobs won't time out. In working on this PR I was also able to revive the Appveyor and Docker CI pipelines (I think Appveyor will only show up for future PRs). Resolves #139",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/872
https://github.com/CliMA/Oceananigans.jl/pull/872:236,Testability,test,tests,236,"This PR splits the tests into four test groups, selectable with the `TEST_GROUP` environment variable: `unit`, `integration`, `regression`, and `scripts`. Using `TEST_GROUP=all` (the default if `TEST_GROUP` is not defined) will run all tests. The purpose of this PR is to address long test build times (see #860) that time out at 50 minutes on Travis CI and at 60 minutes on GitLab CI by splitting tests into multiple jobs (i.e. building a job matrix) that each should individually run much faster. If the different jobs could be run in parallel this would speed up our test builds significantly, but alas we are stuck with free-tier CI pipelines so we can't run too many jobs in parallel and will probably end up waiting longer. But at least our jobs won't time out. In working on this PR I was also able to revive the Appveyor and Docker CI pipelines (I think Appveyor will only show up for future PRs). Resolves #139",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/872
https://github.com/CliMA/Oceananigans.jl/pull/872:285,Testability,test,test,285,"This PR splits the tests into four test groups, selectable with the `TEST_GROUP` environment variable: `unit`, `integration`, `regression`, and `scripts`. Using `TEST_GROUP=all` (the default if `TEST_GROUP` is not defined) will run all tests. The purpose of this PR is to address long test build times (see #860) that time out at 50 minutes on Travis CI and at 60 minutes on GitLab CI by splitting tests into multiple jobs (i.e. building a job matrix) that each should individually run much faster. If the different jobs could be run in parallel this would speed up our test builds significantly, but alas we are stuck with free-tier CI pipelines so we can't run too many jobs in parallel and will probably end up waiting longer. But at least our jobs won't time out. In working on this PR I was also able to revive the Appveyor and Docker CI pipelines (I think Appveyor will only show up for future PRs). Resolves #139",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/872
https://github.com/CliMA/Oceananigans.jl/pull/872:398,Testability,test,tests,398,"This PR splits the tests into four test groups, selectable with the `TEST_GROUP` environment variable: `unit`, `integration`, `regression`, and `scripts`. Using `TEST_GROUP=all` (the default if `TEST_GROUP` is not defined) will run all tests. The purpose of this PR is to address long test build times (see #860) that time out at 50 minutes on Travis CI and at 60 minutes on GitLab CI by splitting tests into multiple jobs (i.e. building a job matrix) that each should individually run much faster. If the different jobs could be run in parallel this would speed up our test builds significantly, but alas we are stuck with free-tier CI pipelines so we can't run too many jobs in parallel and will probably end up waiting longer. But at least our jobs won't time out. In working on this PR I was also able to revive the Appveyor and Docker CI pipelines (I think Appveyor will only show up for future PRs). Resolves #139",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/872
https://github.com/CliMA/Oceananigans.jl/pull/872:570,Testability,test,test,570,"This PR splits the tests into four test groups, selectable with the `TEST_GROUP` environment variable: `unit`, `integration`, `regression`, and `scripts`. Using `TEST_GROUP=all` (the default if `TEST_GROUP` is not defined) will run all tests. The purpose of this PR is to address long test build times (see #860) that time out at 50 minutes on Travis CI and at 60 minutes on GitLab CI by splitting tests into multiple jobs (i.e. building a job matrix) that each should individually run much faster. If the different jobs could be run in parallel this would speed up our test builds significantly, but alas we are stuck with free-tier CI pipelines so we can't run too many jobs in parallel and will probably end up waiting longer. But at least our jobs won't time out. In working on this PR I was also able to revive the Appveyor and Docker CI pipelines (I think Appveyor will only show up for future PRs). Resolves #139",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/872
https://github.com/CliMA/Oceananigans.jl/issues/874:270,Testability,benchmark,benchmarks,270,With the arrival of `CUDA.versioninfo()` (see https://github.com/JuliaGPU/CUDA.jl/commit/f531c5f588164c2a577a7e669b37f51b3f84dd92) in CUDA.jl v1.1.0 we should probably make use of it in `Utils.versioninfo_with_gpu()` for NetCDF metadata (maximizes reproducibility?) and benchmarks.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/874
https://github.com/CliMA/Oceananigans.jl/pull/881:72,Testability,test,tests,72,"Last TODO item for the JOSS paper. Was going to include the convergence tests as part of `test_verification.jl` but in cleaning them up (mostly by relying on the version of Oceananigans in the repository, `using .ConvergenceTests` as a local module, and making sure legends don't block off the plots) I noticed that the 2D convergence tests are all failing now. Pretty sure this must be a stupid mistake as they were all converging correctly as of Oceananigans v0.30.0 but haven't tried to figure out what went wrong yet... Since they're kinda important now I'm thinking we should have a test job that just runs all the convergence tests, tests that the order of convergence is as expected, and produces all the convergence plots so we can look at them. We can do this once we've set up Buildkite somewhere (see also @simonbyrne's https://github.com/CliMA/slurm-buildkite). Also, @glwagner do we still need `analyze_single_forced_fixed_slip.jl` and `analyze_forced_fixed_slip_pressure.jl`? They're not mentioned in the convergence tests `README.md` so maybe we should remove them?. Resolves #873. # Convergence test plots. ![point_exponential_decay_time_stepper_convergence](https://user-images.githubusercontent.com/20099589/91511129-04753d80-e8ad-11ea-95a9-582b79da9dab.png). ![cosine_advection_diffusion_solutions](https://user-images.githubusercontent.com/20099589/91511137-09d28800-e8ad-11ea-9ac5-f978cd49ae5b.png). ![cosine_advection_diffusion_error_convergence](https://user-images.githubusercontent.com/20099589/91511140-0b9c4b80-e8ad-11ea-84ce-cb418b1971b0.png). ![gaussian_advection_diffusion_solutions](https://user-images.githubusercontent.com/20099589/91511147-0dfea580-e8ad-11ea-8c09-9816a687e67e.png). ![gaussian_advection_diffusion_error_convergence](https://user-images.githubusercontent.com/20099589/91511151-0f2fd280-e8ad-11ea-80c4-8b7920da8d64.png). ![two_dimensional_diffusion_convergence](https://user-images.githubusercontent.com/20099589/91511159-122ac300-e8ad-11ea-877e-251def",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/881
https://github.com/CliMA/Oceananigans.jl/pull/881:335,Testability,test,tests,335,"Last TODO item for the JOSS paper. Was going to include the convergence tests as part of `test_verification.jl` but in cleaning them up (mostly by relying on the version of Oceananigans in the repository, `using .ConvergenceTests` as a local module, and making sure legends don't block off the plots) I noticed that the 2D convergence tests are all failing now. Pretty sure this must be a stupid mistake as they were all converging correctly as of Oceananigans v0.30.0 but haven't tried to figure out what went wrong yet... Since they're kinda important now I'm thinking we should have a test job that just runs all the convergence tests, tests that the order of convergence is as expected, and produces all the convergence plots so we can look at them. We can do this once we've set up Buildkite somewhere (see also @simonbyrne's https://github.com/CliMA/slurm-buildkite). Also, @glwagner do we still need `analyze_single_forced_fixed_slip.jl` and `analyze_forced_fixed_slip_pressure.jl`? They're not mentioned in the convergence tests `README.md` so maybe we should remove them?. Resolves #873. # Convergence test plots. ![point_exponential_decay_time_stepper_convergence](https://user-images.githubusercontent.com/20099589/91511129-04753d80-e8ad-11ea-95a9-582b79da9dab.png). ![cosine_advection_diffusion_solutions](https://user-images.githubusercontent.com/20099589/91511137-09d28800-e8ad-11ea-9ac5-f978cd49ae5b.png). ![cosine_advection_diffusion_error_convergence](https://user-images.githubusercontent.com/20099589/91511140-0b9c4b80-e8ad-11ea-84ce-cb418b1971b0.png). ![gaussian_advection_diffusion_solutions](https://user-images.githubusercontent.com/20099589/91511147-0dfea580-e8ad-11ea-8c09-9816a687e67e.png). ![gaussian_advection_diffusion_error_convergence](https://user-images.githubusercontent.com/20099589/91511151-0f2fd280-e8ad-11ea-80c4-8b7920da8d64.png). ![two_dimensional_diffusion_convergence](https://user-images.githubusercontent.com/20099589/91511159-122ac300-e8ad-11ea-877e-251def",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/881
https://github.com/CliMA/Oceananigans.jl/pull/881:588,Testability,test,test,588,"Last TODO item for the JOSS paper. Was going to include the convergence tests as part of `test_verification.jl` but in cleaning them up (mostly by relying on the version of Oceananigans in the repository, `using .ConvergenceTests` as a local module, and making sure legends don't block off the plots) I noticed that the 2D convergence tests are all failing now. Pretty sure this must be a stupid mistake as they were all converging correctly as of Oceananigans v0.30.0 but haven't tried to figure out what went wrong yet... Since they're kinda important now I'm thinking we should have a test job that just runs all the convergence tests, tests that the order of convergence is as expected, and produces all the convergence plots so we can look at them. We can do this once we've set up Buildkite somewhere (see also @simonbyrne's https://github.com/CliMA/slurm-buildkite). Also, @glwagner do we still need `analyze_single_forced_fixed_slip.jl` and `analyze_forced_fixed_slip_pressure.jl`? They're not mentioned in the convergence tests `README.md` so maybe we should remove them?. Resolves #873. # Convergence test plots. ![point_exponential_decay_time_stepper_convergence](https://user-images.githubusercontent.com/20099589/91511129-04753d80-e8ad-11ea-95a9-582b79da9dab.png). ![cosine_advection_diffusion_solutions](https://user-images.githubusercontent.com/20099589/91511137-09d28800-e8ad-11ea-9ac5-f978cd49ae5b.png). ![cosine_advection_diffusion_error_convergence](https://user-images.githubusercontent.com/20099589/91511140-0b9c4b80-e8ad-11ea-84ce-cb418b1971b0.png). ![gaussian_advection_diffusion_solutions](https://user-images.githubusercontent.com/20099589/91511147-0dfea580-e8ad-11ea-8c09-9816a687e67e.png). ![gaussian_advection_diffusion_error_convergence](https://user-images.githubusercontent.com/20099589/91511151-0f2fd280-e8ad-11ea-80c4-8b7920da8d64.png). ![two_dimensional_diffusion_convergence](https://user-images.githubusercontent.com/20099589/91511159-122ac300-e8ad-11ea-877e-251def",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/881
https://github.com/CliMA/Oceananigans.jl/pull/881:632,Testability,test,tests,632,"Last TODO item for the JOSS paper. Was going to include the convergence tests as part of `test_verification.jl` but in cleaning them up (mostly by relying on the version of Oceananigans in the repository, `using .ConvergenceTests` as a local module, and making sure legends don't block off the plots) I noticed that the 2D convergence tests are all failing now. Pretty sure this must be a stupid mistake as they were all converging correctly as of Oceananigans v0.30.0 but haven't tried to figure out what went wrong yet... Since they're kinda important now I'm thinking we should have a test job that just runs all the convergence tests, tests that the order of convergence is as expected, and produces all the convergence plots so we can look at them. We can do this once we've set up Buildkite somewhere (see also @simonbyrne's https://github.com/CliMA/slurm-buildkite). Also, @glwagner do we still need `analyze_single_forced_fixed_slip.jl` and `analyze_forced_fixed_slip_pressure.jl`? They're not mentioned in the convergence tests `README.md` so maybe we should remove them?. Resolves #873. # Convergence test plots. ![point_exponential_decay_time_stepper_convergence](https://user-images.githubusercontent.com/20099589/91511129-04753d80-e8ad-11ea-95a9-582b79da9dab.png). ![cosine_advection_diffusion_solutions](https://user-images.githubusercontent.com/20099589/91511137-09d28800-e8ad-11ea-9ac5-f978cd49ae5b.png). ![cosine_advection_diffusion_error_convergence](https://user-images.githubusercontent.com/20099589/91511140-0b9c4b80-e8ad-11ea-84ce-cb418b1971b0.png). ![gaussian_advection_diffusion_solutions](https://user-images.githubusercontent.com/20099589/91511147-0dfea580-e8ad-11ea-8c09-9816a687e67e.png). ![gaussian_advection_diffusion_error_convergence](https://user-images.githubusercontent.com/20099589/91511151-0f2fd280-e8ad-11ea-80c4-8b7920da8d64.png). ![two_dimensional_diffusion_convergence](https://user-images.githubusercontent.com/20099589/91511159-122ac300-e8ad-11ea-877e-251def",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/881
https://github.com/CliMA/Oceananigans.jl/pull/881:639,Testability,test,tests,639,"Last TODO item for the JOSS paper. Was going to include the convergence tests as part of `test_verification.jl` but in cleaning them up (mostly by relying on the version of Oceananigans in the repository, `using .ConvergenceTests` as a local module, and making sure legends don't block off the plots) I noticed that the 2D convergence tests are all failing now. Pretty sure this must be a stupid mistake as they were all converging correctly as of Oceananigans v0.30.0 but haven't tried to figure out what went wrong yet... Since they're kinda important now I'm thinking we should have a test job that just runs all the convergence tests, tests that the order of convergence is as expected, and produces all the convergence plots so we can look at them. We can do this once we've set up Buildkite somewhere (see also @simonbyrne's https://github.com/CliMA/slurm-buildkite). Also, @glwagner do we still need `analyze_single_forced_fixed_slip.jl` and `analyze_forced_fixed_slip_pressure.jl`? They're not mentioned in the convergence tests `README.md` so maybe we should remove them?. Resolves #873. # Convergence test plots. ![point_exponential_decay_time_stepper_convergence](https://user-images.githubusercontent.com/20099589/91511129-04753d80-e8ad-11ea-95a9-582b79da9dab.png). ![cosine_advection_diffusion_solutions](https://user-images.githubusercontent.com/20099589/91511137-09d28800-e8ad-11ea-9ac5-f978cd49ae5b.png). ![cosine_advection_diffusion_error_convergence](https://user-images.githubusercontent.com/20099589/91511140-0b9c4b80-e8ad-11ea-84ce-cb418b1971b0.png). ![gaussian_advection_diffusion_solutions](https://user-images.githubusercontent.com/20099589/91511147-0dfea580-e8ad-11ea-8c09-9816a687e67e.png). ![gaussian_advection_diffusion_error_convergence](https://user-images.githubusercontent.com/20099589/91511151-0f2fd280-e8ad-11ea-80c4-8b7920da8d64.png). ![two_dimensional_diffusion_convergence](https://user-images.githubusercontent.com/20099589/91511159-122ac300-e8ad-11ea-877e-251def",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/881
https://github.com/CliMA/Oceananigans.jl/pull/881:1031,Testability,test,tests,1031,"for the JOSS paper. Was going to include the convergence tests as part of `test_verification.jl` but in cleaning them up (mostly by relying on the version of Oceananigans in the repository, `using .ConvergenceTests` as a local module, and making sure legends don't block off the plots) I noticed that the 2D convergence tests are all failing now. Pretty sure this must be a stupid mistake as they were all converging correctly as of Oceananigans v0.30.0 but haven't tried to figure out what went wrong yet... Since they're kinda important now I'm thinking we should have a test job that just runs all the convergence tests, tests that the order of convergence is as expected, and produces all the convergence plots so we can look at them. We can do this once we've set up Buildkite somewhere (see also @simonbyrne's https://github.com/CliMA/slurm-buildkite). Also, @glwagner do we still need `analyze_single_forced_fixed_slip.jl` and `analyze_forced_fixed_slip_pressure.jl`? They're not mentioned in the convergence tests `README.md` so maybe we should remove them?. Resolves #873. # Convergence test plots. ![point_exponential_decay_time_stepper_convergence](https://user-images.githubusercontent.com/20099589/91511129-04753d80-e8ad-11ea-95a9-582b79da9dab.png). ![cosine_advection_diffusion_solutions](https://user-images.githubusercontent.com/20099589/91511137-09d28800-e8ad-11ea-9ac5-f978cd49ae5b.png). ![cosine_advection_diffusion_error_convergence](https://user-images.githubusercontent.com/20099589/91511140-0b9c4b80-e8ad-11ea-84ce-cb418b1971b0.png). ![gaussian_advection_diffusion_solutions](https://user-images.githubusercontent.com/20099589/91511147-0dfea580-e8ad-11ea-8c09-9816a687e67e.png). ![gaussian_advection_diffusion_error_convergence](https://user-images.githubusercontent.com/20099589/91511151-0f2fd280-e8ad-11ea-80c4-8b7920da8d64.png). ![two_dimensional_diffusion_convergence](https://user-images.githubusercontent.com/20099589/91511159-122ac300-e8ad-11ea-877e-251defc28879.png). !",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/881
https://github.com/CliMA/Oceananigans.jl/pull/881:1111,Testability,test,test,1111,"l` but in cleaning them up (mostly by relying on the version of Oceananigans in the repository, `using .ConvergenceTests` as a local module, and making sure legends don't block off the plots) I noticed that the 2D convergence tests are all failing now. Pretty sure this must be a stupid mistake as they were all converging correctly as of Oceananigans v0.30.0 but haven't tried to figure out what went wrong yet... Since they're kinda important now I'm thinking we should have a test job that just runs all the convergence tests, tests that the order of convergence is as expected, and produces all the convergence plots so we can look at them. We can do this once we've set up Buildkite somewhere (see also @simonbyrne's https://github.com/CliMA/slurm-buildkite). Also, @glwagner do we still need `analyze_single_forced_fixed_slip.jl` and `analyze_forced_fixed_slip_pressure.jl`? They're not mentioned in the convergence tests `README.md` so maybe we should remove them?. Resolves #873. # Convergence test plots. ![point_exponential_decay_time_stepper_convergence](https://user-images.githubusercontent.com/20099589/91511129-04753d80-e8ad-11ea-95a9-582b79da9dab.png). ![cosine_advection_diffusion_solutions](https://user-images.githubusercontent.com/20099589/91511137-09d28800-e8ad-11ea-9ac5-f978cd49ae5b.png). ![cosine_advection_diffusion_error_convergence](https://user-images.githubusercontent.com/20099589/91511140-0b9c4b80-e8ad-11ea-84ce-cb418b1971b0.png). ![gaussian_advection_diffusion_solutions](https://user-images.githubusercontent.com/20099589/91511147-0dfea580-e8ad-11ea-8c09-9816a687e67e.png). ![gaussian_advection_diffusion_error_convergence](https://user-images.githubusercontent.com/20099589/91511151-0f2fd280-e8ad-11ea-80c4-8b7920da8d64.png). ![two_dimensional_diffusion_convergence](https://user-images.githubusercontent.com/20099589/91511159-122ac300-e8ad-11ea-877e-251defc28879.png). ![taylor_green_convergence](https://user-images.githubusercontent.com/20099589/91511163-12c3598",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/881
https://github.com/CliMA/Oceananigans.jl/issues/882:571,Availability,Error,Error,571,"Yesterday, in https://github.com/openjournals/joss-reviews/issues/2018, I mentioned some failing tests on GPU. Since then, I tried to reproduce them in a clean and up-to-date environment but I now have issues even to install CUDA.jl. I'm suspecting a problem with my CUDA setup, and I don't really have the time nor the need to look into this. I pasted below the tracebacks I got a few days ago, just in case there is something useful for you in it, but don't feel any obligation to look into this issue that I can't reproduce. ```; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136; Test threw exception; Expression: time_step_with_forcing_functions(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103; [2] macro expansion at /home/ancellin/.julia/packages/LLVM/KITdB/src/util.jl:114 [inlined]; [3] LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [7] macro expansion at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:254 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [9] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:748,Availability,error,error,748,"Yesterday, in https://github.com/openjournals/joss-reviews/issues/2018, I mentioned some failing tests on GPU. Since then, I tried to reproduce them in a clean and up-to-date environment but I now have issues even to install CUDA.jl. I'm suspecting a problem with my CUDA setup, and I don't really have the time nor the need to look into this. I pasted below the tracebacks I got a few days ago, just in case there is something useful for you in it, but don't feel any obligation to look into this issue that I can't reproduce. ```; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136; Test threw exception; Expression: time_step_with_forcing_functions(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103; [2] macro expansion at /home/ancellin/.julia/packages/LLVM/KITdB/src/util.jl:114 [inlined]; [3] LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [7] macro expansion at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:254 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [9] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:38063,Availability,Error,Error,38063,"FTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_forcing_functions(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:21; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137; Test threw exception; Expression: time_step_with_parameterized_forcing(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103; [2] macro expansion at /home/ancellin/.julia/packages/LLVM/KITdB/src/util.jl:114 [inlined]; [3] LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:38244,Availability,error,error,38244,"ages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_forcing_functions(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:21; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137; Test threw exception; Expression: time_step_with_parameterized_forcing(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103; [2] macro expansion at /home/ancellin/.julia/packages/LLVM/KITdB/src/util.jl:114 [inlined]; [3] LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [7] macro expansion at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:254 [inlined]; [8] macro e",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:76931,Availability,Error,Error,76931,"FFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_parameterized_forcing(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:40; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; NetCDF [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:524; Got exception outside of a @test; MethodError: no method matching device(::CuContext); Closest candidates are:; device() at /home/ancellin/.julia/packages/CUDA/d6WNR/src/state.jl:225; Stacktrace:; [1] |>(::CuContext, ::typeof(CUDA.device)) at ./operators.jl:823; [2] versioninfo_with_gpu() at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/Utils/versioninfo.jl:9; [3] write_grid_and_attributes(::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Cell,Cell,OffsetArray{Float64,3,CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.Bo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:118275,Availability,Error,Error,118275,t/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean time: 12.156 ms (0.00% GC); maximum time: 14.535 ms (0.00% GC); --------------; samples: 412; evals/sample: 1; Test Summary: | Pass Fail Error Broken Total; Oceananigans | 1579 4 3 2 1588; Grids | 106 106; Operators | 146 146; Boundary conditions | 142 142; Fields | 198 198; Halo regions | 40 40; Solvers | 22 1 23; Pressure solvers | 152 152; Coriolis | 44 44; Buoyancy | 70 70; Surface waves | 1 1; Models | 12 12; Simulations | 26 26; Time stepping | 33 1 34; Time stepping with boundary conditions | 122 122; Forcing | 12 2 14; Forcing function initialization | 5 5; Forcing function time stepping [GPU] | 7 2 9; Turbulence closures | 46 46; Dynamics | 18 18; Diagnostics | 22 22; Output writers | 80 1 81; NetCDF [GPU] | 1 1; JLD2 [GPU] | 9 9; Checkpointer [GPU] | 71 71; Abstract operations | 258 258; Regression | 20 20; Examples | 6 6; Verification | 1 1; Performance benchmarks | 2 4 6; Performance benchmark scripts | 4 4; Static ocean benchmark | 1 1; Channel benchmark | 1 1; Turbulence closures benchmark | 1 1; Tracers benchmark | 1 1; Selected performance benchmarks | 2 2; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:118888,Availability,Checkpoint,Checkpointer,118888,t/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean time: 12.156 ms (0.00% GC); maximum time: 14.535 ms (0.00% GC); --------------; samples: 412; evals/sample: 1; Test Summary: | Pass Fail Error Broken Total; Oceananigans | 1579 4 3 2 1588; Grids | 106 106; Operators | 146 146; Boundary conditions | 142 142; Fields | 198 198; Halo regions | 40 40; Solvers | 22 1 23; Pressure solvers | 152 152; Coriolis | 44 44; Buoyancy | 70 70; Surface waves | 1 1; Models | 12 12; Simulations | 26 26; Time stepping | 33 1 34; Time stepping with boundary conditions | 122 122; Forcing | 12 2 14; Forcing function initialization | 5 5; Forcing function time stepping [GPU] | 7 2 9; Turbulence closures | 46 46; Dynamics | 18 18; Diagnostics | 22 22; Output writers | 80 1 81; NetCDF [GPU] | 1 1; JLD2 [GPU] | 9 9; Checkpointer [GPU] | 71 71; Abstract operations | 258 258; Regression | 20 20; Examples | 6 6; Verification | 1 1; Performance benchmarks | 2 4 6; Performance benchmark scripts | 4 4; Static ocean benchmark | 1 1; Channel benchmark | 1 1; Turbulence closures benchmark | 1 1; Tracers benchmark | 1 1; Selected performance benchmarks | 2 2; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:217,Deployability,install,install,217,"Yesterday, in https://github.com/openjournals/joss-reviews/issues/2018, I mentioned some failing tests on GPU. Since then, I tried to reproduce them in a clean and up-to-date environment but I now have issues even to install CUDA.jl. I'm suspecting a problem with my CUDA setup, and I don't really have the time nor the need to look into this. I pasted below the tracebacks I got a few days ago, just in case there is something useful for you in it, but don't feel any obligation to look into this issue that I can't reproduce. ```; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136; Test threw exception; Expression: time_step_with_forcing_functions(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103; [2] macro expansion at /home/ancellin/.julia/packages/LLVM/KITdB/src/util.jl:114 [inlined]; [3] LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [7] macro expansion at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:254 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [9] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:11969,Integrability,depend,dependencies,11969,"{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{var""#Fu#80"",var""#Fv#81"",var""#Fw#82"",typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}; name::String, kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/CUDA/d6WNR/src/compiler/execution.jl:298; [24] macro expansion at /home/ancellin/.julia/packages/CUDA/d6WNR/src/compiler/execution.jl:109 [inlined]; [25] (::KernelAbstractions.Kernel{KernelAbstractions.CUDADevice,KernelAbstractions.NDIteration.StaticSize{(16, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!)})(::OffsetArray{Float64,3,CuArray{Float64,3}}, ::Vararg{Any,N} where N; ndrange::Nothing, dependencies::KernelAbstractions.CudaEvent, workgroupsize::Nothing, progress::Function) at /home/ancellin/.julia/packages/KernelAbstractions/yw9SF/src/backends/cuda.jl:211; [26] calculate_interior_tendency_contributions!(::NamedTuple{(:u, :v, :w, :T, :S),NTuple{5,OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::GPU, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::CenteredSecondOrder, ::Nothing, ::SeawaterBuoyancy{Float64,LinearEquationOfState{Float64},Nothing,Nothing}, ::Nothing, ::IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}}, ::NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::OffsetAr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:50335,Integrability,depend,dependencies,50335,", :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}; name::String, kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/CUDA/d6WNR/src/compiler/execution.jl:298; [24] macro expansion at /home/ancellin/.julia/packages/CUDA/d6WNR/src/compiler/execution.jl:109 [inlined]; [25] (::KernelAbstractions.Kernel{KernelAbstractions.CUDADevice,KernelAbstractions.NDIteration.StaticSize{(16, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!)})(::OffsetArray{Float64,3,CuArray{Float64,3}}, ::Vararg{Any,N} where N; ndrange::Nothing, dependencies::KernelAbstractions.CudaEvent, workgroupsize::Nothing, progress::Function) at /home/ancellin/.julia/packages/KernelAbstractions/yw9SF/src/backends/cuda.jl:211; [26] calculate_interior_tendency_contributions!(::NamedTuple{(:u, :v, :w, :T, :S),NTuple{5,OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::GPU, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::CenteredSecondOrder, ::Nothing, ::SeawaterBuoyancy{Float64,LinearEquationOfState{Float64},Nothing,Nothing}, ::Nothing, ::IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}}, ::NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::OffsetAr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:41318,Modifiability,Parameteriz,ParameterizedForcing,41318,"(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/CUDA/d6WNR/src/compiler/execution.jl:310; [13] #87 at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:21 [inlined]; [14] get!(::GPUCompiler.var""#87#88""{Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}},typeof(CUDA._cufunction),GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:41388,Modifiability,Parameteriz,ParameterizedForcing,41388,"(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/CUDA/d6WNR/src/compiler/execution.jl:310; [13] #87 at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:21 [inlined]; [14] get!(::GPUCompiler.var""#87#88""{Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}},typeof(CUDA._cufunction),GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:41458,Modifiability,Parameteriz,ParameterizedForcing,41458,"(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/CUDA/d6WNR/src/compiler/execution.jl:310; [13] #87 at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:21 [inlined]; [14] get!(::GPUCompiler.var""#87#88""{Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}},typeof(CUDA._cufunction),GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:43437,Modifiability,Parameteriz,ParameterizedForcing,43437,"(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}}, ::Dict{UInt64,Any}, ::UInt64) at ./dict.jl:452; [15] macro expansion at ./lock.jl:183 [inlined]; [16] check_cache(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_cal",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:43507,Modifiability,Parameteriz,ParameterizedForcing,43507,"(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}}, ::Dict{UInt64,Any}, ::UInt64) at ./dict.jl:452; [15] macro expansion at ./lock.jl:183 [inlined]; [16] check_cache(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_cal",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:43577,Modifiability,Parameteriz,ParameterizedForcing,43577,"(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}}, ::Dict{UInt64,Any}, ::UInt64) at ./dict.jl:452; [15] macro expansion at ./lock.jl:183 [inlined]; [16] check_cache(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_cal",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:45289,Modifiability,Parameteriz,ParameterizedForcing,45289,"(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [17] + at ./int.jl:53 [inlined]; [18] hash_64_64 at ./hashing.jl:35 [inlined]; [19] hash_uint64 at ./hashing.jl:62 [inlined]; [20] hx at ./float.jl:568 [inlined]; [21] hash at ./float.jl:571 [inlined]; [22] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:45359,Modifiability,Parameteriz,ParameterizedForcing,45359,"(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [17] + at ./int.jl:53 [inlined]; [18] hash_64_64 at ./hashing.jl:35 [inlined]; [19] hash_uint64 at ./hashing.jl:62 [inlined]; [20] hx at ./float.jl:568 [inlined]; [21] hash at ./float.jl:571 [inlined]; [22] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:45429,Modifiability,Parameteriz,ParameterizedForcing,45429,"(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [17] + at ./int.jl:53 [inlined]; [18] hash_64_64 at ./hashing.jl:35 [inlined]; [19] hash_uint64 at ./hashing.jl:62 [inlined]; [20] hx at ./float.jl:568 [inlined]; [21] hash at ./float.jl:571 [inlined]; [22] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:47429,Modifiability,Parameteriz,ParameterizedForcing,47429,"(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:0; [23] cufunction(::typeof(Cassette.overdub), ::Type{Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(O",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:47499,Modifiability,Parameteriz,ParameterizedForcing,47499,"(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:0; [23] cufunction(::typeof(Cassette.overdub), ::Type{Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(O",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:47569,Modifiability,Parameteriz,ParameterizedForcing,47569,"(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:0; [23] cufunction(::typeof(Cassette.overdub), ::Type{Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(O",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:49313,Modifiability,Parameteriz,ParameterizedForcing,49313,"(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}; name::String, kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/CUDA/d6WNR/src/compiler/execution.jl:298; [24] macro expansion at /home/ancellin/.julia/packages/CUDA/d6WNR/src/compiler/execution.jl:109 [inlined]; [25] (::KernelAbstractions.Kernel{KernelAbstractions.CUDADevice,KernelAbstractions.NDIteration.StaticSize{(16, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!)})(::OffsetArray{Float64,3,CuArray{Float64,3}}, ::Vararg{Any,N} where N; ndrange::Nothing, dependencies::KernelAbstractions.CudaEvent, workgroupsize::Nothin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:49383,Modifiability,Parameteriz,ParameterizedForcing,49383,"(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}; name::String, kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/CUDA/d6WNR/src/compiler/execution.jl:298; [24] macro expansion at /home/ancellin/.julia/packages/CUDA/d6WNR/src/compiler/execution.jl:109 [inlined]; [25] (::KernelAbstractions.Kernel{KernelAbstractions.CUDADevice,KernelAbstractions.NDIteration.StaticSize{(16, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!)})(::OffsetArray{Float64,3,CuArray{Float64,3}}, ::Vararg{Any,N} where N; ndrange::Nothing, dependencies::KernelAbstractions.CudaEvent, workgroupsize::Nothin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:49453,Modifiability,Parameteriz,ParameterizedForcing,49453,"(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}; name::String, kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/CUDA/d6WNR/src/compiler/execution.jl:298; [24] macro expansion at /home/ancellin/.julia/packages/CUDA/d6WNR/src/compiler/execution.jl:109 [inlined]; [25] (::KernelAbstractions.Kernel{KernelAbstractions.CUDADevice,KernelAbstractions.NDIteration.StaticSize{(16, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!)})(::OffsetArray{Float64,3,CuArray{Float64,3}}, ::Vararg{Any,N} where N; ndrange::Nothing, dependencies::KernelAbstractions.CudaEvent, workgroupsize::Nothin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:51383,Modifiability,Parameteriz,ParameterizedForcing,51383,"(Oceananigans.TimeSteppers.gpu_calculate_Gu!)})(::OffsetArray{Float64,3,CuArray{Float64,3}}, ::Vararg{Any,N} where N; ndrange::Nothing, dependencies::KernelAbstractions.CudaEvent, workgroupsize::Nothing, progress::Function) at /home/ancellin/.julia/packages/KernelAbstractions/yw9SF/src/backends/cuda.jl:211; [26] calculate_interior_tendency_contributions!(::NamedTuple{(:u, :v, :w, :T, :S),NTuple{5,OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::GPU, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::CenteredSecondOrder, ::Nothing, ::SeawaterBuoyancy{Float64,LinearEquationOfState{Float64},Nothing,Nothing}, ::Nothing, ::IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}}, ::NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::OffsetArray{Float64,3,CuArray{Float64,3}}, ::Nothing, ::NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}}, ::Clock{Float64}) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/time_stepping_kernels.jl:18; [27] calculate_tendencies!(::NamedTuple{(:u, :v, :w, :T, :S),NTuple{5,OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::NamedTuple{",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:51453,Modifiability,Parameteriz,ParameterizedForcing,51453,"(Oceananigans.TimeSteppers.gpu_calculate_Gu!)})(::OffsetArray{Float64,3,CuArray{Float64,3}}, ::Vararg{Any,N} where N; ndrange::Nothing, dependencies::KernelAbstractions.CudaEvent, workgroupsize::Nothing, progress::Function) at /home/ancellin/.julia/packages/KernelAbstractions/yw9SF/src/backends/cuda.jl:211; [26] calculate_interior_tendency_contributions!(::NamedTuple{(:u, :v, :w, :T, :S),NTuple{5,OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::GPU, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::CenteredSecondOrder, ::Nothing, ::SeawaterBuoyancy{Float64,LinearEquationOfState{Float64},Nothing,Nothing}, ::Nothing, ::IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}}, ::NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::OffsetArray{Float64,3,CuArray{Float64,3}}, ::Nothing, ::NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}}, ::Clock{Float64}) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/time_stepping_kernels.jl:18; [27] calculate_tendencies!(::NamedTuple{(:u, :v, :w, :T, :S),NTuple{5,OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::NamedTuple{",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:51523,Modifiability,Parameteriz,ParameterizedForcing,51523,"(Oceananigans.TimeSteppers.gpu_calculate_Gu!)})(::OffsetArray{Float64,3,CuArray{Float64,3}}, ::Vararg{Any,N} where N; ndrange::Nothing, dependencies::KernelAbstractions.CudaEvent, workgroupsize::Nothing, progress::Function) at /home/ancellin/.julia/packages/KernelAbstractions/yw9SF/src/backends/cuda.jl:211; [26] calculate_interior_tendency_contributions!(::NamedTuple{(:u, :v, :w, :T, :S),NTuple{5,OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::GPU, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::CenteredSecondOrder, ::Nothing, ::SeawaterBuoyancy{Float64,LinearEquationOfState{Float64},Nothing,Nothing}, ::Nothing, ::IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}}, ::NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::OffsetArray{Float64,3,CuArray{Float64,3}}, ::Nothing, ::NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}}, ::Clock{Float64}) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/time_stepping_kernels.jl:18; [27] calculate_tendencies!(::NamedTuple{(:u, :v, :w, :T, :S),NTuple{5,OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuArray{Float64,3}},OffsetArray{Float64,3,CuArray{Float64,3}}}}, ::NamedTuple{",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:63192,Modifiability,Parameteriz,ParameterizedForcing,63192,"ditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Cell,Cell,OffsetArray{Float64,3,CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},CenteredSecondOrder,PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CuArray{Float64,3},CuArray{Float64,3},CuArray{Float64,3}}},CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/generic_ti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:63262,Modifiability,Parameteriz,ParameterizedForcing,63262,"ditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Cell,Cell,OffsetArray{Float64,3,CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},CenteredSecondOrder,PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CuArray{Float64,3},CuArray{Float64,3},CuArray{Float64,3}}},CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/generic_ti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:63332,Modifiability,Parameteriz,ParameterizedForcing,63332,"ditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Cell,Cell,OffsetArray{Float64,3,CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},CenteredSecondOrder,PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CuArray{Float64,3},CuArray{Float64,3},CuArray{Float64,3}}},CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/generic_ti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:75138,Modifiability,Parameteriz,ParameterizedForcing,75138,"tions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,; Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Cell,Cell,OffsetArray{Float64,3,CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},CenteredSecondOrder,PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CuArray{Float64,3},CuArray{Float64,3},CuArray{Float64,3}}},CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:75208,Modifiability,Parameteriz,ParameterizedForcing,75208,"tions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,; Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Cell,Cell,OffsetArray{Float64,3,CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},CenteredSecondOrder,PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CuArray{Float64,3},CuArray{Float64,3},CuArray{Float64,3}}},CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:75278,Modifiability,Parameteriz,ParameterizedForcing,75278,"tions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,; Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Cell,Cell,OffsetArray{Float64,3,CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},CenteredSecondOrder,PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CuArray{Float64,3},CuArray{Float64,3},CuArray{Float64,3}}},CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:2003,Performance,optimiz,optimize,2003," LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [7] macro expansion at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:254 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [9] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:250; [10] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [11] compile at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [12] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHoo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:2283,Performance,optimiz,optimize,2283,"M_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [7] macro expansion at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:254 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [9] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:250; [10] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [11] compile at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [12] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Ce",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:4300,Performance,cache,cache,4300,"64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{var""#Fu#80"",var""#Fv#81"",var""#Fw#82"",typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/CUDA/d6WNR/src/compiler/execution.jl:310; [13] #87 at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:21 [inlined]; [14] get!(::GPUCompiler.var""#87#88""{Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}},typeof(CUDA._cufunction),GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiff",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:7848,Performance,cache,cache,7848,"StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{var""#Fu#80"",var""#Fv#81"",var""#Fw#82"",typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [17] + at ./int.jl:53 [inlined]; [18] hash_64_64 at ./hashing.jl:35 [inlined]; [19] hash_uint64 at ./hashing.jl:62 [inlined]; [20] hx at ./float.jl:568 [inlined]; [21] hash at ./float.jl:571 [inlined]; [22] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrec",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:9814,Performance,cache,cache,9814,"StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{var""#Fu#80"",var""#Fv#81"",var""#Fw#82"",typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:0; [23] cufunction(::typeof(Cassette.overdub), ::Type{Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},Offset",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:39499,Performance,optimiz,optimize,39499," LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [7] macro expansion at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:254 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [9] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:250; [10] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [11] compile at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [12] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHoo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:39779,Performance,optimiz,optimize,39779,"M_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [7] macro expansion at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:254 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [9] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:250; [10] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [11] compile at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [12] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Ce",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:41970,Performance,cache,cache,41970,"iceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/CUDA/d6WNR/src/compiler/execution.jl:310; [13] #87 at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:21 [inlined]; [14] get!(::GPUCompiler.var""#87#88""{Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}},typeof(CUDA._cufunction),GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiff",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:45866,Performance,cache,cache,45866,"loat64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [17] + at ./int.jl:53 [inlined]; [18] hash_64_64 at ./hashing.jl:35 [inlined]; [19] hash_uint64 at ./hashing.jl:62 [inlined]; [20] hx at ./float.jl:568 [inlined]; [21] hash at ./float.jl:571 [inlined]; [22] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrec",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:48006,Performance,cache,cache,48006,"loat64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:0; [23] cufunction(::typeof(Cassette.overdub), ::Type{Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},Offset",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:119003,Performance,Perform,Performance,119003,t/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean time: 12.156 ms (0.00% GC); maximum time: 14.535 ms (0.00% GC); --------------; samples: 412; evals/sample: 1; Test Summary: | Pass Fail Error Broken Total; Oceananigans | 1579 4 3 2 1588; Grids | 106 106; Operators | 146 146; Boundary conditions | 142 142; Fields | 198 198; Halo regions | 40 40; Solvers | 22 1 23; Pressure solvers | 152 152; Coriolis | 44 44; Buoyancy | 70 70; Surface waves | 1 1; Models | 12 12; Simulations | 26 26; Time stepping | 33 1 34; Time stepping with boundary conditions | 122 122; Forcing | 12 2 14; Forcing function initialization | 5 5; Forcing function time stepping [GPU] | 7 2 9; Turbulence closures | 46 46; Dynamics | 18 18; Diagnostics | 22 22; Output writers | 80 1 81; NetCDF [GPU] | 1 1; JLD2 [GPU] | 9 9; Checkpointer [GPU] | 71 71; Abstract operations | 258 258; Regression | 20 20; Examples | 6 6; Verification | 1 1; Performance benchmarks | 2 4 6; Performance benchmark scripts | 4 4; Static ocean benchmark | 1 1; Channel benchmark | 1 1; Turbulence closures benchmark | 1 1; Tracers benchmark | 1 1; Selected performance benchmarks | 2 2; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:119035,Performance,Perform,Performance,119035,t/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean time: 12.156 ms (0.00% GC); maximum time: 14.535 ms (0.00% GC); --------------; samples: 412; evals/sample: 1; Test Summary: | Pass Fail Error Broken Total; Oceananigans | 1579 4 3 2 1588; Grids | 106 106; Operators | 146 146; Boundary conditions | 142 142; Fields | 198 198; Halo regions | 40 40; Solvers | 22 1 23; Pressure solvers | 152 152; Coriolis | 44 44; Buoyancy | 70 70; Surface waves | 1 1; Models | 12 12; Simulations | 26 26; Time stepping | 33 1 34; Time stepping with boundary conditions | 122 122; Forcing | 12 2 14; Forcing function initialization | 5 5; Forcing function time stepping [GPU] | 7 2 9; Turbulence closures | 46 46; Dynamics | 18 18; Diagnostics | 22 22; Output writers | 80 1 81; NetCDF [GPU] | 1 1; JLD2 [GPU] | 9 9; Checkpointer [GPU] | 71 71; Abstract operations | 258 258; Regression | 20 20; Examples | 6 6; Verification | 1 1; Performance benchmarks | 2 4 6; Performance benchmark scripts | 4 4; Static ocean benchmark | 1 1; Channel benchmark | 1 1; Turbulence closures benchmark | 1 1; Tracers benchmark | 1 1; Selected performance benchmarks | 2 2; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:119198,Performance,perform,performance,119198,t/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean time: 12.156 ms (0.00% GC); maximum time: 14.535 ms (0.00% GC); --------------; samples: 412; evals/sample: 1; Test Summary: | Pass Fail Error Broken Total; Oceananigans | 1579 4 3 2 1588; Grids | 106 106; Operators | 146 146; Boundary conditions | 142 142; Fields | 198 198; Halo regions | 40 40; Solvers | 22 1 23; Pressure solvers | 152 152; Coriolis | 44 44; Buoyancy | 70 70; Surface waves | 1 1; Models | 12 12; Simulations | 26 26; Time stepping | 33 1 34; Time stepping with boundary conditions | 122 122; Forcing | 12 2 14; Forcing function initialization | 5 5; Forcing function time stepping [GPU] | 7 2 9; Turbulence closures | 46 46; Dynamics | 18 18; Diagnostics | 22 22; Output writers | 80 1 81; NetCDF [GPU] | 1 1; JLD2 [GPU] | 9 9; Checkpointer [GPU] | 71 71; Abstract operations | 258 258; Regression | 20 20; Examples | 6 6; Verification | 1 1; Performance benchmarks | 2 4 6; Performance benchmark scripts | 4 4; Static ocean benchmark | 1 1; Channel benchmark | 1 1; Turbulence closures benchmark | 1 1; Tracers benchmark | 1 1; Selected performance benchmarks | 2 2; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:2032,Security,validat,validate,2032," LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [7] macro expansion at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:254 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [9] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:250; [10] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [11] compile at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [12] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHoo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:2312,Security,validat,validate,2312,"M_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [7] macro expansion at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:254 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [9] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:250; [10] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [11] compile at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [12] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Ce",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:7915,Security,hash,hashing,7915,"eredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{var""#Fu#80"",var""#Fv#81"",var""#Fw#82"",typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [17] + at ./int.jl:53 [inlined]; [18] hash_64_64 at ./hashing.jl:35 [inlined]; [19] hash_uint64 at ./hashing.jl:62 [inlined]; [20] hx at ./float.jl:568 [inlined]; [21] hash at ./float.jl:571 [inlined]; [22] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,Iso",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:7962,Security,hash,hashing,7962,"ivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{var""#Fu#80"",var""#Fv#81"",var""#Fw#82"",typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [17] + at ./int.jl:53 [inlined]; [18] hash_64_64 at ./hashing.jl:35 [inlined]; [19] hash_uint64 at ./hashing.jl:62 [inlined]; [20] hx at ./float.jl:568 [inlined]; [21] hash at ./float.jl:571 [inlined]; [22] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:8029,Security,hash,hash,8029,"},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{var""#Fu#80"",var""#Fv#81"",var""#Fw#82"",typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [17] + at ./int.jl:53 [inlined]; [18] hash_64_64 at ./hashing.jl:35 [inlined]; [19] hash_uint64 at ./hashing.jl:62 [inlined]; [20] hx at ./float.jl:568 [inlined]; [21] hash at ./float.jl:571 [inlined]; [22] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{Of",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:39528,Security,validat,validate,39528," LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [7] macro expansion at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:254 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [9] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:250; [10] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [11] compile at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [12] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHoo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:39808,Security,validat,validate,39808,"M_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [7] macro expansion at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:254 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [9] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:250; [10] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [11] compile at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [12] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Ce",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:45933,Security,hash,hashing,45933,"oat64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [17] + at ./int.jl:53 [inlined]; [18] hash_64_64 at ./hashing.jl:35 [inlined]; [19] hash_uint64 at ./hashing.jl:62 [inlined]; [20] hx at ./float.jl:568 [inlined]; [21] hash at ./float.jl:571 [inlined]; [22] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,Iso",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:45980,Security,hash,hashing,45980,"CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [17] + at ./int.jl:53 [inlined]; [18] hash_64_64 at ./hashing.jl:35 [inlined]; [19] hash_uint64 at ./hashing.jl:62 [inlined]; [20] hx at ./float.jl:568 [inlined]; [21] hash at ./float.jl:571 [inlined]; [22] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:46047,Security,hash,hash,46047,"t64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [17] + at ./int.jl:53 [inlined]; [18] hash_64_64 at ./hashing.jl:35 [inlined]; [19] hash_uint64 at ./hashing.jl:62 [inlined]; [20] hx at ./float.jl:568 [inlined]; [21] hash at ./float.jl:571 [inlined]; [22] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{Of",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:97,Testability,test,tests,97,"Yesterday, in https://github.com/openjournals/joss-reviews/issues/2018, I mentioned some failing tests on GPU. Since then, I tried to reproduce them in a clean and up-to-date environment but I now have issues even to install CUDA.jl. I'm suspecting a problem with my CUDA setup, and I don't really have the time nor the need to look into this. I pasted below the tracebacks I got a few days ago, just in case there is something useful for you in it, but don't feel any obligation to look into this issue that I can't reproduce. ```; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136; Test threw exception; Expression: time_step_with_forcing_functions(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103; [2] macro expansion at /home/ancellin/.julia/packages/LLVM/KITdB/src/util.jl:114 [inlined]; [3] LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [7] macro expansion at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:254 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [9] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:584,Testability,Test,Test,584,"Yesterday, in https://github.com/openjournals/joss-reviews/issues/2018, I mentioned some failing tests on GPU. Since then, I tried to reproduce them in a clean and up-to-date environment but I now have issues even to install CUDA.jl. I'm suspecting a problem with my CUDA setup, and I don't really have the time nor the need to look into this. I pasted below the tracebacks I got a few days ago, just in case there is something useful for you in it, but don't feel any obligation to look into this issue that I can't reproduce. ```; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136; Test threw exception; Expression: time_step_with_forcing_functions(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103; [2] macro expansion at /home/ancellin/.julia/packages/LLVM/KITdB/src/util.jl:114 [inlined]; [3] LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [7] macro expansion at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:254 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [9] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:642,Testability,test,test,642,"Yesterday, in https://github.com/openjournals/joss-reviews/issues/2018, I mentioned some failing tests on GPU. Since then, I tried to reproduce them in a clean and up-to-date environment but I now have issues even to install CUDA.jl. I'm suspecting a problem with my CUDA setup, and I don't really have the time nor the need to look into this. I pasted below the tracebacks I got a few days ago, just in case there is something useful for you in it, but don't feel any obligation to look into this issue that I can't reproduce. ```; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136; Test threw exception; Expression: time_step_with_forcing_functions(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103; [2] macro expansion at /home/ancellin/.julia/packages/LLVM/KITdB/src/util.jl:114 [inlined]; [3] LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [7] macro expansion at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:254 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [9] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:669,Testability,Test,Test,669,"Yesterday, in https://github.com/openjournals/joss-reviews/issues/2018, I mentioned some failing tests on GPU. Since then, I tried to reproduce them in a clean and up-to-date environment but I now have issues even to install CUDA.jl. I'm suspecting a problem with my CUDA setup, and I don't really have the time nor the need to look into this. I pasted below the tracebacks I got a few days ago, just in case there is something useful for you in it, but don't feel any obligation to look into this issue that I can't reproduce. ```; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136; Test threw exception; Expression: time_step_with_forcing_functions(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103; [2] macro expansion at /home/ancellin/.julia/packages/LLVM/KITdB/src/util.jl:114 [inlined]; [3] LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [7] macro expansion at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:254 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [9] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:37420,Testability,test,test,37420,", :S),Tuple{var""#Fu#80"",var""#Fv#81"",var""#Fw#82"",typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},CenteredSecondOrder,PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CuArray{Float64,3},CuArray{Float64,3},CuArray{Float64,3}}},CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_forcing_functions(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:21; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137; Test threw exception; Expression: time_step_with_parameterized_forcing(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:37520,Testability,test,test,37520,"nanigans.Forcing.zeroforcing)}},CenteredSecondOrder,PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CuArray{Float64,3},CuArray{Float64,3},CuArray{Float64,3}}},CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_forcing_functions(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:21; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137; Test threw exception; Expression: time_step_with_parameterized_forcing(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103; [2] macro expansion at /home/ancellin/.julia/packages/LLVM/KITdB/src/util.jl:114 [inlined]; [3] LLV",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:37651,Testability,Test,Test,37651,"ple{CuArray{Float64,3},CuArray{Float64,3},CuArray{Float64,3}}},CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_forcing_functions(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:21; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137; Test threw exception; Expression: time_step_with_parameterized_forcing(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103; [2] macro expansion at /home/ancellin/.julia/packages/LLVM/KITdB/src/util.jl:114 [inlined]; [3] LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Ba",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:37660,Testability,Test,Test,37660,"ple{CuArray{Float64,3},CuArray{Float64,3},CuArray{Float64,3}}},CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_forcing_functions(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:21; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137; Test threw exception; Expression: time_step_with_parameterized_forcing(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103; [2] macro expansion at /home/ancellin/.julia/packages/LLVM/KITdB/src/util.jl:114 [inlined]; [3] LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Ba",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:37758,Testability,test,test,37758,"medTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_forcing_functions(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:21; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137; Test threw exception; Expression: time_step_with_parameterized_forcing(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103; [2] macro expansion at /home/ancellin/.julia/packages/LLVM/KITdB/src/util.jl:114 [inlined]; [3] LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:37889,Testability,Test,Test,37889,"rue,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_forcing_functions(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:21; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137; Test threw exception; Expression: time_step_with_parameterized_forcing(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103; [2] macro expansion at /home/ancellin/.julia/packages/LLVM/KITdB/src/util.jl:114 [inlined]; [3] LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancell",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:37898,Testability,Test,Test,37898,"rue,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_forcing_functions(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:21; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137; Test threw exception; Expression: time_step_with_parameterized_forcing(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103; [2] macro expansion at /home/ancellin/.julia/packages/LLVM/KITdB/src/util.jl:114 [inlined]; [3] LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancell",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:37996,Testability,test,test,37996,",3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_forcing_functions(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:21; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137; Test threw exception; Expression: time_step_with_parameterized_forcing(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103; [2] macro expansion at /home/ancellin/.julia/packages/LLVM/KITdB/src/util.jl:114 [inlined]; [3] LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/pack",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:38076,Testability,Test,Test,38076,"FTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_forcing_functions(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:21; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137; Test threw exception; Expression: time_step_with_parameterized_forcing(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103; [2] macro expansion at /home/ancellin/.julia/packages/LLVM/KITdB/src/util.jl:114 [inlined]; [3] LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:38134,Testability,test,test,38134,"4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_forcing_functions(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:21; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137; Test threw exception; Expression: time_step_with_parameterized_forcing(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103; [2] macro expansion at /home/ancellin/.julia/packages/LLVM/KITdB/src/util.jl:114 [inlined]; [3] LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:38161,Testability,Test,Test,38161,"ages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_forcing_functions(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:21; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:136 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; Forcing function time stepping [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137; Test threw exception; Expression: time_step_with_parameterized_forcing(arch); LLVM error: Cannot cast between two non-generic address spaces; Stacktrace:; [1] handle_error(::Cstring) at /home/ancellin/.julia/packages/LLVM/KITdB/src/core/context.jl:103; [2] macro expansion at /home/ancellin/.julia/packages/LLVM/KITdB/src/util.jl:114 [inlined]; [3] LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [7] macro expansion at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:254 [inlined]; [8] macro e",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:76312,Testability,test,test,76312,"Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},CenteredSecondOrder,PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CuArray{Float64,3},CuArray{Float64,3},CuArray{Float64,3}}},CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_parameterized_forcing(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:40; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; NetCDF [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:524; Got exception outside of a @test; MethodError: no method matching device(::CuContext); Closest candidates are:; device() at /home/ancellin/.julia/packages/CUDA/d6WNR/src/state.jl:225; Stacktrace:; [1] |>(::CuContext, ::typeof(CUDA.device)) at ./operators.jl:823; [2] ver",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:76412,Testability,test,test,76412,"gans.Forcing.zeroforcing)}},CenteredSecondOrder,PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CuArray{Float64,3},CuArray{Float64,3},CuArray{Float64,3}}},CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_parameterized_forcing(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:40; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; NetCDF [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:524; Got exception outside of a @test; MethodError: no method matching device(::CuContext); Closest candidates are:; device() at /home/ancellin/.julia/packages/CUDA/d6WNR/src/state.jl:225; Stacktrace:; [1] |>(::CuContext, ::typeof(CUDA.device)) at ./operators.jl:823; [2] versioninfo_with_gpu() at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/Utils/versioninfo.jl:9;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:76543,Testability,Test,Test,76543,"CuArray{Float64,3},CuArray{Float64,3},CuArray{Float64,3}}},CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_parameterized_forcing(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:40; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; NetCDF [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:524; Got exception outside of a @test; MethodError: no method matching device(::CuContext); Closest candidates are:; device() at /home/ancellin/.julia/packages/CUDA/d6WNR/src/state.jl:225; Stacktrace:; [1] |>(::CuContext, ::typeof(CUDA.device)) at ./operators.jl:823; [2] versioninfo_with_gpu() at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/Utils/versioninfo.jl:9; [3] write_grid_and_attributes(::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:76552,Testability,Test,Test,76552,"CuArray{Float64,3},CuArray{Float64,3},CuArray{Float64,3}}},CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_parameterized_forcing(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:40; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; NetCDF [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:524; Got exception outside of a @test; MethodError: no method matching device(::CuContext); Closest candidates are:; device() at /home/ancellin/.julia/packages/CUDA/d6WNR/src/state.jl:225; Stacktrace:; [1] |>(::CuContext, ::typeof(CUDA.device)) at ./operators.jl:823; [2] versioninfo_with_gpu() at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/Utils/versioninfo.jl:9; [3] write_grid_and_attributes(::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:76650,Testability,test,test,76650,"uple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_parameterized_forcing(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:40; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; NetCDF [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:524; Got exception outside of a @test; MethodError: no method matching device(::CuContext); Closest candidates are:; device() at /home/ancellin/.julia/packages/CUDA/d6WNR/src/state.jl:225; Stacktrace:; [1] |>(::CuContext, ::typeof(CUDA.device)) at ./operators.jl:823; [2] versioninfo_with_gpu() at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/Utils/versioninfo.jl:9; [3] write_grid_and_attributes(::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Cell,Cell,OffsetArray{Float64,3,CuArray{Float64,3}},RegularCartesianGrid{Flo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:76781,Testability,Test,Test,76781,"3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_parameterized_forcing(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:40; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; NetCDF [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:524; Got exception outside of a @test; MethodError: no method matching device(::CuContext); Closest candidates are:; device() at /home/ancellin/.julia/packages/CUDA/d6WNR/src/state.jl:225; Stacktrace:; [1] |>(::CuContext, ::typeof(CUDA.device)) at ./operators.jl:823; [2] versioninfo_with_gpu() at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/Utils/versioninfo.jl:9; [3] write_grid_and_attributes(::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Cell,Cell,OffsetArray{Float64,3,CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTupl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:76790,Testability,Test,Test,76790,"3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_parameterized_forcing(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:40; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; NetCDF [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:524; Got exception outside of a @test; MethodError: no method matching device(::CuContext); Closest candidates are:; device() at /home/ancellin/.julia/packages/CUDA/d6WNR/src/state.jl:225; Stacktrace:; [1] |>(::CuContext, ::typeof(CUDA.device)) at ./operators.jl:823; [2] versioninfo_with_gpu() at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/Utils/versioninfo.jl:9; [3] write_grid_and_attributes(::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Cell,Cell,OffsetArray{Float64,3,CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTupl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:76888,Testability,test,test,76888,"Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_parameterized_forcing(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:40; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; NetCDF [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:524; Got exception outside of a @test; MethodError: no method matching device(::CuContext); Closest candidates are:; device() at /home/ancellin/.julia/packages/CUDA/d6WNR/src/state.jl:225; Stacktrace:; [1] |>(::CuContext, ::typeof(CUDA.device)) at ./operators.jl:823; [2] versioninfo_with_gpu() at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/Utils/versioninfo.jl:9; [3] write_grid_and_attributes(::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Cell,Cell,OffsetArray{Float64,3,CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryCondi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:76944,Testability,Test,Test,76944,"FFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_parameterized_forcing(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:40; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; NetCDF [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:524; Got exception outside of a @test; MethodError: no method matching device(::CuContext); Closest candidates are:; device() at /home/ancellin/.julia/packages/CUDA/d6WNR/src/state.jl:225; Stacktrace:; [1] |>(::CuContext, ::typeof(CUDA.device)) at ./operators.jl:823; [2] versioninfo_with_gpu() at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/Utils/versioninfo.jl:9; [3] write_grid_and_attributes(::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Cell,Cell,OffsetArray{Float64,3,CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.Bo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:77002,Testability,test,test,77002,"ple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_parameterized_forcing(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:40; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; NetCDF [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:524; Got exception outside of a @test; MethodError: no method matching device(::CuContext); Closest candidates are:; device() at /home/ancellin/.julia/packages/CUDA/d6WNR/src/state.jl:225; Stacktrace:; [1] |>(::CuContext, ::typeof(CUDA.device)) at ./operators.jl:823; [2] versioninfo_with_gpu() at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/Utils/versioninfo.jl:9; [3] write_grid_and_attributes(::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Cell,Cell,OffsetArray{Float64,3,CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryCondit",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:77063,Testability,test,test,77063,"4; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/adams_bashforth.jl:50; [29] time_step_with_parameterized_forcing(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:40; [30] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:137 [inlined]; [31] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [32] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:135 [inlined]; [33] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [34] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_forcings.jl:124; ; NetCDF [GPU]: Error During Test at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:524; Got exception outside of a @test; MethodError: no method matching device(::CuContext); Closest candidates are:; device() at /home/ancellin/.julia/packages/CUDA/d6WNR/src/state.jl:225; Stacktrace:; [1] |>(::CuContext, ::typeof(CUDA.device)) at ./operators.jl:823; [2] versioninfo_with_gpu() at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/Utils/versioninfo.jl:9; [3] write_grid_and_attributes(::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Cell,Cell,OffsetArray{Float64,3,CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:101811,Testability,test,test,101811,"omplex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Dict{String,Field{X,Y,Z,OffsetArray{Float64,3,CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z where Y where X}; filename::String, iteration_interval::Int64, time_interval::Nothing, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, clobber::Bool, compression::Int64, with_halos::Bool, verbose::Bool, xC::UnitRange{Int64}, xF::UnitRange{Int64}, yC::UnitRange{Int64}, yF::UnitRange{Int64}, zC::UnitRange{Int64}, zF::UnitRange{Int64}) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/OutputWriters/netcdf_output_writer.jl:176; [5] run_thermal_bubble_netcdf_tests(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:29; [6] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:526 [inlined]; [7] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:525 [inlined]; [9] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [10] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:521; [11] include(::String) at ./client.jl:439; [12] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:94; [13] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [14] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:76; [15] include(::String) ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:101916,Testability,test,test,101916,",Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Dict{String,Field{X,Y,Z,OffsetArray{Float64,3,CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z where Y where X}; filename::String, iteration_interval::Int64, time_interval::Nothing, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, clobber::Bool, compression::Int64, with_halos::Bool, verbose::Bool, xC::UnitRange{Int64}, xF::UnitRange{Int64}, yC::UnitRange{Int64}, yF::UnitRange{Int64}, zC::UnitRange{Int64}, zF::UnitRange{Int64}) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/OutputWriters/netcdf_output_writer.jl:176; [5] run_thermal_bubble_netcdf_tests(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:29; [6] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:526 [inlined]; [7] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:525 [inlined]; [9] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [10] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:521; [11] include(::String) at ./client.jl:439; [12] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:94; [13] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [14] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:76; [15] include(::String) at ./client.jl:439; [16] top-level scope at none:6; [17] eval(::Module, ::Any) at ./boot.jl:331; [18] exe",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:102052,Testability,Test,Test,102052,"ularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z where Y where X}; filename::String, iteration_interval::Int64, time_interval::Nothing, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, clobber::Bool, compression::Int64, with_halos::Bool, verbose::Bool, xC::UnitRange{Int64}, xF::UnitRange{Int64}, yC::UnitRange{Int64}, yF::UnitRange{Int64}, zC::UnitRange{Int64}, zF::UnitRange{Int64}) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/OutputWriters/netcdf_output_writer.jl:176; [5] run_thermal_bubble_netcdf_tests(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:29; [6] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:526 [inlined]; [7] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:525 [inlined]; [9] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [10] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:521; [11] include(::String) at ./client.jl:439; [12] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:94; [13] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [14] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:76; [15] include(::String) at ./client.jl:439; [16] top-level scope at none:6; [17] eval(::Module, ::Any) at ./boot.jl:331; [18] exec_options(::Base.JLOptions) at ./client.jl:264; [19] _start() at ./client.jl:484; ; i: 0001, t: 1.000 s, Δt: 1.100 s, wmax = 2.7e-04 ms⁻¹, wall ti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:102061,Testability,Test,Test,102061,"ularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z where Y where X}; filename::String, iteration_interval::Int64, time_interval::Nothing, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, clobber::Bool, compression::Int64, with_halos::Bool, verbose::Bool, xC::UnitRange{Int64}, xF::UnitRange{Int64}, yC::UnitRange{Int64}, yF::UnitRange{Int64}, zC::UnitRange{Int64}, zF::UnitRange{Int64}) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/OutputWriters/netcdf_output_writer.jl:176; [5] run_thermal_bubble_netcdf_tests(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:29; [6] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:526 [inlined]; [7] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:525 [inlined]; [9] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [10] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:521; [11] include(::String) at ./client.jl:439; [12] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:94; [13] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [14] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:76; [15] include(::String) at ./client.jl:439; [16] top-level scope at none:6; [17] eval(::Module, ::Any) at ./boot.jl:331; [18] exec_options(::Base.JLOptions) at ./client.jl:264; [19] _start() at ./client.jl:484; ; i: 0001, t: 1.000 s, Δt: 1.100 s, wmax = 2.7e-04 ms⁻¹, wall ti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:102158,Testability,test,test,102158,"Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},B} where B where Z where Y where X}; filename::String, iteration_interval::Int64, time_interval::Nothing, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, clobber::Bool, compression::Int64, with_halos::Bool, verbose::Bool, xC::UnitRange{Int64}, xF::UnitRange{Int64}, yC::UnitRange{Int64}, yF::UnitRange{Int64}, zC::UnitRange{Int64}, zF::UnitRange{Int64}) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/OutputWriters/netcdf_output_writer.jl:176; [5] run_thermal_bubble_netcdf_tests(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:29; [6] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:526 [inlined]; [7] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:525 [inlined]; [9] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [10] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:521; [11] include(::String) at ./client.jl:439; [12] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:94; [13] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [14] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:76; [15] include(::String) at ./client.jl:439; [16] top-level scope at none:6; [17] eval(::Module, ::Any) at ./boot.jl:331; [18] exec_options(::Base.JLOptions) at ./client.jl:264; [19] _start() at ./client.jl:484; ; i: 0001, t: 1.000 s, Δt: 1.100 s, wmax = 2.7e-04 ms⁻¹, wall time: 18.164 s; progress: 0.0 %, i: 0001, t: 1.000 s, Δt: 1.100 s, wall time: 11.110 s; N² = ((Rᵈ ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:102294,Testability,Test,Test,102294,"_interval::Nothing, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, clobber::Bool, compression::Int64, with_halos::Bool, verbose::Bool, xC::UnitRange{Int64}, xF::UnitRange{Int64}, yC::UnitRange{Int64}, yF::UnitRange{Int64}, zC::UnitRange{Int64}, zF::UnitRange{Int64}) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/OutputWriters/netcdf_output_writer.jl:176; [5] run_thermal_bubble_netcdf_tests(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:29; [6] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:526 [inlined]; [7] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:525 [inlined]; [9] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [10] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:521; [11] include(::String) at ./client.jl:439; [12] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:94; [13] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [14] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:76; [15] include(::String) at ./client.jl:439; [16] top-level scope at none:6; [17] eval(::Module, ::Any) at ./boot.jl:331; [18] exec_options(::Base.JLOptions) at ./client.jl:264; [19] _start() at ./client.jl:484; ; i: 0001, t: 1.000 s, Δt: 1.100 s, wmax = 2.7e-04 ms⁻¹, wall time: 18.164 s; progress: 0.0 %, i: 0001, t: 1.000 s, Δt: 1.100 s, wall time: 11.110 s; N² = ((Rᵈ * f) / Lz) ^ 2 = 0.0004; α = sqrt(N²) / (f * σᵇ) = 0.02314814814814815; i: 0010, t: 3.667 min, Δt: 22.000 s, umax = (2.4e-01, 2.3e-01, 1.9e-05) ms",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:102303,Testability,Test,Test,102303,"_interval::Nothing, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, clobber::Bool, compression::Int64, with_halos::Bool, verbose::Bool, xC::UnitRange{Int64}, xF::UnitRange{Int64}, yC::UnitRange{Int64}, yF::UnitRange{Int64}, zC::UnitRange{Int64}, zF::UnitRange{Int64}) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/OutputWriters/netcdf_output_writer.jl:176; [5] run_thermal_bubble_netcdf_tests(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:29; [6] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:526 [inlined]; [7] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:525 [inlined]; [9] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [10] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:521; [11] include(::String) at ./client.jl:439; [12] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:94; [13] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [14] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:76; [15] include(::String) at ./client.jl:439; [16] top-level scope at none:6; [17] eval(::Module, ::Any) at ./boot.jl:331; [18] exec_options(::Base.JLOptions) at ./client.jl:264; [19] _start() at ./client.jl:484; ; i: 0001, t: 1.000 s, Δt: 1.100 s, wmax = 2.7e-04 ms⁻¹, wall time: 18.164 s; progress: 0.0 %, i: 0001, t: 1.000 s, Δt: 1.100 s, wall time: 11.110 s; N² = ((Rᵈ * f) / Lz) ^ 2 = 0.0004; α = sqrt(N²) / (f * σᵇ) = 0.02314814814814815; i: 0010, t: 3.667 min, Δt: 22.000 s, umax = (2.4e-01, 2.3e-01, 1.9e-05) ms",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:102401,Testability,test,test,102401,"ns::Dict{Any,Any}, clobber::Bool, compression::Int64, with_halos::Bool, verbose::Bool, xC::UnitRange{Int64}, xF::UnitRange{Int64}, yC::UnitRange{Int64}, yF::UnitRange{Int64}, zC::UnitRange{Int64}, zF::UnitRange{Int64}) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/OutputWriters/netcdf_output_writer.jl:176; [5] run_thermal_bubble_netcdf_tests(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:29; [6] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:526 [inlined]; [7] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:525 [inlined]; [9] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [10] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:521; [11] include(::String) at ./client.jl:439; [12] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:94; [13] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [14] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:76; [15] include(::String) at ./client.jl:439; [16] top-level scope at none:6; [17] eval(::Module, ::Any) at ./boot.jl:331; [18] exec_options(::Base.JLOptions) at ./client.jl:264; [19] _start() at ./client.jl:484; ; i: 0001, t: 1.000 s, Δt: 1.100 s, wmax = 2.7e-04 ms⁻¹, wall time: 18.164 s; progress: 0.0 %, i: 0001, t: 1.000 s, Δt: 1.100 s, wall time: 11.110 s; N² = ((Rᵈ * f) / Lz) ^ 2 = 0.0004; α = sqrt(N²) / (f * σᵇ) = 0.02314814814814815; i: 0010, t: 3.667 min, Δt: 22.000 s, umax = (2.4e-01, 2.3e-01, 1.9e-05) ms⁻¹, wall time: 12.877 s; Simulating stratified plane Couette flow. N : 16, 16, 8; L : 12.6, 6.28,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:102551,Testability,test,test,102551,"Int64}, yF::UnitRange{Int64}, zC::UnitRange{Int64}, zF::UnitRange{Int64}) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/OutputWriters/netcdf_output_writer.jl:176; [5] run_thermal_bubble_netcdf_tests(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:29; [6] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:526 [inlined]; [7] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:525 [inlined]; [9] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [10] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:521; [11] include(::String) at ./client.jl:439; [12] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:94; [13] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [14] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:76; [15] include(::String) at ./client.jl:439; [16] top-level scope at none:6; [17] eval(::Module, ::Any) at ./boot.jl:331; [18] exec_options(::Base.JLOptions) at ./client.jl:264; [19] _start() at ./client.jl:484; ; i: 0001, t: 1.000 s, Δt: 1.100 s, wmax = 2.7e-04 ms⁻¹, wall time: 18.164 s; progress: 0.0 %, i: 0001, t: 1.000 s, Δt: 1.100 s, wall time: 11.110 s; N² = ((Rᵈ * f) / Lz) ^ 2 = 0.0004; α = sqrt(N²) / (f * σᵇ) = 0.02314814814814815; i: 0010, t: 3.667 min, Δt: 22.000 s, umax = (2.4e-01, 2.3e-01, 1.9e-05) ms⁻¹, wall time: 12.877 s; Simulating stratified plane Couette flow. N : 16, 16, 8; L : 12.6, 6.28, 2; Re : 4250.000; Ri : 0.010; Pr : 0.700; ν : 0.000235; κ : 0.000336; U_wall : 1.000; Θ_wall : 0.010. [1000.00%] i: 1, t: 1.00e-04, umax: (1.59",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:102666,Testability,Test,Test,102666,"OutputWriters/netcdf_output_writer.jl:176; [5] run_thermal_bubble_netcdf_tests(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:29; [6] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:526 [inlined]; [7] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:525 [inlined]; [9] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [10] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:521; [11] include(::String) at ./client.jl:439; [12] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:94; [13] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [14] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:76; [15] include(::String) at ./client.jl:439; [16] top-level scope at none:6; [17] eval(::Module, ::Any) at ./boot.jl:331; [18] exec_options(::Base.JLOptions) at ./client.jl:264; [19] _start() at ./client.jl:484; ; i: 0001, t: 1.000 s, Δt: 1.100 s, wmax = 2.7e-04 ms⁻¹, wall time: 18.164 s; progress: 0.0 %, i: 0001, t: 1.000 s, Δt: 1.100 s, wall time: 11.110 s; N² = ((Rᵈ * f) / Lz) ^ 2 = 0.0004; α = sqrt(N²) / (f * σᵇ) = 0.02314814814814815; i: 0010, t: 3.667 min, Δt: 22.000 s, umax = (2.4e-01, 2.3e-01, 1.9e-05) ms⁻¹, wall time: 12.877 s; Simulating stratified plane Couette flow. N : 16, 16, 8; L : 12.6, 6.28, 2; Re : 4250.000; Ri : 0.010; Pr : 0.700; ν : 0.000235; κ : 0.000336; U_wall : 1.000; Θ_wall : 0.010. [1000.00%] i: 1, t: 1.00e-04, umax: (1.59e+00, 3.11e-01, 3.85e-01), CFL: 2.03e-04, νκmax: (9.98e-02, 9.97e-02), νκCFL: (1.60e-04, 1.60e-04), next Δt: 1.00e-04, wall time: 8",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:102675,Testability,Test,Test,102675,"OutputWriters/netcdf_output_writer.jl:176; [5] run_thermal_bubble_netcdf_tests(::GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:29; [6] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:526 [inlined]; [7] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:525 [inlined]; [9] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [10] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:521; [11] include(::String) at ./client.jl:439; [12] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:94; [13] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [14] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:76; [15] include(::String) at ./client.jl:439; [16] top-level scope at none:6; [17] eval(::Module, ::Any) at ./boot.jl:331; [18] exec_options(::Base.JLOptions) at ./client.jl:264; [19] _start() at ./client.jl:484; ; i: 0001, t: 1.000 s, Δt: 1.100 s, wmax = 2.7e-04 ms⁻¹, wall time: 18.164 s; progress: 0.0 %, i: 0001, t: 1.000 s, Δt: 1.100 s, wall time: 11.110 s; N² = ((Rᵈ * f) / Lz) ^ 2 = 0.0004; α = sqrt(N²) / (f * σᵇ) = 0.02314814814814815; i: 0010, t: 3.667 min, Δt: 22.000 s, umax = (2.4e-01, 2.3e-01, 1.9e-05) ms⁻¹, wall time: 12.877 s; Simulating stratified plane Couette flow. N : 16, 16, 8; L : 12.6, 6.28, 2; Re : 4250.000; Ri : 0.010; Pr : 0.700; ν : 0.000235; κ : 0.000336; U_wall : 1.000; Θ_wall : 0.010. [1000.00%] i: 1, t: 1.00e-04, umax: (1.59e+00, 3.11e-01, 3.85e-01), CFL: 2.03e-04, νκmax: (9.98e-02, 9.97e-02), νκCFL: (1.60e-04, 1.60e-04), next Δt: 1.00e-04, wall time: 8",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:102763,Testability,test,test,102763,"GPU) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:29; [6] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:526 [inlined]; [7] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:525 [inlined]; [9] macro expansion at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113 [inlined]; [10] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_output_writers.jl:521; [11] include(::String) at ./client.jl:439; [12] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:94; [13] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [14] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:76; [15] include(::String) at ./client.jl:439; [16] top-level scope at none:6; [17] eval(::Module, ::Any) at ./boot.jl:331; [18] exec_options(::Base.JLOptions) at ./client.jl:264; [19] _start() at ./client.jl:484; ; i: 0001, t: 1.000 s, Δt: 1.100 s, wmax = 2.7e-04 ms⁻¹, wall time: 18.164 s; progress: 0.0 %, i: 0001, t: 1.000 s, Δt: 1.100 s, wall time: 11.110 s; N² = ((Rᵈ * f) / Lz) ^ 2 = 0.0004; α = sqrt(N²) / (f * σᵇ) = 0.02314814814814815; i: 0010, t: 3.667 min, Δt: 22.000 s, umax = (2.4e-01, 2.3e-01, 1.9e-05) ms⁻¹, wall time: 12.877 s; Simulating stratified plane Couette flow. N : 16, 16, 8; L : 12.6, 6.28, 2; Re : 4250.000; Ri : 0.010; Pr : 0.700; ν : 0.000235; κ : 0.000336; U_wall : 1.000; Θ_wall : 0.010. [1000.00%] i: 1, t: 1.00e-04, umax: (1.59e+00, 3.11e-01, 3.85e-01), CFL: 2.03e-04, νκmax: (9.98e-02, 9.97e-02), νκCFL: (1.60e-04, 1.60e-04), next Δt: 1.00e-04, wall time: 82.994 ms; Running static ocean benchmark: 16× 16× 16 [CPU, Float32]...; Running s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:103703,Testability,benchmark,benchmark,103703,"pe at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/runtests.jl:76; [15] include(::String) at ./client.jl:439; [16] top-level scope at none:6; [17] eval(::Module, ::Any) at ./boot.jl:331; [18] exec_options(::Base.JLOptions) at ./client.jl:264; [19] _start() at ./client.jl:484; ; i: 0001, t: 1.000 s, Δt: 1.100 s, wmax = 2.7e-04 ms⁻¹, wall time: 18.164 s; progress: 0.0 %, i: 0001, t: 1.000 s, Δt: 1.100 s, wall time: 11.110 s; N² = ((Rᵈ * f) / Lz) ^ 2 = 0.0004; α = sqrt(N²) / (f * σᵇ) = 0.02314814814814815; i: 0010, t: 3.667 min, Δt: 22.000 s, umax = (2.4e-01, 2.3e-01, 1.9e-05) ms⁻¹, wall time: 12.877 s; Simulating stratified plane Couette flow. N : 16, 16, 8; L : 12.6, 6.28, 2; Re : 4250.000; Ri : 0.010; Pr : 0.700; ν : 0.000235; κ : 0.000336; U_wall : 1.000; Θ_wall : 0.010. [1000.00%] i: 1, t: 1.00e-04, umax: (1.59e+00, 3.11e-01, 3.85e-01), CFL: 2.03e-04, νκmax: (9.98e-02, 9.97e-02), νκCFL: (1.60e-04, 1.60e-04), next Δt: 1.00e-04, wall time: 82.994 ms; Running static ocean benchmark: 16× 16× 16 [CPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [CPU, Float64]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_static_ocean_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:103765,Testability,benchmark,benchmark,103765,"ests.jl:76; [15] include(::String) at ./client.jl:439; [16] top-level scope at none:6; [17] eval(::Module, ::Any) at ./boot.jl:331; [18] exec_options(::Base.JLOptions) at ./client.jl:264; [19] _start() at ./client.jl:484; ; i: 0001, t: 1.000 s, Δt: 1.100 s, wmax = 2.7e-04 ms⁻¹, wall time: 18.164 s; progress: 0.0 %, i: 0001, t: 1.000 s, Δt: 1.100 s, wall time: 11.110 s; N² = ((Rᵈ * f) / Lz) ^ 2 = 0.0004; α = sqrt(N²) / (f * σᵇ) = 0.02314814814814815; i: 0010, t: 3.667 min, Δt: 22.000 s, umax = (2.4e-01, 2.3e-01, 1.9e-05) ms⁻¹, wall time: 12.877 s; Simulating stratified plane Couette flow. N : 16, 16, 8; L : 12.6, 6.28, 2; Re : 4250.000; Ri : 0.010; Pr : 0.700; ν : 0.000235; κ : 0.000336; U_wall : 1.000; Θ_wall : 0.010. [1000.00%] i: 1, t: 1.00e-04, umax: (1.59e+00, 3.11e-01, 3.85e-01), CFL: 2.03e-04, νκmax: (9.98e-02, 9.97e-02), νκCFL: (1.60e-04, 1.60e-04), next Δt: 1.00e-04, wall time: 82.994 ms; Running static ocean benchmark: 16× 16× 16 [CPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [CPU, Float64]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_static_ocean_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 29 mod",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:103827,Testability,benchmark,benchmark,103827,"p-level scope at none:6; [17] eval(::Module, ::Any) at ./boot.jl:331; [18] exec_options(::Base.JLOptions) at ./client.jl:264; [19] _start() at ./client.jl:484; ; i: 0001, t: 1.000 s, Δt: 1.100 s, wmax = 2.7e-04 ms⁻¹, wall time: 18.164 s; progress: 0.0 %, i: 0001, t: 1.000 s, Δt: 1.100 s, wall time: 11.110 s; N² = ((Rᵈ * f) / Lz) ^ 2 = 0.0004; α = sqrt(N²) / (f * σᵇ) = 0.02314814814814815; i: 0010, t: 3.667 min, Δt: 22.000 s, umax = (2.4e-01, 2.3e-01, 1.9e-05) ms⁻¹, wall time: 12.877 s; Simulating stratified plane Couette flow. N : 16, 16, 8; L : 12.6, 6.28, 2; Re : 4250.000; Ri : 0.010; Pr : 0.700; ν : 0.000235; κ : 0.000336; U_wall : 1.000; Θ_wall : 0.010. [1000.00%] i: 1, t: 1.00e-04, umax: (1.59e+00, 3.11e-01, 3.85e-01), CFL: 2.03e-04, νκmax: (9.98e-02, 9.97e-02), νκCFL: (1.60e-04, 1.60e-04), next Δt: 1.00e-04, wall time: 82.994 ms; Running static ocean benchmark: 16× 16× 16 [CPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [CPU, Float64]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_static_ocean_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 29 model = IncompressibleModel(architecture=arch, float_type=FT, gri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:103889,Testability,benchmark,benchmark,103889,"jl:331; [18] exec_options(::Base.JLOptions) at ./client.jl:264; [19] _start() at ./client.jl:484; ; i: 0001, t: 1.000 s, Δt: 1.100 s, wmax = 2.7e-04 ms⁻¹, wall time: 18.164 s; progress: 0.0 %, i: 0001, t: 1.000 s, Δt: 1.100 s, wall time: 11.110 s; N² = ((Rᵈ * f) / Lz) ^ 2 = 0.0004; α = sqrt(N²) / (f * σᵇ) = 0.02314814814814815; i: 0010, t: 3.667 min, Δt: 22.000 s, umax = (2.4e-01, 2.3e-01, 1.9e-05) ms⁻¹, wall time: 12.877 s; Simulating stratified plane Couette flow. N : 16, 16, 8; L : 12.6, 6.28, 2; Re : 4250.000; Ri : 0.010; Pr : 0.700; ν : 0.000235; κ : 0.000336; U_wall : 1.000; Θ_wall : 0.010. [1000.00%] i: 1, t: 1.00e-04, umax: (1.59e+00, 3.11e-01, 3.85e-01), CFL: 2.03e-04, νκmax: (9.98e-02, 9.97e-02), νκCFL: (1.60e-04, 1.60e-04), next Δt: 1.00e-04, wall time: 82.994 ms; Running static ocean benchmark: 16× 16× 16 [CPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [CPU, Float64]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_static_ocean_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 29 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 30 ; 31 time_step!(model, 1) # precompile; 32 ; 33 bn",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:104128,Testability,Benchmark,Benchmark,104128,"/ (f * σᵇ) = 0.02314814814814815; i: 0010, t: 3.667 min, Δt: 22.000 s, umax = (2.4e-01, 2.3e-01, 1.9e-05) ms⁻¹, wall time: 12.877 s; Simulating stratified plane Couette flow. N : 16, 16, 8; L : 12.6, 6.28, 2; Re : 4250.000; Ri : 0.010; Pr : 0.700; ν : 0.000235; κ : 0.000336; U_wall : 1.000; Θ_wall : 0.010. [1000.00%] i: 1, t: 1.00e-04, umax: (1.59e+00, 3.11e-01, 3.85e-01), CFL: 2.03e-04, νκmax: (9.98e-02, 9.97e-02), νκCFL: (1.60e-04, 1.60e-04), next Δt: 1.00e-04, wall time: 82.994 ms; Running static ocean benchmark: 16× 16× 16 [CPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [CPU, Float64]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_static_ocean_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 29 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 30 ; 31 time_step!(model, 1) # precompile; 32 ; 33 bname = benchmark_name(N, """", arch, FT); 34 @printf(""Running static ocean benchmark: %s...\n"", bname); 35 for i in 1:Nt; 36 @timeit timer bname time_step!(model, 1); 37 end; 38 end; 39 ; 40 #####; 41 ##### Print benchmark results; 42 #####; 43 ; 44 println(); 45 println(oceananigans_versioninfo())",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:104257,Testability,benchmark,benchmarking,104257,"/ (f * σᵇ) = 0.02314814814814815; i: 0010, t: 3.667 min, Δt: 22.000 s, umax = (2.4e-01, 2.3e-01, 1.9e-05) ms⁻¹, wall time: 12.877 s; Simulating stratified plane Couette flow. N : 16, 16, 8; L : 12.6, 6.28, 2; Re : 4250.000; Ri : 0.010; Pr : 0.700; ν : 0.000235; κ : 0.000336; U_wall : 1.000; Θ_wall : 0.010. [1000.00%] i: 1, t: 1.00e-04, umax: (1.59e+00, 3.11e-01, 3.85e-01), CFL: 2.03e-04, νκmax: (9.98e-02, 9.97e-02), νκCFL: (1.60e-04, 1.60e-04), next Δt: 1.00e-04, wall time: 82.994 ms; Running static ocean benchmark: 16× 16× 16 [CPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [CPU, Float64]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_static_ocean_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 29 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 30 ; 31 time_step!(model, 1) # precompile; 32 ; 33 bname = benchmark_name(N, """", arch, FT); 34 @printf(""Running static ocean benchmark: %s...\n"", bname); 35 for i in 1:Nt; 36 @timeit timer bname time_step!(model, 1); 37 end; 38 end; 39 ; 40 #####; 41 ##### Print benchmark results; 42 #####; 43 ; 44 println(); 45 println(oceananigans_versioninfo())",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:104317,Testability,benchmark,benchmarks,104317,"ll time: 12.877 s; Simulating stratified plane Couette flow. N : 16, 16, 8; L : 12.6, 6.28, 2; Re : 4250.000; Ri : 0.010; Pr : 0.700; ν : 0.000235; κ : 0.000336; U_wall : 1.000; Θ_wall : 0.010. [1000.00%] i: 1, t: 1.00e-04, umax: (1.59e+00, 3.11e-01, 3.85e-01), CFL: 2.03e-04, νκmax: (9.98e-02, 9.97e-02), νκCFL: (1.60e-04, 1.60e-04), next Δt: 1.00e-04, wall time: 82.994 ms; Running static ocean benchmark: 16× 16× 16 [CPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [CPU, Float64]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_static_ocean_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 29 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 30 ; 31 time_step!(model, 1) # precompile; 32 ; 33 bname = benchmark_name(N, """", arch, FT); 34 @printf(""Running static ocean benchmark: %s...\n"", bname); 35 for i in 1:Nt; 36 @timeit timer bname time_step!(model, 1); 37 end; 38 end; 39 ; 40 #####; 41 ##### Print benchmark results; 42 #####; 43 ; 44 println(); 45 println(oceananigans_versioninfo()); 46 println(versioninfo_with_gpu()); 47 ; 48 print_timer(timer, title=""Static ocean benchmarks"", sortby=:name); 4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:104359,Testability,benchmark,benchmarking,104359,"ne Couette flow. N : 16, 16, 8; L : 12.6, 6.28, 2; Re : 4250.000; Ri : 0.010; Pr : 0.700; ν : 0.000235; κ : 0.000336; U_wall : 1.000; Θ_wall : 0.010. [1000.00%] i: 1, t: 1.00e-04, umax: (1.59e+00, 3.11e-01, 3.85e-01), CFL: 2.03e-04, νκmax: (9.98e-02, 9.97e-02), νκCFL: (1.60e-04, 1.60e-04), next Δt: 1.00e-04, wall time: 82.994 ms; Running static ocean benchmark: 16× 16× 16 [CPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [CPU, Float64]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_static_ocean_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 29 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 30 ; 31 time_step!(model, 1) # precompile; 32 ; 33 bname = benchmark_name(N, """", arch, FT); 34 @printf(""Running static ocean benchmark: %s...\n"", bname); 35 for i in 1:Nt; 36 @timeit timer bname time_step!(model, 1); 37 end; 38 end; 39 ; 40 #####; 41 ##### Print benchmark results; 42 #####; 43 ; 44 println(); 45 println(oceananigans_versioninfo()); 46 println(versioninfo_with_gpu()); 47 ; 48 print_timer(timer, title=""Static ocean benchmarks"", sortby=:name); 49 ; 50 println(""\n\nCPU Float64 -> Float32 s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:104451,Testability,benchmark,benchmark,104451,"Ri : 0.010; Pr : 0.700; ν : 0.000235; κ : 0.000336; U_wall : 1.000; Θ_wall : 0.010. [1000.00%] i: 1, t: 1.00e-04, umax: (1.59e+00, 3.11e-01, 3.85e-01), CFL: 2.03e-04, νκmax: (9.98e-02, 9.97e-02), νκCFL: (1.60e-04, 1.60e-04), next Δt: 1.00e-04, wall time: 82.994 ms; Running static ocean benchmark: 16× 16× 16 [CPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [CPU, Float64]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_static_ocean_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 29 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 30 ; 31 time_step!(model, 1) # precompile; 32 ; 33 bname = benchmark_name(N, """", arch, FT); 34 @printf(""Running static ocean benchmark: %s...\n"", bname); 35 for i in 1:Nt; 36 @timeit timer bname time_step!(model, 1); 37 end; 38 end; 39 ; 40 #####; 41 ##### Print benchmark results; 42 #####; 43 ; 44 println(); 45 println(oceananigans_versioninfo()); 46 println(versioninfo_with_gpu()); 47 ; 48 print_timer(timer, title=""Static ocean benchmarks"", sortby=:name); 49 ; 50 println(""\n\nCPU Float64 -> Float32 speedup:""); 51 for N in Ns; 52 bn32 = benchmark_name(N, """", CPU(), F",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:104501,Testability,benchmark,benchmark,104501,"all : 0.010. [1000.00%] i: 1, t: 1.00e-04, umax: (1.59e+00, 3.11e-01, 3.85e-01), CFL: 2.03e-04, νκmax: (9.98e-02, 9.97e-02), νκCFL: (1.60e-04, 1.60e-04), next Δt: 1.00e-04, wall time: 82.994 ms; Running static ocean benchmark: 16× 16× 16 [CPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [CPU, Float64]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_static_ocean_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 29 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 30 ; 31 time_step!(model, 1) # precompile; 32 ; 33 bname = benchmark_name(N, """", arch, FT); 34 @printf(""Running static ocean benchmark: %s...\n"", bname); 35 for i in 1:Nt; 36 @timeit timer bname time_step!(model, 1); 37 end; 38 end; 39 ; 40 #####; 41 ##### Print benchmark results; 42 #####; 43 ; 44 println(); 45 println(oceananigans_versioninfo()); 46 println(versioninfo_with_gpu()); 47 ; 48 print_timer(timer, title=""Static ocean benchmarks"", sortby=:name); 49 ; 50 println(""\n\nCPU Float64 -> Float32 speedup:""); 51 for N in Ns; 52 bn32 = benchmark_name(N, """", CPU(), Float32); 53 bn64 = benchmark_name(N, """", CPU(), Float64); 54 t32 = Time",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:104553,Testability,Benchmark,Benchmark,104553,"3.85e-01), CFL: 2.03e-04, νκmax: (9.98e-02, 9.97e-02), νκCFL: (1.60e-04, 1.60e-04), next Δt: 1.00e-04, wall time: 82.994 ms; Running static ocean benchmark: 16× 16× 16 [CPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [CPU, Float64]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_static_ocean_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 29 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 30 ; 31 time_step!(model, 1) # precompile; 32 ; 33 bname = benchmark_name(N, """", arch, FT); 34 @printf(""Running static ocean benchmark: %s...\n"", bname); 35 for i in 1:Nt; 36 @timeit timer bname time_step!(model, 1); 37 end; 38 end; 39 ; 40 #####; 41 ##### Print benchmark results; 42 #####; 43 ; 44 println(); 45 println(oceananigans_versioninfo()); 46 println(versioninfo_with_gpu()); 47 ; 48 print_timer(timer, title=""Static ocean benchmarks"", sortby=:name); 49 ; 50 println(""\n\nCPU Float64 -> Float32 speedup:""); 51 for N in Ns; 52 bn32 = benchmark_name(N, """", CPU(), Float32); 53 bn64 = benchmark_name(N, """", CPU(), Float64); 54 t32 = TimerOutputs.time(timer[bn32]); 55 t64 = TimerOutputs.time(timer[bn64]); 5",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:104631,Testability,benchmark,benchmarks,104631,", Float64]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_static_ocean_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 29 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 30 ; 31 time_step!(model, 1) # precompile; 32 ; 33 bname = benchmark_name(N, """", arch, FT); 34 @printf(""Running static ocean benchmark: %s...\n"", bname); 35 for i in 1:Nt; 36 @timeit timer bname time_step!(model, 1); 37 end; 38 end; 39 ; 40 #####; 41 ##### Print benchmark results; 42 #####; 43 ; 44 println(); 45 println(oceananigans_versioninfo()); 46 println(versioninfo_with_gpu()); 47 ; 48 print_timer(timer, title=""Static ocean benchmarks"", sortby=:name); 49 ; 50 println(""\n\nCPU Float64 -> Float32 speedup:""); 51 for N in Ns; 52 bn32 = benchmark_name(N, """", CPU(), Float32); 53 bn64 = benchmark_name(N, """", CPU(), Float64); 54 t32 = TimerOutputs.time(timer[bn32]); 55 t64 = TimerOutputs.time(timer[bn64]); 56 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 57 end; 58 ; 59 @hascuda begin; 60 println(""\nGPU Float64 -> Float32 speedup:""); 61 for N in Ns; 62 bn32 = benchmark_name(N, """", GPU(), Float32); 63 bn64 = benchmark_name(N, """", GPU",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:104968,Testability,benchmark,benchmark,104968,", Float64]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float32]...; Running static ocean benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_static_ocean_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 29 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 30 ; 31 time_step!(model, 1) # precompile; 32 ; 33 bname = benchmark_name(N, """", arch, FT); 34 @printf(""Running static ocean benchmark: %s...\n"", bname); 35 for i in 1:Nt; 36 @timeit timer bname time_step!(model, 1); 37 end; 38 end; 39 ; 40 #####; 41 ##### Print benchmark results; 42 #####; 43 ; 44 println(); 45 println(oceananigans_versioninfo()); 46 println(versioninfo_with_gpu()); 47 ; 48 print_timer(timer, title=""Static ocean benchmarks"", sortby=:name); 49 ; 50 println(""\n\nCPU Float64 -> Float32 speedup:""); 51 for N in Ns; 52 bn32 = benchmark_name(N, """", CPU(), Float32); 53 bn64 = benchmark_name(N, """", CPU(), Float64); 54 t32 = TimerOutputs.time(timer[bn32]); 55 t64 = TimerOutputs.time(timer[bn64]); 56 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 57 end; 58 ; 59 @hascuda begin; 60 println(""\nGPU Float64 -> Float32 speedup:""); 61 for N in Ns; 62 bn32 = benchmark_name(N, """", GPU(), Float32); 63 bn64 = benchmark_name(N, """", GPU",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:105106,Testability,benchmark,benchmark,105106,"tions to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 29 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 30 ; 31 time_step!(model, 1) # precompile; 32 ; 33 bname = benchmark_name(N, """", arch, FT); 34 @printf(""Running static ocean benchmark: %s...\n"", bname); 35 for i in 1:Nt; 36 @timeit timer bname time_step!(model, 1); 37 end; 38 end; 39 ; 40 #####; 41 ##### Print benchmark results; 42 #####; 43 ; 44 println(); 45 println(oceananigans_versioninfo()); 46 println(versioninfo_with_gpu()); 47 ; 48 print_timer(timer, title=""Static ocean benchmarks"", sortby=:name); 49 ; 50 println(""\n\nCPU Float64 -> Float32 speedup:""); 51 for N in Ns; 52 bn32 = benchmark_name(N, """", CPU(), Float32); 53 bn64 = benchmark_name(N, """", CPU(), Float64); 54 t32 = TimerOutputs.time(timer[bn32]); 55 t64 = TimerOutputs.time(timer[bn64]); 56 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 57 end; 58 ; 59 @hascuda begin; 60 println(""\nGPU Float64 -> Float32 speedup:""); 61 for N in Ns; 62 bn32 = benchmark_name(N, """", GPU(), Float32); 63 bn64 = benchmark_name(N, """", GPU(), Float64); 64 t32 = TimerOutputs.time(timer[bn32]); 65 t64 = TimerOutputs.time(timer[bn64]); 66 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 67 end; 68 ; 69 println(""\nCPU -> GPU speedup:""); 70 for N in Ns, ft in float_types; 71 bn_cpu = benchmark_name(N, """", CPU(), ft); 72 bn_gpu = benchmark_name(N, """", GPU(), ft); 73 t_cpu = TimerOutputs.time(timer[bn_cpu]); 74 t_gpu = TimerOutputs.time(timer[bn_gpu]); 75 @printf(""%s: %.3f\n"", benchma",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:105277,Testability,benchmark,benchmarks,105277,"tions to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 29 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 30 ; 31 time_step!(model, 1) # precompile; 32 ; 33 bname = benchmark_name(N, """", arch, FT); 34 @printf(""Running static ocean benchmark: %s...\n"", bname); 35 for i in 1:Nt; 36 @timeit timer bname time_step!(model, 1); 37 end; 38 end; 39 ; 40 #####; 41 ##### Print benchmark results; 42 #####; 43 ; 44 println(); 45 println(oceananigans_versioninfo()); 46 println(versioninfo_with_gpu()); 47 ; 48 print_timer(timer, title=""Static ocean benchmarks"", sortby=:name); 49 ; 50 println(""\n\nCPU Float64 -> Float32 speedup:""); 51 for N in Ns; 52 bn32 = benchmark_name(N, """", CPU(), Float32); 53 bn64 = benchmark_name(N, """", CPU(), Float64); 54 t32 = TimerOutputs.time(timer[bn32]); 55 t64 = TimerOutputs.time(timer[bn64]); 56 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 57 end; 58 ; 59 @hascuda begin; 60 println(""\nGPU Float64 -> Float32 speedup:""); 61 for N in Ns; 62 bn32 = benchmark_name(N, """", GPU(), Float32); 63 bn64 = benchmark_name(N, """", GPU(), Float64); 64 t32 = TimerOutputs.time(timer[bn32]); 65 t64 = TimerOutputs.time(timer[bn64]); 66 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 67 end; 68 ; 69 println(""\nCPU -> GPU speedup:""); 70 for N in Ns, ft in float_types; 71 bn_cpu = benchmark_name(N, """", CPU(), ft); 72 bn_gpu = benchmark_name(N, """", GPU(), ft); 73 t_cpu = TimerOutputs.time(timer[bn_cpu]); 74 t_gpu = TimerOutputs.time(timer[bn_gpu]); 75 @printf(""%s: %.3f\n"", benchma",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:106322,Testability,benchmark,benchmark,106322,"y=:name); 49 ; 50 println(""\n\nCPU Float64 -> Float32 speedup:""); 51 for N in Ns; 52 bn32 = benchmark_name(N, """", CPU(), Float32); 53 bn64 = benchmark_name(N, """", CPU(), Float64); 54 t32 = TimerOutputs.time(timer[bn32]); 55 t64 = TimerOutputs.time(timer[bn64]); 56 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 57 end; 58 ; 59 @hascuda begin; 60 println(""\nGPU Float64 -> Float32 speedup:""); 61 for N in Ns; 62 bn32 = benchmark_name(N, """", GPU(), Float32); 63 bn64 = benchmark_name(N, """", GPU(), Float64); 64 t32 = TimerOutputs.time(timer[bn32]); 65 t64 = TimerOutputs.time(timer[bn64]); 66 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 67 end; 68 ; 69 println(""\nCPU -> GPU speedup:""); 70 for N in Ns, ft in float_types; 71 bn_cpu = benchmark_name(N, """", CPU(), ft); 72 bn_gpu = benchmark_name(N, """", GPU(), ft); 73 t_cpu = TimerOutputs.time(timer[bn_cpu]); 74 t_gpu = TimerOutputs.time(timer[bn_gpu]); 75 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 76 end; 77 end; 78 ; 79 end # module; Static ocean benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; Expression: run_script(replace_strings, ""static_ocean"", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running chan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:106333,Testability,Test,Test,106333,"y=:name); 49 ; 50 println(""\n\nCPU Float64 -> Float32 speedup:""); 51 for N in Ns; 52 bn32 = benchmark_name(N, """", CPU(), Float32); 53 bn64 = benchmark_name(N, """", CPU(), Float64); 54 t32 = TimerOutputs.time(timer[bn32]); 55 t64 = TimerOutputs.time(timer[bn64]); 56 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 57 end; 58 ; 59 @hascuda begin; 60 println(""\nGPU Float64 -> Float32 speedup:""); 61 for N in Ns; 62 bn32 = benchmark_name(N, """", GPU(), Float32); 63 bn64 = benchmark_name(N, """", GPU(), Float64); 64 t32 = TimerOutputs.time(timer[bn32]); 65 t64 = TimerOutputs.time(timer[bn64]); 66 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 67 end; 68 ; 69 println(""\nCPU -> GPU speedup:""); 70 for N in Ns, ft in float_types; 71 bn_cpu = benchmark_name(N, """", CPU(), ft); 72 bn_gpu = benchmark_name(N, """", GPU(), ft); 73 t_cpu = TimerOutputs.time(timer[bn_cpu]); 74 t_gpu = TimerOutputs.time(timer[bn_gpu]); 75 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 76 end; 77 end; 78 ; 79 end # module; Static ocean benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; Expression: run_script(replace_strings, ""static_ocean"", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running chan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:106398,Testability,test,test,106398,"hmark_name(N, """", CPU(), Float32); 53 bn64 = benchmark_name(N, """", CPU(), Float64); 54 t32 = TimerOutputs.time(timer[bn32]); 55 t64 = TimerOutputs.time(timer[bn64]); 56 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 57 end; 58 ; 59 @hascuda begin; 60 println(""\nGPU Float64 -> Float32 speedup:""); 61 for N in Ns; 62 bn32 = benchmark_name(N, """", GPU(), Float32); 63 bn64 = benchmark_name(N, """", GPU(), Float64); 64 t32 = TimerOutputs.time(timer[bn32]); 65 t64 = TimerOutputs.time(timer[bn64]); 66 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 67 end; 68 ; 69 println(""\nCPU -> GPU speedup:""); 70 for N in Ns, ft in float_types; 71 bn_cpu = benchmark_name(N, """", CPU(), ft); 72 bn_gpu = benchmark_name(N, """", GPU(), ft); 73 t_cpu = TimerOutputs.time(timer[bn_cpu]); 74 t_gpu = TimerOutputs.time(timer[bn_gpu]); 75 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 76 end; 77 end; 78 ; 79 end # module; Static ocean benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; Expression: run_script(replace_strings, ""static_ocean"", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:106605,Testability,test,test,106605,"), t64/t32); 57 end; 58 ; 59 @hascuda begin; 60 println(""\nGPU Float64 -> Float32 speedup:""); 61 for N in Ns; 62 bn32 = benchmark_name(N, """", GPU(), Float32); 63 bn64 = benchmark_name(N, """", GPU(), Float64); 64 t32 = TimerOutputs.time(timer[bn32]); 65 t64 = TimerOutputs.time(timer[bn64]); 66 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 67 end; 68 ; 69 println(""\nCPU -> GPU speedup:""); 70 for N in Ns, ft in float_types; 71 bn_cpu = benchmark_name(N, """", CPU(), ft); 72 bn_gpu = benchmark_name(N, """", GPU(), ft); 73 t_cpu = TimerOutputs.time(timer[bn_cpu]); 74 t_gpu = TimerOutputs.time(timer[bn_gpu]); 75 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 76 end; 77 end; 78 ; 79 end # module; Static ocean benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; Expression: run_script(replace_strings, ""static_ocean"", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 u",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:106726,Testability,Test,Test,106726,"(N, """", GPU(), Float32); 63 bn64 = benchmark_name(N, """", GPU(), Float64); 64 t32 = TimerOutputs.time(timer[bn32]); 65 t64 = TimerOutputs.time(timer[bn64]); 66 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 67 end; 68 ; 69 println(""\nCPU -> GPU speedup:""); 70 for N in Ns, ft in float_types; 71 bn_cpu = benchmark_name(N, """", CPU(), ft); 72 bn_gpu = benchmark_name(N, """", GPU(), ft); 73 t_cpu = TimerOutputs.time(timer[bn_cpu]); 74 t_gpu = TimerOutputs.time(timer[bn_gpu]); 75 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 76 end; 77 end; 78 ; 79 end # module; Static ocean benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; Expression: run_script(replace_strings, ""static_ocean"", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and paramet",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:106735,Testability,Test,Test,106735,"(N, """", GPU(), Float32); 63 bn64 = benchmark_name(N, """", GPU(), Float64); 64 t32 = TimerOutputs.time(timer[bn32]); 65 t64 = TimerOutputs.time(timer[bn64]); 66 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 67 end; 68 ; 69 println(""\nCPU -> GPU speedup:""); 70 for N in Ns, ft in float_types; 71 bn_cpu = benchmark_name(N, """", CPU(), ft); 72 bn_gpu = benchmark_name(N, """", GPU(), ft); 73 t_cpu = TimerOutputs.time(timer[bn_cpu]); 74 t_gpu = TimerOutputs.time(timer[bn_gpu]); 75 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 76 end; 77 end; 78 ; 79 end # module; Static ocean benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; Expression: run_script(replace_strings, ""static_ocean"", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and paramet",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:106822,Testability,test,test,106822,"TimerOutputs.time(timer[bn32]); 65 t64 = TimerOutputs.time(timer[bn64]); 66 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 67 end; 68 ; 69 println(""\nCPU -> GPU speedup:""); 70 for N in Ns, ft in float_types; 71 bn_cpu = benchmark_name(N, """", CPU(), ft); 72 bn_gpu = benchmark_name(N, """", GPU(), ft); 73 t_cpu = TimerOutputs.time(timer[bn_cpu]); 74 t_gpu = TimerOutputs.time(timer[bn_gpu]); 75 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 76 end; 77 end; 78 ; 79 end # module; Static ocean benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; Expression: run_script(replace_strings, ""static_ocean"", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iter",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:106943,Testability,Test,Test,106943," 68 ; 69 println(""\nCPU -> GPU speedup:""); 70 for N in Ns, ft in float_types; 71 bn_cpu = benchmark_name(N, """", CPU(), ft); 72 bn_gpu = benchmark_name(N, """", GPU(), ft); 73 t_cpu = TimerOutputs.time(timer[bn_cpu]); 74 t_gpu = TimerOutputs.time(timer[bn_gpu]); 75 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 76 end; 77 end; 78 ; 79 end # module; Static ocean benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; Expression: run_script(replace_strings, ""static_ocean"", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:106952,Testability,Test,Test,106952," 68 ; 69 println(""\nCPU -> GPU speedup:""); 70 for N in Ns, ft in float_types; 71 bn_cpu = benchmark_name(N, """", CPU(), ft); 72 bn_gpu = benchmark_name(N, """", GPU(), ft); 73 t_cpu = TimerOutputs.time(timer[bn_cpu]); 74 t_gpu = TimerOutputs.time(timer[bn_gpu]); 75 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 76 end; 77 end; 78 ; 79 end # module; Static ocean benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; Expression: run_script(replace_strings, ""static_ocean"", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:107039,Testability,test,test,107039,"_cpu = benchmark_name(N, """", CPU(), ft); 72 bn_gpu = benchmark_name(N, """", GPU(), ft); 73 t_cpu = TimerOutputs.time(timer[bn_cpu]); 74 t_gpu = TimerOutputs.time(timer[bn_gpu]); 75 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 76 end; 77 end; 78 ; 79 end # module; Static ocean benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; Expression: run_script(replace_strings, ""static_ocean"", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to bench",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:107160,Testability,Test,Test,107160," t_gpu = TimerOutputs.time(timer[bn_gpu]); 75 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 76 end; 77 end; 78 ; 79 end # module; Static ocean benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; Expression: run_script(replace_strings, ""static_ocean"", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-e",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:107169,Testability,Test,Test,107169," t_gpu = TimerOutputs.time(timer[bn_gpu]); 75 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 76 end; 77 end; 78 ; 79 end # module; Static ocean benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; Expression: run_script(replace_strings, ""static_ocean"", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-e",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:107256,Testability,test,test,107256,"N, ft), t_cpu/t_gpu); 76 end; 77 end; 78 ; 79 end # module; Static ocean benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; Expression: run_script(replace_strings, ""static_ocean"", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:107300,Testability,benchmark,benchmark,107300,"; Static ocean benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; Expression: run_script(replace_strings, ""static_ocean"", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 	topology = (Period",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:107357,Testability,benchmark,benchmark,107357,"lia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; Expression: run_script(replace_strings, ""static_ocean"", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 	topology = (Periodic, Bounded, Bounded); 29 	grid = RegularCartesianGrid(topol",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:107414,Testability,benchmark,benchmark,107414,"3; Expression: run_script(replace_strings, ""static_ocean"", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 	topology = (Periodic, Bounded, Bounded); 29 	grid = RegularCartesianGrid(topology=topology, size=N, extent=(1, 1, 1)); 30 model = Incom",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:107471,Testability,benchmark,benchmark,107471,", benchmark_filepath(""static_ocean"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:23; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 	topology = (Periodic, Bounded, Bounded); 29 	grid = RegularCartesianGrid(topology=topology, size=N, extent=(1, 1, 1)); 30 model = IncompressibleModel(architecture=arch, float_type=FT, grid=gri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:107705,Testability,Benchmark,Benchmark,107705,"at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 	topology = (Periodic, Bounded, Bounded); 29 	grid = RegularCartesianGrid(topology=topology, size=N, extent=(1, 1, 1)); 30 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 31 ; 32 time_step!(model, 1) # precompile; 33 ; 34 bname = benchmark_name(N, """", arch, FT); 35 @printf(""Running channel benchmark: %s...\n"", bname); 36 for i in 1:Nt; 37 @timeit timer bname time_step!(model, 1); 38 end; 39 end; 40 ; 41 #####; 42 ##### Print benchmark results; 43 ####",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:107834,Testability,benchmark,benchmarking,107834,"at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:16; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 	topology = (Periodic, Bounded, Bounded); 29 	grid = RegularCartesianGrid(topology=topology, size=N, extent=(1, 1, 1)); 30 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 31 ; 32 time_step!(model, 1) # precompile; 33 ; 34 bname = benchmark_name(N, """", arch, FT); 35 @printf(""Running channel benchmark: %s...\n"", bname); 36 for i in 1:Nt; 37 @timeit timer bname time_step!(model, 1); 38 end; 39 end; 40 ; 41 #####; 42 ##### Print benchmark results; 43 ####",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:107894,Testability,benchmark,benchmarks,107894,"er/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 	topology = (Periodic, Bounded, Bounded); 29 	grid = RegularCartesianGrid(topology=topology, size=N, extent=(1, 1, 1)); 30 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 31 ; 32 time_step!(model, 1) # precompile; 33 ; 34 bname = benchmark_name(N, """", arch, FT); 35 @printf(""Running channel benchmark: %s...\n"", bname); 36 for i in 1:Nt; 37 @timeit timer bname time_step!(model, 1); 38 end; 39 end; 40 ; 41 #####; 42 ##### Print benchmark results; 43 #####; 44 ; 45 println(); 46 println(oceananigans_versioninfo()); 47 println(versioninfo_with_gpu()); 48 ; 49 print_ti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:107936,Testability,benchmark,benchmarking,107936,"lia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 	topology = (Periodic, Bounded, Bounded); 29 	grid = RegularCartesianGrid(topology=topology, size=N, extent=(1, 1, 1)); 30 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 31 ; 32 time_step!(model, 1) # precompile; 33 ; 34 bname = benchmark_name(N, """", arch, FT); 35 @printf(""Running channel benchmark: %s...\n"", bname); 36 for i in 1:Nt; 37 @timeit timer bname time_step!(model, 1); 38 end; 39 end; 40 ; 41 #####; 42 ##### Print benchmark results; 43 #####; 44 ; 45 println(); 46 println(oceananigans_versioninfo()); 47 println(versioninfo_with_gpu()); 48 ; 49 print_timer(timer, title=""Channel benchmarks"", sortb",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:108028,Testability,benchmark,benchmark,108028,"e/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 	topology = (Periodic, Bounded, Bounded); 29 	grid = RegularCartesianGrid(topology=topology, size=N, extent=(1, 1, 1)); 30 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 31 ; 32 time_step!(model, 1) # precompile; 33 ; 34 bname = benchmark_name(N, """", arch, FT); 35 @printf(""Running channel benchmark: %s...\n"", bname); 36 for i in 1:Nt; 37 @timeit timer bname time_step!(model, 1); 38 end; 39 end; 40 ; 41 #####; 42 ##### Print benchmark results; 43 #####; 44 ; 45 println(); 46 println(oceananigans_versioninfo()); 47 println(versioninfo_with_gpu()); 48 ; 49 print_timer(timer, title=""Channel benchmarks"", sortby=:name); 50 ; 51 println(""\n\nCPU Float64 -> Float32 speedup:""); 5",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:108078,Testability,benchmark,benchmark,108078,"3; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 	topology = (Periodic, Bounded, Bounded); 29 	grid = RegularCartesianGrid(topology=topology, size=N, extent=(1, 1, 1)); 30 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 31 ; 32 time_step!(model, 1) # precompile; 33 ; 34 bname = benchmark_name(N, """", arch, FT); 35 @printf(""Running channel benchmark: %s...\n"", bname); 36 for i in 1:Nt; 37 @timeit timer bname time_step!(model, 1); 38 end; 39 end; 40 ; 41 #####; 42 ##### Print benchmark results; 43 #####; 44 ; 45 println(); 46 println(oceananigans_versioninfo()); 47 println(versioninfo_with_gpu()); 48 ; 49 print_timer(timer, title=""Channel benchmarks"", sortby=:name); 50 ; 51 println(""\n\nCPU Float64 -> Float32 speedup:""); 52 for N in Ns; 53 bn32 = benchmark_name(N, """", CPU(), Float32); 54 bn64",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:108130,Testability,Benchmark,Benchmark,108130,"r/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running channel benchmark: 16× 16× 16 [CPU, Float32]...; Running channel benchmark: 16× 16× 16 [CPU, Float64]...; Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 	topology = (Periodic, Bounded, Bounded); 29 	grid = RegularCartesianGrid(topology=topology, size=N, extent=(1, 1, 1)); 30 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 31 ; 32 time_step!(model, 1) # precompile; 33 ; 34 bname = benchmark_name(N, """", arch, FT); 35 @printf(""Running channel benchmark: %s...\n"", bname); 36 for i in 1:Nt; 37 @timeit timer bname time_step!(model, 1); 38 end; 39 end; 40 ; 41 #####; 42 ##### Print benchmark results; 43 #####; 44 ; 45 println(); 46 println(oceananigans_versioninfo()); 47 println(versioninfo_with_gpu()); 48 ; 49 print_timer(timer, title=""Channel benchmarks"", sortby=:name); 50 ; 51 println(""\n\nCPU Float64 -> Float32 speedup:""); 52 for N in Ns; 53 bn32 = benchmark_name(N, """", CPU(), Float32); 54 bn64 = benchmark_name(N, """", CPU(), Float64); 55 t32 = TimerOutputs.time(t",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:108208,Testability,benchmark,benchmarks,108208,"Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 	topology = (Periodic, Bounded, Bounded); 29 	grid = RegularCartesianGrid(topology=topology, size=N, extent=(1, 1, 1)); 30 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 31 ; 32 time_step!(model, 1) # precompile; 33 ; 34 bname = benchmark_name(N, """", arch, FT); 35 @printf(""Running channel benchmark: %s...\n"", bname); 36 for i in 1:Nt; 37 @timeit timer bname time_step!(model, 1); 38 end; 39 end; 40 ; 41 #####; 42 ##### Print benchmark results; 43 #####; 44 ; 45 println(); 46 println(oceananigans_versioninfo()); 47 println(versioninfo_with_gpu()); 48 ; 49 print_timer(timer, title=""Channel benchmarks"", sortby=:name); 50 ; 51 println(""\n\nCPU Float64 -> Float32 speedup:""); 52 for N in Ns; 53 bn32 = benchmark_name(N, """", CPU(), Float32); 54 bn64 = benchmark_name(N, """", CPU(), Float64); 55 t32 = TimerOutputs.time(timer[bn32]); 56 t64 = TimerOutputs.time(timer[bn64]); 57 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 58 end; 59 ; 60 @hascuda begin; 61 println(""\nGPU Float64 -> Float32 speedup:""); 62 for N in Ns; 63 bn32 = benchmark_name(N, """", GPU(), Float32); 64 bn64 = ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:108605,Testability,benchmark,benchmark,108605,"Running channel benchmark: 16× 16× 16 [GPU, Float32]...; Running channel benchmark: 16× 16× 16 [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_channel_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 16 ; 17 # Model resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 	topology = (Periodic, Bounded, Bounded); 29 	grid = RegularCartesianGrid(topology=topology, size=N, extent=(1, 1, 1)); 30 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 31 ; 32 time_step!(model, 1) # precompile; 33 ; 34 bname = benchmark_name(N, """", arch, FT); 35 @printf(""Running channel benchmark: %s...\n"", bname); 36 for i in 1:Nt; 37 @timeit timer bname time_step!(model, 1); 38 end; 39 end; 40 ; 41 #####; 42 ##### Print benchmark results; 43 #####; 44 ; 45 println(); 46 println(oceananigans_versioninfo()); 47 println(versioninfo_with_gpu()); 48 ; 49 print_timer(timer, title=""Channel benchmarks"", sortby=:name); 50 ; 51 println(""\n\nCPU Float64 -> Float32 speedup:""); 52 for N in Ns; 53 bn32 = benchmark_name(N, """", CPU(), Float32); 54 bn64 = benchmark_name(N, """", CPU(), Float64); 55 t32 = TimerOutputs.time(timer[bn32]); 56 t64 = TimerOutputs.time(timer[bn64]); 57 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 58 end; 59 ; 60 @hascuda begin; 61 println(""\nGPU Float64 -> Float32 speedup:""); 62 for N in Ns; 63 bn32 = benchmark_name(N, """", GPU(), Float32); 64 bn64 = ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:108743,Testability,benchmark,benchmark,108743,"del resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 	topology = (Periodic, Bounded, Bounded); 29 	grid = RegularCartesianGrid(topology=topology, size=N, extent=(1, 1, 1)); 30 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 31 ; 32 time_step!(model, 1) # precompile; 33 ; 34 bname = benchmark_name(N, """", arch, FT); 35 @printf(""Running channel benchmark: %s...\n"", bname); 36 for i in 1:Nt; 37 @timeit timer bname time_step!(model, 1); 38 end; 39 end; 40 ; 41 #####; 42 ##### Print benchmark results; 43 #####; 44 ; 45 println(); 46 println(oceananigans_versioninfo()); 47 println(versioninfo_with_gpu()); 48 ; 49 print_timer(timer, title=""Channel benchmarks"", sortby=:name); 50 ; 51 println(""\n\nCPU Float64 -> Float32 speedup:""); 52 for N in Ns; 53 bn32 = benchmark_name(N, """", CPU(), Float32); 54 bn64 = benchmark_name(N, """", CPU(), Float64); 55 t32 = TimerOutputs.time(timer[bn32]); 56 t64 = TimerOutputs.time(timer[bn64]); 57 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 58 end; 59 ; 60 @hascuda begin; 61 println(""\nGPU Float64 -> Float32 speedup:""); 62 for N in Ns; 63 bn32 = benchmark_name(N, """", GPU(), Float32); 64 bn64 = benchmark_name(N, """", GPU(), Float64); 65 t32 = TimerOutputs.time(timer[bn32]); 66 t64 = TimerOutputs.time(timer[bn64]); 67 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 68 end; 69 ; 70 println(""\nCPU -> GPU speedup:""); 71 for N in Ns, ft in float_types; 72 bn_cpu = benchmark_name(N, """", CPU(), ft); 73 bn_gpu = benchmark_name(N, """", GPU(), ft); 74 t_cpu = TimerOutputs.time(timer[bn_cpu]); 75 t_gpu = TimerOutputs.time(timer[bn_gpu]); 76 @printf(""%s: %.3f\n"", benchmark",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:108909,Testability,benchmark,benchmarks,108909,"del resolutions to benchmarks. Focusing on 3D models for GPU benchmarking.; 18 Ns = [(16, 16, 16)]; 19 float_types = [Float32, Float64] # Float types to benchmark.; 20 archs = [CPU()] # Architectures to benchmark on.; 21 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 22 ; 23 #####; 24 ##### Run benchmarks; 25 #####; 26 ; 27 for arch in archs, FT in float_types, N in Ns; 28 	topology = (Periodic, Bounded, Bounded); 29 	grid = RegularCartesianGrid(topology=topology, size=N, extent=(1, 1, 1)); 30 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid); 31 ; 32 time_step!(model, 1) # precompile; 33 ; 34 bname = benchmark_name(N, """", arch, FT); 35 @printf(""Running channel benchmark: %s...\n"", bname); 36 for i in 1:Nt; 37 @timeit timer bname time_step!(model, 1); 38 end; 39 end; 40 ; 41 #####; 42 ##### Print benchmark results; 43 #####; 44 ; 45 println(); 46 println(oceananigans_versioninfo()); 47 println(versioninfo_with_gpu()); 48 ; 49 print_timer(timer, title=""Channel benchmarks"", sortby=:name); 50 ; 51 println(""\n\nCPU Float64 -> Float32 speedup:""); 52 for N in Ns; 53 bn32 = benchmark_name(N, """", CPU(), Float32); 54 bn64 = benchmark_name(N, """", CPU(), Float64); 55 t32 = TimerOutputs.time(timer[bn32]); 56 t64 = TimerOutputs.time(timer[bn64]); 57 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 58 end; 59 ; 60 @hascuda begin; 61 println(""\nGPU Float64 -> Float32 speedup:""); 62 for N in Ns; 63 bn32 = benchmark_name(N, """", GPU(), Float32); 64 bn64 = benchmark_name(N, """", GPU(), Float64); 65 t32 = TimerOutputs.time(timer[bn32]); 66 t64 = TimerOutputs.time(timer[bn64]); 67 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 68 end; 69 ; 70 println(""\nCPU -> GPU speedup:""); 71 for N in Ns, ft in float_types; 72 bn_cpu = benchmark_name(N, """", CPU(), ft); 73 bn_gpu = benchmark_name(N, """", GPU(), ft); 74 t_cpu = TimerOutputs.time(timer[bn_cpu]); 75 t_gpu = TimerOutputs.time(timer[bn_gpu]); 76 @printf(""%s: %.3f\n"", benchmark",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:109949,Testability,benchmark,benchmark,109949,"tby=:name); 50 ; 51 println(""\n\nCPU Float64 -> Float32 speedup:""); 52 for N in Ns; 53 bn32 = benchmark_name(N, """", CPU(), Float32); 54 bn64 = benchmark_name(N, """", CPU(), Float64); 55 t32 = TimerOutputs.time(timer[bn32]); 56 t64 = TimerOutputs.time(timer[bn64]); 57 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 58 end; 59 ; 60 @hascuda begin; 61 println(""\nGPU Float64 -> Float32 speedup:""); 62 for N in Ns; 63 bn32 = benchmark_name(N, """", GPU(), Float32); 64 bn64 = benchmark_name(N, """", GPU(), Float64); 65 t32 = TimerOutputs.time(timer[bn32]); 66 t64 = TimerOutputs.time(timer[bn64]); 67 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 68 end; 69 ; 70 println(""\nCPU -> GPU speedup:""); 71 for N in Ns, ft in float_types; 72 bn_cpu = benchmark_name(N, """", CPU(), ft); 73 bn_gpu = benchmark_name(N, """", GPU(), ft); 74 t_cpu = TimerOutputs.time(timer[bn_cpu]); 75 t_gpu = TimerOutputs.time(timer[bn_gpu]); 76 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 77 end; 78 end; 79 ; 80 end # module; Channel benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; Expression: run_script(replace_strings, ""channel"", benchmark_filepath(""channel"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:109960,Testability,Test,Test,109960,"tby=:name); 50 ; 51 println(""\n\nCPU Float64 -> Float32 speedup:""); 52 for N in Ns; 53 bn32 = benchmark_name(N, """", CPU(), Float32); 54 bn64 = benchmark_name(N, """", CPU(), Float64); 55 t32 = TimerOutputs.time(timer[bn32]); 56 t64 = TimerOutputs.time(timer[bn64]); 57 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 58 end; 59 ; 60 @hascuda begin; 61 println(""\nGPU Float64 -> Float32 speedup:""); 62 for N in Ns; 63 bn32 = benchmark_name(N, """", GPU(), Float32); 64 bn64 = benchmark_name(N, """", GPU(), Float64); 65 t32 = TimerOutputs.time(timer[bn32]); 66 t64 = TimerOutputs.time(timer[bn64]); 67 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 68 end; 69 ; 70 println(""\nCPU -> GPU speedup:""); 71 for N in Ns, ft in float_types; 72 bn_cpu = benchmark_name(N, """", CPU(), ft); 73 bn_gpu = benchmark_name(N, """", GPU(), ft); 74 t_cpu = TimerOutputs.time(timer[bn_cpu]); 75 t_gpu = TimerOutputs.time(timer[bn_gpu]); 76 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 77 end; 78 end; 79 ; 80 end # module; Channel benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; Expression: run_script(replace_strings, ""channel"", benchmark_filepath(""channel"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:110025,Testability,test,test,110025," benchmark_name(N, """", CPU(), Float32); 54 bn64 = benchmark_name(N, """", CPU(), Float64); 55 t32 = TimerOutputs.time(timer[bn32]); 56 t64 = TimerOutputs.time(timer[bn64]); 57 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 58 end; 59 ; 60 @hascuda begin; 61 println(""\nGPU Float64 -> Float32 speedup:""); 62 for N in Ns; 63 bn32 = benchmark_name(N, """", GPU(), Float32); 64 bn64 = benchmark_name(N, """", GPU(), Float64); 65 t32 = TimerOutputs.time(timer[bn32]); 66 t64 = TimerOutputs.time(timer[bn64]); 67 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 68 end; 69 ; 70 println(""\nCPU -> GPU speedup:""); 71 for N in Ns, ft in float_types; 72 bn_cpu = benchmark_name(N, """", CPU(), ft); 73 bn_gpu = benchmark_name(N, """", GPU(), ft); 74 t_cpu = TimerOutputs.time(timer[bn_cpu]); 75 t_gpu = TimerOutputs.time(timer[bn_gpu]); 76 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 77 end; 78 end; 79 ; 80 end # module; Channel benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; Expression: run_script(replace_strings, ""channel"", benchmark_filepath(""channel"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:110222,Testability,test,test,110222,"enchmark_name(N), t64/t32); 58 end; 59 ; 60 @hascuda begin; 61 println(""\nGPU Float64 -> Float32 speedup:""); 62 for N in Ns; 63 bn32 = benchmark_name(N, """", GPU(), Float32); 64 bn64 = benchmark_name(N, """", GPU(), Float64); 65 t32 = TimerOutputs.time(timer[bn32]); 66 t64 = TimerOutputs.time(timer[bn64]); 67 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 68 end; 69 ; 70 println(""\nCPU -> GPU speedup:""); 71 for N in Ns, ft in float_types; 72 bn_cpu = benchmark_name(N, """", CPU(), ft); 73 bn_gpu = benchmark_name(N, """", GPU(), ft); 74 t_cpu = TimerOutputs.time(timer[bn_cpu]); 75 t_gpu = TimerOutputs.time(timer[bn_gpu]); 76 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 77 end; 78 end; 79 ; 80 end # module; Channel benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; Expression: run_script(replace_strings, ""channel"", benchmark_filepath(""channel"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark:",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:110343,Testability,Test,Test,110343," benchmark_name(N, """", GPU(), Float32); 64 bn64 = benchmark_name(N, """", GPU(), Float64); 65 t32 = TimerOutputs.time(timer[bn32]); 66 t64 = TimerOutputs.time(timer[bn64]); 67 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 68 end; 69 ; 70 println(""\nCPU -> GPU speedup:""); 71 for N in Ns, ft in float_types; 72 bn_cpu = benchmark_name(N, """", CPU(), ft); 73 bn_gpu = benchmark_name(N, """", GPU(), ft); 74 t_cpu = TimerOutputs.time(timer[bn_cpu]); 75 t_gpu = TimerOutputs.time(timer[bn_gpu]); 76 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 77 end; 78 end; 79 ; 80 end # module; Channel benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; Expression: run_script(replace_strings, ""channel"", benchmark_filepath(""channel"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:110352,Testability,Test,Test,110352," benchmark_name(N, """", GPU(), Float32); 64 bn64 = benchmark_name(N, """", GPU(), Float64); 65 t32 = TimerOutputs.time(timer[bn32]); 66 t64 = TimerOutputs.time(timer[bn64]); 67 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 68 end; 69 ; 70 println(""\nCPU -> GPU speedup:""); 71 for N in Ns, ft in float_types; 72 bn_cpu = benchmark_name(N, """", CPU(), ft); 73 bn_gpu = benchmark_name(N, """", GPU(), ft); 74 t_cpu = TimerOutputs.time(timer[bn_cpu]); 75 t_gpu = TimerOutputs.time(timer[bn_gpu]); 76 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 77 end; 78 end; 79 ; 80 end # module; Channel benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; Expression: run_script(replace_strings, ""channel"", benchmark_filepath(""channel"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:110439,Testability,test,test,110439,"t64); 65 t32 = TimerOutputs.time(timer[bn32]); 66 t64 = TimerOutputs.time(timer[bn64]); 67 @printf(""%s: %.3f\n"", benchmark_name(N), t64/t32); 68 end; 69 ; 70 println(""\nCPU -> GPU speedup:""); 71 for N in Ns, ft in float_types; 72 bn_cpu = benchmark_name(N, """", CPU(), ft); 73 bn_gpu = benchmark_name(N, """", GPU(), ft); 74 t_cpu = TimerOutputs.time(timer[bn_cpu]); 75 t_gpu = TimerOutputs.time(timer[bn_gpu]); 76 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 77 end; 78 end; 79 ; 80 end # module; Channel benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; Expression: run_script(replace_strings, ""channel"", benchmark_filepath(""channel"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:110560,Testability,Test,Test,110560,"4/t32); 68 end; 69 ; 70 println(""\nCPU -> GPU speedup:""); 71 for N in Ns, ft in float_types; 72 bn_cpu = benchmark_name(N, """", CPU(), ft); 73 bn_gpu = benchmark_name(N, """", GPU(), ft); 74 t_cpu = TimerOutputs.time(timer[bn_cpu]); 75 t_gpu = TimerOutputs.time(timer[bn_gpu]); 76 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 77 end; 78 end; 79 ; 80 end # module; Channel benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; Expression: run_script(replace_strings, ""channel"", benchmark_filepath(""channel"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Print",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:110569,Testability,Test,Test,110569,"4/t32); 68 end; 69 ; 70 println(""\nCPU -> GPU speedup:""); 71 for N in Ns, ft in float_types; 72 bn_cpu = benchmark_name(N, """", CPU(), ft); 73 bn_gpu = benchmark_name(N, """", GPU(), ft); 74 t_cpu = TimerOutputs.time(timer[bn_cpu]); 75 t_gpu = TimerOutputs.time(timer[bn_gpu]); 76 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 77 end; 78 end; 79 ; 80 end # module; Channel benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; Expression: run_script(replace_strings, ""channel"", benchmark_filepath(""channel"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Print",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:110656,Testability,test,test,110656,"at_types; 72 bn_cpu = benchmark_name(N, """", CPU(), ft); 73 bn_gpu = benchmark_name(N, """", GPU(), ft); 74 t_cpu = TimerOutputs.time(timer[bn_cpu]); 75 t_gpu = TimerOutputs.time(timer[bn_gpu]); 76 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 77 end; 78 end; 79 ; 80 end # module; Channel benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; Expression: run_script(replace_strings, ""channel"", benchmark_filepath(""channel"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosur",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:110777,Testability,Test,Test,110777,"er[bn_cpu]); 75 t_gpu = TimerOutputs.time(timer[bn_gpu]); 76 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 77 end; 78 end; 79 ; 80 end # module; Channel benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; Expression: run_script(replace_strings, ""channel"", benchmark_filepath(""channel"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:110786,Testability,Test,Test,110786,"er[bn_cpu]); 75 t_gpu = TimerOutputs.time(timer[bn_gpu]); 76 @printf(""%s: %.3f\n"", benchmark_name(N, ft), t_cpu/t_gpu); 77 end; 78 end; 79 ; 80 end # module; Channel benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; Expression: run_script(replace_strings, ""channel"", benchmark_filepath(""channel"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:110873,Testability,test,test,110873,"benchmark_name(N, ft), t_cpu/t_gpu); 77 end; 78 end; 79 ; 80 end # module; Channel benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; Expression: run_script(replace_strings, ""channel"", benchmark_filepath(""channel"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:110909,Testability,benchmark,benchmark,110909," # module; Channel benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; Expression: run_script(replace_strings, ""channel"", benchmark_filepath(""channel"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 # Run benchmark across ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:110979,Testability,benchmark,benchmark,110979,"s/Oceananigans/LW3v4/test/test_benchmarks.jl:34; Expression: run_script(replace_strings, ""channel"", benchmark_filepath(""channel"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 # Run benchmark across these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # F",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:111051,Testability,benchmark,benchmark,111051,"pt(replace_strings, ""channel"", benchmark_filepath(""channel"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 # Run benchmark across these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # Float types to benchmark.; 21 archs = [CPU()] # Architectures to bench",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:111117,Testability,benchmark,benchmark,111117,"1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 # Run benchmark across these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # Float types to benchmark.; 21 archs = [CPU()] # Architectures to benchmark on.; 22 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with C",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:111206,Testability,benchmark,benchmark,111206,"t_benchmarks.jl:34; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 # Run benchmark across these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # Float types to benchmark.; 21 archs = [CPU()] # Architectures to benchmark on.; 22 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 23 closures = [IsotropicDiffusivity, AnisotropicDiffusivity,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:111276,Testability,benchmark,benchmark,111276,"linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 # Run benchmark across these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # Float types to benchmark.; 21 archs = [CPU()] # Architectures to benchmark on.; 22 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 23 closures = [IsotropicDiffusivity, AnisotropicDiffusivity, SmagorinskyLilly,; 24 	 VerstappenAnisotropicMinimumDissipation]; 25 ;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:111348,Testability,benchmark,benchmark,111348,"top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 # Run benchmark across these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # Float types to benchmark.; 21 archs = [CPU()] # Architectures to benchmark on.; 22 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 23 closures = [IsotropicDiffusivity, AnisotropicDiffusivity, SmagorinskyLilly,; 24 	 VerstappenAnisotropicMinimumDissipation]; 25 ; 26 #####; 27 ##### Run benchmarks; 28 #####; 29 ; 30 for arch in arc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:111414,Testability,benchmark,benchmark,111414,"t_benchmarks.jl:27; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 # Run benchmark across these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # Float types to benchmark.; 21 archs = [CPU()] # Architectures to benchmark on.; 22 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 23 closures = [IsotropicDiffusivity, AnisotropicDiffusivity, SmagorinskyLilly,; 24 	 VerstappenAnisotropicMinimumDissipation]; 25 ; 26 #####; 27 ##### Run benchmarks; 28 #####; 29 ; 30 for arch in archs, FT in float_types, N in Ns, Closure in closures; 31 	grid = RegularCartesi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:111742,Testability,Benchmark,Benchmark,111742,"op-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 # Run benchmark across these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # Float types to benchmark.; 21 archs = [CPU()] # Architectures to benchmark on.; 22 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 23 closures = [IsotropicDiffusivity, AnisotropicDiffusivity, SmagorinskyLilly,; 24 	 VerstappenAnisotropicMinimumDissipation]; 25 ; 26 #####; 27 ##### Run benchmarks; 28 #####; 29 ; 30 for arch in archs, FT in float_types, N in Ns, Closure in closures; 31 	grid = RegularCartesianGrid(FT, size=N, extent=(1, 1, 1)); 32 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid, closure=Closure(FT)); 33 ; 34 time_step!(model, 1) # precompile; 35 ; 36 bn = benchmark_name(N, string(Closure), arch, FT); 37 @printf(""Running benchmark: %s...\n"", bn); 38 for i in 1:Nt; 39 @timeit timer bn time_step!(model, 1); 40 end; 41 end",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:111871,Testability,benchmark,benchmarking,111871,"op-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 # Run benchmark across these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # Float types to benchmark.; 21 archs = [CPU()] # Architectures to benchmark on.; 22 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 23 closures = [IsotropicDiffusivity, AnisotropicDiffusivity, SmagorinskyLilly,; 24 	 VerstappenAnisotropicMinimumDissipation]; 25 ; 26 #####; 27 ##### Run benchmarks; 28 #####; 29 ; 30 for arch in archs, FT in float_types, N in Ns, Closure in closures; 31 	grid = RegularCartesianGrid(FT, size=N, extent=(1, 1, 1)); 32 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid, closure=Closure(FT)); 33 ; 34 time_step!(model, 1) # precompile; 35 ; 36 bn = benchmark_name(N, string(Closure), arch, FT); 37 @printf(""Running benchmark: %s...\n"", bn); 38 for i in 1:Nt; 39 @timeit timer bn time_step!(model, 1); 40 end; 41 end",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:111914,Testability,benchmark,benchmark,111914," 16× 16 IsotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 # Run benchmark across these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # Float types to benchmark.; 21 archs = [CPU()] # Architectures to benchmark on.; 22 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 23 closures = [IsotropicDiffusivity, AnisotropicDiffusivity, SmagorinskyLilly,; 24 	 VerstappenAnisotropicMinimumDissipation]; 25 ; 26 #####; 27 ##### Run benchmarks; 28 #####; 29 ; 30 for arch in archs, FT in float_types, N in Ns, Closure in closures; 31 	grid = RegularCartesianGrid(FT, size=N, extent=(1, 1, 1)); 32 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid, closure=Closure(FT)); 33 ; 34 time_step!(model, 1) # precompile; 35 ; 36 bn = benchmark_name(N, string(Closure), arch, FT); 37 @printf(""Running benchmark: %s...\n"", bn); 38 for i in 1:Nt; 39 @timeit timer bn time_step!(model, 1); 40 end; 41 end; 42 ; 43 #####; 44 ##### Print benchmark results; 45 #####; 46 ; 47 println(); 48 println(oceananigans_versioninfo()",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:112018,Testability,benchmark,benchmark,112018,": 16× 16× 16 AnisotropicDiffusivity [CPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 # Run benchmark across these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # Float types to benchmark.; 21 archs = [CPU()] # Architectures to benchmark on.; 22 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 23 closures = [IsotropicDiffusivity, AnisotropicDiffusivity, SmagorinskyLilly,; 24 	 VerstappenAnisotropicMinimumDissipation]; 25 ; 26 #####; 27 ##### Run benchmarks; 28 #####; 29 ; 30 for arch in archs, FT in float_types, N in Ns, Closure in closures; 31 	grid = RegularCartesianGrid(FT, size=N, extent=(1, 1, 1)); 32 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid, closure=Closure(FT)); 33 ; 34 time_step!(model, 1) # precompile; 35 ; 36 bn = benchmark_name(N, string(Closure), arch, FT); 37 @printf(""Running benchmark: %s...\n"", bn); 38 for i in 1:Nt; 39 @timeit timer bn time_step!(model, 1); 40 end; 41 end; 42 ; 43 #####; 44 ##### Print benchmark results; 45 #####; 46 ; 47 println(); 48 println(oceananigans_versioninfo()); 49 println(versioninfo_with_gpu()); 50 print_timer(timer, titl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:112068,Testability,benchmark,benchmark,112068,"chmark: 16× 16× 16 SmagorinskyLilly [CPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 # Run benchmark across these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # Float types to benchmark.; 21 archs = [CPU()] # Architectures to benchmark on.; 22 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 23 closures = [IsotropicDiffusivity, AnisotropicDiffusivity, SmagorinskyLilly,; 24 	 VerstappenAnisotropicMinimumDissipation]; 25 ; 26 #####; 27 ##### Run benchmarks; 28 #####; 29 ; 30 for arch in archs, FT in float_types, N in Ns, Closure in closures; 31 	grid = RegularCartesianGrid(FT, size=N, extent=(1, 1, 1)); 32 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid, closure=Closure(FT)); 33 ; 34 time_step!(model, 1) # precompile; 35 ; 36 bn = benchmark_name(N, string(Closure), arch, FT); 37 @printf(""Running benchmark: %s...\n"", bn); 38 for i in 1:Nt; 39 @timeit timer bn time_step!(model, 1); 40 end; 41 end; 42 ; 43 #####; 44 ##### Print benchmark results; 45 #####; 46 ; 47 println(); 48 println(oceananigans_versioninfo()); 49 println(versioninfo_with_gpu()); 50 print_timer(timer, title=""Turbulence closure benchmarks"", sortby=:name); 51 println(); 52 ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:112120,Testability,Benchmark,Benchmark,112120,"rk: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [CPU, Float64]...; Running benchmark: 16× 16× 16 IsotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 AnisotropicDiffusivity [GPU, Float64]...; Running benchmark: 16× 16× 16 SmagorinskyLilly [GPU, Float64]...; Running benchmark: 16× 16× 16 VerstappenAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 # Run benchmark across these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # Float types to benchmark.; 21 archs = [CPU()] # Architectures to benchmark on.; 22 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 23 closures = [IsotropicDiffusivity, AnisotropicDiffusivity, SmagorinskyLilly,; 24 	 VerstappenAnisotropicMinimumDissipation]; 25 ; 26 #####; 27 ##### Run benchmarks; 28 #####; 29 ; 30 for arch in archs, FT in float_types, N in Ns, Closure in closures; 31 	grid = RegularCartesianGrid(FT, size=N, extent=(1, 1, 1)); 32 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid, closure=Closure(FT)); 33 ; 34 time_step!(model, 1) # precompile; 35 ; 36 bn = benchmark_name(N, string(Closure), arch, FT); 37 @printf(""Running benchmark: %s...\n"", bn); 38 for i in 1:Nt; 39 @timeit timer bn time_step!(model, 1); 40 end; 41 end; 42 ; 43 #####; 44 ##### Print benchmark results; 45 #####; 46 ; 47 println(); 48 println(oceananigans_versioninfo()); 49 println(versioninfo_with_gpu()); 50 print_timer(timer, title=""Turbulence closure benchmarks"", sortby=:name); 51 println(); 52 ; 53 end # module; Turbulence closures benchmark: Test Failed at /home",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:112325,Testability,benchmark,benchmarks,112325,"enAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 # Run benchmark across these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # Float types to benchmark.; 21 archs = [CPU()] # Architectures to benchmark on.; 22 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 23 closures = [IsotropicDiffusivity, AnisotropicDiffusivity, SmagorinskyLilly,; 24 	 VerstappenAnisotropicMinimumDissipation]; 25 ; 26 #####; 27 ##### Run benchmarks; 28 #####; 29 ; 30 for arch in archs, FT in float_types, N in Ns, Closure in closures; 31 	grid = RegularCartesianGrid(FT, size=N, extent=(1, 1, 1)); 32 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid, closure=Closure(FT)); 33 ; 34 time_step!(model, 1) # precompile; 35 ; 36 bn = benchmark_name(N, string(Closure), arch, FT); 37 @printf(""Running benchmark: %s...\n"", bn); 38 for i in 1:Nt; 39 @timeit timer bn time_step!(model, 1); 40 end; 41 end; 42 ; 43 #####; 44 ##### Print benchmark results; 45 #####; 46 ; 47 println(); 48 println(oceananigans_versioninfo()); 49 println(versioninfo_with_gpu()); 50 print_timer(timer, title=""Turbulence closure benchmarks"", sortby=:name); 51 println(); 52 ; 53 end # module; Turbulence closures benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; Expression: run_script(replace_strings, ""turbulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:112706,Testability,benchmark,benchmark,112706,"enAnisotropicMinimumDissipation [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_turbulence_closures_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.TurbulenceClosures; 6 using Oceananigans.Utils; 7 ; 8 include(""benchmark_utils.jl""); 9 ; 10 #####; 11 ##### Benchmark setup and parameters; 12 #####; 13 ; 14 const timer = TimerOutput(); 15 ; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 # Run benchmark across these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # Float types to benchmark.; 21 archs = [CPU()] # Architectures to benchmark on.; 22 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 23 closures = [IsotropicDiffusivity, AnisotropicDiffusivity, SmagorinskyLilly,; 24 	 VerstappenAnisotropicMinimumDissipation]; 25 ; 26 #####; 27 ##### Run benchmarks; 28 #####; 29 ; 30 for arch in archs, FT in float_types, N in Ns, Closure in closures; 31 	grid = RegularCartesianGrid(FT, size=N, extent=(1, 1, 1)); 32 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid, closure=Closure(FT)); 33 ; 34 time_step!(model, 1) # precompile; 35 ; 36 bn = benchmark_name(N, string(Closure), arch, FT); 37 @printf(""Running benchmark: %s...\n"", bn); 38 for i in 1:Nt; 39 @timeit timer bn time_step!(model, 1); 40 end; 41 end; 42 ; 43 #####; 44 ##### Print benchmark results; 45 #####; 46 ; 47 println(); 48 println(oceananigans_versioninfo()); 49 println(versioninfo_with_gpu()); 50 print_timer(timer, title=""Turbulence closure benchmarks"", sortby=:name); 51 println(); 52 ; 53 end # module; Turbulence closures benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; Expression: run_script(replace_strings, ""turbulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:112838,Testability,benchmark,benchmark,112838,"s these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # Float types to benchmark.; 21 archs = [CPU()] # Architectures to benchmark on.; 22 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 23 closures = [IsotropicDiffusivity, AnisotropicDiffusivity, SmagorinskyLilly,; 24 	 VerstappenAnisotropicMinimumDissipation]; 25 ; 26 #####; 27 ##### Run benchmarks; 28 #####; 29 ; 30 for arch in archs, FT in float_types, N in Ns, Closure in closures; 31 	grid = RegularCartesianGrid(FT, size=N, extent=(1, 1, 1)); 32 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid, closure=Closure(FT)); 33 ; 34 time_step!(model, 1) # precompile; 35 ; 36 bn = benchmark_name(N, string(Closure), arch, FT); 37 @printf(""Running benchmark: %s...\n"", bn); 38 for i in 1:Nt; 39 @timeit timer bn time_step!(model, 1); 40 end; 41 end; 42 ; 43 #####; 44 ##### Print benchmark results; 45 #####; 46 ; 47 println(); 48 println(oceananigans_versioninfo()); 49 println(versioninfo_with_gpu()); 50 print_timer(timer, title=""Turbulence closure benchmarks"", sortby=:name); 51 println(); 52 ; 53 end # module; Turbulence closures benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; Expression: run_script(replace_strings, ""turbulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:113010,Testability,benchmark,benchmarks,113010,"s these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # Float types to benchmark.; 21 archs = [CPU()] # Architectures to benchmark on.; 22 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 23 closures = [IsotropicDiffusivity, AnisotropicDiffusivity, SmagorinskyLilly,; 24 	 VerstappenAnisotropicMinimumDissipation]; 25 ; 26 #####; 27 ##### Run benchmarks; 28 #####; 29 ; 30 for arch in archs, FT in float_types, N in Ns, Closure in closures; 31 	grid = RegularCartesianGrid(FT, size=N, extent=(1, 1, 1)); 32 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid, closure=Closure(FT)); 33 ; 34 time_step!(model, 1) # precompile; 35 ; 36 bn = benchmark_name(N, string(Closure), arch, FT); 37 @printf(""Running benchmark: %s...\n"", bn); 38 for i in 1:Nt; 39 @timeit timer bn time_step!(model, 1); 40 end; 41 end; 42 ; 43 #####; 44 ##### Print benchmark results; 45 #####; 46 ; 47 println(); 48 println(oceananigans_versioninfo()); 49 println(versioninfo_with_gpu()); 50 print_timer(timer, title=""Turbulence closure benchmarks"", sortby=:name); 51 println(); 52 ; 53 end # module; Turbulence closures benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; Expression: run_script(replace_strings, ""turbulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:113094,Testability,benchmark,benchmark,113094,"s these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # Float types to benchmark.; 21 archs = [CPU()] # Architectures to benchmark on.; 22 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 23 closures = [IsotropicDiffusivity, AnisotropicDiffusivity, SmagorinskyLilly,; 24 	 VerstappenAnisotropicMinimumDissipation]; 25 ; 26 #####; 27 ##### Run benchmarks; 28 #####; 29 ; 30 for arch in archs, FT in float_types, N in Ns, Closure in closures; 31 	grid = RegularCartesianGrid(FT, size=N, extent=(1, 1, 1)); 32 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid, closure=Closure(FT)); 33 ; 34 time_step!(model, 1) # precompile; 35 ; 36 bn = benchmark_name(N, string(Closure), arch, FT); 37 @printf(""Running benchmark: %s...\n"", bn); 38 for i in 1:Nt; 39 @timeit timer bn time_step!(model, 1); 40 end; 41 end; 42 ; 43 #####; 44 ##### Print benchmark results; 45 #####; 46 ; 47 println(); 48 println(oceananigans_versioninfo()); 49 println(versioninfo_with_gpu()); 50 print_timer(timer, title=""Turbulence closure benchmarks"", sortby=:name); 51 println(); 52 ; 53 end # module; Turbulence closures benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; Expression: run_script(replace_strings, ""turbulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:113105,Testability,Test,Test,113105,"s these parameters.; 19 Ns = [(16, 16, 16)]; 20 float_types = [Float64] # Float types to benchmark.; 21 archs = [CPU()] # Architectures to benchmark on.; 22 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 23 closures = [IsotropicDiffusivity, AnisotropicDiffusivity, SmagorinskyLilly,; 24 	 VerstappenAnisotropicMinimumDissipation]; 25 ; 26 #####; 27 ##### Run benchmarks; 28 #####; 29 ; 30 for arch in archs, FT in float_types, N in Ns, Closure in closures; 31 	grid = RegularCartesianGrid(FT, size=N, extent=(1, 1, 1)); 32 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid, closure=Closure(FT)); 33 ; 34 time_step!(model, 1) # precompile; 35 ; 36 bn = benchmark_name(N, string(Closure), arch, FT); 37 @printf(""Running benchmark: %s...\n"", bn); 38 for i in 1:Nt; 39 @timeit timer bn time_step!(model, 1); 40 end; 41 end; 42 ; 43 #####; 44 ##### Print benchmark results; 45 #####; 46 ; 47 println(); 48 println(oceananigans_versioninfo()); 49 println(versioninfo_with_gpu()); 50 print_timer(timer, title=""Turbulence closure benchmarks"", sortby=:name); 51 println(); 52 ; 53 end # module; Turbulence closures benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; Expression: run_script(replace_strings, ""turbulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:113170,Testability,test,test,113170,"GPUs.; 23 closures = [IsotropicDiffusivity, AnisotropicDiffusivity, SmagorinskyLilly,; 24 	 VerstappenAnisotropicMinimumDissipation]; 25 ; 26 #####; 27 ##### Run benchmarks; 28 #####; 29 ; 30 for arch in archs, FT in float_types, N in Ns, Closure in closures; 31 	grid = RegularCartesianGrid(FT, size=N, extent=(1, 1, 1)); 32 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid, closure=Closure(FT)); 33 ; 34 time_step!(model, 1) # precompile; 35 ; 36 bn = benchmark_name(N, string(Closure), arch, FT); 37 @printf(""Running benchmark: %s...\n"", bn); 38 for i in 1:Nt; 39 @timeit timer bn time_step!(model, 1); 40 end; 41 end; 42 ; 43 #####; 44 ##### Print benchmark results; 45 #####; 46 ; 47 println(); 48 println(oceananigans_versioninfo()); 49 println(versioninfo_with_gpu()); 50 print_timer(timer, title=""Turbulence closure benchmarks"", sortby=:name); 51 println(); 52 ; 53 end # module; Turbulence closures benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; Expression: run_script(replace_strings, ""turbulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:113391,Testability,test,test,113391,"t_types, N in Ns, Closure in closures; 31 	grid = RegularCartesianGrid(FT, size=N, extent=(1, 1, 1)); 32 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid, closure=Closure(FT)); 33 ; 34 time_step!(model, 1) # precompile; 35 ; 36 bn = benchmark_name(N, string(Closure), arch, FT); 37 @printf(""Running benchmark: %s...\n"", bn); 38 for i in 1:Nt; 39 @timeit timer bn time_step!(model, 1); 40 end; 41 end; 42 ; 43 #####; 44 ##### Print benchmark results; 45 #####; 46 ; 47 println(); 48 println(oceananigans_versioninfo()); 49 println(versioninfo_with_gpu()); 50 print_timer(timer, title=""Turbulence closure benchmarks"", sortby=:name); 51 println(); 52 ; 53 end # module; Turbulence closures benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; Expression: run_script(replace_strings, ""turbulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 act",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:113512,Testability,Test,Test,113512,"rchitecture=arch, float_type=FT, grid=grid, closure=Closure(FT)); 33 ; 34 time_step!(model, 1) # precompile; 35 ; 36 bn = benchmark_name(N, string(Closure), arch, FT); 37 @printf(""Running benchmark: %s...\n"", bn); 38 for i in 1:Nt; 39 @timeit timer bn time_step!(model, 1); 40 end; 41 end; 42 ; 43 #####; 44 ##### Print benchmark results; 45 #####; 46 ; 47 println(); 48 println(oceananigans_versioninfo()); 49 println(versioninfo_with_gpu()); 50 print_timer(timer, title=""Turbulence closure benchmarks"", sortby=:name); 51 println(); 52 ; 53 end # module; Turbulence closures benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; Expression: run_script(replace_strings, ""turbulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 modul",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:113521,Testability,Test,Test,113521,"rchitecture=arch, float_type=FT, grid=grid, closure=Closure(FT)); 33 ; 34 time_step!(model, 1) # precompile; 35 ; 36 bn = benchmark_name(N, string(Closure), arch, FT); 37 @printf(""Running benchmark: %s...\n"", bn); 38 for i in 1:Nt; 39 @timeit timer bn time_step!(model, 1); 40 end; 41 end; 42 ; 43 #####; 44 ##### Print benchmark results; 45 #####; 46 ; 47 println(); 48 println(oceananigans_versioninfo()); 49 println(versioninfo_with_gpu()); 50 print_timer(timer, title=""Turbulence closure benchmarks"", sortby=:name); 51 println(); 52 ; 53 end # module; Turbulence closures benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; Expression: run_script(replace_strings, ""turbulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 modul",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:113608,Testability,test,test,113608,"!(model, 1) # precompile; 35 ; 36 bn = benchmark_name(N, string(Closure), arch, FT); 37 @printf(""Running benchmark: %s...\n"", bn); 38 for i in 1:Nt; 39 @timeit timer bn time_step!(model, 1); 40 end; 41 end; 42 ; 43 #####; 44 ##### Print benchmark results; 45 #####; 46 ; 47 println(); 48 println(oceananigans_versioninfo()); 49 println(versioninfo_with_gpu()); 50 print_timer(timer, title=""Turbulence closure benchmarks"", sortby=:name); 51 println(); 52 ; 53 end # module; Turbulence closures benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; Expression: run_script(replace_strings, ""turbulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 usin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:113729,Testability,Test,Test,113729,"for i in 1:Nt; 39 @timeit timer bn time_step!(model, 1); 40 end; 41 end; 42 ; 43 #####; 44 ##### Print benchmark results; 45 #####; 46 ; 47 println(); 48 println(oceananigans_versioninfo()); 49 println(versioninfo_with_gpu()); 50 print_timer(timer, title=""Turbulence closure benchmarks"", sortby=:name); 51 println(); 52 ; 53 end # module; Turbulence closures benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; Expression: run_script(replace_strings, ""turbulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 co",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:113738,Testability,Test,Test,113738,"for i in 1:Nt; 39 @timeit timer bn time_step!(model, 1); 40 end; 41 end; 42 ; 43 #####; 44 ##### Print benchmark results; 45 #####; 46 ; 47 println(); 48 println(oceananigans_versioninfo()); 49 println(versioninfo_with_gpu()); 50 print_timer(timer, title=""Turbulence closure benchmarks"", sortby=:name); 51 println(); 52 ; 53 end # module; Turbulence closures benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; Expression: run_script(replace_strings, ""turbulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 co",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:113825,Testability,test,test,113825,"###; 44 ##### Print benchmark results; 45 #####; 46 ; 47 println(); 48 println(oceananigans_versioninfo()); 49 println(versioninfo_with_gpu()); 50 print_timer(timer, title=""Turbulence closure benchmarks"", sortby=:name); 51 println(); 52 ; 53 end # module; Turbulence closures benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; Expression: run_script(replace_strings, ""turbulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 FT = Float64; 16 Nt = 10 # Number of iterations t",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:113946,Testability,Test,Test,113946,"h_gpu()); 50 print_timer(timer, title=""Turbulence closure benchmarks"", sortby=:name); 51 println(); 52 ; 53 end # module; Turbulence closures benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; Expression: run_script(replace_strings, ""turbulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 FT = Float64; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 archs = [CPU()] # Architectures to benchmark on.; 19 @hascuda archs = [CPU(), GPU()] #",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:113955,Testability,Test,Test,113955,"h_gpu()); 50 print_timer(timer, title=""Turbulence closure benchmarks"", sortby=:name); 51 println(); 52 ; 53 end # module; Turbulence closures benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; Expression: run_script(replace_strings, ""turbulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 FT = Float64; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 archs = [CPU()] # Architectures to benchmark on.; 19 @hascuda archs = [CPU(), GPU()] #",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:114042,Testability,test,test,114042,"); 51 println(); 52 ; 53 end # module; Turbulence closures benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; Expression: run_script(replace_strings, ""turbulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 FT = Float64; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 archs = [CPU()] # Architectures to benchmark on.; 19 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 20 ; 21 #####; 22 ##### Utility f",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:114078,Testability,benchmark,benchmark,114078,"mark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; Expression: run_script(replace_strings, ""turbulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 FT = Float64; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 archs = [CPU()] # Architectures to benchmark on.; 19 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 20 ; 21 #####; 22 ##### Utility functions for generating tracer lists; 23 #####; 24 ; 25 function",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:114148,Testability,benchmark,benchmark,114148,"st/test_benchmarks.jl:45; Expression: run_script(replace_strings, ""turbulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 FT = Float64; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 archs = [CPU()] # Architectures to benchmark on.; 19 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 20 ; 21 #####; 22 ##### Utility functions for generating tracer lists; 23 #####; 24 ; 25 function active_tracers(n); 26 n == 0 && return []; 27 n == 1 && return [:b]; 28",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:114218,Testability,benchmark,benchmark,114218,"bulence_closures"", benchmark_filepath(""turbulence_closures"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 FT = Float64; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 archs = [CPU()] # Architectures to benchmark on.; 19 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 20 ; 21 #####; 22 ##### Utility functions for generating tracer lists; 23 #####; 24 ; 25 function active_tracers(n); 26 n == 0 && return []; 27 n == 1 && return [:b]; 28 n == 2 && return [:T, :S]; 29 throw(ArgumentError(""Can't have more th",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:114288,Testability,benchmark,benchmark,114288,"ace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 FT = Float64; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 archs = [CPU()] # Architectures to benchmark on.; 19 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 20 ; 21 #####; 22 ##### Utility functions for generating tracer lists; 23 #####; 24 ; 25 function active_tracers(n); 26 n == 0 && return []; 27 n == 1 && return [:b]; 28 n == 2 && return [:T, :S]; 29 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 30 end; 31 ; 32 passive_tracers(n) = [Symbol(",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:114358,Testability,benchmark,benchmark,114358,"ns/LW3v4/test/test_benchmarks.jl:45; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 FT = Float64; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 archs = [CPU()] # Architectures to benchmark on.; 19 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 20 ; 21 #####; 22 ##### Utility functions for generating tracer lists; 23 #####; 24 ; 25 function active_tracers(n); 26 n == 0 && return []; 27 n == 1 && return [:b]; 28 n == 2 && return [:T, :S]; 29 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 30 end; 31 ; 32 passive_tracers(n) = [Symbol(""C"" * string(n)) for n in 1:n]; 33 ; 34 tracer_list(na, np) = Tuple(vc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:114428,Testability,benchmark,benchmark,114428,"er/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:38; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 FT = Float64; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 archs = [CPU()] # Architectures to benchmark on.; 19 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 20 ; 21 #####; 22 ##### Utility functions for generating tracer lists; 23 #####; 24 ; 25 function active_tracers(n); 26 n == 0 && return []; 27 n == 1 && return [:b]; 28 n == 2 && return [:T, :S]; 29 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 30 end; 31 ; 32 passive_tracers(n) = [Symbol(""C"" * string(n)) for n in 1:n]; 33 ; 34 tracer_list(na, np) = Tuple(vcat(active_tracers(na), passive_tracers(np))); 35 ; 36 """""" Number of ac",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:114683,Testability,Benchmark,Benchmark,114683," top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 FT = Float64; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 archs = [CPU()] # Architectures to benchmark on.; 19 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 20 ; 21 #####; 22 ##### Utility functions for generating tracer lists; 23 #####; 24 ; 25 function active_tracers(n); 26 n == 0 && return []; 27 n == 1 && return [:b]; 28 n == 2 && return [:T, :S]; 29 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 30 end; 31 ; 32 passive_tracers(n) = [Symbol(""C"" * string(n)) for n in 1:n]; 33 ; 34 tracer_list(na, np) = Tuple(vcat(active_tracers(na), passive_tracers(np))); 35 ; 36 """""" Number of active tracers to buoyancy """"""; 37 function na2buoyancy(n); 38 n == 0 && return nothing; 39 n == 1 && return BuoyancyTracer(); 40 n == 2 && return SeawaterBuoyancy(); 41 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 42 end; 43 ; 44 #####; 45 ##### Run benchmarks; 46 #####; 47 ; 48 # Each",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:114829,Testability,benchmark,benchmarking,114829," top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 FT = Float64; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 archs = [CPU()] # Architectures to benchmark on.; 19 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 20 ; 21 #####; 22 ##### Utility functions for generating tracer lists; 23 #####; 24 ; 25 function active_tracers(n); 26 n == 0 && return []; 27 n == 1 && return [:b]; 28 n == 2 && return [:T, :S]; 29 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 30 end; 31 ; 32 passive_tracers(n) = [Symbol(""C"" * string(n)) for n in 1:n]; 33 ; 34 tracer_list(na, np) = Tuple(vcat(active_tracers(na), passive_tracers(np))); 35 ; 36 """""" Number of active tracers to buoyancy """"""; 37 function na2buoyancy(n); 38 n == 0 && return nothing; 39 n == 1 && return BuoyancyTracer(); 40 n == 2 && return SeawaterBuoyancy(); 41 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 42 end; 43 ; 44 #####; 45 ##### Run benchmarks; 46 #####; 47 ; 48 # Each",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:114901,Testability,benchmark,benchmark,114901,"ker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 FT = Float64; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 archs = [CPU()] # Architectures to benchmark on.; 19 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 20 ; 21 #####; 22 ##### Utility functions for generating tracer lists; 23 #####; 24 ; 25 function active_tracers(n); 26 n == 0 && return []; 27 n == 1 && return [:b]; 28 n == 2 && return [:T, :S]; 29 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 30 end; 31 ; 32 passive_tracers(n) = [Symbol(""C"" * string(n)) for n in 1:n]; 33 ; 34 tracer_list(na, np) = Tuple(vcat(active_tracers(na), passive_tracers(np))); 35 ; 36 """""" Number of active tracers to buoyancy """"""; 37 function na2buoyancy(n); 38 n == 0 && return nothing; 39 n == 1 && return BuoyancyTracer(); 40 n == 2 && return SeawaterBuoyancy(); 41 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 42 end; 43 ; 44 #####; 45 ##### Run benchmarks; 46 #####; 47 ; 48 # Each test case specifies (number of active tracers, number of passive tracers); 49 test_cases = [(0, 0), (2, 0), (2, 3)]; 50 ; 51 for",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:114953,Testability,Benchmark,Benchmark,114953,"st.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; Running benchmark: 16× 16× 16 0 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [CPU, Float64]...; Running benchmark: 16× 16× 16 0 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 0 passive [GPU, Float64]...; Running benchmark: 16× 16× 16 2 active + 3 passive [GPU, Float64]... Oceananigans v0.34.1; 1 module _Test_tracers_; 2 using Printf; 3 using TimerOutputs; 4 using Oceananigans; 5 using Oceananigans.Utils; 6 ; 7 include(""benchmark_utils.jl""); 8 ; 9 #####; 10 ##### Benchmark setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 FT = Float64; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 archs = [CPU()] # Architectures to benchmark on.; 19 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 20 ; 21 #####; 22 ##### Utility functions for generating tracer lists; 23 #####; 24 ; 25 function active_tracers(n); 26 n == 0 && return []; 27 n == 1 && return [:b]; 28 n == 2 && return [:T, :S]; 29 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 30 end; 31 ; 32 passive_tracers(n) = [Symbol(""C"" * string(n)) for n in 1:n]; 33 ; 34 tracer_list(na, np) = Tuple(vcat(active_tracers(na), passive_tracers(np))); 35 ; 36 """""" Number of active tracers to buoyancy """"""; 37 function na2buoyancy(n); 38 n == 0 && return nothing; 39 n == 1 && return BuoyancyTracer(); 40 n == 2 && return SeawaterBuoyancy(); 41 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 42 end; 43 ; 44 #####; 45 ##### Run benchmarks; 46 #####; 47 ; 48 # Each test case specifies (number of active tracers, number of passive tracers); 49 test_cases = [(0, 0), (2, 0), (2, 3)]; 50 ; 51 for arch in archs, test_case in test_cases; 52 N = arch isa CPU ? (16, 16, 1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:115720,Testability,benchmark,benchmarks,115720,"k setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 FT = Float64; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 archs = [CPU()] # Architectures to benchmark on.; 19 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 20 ; 21 #####; 22 ##### Utility functions for generating tracer lists; 23 #####; 24 ; 25 function active_tracers(n); 26 n == 0 && return []; 27 n == 1 && return [:b]; 28 n == 2 && return [:T, :S]; 29 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 30 end; 31 ; 32 passive_tracers(n) = [Symbol(""C"" * string(n)) for n in 1:n]; 33 ; 34 tracer_list(na, np) = Tuple(vcat(active_tracers(na), passive_tracers(np))); 35 ; 36 """""" Number of active tracers to buoyancy """"""; 37 function na2buoyancy(n); 38 n == 0 && return nothing; 39 n == 1 && return BuoyancyTracer(); 40 n == 2 && return SeawaterBuoyancy(); 41 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 42 end; 43 ; 44 #####; 45 ##### Run benchmarks; 46 #####; 47 ; 48 # Each test case specifies (number of active tracers, number of passive tracers); 49 test_cases = [(0, 0), (2, 0), (2, 3)]; 50 ; 51 for arch in archs, test_case in test_cases; 52 N = arch isa CPU ? (16, 16, 16) : (16, 16, 16); 53 na, np = test_case; 54 tracers = tracer_list(na, np); 55 ; 56 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 57 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid,; 58 buoyancy=na2buoyancy(na), tracers=tracers); 59 ; 60 time_step!(model, 1) # precompile; 61 ; 62 bname = benchmark_name(N, ""$na active + $(lpad(np, 2)) passive"", arch, FT); 63 @printf(""Running benchmark: %s...\n"", bname); 64 for i in 1:Nt; 65 @timeit timer bname time_step!(model, 1); 66 end; 67 end; 68 ; 69 #####; 70 ##### Print benchmark results; 71 #####; 72 ; 73 println(); 74 println(oceananigans_versioninfo()); 75 println(versioninfo_with_gpu()); 76 print_timer(timer, title=""Tracer benchmarks"", sortby=:name)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:115757,Testability,test,test,115757,"k setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 FT = Float64; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 archs = [CPU()] # Architectures to benchmark on.; 19 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 20 ; 21 #####; 22 ##### Utility functions for generating tracer lists; 23 #####; 24 ; 25 function active_tracers(n); 26 n == 0 && return []; 27 n == 1 && return [:b]; 28 n == 2 && return [:T, :S]; 29 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 30 end; 31 ; 32 passive_tracers(n) = [Symbol(""C"" * string(n)) for n in 1:n]; 33 ; 34 tracer_list(na, np) = Tuple(vcat(active_tracers(na), passive_tracers(np))); 35 ; 36 """""" Number of active tracers to buoyancy """"""; 37 function na2buoyancy(n); 38 n == 0 && return nothing; 39 n == 1 && return BuoyancyTracer(); 40 n == 2 && return SeawaterBuoyancy(); 41 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 42 end; 43 ; 44 #####; 45 ##### Run benchmarks; 46 #####; 47 ; 48 # Each test case specifies (number of active tracers, number of passive tracers); 49 test_cases = [(0, 0), (2, 0), (2, 3)]; 50 ; 51 for arch in archs, test_case in test_cases; 52 N = arch isa CPU ? (16, 16, 16) : (16, 16, 16); 53 na, np = test_case; 54 tracers = tracer_list(na, np); 55 ; 56 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 57 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid,; 58 buoyancy=na2buoyancy(na), tracers=tracers); 59 ; 60 time_step!(model, 1) # precompile; 61 ; 62 bname = benchmark_name(N, ""$na active + $(lpad(np, 2)) passive"", arch, FT); 63 @printf(""Running benchmark: %s...\n"", bname); 64 for i in 1:Nt; 65 @timeit timer bname time_step!(model, 1); 66 end; 67 end; 68 ; 69 #####; 70 ##### Print benchmark results; 71 #####; 72 ; 73 println(); 74 println(oceananigans_versioninfo()); 75 println(versioninfo_with_gpu()); 76 print_timer(timer, title=""Tracer benchmarks"", sortby=:name)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:116368,Testability,benchmark,benchmark,116368,"k setup and parameters; 11 #####; 12 ; 13 const timer = TimerOutput(); 14 ; 15 FT = Float64; 16 Nt = 10 # Number of iterations to use for benchmarking time stepping.; 17 ; 18 archs = [CPU()] # Architectures to benchmark on.; 19 @hascuda archs = [CPU(), GPU()] # Benchmark GPU on systems with CUDA-enabled GPUs.; 20 ; 21 #####; 22 ##### Utility functions for generating tracer lists; 23 #####; 24 ; 25 function active_tracers(n); 26 n == 0 && return []; 27 n == 1 && return [:b]; 28 n == 2 && return [:T, :S]; 29 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 30 end; 31 ; 32 passive_tracers(n) = [Symbol(""C"" * string(n)) for n in 1:n]; 33 ; 34 tracer_list(na, np) = Tuple(vcat(active_tracers(na), passive_tracers(np))); 35 ; 36 """""" Number of active tracers to buoyancy """"""; 37 function na2buoyancy(n); 38 n == 0 && return nothing; 39 n == 1 && return BuoyancyTracer(); 40 n == 2 && return SeawaterBuoyancy(); 41 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 42 end; 43 ; 44 #####; 45 ##### Run benchmarks; 46 #####; 47 ; 48 # Each test case specifies (number of active tracers, number of passive tracers); 49 test_cases = [(0, 0), (2, 0), (2, 3)]; 50 ; 51 for arch in archs, test_case in test_cases; 52 N = arch isa CPU ? (16, 16, 16) : (16, 16, 16); 53 na, np = test_case; 54 tracers = tracer_list(na, np); 55 ; 56 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 57 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid,; 58 buoyancy=na2buoyancy(na), tracers=tracers); 59 ; 60 time_step!(model, 1) # precompile; 61 ; 62 bname = benchmark_name(N, ""$na active + $(lpad(np, 2)) passive"", arch, FT); 63 @printf(""Running benchmark: %s...\n"", bname); 64 for i in 1:Nt; 65 @timeit timer bname time_step!(model, 1); 66 end; 67 end; 68 ; 69 #####; 70 ##### Print benchmark results; 71 #####; 72 ; 73 println(); 74 println(oceananigans_versioninfo()); 75 println(versioninfo_with_gpu()); 76 print_timer(timer, title=""Tracer benchmarks"", sortby=:name)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:116506,Testability,benchmark,benchmark,116506,"== 2 && return SeawaterBuoyancy(); 41 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 42 end; 43 ; 44 #####; 45 ##### Run benchmarks; 46 #####; 47 ; 48 # Each test case specifies (number of active tracers, number of passive tracers); 49 test_cases = [(0, 0), (2, 0), (2, 3)]; 50 ; 51 for arch in archs, test_case in test_cases; 52 N = arch isa CPU ? (16, 16, 16) : (16, 16, 16); 53 na, np = test_case; 54 tracers = tracer_list(na, np); 55 ; 56 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 57 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid,; 58 buoyancy=na2buoyancy(na), tracers=tracers); 59 ; 60 time_step!(model, 1) # precompile; 61 ; 62 bname = benchmark_name(N, ""$na active + $(lpad(np, 2)) passive"", arch, FT); 63 @printf(""Running benchmark: %s...\n"", bname); 64 for i in 1:Nt; 65 @timeit timer bname time_step!(model, 1); 66 end; 67 end; 68 ; 69 #####; 70 ##### Print benchmark results; 71 #####; 72 ; 73 println(); 74 println(oceananigans_versioninfo()); 75 println(versioninfo_with_gpu()); 76 print_timer(timer, title=""Tracer benchmarks"", sortby=:name); 77 println(); 78 ; 79 end # module; Tracers benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; Expression: run_script(replace_strings, ""tracers"", benchmark_filepath(""tracers"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:116666,Testability,benchmark,benchmarks,116666,"== 2 && return SeawaterBuoyancy(); 41 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 42 end; 43 ; 44 #####; 45 ##### Run benchmarks; 46 #####; 47 ; 48 # Each test case specifies (number of active tracers, number of passive tracers); 49 test_cases = [(0, 0), (2, 0), (2, 3)]; 50 ; 51 for arch in archs, test_case in test_cases; 52 N = arch isa CPU ? (16, 16, 16) : (16, 16, 16); 53 na, np = test_case; 54 tracers = tracer_list(na, np); 55 ; 56 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 57 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid,; 58 buoyancy=na2buoyancy(na), tracers=tracers); 59 ; 60 time_step!(model, 1) # precompile; 61 ; 62 bname = benchmark_name(N, ""$na active + $(lpad(np, 2)) passive"", arch, FT); 63 @printf(""Running benchmark: %s...\n"", bname); 64 for i in 1:Nt; 65 @timeit timer bname time_step!(model, 1); 66 end; 67 end; 68 ; 69 #####; 70 ##### Print benchmark results; 71 #####; 72 ; 73 println(); 74 println(oceananigans_versioninfo()); 75 println(versioninfo_with_gpu()); 76 print_timer(timer, title=""Tracer benchmarks"", sortby=:name); 77 println(); 78 ; 79 end # module; Tracers benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; Expression: run_script(replace_strings, ""tracers"", benchmark_filepath(""tracers"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:116738,Testability,benchmark,benchmark,116738,"== 2 && return SeawaterBuoyancy(); 41 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 42 end; 43 ; 44 #####; 45 ##### Run benchmarks; 46 #####; 47 ; 48 # Each test case specifies (number of active tracers, number of passive tracers); 49 test_cases = [(0, 0), (2, 0), (2, 3)]; 50 ; 51 for arch in archs, test_case in test_cases; 52 N = arch isa CPU ? (16, 16, 16) : (16, 16, 16); 53 na, np = test_case; 54 tracers = tracer_list(na, np); 55 ; 56 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 57 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid,; 58 buoyancy=na2buoyancy(na), tracers=tracers); 59 ; 60 time_step!(model, 1) # precompile; 61 ; 62 bname = benchmark_name(N, ""$na active + $(lpad(np, 2)) passive"", arch, FT); 63 @printf(""Running benchmark: %s...\n"", bname); 64 for i in 1:Nt; 65 @timeit timer bname time_step!(model, 1); 66 end; 67 end; 68 ; 69 #####; 70 ##### Print benchmark results; 71 #####; 72 ; 73 println(); 74 println(oceananigans_versioninfo()); 75 println(versioninfo_with_gpu()); 76 print_timer(timer, title=""Tracer benchmarks"", sortby=:name); 77 println(); 78 ; 79 end # module; Tracers benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; Expression: run_script(replace_strings, ""tracers"", benchmark_filepath(""tracers"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:116749,Testability,Test,Test,116749,"== 2 && return SeawaterBuoyancy(); 41 throw(ArgumentError(""Can't have more than 2 active tracers!"")); 42 end; 43 ; 44 #####; 45 ##### Run benchmarks; 46 #####; 47 ; 48 # Each test case specifies (number of active tracers, number of passive tracers); 49 test_cases = [(0, 0), (2, 0), (2, 3)]; 50 ; 51 for arch in archs, test_case in test_cases; 52 N = arch isa CPU ? (16, 16, 16) : (16, 16, 16); 53 na, np = test_case; 54 tracers = tracer_list(na, np); 55 ; 56 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 57 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid,; 58 buoyancy=na2buoyancy(na), tracers=tracers); 59 ; 60 time_step!(model, 1) # precompile; 61 ; 62 bname = benchmark_name(N, ""$na active + $(lpad(np, 2)) passive"", arch, FT); 63 @printf(""Running benchmark: %s...\n"", bname); 64 for i in 1:Nt; 65 @timeit timer bname time_step!(model, 1); 66 end; 67 end; 68 ; 69 #####; 70 ##### Print benchmark results; 71 #####; 72 ; 73 println(); 74 println(oceananigans_versioninfo()); 75 println(versioninfo_with_gpu()); 76 print_timer(timer, title=""Tracer benchmarks"", sortby=:name); 77 println(); 78 ; 79 end # module; Tracers benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; Expression: run_script(replace_strings, ""tracers"", benchmark_filepath(""tracers"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:116814,Testability,test,test,116814,"ber of passive tracers); 49 test_cases = [(0, 0), (2, 0), (2, 3)]; 50 ; 51 for arch in archs, test_case in test_cases; 52 N = arch isa CPU ? (16, 16, 16) : (16, 16, 16); 53 na, np = test_case; 54 tracers = tracer_list(na, np); 55 ; 56 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 57 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid,; 58 buoyancy=na2buoyancy(na), tracers=tracers); 59 ; 60 time_step!(model, 1) # precompile; 61 ; 62 bname = benchmark_name(N, ""$na active + $(lpad(np, 2)) passive"", arch, FT); 63 @printf(""Running benchmark: %s...\n"", bname); 64 for i in 1:Nt; 65 @timeit timer bname time_step!(model, 1); 66 end; 67 end; 68 ; 69 #####; 70 ##### Print benchmark results; 71 #####; 72 ; 73 println(); 74 println(oceananigans_versioninfo()); 75 println(versioninfo_with_gpu()); 76 print_timer(timer, title=""Tracer benchmarks"", sortby=:name); 77 println(); 78 ; 79 end # module; Tracers benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; Expression: run_script(replace_strings, ""tracers"", benchmark_filepath(""tracers"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:117011,Testability,test,test,117011,"racers = tracer_list(na, np); 55 ; 56 grid = RegularCartesianGrid(size=N, extent=(1, 1, 1)); 57 model = IncompressibleModel(architecture=arch, float_type=FT, grid=grid,; 58 buoyancy=na2buoyancy(na), tracers=tracers); 59 ; 60 time_step!(model, 1) # precompile; 61 ; 62 bname = benchmark_name(N, ""$na active + $(lpad(np, 2)) passive"", arch, FT); 63 @printf(""Running benchmark: %s...\n"", bname); 64 for i in 1:Nt; 65 @timeit timer bname time_step!(model, 1); 66 end; 67 end; 68 ; 69 #####; 70 ##### Print benchmark results; 71 #####; 72 ; 73 println(); 74 println(oceananigans_versioninfo()); 75 println(versioninfo_with_gpu()); 76 print_timer(timer, title=""Tracer benchmarks"", sortby=:name); 77 println(); 78 ; 79 end # module; Tracers benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; Expression: run_script(replace_strings, ""tracers"", benchmark_filepath(""tracers"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estim",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:117132,Testability,Test,Test,117132,"re=arch, float_type=FT, grid=grid,; 58 buoyancy=na2buoyancy(na), tracers=tracers); 59 ; 60 time_step!(model, 1) # precompile; 61 ; 62 bname = benchmark_name(N, ""$na active + $(lpad(np, 2)) passive"", arch, FT); 63 @printf(""Running benchmark: %s...\n"", bname); 64 for i in 1:Nt; 65 @timeit timer bname time_step!(model, 1); 66 end; 67 end; 68 ; 69 #####; 70 ##### Print benchmark results; 71 #####; 72 ; 73 println(); 74 println(oceananigans_versioninfo()); 75 println(versioninfo_with_gpu()); 76 print_timer(timer, title=""Tracer benchmarks"", sortby=:name); 77 println(); 78 ; 79 end # module; Tracers benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; Expression: run_script(replace_strings, ""tracers"", benchmark_filepath(""tracers"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:117141,Testability,Test,Test,117141,"re=arch, float_type=FT, grid=grid,; 58 buoyancy=na2buoyancy(na), tracers=tracers); 59 ; 60 time_step!(model, 1) # precompile; 61 ; 62 bname = benchmark_name(N, ""$na active + $(lpad(np, 2)) passive"", arch, FT); 63 @printf(""Running benchmark: %s...\n"", bname); 64 for i in 1:Nt; 65 @timeit timer bname time_step!(model, 1); 66 end; 67 end; 68 ; 69 #####; 70 ##### Print benchmark results; 71 #####; 72 ; 73 println(); 74 println(oceananigans_versioninfo()); 75 println(versioninfo_with_gpu()); 76 print_timer(timer, title=""Tracer benchmarks"", sortby=:name); 77 println(); 78 ; 79 end # module; Tracers benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; Expression: run_script(replace_strings, ""tracers"", benchmark_filepath(""tracers"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:117228,Testability,test,test,117228,"59 ; 60 time_step!(model, 1) # precompile; 61 ; 62 bname = benchmark_name(N, ""$na active + $(lpad(np, 2)) passive"", arch, FT); 63 @printf(""Running benchmark: %s...\n"", bname); 64 for i in 1:Nt; 65 @timeit timer bname time_step!(model, 1); 66 end; 67 end; 68 ; 69 #####; 70 ##### Print benchmark results; 71 #####; 72 ; 73 println(); 74 println(oceananigans_versioninfo()); 75 println(versioninfo_with_gpu()); 76 print_timer(timer, title=""Tracer benchmarks"", sortby=:name); 77 println(); 78 ; 79 end # module; Tracers benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; Expression: run_script(replace_strings, ""tracers"", benchmark_filepath(""tracers"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean time: 12.156 ms (0.00% GC); maximum time: 14.535 ms (0.00% GC); --------------; samp",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:117349,Testability,Test,Test,117349,"ntf(""Running benchmark: %s...\n"", bname); 64 for i in 1:Nt; 65 @timeit timer bname time_step!(model, 1); 66 end; 67 end; 68 ; 69 #####; 70 ##### Print benchmark results; 71 #####; 72 ; 73 println(); 74 println(oceananigans_versioninfo()); 75 println(versioninfo_with_gpu()); 76 print_timer(timer, title=""Tracer benchmarks"", sortby=:name); 77 println(); 78 ; 79 end # module; Tracers benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; Expression: run_script(replace_strings, ""tracers"", benchmark_filepath(""tracers"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean time: 12.156 ms (0.00% GC); maximum time: 14.535 ms (0.00% GC); --------------; samples: 412; evals/sample: 1; Test Summary: | Pass Fail Error Broken Total; Oceananigans | 1579 4 3 2 1588; Grids | 106 106; Operators |",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:117358,Testability,Test,Test,117358,"ntf(""Running benchmark: %s...\n"", bname); 64 for i in 1:Nt; 65 @timeit timer bname time_step!(model, 1); 66 end; 67 end; 68 ; 69 #####; 70 ##### Print benchmark results; 71 #####; 72 ; 73 println(); 74 println(oceananigans_versioninfo()); 75 println(versioninfo_with_gpu()); 76 print_timer(timer, title=""Tracer benchmarks"", sortby=:name); 77 println(); 78 ; 79 end # module; Tracers benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; Expression: run_script(replace_strings, ""tracers"", benchmark_filepath(""tracers"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean time: 12.156 ms (0.00% GC); maximum time: 14.535 ms (0.00% GC); --------------; samples: 412; evals/sample: 1; Test Summary: | Pass Fail Error Broken Total; Oceananigans | 1579 4 3 2 1588; Grids | 106 106; Operators |",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:117445,Testability,test,test,117445,"time_step!(model, 1); 66 end; 67 end; 68 ; 69 #####; 70 ##### Print benchmark results; 71 #####; 72 ; 73 println(); 74 println(oceananigans_versioninfo()); 75 println(versioninfo_with_gpu()); 76 print_timer(timer, title=""Tracer benchmarks"", sortby=:name); 77 println(); 78 ; 79 end # module; Tracers benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; Expression: run_script(replace_strings, ""tracers"", benchmark_filepath(""tracers"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean time: 12.156 ms (0.00% GC); maximum time: 14.535 ms (0.00% GC); --------------; samples: 412; evals/sample: 1; Test Summary: | Pass Fail Error Broken Total; Oceananigans | 1579 4 3 2 1588; Grids | 106 106; Operators | 146 146; Boundary conditions | 142 142; Fields | 198 198; Halo regions | 40 40; Sol",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:117566,Testability,Test,Test,117566,"igans_versioninfo()); 75 println(versioninfo_with_gpu()); 76 print_timer(timer, title=""Tracer benchmarks"", sortby=:name); 77 println(); 78 ; 79 end # module; Tracers benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; Expression: run_script(replace_strings, ""tracers"", benchmark_filepath(""tracers"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean time: 12.156 ms (0.00% GC); maximum time: 14.535 ms (0.00% GC); --------------; samples: 412; evals/sample: 1; Test Summary: | Pass Fail Error Broken Total; Oceananigans | 1579 4 3 2 1588; Grids | 106 106; Operators | 146 146; Boundary conditions | 142 142; Fields | 198 198; Halo regions | 40 40; Solvers | 22 1 23; Pressure solvers | 152 152; Coriolis | 44 44; Buoyancy | 70 70; Surface waves | 1 1; Models | 12 12; Simulations | 26",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:117575,Testability,Test,Test,117575,"igans_versioninfo()); 75 println(versioninfo_with_gpu()); 76 print_timer(timer, title=""Tracer benchmarks"", sortby=:name); 77 println(); 78 ; 79 end # module; Tracers benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; Expression: run_script(replace_strings, ""tracers"", benchmark_filepath(""tracers"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean time: 12.156 ms (0.00% GC); maximum time: 14.535 ms (0.00% GC); --------------; samples: 412; evals/sample: 1; Test Summary: | Pass Fail Error Broken Total; Oceananigans | 1579 4 3 2 1588; Grids | 106 106; Operators | 146 146; Boundary conditions | 142 142; Fields | 198 198; Halo regions | 40 40; Solvers | 22 1 23; Pressure solvers | 152 152; Coriolis | 44 44; Buoyancy | 70 70; Surface waves | 1 1; Models | 12 12; Simulations | 26",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:117662,Testability,test,test,117662,"le=""Tracer benchmarks"", sortby=:name); 77 println(); 78 ; 79 end # module; Tracers benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; Expression: run_script(replace_strings, ""tracers"", benchmark_filepath(""tracers"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean time: 12.156 ms (0.00% GC); maximum time: 14.535 ms (0.00% GC); --------------; samples: 412; evals/sample: 1; Test Summary: | Pass Fail Error Broken Total; Oceananigans | 1579 4 3 2 1588; Grids | 106 106; Operators | 146 146; Boundary conditions | 142 142; Fields | 198 198; Halo regions | 40 40; Solvers | 22 1 23; Pressure solvers | 152 152; Coriolis | 44 44; Buoyancy | 70 70; Surface waves | 1 1; Models | 12 12; Simulations | 26 26; Time stepping | 33 1 34; Time stepping with boundary conditions | 122 122; Forc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:117690,Testability,Benchmark,BenchmarkTools,117690,"77 println(); 78 ; 79 end # module; Tracers benchmark: Test Failed at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; Expression: run_script(replace_strings, ""tracers"", benchmark_filepath(""tracers"")); Stacktrace:; [1] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean time: 12.156 ms (0.00% GC); maximum time: 14.535 ms (0.00% GC); --------------; samples: 412; evals/sample: 1; Test Summary: | Pass Fail Error Broken Total; Oceananigans | 1579 4 3 2 1588; Grids | 106 106; Operators | 146 146; Boundary conditions | 142 142; Fields | 198 198; Halo regions | 40 40; Solvers | 22 1 23; Pressure solvers | 152 152; Coriolis | 44 44; Buoyancy | 70 70; Surface waves | 1 1; Models | 12 12; Simulations | 26 26; Time stepping | 33 1 34; Time stepping with boundary conditions | 122 122; Forcing | 12 2 14; Forcing function initia",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:117969,Testability,Benchmark,BenchmarkTools,117969,vel scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:58; [2] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [3] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean time: 12.156 ms (0.00% GC); maximum time: 14.535 ms (0.00% GC); --------------; samples: 412; evals/sample: 1; Test Summary: | Pass Fail Error Broken Total; Oceananigans | 1579 4 3 2 1588; Grids | 106 106; Operators | 146 146; Boundary conditions | 142 142; Fields | 198 198; Halo regions | 40 40; Solvers | 22 1 23; Pressure solvers | 152 152; Coriolis | 44 44; Buoyancy | 70 70; Surface waves | 1 1; Models | 12 12; Simulations | 26 26; Time stepping | 33 1 34; Time stepping with boundary conditions | 122 122; Forcing | 12 2 14; Forcing function initialization | 5 5; Forcing function time stepping [GPU] | 7 2 9; Turbulence closures | 46 46; Dynamics | 18 18; Diagnostics | 22 22; Output writers | 80 1 81; NetCDF [GPU] | 1 1; JLD2 [GPU] | 9 9; Checkpointer [GPU] | 71 71; Abstract operations | 258 258; Re,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:118249,Testability,Test,Test,118249,t/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean time: 12.156 ms (0.00% GC); maximum time: 14.535 ms (0.00% GC); --------------; samples: 412; evals/sample: 1; Test Summary: | Pass Fail Error Broken Total; Oceananigans | 1579 4 3 2 1588; Grids | 106 106; Operators | 146 146; Boundary conditions | 142 142; Fields | 198 198; Halo regions | 40 40; Solvers | 22 1 23; Pressure solvers | 152 152; Coriolis | 44 44; Buoyancy | 70 70; Surface waves | 1 1; Models | 12 12; Simulations | 26 26; Time stepping | 33 1 34; Time stepping with boundary conditions | 122 122; Forcing | 12 2 14; Forcing function initialization | 5 5; Forcing function time stepping [GPU] | 7 2 9; Turbulence closures | 46 46; Dynamics | 18 18; Diagnostics | 22 22; Output writers | 80 1 81; NetCDF [GPU] | 1 1; JLD2 [GPU] | 9 9; Checkpointer [GPU] | 71 71; Abstract operations | 258 258; Regression | 20 20; Examples | 6 6; Verification | 1 1; Performance benchmarks | 2 4 6; Performance benchmark scripts | 4 4; Static ocean benchmark | 1 1; Channel benchmark | 1 1; Turbulence closures benchmark | 1 1; Tracers benchmark | 1 1; Selected performance benchmarks | 2 2; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:119015,Testability,benchmark,benchmarks,119015,t/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean time: 12.156 ms (0.00% GC); maximum time: 14.535 ms (0.00% GC); --------------; samples: 412; evals/sample: 1; Test Summary: | Pass Fail Error Broken Total; Oceananigans | 1579 4 3 2 1588; Grids | 106 106; Operators | 146 146; Boundary conditions | 142 142; Fields | 198 198; Halo regions | 40 40; Solvers | 22 1 23; Pressure solvers | 152 152; Coriolis | 44 44; Buoyancy | 70 70; Surface waves | 1 1; Models | 12 12; Simulations | 26 26; Time stepping | 33 1 34; Time stepping with boundary conditions | 122 122; Forcing | 12 2 14; Forcing function initialization | 5 5; Forcing function time stepping [GPU] | 7 2 9; Turbulence closures | 46 46; Dynamics | 18 18; Diagnostics | 22 22; Output writers | 80 1 81; NetCDF [GPU] | 1 1; JLD2 [GPU] | 9 9; Checkpointer [GPU] | 71 71; Abstract operations | 258 258; Regression | 20 20; Examples | 6 6; Verification | 1 1; Performance benchmarks | 2 4 6; Performance benchmark scripts | 4 4; Static ocean benchmark | 1 1; Channel benchmark | 1 1; Turbulence closures benchmark | 1 1; Tracers benchmark | 1 1; Selected performance benchmarks | 2 2; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:119047,Testability,benchmark,benchmark,119047,t/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean time: 12.156 ms (0.00% GC); maximum time: 14.535 ms (0.00% GC); --------------; samples: 412; evals/sample: 1; Test Summary: | Pass Fail Error Broken Total; Oceananigans | 1579 4 3 2 1588; Grids | 106 106; Operators | 146 146; Boundary conditions | 142 142; Fields | 198 198; Halo regions | 40 40; Solvers | 22 1 23; Pressure solvers | 152 152; Coriolis | 44 44; Buoyancy | 70 70; Surface waves | 1 1; Models | 12 12; Simulations | 26 26; Time stepping | 33 1 34; Time stepping with boundary conditions | 122 122; Forcing | 12 2 14; Forcing function initialization | 5 5; Forcing function time stepping [GPU] | 7 2 9; Turbulence closures | 46 46; Dynamics | 18 18; Diagnostics | 22 22; Output writers | 80 1 81; NetCDF [GPU] | 1 1; JLD2 [GPU] | 9 9; Checkpointer [GPU] | 71 71; Abstract operations | 258 258; Regression | 20 20; Examples | 6 6; Verification | 1 1; Performance benchmarks | 2 4 6; Performance benchmark scripts | 4 4; Static ocean benchmark | 1 1; Channel benchmark | 1 1; Turbulence closures benchmark | 1 1; Tracers benchmark | 1 1; Selected performance benchmarks | 2 2; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:119085,Testability,benchmark,benchmark,119085,t/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean time: 12.156 ms (0.00% GC); maximum time: 14.535 ms (0.00% GC); --------------; samples: 412; evals/sample: 1; Test Summary: | Pass Fail Error Broken Total; Oceananigans | 1579 4 3 2 1588; Grids | 106 106; Operators | 146 146; Boundary conditions | 142 142; Fields | 198 198; Halo regions | 40 40; Solvers | 22 1 23; Pressure solvers | 152 152; Coriolis | 44 44; Buoyancy | 70 70; Surface waves | 1 1; Models | 12 12; Simulations | 26 26; Time stepping | 33 1 34; Time stepping with boundary conditions | 122 122; Forcing | 12 2 14; Forcing function initialization | 5 5; Forcing function time stepping [GPU] | 7 2 9; Turbulence closures | 46 46; Dynamics | 18 18; Diagnostics | 22 22; Output writers | 80 1 81; NetCDF [GPU] | 1 1; JLD2 [GPU] | 9 9; Checkpointer [GPU] | 71 71; Abstract operations | 258 258; Regression | 20 20; Examples | 6 6; Verification | 1 1; Performance benchmarks | 2 4 6; Performance benchmark scripts | 4 4; Static ocean benchmark | 1 1; Channel benchmark | 1 1; Turbulence closures benchmark | 1 1; Tracers benchmark | 1 1; Selected performance benchmarks | 2 2; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:119110,Testability,benchmark,benchmark,119110,t/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean time: 12.156 ms (0.00% GC); maximum time: 14.535 ms (0.00% GC); --------------; samples: 412; evals/sample: 1; Test Summary: | Pass Fail Error Broken Total; Oceananigans | 1579 4 3 2 1588; Grids | 106 106; Operators | 146 146; Boundary conditions | 142 142; Fields | 198 198; Halo regions | 40 40; Solvers | 22 1 23; Pressure solvers | 152 152; Coriolis | 44 44; Buoyancy | 70 70; Surface waves | 1 1; Models | 12 12; Simulations | 26 26; Time stepping | 33 1 34; Time stepping with boundary conditions | 122 122; Forcing | 12 2 14; Forcing function initialization | 5 5; Forcing function time stepping [GPU] | 7 2 9; Turbulence closures | 46 46; Dynamics | 18 18; Diagnostics | 22 22; Output writers | 80 1 81; NetCDF [GPU] | 1 1; JLD2 [GPU] | 9 9; Checkpointer [GPU] | 71 71; Abstract operations | 258 258; Regression | 20 20; Examples | 6 6; Verification | 1 1; Performance benchmarks | 2 4 6; Performance benchmark scripts | 4 4; Static ocean benchmark | 1 1; Channel benchmark | 1 1; Turbulence closures benchmark | 1 1; Tracers benchmark | 1 1; Selected performance benchmarks | 2 2; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:119147,Testability,benchmark,benchmark,119147,t/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean time: 12.156 ms (0.00% GC); maximum time: 14.535 ms (0.00% GC); --------------; samples: 412; evals/sample: 1; Test Summary: | Pass Fail Error Broken Total; Oceananigans | 1579 4 3 2 1588; Grids | 106 106; Operators | 146 146; Boundary conditions | 142 142; Fields | 198 198; Halo regions | 40 40; Solvers | 22 1 23; Pressure solvers | 152 152; Coriolis | 44 44; Buoyancy | 70 70; Surface waves | 1 1; Models | 12 12; Simulations | 26 26; Time stepping | 33 1 34; Time stepping with boundary conditions | 122 122; Forcing | 12 2 14; Forcing function initialization | 5 5; Forcing function time stepping [GPU] | 7 2 9; Turbulence closures | 46 46; Dynamics | 18 18; Diagnostics | 22 22; Output writers | 80 1 81; NetCDF [GPU] | 1 1; JLD2 [GPU] | 9 9; Checkpointer [GPU] | 71 71; Abstract operations | 258 258; Regression | 20 20; Examples | 6 6; Verification | 1 1; Performance benchmarks | 2 4 6; Performance benchmark scripts | 4 4; Static ocean benchmark | 1 1; Channel benchmark | 1 1; Turbulence closures benchmark | 1 1; Tracers benchmark | 1 1; Selected performance benchmarks | 2 2; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:119172,Testability,benchmark,benchmark,119172,t/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean time: 12.156 ms (0.00% GC); maximum time: 14.535 ms (0.00% GC); --------------; samples: 412; evals/sample: 1; Test Summary: | Pass Fail Error Broken Total; Oceananigans | 1579 4 3 2 1588; Grids | 106 106; Operators | 146 146; Boundary conditions | 142 142; Fields | 198 198; Halo regions | 40 40; Solvers | 22 1 23; Pressure solvers | 152 152; Coriolis | 44 44; Buoyancy | 70 70; Surface waves | 1 1; Models | 12 12; Simulations | 26 26; Time stepping | 33 1 34; Time stepping with boundary conditions | 122 122; Forcing | 12 2 14; Forcing function initialization | 5 5; Forcing function time stepping [GPU] | 7 2 9; Turbulence closures | 46 46; Dynamics | 18 18; Diagnostics | 22 22; Output writers | 80 1 81; NetCDF [GPU] | 1 1; JLD2 [GPU] | 9 9; Checkpointer [GPU] | 71 71; Abstract operations | 258 258; Regression | 20 20; Examples | 6 6; Verification | 1 1; Performance benchmarks | 2 4 6; Performance benchmark scripts | 4 4; Static ocean benchmark | 1 1; Channel benchmark | 1 1; Turbulence closures benchmark | 1 1; Tracers benchmark | 1 1; Selected performance benchmarks | 2 2; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/882:119210,Testability,benchmark,benchmarks,119210,t/test_benchmarks.jl:49; [4] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [5] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:13; [6] top-level scope at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/Test/src/Test.jl:1113; [7] top-level scope at /home/ancellin/.julia/packages/Oceananigans/LW3v4/test/test_benchmarks.jl:10; BenchmarkTools.Trial: ; memory estimate: 857.91 KiB; allocs estimate: 10652; --------------; minimum time: 5.317 ms (0.00% GC); median time: 5.676 ms (0.00% GC); mean time: 5.798 ms (1.93% GC); maximum time: 122.454 ms (78.68% GC); --------------; samples: 862; evals/sample: 1; BenchmarkTools.Trial: ; memory estimate: 859.72 KiB; allocs estimate: 10768; --------------; minimum time: 12.002 ms (0.00% GC); median time: 12.150 ms (0.00% GC); mean time: 12.156 ms (0.00% GC); maximum time: 14.535 ms (0.00% GC); --------------; samples: 412; evals/sample: 1; Test Summary: | Pass Fail Error Broken Total; Oceananigans | 1579 4 3 2 1588; Grids | 106 106; Operators | 146 146; Boundary conditions | 142 142; Fields | 198 198; Halo regions | 40 40; Solvers | 22 1 23; Pressure solvers | 152 152; Coriolis | 44 44; Buoyancy | 70 70; Surface waves | 1 1; Models | 12 12; Simulations | 26 26; Time stepping | 33 1 34; Time stepping with boundary conditions | 122 122; Forcing | 12 2 14; Forcing function initialization | 5 5; Forcing function time stepping [GPU] | 7 2 9; Turbulence closures | 46 46; Dynamics | 18 18; Diagnostics | 22 22; Output writers | 80 1 81; NetCDF [GPU] | 1 1; JLD2 [GPU] | 9 9; Checkpointer [GPU] | 71 71; Abstract operations | 258 258; Regression | 20 20; Examples | 6 6; Verification | 1 1; Performance benchmarks | 2 4 6; Performance benchmark scripts | 4 4; Static ocean benchmark | 1 1; Channel benchmark | 1 1; Turbulence closures benchmark | 1 1; Tracers benchmark | 1 1; Selected performance benchmarks | 2 2; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882
https://github.com/CliMA/Oceananigans.jl/issues/883:311,Integrability,depend,depends,311,"https://github.com/CliMA/Oceananigans.jl/blob/5b8813da360921c66c2f3ee77021db91bedda1f7/src/Grids/Grids.jl#L81. Shouldn't the size of the `x`-direction, for example, be `Nx + 2 * Hx`? Perhaps we should simply delete this function if it isn't being used. It doesn't exactly make sense since the size of a _field_ depends on its location, and the topology of the grid.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/883
https://github.com/CliMA/Oceananigans.jl/issues/883:201,Usability,simpl,simply,201,"https://github.com/CliMA/Oceananigans.jl/blob/5b8813da360921c66c2f3ee77021db91bedda1f7/src/Grids/Grids.jl#L81. Shouldn't the size of the `x`-direction, for example, be `Nx + 2 * Hx`? Perhaps we should simply delete this function if it isn't being used. It doesn't exactly make sense since the size of a _field_ depends on its location, and the topology of the grid.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/883
https://github.com/CliMA/Oceananigans.jl/issues/884:731,Availability,redundant,redundant,731,"The `NetCDFOutputWriter` requires the keyword argument `filename`:. https://github.com/CliMA/Oceananigans.jl/blob/ed73ad36c99b61f24c37c73e4a2d26a12c7601d9/src/OutputWriters/netcdf_output_writer.jl#L147-L163. while `JLD2OutputWriter` requires `prefix` (which is optional, even though the default `prefix=""""` would produce a file called `.jld2`:. https://github.com/CliMA/Oceananigans.jl/blob/fbbb5f81b851bb838c8796efba36a3021cb89f0e/src/OutputWriters/jld2_output_writer.jl#L56-L60. There are also some minor differences: `filename` is used for the NetCDF writer, while `filepath` is used for the JLD2 writer. We should probably even out these differences:. * I think `filename` is more descriptive than `prefix`; * I also think its redundant to require the user to specify the file suffix (`.jld2` or `.nc`) in addition to specifying `JLD2` or `NetCDF` in the output writer name. So we need to weigh the two above considerations in coming to a decision. ; * `filepath` may be a better name for the struct member if we are also going to allow the keyword argument `dir` (this is not part of `NetCDFOutputWriter` either). In general I think we should strive to make all the keywords as identical as possible so that users can switch between the writers by changing `NetCDF` to `JLD2` and vice versa.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/884
https://github.com/CliMA/Oceananigans.jl/issues/884:731,Safety,redund,redundant,731,"The `NetCDFOutputWriter` requires the keyword argument `filename`:. https://github.com/CliMA/Oceananigans.jl/blob/ed73ad36c99b61f24c37c73e4a2d26a12c7601d9/src/OutputWriters/netcdf_output_writer.jl#L147-L163. while `JLD2OutputWriter` requires `prefix` (which is optional, even though the default `prefix=""""` would produce a file called `.jld2`:. https://github.com/CliMA/Oceananigans.jl/blob/fbbb5f81b851bb838c8796efba36a3021cb89f0e/src/OutputWriters/jld2_output_writer.jl#L56-L60. There are also some minor differences: `filename` is used for the NetCDF writer, while `filepath` is used for the JLD2 writer. We should probably even out these differences:. * I think `filename` is more descriptive than `prefix`; * I also think its redundant to require the user to specify the file suffix (`.jld2` or `.nc`) in addition to specifying `JLD2` or `NetCDF` in the output writer name. So we need to weigh the two above considerations in coming to a decision. ; * `filepath` may be a better name for the struct member if we are also going to allow the keyword argument `dir` (this is not part of `NetCDFOutputWriter` either). In general I think we should strive to make all the keywords as identical as possible so that users can switch between the writers by changing `NetCDF` to `JLD2` and vice versa.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/884
https://github.com/CliMA/Oceananigans.jl/issues/885:288,Availability,error,error,288,"It's not possible to build a `NetCDFOutputWriter` object with output that is not a field without specifying an ""attribute"", because this line. https://github.com/CliMA/Oceananigans.jl/blob/fbbb5f81b851bb838c8796efba36a3021cb89f0e/src/OutputWriters/netcdf_output_writer.jl#L192. throws an error. The error is a `KeyError`, eg:. ```; KeyError: key :time_average not found; Stacktrace:; [1] getindex at ./dict.jl:477 [inlined]; [2] NetCDFOutputWriter(::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S); ...; ```. which occurs because, in this case, `:time_average` is not one of the defaults provided:. https://github.com/CliMA/Oceananigans.jl/blob/fbbb5f81b851bb838c8796efba36a3021cb89f0e/src/OutputWriters/netcdf_output_writer.jl#L13-L20. There are really two issues:. 1. Should we really require users to specify ""output attributes"" with their output? While this does seem like good practice, I don't think we want to strictly police this behavior. Sometimes its nice to be able to play around with output, with no intention of sharing / using the data in the future. For example, we could throw a `try`-block around the above attempt to find ""default"" attributes, so that its possible to build an output writer with non-default output without specifying output attributes. 2. If we do intend to require ""output attributes"", we should probably throw an error that says something like ""output attributes must be specified for x"".",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/885
https://github.com/CliMA/Oceananigans.jl/issues/885:299,Availability,error,error,299,"It's not possible to build a `NetCDFOutputWriter` object with output that is not a field without specifying an ""attribute"", because this line. https://github.com/CliMA/Oceananigans.jl/blob/fbbb5f81b851bb838c8796efba36a3021cb89f0e/src/OutputWriters/netcdf_output_writer.jl#L192. throws an error. The error is a `KeyError`, eg:. ```; KeyError: key :time_average not found; Stacktrace:; [1] getindex at ./dict.jl:477 [inlined]; [2] NetCDFOutputWriter(::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S); ...; ```. which occurs because, in this case, `:time_average` is not one of the defaults provided:. https://github.com/CliMA/Oceananigans.jl/blob/fbbb5f81b851bb838c8796efba36a3021cb89f0e/src/OutputWriters/netcdf_output_writer.jl#L13-L20. There are really two issues:. 1. Should we really require users to specify ""output attributes"" with their output? While this does seem like good practice, I don't think we want to strictly police this behavior. Sometimes its nice to be able to play around with output, with no intention of sharing / using the data in the future. For example, we could throw a `try`-block around the above attempt to find ""default"" attributes, so that its possible to build an output writer with non-default output without specifying output attributes. 2. If we do intend to require ""output attributes"", we should probably throw an error that says something like ""output attributes must be specified for x"".",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/885
https://github.com/CliMA/Oceananigans.jl/issues/885:1416,Availability,error,error,1416,"It's not possible to build a `NetCDFOutputWriter` object with output that is not a field without specifying an ""attribute"", because this line. https://github.com/CliMA/Oceananigans.jl/blob/fbbb5f81b851bb838c8796efba36a3021cb89f0e/src/OutputWriters/netcdf_output_writer.jl#L192. throws an error. The error is a `KeyError`, eg:. ```; KeyError: key :time_average not found; Stacktrace:; [1] getindex at ./dict.jl:477 [inlined]; [2] NetCDFOutputWriter(::IncompressibleModel{Oceananigans.TimeSteppers.AdamsBashforthTimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S); ...; ```. which occurs because, in this case, `:time_average` is not one of the defaults provided:. https://github.com/CliMA/Oceananigans.jl/blob/fbbb5f81b851bb838c8796efba36a3021cb89f0e/src/OutputWriters/netcdf_output_writer.jl#L13-L20. There are really two issues:. 1. Should we really require users to specify ""output attributes"" with their output? While this does seem like good practice, I don't think we want to strictly police this behavior. Sometimes its nice to be able to play around with output, with no intention of sharing / using the data in the future. For example, we could throw a `try`-block around the above attempt to find ""default"" attributes, so that its possible to build an output writer with non-default output without specifying output attributes. 2. If we do intend to require ""output attributes"", we should probably throw an error that says something like ""output attributes must be specified for x"".",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/885
https://github.com/CliMA/Oceananigans.jl/pull/886:63,Integrability,depend,dependency,63,"This PR introduces the concept of an output writer ""diagnostic dependency"": a diagnostic which must be added to `simulation.diagnostics` in order for output to be correct. If a type of output has a ""diagnostic dependency"", it must define the function `add_dependency!(diagnostics, output)`, which will add any appropriate diagnostics to the ordered dictionary `diagnostics`. Currently we only have one type of output that requires a diagnostic, which is the `WindowedTimeAverage`. For `WindowedTimeAverage`, `add_dependency!` is. ```julia; add_dependency!(diags, wta::WindowedTimeAverage) = !(wta ∈ values(diags)) && push!(diags, wta); ```. (As a side note, we could require that all values of `diagnostics` are unique, which would obviate the check above.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/886
https://github.com/CliMA/Oceananigans.jl/pull/886:210,Integrability,depend,dependency,210,"This PR introduces the concept of an output writer ""diagnostic dependency"": a diagnostic which must be added to `simulation.diagnostics` in order for output to be correct. If a type of output has a ""diagnostic dependency"", it must define the function `add_dependency!(diagnostics, output)`, which will add any appropriate diagnostics to the ordered dictionary `diagnostics`. Currently we only have one type of output that requires a diagnostic, which is the `WindowedTimeAverage`. For `WindowedTimeAverage`, `add_dependency!` is. ```julia; add_dependency!(diags, wta::WindowedTimeAverage) = !(wta ∈ values(diags)) && push!(diags, wta); ```. (As a side note, we could require that all values of `diagnostics` are unique, which would obviate the check above.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/886
https://github.com/CliMA/Oceananigans.jl/pull/887:836,Modifiability,extend,extend,836,"This PR adds the keyword arguments `time_averaging_window` and `time_averaging_stride` to the constructors for `JLD2OutputWriter` and `NetCDFOutputWriter`. A non-`nothing` `time_averaging_window` transforms all the specified output to a `WindowedTimeAverage`. I have implemented this feature for `JLD2OutputWriter` only so far. ~~@ali-ramadhan, can you confirm that the pattern applied to `JLD2OutputWriter` will work for `NetCDFOutputWriter`? I'm not 100% sure how it would work with the ""slice"" functionality of the `NetCDFOutputWriter`.~~. Todo:. - ~~[ ] Implement convenience kwargs for `NetCDFOutputWriter`~~; - [ ] Tests for `JLD2OutputWriter`; - ~~[ ] Tests for `NetCDFOutputWriter`~~. Edit: I think we should just get this working for the `JLD2OutputWriter` for now. The `NetCDFOutputWriter` needs a bit of work anyways. We can extend `NetCDFOutputWriter` to averaged output once that preliminary work is complete.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/887
https://github.com/CliMA/Oceananigans.jl/pull/887:621,Testability,Test,Tests,621,"This PR adds the keyword arguments `time_averaging_window` and `time_averaging_stride` to the constructors for `JLD2OutputWriter` and `NetCDFOutputWriter`. A non-`nothing` `time_averaging_window` transforms all the specified output to a `WindowedTimeAverage`. I have implemented this feature for `JLD2OutputWriter` only so far. ~~@ali-ramadhan, can you confirm that the pattern applied to `JLD2OutputWriter` will work for `NetCDFOutputWriter`? I'm not 100% sure how it would work with the ""slice"" functionality of the `NetCDFOutputWriter`.~~. Todo:. - ~~[ ] Implement convenience kwargs for `NetCDFOutputWriter`~~; - [ ] Tests for `JLD2OutputWriter`; - ~~[ ] Tests for `NetCDFOutputWriter`~~. Edit: I think we should just get this working for the `JLD2OutputWriter` for now. The `NetCDFOutputWriter` needs a bit of work anyways. We can extend `NetCDFOutputWriter` to averaged output once that preliminary work is complete.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/887
https://github.com/CliMA/Oceananigans.jl/pull/887:659,Testability,Test,Tests,659,"This PR adds the keyword arguments `time_averaging_window` and `time_averaging_stride` to the constructors for `JLD2OutputWriter` and `NetCDFOutputWriter`. A non-`nothing` `time_averaging_window` transforms all the specified output to a `WindowedTimeAverage`. I have implemented this feature for `JLD2OutputWriter` only so far. ~~@ali-ramadhan, can you confirm that the pattern applied to `JLD2OutputWriter` will work for `NetCDFOutputWriter`? I'm not 100% sure how it would work with the ""slice"" functionality of the `NetCDFOutputWriter`.~~. Todo:. - ~~[ ] Implement convenience kwargs for `NetCDFOutputWriter`~~; - [ ] Tests for `JLD2OutputWriter`; - ~~[ ] Tests for `NetCDFOutputWriter`~~. Edit: I think we should just get this working for the `JLD2OutputWriter` for now. The `NetCDFOutputWriter` needs a bit of work anyways. We can extend `NetCDFOutputWriter` to averaged output once that preliminary work is complete.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/887
https://github.com/CliMA/Oceananigans.jl/pull/888:175,Testability,test,tested,175,"This pull request changes the compat entry for the `JLD2` package from `^0.1.2, ^1` to `^0.1.2, ^1, 0.2`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/888
https://github.com/CliMA/Oceananigans.jl/pull/888:280,Testability,test,tests,280,"This pull request changes the compat entry for the `JLD2` package from `^0.1.2, ^1` to `^0.1.2, ^1, 0.2`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/888
https://github.com/CliMA/Oceananigans.jl/issues/890:262,Security,validat,validate,262,"Incorrect behavior results if, for example, a `NormalFlow` boundary condition is applied to a tracer or non-wall-normal velocity component. Conversely, only the `NormalFlow` boundary condition type is correct for a wall-normal velocity component. We may want to validate the boundary condition types in the constructors for `XFaceField`, `YFaceField`, `ZFaceField`, and `CellField`. I think this might save some users a bit of pain.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/890
https://github.com/CliMA/Oceananigans.jl/pull/891:5,Deployability,release,release,5,This release will go alongside the JOSS paper. Release notes:. * Support for multithreaded CPU simulations! Set the number of threads via the `JULIA_NUM_THREADS` environment variable or via the `-t` flag in Julia 1.5+.; * New `OceananigansLogger` for fancy log messages with time stamps.; * New experimental diagnostic `WindowedTimeAverage`.; * `Average` diagnostic can include or exclude halos via the `with_halos` keyword argument.; * Improved testing infrastructure made possible by splitting tests into four groups.; * Cleaned up convergence test scripts and plots. Convergence tests can be run via the `TEST_GROUP=convergence`.; * Numerous bug fixes and documentation updates.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/891
https://github.com/CliMA/Oceananigans.jl/pull/891:47,Deployability,Release,Release,47,This release will go alongside the JOSS paper. Release notes:. * Support for multithreaded CPU simulations! Set the number of threads via the `JULIA_NUM_THREADS` environment variable or via the `-t` flag in Julia 1.5+.; * New `OceananigansLogger` for fancy log messages with time stamps.; * New experimental diagnostic `WindowedTimeAverage`.; * `Average` diagnostic can include or exclude halos via the `with_halos` keyword argument.; * Improved testing infrastructure made possible by splitting tests into four groups.; * Cleaned up convergence test scripts and plots. Convergence tests can be run via the `TEST_GROUP=convergence`.; * Numerous bug fixes and documentation updates.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/891
https://github.com/CliMA/Oceananigans.jl/pull/891:673,Deployability,update,updates,673,This release will go alongside the JOSS paper. Release notes:. * Support for multithreaded CPU simulations! Set the number of threads via the `JULIA_NUM_THREADS` environment variable or via the `-t` flag in Julia 1.5+.; * New `OceananigansLogger` for fancy log messages with time stamps.; * New experimental diagnostic `WindowedTimeAverage`.; * `Average` diagnostic can include or exclude halos via the `with_halos` keyword argument.; * Improved testing infrastructure made possible by splitting tests into four groups.; * Cleaned up convergence test scripts and plots. Convergence tests can be run via the `TEST_GROUP=convergence`.; * Numerous bug fixes and documentation updates.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/891
https://github.com/CliMA/Oceananigans.jl/pull/891:261,Integrability,message,messages,261,This release will go alongside the JOSS paper. Release notes:. * Support for multithreaded CPU simulations! Set the number of threads via the `JULIA_NUM_THREADS` environment variable or via the `-t` flag in Julia 1.5+.; * New `OceananigansLogger` for fancy log messages with time stamps.; * New experimental diagnostic `WindowedTimeAverage`.; * `Average` diagnostic can include or exclude halos via the `with_halos` keyword argument.; * Improved testing infrastructure made possible by splitting tests into four groups.; * Cleaned up convergence test scripts and plots. Convergence tests can be run via the `TEST_GROUP=convergence`.; * Numerous bug fixes and documentation updates.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/891
https://github.com/CliMA/Oceananigans.jl/pull/891:174,Modifiability,variab,variable,174,This release will go alongside the JOSS paper. Release notes:. * Support for multithreaded CPU simulations! Set the number of threads via the `JULIA_NUM_THREADS` environment variable or via the `-t` flag in Julia 1.5+.; * New `OceananigansLogger` for fancy log messages with time stamps.; * New experimental diagnostic `WindowedTimeAverage`.; * `Average` diagnostic can include or exclude halos via the `with_halos` keyword argument.; * Improved testing infrastructure made possible by splitting tests into four groups.; * Cleaned up convergence test scripts and plots. Convergence tests can be run via the `TEST_GROUP=convergence`.; * Numerous bug fixes and documentation updates.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/891
https://github.com/CliMA/Oceananigans.jl/pull/891:257,Testability,log,log,257,This release will go alongside the JOSS paper. Release notes:. * Support for multithreaded CPU simulations! Set the number of threads via the `JULIA_NUM_THREADS` environment variable or via the `-t` flag in Julia 1.5+.; * New `OceananigansLogger` for fancy log messages with time stamps.; * New experimental diagnostic `WindowedTimeAverage`.; * `Average` diagnostic can include or exclude halos via the `with_halos` keyword argument.; * Improved testing infrastructure made possible by splitting tests into four groups.; * Cleaned up convergence test scripts and plots. Convergence tests can be run via the `TEST_GROUP=convergence`.; * Numerous bug fixes and documentation updates.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/891
https://github.com/CliMA/Oceananigans.jl/pull/891:446,Testability,test,testing,446,This release will go alongside the JOSS paper. Release notes:. * Support for multithreaded CPU simulations! Set the number of threads via the `JULIA_NUM_THREADS` environment variable or via the `-t` flag in Julia 1.5+.; * New `OceananigansLogger` for fancy log messages with time stamps.; * New experimental diagnostic `WindowedTimeAverage`.; * `Average` diagnostic can include or exclude halos via the `with_halos` keyword argument.; * Improved testing infrastructure made possible by splitting tests into four groups.; * Cleaned up convergence test scripts and plots. Convergence tests can be run via the `TEST_GROUP=convergence`.; * Numerous bug fixes and documentation updates.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/891
https://github.com/CliMA/Oceananigans.jl/pull/891:496,Testability,test,tests,496,This release will go alongside the JOSS paper. Release notes:. * Support for multithreaded CPU simulations! Set the number of threads via the `JULIA_NUM_THREADS` environment variable or via the `-t` flag in Julia 1.5+.; * New `OceananigansLogger` for fancy log messages with time stamps.; * New experimental diagnostic `WindowedTimeAverage`.; * `Average` diagnostic can include or exclude halos via the `with_halos` keyword argument.; * Improved testing infrastructure made possible by splitting tests into four groups.; * Cleaned up convergence test scripts and plots. Convergence tests can be run via the `TEST_GROUP=convergence`.; * Numerous bug fixes and documentation updates.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/891
https://github.com/CliMA/Oceananigans.jl/pull/891:546,Testability,test,test,546,This release will go alongside the JOSS paper. Release notes:. * Support for multithreaded CPU simulations! Set the number of threads via the `JULIA_NUM_THREADS` environment variable or via the `-t` flag in Julia 1.5+.; * New `OceananigansLogger` for fancy log messages with time stamps.; * New experimental diagnostic `WindowedTimeAverage`.; * `Average` diagnostic can include or exclude halos via the `with_halos` keyword argument.; * Improved testing infrastructure made possible by splitting tests into four groups.; * Cleaned up convergence test scripts and plots. Convergence tests can be run via the `TEST_GROUP=convergence`.; * Numerous bug fixes and documentation updates.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/891
https://github.com/CliMA/Oceananigans.jl/pull/891:582,Testability,test,tests,582,This release will go alongside the JOSS paper. Release notes:. * Support for multithreaded CPU simulations! Set the number of threads via the `JULIA_NUM_THREADS` environment variable or via the `-t` flag in Julia 1.5+.; * New `OceananigansLogger` for fancy log messages with time stamps.; * New experimental diagnostic `WindowedTimeAverage`.; * `Average` diagnostic can include or exclude halos via the `with_halos` keyword argument.; * Improved testing infrastructure made possible by splitting tests into four groups.; * Cleaned up convergence test scripts and plots. Convergence tests can be run via the `TEST_GROUP=convergence`.; * Numerous bug fixes and documentation updates.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/891
https://github.com/CliMA/Oceananigans.jl/pull/894:909,Availability,recover,recovered,909,"This PR simplifies the API for specifying boundary conditions that are functions. We build boundary conditions by writing. ```julia; bc = BoundaryCondition(BCType, condition); ```. where `BCType` is the ""type"" of the boundary condition (`Value`, `Gradient`, `Flux`, `NormalFlow`), and `condition` is the boundary condition. If `condition` is a function, it is now assumed it can be called with the signature `condition(ξ, η, t)`, where `(ξ, η)` are spatial coordinates that vary along the boundary in question (`y, z` for `x`-boundaries, `x, z` for `y`-boundaries, and `x, y` for `z`-boundaries). Different behavior is achieved by specifying keyword arguments of `BoundaryCondition`. For example, a non-`nothing` `parameters` keyword argument means that the last argument of condition is `parameters`: `condition(ξ, η, t, parameters)`. If `discrete_form=true`, the original behavior of `BoundaryCondition` is recovered, so that `condition` is called with the ""discrete form"" `condition(i, j, grid, clock, state)`, where `i, j` are indicies that vary along the boundary in question. Specifying both `discrete_form=true` and non-`nothing` `parameters` transforms `condition` into a `ParameterizedDiscreteBoundaryFunction`, which is called with `condition(i, j, grid, clock, state, parameters)`. Under the hood, this functionality is achieved by assuming that boundary conditions for fields are always built with `FieldBoundaryConditions`. This assumptions means we can use the information provided there to ensure that `BoundaryFunction`s are always tagged with the correct boundary plane and cell location. This relieves the user from having to specify the boundary plane and cell location of a `BoundaryFunction` explicitly. We hope this simplifies the API. Resolves #769",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/894
https://github.com/CliMA/Oceananigans.jl/pull/894:1181,Modifiability,Parameteriz,ParameterizedDiscreteBoundaryFunction,1181,"This PR simplifies the API for specifying boundary conditions that are functions. We build boundary conditions by writing. ```julia; bc = BoundaryCondition(BCType, condition); ```. where `BCType` is the ""type"" of the boundary condition (`Value`, `Gradient`, `Flux`, `NormalFlow`), and `condition` is the boundary condition. If `condition` is a function, it is now assumed it can be called with the signature `condition(ξ, η, t)`, where `(ξ, η)` are spatial coordinates that vary along the boundary in question (`y, z` for `x`-boundaries, `x, z` for `y`-boundaries, and `x, y` for `z`-boundaries). Different behavior is achieved by specifying keyword arguments of `BoundaryCondition`. For example, a non-`nothing` `parameters` keyword argument means that the last argument of condition is `parameters`: `condition(ξ, η, t, parameters)`. If `discrete_form=true`, the original behavior of `BoundaryCondition` is recovered, so that `condition` is called with the ""discrete form"" `condition(i, j, grid, clock, state)`, where `i, j` are indicies that vary along the boundary in question. Specifying both `discrete_form=true` and non-`nothing` `parameters` transforms `condition` into a `ParameterizedDiscreteBoundaryFunction`, which is called with `condition(i, j, grid, clock, state, parameters)`. Under the hood, this functionality is achieved by assuming that boundary conditions for fields are always built with `FieldBoundaryConditions`. This assumptions means we can use the information provided there to ensure that `BoundaryFunction`s are always tagged with the correct boundary plane and cell location. This relieves the user from having to specify the boundary plane and cell location of a `BoundaryFunction` explicitly. We hope this simplifies the API. Resolves #769",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/894
https://github.com/CliMA/Oceananigans.jl/pull/894:909,Safety,recover,recovered,909,"This PR simplifies the API for specifying boundary conditions that are functions. We build boundary conditions by writing. ```julia; bc = BoundaryCondition(BCType, condition); ```. where `BCType` is the ""type"" of the boundary condition (`Value`, `Gradient`, `Flux`, `NormalFlow`), and `condition` is the boundary condition. If `condition` is a function, it is now assumed it can be called with the signature `condition(ξ, η, t)`, where `(ξ, η)` are spatial coordinates that vary along the boundary in question (`y, z` for `x`-boundaries, `x, z` for `y`-boundaries, and `x, y` for `z`-boundaries). Different behavior is achieved by specifying keyword arguments of `BoundaryCondition`. For example, a non-`nothing` `parameters` keyword argument means that the last argument of condition is `parameters`: `condition(ξ, η, t, parameters)`. If `discrete_form=true`, the original behavior of `BoundaryCondition` is recovered, so that `condition` is called with the ""discrete form"" `condition(i, j, grid, clock, state)`, where `i, j` are indicies that vary along the boundary in question. Specifying both `discrete_form=true` and non-`nothing` `parameters` transforms `condition` into a `ParameterizedDiscreteBoundaryFunction`, which is called with `condition(i, j, grid, clock, state, parameters)`. Under the hood, this functionality is achieved by assuming that boundary conditions for fields are always built with `FieldBoundaryConditions`. This assumptions means we can use the information provided there to ensure that `BoundaryFunction`s are always tagged with the correct boundary plane and cell location. This relieves the user from having to specify the boundary plane and cell location of a `BoundaryFunction` explicitly. We hope this simplifies the API. Resolves #769",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/894
https://github.com/CliMA/Oceananigans.jl/pull/894:8,Usability,simpl,simplifies,8,"This PR simplifies the API for specifying boundary conditions that are functions. We build boundary conditions by writing. ```julia; bc = BoundaryCondition(BCType, condition); ```. where `BCType` is the ""type"" of the boundary condition (`Value`, `Gradient`, `Flux`, `NormalFlow`), and `condition` is the boundary condition. If `condition` is a function, it is now assumed it can be called with the signature `condition(ξ, η, t)`, where `(ξ, η)` are spatial coordinates that vary along the boundary in question (`y, z` for `x`-boundaries, `x, z` for `y`-boundaries, and `x, y` for `z`-boundaries). Different behavior is achieved by specifying keyword arguments of `BoundaryCondition`. For example, a non-`nothing` `parameters` keyword argument means that the last argument of condition is `parameters`: `condition(ξ, η, t, parameters)`. If `discrete_form=true`, the original behavior of `BoundaryCondition` is recovered, so that `condition` is called with the ""discrete form"" `condition(i, j, grid, clock, state)`, where `i, j` are indicies that vary along the boundary in question. Specifying both `discrete_form=true` and non-`nothing` `parameters` transforms `condition` into a `ParameterizedDiscreteBoundaryFunction`, which is called with `condition(i, j, grid, clock, state, parameters)`. Under the hood, this functionality is achieved by assuming that boundary conditions for fields are always built with `FieldBoundaryConditions`. This assumptions means we can use the information provided there to ensure that `BoundaryFunction`s are always tagged with the correct boundary plane and cell location. This relieves the user from having to specify the boundary plane and cell location of a `BoundaryFunction` explicitly. We hope this simplifies the API. Resolves #769",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/894
https://github.com/CliMA/Oceananigans.jl/pull/894:1738,Usability,simpl,simplifies,1738,"This PR simplifies the API for specifying boundary conditions that are functions. We build boundary conditions by writing. ```julia; bc = BoundaryCondition(BCType, condition); ```. where `BCType` is the ""type"" of the boundary condition (`Value`, `Gradient`, `Flux`, `NormalFlow`), and `condition` is the boundary condition. If `condition` is a function, it is now assumed it can be called with the signature `condition(ξ, η, t)`, where `(ξ, η)` are spatial coordinates that vary along the boundary in question (`y, z` for `x`-boundaries, `x, z` for `y`-boundaries, and `x, y` for `z`-boundaries). Different behavior is achieved by specifying keyword arguments of `BoundaryCondition`. For example, a non-`nothing` `parameters` keyword argument means that the last argument of condition is `parameters`: `condition(ξ, η, t, parameters)`. If `discrete_form=true`, the original behavior of `BoundaryCondition` is recovered, so that `condition` is called with the ""discrete form"" `condition(i, j, grid, clock, state)`, where `i, j` are indicies that vary along the boundary in question. Specifying both `discrete_form=true` and non-`nothing` `parameters` transforms `condition` into a `ParameterizedDiscreteBoundaryFunction`, which is called with `condition(i, j, grid, clock, state, parameters)`. Under the hood, this functionality is achieved by assuming that boundary conditions for fields are always built with `FieldBoundaryConditions`. This assumptions means we can use the information provided there to ensure that `BoundaryFunction`s are always tagged with the correct boundary plane and cell location. This relieves the user from having to specify the boundary plane and cell location of a `BoundaryFunction` explicitly. We hope this simplifies the API. Resolves #769",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/894
https://github.com/CliMA/Oceananigans.jl/issues/896:18,Integrability,interface,interface,18,"We need a unified interface for specifying forcing functions. The first change needed is to assume that, by default, forcing functions are called with the signature. ```julia; forcing(x, y, z, t); ```. This can be achieved with modest changes to [`ModelForcing`](https://github.com/CliMA/Oceananigans.jl/blob/f13a0a26df78cd1c1495d56ef5e7ea2fbbbfb23c/src/Forcing/model_forcing.jl). Next, we can introduce an interface, something like `Forcing(func; kwargs...)`, where `func` is the forcing function. A few kwargs that we might want:. - `parameters`: when `parameters` is specified, `func` is transformed into either a `SimpleForcing` or `ParameterizedForcing` which takes parameters. - `discrete_form`: when `discrete_form=true`, the function signature is assumed to have the ""discrete form"" `func(i, j, k, grid, clock, state)`. - `field_dependent`: this only applies when `discrete_form=false`, and specifies that the function signature contains field. We'll also need a new type, perhaps `DiscreteForcing`, that ensures a forcing function is not transformed into a `SimpleForcing` inside the `ModelForcing` constructor. Finally, we can add keyword arguments to `ModelForcing` that apply the relevant transformations to every forcing function as a convenience.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/896
https://github.com/CliMA/Oceananigans.jl/issues/896:407,Integrability,interface,interface,407,"We need a unified interface for specifying forcing functions. The first change needed is to assume that, by default, forcing functions are called with the signature. ```julia; forcing(x, y, z, t); ```. This can be achieved with modest changes to [`ModelForcing`](https://github.com/CliMA/Oceananigans.jl/blob/f13a0a26df78cd1c1495d56ef5e7ea2fbbbfb23c/src/Forcing/model_forcing.jl). Next, we can introduce an interface, something like `Forcing(func; kwargs...)`, where `func` is the forcing function. A few kwargs that we might want:. - `parameters`: when `parameters` is specified, `func` is transformed into either a `SimpleForcing` or `ParameterizedForcing` which takes parameters. - `discrete_form`: when `discrete_form=true`, the function signature is assumed to have the ""discrete form"" `func(i, j, k, grid, clock, state)`. - `field_dependent`: this only applies when `discrete_form=false`, and specifies that the function signature contains field. We'll also need a new type, perhaps `DiscreteForcing`, that ensures a forcing function is not transformed into a `SimpleForcing` inside the `ModelForcing` constructor. Finally, we can add keyword arguments to `ModelForcing` that apply the relevant transformations to every forcing function as a convenience.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/896
https://github.com/CliMA/Oceananigans.jl/issues/896:637,Modifiability,Parameteriz,ParameterizedForcing,637,"We need a unified interface for specifying forcing functions. The first change needed is to assume that, by default, forcing functions are called with the signature. ```julia; forcing(x, y, z, t); ```. This can be achieved with modest changes to [`ModelForcing`](https://github.com/CliMA/Oceananigans.jl/blob/f13a0a26df78cd1c1495d56ef5e7ea2fbbbfb23c/src/Forcing/model_forcing.jl). Next, we can introduce an interface, something like `Forcing(func; kwargs...)`, where `func` is the forcing function. A few kwargs that we might want:. - `parameters`: when `parameters` is specified, `func` is transformed into either a `SimpleForcing` or `ParameterizedForcing` which takes parameters. - `discrete_form`: when `discrete_form=true`, the function signature is assumed to have the ""discrete form"" `func(i, j, k, grid, clock, state)`. - `field_dependent`: this only applies when `discrete_form=false`, and specifies that the function signature contains field. We'll also need a new type, perhaps `DiscreteForcing`, that ensures a forcing function is not transformed into a `SimpleForcing` inside the `ModelForcing` constructor. Finally, we can add keyword arguments to `ModelForcing` that apply the relevant transformations to every forcing function as a convenience.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/896
https://github.com/CliMA/Oceananigans.jl/issues/896:618,Usability,Simpl,SimpleForcing,618,"We need a unified interface for specifying forcing functions. The first change needed is to assume that, by default, forcing functions are called with the signature. ```julia; forcing(x, y, z, t); ```. This can be achieved with modest changes to [`ModelForcing`](https://github.com/CliMA/Oceananigans.jl/blob/f13a0a26df78cd1c1495d56ef5e7ea2fbbbfb23c/src/Forcing/model_forcing.jl). Next, we can introduce an interface, something like `Forcing(func; kwargs...)`, where `func` is the forcing function. A few kwargs that we might want:. - `parameters`: when `parameters` is specified, `func` is transformed into either a `SimpleForcing` or `ParameterizedForcing` which takes parameters. - `discrete_form`: when `discrete_form=true`, the function signature is assumed to have the ""discrete form"" `func(i, j, k, grid, clock, state)`. - `field_dependent`: this only applies when `discrete_form=false`, and specifies that the function signature contains field. We'll also need a new type, perhaps `DiscreteForcing`, that ensures a forcing function is not transformed into a `SimpleForcing` inside the `ModelForcing` constructor. Finally, we can add keyword arguments to `ModelForcing` that apply the relevant transformations to every forcing function as a convenience.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/896
https://github.com/CliMA/Oceananigans.jl/issues/896:1067,Usability,Simpl,SimpleForcing,1067,"We need a unified interface for specifying forcing functions. The first change needed is to assume that, by default, forcing functions are called with the signature. ```julia; forcing(x, y, z, t); ```. This can be achieved with modest changes to [`ModelForcing`](https://github.com/CliMA/Oceananigans.jl/blob/f13a0a26df78cd1c1495d56ef5e7ea2fbbbfb23c/src/Forcing/model_forcing.jl). Next, we can introduce an interface, something like `Forcing(func; kwargs...)`, where `func` is the forcing function. A few kwargs that we might want:. - `parameters`: when `parameters` is specified, `func` is transformed into either a `SimpleForcing` or `ParameterizedForcing` which takes parameters. - `discrete_form`: when `discrete_form=true`, the function signature is assumed to have the ""discrete form"" `func(i, j, k, grid, clock, state)`. - `field_dependent`: this only applies when `discrete_form=false`, and specifies that the function signature contains field. We'll also need a new type, perhaps `DiscreteForcing`, that ensures a forcing function is not transformed into a `SimpleForcing` inside the `ModelForcing` constructor. Finally, we can add keyword arguments to `ModelForcing` that apply the relevant transformations to every forcing function as a convenience.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/896
https://github.com/CliMA/Oceananigans.jl/issues/897:21,Deployability,continuous,continuous,21,"We have the need for continuous (not discrete) boundary condition functions that depend on the field to which the boundary condition is applied. For example, in the `ocean_convection_and_wind_mixing.jl`, the prescribed salinity flux depends on the salinity adjacent to the boundary:. https://github.com/CliMA/Oceananigans.jl/blob/f13a0a26df78cd1c1495d56ef5e7ea2fbbbfb23c/examples/ocean_wind_mixing_and_convection.jl#L73. The linear drag boundary condition implemented in `eady_turbulence.jl` is similar:. https://github.com/CliMA/Oceananigans.jl/blob/f13a0a26df78cd1c1495d56ef5e7ea2fbbbfb23c/examples/eady_turbulence.jl#L60. A slightly simpler interface would allow users to implement the salinity flux (for example) with. ```julia; Qˢ(x, y, t, S, evaporation) = - evaporation * S; ```. For this to work, a number of changes must be made in `BoundaryFunction`, `BoundaryCondition`, `FieldBoundaryConditions`, and the `TracerFields` constructor:. - `BoundaryFunction` must record whether or not the function is `field_dependent`, as well as the ""`side`"" of the boundary condition (left or right, so that the wall-normal index may be inferred), the `field_name`, and the `field_container` in which the field lives (`model.velocities` or `model.tracers`). - `BoundaryCondition` must provide the option `field_dependent=true`. - `FieldBoundaryConditions` must supply the `side` at which the boundary condition is applied (`Left()` for west, south, bottom and `Right()` for east, north, and top). - `TracerFields` must supply the tracer name. New methods for field-dependent `BoundaryFunction`s are also required. For `z`-boundaries, for example, we need. ```julia; @inline function (bc::BoundaryFunction{:z, X, Y, true})(j, k, grid, clock, state) where {X, Y}; k = wall_adjacent_index(bc.side, grid.Nz); container = getproperty(state, bc.field_container); field = getproperty(container, bc.field_name); ; return @inbounds call_boundary_function(bc.func, xnode(X, i, grid), ynode(Y, j, grid), clock.time, f",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/897
https://github.com/CliMA/Oceananigans.jl/issues/897:81,Integrability,depend,depend,81,"We have the need for continuous (not discrete) boundary condition functions that depend on the field to which the boundary condition is applied. For example, in the `ocean_convection_and_wind_mixing.jl`, the prescribed salinity flux depends on the salinity adjacent to the boundary:. https://github.com/CliMA/Oceananigans.jl/blob/f13a0a26df78cd1c1495d56ef5e7ea2fbbbfb23c/examples/ocean_wind_mixing_and_convection.jl#L73. The linear drag boundary condition implemented in `eady_turbulence.jl` is similar:. https://github.com/CliMA/Oceananigans.jl/blob/f13a0a26df78cd1c1495d56ef5e7ea2fbbbfb23c/examples/eady_turbulence.jl#L60. A slightly simpler interface would allow users to implement the salinity flux (for example) with. ```julia; Qˢ(x, y, t, S, evaporation) = - evaporation * S; ```. For this to work, a number of changes must be made in `BoundaryFunction`, `BoundaryCondition`, `FieldBoundaryConditions`, and the `TracerFields` constructor:. - `BoundaryFunction` must record whether or not the function is `field_dependent`, as well as the ""`side`"" of the boundary condition (left or right, so that the wall-normal index may be inferred), the `field_name`, and the `field_container` in which the field lives (`model.velocities` or `model.tracers`). - `BoundaryCondition` must provide the option `field_dependent=true`. - `FieldBoundaryConditions` must supply the `side` at which the boundary condition is applied (`Left()` for west, south, bottom and `Right()` for east, north, and top). - `TracerFields` must supply the tracer name. New methods for field-dependent `BoundaryFunction`s are also required. For `z`-boundaries, for example, we need. ```julia; @inline function (bc::BoundaryFunction{:z, X, Y, true})(j, k, grid, clock, state) where {X, Y}; k = wall_adjacent_index(bc.side, grid.Nz); container = getproperty(state, bc.field_container); field = getproperty(container, bc.field_name); ; return @inbounds call_boundary_function(bc.func, xnode(X, i, grid), ynode(Y, j, grid), clock.time, f",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/897
https://github.com/CliMA/Oceananigans.jl/issues/897:233,Integrability,depend,depends,233,"We have the need for continuous (not discrete) boundary condition functions that depend on the field to which the boundary condition is applied. For example, in the `ocean_convection_and_wind_mixing.jl`, the prescribed salinity flux depends on the salinity adjacent to the boundary:. https://github.com/CliMA/Oceananigans.jl/blob/f13a0a26df78cd1c1495d56ef5e7ea2fbbbfb23c/examples/ocean_wind_mixing_and_convection.jl#L73. The linear drag boundary condition implemented in `eady_turbulence.jl` is similar:. https://github.com/CliMA/Oceananigans.jl/blob/f13a0a26df78cd1c1495d56ef5e7ea2fbbbfb23c/examples/eady_turbulence.jl#L60. A slightly simpler interface would allow users to implement the salinity flux (for example) with. ```julia; Qˢ(x, y, t, S, evaporation) = - evaporation * S; ```. For this to work, a number of changes must be made in `BoundaryFunction`, `BoundaryCondition`, `FieldBoundaryConditions`, and the `TracerFields` constructor:. - `BoundaryFunction` must record whether or not the function is `field_dependent`, as well as the ""`side`"" of the boundary condition (left or right, so that the wall-normal index may be inferred), the `field_name`, and the `field_container` in which the field lives (`model.velocities` or `model.tracers`). - `BoundaryCondition` must provide the option `field_dependent=true`. - `FieldBoundaryConditions` must supply the `side` at which the boundary condition is applied (`Left()` for west, south, bottom and `Right()` for east, north, and top). - `TracerFields` must supply the tracer name. New methods for field-dependent `BoundaryFunction`s are also required. For `z`-boundaries, for example, we need. ```julia; @inline function (bc::BoundaryFunction{:z, X, Y, true})(j, k, grid, clock, state) where {X, Y}; k = wall_adjacent_index(bc.side, grid.Nz); container = getproperty(state, bc.field_container); field = getproperty(container, bc.field_name); ; return @inbounds call_boundary_function(bc.func, xnode(X, i, grid), ynode(Y, j, grid), clock.time, f",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/897
https://github.com/CliMA/Oceananigans.jl/issues/897:644,Integrability,interface,interface,644,"We have the need for continuous (not discrete) boundary condition functions that depend on the field to which the boundary condition is applied. For example, in the `ocean_convection_and_wind_mixing.jl`, the prescribed salinity flux depends on the salinity adjacent to the boundary:. https://github.com/CliMA/Oceananigans.jl/blob/f13a0a26df78cd1c1495d56ef5e7ea2fbbbfb23c/examples/ocean_wind_mixing_and_convection.jl#L73. The linear drag boundary condition implemented in `eady_turbulence.jl` is similar:. https://github.com/CliMA/Oceananigans.jl/blob/f13a0a26df78cd1c1495d56ef5e7ea2fbbbfb23c/examples/eady_turbulence.jl#L60. A slightly simpler interface would allow users to implement the salinity flux (for example) with. ```julia; Qˢ(x, y, t, S, evaporation) = - evaporation * S; ```. For this to work, a number of changes must be made in `BoundaryFunction`, `BoundaryCondition`, `FieldBoundaryConditions`, and the `TracerFields` constructor:. - `BoundaryFunction` must record whether or not the function is `field_dependent`, as well as the ""`side`"" of the boundary condition (left or right, so that the wall-normal index may be inferred), the `field_name`, and the `field_container` in which the field lives (`model.velocities` or `model.tracers`). - `BoundaryCondition` must provide the option `field_dependent=true`. - `FieldBoundaryConditions` must supply the `side` at which the boundary condition is applied (`Left()` for west, south, bottom and `Right()` for east, north, and top). - `TracerFields` must supply the tracer name. New methods for field-dependent `BoundaryFunction`s are also required. For `z`-boundaries, for example, we need. ```julia; @inline function (bc::BoundaryFunction{:z, X, Y, true})(j, k, grid, clock, state) where {X, Y}; k = wall_adjacent_index(bc.side, grid.Nz); container = getproperty(state, bc.field_container); field = getproperty(container, bc.field_name); ; return @inbounds call_boundary_function(bc.func, xnode(X, i, grid), ynode(Y, j, grid), clock.time, f",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/897
https://github.com/CliMA/Oceananigans.jl/issues/897:1560,Integrability,depend,dependent,1560,"crete) boundary condition functions that depend on the field to which the boundary condition is applied. For example, in the `ocean_convection_and_wind_mixing.jl`, the prescribed salinity flux depends on the salinity adjacent to the boundary:. https://github.com/CliMA/Oceananigans.jl/blob/f13a0a26df78cd1c1495d56ef5e7ea2fbbbfb23c/examples/ocean_wind_mixing_and_convection.jl#L73. The linear drag boundary condition implemented in `eady_turbulence.jl` is similar:. https://github.com/CliMA/Oceananigans.jl/blob/f13a0a26df78cd1c1495d56ef5e7ea2fbbbfb23c/examples/eady_turbulence.jl#L60. A slightly simpler interface would allow users to implement the salinity flux (for example) with. ```julia; Qˢ(x, y, t, S, evaporation) = - evaporation * S; ```. For this to work, a number of changes must be made in `BoundaryFunction`, `BoundaryCondition`, `FieldBoundaryConditions`, and the `TracerFields` constructor:. - `BoundaryFunction` must record whether or not the function is `field_dependent`, as well as the ""`side`"" of the boundary condition (left or right, so that the wall-normal index may be inferred), the `field_name`, and the `field_container` in which the field lives (`model.velocities` or `model.tracers`). - `BoundaryCondition` must provide the option `field_dependent=true`. - `FieldBoundaryConditions` must supply the `side` at which the boundary condition is applied (`Left()` for west, south, bottom and `Right()` for east, north, and top). - `TracerFields` must supply the tracer name. New methods for field-dependent `BoundaryFunction`s are also required. For `z`-boundaries, for example, we need. ```julia; @inline function (bc::BoundaryFunction{:z, X, Y, true})(j, k, grid, clock, state) where {X, Y}; k = wall_adjacent_index(bc.side, grid.Nz); container = getproperty(state, bc.field_container); field = getproperty(container, bc.field_name); ; return @inbounds call_boundary_function(bc.func, xnode(X, i, grid), ynode(Y, j, grid), clock.time, field[i, j, k], bc.parameters); end; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/897
https://github.com/CliMA/Oceananigans.jl/issues/897:636,Usability,simpl,simpler,636,"We have the need for continuous (not discrete) boundary condition functions that depend on the field to which the boundary condition is applied. For example, in the `ocean_convection_and_wind_mixing.jl`, the prescribed salinity flux depends on the salinity adjacent to the boundary:. https://github.com/CliMA/Oceananigans.jl/blob/f13a0a26df78cd1c1495d56ef5e7ea2fbbbfb23c/examples/ocean_wind_mixing_and_convection.jl#L73. The linear drag boundary condition implemented in `eady_turbulence.jl` is similar:. https://github.com/CliMA/Oceananigans.jl/blob/f13a0a26df78cd1c1495d56ef5e7ea2fbbbfb23c/examples/eady_turbulence.jl#L60. A slightly simpler interface would allow users to implement the salinity flux (for example) with. ```julia; Qˢ(x, y, t, S, evaporation) = - evaporation * S; ```. For this to work, a number of changes must be made in `BoundaryFunction`, `BoundaryCondition`, `FieldBoundaryConditions`, and the `TracerFields` constructor:. - `BoundaryFunction` must record whether or not the function is `field_dependent`, as well as the ""`side`"" of the boundary condition (left or right, so that the wall-normal index may be inferred), the `field_name`, and the `field_container` in which the field lives (`model.velocities` or `model.tracers`). - `BoundaryCondition` must provide the option `field_dependent=true`. - `FieldBoundaryConditions` must supply the `side` at which the boundary condition is applied (`Left()` for west, south, bottom and `Right()` for east, north, and top). - `TracerFields` must supply the tracer name. New methods for field-dependent `BoundaryFunction`s are also required. For `z`-boundaries, for example, we need. ```julia; @inline function (bc::BoundaryFunction{:z, X, Y, true})(j, k, grid, clock, state) where {X, Y}; k = wall_adjacent_index(bc.side, grid.Nz); container = getproperty(state, bc.field_container); field = getproperty(container, bc.field_name); ; return @inbounds call_boundary_function(bc.func, xnode(X, i, grid), ynode(Y, j, grid), clock.time, f",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/897
https://github.com/CliMA/Oceananigans.jl/pull/898:439,Availability,down,downstream,439,"This pull request sets the compat entry for the `SafeTestsets` package to `0.0.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `SafeTestsets` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/898
https://github.com/CliMA/Oceananigans.jl/pull/898:387,Deployability,patch,patch,387,"This pull request sets the compat entry for the `SafeTestsets` package to `0.0.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `SafeTestsets` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/898
https://github.com/CliMA/Oceananigans.jl/pull/898:393,Deployability,release,release,393,"This pull request sets the compat entry for the `SafeTestsets` package to `0.0.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `SafeTestsets` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/898
https://github.com/CliMA/Oceananigans.jl/pull/898:463,Integrability,depend,depend,463,"This pull request sets the compat entry for the `SafeTestsets` package to `0.0.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `SafeTestsets` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/898
https://github.com/CliMA/Oceananigans.jl/pull/898:49,Safety,Safe,SafeTestsets,49,"This pull request sets the compat entry for the `SafeTestsets` package to `0.0.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `SafeTestsets` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/898
https://github.com/CliMA/Oceananigans.jl/pull/898:170,Safety,Safe,SafeTestsets,170,"This pull request sets the compat entry for the `SafeTestsets` package to `0.0.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `SafeTestsets` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/898
https://github.com/CliMA/Oceananigans.jl/pull/898:210,Testability,test,tested,210,"This pull request sets the compat entry for the `SafeTestsets` package to `0.0.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `SafeTestsets` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/898
https://github.com/CliMA/Oceananigans.jl/pull/898:315,Testability,test,tests,315,"This pull request sets the compat entry for the `SafeTestsets` package to `0.0.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `SafeTestsets` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/898
https://github.com/CliMA/Oceananigans.jl/pull/898:482,Testability,test,tests,482,"This pull request sets the compat entry for the `SafeTestsets` package to `0.0.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `SafeTestsets` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/898
https://github.com/CliMA/Oceananigans.jl/pull/899:282,Energy Efficiency,energy,energy,282,"This PR adds a new Coriolis implementation, a non-traditional β plane that accounts for the latitudinal variation of both the locally vertical and the locally horizontal components of the rotation vector. This implementation is based off of section 5 of Dellar (2011). It conserves energy, angular momentum, and potential vorticity. Dellar, P. (2011). Variations on a beta-plane: Derivation of non-traditional beta-plane equations from Hamilton's principle on a sphere. Journal of Fluid Mechanics, 674, 174-195. doi:[10.1017/S0022112010006464](https://doi.org/10.1017/S0022112010006464)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/899
https://github.com/CliMA/Oceananigans.jl/pull/904:1135,Testability,test,tests,1135,"This PR generalizes `fill_halo_regions!` for flux boundary conditions to work correctly for biharmonic diffusivities, in addition to second-order diffusivities. This will allow biharmonic diffusivities to be used in closed domains or along `Bounded` dimensions. In particular (and after tweaking the definition of `AnisotropicBiharmonicDiffusivity`), no flux conditions on any even diffusion operator are enforced by ensuring that odd derivatives across the boundary are zero. This was already done for the first derivative, but did not work for third derivatives and higher. In this PR, kernels are written that _reflect_ fields across the boundary for flux boundary conditions. Reflection implies that odd derivatives are zero and ensures that no flux is enforced for diffusivities of order higher than two. Note that `Value` and `Gradient` boundary conditions do not work for biharmonic diffusivity (and likely never will). Thus only `Flux` and `Periodic` boundary conditions are supported with biharmonic diffusivity. This PR also does some minor shuffling of file content and names, and generalizes the tracer and momentum budget tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/904
https://github.com/CliMA/Oceananigans.jl/issues/913:232,Modifiability,variab,variables,232,"I think we should change the kwarg to `mode` with the two options from NCDatasets.jl: `""a""` (for append) and `""c""` (for clobber or create). Right now even with `clobber=false` `NetCDFOutputWriter` tries to define new dimensions and variables (which would fail due to conflict with existing dimensions/variables). cc @suyashbire1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/913
https://github.com/CliMA/Oceananigans.jl/issues/913:301,Modifiability,variab,variables,301,"I think we should change the kwarg to `mode` with the two options from NCDatasets.jl: `""a""` (for append) and `""c""` (for clobber or create). Right now even with `clobber=false` `NetCDFOutputWriter` tries to define new dimensions and variables (which would fail due to conflict with existing dimensions/variables). cc @suyashbire1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/913
https://github.com/CliMA/Oceananigans.jl/pull/914:158,Integrability,depend,depending,158,"This PR cleans up the `Fields` module: previously, `zeros` was overloaded in a confusing way that would return either `Array` / `CuArray` or an `OffsetArray` depending on the arguments. . This PR introduces a function `new_data` that returns an `OffsetArray`. `new_data` is intended to build `OffsetArrays` that hold the data associated with a field, using the architecture, grid eltype, and the field location to determine array type, size, and indexing. This PR moves the vanilla `zeros` definitions (convenience methods that use `eltype(grid)` to determine floating point type and `arch` to determine whether or not an array is converted to `CuArray`) to `Fields.jl` top-level.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/914
https://github.com/CliMA/Oceananigans.jl/pull/915:467,Availability,checkpoint,checkpoint,467,"This PR refactors the `NetCDFOutputWriter` constructor by getting rid of the `write_grid_and_attributes` function and by changing the boolean `clobber` keyword argument to `mode`, which is passed to NCDatasets.jl and takes on the values `""c""` for create/clobber or `""a""` for append. Passing `mode=""a""` allows you to append to an existing NetCDF file. I added some tests for this. This is important if we want to keep using the same NetCDF file after restoring from a checkpoint. cc @suyashbire1 . Resolves #913",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/915
https://github.com/CliMA/Oceananigans.jl/pull/915:8,Modifiability,refactor,refactors,8,"This PR refactors the `NetCDFOutputWriter` constructor by getting rid of the `write_grid_and_attributes` function and by changing the boolean `clobber` keyword argument to `mode`, which is passed to NCDatasets.jl and takes on the values `""c""` for create/clobber or `""a""` for append. Passing `mode=""a""` allows you to append to an existing NetCDF file. I added some tests for this. This is important if we want to keep using the same NetCDF file after restoring from a checkpoint. cc @suyashbire1 . Resolves #913",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/915
https://github.com/CliMA/Oceananigans.jl/pull/915:364,Testability,test,tests,364,"This PR refactors the `NetCDFOutputWriter` constructor by getting rid of the `write_grid_and_attributes` function and by changing the boolean `clobber` keyword argument to `mode`, which is passed to NCDatasets.jl and takes on the values `""c""` for create/clobber or `""a""` for append. Passing `mode=""a""` allows you to append to an existing NetCDF file. I added some tests for this. This is important if we want to keep using the same NetCDF file after restoring from a checkpoint. cc @suyashbire1 . Resolves #913",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/915
https://github.com/CliMA/Oceananigans.jl/pull/916:47,Deployability,release,release,47,"OK so looks like this will have to be the JOSS release and include the JOSS paper in the repository (#564). I'd also like to include PRs #910 and #915 in this release. @glwagner Do you want to include any PRs in v0.36.0?. Release notes:. This release coincides with the publication of the Oceananigans.jl Journal of Open Source Software (JOSS) paper. Changelog:; * Simplified boundary condition interface, types, and constructors. (@glwagner do you want add to this, maybe include a list of breaking changes?); * Support for a `NonTraditionalBetaPlane` Coriolis force implementation.; * The `AnisotropicBiharmonicDiffusivity` closure now works properly in closed domains with zero `Flux` boundary conditions, as higher-order boundary conditions are enforced.; * Bug fix: Appending to NetCDF files with `NetCDFOutputWriter` works now.; * Bug fix: Computations of abstract operations compute the right end point of face-centered fields along bounded dimensions.; * Bug fix: Averages `with_halos=false` return results with the correct dimensions for face-centered results along bounded dimensions.; * Small bug fixes for `show` methods. Breaking changes:; * When constructing a `NetCDFOutputWriter`, use `mode=""c""` instead of `clobber=true` and `mode=""a""` instead of `clobber=false`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/916
https://github.com/CliMA/Oceananigans.jl/pull/916:159,Deployability,release,release,159,"OK so looks like this will have to be the JOSS release and include the JOSS paper in the repository (#564). I'd also like to include PRs #910 and #915 in this release. @glwagner Do you want to include any PRs in v0.36.0?. Release notes:. This release coincides with the publication of the Oceananigans.jl Journal of Open Source Software (JOSS) paper. Changelog:; * Simplified boundary condition interface, types, and constructors. (@glwagner do you want add to this, maybe include a list of breaking changes?); * Support for a `NonTraditionalBetaPlane` Coriolis force implementation.; * The `AnisotropicBiharmonicDiffusivity` closure now works properly in closed domains with zero `Flux` boundary conditions, as higher-order boundary conditions are enforced.; * Bug fix: Appending to NetCDF files with `NetCDFOutputWriter` works now.; * Bug fix: Computations of abstract operations compute the right end point of face-centered fields along bounded dimensions.; * Bug fix: Averages `with_halos=false` return results with the correct dimensions for face-centered results along bounded dimensions.; * Small bug fixes for `show` methods. Breaking changes:; * When constructing a `NetCDFOutputWriter`, use `mode=""c""` instead of `clobber=true` and `mode=""a""` instead of `clobber=false`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/916
https://github.com/CliMA/Oceananigans.jl/pull/916:222,Deployability,Release,Release,222,"OK so looks like this will have to be the JOSS release and include the JOSS paper in the repository (#564). I'd also like to include PRs #910 and #915 in this release. @glwagner Do you want to include any PRs in v0.36.0?. Release notes:. This release coincides with the publication of the Oceananigans.jl Journal of Open Source Software (JOSS) paper. Changelog:; * Simplified boundary condition interface, types, and constructors. (@glwagner do you want add to this, maybe include a list of breaking changes?); * Support for a `NonTraditionalBetaPlane` Coriolis force implementation.; * The `AnisotropicBiharmonicDiffusivity` closure now works properly in closed domains with zero `Flux` boundary conditions, as higher-order boundary conditions are enforced.; * Bug fix: Appending to NetCDF files with `NetCDFOutputWriter` works now.; * Bug fix: Computations of abstract operations compute the right end point of face-centered fields along bounded dimensions.; * Bug fix: Averages `with_halos=false` return results with the correct dimensions for face-centered results along bounded dimensions.; * Small bug fixes for `show` methods. Breaking changes:; * When constructing a `NetCDFOutputWriter`, use `mode=""c""` instead of `clobber=true` and `mode=""a""` instead of `clobber=false`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/916
https://github.com/CliMA/Oceananigans.jl/pull/916:243,Deployability,release,release,243,"OK so looks like this will have to be the JOSS release and include the JOSS paper in the repository (#564). I'd also like to include PRs #910 and #915 in this release. @glwagner Do you want to include any PRs in v0.36.0?. Release notes:. This release coincides with the publication of the Oceananigans.jl Journal of Open Source Software (JOSS) paper. Changelog:; * Simplified boundary condition interface, types, and constructors. (@glwagner do you want add to this, maybe include a list of breaking changes?); * Support for a `NonTraditionalBetaPlane` Coriolis force implementation.; * The `AnisotropicBiharmonicDiffusivity` closure now works properly in closed domains with zero `Flux` boundary conditions, as higher-order boundary conditions are enforced.; * Bug fix: Appending to NetCDF files with `NetCDFOutputWriter` works now.; * Bug fix: Computations of abstract operations compute the right end point of face-centered fields along bounded dimensions.; * Bug fix: Averages `with_halos=false` return results with the correct dimensions for face-centered results along bounded dimensions.; * Small bug fixes for `show` methods. Breaking changes:; * When constructing a `NetCDFOutputWriter`, use `mode=""c""` instead of `clobber=true` and `mode=""a""` instead of `clobber=false`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/916
https://github.com/CliMA/Oceananigans.jl/pull/916:395,Integrability,interface,interface,395,"OK so looks like this will have to be the JOSS release and include the JOSS paper in the repository (#564). I'd also like to include PRs #910 and #915 in this release. @glwagner Do you want to include any PRs in v0.36.0?. Release notes:. This release coincides with the publication of the Oceananigans.jl Journal of Open Source Software (JOSS) paper. Changelog:; * Simplified boundary condition interface, types, and constructors. (@glwagner do you want add to this, maybe include a list of breaking changes?); * Support for a `NonTraditionalBetaPlane` Coriolis force implementation.; * The `AnisotropicBiharmonicDiffusivity` closure now works properly in closed domains with zero `Flux` boundary conditions, as higher-order boundary conditions are enforced.; * Bug fix: Appending to NetCDF files with `NetCDFOutputWriter` works now.; * Bug fix: Computations of abstract operations compute the right end point of face-centered fields along bounded dimensions.; * Bug fix: Averages `with_halos=false` return results with the correct dimensions for face-centered results along bounded dimensions.; * Small bug fixes for `show` methods. Breaking changes:; * When constructing a `NetCDFOutputWriter`, use `mode=""c""` instead of `clobber=true` and `mode=""a""` instead of `clobber=false`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/916
https://github.com/CliMA/Oceananigans.jl/pull/916:365,Usability,Simpl,Simplified,365,"OK so looks like this will have to be the JOSS release and include the JOSS paper in the repository (#564). I'd also like to include PRs #910 and #915 in this release. @glwagner Do you want to include any PRs in v0.36.0?. Release notes:. This release coincides with the publication of the Oceananigans.jl Journal of Open Source Software (JOSS) paper. Changelog:; * Simplified boundary condition interface, types, and constructors. (@glwagner do you want add to this, maybe include a list of breaking changes?); * Support for a `NonTraditionalBetaPlane` Coriolis force implementation.; * The `AnisotropicBiharmonicDiffusivity` closure now works properly in closed domains with zero `Flux` boundary conditions, as higher-order boundary conditions are enforced.; * Bug fix: Appending to NetCDF files with `NetCDFOutputWriter` works now.; * Bug fix: Computations of abstract operations compute the right end point of face-centered fields along bounded dimensions.; * Bug fix: Averages `with_halos=false` return results with the correct dimensions for face-centered results along bounded dimensions.; * Small bug fixes for `show` methods. Breaking changes:; * When constructing a `NetCDFOutputWriter`, use `mode=""c""` instead of `clobber=true` and `mode=""a""` instead of `clobber=false`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/916
https://github.com/CliMA/Oceananigans.jl/issues/918:299,Testability,log,logic,299,"Ah sorry I accidently merged yesterday without addressing this point. Dellar (2011) and other literature I've read commonly use f and f̃ (`\tilde{f}`) to refer to `fz` and `fy`, although I think `fz` and `fy` is clearer and we did decide to switch to `fz` and `fy` at some point. Following the same logic, `βz` and `βy` would be both consistent and clearer. _Originally posted by @ali-ramadhan in https://github.com/CliMA/Oceananigans.jl/pull/899#discussion_r483949249_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/918
https://github.com/CliMA/Oceananigans.jl/issues/918:212,Usability,clear,clearer,212,"Ah sorry I accidently merged yesterday without addressing this point. Dellar (2011) and other literature I've read commonly use f and f̃ (`\tilde{f}`) to refer to `fz` and `fy`, although I think `fz` and `fy` is clearer and we did decide to switch to `fz` and `fy` at some point. Following the same logic, `βz` and `βy` would be both consistent and clearer. _Originally posted by @ali-ramadhan in https://github.com/CliMA/Oceananigans.jl/pull/899#discussion_r483949249_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/918
https://github.com/CliMA/Oceananigans.jl/issues/918:349,Usability,clear,clearer,349,"Ah sorry I accidently merged yesterday without addressing this point. Dellar (2011) and other literature I've read commonly use f and f̃ (`\tilde{f}`) to refer to `fz` and `fy`, although I think `fz` and `fy` is clearer and we did decide to switch to `fz` and `fy` at some point. Following the same logic, `βz` and `βy` would be both consistent and clearer. _Originally posted by @ali-ramadhan in https://github.com/CliMA/Oceananigans.jl/pull/899#discussion_r483949249_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/918
https://github.com/CliMA/Oceananigans.jl/issues/919:118,Integrability,interface,interfaces,118,The right boundaries are _misidentified_ as halo regions and zeroed out when the field in question is located at cell interfaces along a `Bounded` direction:. https://github.com/CliMA/Oceananigans.jl/blob/01b248145356586f921239701b14c2f0e2073b27/src/BoundaryConditions/zero_halo_regions.jl#L24-L26,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/919
https://github.com/CliMA/Oceananigans.jl/pull/920:93,Energy Efficiency,Reduce,ReducedField,93,"This PR adds an `AbstractReducedField` that subtypes `AbstractField`, as well as a concrete `ReducedField` that is the analogue of `Field`. Reduced dimensions are tagged as having `Nothing` locations, and three-dimensional indexing into reduced fields is managed. This PR also reorganizes the `Fields` submodule in light of the generalization of the concept of an `AbstractField`. Resolves #525",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/920
https://github.com/CliMA/Oceananigans.jl/pull/920:140,Energy Efficiency,Reduce,Reduced,140,"This PR adds an `AbstractReducedField` that subtypes `AbstractField`, as well as a concrete `ReducedField` that is the analogue of `Field`. Reduced dimensions are tagged as having `Nothing` locations, and three-dimensional indexing into reduced fields is managed. This PR also reorganizes the `Fields` submodule in light of the generalization of the concept of an `AbstractField`. Resolves #525",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/920
https://github.com/CliMA/Oceananigans.jl/pull/920:237,Energy Efficiency,reduce,reduced,237,"This PR adds an `AbstractReducedField` that subtypes `AbstractField`, as well as a concrete `ReducedField` that is the analogue of `Field`. Reduced dimensions are tagged as having `Nothing` locations, and three-dimensional indexing into reduced fields is managed. This PR also reorganizes the `Fields` submodule in light of the generalization of the concept of an `AbstractField`. Resolves #525",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/920
https://github.com/CliMA/Oceananigans.jl/pull/924:177,Testability,test,tested,177,"This pull request changes the compat entry for the `KernelAbstractions` package from `^0.3` to `^0.3, 0.4`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/924
https://github.com/CliMA/Oceananigans.jl/pull/924:282,Testability,test,tests,282,"This pull request changes the compat entry for the `KernelAbstractions` package from `^0.3` to `^0.3, 0.4`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/924
https://github.com/CliMA/Oceananigans.jl/issues/925:30,Testability,test,tested,30,Is the fourth-order advection tested?; https://github.com/CliMA/Oceananigans.jl/blob/master/src/Advection/centered_fourth_order.jl. I tried using it in an example I'm drafting and code blew up. With the same time-step but the default advection scheme everything seemed fine... That doesn't necessarily mean that there is a problem but I was a bit alarmed I must say..,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/925
https://github.com/CliMA/Oceananigans.jl/pull/930:516,Energy Efficiency,reduce,reduced,516,"This PR introduces an `AveragedField` type. The intent is that this field will eventually replace `Average`. Before that occurs, we need to overhaul both output writers, but especially the NetCDFOutputWriter, so that they can properly slice all types of fields. An `AveragedField` is constructed with the syntax (for example). ```julia; avg = AveragedField(operand; dims=(1, 2)); ```. where `operand` is the object being averaged (which should also be a field), and `dims` are the dimensions over which the field is reduced. There is an optional argument `data` which would be an `OffsetArray` of the correct size which avoids extra memory allocation. We also overload `Statistics.mean`, so that the above code can be written. ```julia; avg = mean(operand; dims=(1, 2)); ```. When we have `ComputedField`s, `operand` can involve `AbstractOperations`. This will come in a future PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/930
https://github.com/CliMA/Oceananigans.jl/pull/930:620,Safety,avoid,avoids,620,"This PR introduces an `AveragedField` type. The intent is that this field will eventually replace `Average`. Before that occurs, we need to overhaul both output writers, but especially the NetCDFOutputWriter, so that they can properly slice all types of fields. An `AveragedField` is constructed with the syntax (for example). ```julia; avg = AveragedField(operand; dims=(1, 2)); ```. where `operand` is the object being averaged (which should also be a field), and `dims` are the dimensions over which the field is reduced. There is an optional argument `data` which would be an `OffsetArray` of the correct size which avoids extra memory allocation. We also overload `Statistics.mean`, so that the above code can be written. ```julia; avg = mean(operand; dims=(1, 2)); ```. When we have `ComputedField`s, `operand` can involve `AbstractOperations`. This will come in a future PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/930
https://github.com/CliMA/Oceananigans.jl/pull/931:761,Integrability,depend,depend,761,"This PR implements `ComputedField`. The concept is that the results of applying an abstract operation should be stored in a field-like object, since it has a location. This PR, along with #930, tidies up the way that abstract operations are computed and stored, how averages of fields are computed and stored, and how averages of abstract operations are handled. A key new function is `AveragedField(op::AbstractOperation; kwargs...)`, which first creates a `ComputedField`, and then returns an average over that `ComputedField`. Another key feature is that `compute!(comp::ComputedField` calls `compute!(comp.operand)`. In addition, `compute!(op::AbstractOperation)` is defined for all abstract operations. This means that abstract operations which themselves depend on either `ComputedField`s or `AveragedField`s can be computed correctly. In the future, however, some optimization is warranted to avoid ""recomputing"" certain fields. Once both the `JLD2OutputWriter` and the `NetCDFOutputWriter` have full support for all types of `AbstractField`, we can nuke both `Average` and `Computation` from the source and move to this new interface.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/931
https://github.com/CliMA/Oceananigans.jl/pull/931:1132,Integrability,interface,interface,1132,"This PR implements `ComputedField`. The concept is that the results of applying an abstract operation should be stored in a field-like object, since it has a location. This PR, along with #930, tidies up the way that abstract operations are computed and stored, how averages of fields are computed and stored, and how averages of abstract operations are handled. A key new function is `AveragedField(op::AbstractOperation; kwargs...)`, which first creates a `ComputedField`, and then returns an average over that `ComputedField`. Another key feature is that `compute!(comp::ComputedField` calls `compute!(comp.operand)`. In addition, `compute!(op::AbstractOperation)` is defined for all abstract operations. This means that abstract operations which themselves depend on either `ComputedField`s or `AveragedField`s can be computed correctly. In the future, however, some optimization is warranted to avoid ""recomputing"" certain fields. Once both the `JLD2OutputWriter` and the `NetCDFOutputWriter` have full support for all types of `AbstractField`, we can nuke both `Average` and `Computation` from the source and move to this new interface.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/931
https://github.com/CliMA/Oceananigans.jl/pull/931:871,Performance,optimiz,optimization,871,"This PR implements `ComputedField`. The concept is that the results of applying an abstract operation should be stored in a field-like object, since it has a location. This PR, along with #930, tidies up the way that abstract operations are computed and stored, how averages of fields are computed and stored, and how averages of abstract operations are handled. A key new function is `AveragedField(op::AbstractOperation; kwargs...)`, which first creates a `ComputedField`, and then returns an average over that `ComputedField`. Another key feature is that `compute!(comp::ComputedField` calls `compute!(comp.operand)`. In addition, `compute!(op::AbstractOperation)` is defined for all abstract operations. This means that abstract operations which themselves depend on either `ComputedField`s or `AveragedField`s can be computed correctly. In the future, however, some optimization is warranted to avoid ""recomputing"" certain fields. Once both the `JLD2OutputWriter` and the `NetCDFOutputWriter` have full support for all types of `AbstractField`, we can nuke both `Average` and `Computation` from the source and move to this new interface.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/931
https://github.com/CliMA/Oceananigans.jl/pull/931:900,Safety,avoid,avoid,900,"This PR implements `ComputedField`. The concept is that the results of applying an abstract operation should be stored in a field-like object, since it has a location. This PR, along with #930, tidies up the way that abstract operations are computed and stored, how averages of fields are computed and stored, and how averages of abstract operations are handled. A key new function is `AveragedField(op::AbstractOperation; kwargs...)`, which first creates a `ComputedField`, and then returns an average over that `ComputedField`. Another key feature is that `compute!(comp::ComputedField` calls `compute!(comp.operand)`. In addition, `compute!(op::AbstractOperation)` is defined for all abstract operations. This means that abstract operations which themselves depend on either `ComputedField`s or `AveragedField`s can be computed correctly. In the future, however, some optimization is warranted to avoid ""recomputing"" certain fields. Once both the `JLD2OutputWriter` and the `NetCDFOutputWriter` have full support for all types of `AbstractField`, we can nuke both `Average` and `Computation` from the source and move to this new interface.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/931
https://github.com/CliMA/Oceananigans.jl/pull/932:220,Deployability,integrat,integration,220,"This PR adds a `FieldSlicer` that slices fields on indices prior to output. This PR is a work in progress because we at least need unit tests:. - [x] add unit tests for `FieldSlicer`. It probably also make sense to test integration with both `JLD2OutputWriter` and `WindowedTimeAverage`:. - [x] add tests for integration with `JLD2OutputWriter` and `WindowedTimeAverage`. In the future, we would like to permit slicing at physical locations (rather than indices). This can be accomodated in the constructor for `FieldSlicer` in various ways (outside the scope of this PR). We would also like the ability to interpolate to locations. For this we want something like `InterpolatingFieldSlicer`. Comments and suggestions for the API are welcome.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/932
https://github.com/CliMA/Oceananigans.jl/pull/932:309,Deployability,integrat,integration,309,"This PR adds a `FieldSlicer` that slices fields on indices prior to output. This PR is a work in progress because we at least need unit tests:. - [x] add unit tests for `FieldSlicer`. It probably also make sense to test integration with both `JLD2OutputWriter` and `WindowedTimeAverage`:. - [x] add tests for integration with `JLD2OutputWriter` and `WindowedTimeAverage`. In the future, we would like to permit slicing at physical locations (rather than indices). This can be accomodated in the constructor for `FieldSlicer` in various ways (outside the scope of this PR). We would also like the ability to interpolate to locations. For this we want something like `InterpolatingFieldSlicer`. Comments and suggestions for the API are welcome.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/932
https://github.com/CliMA/Oceananigans.jl/pull/932:220,Integrability,integrat,integration,220,"This PR adds a `FieldSlicer` that slices fields on indices prior to output. This PR is a work in progress because we at least need unit tests:. - [x] add unit tests for `FieldSlicer`. It probably also make sense to test integration with both `JLD2OutputWriter` and `WindowedTimeAverage`:. - [x] add tests for integration with `JLD2OutputWriter` and `WindowedTimeAverage`. In the future, we would like to permit slicing at physical locations (rather than indices). This can be accomodated in the constructor for `FieldSlicer` in various ways (outside the scope of this PR). We would also like the ability to interpolate to locations. For this we want something like `InterpolatingFieldSlicer`. Comments and suggestions for the API are welcome.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/932
https://github.com/CliMA/Oceananigans.jl/pull/932:309,Integrability,integrat,integration,309,"This PR adds a `FieldSlicer` that slices fields on indices prior to output. This PR is a work in progress because we at least need unit tests:. - [x] add unit tests for `FieldSlicer`. It probably also make sense to test integration with both `JLD2OutputWriter` and `WindowedTimeAverage`:. - [x] add tests for integration with `JLD2OutputWriter` and `WindowedTimeAverage`. In the future, we would like to permit slicing at physical locations (rather than indices). This can be accomodated in the constructor for `FieldSlicer` in various ways (outside the scope of this PR). We would also like the ability to interpolate to locations. For this we want something like `InterpolatingFieldSlicer`. Comments and suggestions for the API are welcome.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/932
https://github.com/CliMA/Oceananigans.jl/pull/932:136,Testability,test,tests,136,"This PR adds a `FieldSlicer` that slices fields on indices prior to output. This PR is a work in progress because we at least need unit tests:. - [x] add unit tests for `FieldSlicer`. It probably also make sense to test integration with both `JLD2OutputWriter` and `WindowedTimeAverage`:. - [x] add tests for integration with `JLD2OutputWriter` and `WindowedTimeAverage`. In the future, we would like to permit slicing at physical locations (rather than indices). This can be accomodated in the constructor for `FieldSlicer` in various ways (outside the scope of this PR). We would also like the ability to interpolate to locations. For this we want something like `InterpolatingFieldSlicer`. Comments and suggestions for the API are welcome.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/932
https://github.com/CliMA/Oceananigans.jl/pull/932:159,Testability,test,tests,159,"This PR adds a `FieldSlicer` that slices fields on indices prior to output. This PR is a work in progress because we at least need unit tests:. - [x] add unit tests for `FieldSlicer`. It probably also make sense to test integration with both `JLD2OutputWriter` and `WindowedTimeAverage`:. - [x] add tests for integration with `JLD2OutputWriter` and `WindowedTimeAverage`. In the future, we would like to permit slicing at physical locations (rather than indices). This can be accomodated in the constructor for `FieldSlicer` in various ways (outside the scope of this PR). We would also like the ability to interpolate to locations. For this we want something like `InterpolatingFieldSlicer`. Comments and suggestions for the API are welcome.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/932
https://github.com/CliMA/Oceananigans.jl/pull/932:215,Testability,test,test,215,"This PR adds a `FieldSlicer` that slices fields on indices prior to output. This PR is a work in progress because we at least need unit tests:. - [x] add unit tests for `FieldSlicer`. It probably also make sense to test integration with both `JLD2OutputWriter` and `WindowedTimeAverage`:. - [x] add tests for integration with `JLD2OutputWriter` and `WindowedTimeAverage`. In the future, we would like to permit slicing at physical locations (rather than indices). This can be accomodated in the constructor for `FieldSlicer` in various ways (outside the scope of this PR). We would also like the ability to interpolate to locations. For this we want something like `InterpolatingFieldSlicer`. Comments and suggestions for the API are welcome.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/932
https://github.com/CliMA/Oceananigans.jl/pull/932:299,Testability,test,tests,299,"This PR adds a `FieldSlicer` that slices fields on indices prior to output. This PR is a work in progress because we at least need unit tests:. - [x] add unit tests for `FieldSlicer`. It probably also make sense to test integration with both `JLD2OutputWriter` and `WindowedTimeAverage`:. - [x] add tests for integration with `JLD2OutputWriter` and `WindowedTimeAverage`. In the future, we would like to permit slicing at physical locations (rather than indices). This can be accomodated in the constructor for `FieldSlicer` in various ways (outside the scope of this PR). We would also like the ability to interpolate to locations. For this we want something like `InterpolatingFieldSlicer`. Comments and suggestions for the API are welcome.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/932
https://github.com/CliMA/Oceananigans.jl/pull/936:169,Deployability,Integrat,Integration,169,"This PR adds third-order advection schemes, plus convergence tests for advection schemes. To do:. - [ ] Finish writing third-order momentum advection operators; ~~- [ ] Integration tests for time-stepping with different advection schemes~~; ~~- [ ] Generalize validation experiments to test third-order and fourth-order advection~~. Minor:. Should we call it `UpwindThirdOrder` or `UpwindBiasedThirdOrder` ?. As a side note, we eventually need to generalize advection schemes so that a different scheme can be applied to momentum and tracers, and possibly even to every tracer individually. This is not difficult since we have a similar pattern implemented for turbulence closures.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/936
https://github.com/CliMA/Oceananigans.jl/pull/936:169,Integrability,Integrat,Integration,169,"This PR adds third-order advection schemes, plus convergence tests for advection schemes. To do:. - [ ] Finish writing third-order momentum advection operators; ~~- [ ] Integration tests for time-stepping with different advection schemes~~; ~~- [ ] Generalize validation experiments to test third-order and fourth-order advection~~. Minor:. Should we call it `UpwindThirdOrder` or `UpwindBiasedThirdOrder` ?. As a side note, we eventually need to generalize advection schemes so that a different scheme can be applied to momentum and tracers, and possibly even to every tracer individually. This is not difficult since we have a similar pattern implemented for turbulence closures.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/936
https://github.com/CliMA/Oceananigans.jl/pull/936:260,Security,validat,validation,260,"This PR adds third-order advection schemes, plus convergence tests for advection schemes. To do:. - [ ] Finish writing third-order momentum advection operators; ~~- [ ] Integration tests for time-stepping with different advection schemes~~; ~~- [ ] Generalize validation experiments to test third-order and fourth-order advection~~. Minor:. Should we call it `UpwindThirdOrder` or `UpwindBiasedThirdOrder` ?. As a side note, we eventually need to generalize advection schemes so that a different scheme can be applied to momentum and tracers, and possibly even to every tracer individually. This is not difficult since we have a similar pattern implemented for turbulence closures.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/936
https://github.com/CliMA/Oceananigans.jl/pull/936:61,Testability,test,tests,61,"This PR adds third-order advection schemes, plus convergence tests for advection schemes. To do:. - [ ] Finish writing third-order momentum advection operators; ~~- [ ] Integration tests for time-stepping with different advection schemes~~; ~~- [ ] Generalize validation experiments to test third-order and fourth-order advection~~. Minor:. Should we call it `UpwindThirdOrder` or `UpwindBiasedThirdOrder` ?. As a side note, we eventually need to generalize advection schemes so that a different scheme can be applied to momentum and tracers, and possibly even to every tracer individually. This is not difficult since we have a similar pattern implemented for turbulence closures.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/936
https://github.com/CliMA/Oceananigans.jl/pull/936:181,Testability,test,tests,181,"This PR adds third-order advection schemes, plus convergence tests for advection schemes. To do:. - [ ] Finish writing third-order momentum advection operators; ~~- [ ] Integration tests for time-stepping with different advection schemes~~; ~~- [ ] Generalize validation experiments to test third-order and fourth-order advection~~. Minor:. Should we call it `UpwindThirdOrder` or `UpwindBiasedThirdOrder` ?. As a side note, we eventually need to generalize advection schemes so that a different scheme can be applied to momentum and tracers, and possibly even to every tracer individually. This is not difficult since we have a similar pattern implemented for turbulence closures.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/936
https://github.com/CliMA/Oceananigans.jl/pull/936:286,Testability,test,test,286,"This PR adds third-order advection schemes, plus convergence tests for advection schemes. To do:. - [ ] Finish writing third-order momentum advection operators; ~~- [ ] Integration tests for time-stepping with different advection schemes~~; ~~- [ ] Generalize validation experiments to test third-order and fourth-order advection~~. Minor:. Should we call it `UpwindThirdOrder` or `UpwindBiasedThirdOrder` ?. As a side note, we eventually need to generalize advection schemes so that a different scheme can be applied to momentum and tracers, and possibly even to every tracer individually. This is not difficult since we have a similar pattern implemented for turbulence closures.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/936
https://github.com/CliMA/Oceananigans.jl/pull/937:131,Availability,error,error,131,"Many models of size (16, 16, 16) are reduced to size (1, 1, 1). Oftentimes the test just executes a time-step to ensure there's no error. For this, a size (1, 1, 1) is sufficient.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/937
https://github.com/CliMA/Oceananigans.jl/pull/937:37,Energy Efficiency,reduce,reduced,37,"Many models of size (16, 16, 16) are reduced to size (1, 1, 1). Oftentimes the test just executes a time-step to ensure there's no error. For this, a size (1, 1, 1) is sufficient.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/937
https://github.com/CliMA/Oceananigans.jl/pull/937:79,Testability,test,test,79,"Many models of size (16, 16, 16) are reduced to size (1, 1, 1). Oftentimes the test just executes a time-step to ensure there's no error. For this, a size (1, 1, 1) is sufficient.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/937
https://github.com/CliMA/Oceananigans.jl/issues/939:304,Availability,ERROR,ERROR,304,"`closure = nothing` is effectively the same thing as `closure = IsotropicDiffusivity(ν=0, κ=0)` so maybe this issue isn't worth thinking about. ```julia; using Oceananigans; grid = RegularCartesianGrid(size=(4, 4, 4), extent=(1, 1, 1)); model = IncompressibleModel(grid=grid, closure=nothing); ```. ```; ERROR: MethodError: no method matching with_tracers(::Tuple{Symbol,Symbol}, ::Nothing); Closest candidates are:; with_tracers(::Any, ::NamedTuple, ::Any; with_velocities) at /home/alir/Oceananigans.jl/src/Utils/with_tracers.jl:10; with_tracers(::Any, ::Tuple) at /home/alir/Oceananigans.jl/src/TurbulenceClosures/TurbulenceClosures.jl:150; with_tracers(::Any, ::IsotropicDiffusivity) at /home/alir/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/isotropic_diffusivity.jl:38; ...; Stacktrace:; [1] IncompressibleModel(; grid::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, architecture::CPU, float_type::Type{T} where T, clock::Clock{Float64}, advection::Oceananigans.Advection.CenteredSecondOrder, buoyancy::SeawaterBuoyancy{Float64,LinearEquationOfState{Float64},Nothing,Nothing}, coriolis::Nothing, surface_waves::Nothing, forcing::NamedTuple{(:u, :v, :w),Tuple{typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}}, closure::Nothing, boundary_conditions::NamedTuple{(:u, :v, :w),Tuple{NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}},NamedTuple{(:x, :y, :z),Tupl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/939
https://github.com/CliMA/Oceananigans.jl/issues/941:40,Availability,error,error,40,Model constructor could emit a warning (error would be more suitable). Could re-create the grid but maybe that's not as good as getting the user to specify the right halo size. New users shouldn't have to interact with halos and getting `NaN`s because you didn't know to change the halo size can be frustrating.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/941
https://github.com/CliMA/Oceananigans.jl/issues/942:326,Availability,toler,tolerance,326,"In `test_dynamics.jl` we test budgets for tracers and momentum variables:. https://github.com/CliMA/Oceananigans.jl/blob/0807552c94b87ec009564bf228ab85517e31dde0/test/test_dynamics.jl#L25-L41. However, the test is imperfect because 1) it does not test velocity components in non-periodic directions and 2) it uses a too-loose tolerance. ~~We can improve this test by tapering the initial condition for the field in question to zero for velocity fields in bounded directions.~~. EDIT: a little thought goes a long way: in `Bounded` directions, momentum is not conserved in general unless pressure at the boundaries is zero. Perhaps we should be happy just to test momentum conservation in periodic directions. This is still an important test that ensures the no flux condition is correctly implemented. Also, we can make the tolerance more strict. Finally, once this test works well, we can get rid of the `tracer_conserved_in_channel` test in `test_time_stepping.jl`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/942
https://github.com/CliMA/Oceananigans.jl/issues/942:824,Availability,toler,tolerance,824,"In `test_dynamics.jl` we test budgets for tracers and momentum variables:. https://github.com/CliMA/Oceananigans.jl/blob/0807552c94b87ec009564bf228ab85517e31dde0/test/test_dynamics.jl#L25-L41. However, the test is imperfect because 1) it does not test velocity components in non-periodic directions and 2) it uses a too-loose tolerance. ~~We can improve this test by tapering the initial condition for the field in question to zero for velocity fields in bounded directions.~~. EDIT: a little thought goes a long way: in `Bounded` directions, momentum is not conserved in general unless pressure at the boundaries is zero. Perhaps we should be happy just to test momentum conservation in periodic directions. This is still an important test that ensures the no flux condition is correctly implemented. Also, we can make the tolerance more strict. Finally, once this test works well, we can get rid of the `tracer_conserved_in_channel` test in `test_time_stepping.jl`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/942
https://github.com/CliMA/Oceananigans.jl/issues/942:63,Modifiability,variab,variables,63,"In `test_dynamics.jl` we test budgets for tracers and momentum variables:. https://github.com/CliMA/Oceananigans.jl/blob/0807552c94b87ec009564bf228ab85517e31dde0/test/test_dynamics.jl#L25-L41. However, the test is imperfect because 1) it does not test velocity components in non-periodic directions and 2) it uses a too-loose tolerance. ~~We can improve this test by tapering the initial condition for the field in question to zero for velocity fields in bounded directions.~~. EDIT: a little thought goes a long way: in `Bounded` directions, momentum is not conserved in general unless pressure at the boundaries is zero. Perhaps we should be happy just to test momentum conservation in periodic directions. This is still an important test that ensures the no flux condition is correctly implemented. Also, we can make the tolerance more strict. Finally, once this test works well, we can get rid of the `tracer_conserved_in_channel` test in `test_time_stepping.jl`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/942
https://github.com/CliMA/Oceananigans.jl/issues/942:25,Testability,test,test,25,"In `test_dynamics.jl` we test budgets for tracers and momentum variables:. https://github.com/CliMA/Oceananigans.jl/blob/0807552c94b87ec009564bf228ab85517e31dde0/test/test_dynamics.jl#L25-L41. However, the test is imperfect because 1) it does not test velocity components in non-periodic directions and 2) it uses a too-loose tolerance. ~~We can improve this test by tapering the initial condition for the field in question to zero for velocity fields in bounded directions.~~. EDIT: a little thought goes a long way: in `Bounded` directions, momentum is not conserved in general unless pressure at the boundaries is zero. Perhaps we should be happy just to test momentum conservation in periodic directions. This is still an important test that ensures the no flux condition is correctly implemented. Also, we can make the tolerance more strict. Finally, once this test works well, we can get rid of the `tracer_conserved_in_channel` test in `test_time_stepping.jl`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/942
https://github.com/CliMA/Oceananigans.jl/issues/942:162,Testability,test,test,162,"In `test_dynamics.jl` we test budgets for tracers and momentum variables:. https://github.com/CliMA/Oceananigans.jl/blob/0807552c94b87ec009564bf228ab85517e31dde0/test/test_dynamics.jl#L25-L41. However, the test is imperfect because 1) it does not test velocity components in non-periodic directions and 2) it uses a too-loose tolerance. ~~We can improve this test by tapering the initial condition for the field in question to zero for velocity fields in bounded directions.~~. EDIT: a little thought goes a long way: in `Bounded` directions, momentum is not conserved in general unless pressure at the boundaries is zero. Perhaps we should be happy just to test momentum conservation in periodic directions. This is still an important test that ensures the no flux condition is correctly implemented. Also, we can make the tolerance more strict. Finally, once this test works well, we can get rid of the `tracer_conserved_in_channel` test in `test_time_stepping.jl`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/942
https://github.com/CliMA/Oceananigans.jl/issues/942:206,Testability,test,test,206,"In `test_dynamics.jl` we test budgets for tracers and momentum variables:. https://github.com/CliMA/Oceananigans.jl/blob/0807552c94b87ec009564bf228ab85517e31dde0/test/test_dynamics.jl#L25-L41. However, the test is imperfect because 1) it does not test velocity components in non-periodic directions and 2) it uses a too-loose tolerance. ~~We can improve this test by tapering the initial condition for the field in question to zero for velocity fields in bounded directions.~~. EDIT: a little thought goes a long way: in `Bounded` directions, momentum is not conserved in general unless pressure at the boundaries is zero. Perhaps we should be happy just to test momentum conservation in periodic directions. This is still an important test that ensures the no flux condition is correctly implemented. Also, we can make the tolerance more strict. Finally, once this test works well, we can get rid of the `tracer_conserved_in_channel` test in `test_time_stepping.jl`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/942
https://github.com/CliMA/Oceananigans.jl/issues/942:247,Testability,test,test,247,"In `test_dynamics.jl` we test budgets for tracers and momentum variables:. https://github.com/CliMA/Oceananigans.jl/blob/0807552c94b87ec009564bf228ab85517e31dde0/test/test_dynamics.jl#L25-L41. However, the test is imperfect because 1) it does not test velocity components in non-periodic directions and 2) it uses a too-loose tolerance. ~~We can improve this test by tapering the initial condition for the field in question to zero for velocity fields in bounded directions.~~. EDIT: a little thought goes a long way: in `Bounded` directions, momentum is not conserved in general unless pressure at the boundaries is zero. Perhaps we should be happy just to test momentum conservation in periodic directions. This is still an important test that ensures the no flux condition is correctly implemented. Also, we can make the tolerance more strict. Finally, once this test works well, we can get rid of the `tracer_conserved_in_channel` test in `test_time_stepping.jl`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/942
https://github.com/CliMA/Oceananigans.jl/issues/942:359,Testability,test,test,359,"In `test_dynamics.jl` we test budgets for tracers and momentum variables:. https://github.com/CliMA/Oceananigans.jl/blob/0807552c94b87ec009564bf228ab85517e31dde0/test/test_dynamics.jl#L25-L41. However, the test is imperfect because 1) it does not test velocity components in non-periodic directions and 2) it uses a too-loose tolerance. ~~We can improve this test by tapering the initial condition for the field in question to zero for velocity fields in bounded directions.~~. EDIT: a little thought goes a long way: in `Bounded` directions, momentum is not conserved in general unless pressure at the boundaries is zero. Perhaps we should be happy just to test momentum conservation in periodic directions. This is still an important test that ensures the no flux condition is correctly implemented. Also, we can make the tolerance more strict. Finally, once this test works well, we can get rid of the `tracer_conserved_in_channel` test in `test_time_stepping.jl`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/942
https://github.com/CliMA/Oceananigans.jl/issues/942:658,Testability,test,test,658,"In `test_dynamics.jl` we test budgets for tracers and momentum variables:. https://github.com/CliMA/Oceananigans.jl/blob/0807552c94b87ec009564bf228ab85517e31dde0/test/test_dynamics.jl#L25-L41. However, the test is imperfect because 1) it does not test velocity components in non-periodic directions and 2) it uses a too-loose tolerance. ~~We can improve this test by tapering the initial condition for the field in question to zero for velocity fields in bounded directions.~~. EDIT: a little thought goes a long way: in `Bounded` directions, momentum is not conserved in general unless pressure at the boundaries is zero. Perhaps we should be happy just to test momentum conservation in periodic directions. This is still an important test that ensures the no flux condition is correctly implemented. Also, we can make the tolerance more strict. Finally, once this test works well, we can get rid of the `tracer_conserved_in_channel` test in `test_time_stepping.jl`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/942
https://github.com/CliMA/Oceananigans.jl/issues/942:736,Testability,test,test,736,"In `test_dynamics.jl` we test budgets for tracers and momentum variables:. https://github.com/CliMA/Oceananigans.jl/blob/0807552c94b87ec009564bf228ab85517e31dde0/test/test_dynamics.jl#L25-L41. However, the test is imperfect because 1) it does not test velocity components in non-periodic directions and 2) it uses a too-loose tolerance. ~~We can improve this test by tapering the initial condition for the field in question to zero for velocity fields in bounded directions.~~. EDIT: a little thought goes a long way: in `Bounded` directions, momentum is not conserved in general unless pressure at the boundaries is zero. Perhaps we should be happy just to test momentum conservation in periodic directions. This is still an important test that ensures the no flux condition is correctly implemented. Also, we can make the tolerance more strict. Finally, once this test works well, we can get rid of the `tracer_conserved_in_channel` test in `test_time_stepping.jl`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/942
https://github.com/CliMA/Oceananigans.jl/issues/942:866,Testability,test,test,866,"In `test_dynamics.jl` we test budgets for tracers and momentum variables:. https://github.com/CliMA/Oceananigans.jl/blob/0807552c94b87ec009564bf228ab85517e31dde0/test/test_dynamics.jl#L25-L41. However, the test is imperfect because 1) it does not test velocity components in non-periodic directions and 2) it uses a too-loose tolerance. ~~We can improve this test by tapering the initial condition for the field in question to zero for velocity fields in bounded directions.~~. EDIT: a little thought goes a long way: in `Bounded` directions, momentum is not conserved in general unless pressure at the boundaries is zero. Perhaps we should be happy just to test momentum conservation in periodic directions. This is still an important test that ensures the no flux condition is correctly implemented. Also, we can make the tolerance more strict. Finally, once this test works well, we can get rid of the `tracer_conserved_in_channel` test in `test_time_stepping.jl`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/942
https://github.com/CliMA/Oceananigans.jl/issues/942:935,Testability,test,test,935,"In `test_dynamics.jl` we test budgets for tracers and momentum variables:. https://github.com/CliMA/Oceananigans.jl/blob/0807552c94b87ec009564bf228ab85517e31dde0/test/test_dynamics.jl#L25-L41. However, the test is imperfect because 1) it does not test velocity components in non-periodic directions and 2) it uses a too-loose tolerance. ~~We can improve this test by tapering the initial condition for the field in question to zero for velocity fields in bounded directions.~~. EDIT: a little thought goes a long way: in `Bounded` directions, momentum is not conserved in general unless pressure at the boundaries is zero. Perhaps we should be happy just to test momentum conservation in periodic directions. This is still an important test that ensures the no flux condition is correctly implemented. Also, we can make the tolerance more strict. Finally, once this test works well, we can get rid of the `tracer_conserved_in_channel` test in `test_time_stepping.jl`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/942
https://github.com/CliMA/Oceananigans.jl/pull/943:56,Testability,test,tests,56,"This PR regenerates data for the ""Ocean LES"" regression tests. It should be merged after #711.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/943
https://github.com/CliMA/Oceananigans.jl/pull/945:1049,Availability,checkpoint,checkpointing,1049,"This PR implements a third-order Runge-Kutta time stepping method. The implementation is based off [Le and Moin (1991)](https://www.sciencedirect.com/science/article/pii/0021999191902157). It should be noted, however, that we do not use an implicit method for diffusion, and that the pressure correction is calculated every substep. It could be possible in the future to implement the optimization described in Le and Moin (1991) that reduces the number of times the pressure Poisson equation needs to be solved each time-step from 3 to 1, though this would reduce the accuracy of the scheme from third to second-order. So far, this PR extends the dynamics tests and incompressibility test to `RungeKutta3TimeStepper`. It also extends the time stepper convergence test to the `RungeKutta3TimeStepper`. I am open to changing the name of the time stepper. It may also be a good idea to add basic documentation. The time stepper is used by setting the keyword `timestepper=:RungeKutta3` in the constructor for `IncompressibleModel`. ~~I am not sure if checkpointing will work with this timestepper.~~. Checkpointing will not work with this timestepper. A more generic checkpointer awaits a future PR. Resolves #506",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/945
https://github.com/CliMA/Oceananigans.jl/pull/945:1099,Availability,Checkpoint,Checkpointing,1099,"This PR implements a third-order Runge-Kutta time stepping method. The implementation is based off [Le and Moin (1991)](https://www.sciencedirect.com/science/article/pii/0021999191902157). It should be noted, however, that we do not use an implicit method for diffusion, and that the pressure correction is calculated every substep. It could be possible in the future to implement the optimization described in Le and Moin (1991) that reduces the number of times the pressure Poisson equation needs to be solved each time-step from 3 to 1, though this would reduce the accuracy of the scheme from third to second-order. So far, this PR extends the dynamics tests and incompressibility test to `RungeKutta3TimeStepper`. It also extends the time stepper convergence test to the `RungeKutta3TimeStepper`. I am open to changing the name of the time stepper. It may also be a good idea to add basic documentation. The time stepper is used by setting the keyword `timestepper=:RungeKutta3` in the constructor for `IncompressibleModel`. ~~I am not sure if checkpointing will work with this timestepper.~~. Checkpointing will not work with this timestepper. A more generic checkpointer awaits a future PR. Resolves #506",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/945
https://github.com/CliMA/Oceananigans.jl/pull/945:1165,Availability,checkpoint,checkpointer,1165,"This PR implements a third-order Runge-Kutta time stepping method. The implementation is based off [Le and Moin (1991)](https://www.sciencedirect.com/science/article/pii/0021999191902157). It should be noted, however, that we do not use an implicit method for diffusion, and that the pressure correction is calculated every substep. It could be possible in the future to implement the optimization described in Le and Moin (1991) that reduces the number of times the pressure Poisson equation needs to be solved each time-step from 3 to 1, though this would reduce the accuracy of the scheme from third to second-order. So far, this PR extends the dynamics tests and incompressibility test to `RungeKutta3TimeStepper`. It also extends the time stepper convergence test to the `RungeKutta3TimeStepper`. I am open to changing the name of the time stepper. It may also be a good idea to add basic documentation. The time stepper is used by setting the keyword `timestepper=:RungeKutta3` in the constructor for `IncompressibleModel`. ~~I am not sure if checkpointing will work with this timestepper.~~. Checkpointing will not work with this timestepper. A more generic checkpointer awaits a future PR. Resolves #506",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/945
https://github.com/CliMA/Oceananigans.jl/pull/945:435,Energy Efficiency,reduce,reduces,435,"This PR implements a third-order Runge-Kutta time stepping method. The implementation is based off [Le and Moin (1991)](https://www.sciencedirect.com/science/article/pii/0021999191902157). It should be noted, however, that we do not use an implicit method for diffusion, and that the pressure correction is calculated every substep. It could be possible in the future to implement the optimization described in Le and Moin (1991) that reduces the number of times the pressure Poisson equation needs to be solved each time-step from 3 to 1, though this would reduce the accuracy of the scheme from third to second-order. So far, this PR extends the dynamics tests and incompressibility test to `RungeKutta3TimeStepper`. It also extends the time stepper convergence test to the `RungeKutta3TimeStepper`. I am open to changing the name of the time stepper. It may also be a good idea to add basic documentation. The time stepper is used by setting the keyword `timestepper=:RungeKutta3` in the constructor for `IncompressibleModel`. ~~I am not sure if checkpointing will work with this timestepper.~~. Checkpointing will not work with this timestepper. A more generic checkpointer awaits a future PR. Resolves #506",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/945
https://github.com/CliMA/Oceananigans.jl/pull/945:558,Energy Efficiency,reduce,reduce,558,"This PR implements a third-order Runge-Kutta time stepping method. The implementation is based off [Le and Moin (1991)](https://www.sciencedirect.com/science/article/pii/0021999191902157). It should be noted, however, that we do not use an implicit method for diffusion, and that the pressure correction is calculated every substep. It could be possible in the future to implement the optimization described in Le and Moin (1991) that reduces the number of times the pressure Poisson equation needs to be solved each time-step from 3 to 1, though this would reduce the accuracy of the scheme from third to second-order. So far, this PR extends the dynamics tests and incompressibility test to `RungeKutta3TimeStepper`. It also extends the time stepper convergence test to the `RungeKutta3TimeStepper`. I am open to changing the name of the time stepper. It may also be a good idea to add basic documentation. The time stepper is used by setting the keyword `timestepper=:RungeKutta3` in the constructor for `IncompressibleModel`. ~~I am not sure if checkpointing will work with this timestepper.~~. Checkpointing will not work with this timestepper. A more generic checkpointer awaits a future PR. Resolves #506",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/945
https://github.com/CliMA/Oceananigans.jl/pull/945:636,Modifiability,extend,extends,636,"This PR implements a third-order Runge-Kutta time stepping method. The implementation is based off [Le and Moin (1991)](https://www.sciencedirect.com/science/article/pii/0021999191902157). It should be noted, however, that we do not use an implicit method for diffusion, and that the pressure correction is calculated every substep. It could be possible in the future to implement the optimization described in Le and Moin (1991) that reduces the number of times the pressure Poisson equation needs to be solved each time-step from 3 to 1, though this would reduce the accuracy of the scheme from third to second-order. So far, this PR extends the dynamics tests and incompressibility test to `RungeKutta3TimeStepper`. It also extends the time stepper convergence test to the `RungeKutta3TimeStepper`. I am open to changing the name of the time stepper. It may also be a good idea to add basic documentation. The time stepper is used by setting the keyword `timestepper=:RungeKutta3` in the constructor for `IncompressibleModel`. ~~I am not sure if checkpointing will work with this timestepper.~~. Checkpointing will not work with this timestepper. A more generic checkpointer awaits a future PR. Resolves #506",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/945
https://github.com/CliMA/Oceananigans.jl/pull/945:727,Modifiability,extend,extends,727,"This PR implements a third-order Runge-Kutta time stepping method. The implementation is based off [Le and Moin (1991)](https://www.sciencedirect.com/science/article/pii/0021999191902157). It should be noted, however, that we do not use an implicit method for diffusion, and that the pressure correction is calculated every substep. It could be possible in the future to implement the optimization described in Le and Moin (1991) that reduces the number of times the pressure Poisson equation needs to be solved each time-step from 3 to 1, though this would reduce the accuracy of the scheme from third to second-order. So far, this PR extends the dynamics tests and incompressibility test to `RungeKutta3TimeStepper`. It also extends the time stepper convergence test to the `RungeKutta3TimeStepper`. I am open to changing the name of the time stepper. It may also be a good idea to add basic documentation. The time stepper is used by setting the keyword `timestepper=:RungeKutta3` in the constructor for `IncompressibleModel`. ~~I am not sure if checkpointing will work with this timestepper.~~. Checkpointing will not work with this timestepper. A more generic checkpointer awaits a future PR. Resolves #506",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/945
https://github.com/CliMA/Oceananigans.jl/pull/945:385,Performance,optimiz,optimization,385,"This PR implements a third-order Runge-Kutta time stepping method. The implementation is based off [Le and Moin (1991)](https://www.sciencedirect.com/science/article/pii/0021999191902157). It should be noted, however, that we do not use an implicit method for diffusion, and that the pressure correction is calculated every substep. It could be possible in the future to implement the optimization described in Le and Moin (1991) that reduces the number of times the pressure Poisson equation needs to be solved each time-step from 3 to 1, though this would reduce the accuracy of the scheme from third to second-order. So far, this PR extends the dynamics tests and incompressibility test to `RungeKutta3TimeStepper`. It also extends the time stepper convergence test to the `RungeKutta3TimeStepper`. I am open to changing the name of the time stepper. It may also be a good idea to add basic documentation. The time stepper is used by setting the keyword `timestepper=:RungeKutta3` in the constructor for `IncompressibleModel`. ~~I am not sure if checkpointing will work with this timestepper.~~. Checkpointing will not work with this timestepper. A more generic checkpointer awaits a future PR. Resolves #506",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/945
https://github.com/CliMA/Oceananigans.jl/pull/945:657,Testability,test,tests,657,"This PR implements a third-order Runge-Kutta time stepping method. The implementation is based off [Le and Moin (1991)](https://www.sciencedirect.com/science/article/pii/0021999191902157). It should be noted, however, that we do not use an implicit method for diffusion, and that the pressure correction is calculated every substep. It could be possible in the future to implement the optimization described in Le and Moin (1991) that reduces the number of times the pressure Poisson equation needs to be solved each time-step from 3 to 1, though this would reduce the accuracy of the scheme from third to second-order. So far, this PR extends the dynamics tests and incompressibility test to `RungeKutta3TimeStepper`. It also extends the time stepper convergence test to the `RungeKutta3TimeStepper`. I am open to changing the name of the time stepper. It may also be a good idea to add basic documentation. The time stepper is used by setting the keyword `timestepper=:RungeKutta3` in the constructor for `IncompressibleModel`. ~~I am not sure if checkpointing will work with this timestepper.~~. Checkpointing will not work with this timestepper. A more generic checkpointer awaits a future PR. Resolves #506",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/945
https://github.com/CliMA/Oceananigans.jl/pull/945:685,Testability,test,test,685,"This PR implements a third-order Runge-Kutta time stepping method. The implementation is based off [Le and Moin (1991)](https://www.sciencedirect.com/science/article/pii/0021999191902157). It should be noted, however, that we do not use an implicit method for diffusion, and that the pressure correction is calculated every substep. It could be possible in the future to implement the optimization described in Le and Moin (1991) that reduces the number of times the pressure Poisson equation needs to be solved each time-step from 3 to 1, though this would reduce the accuracy of the scheme from third to second-order. So far, this PR extends the dynamics tests and incompressibility test to `RungeKutta3TimeStepper`. It also extends the time stepper convergence test to the `RungeKutta3TimeStepper`. I am open to changing the name of the time stepper. It may also be a good idea to add basic documentation. The time stepper is used by setting the keyword `timestepper=:RungeKutta3` in the constructor for `IncompressibleModel`. ~~I am not sure if checkpointing will work with this timestepper.~~. Checkpointing will not work with this timestepper. A more generic checkpointer awaits a future PR. Resolves #506",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/945
https://github.com/CliMA/Oceananigans.jl/pull/945:764,Testability,test,test,764,"This PR implements a third-order Runge-Kutta time stepping method. The implementation is based off [Le and Moin (1991)](https://www.sciencedirect.com/science/article/pii/0021999191902157). It should be noted, however, that we do not use an implicit method for diffusion, and that the pressure correction is calculated every substep. It could be possible in the future to implement the optimization described in Le and Moin (1991) that reduces the number of times the pressure Poisson equation needs to be solved each time-step from 3 to 1, though this would reduce the accuracy of the scheme from third to second-order. So far, this PR extends the dynamics tests and incompressibility test to `RungeKutta3TimeStepper`. It also extends the time stepper convergence test to the `RungeKutta3TimeStepper`. I am open to changing the name of the time stepper. It may also be a good idea to add basic documentation. The time stepper is used by setting the keyword `timestepper=:RungeKutta3` in the constructor for `IncompressibleModel`. ~~I am not sure if checkpointing will work with this timestepper.~~. Checkpointing will not work with this timestepper. A more generic checkpointer awaits a future PR. Resolves #506",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/945
https://github.com/CliMA/Oceananigans.jl/issues/946:217,Energy Efficiency,adapt,adaptive,217,"The docs include a ""Model setup"" section which includes references and info about `Simulation`. I think we should have a separate section on `Simulation`, which includes an explanation of diagnostics, output writers, adaptive timestepping, and `run!`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/946
https://github.com/CliMA/Oceananigans.jl/issues/946:217,Modifiability,adapt,adaptive,217,"The docs include a ""Model setup"" section which includes references and info about `Simulation`. I think we should have a separate section on `Simulation`, which includes an explanation of diagnostics, output writers, adaptive timestepping, and `run!`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/946
https://github.com/CliMA/Oceananigans.jl/pull/948:65,Availability,checkpoint,checkpoint,65,I think we should tag a v0.37.0 release to ensure we have a code checkpoint before which we were recomputing w and after which we were not (since it's a change to the numerical methods). Might be good if we do this before merging in RK3.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/948
https://github.com/CliMA/Oceananigans.jl/pull/948:32,Deployability,release,release,32,I think we should tag a v0.37.0 release to ensure we have a code checkpoint before which we were recomputing w and after which we were not (since it's a change to the numerical methods). Might be good if we do this before merging in RK3.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/948
https://github.com/CliMA/Oceananigans.jl/issues/949:192,Deployability,configurat,configuration,192,"I am using the master branch for nutrient tracers with a 3rd DST advection scheme. I found that the halo points don't have the same values as the boundaries in a periodic domain. Below is the configuration I use and a slice of u velocity. Not sure it's a bug or you intended to do so... Also, the fancy logger disappeared after I updated to 0.36.0. ```julia; grid = RegularCartesianGrid(size=(32, 2, 32), extent=(2*32, 2*2, 2*32), halo = (2, 2, 2)). RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 66.0], y ∈ [0.0, 6.0], z ∈ [-64.0, 2.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (32, 2, 32); halo size (Hx, Hy, Hz): (2, 2, 2); grid spacing (Δx, Δy, Δz): (2.0, 2.0, 2.0); ```; ```julia; T_bcs = TracerBoundaryConditions(Ogrid, top = BoundaryCondition(Flux, Qᵀ), ; bottom = BoundaryCondition(Gradient, ∂T∂z)). model = IncompressibleModel(; architecture = CPU(),; grid = grid,; coriolis = FPlane(f=f),; buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(α=α, β=β)),; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (T=T_bcs,); ); ```; ```julia; model.velocities.u.data.parent[:,:,3]; 36×6 Array{Float64,2}:; -0.0085938 -0.00844015 -0.0085938 -0.00844015 -0.0085938 -0.00844015; -0.010009 -0.0104645 -0.010009 -0.0104645 -0.010009 -0.0104645; -0.00859588 -0.00912747 -0.00829848 -0.00823567 -0.00859588 -0.00912747; -0.00742535 -0.00655195 -0.00594664 -0.00595502 -0.00742535 -0.00655195; -0.00536066 -0.0038463 -0.00437428 -0.00422142 -0.00536066 -0.0038463; -0.00241687 -0.00325761 -0.00216266 -0.00211736 -0.00241687 -0.00325761; 0.00258328 0.00188971 0.00159199 0.00141804 0.00258328 0.00188971; 0.00289388 0.00378436 0.00257106 0.00259916 0.00289388 0.00378436; 0.00363445 0.00407903 0.00342151 0.00360496 0.00363445 0.00407903; 0.00575018 0.00480254 0.00481157 0.00447708 0.00575018 0.00480254; 0.00667745 0.00577658 0.00495125 0.00499728 0.00667745 0.00577658; 0.00464067 0.00487611 0.00543163 0.00506227 0.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/949
https://github.com/CliMA/Oceananigans.jl/issues/949:330,Deployability,update,updated,330,"I am using the master branch for nutrient tracers with a 3rd DST advection scheme. I found that the halo points don't have the same values as the boundaries in a periodic domain. Below is the configuration I use and a slice of u velocity. Not sure it's a bug or you intended to do so... Also, the fancy logger disappeared after I updated to 0.36.0. ```julia; grid = RegularCartesianGrid(size=(32, 2, 32), extent=(2*32, 2*2, 2*32), halo = (2, 2, 2)). RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 66.0], y ∈ [0.0, 6.0], z ∈ [-64.0, 2.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (32, 2, 32); halo size (Hx, Hy, Hz): (2, 2, 2); grid spacing (Δx, Δy, Δz): (2.0, 2.0, 2.0); ```; ```julia; T_bcs = TracerBoundaryConditions(Ogrid, top = BoundaryCondition(Flux, Qᵀ), ; bottom = BoundaryCondition(Gradient, ∂T∂z)). model = IncompressibleModel(; architecture = CPU(),; grid = grid,; coriolis = FPlane(f=f),; buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(α=α, β=β)),; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (T=T_bcs,); ); ```; ```julia; model.velocities.u.data.parent[:,:,3]; 36×6 Array{Float64,2}:; -0.0085938 -0.00844015 -0.0085938 -0.00844015 -0.0085938 -0.00844015; -0.010009 -0.0104645 -0.010009 -0.0104645 -0.010009 -0.0104645; -0.00859588 -0.00912747 -0.00829848 -0.00823567 -0.00859588 -0.00912747; -0.00742535 -0.00655195 -0.00594664 -0.00595502 -0.00742535 -0.00655195; -0.00536066 -0.0038463 -0.00437428 -0.00422142 -0.00536066 -0.0038463; -0.00241687 -0.00325761 -0.00216266 -0.00211736 -0.00241687 -0.00325761; 0.00258328 0.00188971 0.00159199 0.00141804 0.00258328 0.00188971; 0.00289388 0.00378436 0.00257106 0.00259916 0.00289388 0.00378436; 0.00363445 0.00407903 0.00342151 0.00360496 0.00363445 0.00407903; 0.00575018 0.00480254 0.00481157 0.00447708 0.00575018 0.00480254; 0.00667745 0.00577658 0.00495125 0.00499728 0.00667745 0.00577658; 0.00464067 0.00487611 0.00543163 0.00506227 0.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/949
https://github.com/CliMA/Oceananigans.jl/issues/949:192,Modifiability,config,configuration,192,"I am using the master branch for nutrient tracers with a 3rd DST advection scheme. I found that the halo points don't have the same values as the boundaries in a periodic domain. Below is the configuration I use and a slice of u velocity. Not sure it's a bug or you intended to do so... Also, the fancy logger disappeared after I updated to 0.36.0. ```julia; grid = RegularCartesianGrid(size=(32, 2, 32), extent=(2*32, 2*2, 2*32), halo = (2, 2, 2)). RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 66.0], y ∈ [0.0, 6.0], z ∈ [-64.0, 2.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (32, 2, 32); halo size (Hx, Hy, Hz): (2, 2, 2); grid spacing (Δx, Δy, Δz): (2.0, 2.0, 2.0); ```; ```julia; T_bcs = TracerBoundaryConditions(Ogrid, top = BoundaryCondition(Flux, Qᵀ), ; bottom = BoundaryCondition(Gradient, ∂T∂z)). model = IncompressibleModel(; architecture = CPU(),; grid = grid,; coriolis = FPlane(f=f),; buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(α=α, β=β)),; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (T=T_bcs,); ); ```; ```julia; model.velocities.u.data.parent[:,:,3]; 36×6 Array{Float64,2}:; -0.0085938 -0.00844015 -0.0085938 -0.00844015 -0.0085938 -0.00844015; -0.010009 -0.0104645 -0.010009 -0.0104645 -0.010009 -0.0104645; -0.00859588 -0.00912747 -0.00829848 -0.00823567 -0.00859588 -0.00912747; -0.00742535 -0.00655195 -0.00594664 -0.00595502 -0.00742535 -0.00655195; -0.00536066 -0.0038463 -0.00437428 -0.00422142 -0.00536066 -0.0038463; -0.00241687 -0.00325761 -0.00216266 -0.00211736 -0.00241687 -0.00325761; 0.00258328 0.00188971 0.00159199 0.00141804 0.00258328 0.00188971; 0.00289388 0.00378436 0.00257106 0.00259916 0.00289388 0.00378436; 0.00363445 0.00407903 0.00342151 0.00360496 0.00363445 0.00407903; 0.00575018 0.00480254 0.00481157 0.00447708 0.00575018 0.00480254; 0.00667745 0.00577658 0.00495125 0.00499728 0.00667745 0.00577658; 0.00464067 0.00487611 0.00543163 0.00506227 0.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/949
https://github.com/CliMA/Oceananigans.jl/issues/949:303,Testability,log,logger,303,"I am using the master branch for nutrient tracers with a 3rd DST advection scheme. I found that the halo points don't have the same values as the boundaries in a periodic domain. Below is the configuration I use and a slice of u velocity. Not sure it's a bug or you intended to do so... Also, the fancy logger disappeared after I updated to 0.36.0. ```julia; grid = RegularCartesianGrid(size=(32, 2, 32), extent=(2*32, 2*2, 2*32), halo = (2, 2, 2)). RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 66.0], y ∈ [0.0, 6.0], z ∈ [-64.0, 2.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (32, 2, 32); halo size (Hx, Hy, Hz): (2, 2, 2); grid spacing (Δx, Δy, Δz): (2.0, 2.0, 2.0); ```; ```julia; T_bcs = TracerBoundaryConditions(Ogrid, top = BoundaryCondition(Flux, Qᵀ), ; bottom = BoundaryCondition(Gradient, ∂T∂z)). model = IncompressibleModel(; architecture = CPU(),; grid = grid,; coriolis = FPlane(f=f),; buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(α=α, β=β)),; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (T=T_bcs,); ); ```; ```julia; model.velocities.u.data.parent[:,:,3]; 36×6 Array{Float64,2}:; -0.0085938 -0.00844015 -0.0085938 -0.00844015 -0.0085938 -0.00844015; -0.010009 -0.0104645 -0.010009 -0.0104645 -0.010009 -0.0104645; -0.00859588 -0.00912747 -0.00829848 -0.00823567 -0.00859588 -0.00912747; -0.00742535 -0.00655195 -0.00594664 -0.00595502 -0.00742535 -0.00655195; -0.00536066 -0.0038463 -0.00437428 -0.00422142 -0.00536066 -0.0038463; -0.00241687 -0.00325761 -0.00216266 -0.00211736 -0.00241687 -0.00325761; 0.00258328 0.00188971 0.00159199 0.00141804 0.00258328 0.00188971; 0.00289388 0.00378436 0.00257106 0.00259916 0.00289388 0.00378436; 0.00363445 0.00407903 0.00342151 0.00360496 0.00363445 0.00407903; 0.00575018 0.00480254 0.00481157 0.00447708 0.00575018 0.00480254; 0.00667745 0.00577658 0.00495125 0.00499728 0.00667745 0.00577658; 0.00464067 0.00487611 0.00543163 0.00506227 0.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/949
https://github.com/CliMA/Oceananigans.jl/pull/952:332,Integrability,depend,depend,332,"This PR adds a `BuoyancyField` which is a type of lazily computed field constructed via `b = BuoyancyField(model)`. . `BuoyancyField` represents model buoyancy in abstract operations:. ```julia; b = BuoyancyField(model); wb = ComputedField(w * b); ```. etc. This is important for nonlinear equations of state, where statistics that depend on buoyancy need to be calculated online. cc @BrodiePearson. Side note: we need the same for `PressureField`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/952
https://github.com/CliMA/Oceananigans.jl/pull/953:30,Testability,test,tests,30,"~~Since this wasn't caught by tests, I think this PR should add a test.~~. A test will be added in an imminent PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/953
https://github.com/CliMA/Oceananigans.jl/pull/953:66,Testability,test,test,66,"~~Since this wasn't caught by tests, I think this PR should add a test.~~. A test will be added in an imminent PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/953
https://github.com/CliMA/Oceananigans.jl/pull/953:77,Testability,test,test,77,"~~Since this wasn't caught by tests, I think this PR should add a test.~~. A test will be added in an imminent PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/953
https://github.com/CliMA/Oceananigans.jl/issues/955:164,Availability,robust,robust,164,"We now have an infrastructure for embedding fields that require computation like `AveragedField` and `ComputedField` within abstract operations. We currently use a robust, but expensive strategy for ensuring that a computation is correct: immediately prior to evaluating an `AbstractOperation`, we call `compute!` on all of its nodes. This ensures that all data used in the `AbstractOperation` is up to date. A downside to this strategy is that it is more expensive than it needs to be in many common cases. An example is the calculation of three-dimensional buoyancy fluxes `u * b`, `v * b`, and `w * b`, where `b = BuoyancyField(model)`. Evaluating these three expressions will each trigger an evaluation of the model buoyancy. Two of those evaluations are unnecessary. We should brainstorm ways to avoid superfluous recalculation of `ComputedField`s and `AveragedField`s.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/955
https://github.com/CliMA/Oceananigans.jl/issues/955:411,Availability,down,downside,411,"We now have an infrastructure for embedding fields that require computation like `AveragedField` and `ComputedField` within abstract operations. We currently use a robust, but expensive strategy for ensuring that a computation is correct: immediately prior to evaluating an `AbstractOperation`, we call `compute!` on all of its nodes. This ensures that all data used in the `AbstractOperation` is up to date. A downside to this strategy is that it is more expensive than it needs to be in many common cases. An example is the calculation of three-dimensional buoyancy fluxes `u * b`, `v * b`, and `w * b`, where `b = BuoyancyField(model)`. Evaluating these three expressions will each trigger an evaluation of the model buoyancy. Two of those evaluations are unnecessary. We should brainstorm ways to avoid superfluous recalculation of `ComputedField`s and `AveragedField`s.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/955
https://github.com/CliMA/Oceananigans.jl/issues/955:801,Safety,avoid,avoid,801,"We now have an infrastructure for embedding fields that require computation like `AveragedField` and `ComputedField` within abstract operations. We currently use a robust, but expensive strategy for ensuring that a computation is correct: immediately prior to evaluating an `AbstractOperation`, we call `compute!` on all of its nodes. This ensures that all data used in the `AbstractOperation` is up to date. A downside to this strategy is that it is more expensive than it needs to be in many common cases. An example is the calculation of three-dimensional buoyancy fluxes `u * b`, `v * b`, and `w * b`, where `b = BuoyancyField(model)`. Evaluating these three expressions will each trigger an evaluation of the model buoyancy. Two of those evaluations are unnecessary. We should brainstorm ways to avoid superfluous recalculation of `ComputedField`s and `AveragedField`s.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/955
https://github.com/CliMA/Oceananigans.jl/pull/956:195,Testability,test,tests,195,"This PR adds a convenience function `PressureField(model)` that returns a `ComputedField` representing total pressure, with data stored by default in the hydrostatic pressure field. It also adds tests for using `AveragedField`s and `ComputedField`s in operations, and fixes a method ambiguity associated with deducing interpolation to `Nothing` locations.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/956
https://github.com/CliMA/Oceananigans.jl/issues/958:233,Integrability,wrap,wrapped,233,"It would be relatively simple to create a new type called `PrescribedVelocities` for the purpose of solving tracer advection problems with prescribed fluid motion. The velocity fields would be specified as functions of `x, y, z, t`, wrapped in a [`FunctionField`](https://github.com/CliMA/Oceananigans.jl/blob/master/src/Fields/function_field.jl) at the appropriate locations, and stored in `PrescribedVelocities`:. ```julia; struct PrescribedVelocities{U, V, W}; u :: U; v :: V; w :: W; end; ```. The next part of this implementation is overloading halo filling, time stepping, pressure corrections, and other functions that act on `model.velocities` with a bypass for `PrescribedVelocities`. This would be tedious but straightforward. We can also avoid allocating memory for pressure fields.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/958
https://github.com/CliMA/Oceananigans.jl/issues/958:749,Safety,avoid,avoid,749,"It would be relatively simple to create a new type called `PrescribedVelocities` for the purpose of solving tracer advection problems with prescribed fluid motion. The velocity fields would be specified as functions of `x, y, z, t`, wrapped in a [`FunctionField`](https://github.com/CliMA/Oceananigans.jl/blob/master/src/Fields/function_field.jl) at the appropriate locations, and stored in `PrescribedVelocities`:. ```julia; struct PrescribedVelocities{U, V, W}; u :: U; v :: V; w :: W; end; ```. The next part of this implementation is overloading halo filling, time stepping, pressure corrections, and other functions that act on `model.velocities` with a bypass for `PrescribedVelocities`. This would be tedious but straightforward. We can also avoid allocating memory for pressure fields.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/958
https://github.com/CliMA/Oceananigans.jl/issues/958:23,Usability,simpl,simple,23,"It would be relatively simple to create a new type called `PrescribedVelocities` for the purpose of solving tracer advection problems with prescribed fluid motion. The velocity fields would be specified as functions of `x, y, z, t`, wrapped in a [`FunctionField`](https://github.com/CliMA/Oceananigans.jl/blob/master/src/Fields/function_field.jl) at the appropriate locations, and stored in `PrescribedVelocities`:. ```julia; struct PrescribedVelocities{U, V, W}; u :: U; v :: V; w :: W; end; ```. The next part of this implementation is overloading halo filling, time stepping, pressure corrections, and other functions that act on `model.velocities` with a bypass for `PrescribedVelocities`. This would be tedious but straightforward. We can also avoid allocating memory for pressure fields.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/958
https://github.com/CliMA/Oceananigans.jl/issues/959:324,Usability,simpl,simple,324,"I'm not 100% we want to enforce this, but it should be possible to ensure that `BinaryOperations` always occur at shared locations of fields. `BinaryOperations` are constructed via. https://github.com/CliMA/Oceananigans.jl/blob/c572c39b291bfea49e8ca4f6cdd4cb94e8cb4893/src/AbstractOperations/binary_operations.jl#L38-L43. A simple check will ensure that `Lab` always contains shared locations:. ```julia; Lab = Tuple(La[i] === Lb[i] && !isnothing(La[i]) ? La[i] : Lab[i] for i = 1:3); ```. I believe @jm-c has mentioned that this should always be enforced... ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/959
https://github.com/CliMA/Oceananigans.jl/issues/960:26,Integrability,interface,interface,26,"We may able to provide an interface for specifying background tracer distributions and velocity fields (which perform advection only?) using `FunctionField`s and the existing advection operators. I think we would want this functionality to assume that the _linear_ balances between background terms are somehow separately satisfied. With that assumption we can include just the two nonlinear terms associated with 1) advection of the resolved field by the background field and 2) advection of the background field by the resolved fields. For this to be easily implemented we need to change the function signature of the advection operators for momentum from. ```julia; div_ũu(i, j, k, grid, advection, U); ```. to . ```julia; div_ũu(i, j, k, grid, advection, U, u); ```. which then enables us to include background terms via. ```julia; div_ũu(i, j, k, grid, advection, U_background, u) + div_ũu(i, j, k, grid, advection, U, u_background); ```. for example. Tracers are fine, since the current function is. ```julia; div_uc(i, j, k, grid, advection, U, c); ```. which will become. ```julia; div_uc(i, j, k, grid, advection, U_background, c) + div_uc(i, j, k, grid, advection, U, c_background); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/960
https://github.com/CliMA/Oceananigans.jl/issues/960:110,Performance,perform,perform,110,"We may able to provide an interface for specifying background tracer distributions and velocity fields (which perform advection only?) using `FunctionField`s and the existing advection operators. I think we would want this functionality to assume that the _linear_ balances between background terms are somehow separately satisfied. With that assumption we can include just the two nonlinear terms associated with 1) advection of the resolved field by the background field and 2) advection of the background field by the resolved fields. For this to be easily implemented we need to change the function signature of the advection operators for momentum from. ```julia; div_ũu(i, j, k, grid, advection, U); ```. to . ```julia; div_ũu(i, j, k, grid, advection, U, u); ```. which then enables us to include background terms via. ```julia; div_ũu(i, j, k, grid, advection, U_background, u) + div_ũu(i, j, k, grid, advection, U, u_background); ```. for example. Tracers are fine, since the current function is. ```julia; div_uc(i, j, k, grid, advection, U, c); ```. which will become. ```julia; div_uc(i, j, k, grid, advection, U_background, c) + div_uc(i, j, k, grid, advection, U, c_background); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/960
https://github.com/CliMA/Oceananigans.jl/issues/962:1004,Safety,avoid,avoid,1004,"Prior to time-stepping we execute an ""initial"" call to `run_diagnostic` for every `simulation.diagnostics`:. https://github.com/CliMA/Oceananigans.jl/blob/c572c39b291bfea49e8ca4f6cdd4cb94e8cb4893/src/Simulations/run.jl#L80-L83. This is an edge case for calling `run_diagnostic` on the `WindowedTimeAverage` in which we are not currently collecting, but also do not wish to initialize data collection. In other words, `run_diagnostic` assumes that if it is called, the user wishes to start collecting data:. https://github.com/CliMA/Oceananigans.jl/blob/c572c39b291bfea49e8ca4f6cdd4cb94e8cb4893/src/OutputWriters/windowed_time_average.jl#L90-L92. but this assumption is not necessarily correct for the initial call to `run_diagnostic`. We thus need to check whether `run_diagnostic` has been called at the zeroth iteration --- and also whether or not we ""should"" be initializing data collection (this is true when `time_window == time_interval`, since we are then always collecting data for averaging) to avoid spurious data collection.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/962
https://github.com/CliMA/Oceananigans.jl/issues/963:479,Availability,recover,recovered,479,"Currently the `JLD2OutputWriter` labels output in a timeseries by `model.clock.iteration`. It might be easier to handle output if data is labeled by ""save point"", so it goes 0, 1, 2... This is easier to work with at the REPL, since you always know, for example, that `file[""timeseries/u/1""]` exists (rather than having to manually inspect the file to figure out the iterations that data ended up being saved at). We can add a field `iteration` so that the model iteration can be recovered, if that's needed.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/963
https://github.com/CliMA/Oceananigans.jl/issues/963:479,Safety,recover,recovered,479,"Currently the `JLD2OutputWriter` labels output in a timeseries by `model.clock.iteration`. It might be easier to handle output if data is labeled by ""save point"", so it goes 0, 1, 2... This is easier to work with at the REPL, since you always know, for example, that `file[""timeseries/u/1""]` exists (rather than having to manually inspect the file to figure out the iterations that data ended up being saved at). We can add a field `iteration` so that the model iteration can be recovered, if that's needed.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/963
https://github.com/CliMA/Oceananigans.jl/pull/964:352,Testability,test,test,352,"This PR fixes two bugs in `WindowedTimeAverage`. The first is discussed in #962. The second occurs because it is possible that the output time specified by `time_interval` is reached prior to the completion of `time_window`. This PR changes `WindowedTimeAverage` so that average finalization occurs just prior to output. It'd probably be good to add a test to this PR. In addition, issues like this suggest it may be best to adjust the time-step so that output is ""aligned"". We can do this without cost now that we have a RungeKutta3 timestepper.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/964
https://github.com/CliMA/Oceananigans.jl/pull/968:61,Availability,redundant,redundant,61,"This PR implements an optimization that (potentially) avoids redundant recompilation of fields when `compute!(output)` is called in `fetch_output`. This optimization was discussed on #955 . The idea is to use `model.clock.time` as a ""key"" which is checked prior to computation. Fields that opt-in to avoid recomputation then check if `model.clock.time == field.status.time`. If the two are equal, no computation is performed. This will hopefully speed up expressions that involve `AveragedField`s, `ComputedField`s, and `BuoyancyField`. Note that in the case that users specify scratch space for a field, they must opt-in to this optimization by passing `recompute_safely=false` to the field constructor. If scratch space is not specified (and we therefore know it is unique), recomputation is avoided by default. This PR also changes the keyword `computed_data` to `operand_data` in the constructor for `AveragedField(op::AbstractOperation)`. . Todo:. - [x] Tests. Resolves #955 ; Resolves #967",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/968
https://github.com/CliMA/Oceananigans.jl/pull/968:22,Performance,optimiz,optimization,22,"This PR implements an optimization that (potentially) avoids redundant recompilation of fields when `compute!(output)` is called in `fetch_output`. This optimization was discussed on #955 . The idea is to use `model.clock.time` as a ""key"" which is checked prior to computation. Fields that opt-in to avoid recomputation then check if `model.clock.time == field.status.time`. If the two are equal, no computation is performed. This will hopefully speed up expressions that involve `AveragedField`s, `ComputedField`s, and `BuoyancyField`. Note that in the case that users specify scratch space for a field, they must opt-in to this optimization by passing `recompute_safely=false` to the field constructor. If scratch space is not specified (and we therefore know it is unique), recomputation is avoided by default. This PR also changes the keyword `computed_data` to `operand_data` in the constructor for `AveragedField(op::AbstractOperation)`. . Todo:. - [x] Tests. Resolves #955 ; Resolves #967",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/968
https://github.com/CliMA/Oceananigans.jl/pull/968:153,Performance,optimiz,optimization,153,"This PR implements an optimization that (potentially) avoids redundant recompilation of fields when `compute!(output)` is called in `fetch_output`. This optimization was discussed on #955 . The idea is to use `model.clock.time` as a ""key"" which is checked prior to computation. Fields that opt-in to avoid recomputation then check if `model.clock.time == field.status.time`. If the two are equal, no computation is performed. This will hopefully speed up expressions that involve `AveragedField`s, `ComputedField`s, and `BuoyancyField`. Note that in the case that users specify scratch space for a field, they must opt-in to this optimization by passing `recompute_safely=false` to the field constructor. If scratch space is not specified (and we therefore know it is unique), recomputation is avoided by default. This PR also changes the keyword `computed_data` to `operand_data` in the constructor for `AveragedField(op::AbstractOperation)`. . Todo:. - [x] Tests. Resolves #955 ; Resolves #967",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/968
https://github.com/CliMA/Oceananigans.jl/pull/968:415,Performance,perform,performed,415,"This PR implements an optimization that (potentially) avoids redundant recompilation of fields when `compute!(output)` is called in `fetch_output`. This optimization was discussed on #955 . The idea is to use `model.clock.time` as a ""key"" which is checked prior to computation. Fields that opt-in to avoid recomputation then check if `model.clock.time == field.status.time`. If the two are equal, no computation is performed. This will hopefully speed up expressions that involve `AveragedField`s, `ComputedField`s, and `BuoyancyField`. Note that in the case that users specify scratch space for a field, they must opt-in to this optimization by passing `recompute_safely=false` to the field constructor. If scratch space is not specified (and we therefore know it is unique), recomputation is avoided by default. This PR also changes the keyword `computed_data` to `operand_data` in the constructor for `AveragedField(op::AbstractOperation)`. . Todo:. - [x] Tests. Resolves #955 ; Resolves #967",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/968
https://github.com/CliMA/Oceananigans.jl/pull/968:630,Performance,optimiz,optimization,630,"This PR implements an optimization that (potentially) avoids redundant recompilation of fields when `compute!(output)` is called in `fetch_output`. This optimization was discussed on #955 . The idea is to use `model.clock.time` as a ""key"" which is checked prior to computation. Fields that opt-in to avoid recomputation then check if `model.clock.time == field.status.time`. If the two are equal, no computation is performed. This will hopefully speed up expressions that involve `AveragedField`s, `ComputedField`s, and `BuoyancyField`. Note that in the case that users specify scratch space for a field, they must opt-in to this optimization by passing `recompute_safely=false` to the field constructor. If scratch space is not specified (and we therefore know it is unique), recomputation is avoided by default. This PR also changes the keyword `computed_data` to `operand_data` in the constructor for `AveragedField(op::AbstractOperation)`. . Todo:. - [x] Tests. Resolves #955 ; Resolves #967",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/968
https://github.com/CliMA/Oceananigans.jl/pull/968:54,Safety,avoid,avoids,54,"This PR implements an optimization that (potentially) avoids redundant recompilation of fields when `compute!(output)` is called in `fetch_output`. This optimization was discussed on #955 . The idea is to use `model.clock.time` as a ""key"" which is checked prior to computation. Fields that opt-in to avoid recomputation then check if `model.clock.time == field.status.time`. If the two are equal, no computation is performed. This will hopefully speed up expressions that involve `AveragedField`s, `ComputedField`s, and `BuoyancyField`. Note that in the case that users specify scratch space for a field, they must opt-in to this optimization by passing `recompute_safely=false` to the field constructor. If scratch space is not specified (and we therefore know it is unique), recomputation is avoided by default. This PR also changes the keyword `computed_data` to `operand_data` in the constructor for `AveragedField(op::AbstractOperation)`. . Todo:. - [x] Tests. Resolves #955 ; Resolves #967",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/968
https://github.com/CliMA/Oceananigans.jl/pull/968:61,Safety,redund,redundant,61,"This PR implements an optimization that (potentially) avoids redundant recompilation of fields when `compute!(output)` is called in `fetch_output`. This optimization was discussed on #955 . The idea is to use `model.clock.time` as a ""key"" which is checked prior to computation. Fields that opt-in to avoid recomputation then check if `model.clock.time == field.status.time`. If the two are equal, no computation is performed. This will hopefully speed up expressions that involve `AveragedField`s, `ComputedField`s, and `BuoyancyField`. Note that in the case that users specify scratch space for a field, they must opt-in to this optimization by passing `recompute_safely=false` to the field constructor. If scratch space is not specified (and we therefore know it is unique), recomputation is avoided by default. This PR also changes the keyword `computed_data` to `operand_data` in the constructor for `AveragedField(op::AbstractOperation)`. . Todo:. - [x] Tests. Resolves #955 ; Resolves #967",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/968
https://github.com/CliMA/Oceananigans.jl/pull/968:300,Safety,avoid,avoid,300,"This PR implements an optimization that (potentially) avoids redundant recompilation of fields when `compute!(output)` is called in `fetch_output`. This optimization was discussed on #955 . The idea is to use `model.clock.time` as a ""key"" which is checked prior to computation. Fields that opt-in to avoid recomputation then check if `model.clock.time == field.status.time`. If the two are equal, no computation is performed. This will hopefully speed up expressions that involve `AveragedField`s, `ComputedField`s, and `BuoyancyField`. Note that in the case that users specify scratch space for a field, they must opt-in to this optimization by passing `recompute_safely=false` to the field constructor. If scratch space is not specified (and we therefore know it is unique), recomputation is avoided by default. This PR also changes the keyword `computed_data` to `operand_data` in the constructor for `AveragedField(op::AbstractOperation)`. . Todo:. - [x] Tests. Resolves #955 ; Resolves #967",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/968
https://github.com/CliMA/Oceananigans.jl/pull/968:794,Safety,avoid,avoided,794,"This PR implements an optimization that (potentially) avoids redundant recompilation of fields when `compute!(output)` is called in `fetch_output`. This optimization was discussed on #955 . The idea is to use `model.clock.time` as a ""key"" which is checked prior to computation. Fields that opt-in to avoid recomputation then check if `model.clock.time == field.status.time`. If the two are equal, no computation is performed. This will hopefully speed up expressions that involve `AveragedField`s, `ComputedField`s, and `BuoyancyField`. Note that in the case that users specify scratch space for a field, they must opt-in to this optimization by passing `recompute_safely=false` to the field constructor. If scratch space is not specified (and we therefore know it is unique), recomputation is avoided by default. This PR also changes the keyword `computed_data` to `operand_data` in the constructor for `AveragedField(op::AbstractOperation)`. . Todo:. - [x] Tests. Resolves #955 ; Resolves #967",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/968
https://github.com/CliMA/Oceananigans.jl/pull/968:959,Testability,Test,Tests,959,"This PR implements an optimization that (potentially) avoids redundant recompilation of fields when `compute!(output)` is called in `fetch_output`. This optimization was discussed on #955 . The idea is to use `model.clock.time` as a ""key"" which is checked prior to computation. Fields that opt-in to avoid recomputation then check if `model.clock.time == field.status.time`. If the two are equal, no computation is performed. This will hopefully speed up expressions that involve `AveragedField`s, `ComputedField`s, and `BuoyancyField`. Note that in the case that users specify scratch space for a field, they must opt-in to this optimization by passing `recompute_safely=false` to the field constructor. If scratch space is not specified (and we therefore know it is unique), recomputation is avoided by default. This PR also changes the keyword `computed_data` to `operand_data` in the constructor for `AveragedField(op::AbstractOperation)`. . Todo:. - [x] Tests. Resolves #955 ; Resolves #967",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/968
https://github.com/CliMA/Oceananigans.jl/pull/970:611,Availability,avail,available,611,"This PR adds a `dims` keyword argument to `zero_halo_regions`, so that we can avoid zeroing out halo regions in directions that are not averaged. It also adds tests to ensure that this works. This PR does not solve all the issues with averaging halo regions, however. In particular, the halo regions are not guaranteed to be correct because they may have been previously zeroed out. This can be solved by calling `fill_halo_regions` prior to computing an average. However, this solution is not possible with the current syntax, because field boundary conditions can depend on other fields of model that are not available within `compute!(averaged_field)`. I will raise an issue after this PR to discuss this other problem, which involves some difficult trade-offs.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/970
https://github.com/CliMA/Oceananigans.jl/pull/970:566,Integrability,depend,depend,566,"This PR adds a `dims` keyword argument to `zero_halo_regions`, so that we can avoid zeroing out halo regions in directions that are not averaged. It also adds tests to ensure that this works. This PR does not solve all the issues with averaging halo regions, however. In particular, the halo regions are not guaranteed to be correct because they may have been previously zeroed out. This can be solved by calling `fill_halo_regions` prior to computing an average. However, this solution is not possible with the current syntax, because field boundary conditions can depend on other fields of model that are not available within `compute!(averaged_field)`. I will raise an issue after this PR to discuss this other problem, which involves some difficult trade-offs.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/970
https://github.com/CliMA/Oceananigans.jl/pull/970:78,Safety,avoid,avoid,78,"This PR adds a `dims` keyword argument to `zero_halo_regions`, so that we can avoid zeroing out halo regions in directions that are not averaged. It also adds tests to ensure that this works. This PR does not solve all the issues with averaging halo regions, however. In particular, the halo regions are not guaranteed to be correct because they may have been previously zeroed out. This can be solved by calling `fill_halo_regions` prior to computing an average. However, this solution is not possible with the current syntax, because field boundary conditions can depend on other fields of model that are not available within `compute!(averaged_field)`. I will raise an issue after this PR to discuss this other problem, which involves some difficult trade-offs.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/970
https://github.com/CliMA/Oceananigans.jl/pull/970:159,Testability,test,tests,159,"This PR adds a `dims` keyword argument to `zero_halo_regions`, so that we can avoid zeroing out halo regions in directions that are not averaged. It also adds tests to ensure that this works. This PR does not solve all the issues with averaging halo regions, however. In particular, the halo regions are not guaranteed to be correct because they may have been previously zeroed out. This can be solved by calling `fill_halo_regions` prior to computing an average. However, this solution is not possible with the current syntax, because field boundary conditions can depend on other fields of model that are not available within `compute!(averaged_field)`. I will raise an issue after this PR to discuss this other problem, which involves some difficult trade-offs.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/970
https://github.com/CliMA/Oceananigans.jl/issues/971:1382,Deployability,continuous,continuous,1382,"Currently it is not generically possible to call. ```julia; fill_halo_regions!(field); ```. Part of this is trivial as noted in #969. But another part is that boundary conditions on fields can depend on other _other_ fields, to which `field` contains no reference. We allow field boundary conditions to depend on anything in `state(model)`, which includes the model velocity fields, tracer fields, pressure fields, and diffusivities. Because references to `state(model)` are required to fill halo regions in general, we are unable to fill halo regions prior to computing an `AveragedField` (for example). We may not _want_ to solve this problem because it require too-invasive changes. For example, we certainly want to support the concept of fields that are independent of other fields. General support for interdependent fields may be too difficult. Some possible solutions:. * an ""optional"" `state` property of `Field` which is set to `nothing` by default. We can ensure that `state` is properly determined in the constructor for `IncompressibleModel` for the model fields. * an ""optional"" `state` or `fields` property within each individual boundary condition (with a similar function as the optional property above). This property could be activated only for boundary conditions that need it (currently, only discrete form boundary conditions, though this could be extended to continuous form boundary conditions in the future via #897). Solving this will simplify time-stepping code a bit and permit simpler halo region filling via `fill_halo_regions!(field)` with no additional arguments.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/971
https://github.com/CliMA/Oceananigans.jl/issues/971:193,Integrability,depend,depend,193,"Currently it is not generically possible to call. ```julia; fill_halo_regions!(field); ```. Part of this is trivial as noted in #969. But another part is that boundary conditions on fields can depend on other _other_ fields, to which `field` contains no reference. We allow field boundary conditions to depend on anything in `state(model)`, which includes the model velocity fields, tracer fields, pressure fields, and diffusivities. Because references to `state(model)` are required to fill halo regions in general, we are unable to fill halo regions prior to computing an `AveragedField` (for example). We may not _want_ to solve this problem because it require too-invasive changes. For example, we certainly want to support the concept of fields that are independent of other fields. General support for interdependent fields may be too difficult. Some possible solutions:. * an ""optional"" `state` property of `Field` which is set to `nothing` by default. We can ensure that `state` is properly determined in the constructor for `IncompressibleModel` for the model fields. * an ""optional"" `state` or `fields` property within each individual boundary condition (with a similar function as the optional property above). This property could be activated only for boundary conditions that need it (currently, only discrete form boundary conditions, though this could be extended to continuous form boundary conditions in the future via #897). Solving this will simplify time-stepping code a bit and permit simpler halo region filling via `fill_halo_regions!(field)` with no additional arguments.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/971
https://github.com/CliMA/Oceananigans.jl/issues/971:303,Integrability,depend,depend,303,"Currently it is not generically possible to call. ```julia; fill_halo_regions!(field); ```. Part of this is trivial as noted in #969. But another part is that boundary conditions on fields can depend on other _other_ fields, to which `field` contains no reference. We allow field boundary conditions to depend on anything in `state(model)`, which includes the model velocity fields, tracer fields, pressure fields, and diffusivities. Because references to `state(model)` are required to fill halo regions in general, we are unable to fill halo regions prior to computing an `AveragedField` (for example). We may not _want_ to solve this problem because it require too-invasive changes. For example, we certainly want to support the concept of fields that are independent of other fields. General support for interdependent fields may be too difficult. Some possible solutions:. * an ""optional"" `state` property of `Field` which is set to `nothing` by default. We can ensure that `state` is properly determined in the constructor for `IncompressibleModel` for the model fields. * an ""optional"" `state` or `fields` property within each individual boundary condition (with a similar function as the optional property above). This property could be activated only for boundary conditions that need it (currently, only discrete form boundary conditions, though this could be extended to continuous form boundary conditions in the future via #897). Solving this will simplify time-stepping code a bit and permit simpler halo region filling via `fill_halo_regions!(field)` with no additional arguments.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/971
https://github.com/CliMA/Oceananigans.jl/issues/971:1370,Modifiability,extend,extended,1370,"Currently it is not generically possible to call. ```julia; fill_halo_regions!(field); ```. Part of this is trivial as noted in #969. But another part is that boundary conditions on fields can depend on other _other_ fields, to which `field` contains no reference. We allow field boundary conditions to depend on anything in `state(model)`, which includes the model velocity fields, tracer fields, pressure fields, and diffusivities. Because references to `state(model)` are required to fill halo regions in general, we are unable to fill halo regions prior to computing an `AveragedField` (for example). We may not _want_ to solve this problem because it require too-invasive changes. For example, we certainly want to support the concept of fields that are independent of other fields. General support for interdependent fields may be too difficult. Some possible solutions:. * an ""optional"" `state` property of `Field` which is set to `nothing` by default. We can ensure that `state` is properly determined in the constructor for `IncompressibleModel` for the model fields. * an ""optional"" `state` or `fields` property within each individual boundary condition (with a similar function as the optional property above). This property could be activated only for boundary conditions that need it (currently, only discrete form boundary conditions, though this could be extended to continuous form boundary conditions in the future via #897). Solving this will simplify time-stepping code a bit and permit simpler halo region filling via `fill_halo_regions!(field)` with no additional arguments.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/971
https://github.com/CliMA/Oceananigans.jl/issues/971:1461,Usability,simpl,simplify,1461,"Currently it is not generically possible to call. ```julia; fill_halo_regions!(field); ```. Part of this is trivial as noted in #969. But another part is that boundary conditions on fields can depend on other _other_ fields, to which `field` contains no reference. We allow field boundary conditions to depend on anything in `state(model)`, which includes the model velocity fields, tracer fields, pressure fields, and diffusivities. Because references to `state(model)` are required to fill halo regions in general, we are unable to fill halo regions prior to computing an `AveragedField` (for example). We may not _want_ to solve this problem because it require too-invasive changes. For example, we certainly want to support the concept of fields that are independent of other fields. General support for interdependent fields may be too difficult. Some possible solutions:. * an ""optional"" `state` property of `Field` which is set to `nothing` by default. We can ensure that `state` is properly determined in the constructor for `IncompressibleModel` for the model fields. * an ""optional"" `state` or `fields` property within each individual boundary condition (with a similar function as the optional property above). This property could be activated only for boundary conditions that need it (currently, only discrete form boundary conditions, though this could be extended to continuous form boundary conditions in the future via #897). Solving this will simplify time-stepping code a bit and permit simpler halo region filling via `fill_halo_regions!(field)` with no additional arguments.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/971
https://github.com/CliMA/Oceananigans.jl/issues/971:1506,Usability,simpl,simpler,1506,"Currently it is not generically possible to call. ```julia; fill_halo_regions!(field); ```. Part of this is trivial as noted in #969. But another part is that boundary conditions on fields can depend on other _other_ fields, to which `field` contains no reference. We allow field boundary conditions to depend on anything in `state(model)`, which includes the model velocity fields, tracer fields, pressure fields, and diffusivities. Because references to `state(model)` are required to fill halo regions in general, we are unable to fill halo regions prior to computing an `AveragedField` (for example). We may not _want_ to solve this problem because it require too-invasive changes. For example, we certainly want to support the concept of fields that are independent of other fields. General support for interdependent fields may be too difficult. Some possible solutions:. * an ""optional"" `state` property of `Field` which is set to `nothing` by default. We can ensure that `state` is properly determined in the constructor for `IncompressibleModel` for the model fields. * an ""optional"" `state` or `fields` property within each individual boundary condition (with a similar function as the optional property above). This property could be activated only for boundary conditions that need it (currently, only discrete form boundary conditions, though this could be extended to continuous form boundary conditions in the future via #897). Solving this will simplify time-stepping code a bit and permit simpler halo region filling via `fill_halo_regions!(field)` with no additional arguments.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/971
https://github.com/CliMA/Oceananigans.jl/pull/972:390,Integrability,interface,interfaces,390,"This PR implements a new framework for high-order advection schemes. There are two types of advection schemes: `AbstractCenteredAdvectionScheme` and `AbstractUpwindBiasedAdvectionScheme`. This PR implements momentum and tracer flux operators such that an centered advection scheme needs only to implement 7 functions: 6 `symmetric_interpolate_*` functions for `x, y, z` at cell centers and interfaces, and a `boundary_buffer` scheme that indicates the buffer needed around boundaries in `Bounded` directions`. . Upwind biased advection schemes need 19 functions: `halo_buffer`, 12 functions for `left_biased_interpolate_*` and `right_biased_interpolate_*`, and 6 functions for `symmetric_interpolate_*` that use a symmetric interpolation (typically of order `m-1`, where `m` is the order of the upwind scheme). These are used for momentum advection. This PR refactors fourth order advection to use the framework. It still needs:. - [x] third-order upwind biased advection (as an example); - [x] tests. Resolves #965",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/972
https://github.com/CliMA/Oceananigans.jl/pull/972:858,Modifiability,refactor,refactors,858,"This PR implements a new framework for high-order advection schemes. There are two types of advection schemes: `AbstractCenteredAdvectionScheme` and `AbstractUpwindBiasedAdvectionScheme`. This PR implements momentum and tracer flux operators such that an centered advection scheme needs only to implement 7 functions: 6 `symmetric_interpolate_*` functions for `x, y, z` at cell centers and interfaces, and a `boundary_buffer` scheme that indicates the buffer needed around boundaries in `Bounded` directions`. . Upwind biased advection schemes need 19 functions: `halo_buffer`, 12 functions for `left_biased_interpolate_*` and `right_biased_interpolate_*`, and 6 functions for `symmetric_interpolate_*` that use a symmetric interpolation (typically of order `m-1`, where `m` is the order of the upwind scheme). These are used for momentum advection. This PR refactors fourth order advection to use the framework. It still needs:. - [x] third-order upwind biased advection (as an example); - [x] tests. Resolves #965",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/972
https://github.com/CliMA/Oceananigans.jl/pull/972:995,Testability,test,tests,995,"This PR implements a new framework for high-order advection schemes. There are two types of advection schemes: `AbstractCenteredAdvectionScheme` and `AbstractUpwindBiasedAdvectionScheme`. This PR implements momentum and tracer flux operators such that an centered advection scheme needs only to implement 7 functions: 6 `symmetric_interpolate_*` functions for `x, y, z` at cell centers and interfaces, and a `boundary_buffer` scheme that indicates the buffer needed around boundaries in `Bounded` directions`. . Upwind biased advection schemes need 19 functions: `halo_buffer`, 12 functions for `left_biased_interpolate_*` and `right_biased_interpolate_*`, and 6 functions for `symmetric_interpolate_*` that use a symmetric interpolation (typically of order `m-1`, where `m` is the order of the upwind scheme). These are used for momentum advection. This PR refactors fourth order advection to use the framework. It still needs:. - [x] third-order upwind biased advection (as an example); - [x] tests. Resolves #965",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/972
https://github.com/CliMA/Oceananigans.jl/issues/973:128,Energy Efficiency,energy,energy,128,"Might be a pretty good idea, other models do it too. I can think of three so far: @sandreza's KPP paper, @glwagner's momentum + energy transfer paper, and [Bhamidipati et al. (2020)](https://doi.org/10.1016/j.ocemod.2020.101615).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/973
https://github.com/CliMA/Oceananigans.jl/pull/974:0,Testability,test,test,0,test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/974
https://github.com/CliMA/Oceananigans.jl/issues/975:698,Availability,checkpoint,checkpoint,698,"Shouldn't be too hard to implement an `InterpolatedField` object where. ```julia; ℑc = InterpolatedField(model.tracers.c, new_grid); ℑc(x, y, z); ```. evaluates the `model.tracers.c` field at the location `(x, y, z)` with tri-linear interpolation (for now, could support other interpolation schemes in the future but not sure if it's that beneficial). This has at least three potential uses:; 1. Lagrangian particle tracking where the velocities need to be evaluated in-between grid points.; 2. Writing output to a custom grid (different from the model grid). This should be as easy as passing an `InterpolatedField` to one of the output writers.; 3. If a custom grid is passed when restoring from checkpoint, i.e. `restore_from_checkpoint(filepath, grid=new_grid)`, the checkpointed fields are interpolated onto the new grid. This is useful for spinning up simulations on a coarse grid then restoring from checkpoint on a finer grid. cc @sandreza from our Slack discussion on mesoscale channels",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/975
https://github.com/CliMA/Oceananigans.jl/issues/975:771,Availability,checkpoint,checkpointed,771,"Shouldn't be too hard to implement an `InterpolatedField` object where. ```julia; ℑc = InterpolatedField(model.tracers.c, new_grid); ℑc(x, y, z); ```. evaluates the `model.tracers.c` field at the location `(x, y, z)` with tri-linear interpolation (for now, could support other interpolation schemes in the future but not sure if it's that beneficial). This has at least three potential uses:; 1. Lagrangian particle tracking where the velocities need to be evaluated in-between grid points.; 2. Writing output to a custom grid (different from the model grid). This should be as easy as passing an `InterpolatedField` to one of the output writers.; 3. If a custom grid is passed when restoring from checkpoint, i.e. `restore_from_checkpoint(filepath, grid=new_grid)`, the checkpointed fields are interpolated onto the new grid. This is useful for spinning up simulations on a coarse grid then restoring from checkpoint on a finer grid. cc @sandreza from our Slack discussion on mesoscale channels",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/975
https://github.com/CliMA/Oceananigans.jl/issues/975:907,Availability,checkpoint,checkpoint,907,"Shouldn't be too hard to implement an `InterpolatedField` object where. ```julia; ℑc = InterpolatedField(model.tracers.c, new_grid); ℑc(x, y, z); ```. evaluates the `model.tracers.c` field at the location `(x, y, z)` with tri-linear interpolation (for now, could support other interpolation schemes in the future but not sure if it's that beneficial). This has at least three potential uses:; 1. Lagrangian particle tracking where the velocities need to be evaluated in-between grid points.; 2. Writing output to a custom grid (different from the model grid). This should be as easy as passing an `InterpolatedField` to one of the output writers.; 3. If a custom grid is passed when restoring from checkpoint, i.e. `restore_from_checkpoint(filepath, grid=new_grid)`, the checkpointed fields are interpolated onto the new grid. This is useful for spinning up simulations on a coarse grid then restoring from checkpoint on a finer grid. cc @sandreza from our Slack discussion on mesoscale channels",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/975
https://github.com/CliMA/Oceananigans.jl/pull/984:10,Testability,test,tests,10,Adds some tests too. Resolves #637,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/984
https://github.com/CliMA/Oceananigans.jl/issues/985:297,Security,access,accessed,297,"Currently the argument `state` used in boundary condition functions and forcing functions adopts the hierarchy in `IncompressibleModel`:. https://github.com/CliMA/Oceananigans.jl/blob/d80be8cf1db4f97515346ae3140b7cbf3f2ddab4/src/Models/Models.jl#L30-L32. so that the `u`-velocity, for example, is accessed via `state.velocities.u`. I'm wondering if we should flatten `state`:. ```julia; @inline state(model) = merge(datatuple(model.velocities), datatuple(model.tracers), datatuple(model.diffusivities)); ```. Life is a bit simpler because then all the fields are accessed via `state.u`, `state.v`, `state.T`, etc. A related question is nomenclature: we can change `state` to `fields`, or maybe `model_fields`, as there is a similar function called `fields`:. https://github.com/CliMA/Oceananigans.jl/blob/d80be8cf1db4f97515346ae3140b7cbf3f2ddab4/src/Models/Models.jl#L34. `model_fields` is a bit more specific so might be a bit more interpretable than `state`. For users this is only a question of documentation of boundary condition forcing and forcing functions since they don't see the internal implementation anyways.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/985
https://github.com/CliMA/Oceananigans.jl/issues/985:563,Security,access,accessed,563,"Currently the argument `state` used in boundary condition functions and forcing functions adopts the hierarchy in `IncompressibleModel`:. https://github.com/CliMA/Oceananigans.jl/blob/d80be8cf1db4f97515346ae3140b7cbf3f2ddab4/src/Models/Models.jl#L30-L32. so that the `u`-velocity, for example, is accessed via `state.velocities.u`. I'm wondering if we should flatten `state`:. ```julia; @inline state(model) = merge(datatuple(model.velocities), datatuple(model.tracers), datatuple(model.diffusivities)); ```. Life is a bit simpler because then all the fields are accessed via `state.u`, `state.v`, `state.T`, etc. A related question is nomenclature: we can change `state` to `fields`, or maybe `model_fields`, as there is a similar function called `fields`:. https://github.com/CliMA/Oceananigans.jl/blob/d80be8cf1db4f97515346ae3140b7cbf3f2ddab4/src/Models/Models.jl#L34. `model_fields` is a bit more specific so might be a bit more interpretable than `state`. For users this is only a question of documentation of boundary condition forcing and forcing functions since they don't see the internal implementation anyways.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/985
https://github.com/CliMA/Oceananigans.jl/issues/985:523,Usability,simpl,simpler,523,"Currently the argument `state` used in boundary condition functions and forcing functions adopts the hierarchy in `IncompressibleModel`:. https://github.com/CliMA/Oceananigans.jl/blob/d80be8cf1db4f97515346ae3140b7cbf3f2ddab4/src/Models/Models.jl#L30-L32. so that the `u`-velocity, for example, is accessed via `state.velocities.u`. I'm wondering if we should flatten `state`:. ```julia; @inline state(model) = merge(datatuple(model.velocities), datatuple(model.tracers), datatuple(model.diffusivities)); ```. Life is a bit simpler because then all the fields are accessed via `state.u`, `state.v`, `state.T`, etc. A related question is nomenclature: we can change `state` to `fields`, or maybe `model_fields`, as there is a similar function called `fields`:. https://github.com/CliMA/Oceananigans.jl/blob/d80be8cf1db4f97515346ae3140b7cbf3f2ddab4/src/Models/Models.jl#L34. `model_fields` is a bit more specific so might be a bit more interpretable than `state`. For users this is only a question of documentation of boundary condition forcing and forcing functions since they don't see the internal implementation anyways.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/985
https://github.com/CliMA/Oceananigans.jl/issues/987:3,Energy Efficiency,reduce,reduce,3,"To reduce the number of operations, the number of memory allocations, and register pressure in GPU kernels, we might want to try refactoring upwind schemes to convert this pattern. ```julia; @inline upwind_biased_product(ũ, ψᴸ, ψᴿ) = ((ũ + abs(ũ)) * ψᴸ + (ũ - abs(ũ)) * ψᴿ) / 2. @inline function momentum_flux_uv(i, j, k, grid, scheme::AbstractUpwindBiasedAdvectionScheme, u, v). ṽ = _symmetric_interpolate_xᶠᵃᵃ(i, j, k, grid, scheme, v); uᴸ = _left_biased_interpolate_yᵃᶠᵃ(i, j, k, grid, scheme, u); uᴿ = _right_biased_interpolate_yᵃᶠᵃ(i, j, k, grid, scheme, u). return Ayᵃᵃᶠ(i, j, k, grid) * upwind_biased_product(ṽ, uᴸ, uᴿ); end; ```. to something like. ```julia; @inline function momentum_flux_uv(i, j, k, grid, scheme::AbstractUpwindBiasedAdvectionScheme, u, v); ; ṽ = _symmetric_interpolate_xᶠᵃᵃ(i, j, k, grid, scheme, v); u = ṽ > 0 ? _left_biased_interpolate_yᵃᶠᵃ(i, j, k, grid, scheme, u) :; _right_biased_interpolate_yᵃᶠᵃ(i, j, k, grid, scheme, u); ; return Ayᵃᵃᶠ(i, j, k, grid) * ṽ * u; end; ```. Could save a lot of operations and register pressure for higher-order schemes. I actually don't see why `((ũ + abs(ũ)) * ψᴸ + (ũ - abs(ũ)) * ψᴿ) / 2` is used instead of if-statements. Maybe @christophernhill or @jm-c know?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/987
https://github.com/CliMA/Oceananigans.jl/issues/987:129,Modifiability,refactor,refactoring,129,"To reduce the number of operations, the number of memory allocations, and register pressure in GPU kernels, we might want to try refactoring upwind schemes to convert this pattern. ```julia; @inline upwind_biased_product(ũ, ψᴸ, ψᴿ) = ((ũ + abs(ũ)) * ψᴸ + (ũ - abs(ũ)) * ψᴿ) / 2. @inline function momentum_flux_uv(i, j, k, grid, scheme::AbstractUpwindBiasedAdvectionScheme, u, v). ṽ = _symmetric_interpolate_xᶠᵃᵃ(i, j, k, grid, scheme, v); uᴸ = _left_biased_interpolate_yᵃᶠᵃ(i, j, k, grid, scheme, u); uᴿ = _right_biased_interpolate_yᵃᶠᵃ(i, j, k, grid, scheme, u). return Ayᵃᵃᶠ(i, j, k, grid) * upwind_biased_product(ṽ, uᴸ, uᴿ); end; ```. to something like. ```julia; @inline function momentum_flux_uv(i, j, k, grid, scheme::AbstractUpwindBiasedAdvectionScheme, u, v); ; ṽ = _symmetric_interpolate_xᶠᵃᵃ(i, j, k, grid, scheme, v); u = ṽ > 0 ? _left_biased_interpolate_yᵃᶠᵃ(i, j, k, grid, scheme, u) :; _right_biased_interpolate_yᵃᶠᵃ(i, j, k, grid, scheme, u); ; return Ayᵃᵃᶠ(i, j, k, grid) * ṽ * u; end; ```. Could save a lot of operations and register pressure for higher-order schemes. I actually don't see why `((ũ + abs(ũ)) * ψᴸ + (ũ - abs(ũ)) * ψᴿ) / 2` is used instead of if-statements. Maybe @christophernhill or @jm-c know?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/987
https://github.com/CliMA/Oceananigans.jl/pull/988:23,Deployability,release,release,23,Would be good to tag a release once the current batch of PRs is merged.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/988
https://github.com/CliMA/Oceananigans.jl/pull/989:492,Deployability,continuous,continuous,492,"This PR overhauls the infrastructure supporting user-defined forcing functions. Many of these changes are discussed in #896 . ## `ModelForcing` is no more. The first important change is the elimination of `ModelForcing`. The `forcing` kwarg in the constructor for `IncompressibleModel` now accepts a named tuple, similar to the kwarg `boundary_conditions`. ## New default for `IncompressibleModel`. Second, functions that are passed directly to `IncompressibleModel` are assumed to have the ""continuous form"" signature. ```julia; func(x, y, z, t); ```. ## New user-facing function: `Forcing`. Third, forcing functions that deviate from this default behavior should be constructed with the function `Forcing`. Thus `SimpleForcing` is eliminated, as well as `ParameterizedForcing`. Moreover, simple-forcing-like functions can now depend on arbitrary fields interpolated to the location at which the forcing is applied. We thus support constructs like. ```julia; growth_in_sunlight(x, y, z, t, P) = exp(z) * P. plankton_forcing = Forcing(growth_in_sunlight, field_dependencies=:P); ```. provided that `:P` is in `model.tracers`. ### Docstring for `Forcing`. ```julia; """"""; Forcing(func; parameters=nothing, field_dependencies=(), discrete_form=false). Returns a forcing function added to the tendency of an Oceananigans model field. If `discrete_form=false` (the default), and neither `parameters` nor `field_dependencies`; are provided, then `func` must be callable with the signature. `func(x, y, z, t)`. where `x, y, z` are the east-west, north-south, and vertical spatial coordinates, and `t` is time.; Note that this form is also default in the constructor for `IncompressibleModel` and `Forcing` is; not needed for forcing functions of this form. If `discrete_form=false` (the default), and `field_dependencies` are provided,; the signature of `func` must include them. For example, if `field_dependencies=(:u, :S)`; (and `parameters` are _not_ provided), then `func` must be callable with the sign",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/989
https://github.com/CliMA/Oceananigans.jl/pull/989:828,Integrability,depend,depend,828,"This PR overhauls the infrastructure supporting user-defined forcing functions. Many of these changes are discussed in #896 . ## `ModelForcing` is no more. The first important change is the elimination of `ModelForcing`. The `forcing` kwarg in the constructor for `IncompressibleModel` now accepts a named tuple, similar to the kwarg `boundary_conditions`. ## New default for `IncompressibleModel`. Second, functions that are passed directly to `IncompressibleModel` are assumed to have the ""continuous form"" signature. ```julia; func(x, y, z, t); ```. ## New user-facing function: `Forcing`. Third, forcing functions that deviate from this default behavior should be constructed with the function `Forcing`. Thus `SimpleForcing` is eliminated, as well as `ParameterizedForcing`. Moreover, simple-forcing-like functions can now depend on arbitrary fields interpolated to the location at which the forcing is applied. We thus support constructs like. ```julia; growth_in_sunlight(x, y, z, t, P) = exp(z) * P. plankton_forcing = Forcing(growth_in_sunlight, field_dependencies=:P); ```. provided that `:P` is in `model.tracers`. ### Docstring for `Forcing`. ```julia; """"""; Forcing(func; parameters=nothing, field_dependencies=(), discrete_form=false). Returns a forcing function added to the tendency of an Oceananigans model field. If `discrete_form=false` (the default), and neither `parameters` nor `field_dependencies`; are provided, then `func` must be callable with the signature. `func(x, y, z, t)`. where `x, y, z` are the east-west, north-south, and vertical spatial coordinates, and `t` is time.; Note that this form is also default in the constructor for `IncompressibleModel` and `Forcing` is; not needed for forcing functions of this form. If `discrete_form=false` (the default), and `field_dependencies` are provided,; the signature of `func` must include them. For example, if `field_dependencies=(:u, :S)`; (and `parameters` are _not_ provided), then `func` must be callable with the sign",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/989
https://github.com/CliMA/Oceananigans.jl/pull/989:2433,Integrability,depend,depend,2433,"hen `func` must be callable with the signature. `func(x, y, z, t)`. where `x, y, z` are the east-west, north-south, and vertical spatial coordinates, and `t` is time.; Note that this form is also default in the constructor for `IncompressibleModel` and `Forcing` is; not needed for forcing functions of this form. If `discrete_form=false` (the default), and `field_dependencies` are provided,; the signature of `func` must include them. For example, if `field_dependencies=(:u, :S)`; (and `parameters` are _not_ provided), then `func` must be callable with the signature. `func(x, y, z, t, u, S)`. where `u` is assumed to be the `u`-velocity component, and `S` is a tracer. Note that any field; which does not have the name `u`, `v`, or `w` is assumed to be a tracer and must be present; in `model.tracers`. If `discrete_form=false` (the default) and `parameters` are provided, then the _last_ argument; to `func` must be `parameters`. For example, if `func` has no `field_dependencies` but does; depend on `parameters`, then it must be callable with the signature. `func(x, y, z, t, parameters)`. With `field_dependencies=(:u, :v, :w, :c)` and `parameters`, then `func` must be; callable with the signature. `func(x, y, z, t, u, v, w, c, parameters)`. If `discrete_form=true` then `func` must be callable with the ""discrete form"". `func(i, j, k, grid, clock, model_fields)`. where `i, j, k` is the grid point at which the forcing is applied, `grid` is `model.grid`,; `clock.time` is the current simulation time and `clock.iteration` is the current model iteration,; and `model_fields` is a `NamedTuple` with `u, v, w`, the fields in `model.tracers`,; and the fields in `model.diffusivities`, each of which is an `OffsetArray`s (or `NamedTuple`s; of `OffsetArray`s depending on the turbulence closure) of field data. When `discrete_form=true` and `parameters` _is_ specified, `func` must be callable with the signature. `func(i, j, k, grid, clock, model_fields, parameters)`; ; `parameters` is arbitr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/989
https://github.com/CliMA/Oceananigans.jl/pull/989:3201,Integrability,depend,depending,3201,"sumed to be a tracer and must be present; in `model.tracers`. If `discrete_form=false` (the default) and `parameters` are provided, then the _last_ argument; to `func` must be `parameters`. For example, if `func` has no `field_dependencies` but does; depend on `parameters`, then it must be callable with the signature. `func(x, y, z, t, parameters)`. With `field_dependencies=(:u, :v, :w, :c)` and `parameters`, then `func` must be; callable with the signature. `func(x, y, z, t, u, v, w, c, parameters)`. If `discrete_form=true` then `func` must be callable with the ""discrete form"". `func(i, j, k, grid, clock, model_fields)`. where `i, j, k` is the grid point at which the forcing is applied, `grid` is `model.grid`,; `clock.time` is the current simulation time and `clock.iteration` is the current model iteration,; and `model_fields` is a `NamedTuple` with `u, v, w`, the fields in `model.tracers`,; and the fields in `model.diffusivities`, each of which is an `OffsetArray`s (or `NamedTuple`s; of `OffsetArray`s depending on the turbulence closure) of field data. When `discrete_form=true` and `parameters` _is_ specified, `func` must be callable with the signature. `func(i, j, k, grid, clock, model_fields, parameters)`; ; `parameters` is arbitrary in principle, however GPU compilation can place; constraints on `typeof(parameters)`. Examples; =======. ```julia; # Parameterized forcing; parameterized_func(x, y, z, t, p) = p.μ * exp(z / p.λ) * cos(p.ω * t). v_forcing = Forcing(parameterized_func, parameters = (μ=42, λ=0.1, ω=π)). # Field-dependent forcing; growth_in_sunlight(x, y, z, t, P) = exp(z) * P. plankton_forcing = Forcing(growth_in_sunlight, field_dependencies=:P). # Parameterized, field-dependent forcing; tracer_relaxation(x, y, z, t, c, p) = p.μ * exp((z + p.H) / p.λ) * (p.dCdz * z - c) . c_forcing = Forcing(tracer_relaxation,; field_dependencies = :c,; parameters = (μ=1/60, λ=10, H=1000, dCdz=1)). # Unparameterized discrete-form forcing function; filtered_relaxation(i,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/989
https://github.com/CliMA/Oceananigans.jl/pull/989:3733,Integrability,depend,dependent,3733,"form"". `func(i, j, k, grid, clock, model_fields)`. where `i, j, k` is the grid point at which the forcing is applied, `grid` is `model.grid`,; `clock.time` is the current simulation time and `clock.iteration` is the current model iteration,; and `model_fields` is a `NamedTuple` with `u, v, w`, the fields in `model.tracers`,; and the fields in `model.diffusivities`, each of which is an `OffsetArray`s (or `NamedTuple`s; of `OffsetArray`s depending on the turbulence closure) of field data. When `discrete_form=true` and `parameters` _is_ specified, `func` must be callable with the signature. `func(i, j, k, grid, clock, model_fields, parameters)`; ; `parameters` is arbitrary in principle, however GPU compilation can place; constraints on `typeof(parameters)`. Examples; =======. ```julia; # Parameterized forcing; parameterized_func(x, y, z, t, p) = p.μ * exp(z / p.λ) * cos(p.ω * t). v_forcing = Forcing(parameterized_func, parameters = (μ=42, λ=0.1, ω=π)). # Field-dependent forcing; growth_in_sunlight(x, y, z, t, P) = exp(z) * P. plankton_forcing = Forcing(growth_in_sunlight, field_dependencies=:P). # Parameterized, field-dependent forcing; tracer_relaxation(x, y, z, t, c, p) = p.μ * exp((z + p.H) / p.λ) * (p.dCdz * z - c) . c_forcing = Forcing(tracer_relaxation,; field_dependencies = :c,; parameters = (μ=1/60, λ=10, H=1000, dCdz=1)). # Unparameterized discrete-form forcing function; filtered_relaxation(i, j, k, grid, clock, model_fields) =; @inbounds - (model_fields.c[i-1, j, k] + model_fields.c[i, j, k] + model_fields.c[i+1, j, k]) / 3. simple_forcing = Forcing(simple_nonlinear_source, discrete_form=true). # Discrete-form forcing function with parameters; masked_damping(i, j, k, grid, clock, model_fields, parameters) = ; @inbounds - parameters.μ * exp(grid.zC[k] / parameters.λ) * model_fields.u[i, j, k]. masked_damping_forcing = Forcing(masked_damping, parameters=(μ=42, λ=π), discrete_form=true); ```. ## New object showing up in discrete-form boundary condition functions ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/989
https://github.com/CliMA/Oceananigans.jl/pull/989:3894,Integrability,depend,dependent,3894,"time` is the current simulation time and `clock.iteration` is the current model iteration,; and `model_fields` is a `NamedTuple` with `u, v, w`, the fields in `model.tracers`,; and the fields in `model.diffusivities`, each of which is an `OffsetArray`s (or `NamedTuple`s; of `OffsetArray`s depending on the turbulence closure) of field data. When `discrete_form=true` and `parameters` _is_ specified, `func` must be callable with the signature. `func(i, j, k, grid, clock, model_fields, parameters)`; ; `parameters` is arbitrary in principle, however GPU compilation can place; constraints on `typeof(parameters)`. Examples; =======. ```julia; # Parameterized forcing; parameterized_func(x, y, z, t, p) = p.μ * exp(z / p.λ) * cos(p.ω * t). v_forcing = Forcing(parameterized_func, parameters = (μ=42, λ=0.1, ω=π)). # Field-dependent forcing; growth_in_sunlight(x, y, z, t, P) = exp(z) * P. plankton_forcing = Forcing(growth_in_sunlight, field_dependencies=:P). # Parameterized, field-dependent forcing; tracer_relaxation(x, y, z, t, c, p) = p.μ * exp((z + p.H) / p.λ) * (p.dCdz * z - c) . c_forcing = Forcing(tracer_relaxation,; field_dependencies = :c,; parameters = (μ=1/60, λ=10, H=1000, dCdz=1)). # Unparameterized discrete-form forcing function; filtered_relaxation(i, j, k, grid, clock, model_fields) =; @inbounds - (model_fields.c[i-1, j, k] + model_fields.c[i, j, k] + model_fields.c[i+1, j, k]) / 3. simple_forcing = Forcing(simple_nonlinear_source, discrete_form=true). # Discrete-form forcing function with parameters; masked_damping(i, j, k, grid, clock, model_fields, parameters) = ; @inbounds - parameters.μ * exp(grid.zC[k] / parameters.λ) * model_fields.u[i, j, k]. masked_damping_forcing = Forcing(masked_damping, parameters=(μ=42, λ=π), discrete_form=true); ```. ## New object showing up in discrete-form boundary condition functions and forcing functions. Previously, discrete-form boundary condition functions and forcing functions contained an object called `state`: `state.velocit",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/989
https://github.com/CliMA/Oceananigans.jl/pull/989:757,Modifiability,Parameteriz,ParameterizedForcing,757,"This PR overhauls the infrastructure supporting user-defined forcing functions. Many of these changes are discussed in #896 . ## `ModelForcing` is no more. The first important change is the elimination of `ModelForcing`. The `forcing` kwarg in the constructor for `IncompressibleModel` now accepts a named tuple, similar to the kwarg `boundary_conditions`. ## New default for `IncompressibleModel`. Second, functions that are passed directly to `IncompressibleModel` are assumed to have the ""continuous form"" signature. ```julia; func(x, y, z, t); ```. ## New user-facing function: `Forcing`. Third, forcing functions that deviate from this default behavior should be constructed with the function `Forcing`. Thus `SimpleForcing` is eliminated, as well as `ParameterizedForcing`. Moreover, simple-forcing-like functions can now depend on arbitrary fields interpolated to the location at which the forcing is applied. We thus support constructs like. ```julia; growth_in_sunlight(x, y, z, t, P) = exp(z) * P. plankton_forcing = Forcing(growth_in_sunlight, field_dependencies=:P); ```. provided that `:P` is in `model.tracers`. ### Docstring for `Forcing`. ```julia; """"""; Forcing(func; parameters=nothing, field_dependencies=(), discrete_form=false). Returns a forcing function added to the tendency of an Oceananigans model field. If `discrete_form=false` (the default), and neither `parameters` nor `field_dependencies`; are provided, then `func` must be callable with the signature. `func(x, y, z, t)`. where `x, y, z` are the east-west, north-south, and vertical spatial coordinates, and `t` is time.; Note that this form is also default in the constructor for `IncompressibleModel` and `Forcing` is; not needed for forcing functions of this form. If `discrete_form=false` (the default), and `field_dependencies` are provided,; the signature of `func` must include them. For example, if `field_dependencies=(:u, :S)`; (and `parameters` are _not_ provided), then `func` must be callable with the sign",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/989
https://github.com/CliMA/Oceananigans.jl/pull/989:3557,Modifiability,Parameteriz,Parameterized,3557,"`parameters`, then `func` must be; callable with the signature. `func(x, y, z, t, u, v, w, c, parameters)`. If `discrete_form=true` then `func` must be callable with the ""discrete form"". `func(i, j, k, grid, clock, model_fields)`. where `i, j, k` is the grid point at which the forcing is applied, `grid` is `model.grid`,; `clock.time` is the current simulation time and `clock.iteration` is the current model iteration,; and `model_fields` is a `NamedTuple` with `u, v, w`, the fields in `model.tracers`,; and the fields in `model.diffusivities`, each of which is an `OffsetArray`s (or `NamedTuple`s; of `OffsetArray`s depending on the turbulence closure) of field data. When `discrete_form=true` and `parameters` _is_ specified, `func` must be callable with the signature. `func(i, j, k, grid, clock, model_fields, parameters)`; ; `parameters` is arbitrary in principle, however GPU compilation can place; constraints on `typeof(parameters)`. Examples; =======. ```julia; # Parameterized forcing; parameterized_func(x, y, z, t, p) = p.μ * exp(z / p.λ) * cos(p.ω * t). v_forcing = Forcing(parameterized_func, parameters = (μ=42, λ=0.1, ω=π)). # Field-dependent forcing; growth_in_sunlight(x, y, z, t, P) = exp(z) * P. plankton_forcing = Forcing(growth_in_sunlight, field_dependencies=:P). # Parameterized, field-dependent forcing; tracer_relaxation(x, y, z, t, c, p) = p.μ * exp((z + p.H) / p.λ) * (p.dCdz * z - c) . c_forcing = Forcing(tracer_relaxation,; field_dependencies = :c,; parameters = (μ=1/60, λ=10, H=1000, dCdz=1)). # Unparameterized discrete-form forcing function; filtered_relaxation(i, j, k, grid, clock, model_fields) =; @inbounds - (model_fields.c[i-1, j, k] + model_fields.c[i, j, k] + model_fields.c[i+1, j, k]) / 3. simple_forcing = Forcing(simple_nonlinear_source, discrete_form=true). # Discrete-form forcing function with parameters; masked_damping(i, j, k, grid, clock, model_fields, parameters) = ; @inbounds - parameters.μ * exp(grid.zC[k] / parameters.λ) * model_fields.u",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/989
https://github.com/CliMA/Oceananigans.jl/pull/989:3873,Modifiability,Parameteriz,Parameterized,3873,"time` is the current simulation time and `clock.iteration` is the current model iteration,; and `model_fields` is a `NamedTuple` with `u, v, w`, the fields in `model.tracers`,; and the fields in `model.diffusivities`, each of which is an `OffsetArray`s (or `NamedTuple`s; of `OffsetArray`s depending on the turbulence closure) of field data. When `discrete_form=true` and `parameters` _is_ specified, `func` must be callable with the signature. `func(i, j, k, grid, clock, model_fields, parameters)`; ; `parameters` is arbitrary in principle, however GPU compilation can place; constraints on `typeof(parameters)`. Examples; =======. ```julia; # Parameterized forcing; parameterized_func(x, y, z, t, p) = p.μ * exp(z / p.λ) * cos(p.ω * t). v_forcing = Forcing(parameterized_func, parameters = (μ=42, λ=0.1, ω=π)). # Field-dependent forcing; growth_in_sunlight(x, y, z, t, P) = exp(z) * P. plankton_forcing = Forcing(growth_in_sunlight, field_dependencies=:P). # Parameterized, field-dependent forcing; tracer_relaxation(x, y, z, t, c, p) = p.μ * exp((z + p.H) / p.λ) * (p.dCdz * z - c) . c_forcing = Forcing(tracer_relaxation,; field_dependencies = :c,; parameters = (μ=1/60, λ=10, H=1000, dCdz=1)). # Unparameterized discrete-form forcing function; filtered_relaxation(i, j, k, grid, clock, model_fields) =; @inbounds - (model_fields.c[i-1, j, k] + model_fields.c[i, j, k] + model_fields.c[i+1, j, k]) / 3. simple_forcing = Forcing(simple_nonlinear_source, discrete_form=true). # Discrete-form forcing function with parameters; masked_damping(i, j, k, grid, clock, model_fields, parameters) = ; @inbounds - parameters.μ * exp(grid.zC[k] / parameters.λ) * model_fields.u[i, j, k]. masked_damping_forcing = Forcing(masked_damping, parameters=(μ=42, λ=π), discrete_form=true); ```. ## New object showing up in discrete-form boundary condition functions and forcing functions. Previously, discrete-form boundary condition functions and forcing functions contained an object called `state`: `state.velocit",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/989
https://github.com/CliMA/Oceananigans.jl/pull/989:715,Usability,Simpl,SimpleForcing,715,"This PR overhauls the infrastructure supporting user-defined forcing functions. Many of these changes are discussed in #896 . ## `ModelForcing` is no more. The first important change is the elimination of `ModelForcing`. The `forcing` kwarg in the constructor for `IncompressibleModel` now accepts a named tuple, similar to the kwarg `boundary_conditions`. ## New default for `IncompressibleModel`. Second, functions that are passed directly to `IncompressibleModel` are assumed to have the ""continuous form"" signature. ```julia; func(x, y, z, t); ```. ## New user-facing function: `Forcing`. Third, forcing functions that deviate from this default behavior should be constructed with the function `Forcing`. Thus `SimpleForcing` is eliminated, as well as `ParameterizedForcing`. Moreover, simple-forcing-like functions can now depend on arbitrary fields interpolated to the location at which the forcing is applied. We thus support constructs like. ```julia; growth_in_sunlight(x, y, z, t, P) = exp(z) * P. plankton_forcing = Forcing(growth_in_sunlight, field_dependencies=:P); ```. provided that `:P` is in `model.tracers`. ### Docstring for `Forcing`. ```julia; """"""; Forcing(func; parameters=nothing, field_dependencies=(), discrete_form=false). Returns a forcing function added to the tendency of an Oceananigans model field. If `discrete_form=false` (the default), and neither `parameters` nor `field_dependencies`; are provided, then `func` must be callable with the signature. `func(x, y, z, t)`. where `x, y, z` are the east-west, north-south, and vertical spatial coordinates, and `t` is time.; Note that this form is also default in the constructor for `IncompressibleModel` and `Forcing` is; not needed for forcing functions of this form. If `discrete_form=false` (the default), and `field_dependencies` are provided,; the signature of `func` must include them. For example, if `field_dependencies=(:u, :S)`; (and `parameters` are _not_ provided), then `func` must be callable with the sign",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/989
https://github.com/CliMA/Oceananigans.jl/pull/989:790,Usability,simpl,simple-forcing-like,790,"This PR overhauls the infrastructure supporting user-defined forcing functions. Many of these changes are discussed in #896 . ## `ModelForcing` is no more. The first important change is the elimination of `ModelForcing`. The `forcing` kwarg in the constructor for `IncompressibleModel` now accepts a named tuple, similar to the kwarg `boundary_conditions`. ## New default for `IncompressibleModel`. Second, functions that are passed directly to `IncompressibleModel` are assumed to have the ""continuous form"" signature. ```julia; func(x, y, z, t); ```. ## New user-facing function: `Forcing`. Third, forcing functions that deviate from this default behavior should be constructed with the function `Forcing`. Thus `SimpleForcing` is eliminated, as well as `ParameterizedForcing`. Moreover, simple-forcing-like functions can now depend on arbitrary fields interpolated to the location at which the forcing is applied. We thus support constructs like. ```julia; growth_in_sunlight(x, y, z, t, P) = exp(z) * P. plankton_forcing = Forcing(growth_in_sunlight, field_dependencies=:P); ```. provided that `:P` is in `model.tracers`. ### Docstring for `Forcing`. ```julia; """"""; Forcing(func; parameters=nothing, field_dependencies=(), discrete_form=false). Returns a forcing function added to the tendency of an Oceananigans model field. If `discrete_form=false` (the default), and neither `parameters` nor `field_dependencies`; are provided, then `func` must be callable with the signature. `func(x, y, z, t)`. where `x, y, z` are the east-west, north-south, and vertical spatial coordinates, and `t` is time.; Note that this form is also default in the constructor for `IncompressibleModel` and `Forcing` is; not needed for forcing functions of this form. If `discrete_form=false` (the default), and `field_dependencies` are provided,; the signature of `func` must include them. For example, if `field_dependencies=(:u, :S)`; (and `parameters` are _not_ provided), then `func` must be callable with the sign",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/989
https://github.com/CliMA/Oceananigans.jl/issues/990:121,Deployability,pipeline,pipelines,121,"It's frustrating to encounter PyCall issues (as @sandreza and @qwert2266 already have) and it puts an extra burden on CI pipelines, so we should remove the SymPy dependency for now while the generated `WENO{N}` schemes are experimental.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/990
https://github.com/CliMA/Oceananigans.jl/issues/990:162,Integrability,depend,dependency,162,"It's frustrating to encounter PyCall issues (as @sandreza and @qwert2266 already have) and it puts an extra burden on CI pipelines, so we should remove the SymPy dependency for now while the generated `WENO{N}` schemes are experimental.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/990
https://github.com/CliMA/Oceananigans.jl/issues/991:538,Availability,ERROR,ERROR,538,"Might be because I updated the `Manifest.toml` which included an upgrade to OffsetArrays v1.3.0 but @qwert2266 ran into this issue on Oceananigans v0.37.0. ```; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.0 (2020-08-01); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: MethodError: OffsetArrays.OffsetArray(::CUDA.CuArray{Float64,3}, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Tuple{DataType,DataType,DataType}) is ambiguous. Candidates:; (::Type{OffsetArrays.OffsetArray})(A::AbstractArray, inds...) in OffsetArrays at /home/alir/.julia/packages/OffsetArrays/CXQGe/src/OffsetArrays.jl:172; (::Type{OffsetArrays.OffsetArray})(underlying_data, grid::Oceananigans.Grids.AbstractGrid, loc) in Oceananigans.Fields at /home/alir/Oceananigans.jl/src/Fields/new_data.jl:33; Possible fix, define; OffsetArrays.OffsetArray(::AbstractArray, ::Oceananigans.Grids.AbstractGrid, ::Any); Stacktrace:; [1] new_data(::Type{T} where T, ::GPU, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Tuple{DataType,DataType,DataType}) at /home/alir/Oceananigans.jl/src/Fields/new_data.jl:70; [2] XFaceField(::DataType, ::GPU, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/991
https://github.com/CliMA/Oceananigans.jl/issues/991:19,Deployability,update,updated,19,"Might be because I updated the `Manifest.toml` which included an upgrade to OffsetArrays v1.3.0 but @qwert2266 ran into this issue on Oceananigans v0.37.0. ```; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.0 (2020-08-01); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: MethodError: OffsetArrays.OffsetArray(::CUDA.CuArray{Float64,3}, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Tuple{DataType,DataType,DataType}) is ambiguous. Candidates:; (::Type{OffsetArrays.OffsetArray})(A::AbstractArray, inds...) in OffsetArrays at /home/alir/.julia/packages/OffsetArrays/CXQGe/src/OffsetArrays.jl:172; (::Type{OffsetArrays.OffsetArray})(underlying_data, grid::Oceananigans.Grids.AbstractGrid, loc) in Oceananigans.Fields at /home/alir/Oceananigans.jl/src/Fields/new_data.jl:33; Possible fix, define; OffsetArrays.OffsetArray(::AbstractArray, ::Oceananigans.Grids.AbstractGrid, ::Any); Stacktrace:; [1] new_data(::Type{T} where T, ::GPU, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Tuple{DataType,DataType,DataType}) at /home/alir/Oceananigans.jl/src/Fields/new_data.jl:70; [2] XFaceField(::DataType, ::GPU, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/991
https://github.com/CliMA/Oceananigans.jl/issues/991:65,Deployability,upgrade,upgrade,65,"Might be because I updated the `Manifest.toml` which included an upgrade to OffsetArrays v1.3.0 but @qwert2266 ran into this issue on Oceananigans v0.37.0. ```; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.0 (2020-08-01); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: MethodError: OffsetArrays.OffsetArray(::CUDA.CuArray{Float64,3}, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Tuple{DataType,DataType,DataType}) is ambiguous. Candidates:; (::Type{OffsetArrays.OffsetArray})(A::AbstractArray, inds...) in OffsetArrays at /home/alir/.julia/packages/OffsetArrays/CXQGe/src/OffsetArrays.jl:172; (::Type{OffsetArrays.OffsetArray})(underlying_data, grid::Oceananigans.Grids.AbstractGrid, loc) in Oceananigans.Fields at /home/alir/Oceananigans.jl/src/Fields/new_data.jl:33; Possible fix, define; OffsetArrays.OffsetArray(::AbstractArray, ::Oceananigans.Grids.AbstractGrid, ::Any); Stacktrace:; [1] new_data(::Type{T} where T, ::GPU, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Tuple{DataType,DataType,DataType}) at /home/alir/Oceananigans.jl/src/Fields/new_data.jl:70; [2] XFaceField(::DataType, ::GPU, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/991
https://github.com/CliMA/Oceananigans.jl/issues/991:420,Deployability,release,release,420,"Might be because I updated the `Manifest.toml` which included an upgrade to OffsetArrays v1.3.0 but @qwert2266 ran into this issue on Oceananigans v0.37.0. ```; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.0 (2020-08-01); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: MethodError: OffsetArrays.OffsetArray(::CUDA.CuArray{Float64,3}, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Tuple{DataType,DataType,DataType}) is ambiguous. Candidates:; (::Type{OffsetArrays.OffsetArray})(A::AbstractArray, inds...) in OffsetArrays at /home/alir/.julia/packages/OffsetArrays/CXQGe/src/OffsetArrays.jl:172; (::Type{OffsetArrays.OffsetArray})(underlying_data, grid::Oceananigans.Grids.AbstractGrid, loc) in Oceananigans.Fields at /home/alir/Oceananigans.jl/src/Fields/new_data.jl:33; Possible fix, define; OffsetArrays.OffsetArray(::AbstractArray, ::Oceananigans.Grids.AbstractGrid, ::Any); Stacktrace:; [1] new_data(::Type{T} where T, ::GPU, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Tuple{DataType,DataType,DataType}) at /home/alir/Oceananigans.jl/src/Fields/new_data.jl:70; [2] XFaceField(::DataType, ::GPU, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/991
https://github.com/CliMA/Oceananigans.jl/pull/993:389,Availability,avail,available,389,Looks better now:. ![Square_RungeKutta3_UpwindBiasedThirdOrder_N64_CFL0 50_U+1](https://user-images.githubusercontent.com/15271942/94485679-4c3cfc80-01ac-11eb-90b1-4cf01cb5f1b5.gif). ![Square_RungeKutta3_UpwindBiasedThirdOrder_N64_CFL0 50_U-1](https://user-images.githubusercontent.com/15271942/94485715-5b23af00-01ac-11eb-8957-e47c06ace110.gif). Will post convergence plots when they are available. Resolves #986 (note there was also a bug in the right-biased interpolation function),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/993
https://github.com/CliMA/Oceananigans.jl/pull/994:534,Deployability,update,update,534,This PR adds a naive fifth-order advection scheme called `UpwindBiasedFifthOrder`. This primarily interesting to see the advantages of the WENO algorithm at the same order of accuracy. ![Square_RungeKutta3_UpwindBiasedFifthOrder_N64_CFL0 50_U+1](https://user-images.githubusercontent.com/15271942/94488260-49440b00-01b0-11eb-985f-ab8aed3892ab.gif). ![Square_RungeKutta3_UpwindBiasedFifthOrder_N64_CFL0 50_U-1](https://user-images.githubusercontent.com/15271942/94488252-46491a80-01b0-11eb-92c3-23b814e44f18.gif). Still need to. - [ ] update convergence tests to include `UpwindBiasedFifthOrder`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/994
https://github.com/CliMA/Oceananigans.jl/pull/994:553,Testability,test,tests,553,This PR adds a naive fifth-order advection scheme called `UpwindBiasedFifthOrder`. This primarily interesting to see the advantages of the WENO algorithm at the same order of accuracy. ![Square_RungeKutta3_UpwindBiasedFifthOrder_N64_CFL0 50_U+1](https://user-images.githubusercontent.com/15271942/94488260-49440b00-01b0-11eb-985f-ab8aed3892ab.gif). ![Square_RungeKutta3_UpwindBiasedFifthOrder_N64_CFL0 50_U-1](https://user-images.githubusercontent.com/15271942/94488252-46491a80-01b0-11eb-92c3-23b814e44f18.gif). Still need to. - [ ] update convergence tests to include `UpwindBiasedFifthOrder`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/994
https://github.com/CliMA/Oceananigans.jl/pull/996:114,Safety,avoid,avoid,114,We'll uncomment these lines once `WENO{N}` schemes are ready to be used. And hopefully we can figure out a way to avoid frustrating users with PyCall/Conda stuff just to use Oceananigans. Resolves #990,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/996
https://github.com/CliMA/Oceananigans.jl/pull/997:24,Availability,error,error,24,"So far we have a better error message but after trying a few different things I couldn't get `_permute_index(i, N)` to work =/. Gonna keep this open since it's becoming a high priority issue. Resolves #828",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/997
https://github.com/CliMA/Oceananigans.jl/pull/997:30,Integrability,message,message,30,"So far we have a better error message but after trying a few different things I couldn't get `_permute_index(i, N)` to work =/. Gonna keep this open since it's becoming a high priority issue. Resolves #828",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/997
https://github.com/CliMA/Oceananigans.jl/pull/999:1220,Availability,error,error,1220,"This PR extends the implementation of `IsotropicDiffusivity` to accept `AbstractField`s (such as `ComputedField`) as diffusivities and viscosities. Using this implementation with `model.velocities` or `model.tracers` requires that users instantiate the velocity and tracer fields prior to building the model. The test provided with this PR gives an example:. ```julia; arch = CPU(); grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 2, 3)) . tracer_names = (:T, :S, :c) ; u, v, w = velocities = VelocityFields(arch, grid); T, S, c = tracers = TracerFields(arch, grid, tracer_names). ν = @at (Cell, Cell, Cell) u^2 * ∂z(T); κ = @at (Cell, Cell, Cell) S * c * sin(T). closure = IsotropicDiffusivity(ν = ComputedField(ν),; κ = ComputedField(κ)). model = IncompressibleModel(architecture=arch, grid=grid, closure=closure,; velocities=velocities, tracers=tracers); ```. A major gotcha with this implementation is that users _must_ pass the velocity and tracer fields on to `IncompressibleModel` (or the prescribed viscosity will be meaningless. We should probably also ensure that diffusivities-as-`Field`s are located at `Cell, Cell, Cell`, as the viscous and diffusive flux operators assume. A way we can prevent this error is to check that `ComputedField` viscosities or diffusivities contain references to `model.velocities` or `model.tracers`. However, this could --- in principle anyways --- exclude valid cases. I'm happy to merge as-is, or to make the implementation more robust, somehow. Possible todo:. - [ ] Allow specification of `AbstractOperation`s rather than `ComputedField`s in `IsotropicDiffusivity` constructor; - [ ] Check that `Field`-viscosities and diffusivities have correct location in `IsotropicDiffusivity` constructor; - [ ] Make implementation more robust / less error-prone?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/999
https://github.com/CliMA/Oceananigans.jl/pull/999:1480,Availability,robust,robust,1480,"This PR extends the implementation of `IsotropicDiffusivity` to accept `AbstractField`s (such as `ComputedField`) as diffusivities and viscosities. Using this implementation with `model.velocities` or `model.tracers` requires that users instantiate the velocity and tracer fields prior to building the model. The test provided with this PR gives an example:. ```julia; arch = CPU(); grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 2, 3)) . tracer_names = (:T, :S, :c) ; u, v, w = velocities = VelocityFields(arch, grid); T, S, c = tracers = TracerFields(arch, grid, tracer_names). ν = @at (Cell, Cell, Cell) u^2 * ∂z(T); κ = @at (Cell, Cell, Cell) S * c * sin(T). closure = IsotropicDiffusivity(ν = ComputedField(ν),; κ = ComputedField(κ)). model = IncompressibleModel(architecture=arch, grid=grid, closure=closure,; velocities=velocities, tracers=tracers); ```. A major gotcha with this implementation is that users _must_ pass the velocity and tracer fields on to `IncompressibleModel` (or the prescribed viscosity will be meaningless. We should probably also ensure that diffusivities-as-`Field`s are located at `Cell, Cell, Cell`, as the viscous and diffusive flux operators assume. A way we can prevent this error is to check that `ComputedField` viscosities or diffusivities contain references to `model.velocities` or `model.tracers`. However, this could --- in principle anyways --- exclude valid cases. I'm happy to merge as-is, or to make the implementation more robust, somehow. Possible todo:. - [ ] Allow specification of `AbstractOperation`s rather than `ComputedField`s in `IsotropicDiffusivity` constructor; - [ ] Check that `Field`-viscosities and diffusivities have correct location in `IsotropicDiffusivity` constructor; - [ ] Make implementation more robust / less error-prone?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/999
https://github.com/CliMA/Oceananigans.jl/pull/999:1778,Availability,robust,robust,1778,"This PR extends the implementation of `IsotropicDiffusivity` to accept `AbstractField`s (such as `ComputedField`) as diffusivities and viscosities. Using this implementation with `model.velocities` or `model.tracers` requires that users instantiate the velocity and tracer fields prior to building the model. The test provided with this PR gives an example:. ```julia; arch = CPU(); grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 2, 3)) . tracer_names = (:T, :S, :c) ; u, v, w = velocities = VelocityFields(arch, grid); T, S, c = tracers = TracerFields(arch, grid, tracer_names). ν = @at (Cell, Cell, Cell) u^2 * ∂z(T); κ = @at (Cell, Cell, Cell) S * c * sin(T). closure = IsotropicDiffusivity(ν = ComputedField(ν),; κ = ComputedField(κ)). model = IncompressibleModel(architecture=arch, grid=grid, closure=closure,; velocities=velocities, tracers=tracers); ```. A major gotcha with this implementation is that users _must_ pass the velocity and tracer fields on to `IncompressibleModel` (or the prescribed viscosity will be meaningless. We should probably also ensure that diffusivities-as-`Field`s are located at `Cell, Cell, Cell`, as the viscous and diffusive flux operators assume. A way we can prevent this error is to check that `ComputedField` viscosities or diffusivities contain references to `model.velocities` or `model.tracers`. However, this could --- in principle anyways --- exclude valid cases. I'm happy to merge as-is, or to make the implementation more robust, somehow. Possible todo:. - [ ] Allow specification of `AbstractOperation`s rather than `ComputedField`s in `IsotropicDiffusivity` constructor; - [ ] Check that `Field`-viscosities and diffusivities have correct location in `IsotropicDiffusivity` constructor; - [ ] Make implementation more robust / less error-prone?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/999
https://github.com/CliMA/Oceananigans.jl/pull/999:1792,Availability,error,error-prone,1792,"This PR extends the implementation of `IsotropicDiffusivity` to accept `AbstractField`s (such as `ComputedField`) as diffusivities and viscosities. Using this implementation with `model.velocities` or `model.tracers` requires that users instantiate the velocity and tracer fields prior to building the model. The test provided with this PR gives an example:. ```julia; arch = CPU(); grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 2, 3)) . tracer_names = (:T, :S, :c) ; u, v, w = velocities = VelocityFields(arch, grid); T, S, c = tracers = TracerFields(arch, grid, tracer_names). ν = @at (Cell, Cell, Cell) u^2 * ∂z(T); κ = @at (Cell, Cell, Cell) S * c * sin(T). closure = IsotropicDiffusivity(ν = ComputedField(ν),; κ = ComputedField(κ)). model = IncompressibleModel(architecture=arch, grid=grid, closure=closure,; velocities=velocities, tracers=tracers); ```. A major gotcha with this implementation is that users _must_ pass the velocity and tracer fields on to `IncompressibleModel` (or the prescribed viscosity will be meaningless. We should probably also ensure that diffusivities-as-`Field`s are located at `Cell, Cell, Cell`, as the viscous and diffusive flux operators assume. A way we can prevent this error is to check that `ComputedField` viscosities or diffusivities contain references to `model.velocities` or `model.tracers`. However, this could --- in principle anyways --- exclude valid cases. I'm happy to merge as-is, or to make the implementation more robust, somehow. Possible todo:. - [ ] Allow specification of `AbstractOperation`s rather than `ComputedField`s in `IsotropicDiffusivity` constructor; - [ ] Check that `Field`-viscosities and diffusivities have correct location in `IsotropicDiffusivity` constructor; - [ ] Make implementation more robust / less error-prone?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/999
https://github.com/CliMA/Oceananigans.jl/pull/999:8,Modifiability,extend,extends,8,"This PR extends the implementation of `IsotropicDiffusivity` to accept `AbstractField`s (such as `ComputedField`) as diffusivities and viscosities. Using this implementation with `model.velocities` or `model.tracers` requires that users instantiate the velocity and tracer fields prior to building the model. The test provided with this PR gives an example:. ```julia; arch = CPU(); grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 2, 3)) . tracer_names = (:T, :S, :c) ; u, v, w = velocities = VelocityFields(arch, grid); T, S, c = tracers = TracerFields(arch, grid, tracer_names). ν = @at (Cell, Cell, Cell) u^2 * ∂z(T); κ = @at (Cell, Cell, Cell) S * c * sin(T). closure = IsotropicDiffusivity(ν = ComputedField(ν),; κ = ComputedField(κ)). model = IncompressibleModel(architecture=arch, grid=grid, closure=closure,; velocities=velocities, tracers=tracers); ```. A major gotcha with this implementation is that users _must_ pass the velocity and tracer fields on to `IncompressibleModel` (or the prescribed viscosity will be meaningless. We should probably also ensure that diffusivities-as-`Field`s are located at `Cell, Cell, Cell`, as the viscous and diffusive flux operators assume. A way we can prevent this error is to check that `ComputedField` viscosities or diffusivities contain references to `model.velocities` or `model.tracers`. However, this could --- in principle anyways --- exclude valid cases. I'm happy to merge as-is, or to make the implementation more robust, somehow. Possible todo:. - [ ] Allow specification of `AbstractOperation`s rather than `ComputedField`s in `IsotropicDiffusivity` constructor; - [ ] Check that `Field`-viscosities and diffusivities have correct location in `IsotropicDiffusivity` constructor; - [ ] Make implementation more robust / less error-prone?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/999
https://github.com/CliMA/Oceananigans.jl/pull/999:313,Testability,test,test,313,"This PR extends the implementation of `IsotropicDiffusivity` to accept `AbstractField`s (such as `ComputedField`) as diffusivities and viscosities. Using this implementation with `model.velocities` or `model.tracers` requires that users instantiate the velocity and tracer fields prior to building the model. The test provided with this PR gives an example:. ```julia; arch = CPU(); grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 2, 3)) . tracer_names = (:T, :S, :c) ; u, v, w = velocities = VelocityFields(arch, grid); T, S, c = tracers = TracerFields(arch, grid, tracer_names). ν = @at (Cell, Cell, Cell) u^2 * ∂z(T); κ = @at (Cell, Cell, Cell) S * c * sin(T). closure = IsotropicDiffusivity(ν = ComputedField(ν),; κ = ComputedField(κ)). model = IncompressibleModel(architecture=arch, grid=grid, closure=closure,; velocities=velocities, tracers=tracers); ```. A major gotcha with this implementation is that users _must_ pass the velocity and tracer fields on to `IncompressibleModel` (or the prescribed viscosity will be meaningless. We should probably also ensure that diffusivities-as-`Field`s are located at `Cell, Cell, Cell`, as the viscous and diffusive flux operators assume. A way we can prevent this error is to check that `ComputedField` viscosities or diffusivities contain references to `model.velocities` or `model.tracers`. However, this could --- in principle anyways --- exclude valid cases. I'm happy to merge as-is, or to make the implementation more robust, somehow. Possible todo:. - [ ] Allow specification of `AbstractOperation`s rather than `ComputedField`s in `IsotropicDiffusivity` constructor; - [ ] Check that `Field`-viscosities and diffusivities have correct location in `IsotropicDiffusivity` constructor; - [ ] Make implementation more robust / less error-prone?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/999
https://github.com/CliMA/Oceananigans.jl/issues/1001:665,Availability,error,error,665,"At the moment, to solve equations on a two-dimensional grid one has to provide `Nz=1` and any `Lz` they wish. For example, giving `Lz=2e-16` works pretty well:. ```julia; julia> grid = RegularCartesianGrid(size=(128, 128, 1), extent=(2π, 2π, eps(Float64))); RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 6.283185307179586], y ∈ [0.0, 6.283185307179586], z ∈ [-2.220446049250313e-16, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (128, 128, 1); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (0.04908738521234052, 0.04908738521234052, 2.220446049250313e-16); ```. However, `Lz=0` spits out an error...; ```julia; julia> grid = RegularCartesianGrid(size=(128, 128, 1), extent=(2π, 2π, 0)); ERROR: ArgumentError: Elements of extent=(6.283185307179586, 6.283185307179586, 0) must be > 0!; Stacktrace:; [1] validate_tupled_argument at /Users/navid/Research/Oceananigans.jl/src/Grids/grid_utils.jl:306 [inlined]; [2] validate_regular_grid_size_and_extent(::Type{T} where T, ::Tuple{Int64,Int64,Int64}, ::Tuple{Float64,Float64,Int64}, ::Tuple{Int64,Int64,Int64}, ::Nothing, ::Nothing, ::Nothing) at /Users/navid/Research/Oceananigans.jl/src/Grids/grid_utils.jl:330; [3] RegularCartesianGrid(::Type{T} where T; size::Tuple{Int64,Int64,Int64}, x::Nothing, y::Nothing, z::Nothing, extent::Tuple{Float64,Float64,Int64}, topology::Tuple{DataType,DataType,DataType}, halo::Tuple{Int64,Int64,Int64}) at /Users/navid/Research/Oceananigans.jl/src/Grids/regular_cartesian_grid.jl:126; [4] top-level scope at REPL[33]:1; ```. Perhaps it makes sense that there should be a check and each dimension that has extent =0 and number of grid-points =1 should be treated ""specially"" and bypass the validation at https://github.com/CliMA/Oceananigans.jl/blob/e808a821d78949b0482b8372533e992cabb5d65f/src/Grids/grid_utils.jl#L306?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1001
https://github.com/CliMA/Oceananigans.jl/issues/1001:761,Availability,ERROR,ERROR,761,"At the moment, to solve equations on a two-dimensional grid one has to provide `Nz=1` and any `Lz` they wish. For example, giving `Lz=2e-16` works pretty well:. ```julia; julia> grid = RegularCartesianGrid(size=(128, 128, 1), extent=(2π, 2π, eps(Float64))); RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 6.283185307179586], y ∈ [0.0, 6.283185307179586], z ∈ [-2.220446049250313e-16, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (128, 128, 1); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (0.04908738521234052, 0.04908738521234052, 2.220446049250313e-16); ```. However, `Lz=0` spits out an error...; ```julia; julia> grid = RegularCartesianGrid(size=(128, 128, 1), extent=(2π, 2π, 0)); ERROR: ArgumentError: Elements of extent=(6.283185307179586, 6.283185307179586, 0) must be > 0!; Stacktrace:; [1] validate_tupled_argument at /Users/navid/Research/Oceananigans.jl/src/Grids/grid_utils.jl:306 [inlined]; [2] validate_regular_grid_size_and_extent(::Type{T} where T, ::Tuple{Int64,Int64,Int64}, ::Tuple{Float64,Float64,Int64}, ::Tuple{Int64,Int64,Int64}, ::Nothing, ::Nothing, ::Nothing) at /Users/navid/Research/Oceananigans.jl/src/Grids/grid_utils.jl:330; [3] RegularCartesianGrid(::Type{T} where T; size::Tuple{Int64,Int64,Int64}, x::Nothing, y::Nothing, z::Nothing, extent::Tuple{Float64,Float64,Int64}, topology::Tuple{DataType,DataType,DataType}, halo::Tuple{Int64,Int64,Int64}) at /Users/navid/Research/Oceananigans.jl/src/Grids/regular_cartesian_grid.jl:126; [4] top-level scope at REPL[33]:1; ```. Perhaps it makes sense that there should be a check and each dimension that has extent =0 and number of grid-points =1 should be treated ""specially"" and bypass the validation at https://github.com/CliMA/Oceananigans.jl/blob/e808a821d78949b0482b8372533e992cabb5d65f/src/Grids/grid_utils.jl#L306?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1001
https://github.com/CliMA/Oceananigans.jl/issues/1001:1745,Security,validat,validation,1745,"At the moment, to solve equations on a two-dimensional grid one has to provide `Nz=1` and any `Lz` they wish. For example, giving `Lz=2e-16` works pretty well:. ```julia; julia> grid = RegularCartesianGrid(size=(128, 128, 1), extent=(2π, 2π, eps(Float64))); RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 6.283185307179586], y ∈ [0.0, 6.283185307179586], z ∈ [-2.220446049250313e-16, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (128, 128, 1); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (0.04908738521234052, 0.04908738521234052, 2.220446049250313e-16); ```. However, `Lz=0` spits out an error...; ```julia; julia> grid = RegularCartesianGrid(size=(128, 128, 1), extent=(2π, 2π, 0)); ERROR: ArgumentError: Elements of extent=(6.283185307179586, 6.283185307179586, 0) must be > 0!; Stacktrace:; [1] validate_tupled_argument at /Users/navid/Research/Oceananigans.jl/src/Grids/grid_utils.jl:306 [inlined]; [2] validate_regular_grid_size_and_extent(::Type{T} where T, ::Tuple{Int64,Int64,Int64}, ::Tuple{Float64,Float64,Int64}, ::Tuple{Int64,Int64,Int64}, ::Nothing, ::Nothing, ::Nothing) at /Users/navid/Research/Oceananigans.jl/src/Grids/grid_utils.jl:330; [3] RegularCartesianGrid(::Type{T} where T; size::Tuple{Int64,Int64,Int64}, x::Nothing, y::Nothing, z::Nothing, extent::Tuple{Float64,Float64,Int64}, topology::Tuple{DataType,DataType,DataType}, halo::Tuple{Int64,Int64,Int64}) at /Users/navid/Research/Oceananigans.jl/src/Grids/regular_cartesian_grid.jl:126; [4] top-level scope at REPL[33]:1; ```. Perhaps it makes sense that there should be a check and each dimension that has extent =0 and number of grid-points =1 should be treated ""specially"" and bypass the validation at https://github.com/CliMA/Oceananigans.jl/blob/e808a821d78949b0482b8372533e992cabb5d65f/src/Grids/grid_utils.jl#L306?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1001
https://github.com/CliMA/Oceananigans.jl/issues/1002:1362,Integrability,wrap,wrap,1362,"`Oceananigans.TurbulenceClosures` is a bit messy right now. One big issue is that we have two implementations of `AnisotropicMinimumDissipation`. I think we should commit to `VerstappenAnisotropicMinimumDissipation`, and possibly change its name to just `AnisotropicMinimumDissipation`. We should also probably only support one version of `Smagorinsky`. We have an implementation of the Smagorinsky model that is _apparently_ used by the UK Met Office's Large Eddy Model (LEM), aka ""BLASIUS"" (`blasius_smagorinsky.jl`). But we never use this model and its untested. It's no small piece of work to really test all that code. Maybe we should delete it and just keep the much more common and popular `smagorinsky_lilly.jl`? We can also delete the alias `ConstantSmagorinsky`. Some functions should probably be shuffled around: all of the code in `closure_operators.jl` should be moved to `viscous_dissipation_operators.jl` and `diffusion_operators`. Also to be consistent we should rename `viscous_dissipation_operators.jl` to `viscosity_operators.jl` (or at the least, `viscous_friction_operators.jl`. The functions in `closure_operators.jl` also need to be converted to finite-volume form. I think the implementation of those functions can also be simplified to accept an isotropic viscosity rather than the entire `diffusivities` object. We should also probably wrap all of the closures in their own submodules? Or maybe not... The implementation for tupled closures is also split into the top-level file and `closure_tuples.jl`. We should put the whole thing in `closure_tuples.jl`. What else?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1002
https://github.com/CliMA/Oceananigans.jl/issues/1002:604,Testability,test,test,604,"`Oceananigans.TurbulenceClosures` is a bit messy right now. One big issue is that we have two implementations of `AnisotropicMinimumDissipation`. I think we should commit to `VerstappenAnisotropicMinimumDissipation`, and possibly change its name to just `AnisotropicMinimumDissipation`. We should also probably only support one version of `Smagorinsky`. We have an implementation of the Smagorinsky model that is _apparently_ used by the UK Met Office's Large Eddy Model (LEM), aka ""BLASIUS"" (`blasius_smagorinsky.jl`). But we never use this model and its untested. It's no small piece of work to really test all that code. Maybe we should delete it and just keep the much more common and popular `smagorinsky_lilly.jl`? We can also delete the alias `ConstantSmagorinsky`. Some functions should probably be shuffled around: all of the code in `closure_operators.jl` should be moved to `viscous_dissipation_operators.jl` and `diffusion_operators`. Also to be consistent we should rename `viscous_dissipation_operators.jl` to `viscosity_operators.jl` (or at the least, `viscous_friction_operators.jl`. The functions in `closure_operators.jl` also need to be converted to finite-volume form. I think the implementation of those functions can also be simplified to accept an isotropic viscosity rather than the entire `diffusivities` object. We should also probably wrap all of the closures in their own submodules? Or maybe not... The implementation for tupled closures is also split into the top-level file and `closure_tuples.jl`. We should put the whole thing in `closure_tuples.jl`. What else?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1002
https://github.com/CliMA/Oceananigans.jl/issues/1002:1247,Usability,simpl,simplified,1247,"`Oceananigans.TurbulenceClosures` is a bit messy right now. One big issue is that we have two implementations of `AnisotropicMinimumDissipation`. I think we should commit to `VerstappenAnisotropicMinimumDissipation`, and possibly change its name to just `AnisotropicMinimumDissipation`. We should also probably only support one version of `Smagorinsky`. We have an implementation of the Smagorinsky model that is _apparently_ used by the UK Met Office's Large Eddy Model (LEM), aka ""BLASIUS"" (`blasius_smagorinsky.jl`). But we never use this model and its untested. It's no small piece of work to really test all that code. Maybe we should delete it and just keep the much more common and popular `smagorinsky_lilly.jl`? We can also delete the alias `ConstantSmagorinsky`. Some functions should probably be shuffled around: all of the code in `closure_operators.jl` should be moved to `viscous_dissipation_operators.jl` and `diffusion_operators`. Also to be consistent we should rename `viscous_dissipation_operators.jl` to `viscosity_operators.jl` (or at the least, `viscous_friction_operators.jl`. The functions in `closure_operators.jl` also need to be converted to finite-volume form. I think the implementation of those functions can also be simplified to accept an isotropic viscosity rather than the entire `diffusivities` object. We should also probably wrap all of the closures in their own submodules? Or maybe not... The implementation for tupled closures is also split into the top-level file and `closure_tuples.jl`. We should put the whole thing in `closure_tuples.jl`. What else?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1002
https://github.com/CliMA/Oceananigans.jl/pull/1003:1361,Performance,optimiz,optimization,1361,"This PR increases our support for `Flat` dimensions of `RegularCartesianGrid`. When topology in a direction is `Flat`, the halo size is set to 0, the grid size to 1, and halo filling, interpolation, and differences are all elided. Two new examples in the docstring for `RegularCartesianGrid` illustrate it's use:. * A two-dimenisional, horizontally-periodic grid:. ```julia; julia> using Oceananigans. julia> grid = RegularCartesianGrid(size=(32, 32), extent=(2π, 4π), topology=(Periodic, Periodic, Flat)); RegularCartesianGrid{Float64, Periodic, Periodic, Flat}; domain: x ∈ [0.0, 6.283185307179586], y ∈ [0.0, 12.566370614359172], z ∈ [0.0, 0.0]; topology: (Periodic, Periodic, Flat); resolution (Nx, Ny, Nz): (32, 32, 1); halo size (Hx, Hy, Hz): (1, 1, 0); grid spacing (Δx, Δy, Δz): (0.19634954084936207, 0.39269908169872414, 0.0); ```. * A one-dimensional ""column"" grid:. ```julia; julia> using Oceananigans. julia> grid = RegularCartesianGrid(size=256, z=(-128, 0), topology=(Flat, Flat, Bounded)); RegularCartesianGrid{Float64, Flat, Flat, Bounded}; domain: x ∈ [0.0, 0.0], y ∈ [0.0, 0.0], z ∈ [-128.0, 0.0]; topology: (Flat, Flat, Bounded); resolution (Nx, Ny, Nz): (1, 1, 256); halo size (Hx, Hy, Hz): (0, 0, 1); grid spacing (Δx, Δy, Δz): (0.0, 0.0, 0.5); ```. In principle we can also eliminate the pressure solver for column models. I'll leave this optimization for a future PR. Resolves #902 ; Resolves #940 ; Resolves #1001; Resolves #35",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1003
https://github.com/CliMA/Oceananigans.jl/issues/1004:402,Availability,error,error,402,"It looks like the Langmuir turbulence example is broken (the video generated in the documentation is blank and it does not run on my computer). I think it may be these two lines where the halo regions for each variable are manually removed, but Oceananigans seems to have already extracted those halo regions. This causes the variable and coordinate arrays to be different sizes, leading to a plotting error. https://github.com/CliMA/Oceananigans.jl/blob/24e9c2c3c85cc092913989d6c88d38046998aa07/examples/langmuir_turbulence.jl#L277-L278",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1004
https://github.com/CliMA/Oceananigans.jl/issues/1004:210,Modifiability,variab,variable,210,"It looks like the Langmuir turbulence example is broken (the video generated in the documentation is blank and it does not run on my computer). I think it may be these two lines where the halo regions for each variable are manually removed, but Oceananigans seems to have already extracted those halo regions. This causes the variable and coordinate arrays to be different sizes, leading to a plotting error. https://github.com/CliMA/Oceananigans.jl/blob/24e9c2c3c85cc092913989d6c88d38046998aa07/examples/langmuir_turbulence.jl#L277-L278",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1004
https://github.com/CliMA/Oceananigans.jl/issues/1004:326,Modifiability,variab,variable,326,"It looks like the Langmuir turbulence example is broken (the video generated in the documentation is blank and it does not run on my computer). I think it may be these two lines where the halo regions for each variable are manually removed, but Oceananigans seems to have already extracted those halo regions. This causes the variable and coordinate arrays to be different sizes, leading to a plotting error. https://github.com/CliMA/Oceananigans.jl/blob/24e9c2c3c85cc092913989d6c88d38046998aa07/examples/langmuir_turbulence.jl#L277-L278",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1004
https://github.com/CliMA/Oceananigans.jl/issues/1007:118,Modifiability,enhance,enhancement,118,"I believe currently the pressure solved cannot work on GPU when grid has `topology = (Bounded, Bounded, Bounded)`. An enhancement so such topologies can run on GPUs would be great.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1007
https://github.com/CliMA/Oceananigans.jl/issues/1008:211,Availability,Checkpoint,Checkpointer,211,"Reported by @qwert2266. Would happen to any model property that is part of; ```; properties = [:architecture, :grid, :clock, :coriolis, :buoyancy, :closure, :velocities, :tracers, :timestepper]; ```; passed to `Checkpointer` upon construction. https://github.com/CliMA/Oceananigans.jl/blob/ac3130e84ac132daaacbd428ea6450beb9b330aa/src/OutputWriters/checkpointer.jl#L186-L189",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1008
https://github.com/CliMA/Oceananigans.jl/issues/1008:349,Availability,checkpoint,checkpointer,349,"Reported by @qwert2266. Would happen to any model property that is part of; ```; properties = [:architecture, :grid, :clock, :coriolis, :buoyancy, :closure, :velocities, :tracers, :timestepper]; ```; passed to `Checkpointer` upon construction. https://github.com/CliMA/Oceananigans.jl/blob/ac3130e84ac132daaacbd428ea6450beb9b330aa/src/OutputWriters/checkpointer.jl#L186-L189",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1008
https://github.com/CliMA/Oceananigans.jl/issues/1010:43,Availability,fault,fault,43,"Also reported by @qwert2266 but this is my fault since GitLab CI doesn't seem to be actually running GPU tests... Using something like; ```julia; @inline FT(x, y, z, t, T, p) = - exp(z/p.ℓ) * 2p.K/p.Δz^2 * T; T_forcing = Forcing(FT, field_dependencies=:T, parameters=bc_params); forcing = (T=T_forcing,); ```. causes. ```; ERROR: LoadError: GPU compilation of kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!), OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, Oceananigans.Advection.CenteredSecondOrder, NonTraditionalFPlane{Float64}, Nothing, AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}}, NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, Nothing, NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:323,Availability,ERROR,ERROR,323,"Also reported by @qwert2266 but this is my fault since GitLab CI doesn't seem to be actually running GPU tests... Using something like; ```julia; @inline FT(x, y, z, t, T, p) = - exp(z/p.ℓ) * 2p.K/p.Δz^2 * T; T_forcing = Forcing(FT, field_dependencies=:T, parameters=bc_params); forcing = (T=T_forcing,); ```. causes. ```; ERROR: LoadError: GPU compilation of kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!), OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, Oceananigans.Advection.CenteredSecondOrder, NonTraditionalFPlane{Float64}, Nothing, AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}}, NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, Nothing, NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:1811,Deployability,Continuous,ContinuousForcing,1811,"eof(Oceananigans.TimeSteppers.gpu_calculate_Gu!), OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, Oceananigans.Advection.CenteredSecondOrder, NonTraditionalFPlane{Float64}, Nothing, AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}}, NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, Nothing, NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}}, OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}, NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}) failed; KernelError: passing and using non-bitstype argument. Argument 13 to your kernel function is of type NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.For",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:1984,Deployability,Continuous,ContinuousForcing,1984,"iodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, Oceananigans.Advection.CenteredSecondOrder, NonTraditionalFPlane{Float64}, Nothing, AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}}, NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, Nothing, NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}}, OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}, NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}) failed; KernelError: passing and using non-bitstype argument. Argument 13 to your kernel function is of type NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.For",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:2157,Deployability,Continuous,ContinuousForcing,2157,"r, NonTraditionalFPlane{Float64}, Nothing, AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}}, NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, Nothing, NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}}, OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}, NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}) failed; KernelError: passing and using non-bitstype argument. Argument 13 to your kernel function is of type NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.For",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:2330,Deployability,Continuous,ContinuousForcing,2330,"Tuple{Float64}}}, NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, Nothing, NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}}, OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}, NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}) failed; KernelError: passing and using non-bitstype argument. Argument 13 to your kernel function is of type NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.For",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:2833,Deployability,Continuous,ContinuousForcing,2833,"Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}}, OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}, NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}) failed; KernelError: passing and using non-bitstype argument. Argument 13 to your kernel function is of type NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}}, which is not isbits:; .T is of type Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}} which is not isbits.; .field_dependencies is of type Tuple{Symbol}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:3006,Deployability,Continuous,ContinuousForcing,3006,"Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}}, OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}, NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}) failed; KernelError: passing and using non-bitstype argument. Argument 13 to your kernel function is of type NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}}, which is not isbits:; .T is of type Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}} which is not isbits.; .field_dependencies is of type Tuple{Symbol} which is not isbits.; .1 is of type Symbol which is not isbits. Passing non-isbits types is only allowed if they they are unused by the kernel. Stacktrace:; [1] check_invoc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:3179,Deployability,Continuous,ContinuousForcing,3179,"Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}}, OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}, NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}) failed; KernelError: passing and using non-bitstype argument. Argument 13 to your kernel function is of type NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}}, which is not isbits:; .T is of type Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}} which is not isbits.; .field_dependencies is of type Tuple{Symbol} which is not isbits.; .1 is of type Symbol which is not isbits. Passing non-isbits types is only allowed if they they are unused by the kernel. Stacktrace:; [1] check_invocation(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Function) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/validation.j",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:3352,Deployability,Continuous,ContinuousForcing,3352,"Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}}, OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}, NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}) failed; KernelError: passing and using non-bitstype argument. Argument 13 to your kernel function is of type NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}}, which is not isbits:; .T is of type Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}} which is not isbits.; .field_dependencies is of type Tuple{Symbol} which is not isbits.; .1 is of type Symbol which is not isbits. Passing non-isbits types is only allowed if they they are unused by the kernel. Stacktrace:; [1] check_invocation(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Function) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/validation.jl:75; [2] macro expansion at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:240 [inlined]; [3] macro expansion at /home/ptuckman/.julia/packages/TimerOutputs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:3598,Deployability,Continuous,ContinuousForcing,3598,"time, :iteration, :stage),Tuple{Float64,Int64,Int64}}) failed; KernelError: passing and using non-bitstype argument. Argument 13 to your kernel function is of type NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}}, which is not isbits:; .T is of type Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}} which is not isbits.; .field_dependencies is of type Tuple{Symbol} which is not isbits.; .1 is of type Symbol which is not isbits. Passing non-isbits types is only allowed if they they are unused by the kernel. Stacktrace:; [1] check_invocation(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Function) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/validation.jl:75; [2] macro expansion at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:240 [inlined]; [3] macro expansion at /home/ptuckman/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Boo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:6547,Deployability,Continuous,ContinuousForcing,6547,"Hooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Oceananigans.Advection.CenteredSecondOrder,NonTraditionalFPlane{Float64},Nothing,AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/CUDA/dZvbp/src/compiler/exe",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:6720,Deployability,Continuous,ContinuousForcing,6720,"odic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Oceananigans.Advection.CenteredSecondOrder,NonTraditionalFPlane{Float64},Nothing,AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/CUDA/dZvbp/src/compiler/execution.jl:310; [8] #87 at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:21 [inlined]; [9] get!(::GPUCompiler.var""#87#88""{Base.Iterators.Pairs{Symbol,Int64,Tu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:6893,Deployability,Continuous,ContinuousForcing,6893,"ondOrder,NonTraditionalFPlane{Float64},Nothing,AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/CUDA/dZvbp/src/compiler/execution.jl:310; [8] #87 at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:21 [inlined]; [9] get!(::GPUCompiler.var""#87#88""{Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}},typeof(CUDA._cufunction),GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),Kern",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:7066,Deployability,Continuous,ContinuousForcing,7066,"T,),Tuple{Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/CUDA/dZvbp/src/compiler/execution.jl:310; [8] #87 at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:21 [inlined]; [9] get!(::GPUCompiler.var""#87#88""{Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}},typeof(CUDA._cufunction),GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDI",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:9285,Deployability,Continuous,ContinuousForcing,9285,"Hooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Oceananigans.Advection.CenteredSecondOrder,NonTraditionalFPlane{Float64},Nothing,AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}}, ::Dict{UInt64,Any}, ::UInt64) at ./dict.jl:452; [10] macro expansion at ./lock.jl:183 [inlined]; [11] check_cache(::typeof(CUDA._cufunction), ::GPUCompiler.Fu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:9458,Deployability,Continuous,ContinuousForcing,9458,"odic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Oceananigans.Advection.CenteredSecondOrder,NonTraditionalFPlane{Float64},Nothing,AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}}, ::Dict{UInt64,Any}, ::UInt64) at ./dict.jl:452; [10] macro expansion at ./lock.jl:183 [inlined]; [11] check_cache(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},K",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:9631,Deployability,Continuous,ContinuousForcing,9631,"ondOrder,NonTraditionalFPlane{Float64},Nothing,AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}}, ::Dict{UInt64,Any}, ::UInt64) at ./dict.jl:452; [10] macro expansion at ./lock.jl:183 [inlined]; [11] check_cache(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:9804,Deployability,Continuous,ContinuousForcing,9804,"T,),Tuple{Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}}, ::Dict{UInt64,Any}, ::UInt64) at ./dict.jl:452; [10] macro expansion at ./lock.jl:183 [inlined]; [11] check_cache(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_cal",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:11758,Deployability,Continuous,ContinuousForcing,11758,"Hooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Oceananigans.Advection.CenteredSecondOrder,NonTraditionalFPlane{Float64},Nothing,AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:11931,Deployability,Continuous,ContinuousForcing,11931,"odic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Oceananigans.Advection.CenteredSecondOrder,NonTraditionalFPlane{Float64},Nothing,AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [12] + at ./int.jl:53 [inlined]; [13] hash_64_64 at ./hashing.jl:35 [inlined]; [14] hash_uint64 at ./hashing.jl:62 [inlined]; [15] hx at ./float.jl:568 [in",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:12104,Deployability,Continuous,ContinuousForcing,12104,"ondOrder,NonTraditionalFPlane{Float64},Nothing,AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [12] + at ./int.jl:53 [inlined]; [13] hash_64_64 at ./hashing.jl:35 [inlined]; [14] hash_uint64 at ./hashing.jl:62 [inlined]; [15] hx at ./float.jl:568 [inlined]; [16] hash at ./float.jl:571 [inlined]; [17] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:12277,Deployability,Continuous,ContinuousForcing,12277,"T,),Tuple{Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [12] + at ./int.jl:53 [inlined]; [13] hash_64_64 at ./hashing.jl:35 [inlined]; [14] hash_uint64 at ./hashing.jl:62 [inlined]; [15] hx at ./float.jl:568 [inlined]; [16] hash at ./float.jl:571 [inlined]; [17] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:14519,Deployability,Continuous,ContinuousForcing,14519,"Hooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Oceananigans.Advection.CenteredSecondOrder,NonTraditionalFPlane{Float64},Nothing,AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:14692,Deployability,Continuous,ContinuousForcing,14692,"odic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Oceananigans.Advection.CenteredSecondOrder,NonTraditionalFPlane{Float64},Nothing,AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:0; [18] cufunction(::typeof(Cassette.overdub), ::Type{Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIterati",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:14865,Deployability,Continuous,ContinuousForcing,14865,"ondOrder,NonTraditionalFPlane{Float64},Nothing,AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:0; [18] cufunction(::typeof(Cassette.overdub), ::Type{Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:15038,Deployability,Continuous,ContinuousForcing,15038,"T,),Tuple{Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:0; [18] cufunction(::typeof(Cassette.overdub), ::Type{Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(O",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:17024,Deployability,Continuous,ContinuousForcing,17024,"Hooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Oceananigans.Advection.CenteredSecondOrder,NonTraditionalFPlane{Float64},Nothing,AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}; name::String, kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/CUDA/dZvbp/sr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:17197,Deployability,Continuous,ContinuousForcing,17197,"odic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Oceananigans.Advection.CenteredSecondOrder,NonTraditionalFPlane{Float64},Nothing,AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}; name::String, kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/CUDA/dZvbp/src/compiler/execution.jl:298; [19] macro expansion at /home/ptuckman/.julia/packages/CUDA/dZvbp/src/compiler/execution.jl:109 [inlined]; [20] (::KernelAbstractions.Kernel{Ker",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:17370,Deployability,Continuous,ContinuousForcing,17370,"ondOrder,NonTraditionalFPlane{Float64},Nothing,AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}; name::String, kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/CUDA/dZvbp/src/compiler/execution.jl:298; [19] macro expansion at /home/ptuckman/.julia/packages/CUDA/dZvbp/src/compiler/execution.jl:109 [inlined]; [20] (::KernelAbstractions.Kernel{KernelAbstractions.CUDADevice,KernelAbstractions.NDIteration.StaticSize{(16, 16)},KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},typeof(Oceananigans.TimeSteppers.gp",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:17543,Deployability,Continuous,ContinuousForcing,17543,"T,),Tuple{Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}; name::String, kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/CUDA/dZvbp/src/compiler/execution.jl:298; [19] macro expansion at /home/ptuckman/.julia/packages/CUDA/dZvbp/src/compiler/execution.jl:109 [inlined]; [20] (::KernelAbstractions.Kernel{KernelAbstractions.CUDADevice,KernelAbstractions.NDIteration.StaticSize{(16, 16)},KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!)})(::OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, ::Vararg{Any,N} where N; ndrange::Nothing, dependencies::KernelAbstractions.CudaEvent, work",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:19767,Deployability,Continuous,ContinuousForcing,19767,"s.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}}}, ::GPU, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Oceananigans.Advection.CenteredSecondOrder, ::NonTraditionalFPlane{Float64}, ::SeawaterBuoyancy{Float64,LinearEquationOfState{Float64},Nothing,Float64}, ::Nothing, ::AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}}, ::NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}}}, ::NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}}}, ::OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, ::Nothing, ::NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}}, ::Clock{Float64}) at /home/ptuckman/.julia/packages/Oceananigans/KJCVx/src/TimeSteppers/time_stepping_kernels.jl:18; [22] calculate_tendencies!(::NamedTuple{(:u, :v, :w, :T),NTuple{4,OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}}}, ::NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float6",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:19940,Deployability,Continuous,ContinuousForcing,19940,"ase.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Oceananigans.Advection.CenteredSecondOrder, ::NonTraditionalFPlane{Float64}, ::SeawaterBuoyancy{Float64,LinearEquationOfState{Float64},Nothing,Float64}, ::Nothing, ::AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}}, ::NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}}}, ::NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}}}, ::OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, ::Nothing, ::NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}}, ::Clock{Float64}) at /home/ptuckman/.julia/packages/Oceananigans/KJCVx/src/TimeSteppers/time_stepping_kernels.jl:18; [22] calculate_tendencies!(::NamedTuple{(:u, :v, :w, :T),NTuple{4,OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}}}, ::NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}}}, ::NamedTuple{(:T,),Tu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:20113,Deployability,Continuous,ContinuousForcing,20113,"EquationOfState{Float64},Nothing,Float64}, ::Nothing, ::AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}}, ::NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}}}, ::NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}}}, ::OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, ::Nothing, ::NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}}, ::Clock{Float64}) at /home/ptuckman/.julia/packages/Oceananigans/KJCVx/src/TimeSteppers/time_stepping_kernels.jl:18; [22] calculate_tendencies!(::NamedTuple{(:u, :v, :w, :T),NTuple{4,OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}}}, ::NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}}}, ::NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}}}, ::NamedTuple{(:pHY′, :pNHS),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}},OffsetArrays",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:20286,Deployability,Continuous,ContinuousForcing,20286,"dTuple{(:T,),Tuple{Float64}}}, ::NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}}}, ::NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}}}, ::OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, ::Nothing, ::NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}}, ::Clock{Float64}) at /home/ptuckman/.julia/packages/Oceananigans/KJCVx/src/TimeSteppers/time_stepping_kernels.jl:18; [22] calculate_tendencies!(::NamedTuple{(:u, :v, :w, :T),NTuple{4,OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}}}, ::NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}}}, ::NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}}}, ::NamedTuple{(:pHY′, :pNHS),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}}}, ::Nothing, ::IncompressibleModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64,NamedTuple{(:u, :v, :w,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:29622,Deployability,Continuous,ContinuousForcing,29622,"Condition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},Oceananigans.Advection.CenteredSecondOrder,Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CUDA.CuArray{Float64,3},CUDA.CuArray{Float64,3},CUDA.CuArray{Float64,3}}},CUDA.CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IF",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:29795,Deployability,Continuous,ContinuousForcing,29795,"ans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},Oceananigans.Advection.CenteredSecondOrder,Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CUDA.CuArray{Float64,3},CUDA.CuArray{Float64,3},CUDA.CuArray{Float64,3}}},CUDA.CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPla",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:29968,Deployability,Continuous,ContinuousForcing,29968,"nded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},Oceananigans.Advection.CenteredSecondOrder,Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CUDA.CuArray{Float64,3},CUDA.CuArray{Float64,3},CUDA.CuArray{Float64,3}}},CUDA.CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tupl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:30141,Deployability,Continuous,ContinuousForcing,30141,"ditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},Oceananigans.Advection.CenteredSecondOrder,Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CUDA.CuArray{Float64,3},CUDA.CuArray{Float64,3},CUDA.CuArray{Float64,3}}},CUDA.CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CUDA.CuArray{Complex{Float64},3},CUDA.CuArray{Complex{Float64},3}}}},Nothing}) at /home/ptuckman/.julia/packages/Oceananigans/KJCVx/src/TimeSteppers/generic_time_stepping.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:39611,Deployability,Continuous,ContinuousForcing,39611,"Condition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},Oceananigans.Advection.CenteredSecondOrder,Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CUDA.CuArray{Float64,3},CUDA.CuArray{Float64,3},CUDA.CuArray{Float64,3}}},CUDA.CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IF",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:39784,Deployability,Continuous,ContinuousForcing,39784,"ans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},Oceananigans.Advection.CenteredSecondOrder,Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CUDA.CuArray{Float64,3},CUDA.CuArray{Float64,3},CUDA.CuArray{Float64,3}}},CUDA.CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPla",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:39957,Deployability,Continuous,ContinuousForcing,39957,"nded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},Oceananigans.Advection.CenteredSecondOrder,Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CUDA.CuArray{Float64,3},CUDA.CuArray{Float64,3},CUDA.CuArray{Float64,3}}},CUDA.CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tupl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:40130,Deployability,Continuous,ContinuousForcing,40130,"ditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},Oceananigans.Advection.CenteredSecondOrder,Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CUDA.CuArray{Float64,3},CUDA.CuArray{Float64,3},CUDA.CuArray{Float64,3}}},CUDA.CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CUDA.CuArray{Complex{Float64},3},CUDA.CuArray{Complex{Float64},3}}}},Nothing}, ::Float64; euler::Bool) at /home/ptuckman/.julia/packages/Oceananigans/KJCVx/src/TimeStepper",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:49751,Deployability,Continuous,ContinuousForcing,49751,"Condition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},Oceananigans.Advection.CenteredSecondOrder,Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CUDA.CuArray{Float64,3},CUDA.CuArray{Float64,3},CUDA.CuArray{Float64,3}}},CUDA.CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IF",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:49924,Deployability,Continuous,ContinuousForcing,49924,"ans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},Oceananigans.Advection.CenteredSecondOrder,Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CUDA.CuArray{Float64,3},CUDA.CuArray{Float64,3},CUDA.CuArray{Float64,3}}},CUDA.CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPla",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:50097,Deployability,Continuous,ContinuousForcing,50097,"nded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},Oceananigans.Advection.CenteredSecondOrder,Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CUDA.CuArray{Float64,3},CUDA.CuArray{Float64,3},CUDA.CuArray{Float64,3}}},CUDA.CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tupl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:50270,Deployability,Continuous,ContinuousForcing,50270,"ditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},Oceananigans.Advection.CenteredSecondOrder,Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CUDA.CuArray{Float64,3},CUDA.CuArray{Float64,3},CUDA.CuArray{Float64,3}}},CUDA.CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CUDA.CuArray{Complex{Float64},3},CUDA.CuArray{Complex{Float64},3}}}},Nothing},TimeStepWizard{Float64},Array{Any,1},Float64,Float64,Float64,Float64,OrderedCollections.Order",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:18511,Integrability,depend,dependencies,18511,"ngs.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}; name::String, kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/CUDA/dZvbp/src/compiler/execution.jl:298; [19] macro expansion at /home/ptuckman/.julia/packages/CUDA/dZvbp/src/compiler/execution.jl:109 [inlined]; [20] (::KernelAbstractions.Kernel{KernelAbstractions.CUDADevice,KernelAbstractions.NDIteration.StaticSize{(16, 16)},KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!)})(::OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, ::Vararg{Any,N} where N; ndrange::Nothing, dependencies::KernelAbstractions.CudaEvent, workgroupsize::Nothing, progress::Function) at /home/ptuckman/.julia/packages/KernelAbstractions/rFWPd/src/backends/cuda.jl:172; [21] calculate_interior_tendency_contributions!(::NamedTuple{(:u, :v, :w, :T),NTuple{4,OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}}}, ::GPU, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Oceananigans.Advection.CenteredSecondOrder, ::NonTraditionalFPlane{Float64}, ::SeawaterBuoyancy{Float64,LinearEquationOfState{Float64},Nothing,Float64}, ::Nothing, ::AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}}, ::NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}},OffsetArrays",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:330,Performance,Load,LoadError,330,"Also reported by @qwert2266 but this is my fault since GitLab CI doesn't seem to be actually running GPU tests... Using something like; ```julia; @inline FT(x, y, z, t, T, p) = - exp(z/p.ℓ) * 2p.K/p.Δz^2 * T; T_forcing = Forcing(FT, field_dependencies=:T, parameters=bc_params); forcing = (T=T_forcing,); ```. causes. ```; ERROR: LoadError: GPU compilation of kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!), OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, Oceananigans.Advection.CenteredSecondOrder, NonTraditionalFPlane{Float64}, Nothing, AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}}, NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, Nothing, NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:4554,Performance,optimiz,optimize,4554," is of type Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}} which is not isbits.; .field_dependencies is of type Tuple{Symbol} which is not isbits.; .1 is of type Symbol which is not isbits. Passing non-isbits types is only allowed if they they are unused by the kernel. Stacktrace:; [1] check_invocation(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Function) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/validation.jl:75; [2] macro expansion at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:240 [inlined]; [3] macro expansion at /home/ptuckman/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:239; [5] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [6] compile at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [7] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:4833,Performance,optimiz,optimize,4833,"ymbol} which is not isbits.; .1 is of type Symbol which is not isbits. Passing non-isbits types is only allowed if they they are unused by the kernel. Stacktrace:; [1] check_invocation(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Function) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/validation.jl:75; [2] macro expansion at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:240 [inlined]; [3] macro expansion at /home/ptuckman/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:239; [5] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [6] compile at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [7] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},B",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:7642,Performance,cache,cache,7642,"Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/CUDA/dZvbp/src/compiler/execution.jl:310; [8] #87 at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:21 [inlined]; [9] get!(::GPUCompiler.var""#87#88""{Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}},typeof(CUDA._cufunction),GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Oceananigans.Ad",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:12779,Performance,cache,cache,12779,"nuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [12] + at ./int.jl:53 [inlined]; [13] hash_64_64 at ./hashing.jl:35 [inlined]; [14] hash_uint64 at ./hashing.jl:62 [inlined]; [15] hx at ./float.jl:568 [inlined]; [16] hash at ./float.jl:571 [inlined]; [17] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:15540,Performance,cache,cache,15540,"nuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:0; [18] cufunction(::typeof(Cassette.overdub), ::Type{Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Oceananigans.Advection.CenteredSecondOrder,NonTraditionalFPlane{Float64},Nothing,AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:4183,Security,validat,validation,4183,"Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}}, which is not isbits:; .T is of type Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}} which is not isbits.; .field_dependencies is of type Tuple{Symbol} which is not isbits.; .1 is of type Symbol which is not isbits. Passing non-isbits types is only allowed if they they are unused by the kernel. Stacktrace:; [1] check_invocation(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Function) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/validation.jl:75; [2] macro expansion at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:240 [inlined]; [3] macro expansion at /home/ptuckman/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:239; [5] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [6] compile at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [7] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),Ker",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:4583,Security,validat,validate,4583," is of type Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}} which is not isbits.; .field_dependencies is of type Tuple{Symbol} which is not isbits.; .1 is of type Symbol which is not isbits. Passing non-isbits types is only allowed if they they are unused by the kernel. Stacktrace:; [1] check_invocation(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Function) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/validation.jl:75; [2] macro expansion at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:240 [inlined]; [3] macro expansion at /home/ptuckman/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:239; [5] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [6] compile at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [7] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:4862,Security,validat,validate,4862,"ymbol} which is not isbits.; .1 is of type Symbol which is not isbits. Passing non-isbits types is only allowed if they they are unused by the kernel. Stacktrace:; [1] check_invocation(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Function) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/validation.jl:75; [2] macro expansion at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:240 [inlined]; [3] macro expansion at /home/ptuckman/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:239; [5] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [6] compile at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [7] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},B",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:12846,Security,hash,hashing,12846,"othing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [12] + at ./int.jl:53 [inlined]; [13] hash_64_64 at ./hashing.jl:35 [inlined]; [14] hash_uint64 at ./hashing.jl:62 [inlined]; [15] hx at ./float.jl:568 [inlined]; [16] hash at ./float.jl:571 [inlined]; [17] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Ocea",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:12893,Security,hash,hashing,12893,"ng),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [12] + at ./int.jl:53 [inlined]; [13] hash_64_64 at ./hashing.jl:35 [inlined]; [14] hash_uint64 at ./hashing.jl:62 [inlined]; [15] hx at ./float.jl:568 [inlined]; [16] hash at ./float.jl:571 [inlined]; [17] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Oceananigans.Advection.CenteredSecondOrder,NonTradi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:12960,Security,hash,hash,12960,"nanigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}, ::UInt64; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:19; [12] + at ./int.jl:53 [inlined]; [13] hash_64_64 at ./hashing.jl:35 [inlined]; [14] hash_uint64 at ./hashing.jl:62 [inlined]; [15] hx at ./float.jl:568 [inlined]; [16] hash at ./float.jl:571 [inlined]; [17] cached_compilation(::typeof(CUDA._cufunction), ::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Oceananigans.Advection.CenteredSecondOrder,NonTraditionalFPlane{Float64},Nothing,AnisotropicDiffusivity{Flo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1010:105,Testability,test,tests,105,"Also reported by @qwert2266 but this is my fault since GitLab CI doesn't seem to be actually running GPU tests... Using something like; ```julia; @inline FT(x, y, z, t, T, p) = - exp(z/p.ℓ) * 2p.K/p.Δz^2 * T; T_forcing = Forcing(FT, field_dependencies=:T, parameters=bc_params); forcing = (T=T_forcing,); ```. causes. ```; ERROR: LoadError: GPU compilation of kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!), OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, Oceananigans.Advection.CenteredSecondOrder, NonTraditionalFPlane{Float64}, Nothing, AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}}, NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, Nothing, NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010
https://github.com/CliMA/Oceananigans.jl/issues/1011:43,Deployability,continuous,continuous,43,"Our user interface makes extensive use of ""continuous"" function of `x, y, z, t`. Throughout our code, we evaluate these functions in control volumes using a first-order accurate method. In other words, the volume-average of a function is approximated by its value at the barycenter of a cell, as in `FunctionField`:. https://github.com/CliMA/Oceananigans.jl/blob/068a7ae7bbae244fc80c907d53cb0938adb9b5d0/src/Fields/function_field.jl#L45-L46. In the above code, `getindex` is (implicitly) assumed to return the volume average of the function `f` in the control volume labeled `i, j, k`. This volume average is approximated by simply evaluating the function `x, y, z, t` at the barycenter of the control volume in question. This is a valid, but only first-order approximation. The pitfall of this method is that its accuracy degrades significantly when `f` varies on a scale comparable to the grid scale. Another issue is that significant differences can arise between an analytically prescribed domain-integrated tracer, for example, and the discrete domain-integrated tracer after using `set!`. To fix such problems, higher-order approximation methods for volume averages of functions may be helpful. When using a higher-order approximation method, a function of `x, y, z, t` would be evaluated multiple times per grid point. This would have an immediate obvious use in `set!(field, func::Function)`. Such a method may also be useful for forcing functions, boundary conditions, and prescribed background fields (once #960 is resolved). While evaluating a function multiple times per grid point would make a simulation more computationally expensive, the extra cost may be negligible in simulations that are dominated by the cost of memory accesses. A high-order method we might consider is multi-dimemsional Gaussian quadrature. We could add the necessary quadrature data to `FunctionField`, and expand the importance of `FunctionField` by using it within `ContinuousForcing`, `BoundaryFunction`, and ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1011
https://github.com/CliMA/Oceananigans.jl/issues/1011:1001,Deployability,integrat,integrated,1001,"Our user interface makes extensive use of ""continuous"" function of `x, y, z, t`. Throughout our code, we evaluate these functions in control volumes using a first-order accurate method. In other words, the volume-average of a function is approximated by its value at the barycenter of a cell, as in `FunctionField`:. https://github.com/CliMA/Oceananigans.jl/blob/068a7ae7bbae244fc80c907d53cb0938adb9b5d0/src/Fields/function_field.jl#L45-L46. In the above code, `getindex` is (implicitly) assumed to return the volume average of the function `f` in the control volume labeled `i, j, k`. This volume average is approximated by simply evaluating the function `x, y, z, t` at the barycenter of the control volume in question. This is a valid, but only first-order approximation. The pitfall of this method is that its accuracy degrades significantly when `f` varies on a scale comparable to the grid scale. Another issue is that significant differences can arise between an analytically prescribed domain-integrated tracer, for example, and the discrete domain-integrated tracer after using `set!`. To fix such problems, higher-order approximation methods for volume averages of functions may be helpful. When using a higher-order approximation method, a function of `x, y, z, t` would be evaluated multiple times per grid point. This would have an immediate obvious use in `set!(field, func::Function)`. Such a method may also be useful for forcing functions, boundary conditions, and prescribed background fields (once #960 is resolved). While evaluating a function multiple times per grid point would make a simulation more computationally expensive, the extra cost may be negligible in simulations that are dominated by the cost of memory accesses. A high-order method we might consider is multi-dimemsional Gaussian quadrature. We could add the necessary quadrature data to `FunctionField`, and expand the importance of `FunctionField` by using it within `ContinuousForcing`, `BoundaryFunction`, and ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1011
https://github.com/CliMA/Oceananigans.jl/issues/1011:1057,Deployability,integrat,integrated,1057,"Our user interface makes extensive use of ""continuous"" function of `x, y, z, t`. Throughout our code, we evaluate these functions in control volumes using a first-order accurate method. In other words, the volume-average of a function is approximated by its value at the barycenter of a cell, as in `FunctionField`:. https://github.com/CliMA/Oceananigans.jl/blob/068a7ae7bbae244fc80c907d53cb0938adb9b5d0/src/Fields/function_field.jl#L45-L46. In the above code, `getindex` is (implicitly) assumed to return the volume average of the function `f` in the control volume labeled `i, j, k`. This volume average is approximated by simply evaluating the function `x, y, z, t` at the barycenter of the control volume in question. This is a valid, but only first-order approximation. The pitfall of this method is that its accuracy degrades significantly when `f` varies on a scale comparable to the grid scale. Another issue is that significant differences can arise between an analytically prescribed domain-integrated tracer, for example, and the discrete domain-integrated tracer after using `set!`. To fix such problems, higher-order approximation methods for volume averages of functions may be helpful. When using a higher-order approximation method, a function of `x, y, z, t` would be evaluated multiple times per grid point. This would have an immediate obvious use in `set!(field, func::Function)`. Such a method may also be useful for forcing functions, boundary conditions, and prescribed background fields (once #960 is resolved). While evaluating a function multiple times per grid point would make a simulation more computationally expensive, the extra cost may be negligible in simulations that are dominated by the cost of memory accesses. A high-order method we might consider is multi-dimemsional Gaussian quadrature. We could add the necessary quadrature data to `FunctionField`, and expand the importance of `FunctionField` by using it within `ContinuousForcing`, `BoundaryFunction`, and ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1011
https://github.com/CliMA/Oceananigans.jl/issues/1011:1957,Deployability,Continuous,ContinuousForcing,1957," interface makes extensive use of ""continuous"" function of `x, y, z, t`. Throughout our code, we evaluate these functions in control volumes using a first-order accurate method. In other words, the volume-average of a function is approximated by its value at the barycenter of a cell, as in `FunctionField`:. https://github.com/CliMA/Oceananigans.jl/blob/068a7ae7bbae244fc80c907d53cb0938adb9b5d0/src/Fields/function_field.jl#L45-L46. In the above code, `getindex` is (implicitly) assumed to return the volume average of the function `f` in the control volume labeled `i, j, k`. This volume average is approximated by simply evaluating the function `x, y, z, t` at the barycenter of the control volume in question. This is a valid, but only first-order approximation. The pitfall of this method is that its accuracy degrades significantly when `f` varies on a scale comparable to the grid scale. Another issue is that significant differences can arise between an analytically prescribed domain-integrated tracer, for example, and the discrete domain-integrated tracer after using `set!`. To fix such problems, higher-order approximation methods for volume averages of functions may be helpful. When using a higher-order approximation method, a function of `x, y, z, t` would be evaluated multiple times per grid point. This would have an immediate obvious use in `set!(field, func::Function)`. Such a method may also be useful for forcing functions, boundary conditions, and prescribed background fields (once #960 is resolved). While evaluating a function multiple times per grid point would make a simulation more computationally expensive, the extra cost may be negligible in simulations that are dominated by the cost of memory accesses. A high-order method we might consider is multi-dimemsional Gaussian quadrature. We could add the necessary quadrature data to `FunctionField`, and expand the importance of `FunctionField` by using it within `ContinuousForcing`, `BoundaryFunction`, and `set!`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1011
https://github.com/CliMA/Oceananigans.jl/issues/1011:9,Integrability,interface,interface,9,"Our user interface makes extensive use of ""continuous"" function of `x, y, z, t`. Throughout our code, we evaluate these functions in control volumes using a first-order accurate method. In other words, the volume-average of a function is approximated by its value at the barycenter of a cell, as in `FunctionField`:. https://github.com/CliMA/Oceananigans.jl/blob/068a7ae7bbae244fc80c907d53cb0938adb9b5d0/src/Fields/function_field.jl#L45-L46. In the above code, `getindex` is (implicitly) assumed to return the volume average of the function `f` in the control volume labeled `i, j, k`. This volume average is approximated by simply evaluating the function `x, y, z, t` at the barycenter of the control volume in question. This is a valid, but only first-order approximation. The pitfall of this method is that its accuracy degrades significantly when `f` varies on a scale comparable to the grid scale. Another issue is that significant differences can arise between an analytically prescribed domain-integrated tracer, for example, and the discrete domain-integrated tracer after using `set!`. To fix such problems, higher-order approximation methods for volume averages of functions may be helpful. When using a higher-order approximation method, a function of `x, y, z, t` would be evaluated multiple times per grid point. This would have an immediate obvious use in `set!(field, func::Function)`. Such a method may also be useful for forcing functions, boundary conditions, and prescribed background fields (once #960 is resolved). While evaluating a function multiple times per grid point would make a simulation more computationally expensive, the extra cost may be negligible in simulations that are dominated by the cost of memory accesses. A high-order method we might consider is multi-dimemsional Gaussian quadrature. We could add the necessary quadrature data to `FunctionField`, and expand the importance of `FunctionField` by using it within `ContinuousForcing`, `BoundaryFunction`, and ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1011
https://github.com/CliMA/Oceananigans.jl/issues/1011:1001,Integrability,integrat,integrated,1001,"Our user interface makes extensive use of ""continuous"" function of `x, y, z, t`. Throughout our code, we evaluate these functions in control volumes using a first-order accurate method. In other words, the volume-average of a function is approximated by its value at the barycenter of a cell, as in `FunctionField`:. https://github.com/CliMA/Oceananigans.jl/blob/068a7ae7bbae244fc80c907d53cb0938adb9b5d0/src/Fields/function_field.jl#L45-L46. In the above code, `getindex` is (implicitly) assumed to return the volume average of the function `f` in the control volume labeled `i, j, k`. This volume average is approximated by simply evaluating the function `x, y, z, t` at the barycenter of the control volume in question. This is a valid, but only first-order approximation. The pitfall of this method is that its accuracy degrades significantly when `f` varies on a scale comparable to the grid scale. Another issue is that significant differences can arise between an analytically prescribed domain-integrated tracer, for example, and the discrete domain-integrated tracer after using `set!`. To fix such problems, higher-order approximation methods for volume averages of functions may be helpful. When using a higher-order approximation method, a function of `x, y, z, t` would be evaluated multiple times per grid point. This would have an immediate obvious use in `set!(field, func::Function)`. Such a method may also be useful for forcing functions, boundary conditions, and prescribed background fields (once #960 is resolved). While evaluating a function multiple times per grid point would make a simulation more computationally expensive, the extra cost may be negligible in simulations that are dominated by the cost of memory accesses. A high-order method we might consider is multi-dimemsional Gaussian quadrature. We could add the necessary quadrature data to `FunctionField`, and expand the importance of `FunctionField` by using it within `ContinuousForcing`, `BoundaryFunction`, and ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1011
https://github.com/CliMA/Oceananigans.jl/issues/1011:1057,Integrability,integrat,integrated,1057,"Our user interface makes extensive use of ""continuous"" function of `x, y, z, t`. Throughout our code, we evaluate these functions in control volumes using a first-order accurate method. In other words, the volume-average of a function is approximated by its value at the barycenter of a cell, as in `FunctionField`:. https://github.com/CliMA/Oceananigans.jl/blob/068a7ae7bbae244fc80c907d53cb0938adb9b5d0/src/Fields/function_field.jl#L45-L46. In the above code, `getindex` is (implicitly) assumed to return the volume average of the function `f` in the control volume labeled `i, j, k`. This volume average is approximated by simply evaluating the function `x, y, z, t` at the barycenter of the control volume in question. This is a valid, but only first-order approximation. The pitfall of this method is that its accuracy degrades significantly when `f` varies on a scale comparable to the grid scale. Another issue is that significant differences can arise between an analytically prescribed domain-integrated tracer, for example, and the discrete domain-integrated tracer after using `set!`. To fix such problems, higher-order approximation methods for volume averages of functions may be helpful. When using a higher-order approximation method, a function of `x, y, z, t` would be evaluated multiple times per grid point. This would have an immediate obvious use in `set!(field, func::Function)`. Such a method may also be useful for forcing functions, boundary conditions, and prescribed background fields (once #960 is resolved). While evaluating a function multiple times per grid point would make a simulation more computationally expensive, the extra cost may be negligible in simulations that are dominated by the cost of memory accesses. A high-order method we might consider is multi-dimemsional Gaussian quadrature. We could add the necessary quadrature data to `FunctionField`, and expand the importance of `FunctionField` by using it within `ContinuousForcing`, `BoundaryFunction`, and ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1011
https://github.com/CliMA/Oceananigans.jl/issues/1011:1739,Security,access,accesses,1739," interface makes extensive use of ""continuous"" function of `x, y, z, t`. Throughout our code, we evaluate these functions in control volumes using a first-order accurate method. In other words, the volume-average of a function is approximated by its value at the barycenter of a cell, as in `FunctionField`:. https://github.com/CliMA/Oceananigans.jl/blob/068a7ae7bbae244fc80c907d53cb0938adb9b5d0/src/Fields/function_field.jl#L45-L46. In the above code, `getindex` is (implicitly) assumed to return the volume average of the function `f` in the control volume labeled `i, j, k`. This volume average is approximated by simply evaluating the function `x, y, z, t` at the barycenter of the control volume in question. This is a valid, but only first-order approximation. The pitfall of this method is that its accuracy degrades significantly when `f` varies on a scale comparable to the grid scale. Another issue is that significant differences can arise between an analytically prescribed domain-integrated tracer, for example, and the discrete domain-integrated tracer after using `set!`. To fix such problems, higher-order approximation methods for volume averages of functions may be helpful. When using a higher-order approximation method, a function of `x, y, z, t` would be evaluated multiple times per grid point. This would have an immediate obvious use in `set!(field, func::Function)`. Such a method may also be useful for forcing functions, boundary conditions, and prescribed background fields (once #960 is resolved). While evaluating a function multiple times per grid point would make a simulation more computationally expensive, the extra cost may be negligible in simulations that are dominated by the cost of memory accesses. A high-order method we might consider is multi-dimemsional Gaussian quadrature. We could add the necessary quadrature data to `FunctionField`, and expand the importance of `FunctionField` by using it within `ContinuousForcing`, `BoundaryFunction`, and `set!`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1011
https://github.com/CliMA/Oceananigans.jl/issues/1011:625,Usability,simpl,simply,625,"Our user interface makes extensive use of ""continuous"" function of `x, y, z, t`. Throughout our code, we evaluate these functions in control volumes using a first-order accurate method. In other words, the volume-average of a function is approximated by its value at the barycenter of a cell, as in `FunctionField`:. https://github.com/CliMA/Oceananigans.jl/blob/068a7ae7bbae244fc80c907d53cb0938adb9b5d0/src/Fields/function_field.jl#L45-L46. In the above code, `getindex` is (implicitly) assumed to return the volume average of the function `f` in the control volume labeled `i, j, k`. This volume average is approximated by simply evaluating the function `x, y, z, t` at the barycenter of the control volume in question. This is a valid, but only first-order approximation. The pitfall of this method is that its accuracy degrades significantly when `f` varies on a scale comparable to the grid scale. Another issue is that significant differences can arise between an analytically prescribed domain-integrated tracer, for example, and the discrete domain-integrated tracer after using `set!`. To fix such problems, higher-order approximation methods for volume averages of functions may be helpful. When using a higher-order approximation method, a function of `x, y, z, t` would be evaluated multiple times per grid point. This would have an immediate obvious use in `set!(field, func::Function)`. Such a method may also be useful for forcing functions, boundary conditions, and prescribed background fields (once #960 is resolved). While evaluating a function multiple times per grid point would make a simulation more computationally expensive, the extra cost may be negligible in simulations that are dominated by the cost of memory accesses. A high-order method we might consider is multi-dimemsional Gaussian quadrature. We could add the necessary quadrature data to `FunctionField`, and expand the importance of `FunctionField` by using it within `ContinuousForcing`, `BoundaryFunction`, and ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1011
https://github.com/CliMA/Oceananigans.jl/pull/1012:372,Availability,error,error,372,"This PR puts some code into the `IncompressibleModel` constructor that adjusts the halos in `grid` so that they're valid for the specified `advection` scheme and turbulence `closure`. The changes went a little deep because of the fact that we allow fields to be passed directly to `IncompressibleModel`. We now check whether such fields have the correct grid and throw an error if they don't. I decided not to validate the `pressure_solver` input. This isn't commonly provided by users (and wasn't previously checked). There's a new function in `Solvers` that could be modified if such a check becomes desirable. Here's what happens if you use a high-order advection scheme now:. ```julia; using Oceananigans, Oceanaingans.Advection. grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 2, 3)). # output --- note that halos are (1, 1, 1); RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 1.0], y ∈ [0.0, 2.0], z ∈ [-3.0, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (1, 1, 1); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (1.0, 2.0, 3.0); ```. but,. ```julia; model = IncompressibleModel(advection=WENO5(), grid=grid). model.grid. # output --- halos are (3, 3, 3); RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 1.0], y ∈ [0.0, 2.0], z ∈ [-3.0, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (1, 1, 1); halo size (Hx, Hy, Hz): (3, 3, 3); grid spacing (Δx, Δy, Δz): (1.0, 2.0, 3.0); ```. This PR relies on #1003 . Resolves #941",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1012
https://github.com/CliMA/Oceananigans.jl/pull/1012:410,Security,validat,validate,410,"This PR puts some code into the `IncompressibleModel` constructor that adjusts the halos in `grid` so that they're valid for the specified `advection` scheme and turbulence `closure`. The changes went a little deep because of the fact that we allow fields to be passed directly to `IncompressibleModel`. We now check whether such fields have the correct grid and throw an error if they don't. I decided not to validate the `pressure_solver` input. This isn't commonly provided by users (and wasn't previously checked). There's a new function in `Solvers` that could be modified if such a check becomes desirable. Here's what happens if you use a high-order advection scheme now:. ```julia; using Oceananigans, Oceanaingans.Advection. grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 2, 3)). # output --- note that halos are (1, 1, 1); RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 1.0], y ∈ [0.0, 2.0], z ∈ [-3.0, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (1, 1, 1); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (1.0, 2.0, 3.0); ```. but,. ```julia; model = IncompressibleModel(advection=WENO5(), grid=grid). model.grid. # output --- halos are (3, 3, 3); RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 1.0], y ∈ [0.0, 2.0], z ∈ [-3.0, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (1, 1, 1); halo size (Hx, Hy, Hz): (3, 3, 3); grid spacing (Δx, Δy, Δz): (1.0, 2.0, 3.0); ```. This PR relies on #1003 . Resolves #941",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1012
https://github.com/CliMA/Oceananigans.jl/issues/1013:299,Integrability,message,messages,299,"Sometimes precompilation and model setup tasks can take a fair amount of time. This can lead to head-scratching and/or boredom while running scripts: what _is_ Oceananigans up to, anyways?. To solve this problem and make Oceananigans more friendly and more chatty, we might add some helpful `@info` messages that print at various stages in the model setup process. Looking at the examples gives a helpful overview of model setup. Here's some things we might consider info statements for:. 1. Grid creation (type, size, topology, domain); 2. Boundary conditions (type and non-default boundary conditions); 3. Model creation (grid info including size and halo regions, and maybe just `display` model properties); 4. `set!(model, ...)`?; 5. `Simulation` construction (stop criteria, time-step...); 6. `run!` initialization (diagnostics, output writers); 7. `run!` completion?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1013
https://github.com/CliMA/Oceananigans.jl/pull/1014:606,Deployability,update,update,606,"This PR adds a property to `IncompressibleModel` called `background_fields`. `background_fields.velocities` contains background velocity fields; `background_fields.tracers` contains background tracer fields. Background fields are specified with a `NamedTuple` similar to forcing functions and boundary conditions:. ```julia; background_u(x, y, z, t) = z * sin(t). model = IncompressibleModel(grid=grid, background_fields=(u,), ...); ```. Background fields are neglected in all tendency terms _except_ the advection terms. This restricts their use, but greatly simplifies their implementation. Todo:. - [x] update physics docs to include background fields in model equations; - [x] update model setup docs; - [x] tests; - [x] update `eady_turbulence.jl` and `internal_wave.jl` example to use `background_fields`; - [x] extend implementation of `FunctionField` to take parameters and add a special constructor for background `FunctionFields`. Resolves #960",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1014
https://github.com/CliMA/Oceananigans.jl/pull/1014:681,Deployability,update,update,681,"This PR adds a property to `IncompressibleModel` called `background_fields`. `background_fields.velocities` contains background velocity fields; `background_fields.tracers` contains background tracer fields. Background fields are specified with a `NamedTuple` similar to forcing functions and boundary conditions:. ```julia; background_u(x, y, z, t) = z * sin(t). model = IncompressibleModel(grid=grid, background_fields=(u,), ...); ```. Background fields are neglected in all tendency terms _except_ the advection terms. This restricts their use, but greatly simplifies their implementation. Todo:. - [x] update physics docs to include background fields in model equations; - [x] update model setup docs; - [x] tests; - [x] update `eady_turbulence.jl` and `internal_wave.jl` example to use `background_fields`; - [x] extend implementation of `FunctionField` to take parameters and add a special constructor for background `FunctionFields`. Resolves #960",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1014
https://github.com/CliMA/Oceananigans.jl/pull/1014:725,Deployability,update,update,725,"This PR adds a property to `IncompressibleModel` called `background_fields`. `background_fields.velocities` contains background velocity fields; `background_fields.tracers` contains background tracer fields. Background fields are specified with a `NamedTuple` similar to forcing functions and boundary conditions:. ```julia; background_u(x, y, z, t) = z * sin(t). model = IncompressibleModel(grid=grid, background_fields=(u,), ...); ```. Background fields are neglected in all tendency terms _except_ the advection terms. This restricts their use, but greatly simplifies their implementation. Todo:. - [x] update physics docs to include background fields in model equations; - [x] update model setup docs; - [x] tests; - [x] update `eady_turbulence.jl` and `internal_wave.jl` example to use `background_fields`; - [x] extend implementation of `FunctionField` to take parameters and add a special constructor for background `FunctionFields`. Resolves #960",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1014
https://github.com/CliMA/Oceananigans.jl/pull/1014:818,Modifiability,extend,extend,818,"This PR adds a property to `IncompressibleModel` called `background_fields`. `background_fields.velocities` contains background velocity fields; `background_fields.tracers` contains background tracer fields. Background fields are specified with a `NamedTuple` similar to forcing functions and boundary conditions:. ```julia; background_u(x, y, z, t) = z * sin(t). model = IncompressibleModel(grid=grid, background_fields=(u,), ...); ```. Background fields are neglected in all tendency terms _except_ the advection terms. This restricts their use, but greatly simplifies their implementation. Todo:. - [x] update physics docs to include background fields in model equations; - [x] update model setup docs; - [x] tests; - [x] update `eady_turbulence.jl` and `internal_wave.jl` example to use `background_fields`; - [x] extend implementation of `FunctionField` to take parameters and add a special constructor for background `FunctionFields`. Resolves #960",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1014
https://github.com/CliMA/Oceananigans.jl/pull/1014:712,Testability,test,tests,712,"This PR adds a property to `IncompressibleModel` called `background_fields`. `background_fields.velocities` contains background velocity fields; `background_fields.tracers` contains background tracer fields. Background fields are specified with a `NamedTuple` similar to forcing functions and boundary conditions:. ```julia; background_u(x, y, z, t) = z * sin(t). model = IncompressibleModel(grid=grid, background_fields=(u,), ...); ```. Background fields are neglected in all tendency terms _except_ the advection terms. This restricts their use, but greatly simplifies their implementation. Todo:. - [x] update physics docs to include background fields in model equations; - [x] update model setup docs; - [x] tests; - [x] update `eady_turbulence.jl` and `internal_wave.jl` example to use `background_fields`; - [x] extend implementation of `FunctionField` to take parameters and add a special constructor for background `FunctionFields`. Resolves #960",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1014
https://github.com/CliMA/Oceananigans.jl/pull/1014:560,Usability,simpl,simplifies,560,"This PR adds a property to `IncompressibleModel` called `background_fields`. `background_fields.velocities` contains background velocity fields; `background_fields.tracers` contains background tracer fields. Background fields are specified with a `NamedTuple` similar to forcing functions and boundary conditions:. ```julia; background_u(x, y, z, t) = z * sin(t). model = IncompressibleModel(grid=grid, background_fields=(u,), ...); ```. Background fields are neglected in all tendency terms _except_ the advection terms. This restricts their use, but greatly simplifies their implementation. Todo:. - [x] update physics docs to include background fields in model equations; - [x] update model setup docs; - [x] tests; - [x] update `eady_turbulence.jl` and `internal_wave.jl` example to use `background_fields`; - [x] extend implementation of `FunctionField` to take parameters and add a special constructor for background `FunctionFields`. Resolves #960",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1014
https://github.com/CliMA/Oceananigans.jl/issues/1015:617,Availability,down,down,617,"We should allow different advection schemes for velocities and tracers. This requires doing something similar to what we do for closures. Perhaps we can allow. ```julia; model = IncompressibleModel(advection=(velocities=CenteredFourthOrder(), tracers=WENO5())); ```. We also probably want to allow different advection schemes for every tracer. We can support something like. ```julia; model = IncompressibleModel(advection=(velocities=CenteredFourthOrder(), T=WENO5(), S=CenteredSecondOrder())); ```. Let's discuss whether the syntax proposed above is acceptable or if we want a different design. PS we need to write down a list of `forbidden_tracer_names` and throw an error if they are provided. Right now these are `:u, :v, :w` and any possible property of `diffusivities`. The above design would also preclude `:velocities` and `:tracers`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1015
https://github.com/CliMA/Oceananigans.jl/issues/1015:670,Availability,error,error,670,"We should allow different advection schemes for velocities and tracers. This requires doing something similar to what we do for closures. Perhaps we can allow. ```julia; model = IncompressibleModel(advection=(velocities=CenteredFourthOrder(), tracers=WENO5())); ```. We also probably want to allow different advection schemes for every tracer. We can support something like. ```julia; model = IncompressibleModel(advection=(velocities=CenteredFourthOrder(), T=WENO5(), S=CenteredSecondOrder())); ```. Let's discuss whether the syntax proposed above is acceptable or if we want a different design. PS we need to write down a list of `forbidden_tracer_names` and throw an error if they are provided. Right now these are `:u, :v, :w` and any possible property of `diffusivities`. The above design would also preclude `:velocities` and `:tracers`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1015
https://github.com/CliMA/Oceananigans.jl/pull/1016:118,Usability,clear,clear,118,Resolves #1010. This PR also adds an annotation to `DiscreteForcing` that may help with GPU compilation (its not 100% clear now however).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1016
https://github.com/CliMA/Oceananigans.jl/pull/1018:44,Availability,failure,failures,44,Should at least help with detecting doctest failures and we want to build+deploy docs on Buildkite anyways.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1018
https://github.com/CliMA/Oceananigans.jl/pull/1018:74,Deployability,deploy,deploy,74,Should at least help with detecting doctest failures and we want to build+deploy docs on Buildkite anyways.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1018
https://github.com/CliMA/Oceananigans.jl/pull/1018:26,Safety,detect,detecting,26,Should at least help with detecting doctest failures and we want to build+deploy docs on Buildkite anyways.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1018
https://github.com/CliMA/Oceananigans.jl/pull/1020:306,Availability,error,errors,306,"The primary issue fixed here are actually the tests themselves, rather than the implementation. However this PR also makes a number of small improvements to the implementation, including a bug in which `recompute_safely` was implemented wrong (despite producing correct behavior, due to a ""cancellation of errors""). It looks like computations on `Faces` and along `Bounded` dimensions may not be possible with `BuoyancyField`. I will open an issue with an MWE. This is not a high-priority, because making such computations on boundaries correct in general really requires solving #971 ; otherwise we cannot guarantee that boundary conditions are correct (and they will often be wrong when averages are taken, as they commonly are during output). Relies on #1016 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1020
https://github.com/CliMA/Oceananigans.jl/pull/1020:46,Testability,test,tests,46,"The primary issue fixed here are actually the tests themselves, rather than the implementation. However this PR also makes a number of small improvements to the implementation, including a bug in which `recompute_safely` was implemented wrong (despite producing correct behavior, due to a ""cancellation of errors""). It looks like computations on `Faces` and along `Bounded` dimensions may not be possible with `BuoyancyField`. I will open an issue with an MWE. This is not a high-priority, because making such computations on boundaries correct in general really requires solving #971 ; otherwise we cannot guarantee that boundary conditions are correct (and they will often be wrong when averages are taken, as they commonly are during output). Relies on #1016 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1020
https://github.com/CliMA/Oceananigans.jl/pull/1021:18,Deployability,release,release,18,We should tag and release v0.40.0 once PR #1020 is merged since GPU tests fail on v0.39.0 and #1020 fixes things so all tests pass.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1021
https://github.com/CliMA/Oceananigans.jl/pull/1021:68,Testability,test,tests,68,We should tag and release v0.40.0 once PR #1020 is merged since GPU tests fail on v0.39.0 and #1020 fixes things so all tests pass.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1021
https://github.com/CliMA/Oceananigans.jl/pull/1021:120,Testability,test,tests,120,We should tag and release v0.40.0 once PR #1020 is merged since GPU tests fail on v0.39.0 and #1020 fixes things so all tests pass.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1021
https://github.com/CliMA/Oceananigans.jl/pull/1022:159,Testability,test,tested,159,"This pull request changes the compat entry for the `CUDA` package from `^1` to `^1, 2.0`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1022
https://github.com/CliMA/Oceananigans.jl/pull/1022:264,Testability,test,tests,264,"This pull request changes the compat entry for the `CUDA` package from `^1` to `^1, 2.0`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1022
https://github.com/CliMA/Oceananigans.jl/issues/1023:577,Testability,test,testing,577,"I think the definition of ""cell volumes"" needs to be dispatched on for models of dimension < 3:. https://github.com/CliMA/Oceananigans.jl/blob/6b2cea36d5782f5a73402b97f4d7476de9237c93/src/Operators/areas_and_volumes.jl#L49-L50. Since `Flat` dimensions have zero grid spacing, cell volumes in models with `Flat` dimensions are spuriously calculated to be `0`, which leads to dividing by `0` in advection operators, eg. https://github.com/CliMA/Oceananigans.jl/blob/6b2cea36d5782f5a73402b97f4d7476de9237c93/src/Advection/tracer_advection_operators.jl#L15-L19. I found this while testing the `internal_wave.jl` example for #1014 . We should have a test that models with `Flat` dimensions don't NaN. In fact, I think most or all of the dynamics tests could be converted to use `Flat`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1023
https://github.com/CliMA/Oceananigans.jl/issues/1023:645,Testability,test,test,645,"I think the definition of ""cell volumes"" needs to be dispatched on for models of dimension < 3:. https://github.com/CliMA/Oceananigans.jl/blob/6b2cea36d5782f5a73402b97f4d7476de9237c93/src/Operators/areas_and_volumes.jl#L49-L50. Since `Flat` dimensions have zero grid spacing, cell volumes in models with `Flat` dimensions are spuriously calculated to be `0`, which leads to dividing by `0` in advection operators, eg. https://github.com/CliMA/Oceananigans.jl/blob/6b2cea36d5782f5a73402b97f4d7476de9237c93/src/Advection/tracer_advection_operators.jl#L15-L19. I found this while testing the `internal_wave.jl` example for #1014 . We should have a test that models with `Flat` dimensions don't NaN. In fact, I think most or all of the dynamics tests could be converted to use `Flat`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1023
https://github.com/CliMA/Oceananigans.jl/issues/1023:741,Testability,test,tests,741,"I think the definition of ""cell volumes"" needs to be dispatched on for models of dimension < 3:. https://github.com/CliMA/Oceananigans.jl/blob/6b2cea36d5782f5a73402b97f4d7476de9237c93/src/Operators/areas_and_volumes.jl#L49-L50. Since `Flat` dimensions have zero grid spacing, cell volumes in models with `Flat` dimensions are spuriously calculated to be `0`, which leads to dividing by `0` in advection operators, eg. https://github.com/CliMA/Oceananigans.jl/blob/6b2cea36d5782f5a73402b97f4d7476de9237c93/src/Advection/tracer_advection_operators.jl#L15-L19. I found this while testing the `internal_wave.jl` example for #1014 . We should have a test that models with `Flat` dimensions don't NaN. In fact, I think most or all of the dynamics tests could be converted to use `Flat`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1023
https://github.com/CliMA/Oceananigans.jl/pull/1024:48,Testability,test,tests,48,Could also change some of the examples and some tests to use flat dimensions now. Resolves #1023 ; Resolves #1026,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1024
https://github.com/CliMA/Oceananigans.jl/pull/1025:212,Testability,test,test,212,"Array conversions when fetching output trigger `copyto!` and then `getindex`, which is in turn disallowed. This PR fixes an issue with output on the GPU on master. I'm a bit perplexed why the `jld2_field_output` test didn't pick this up.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1025
https://github.com/CliMA/Oceananigans.jl/issues/1026:615,Availability,Error,Error,615,"```Julia. julia> using Oceananigans; [ Info: Oceananigans will use 12 threads. julia> model = IncompressibleModel(grid = RegularCartesianGrid(topology=(Periodic, Periodic, Flat), size=(16, 16), extent=(2π, 2π))); IncompressibleModel{CPU, Float64}(time = 0.000 s, iteration = 0); ├── grid: RegularCartesianGrid{Float64, Periodic, Periodic, Flat}(Nx=16, Ny=16, Nz=1); ├── tracers: (:T, :S); ├── closure: IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}}; ├── buoyancy: SeawaterBuoyancy{Float64,LinearEquationOfState{Float64},Nothing,Nothing}; └── coriolis: Nothing. julia> model.velocities.u; Error showing value of type Field{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Flat,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{Nothing,Nothing}}}}:; ERROR: MethodError: no method matching bctype_str(::Nothing); Closest candidates are:; bctype_str(::BoundaryCondition{Flux,Nothing}) at /Users/navid/Research/Oceananigans.jl/src/BoundaryConditions/show_boundary_conditions.jl:29; bctype_str(::BoundaryCondition{var""#s63"",T} where T where var""#s63""<:Flux) at /Users/navid/Research/Oceananigans.jl/src/BoundaryConditions/show_boundary_conditions.jl:24; bctype_str(::BoundaryCondition{var""#s63"",T} where T where var""#s63""<:Oceananigans.BoundaryConditions.Periodic) at /Users/navid/Research/Oceananigans.jl/src/BoundaryConditions/show_boundary_conditions.jl:25; ...; Stacktrace:; [1] short_show(::Nam",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1026
https://github.com/CliMA/Oceananigans.jl/issues/1026:1356,Availability,ERROR,ERROR,1356,"ropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}}; ├── buoyancy: SeawaterBuoyancy{Float64,LinearEquationOfState{Float64},Nothing,Nothing}; └── coriolis: Nothing. julia> model.velocities.u; Error showing value of type Field{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Flat,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{Nothing,Nothing}}}}:; ERROR: MethodError: no method matching bctype_str(::Nothing); Closest candidates are:; bctype_str(::BoundaryCondition{Flux,Nothing}) at /Users/navid/Research/Oceananigans.jl/src/BoundaryConditions/show_boundary_conditions.jl:29; bctype_str(::BoundaryCondition{var""#s63"",T} where T where var""#s63""<:Flux) at /Users/navid/Research/Oceananigans.jl/src/BoundaryConditions/show_boundary_conditions.jl:24; bctype_str(::BoundaryCondition{var""#s63"",T} where T where var""#s63""<:Oceananigans.BoundaryConditions.Periodic) at /Users/navid/Research/Oceananigans.jl/src/BoundaryConditions/show_boundary_conditions.jl:25; ...; Stacktrace:; [1] short_show(::NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{Nothing,Nothing}}}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1026
https://github.com/CliMA/Oceananigans.jl/issues/1026:5684,Energy Efficiency,Adapt,Adapt,5684,""")}, ::Any) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:214; [5] display(::REPL.REPLDisplay, ::Any) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:218; [6] display(::Any) at ./multimedia.jl:328; [7] #invokelatest#1 at ./essentials.jl:710 [inlined]; [8] invokelatest at ./essentials.jl:709 [inlined]; [9] print_response(::IO, ::Any, ::Bool, ::Bool, ::Any) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:238; [10] print_response(::REPL.AbstractREPL, ::Any, ::Bool, ::Bool) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:223; [11] (::REPL.var""#do_respond#54""{Bool,Bool,REPL.var""#64#73""{REPL.LineEditREPL,REPL.REPLHistoryProvider},REPL.LineEditREPL,REPL.LineEdit.Prompt})(::Any, ::Any, ::Any) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:822; [12] #invokelatest#1 at ./essentials.jl:710 [inlined]; [13] invokelatest at ./essentials.jl:709 [inlined]; [14] run_interface(::REPL.Terminals.TextTerminal, ::REPL.LineEdit.ModalInterface, ::REPL.LineEdit.MIState) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/LineEdit.jl:2355; [15] run_frontend(::REPL.LineEditREPL, ::REPL.REPLBackendRef) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:1144; [16] (::REPL.var""#38#42""{REPL.LineEditREPL,REPL.REPLBackendRef})() at ./task.jl:356. (Oceananigans) pkg> st; Project Oceananigans v0.40.0; Status `~/Research/Oceananigans.jl/Project.toml`; [79e6a3ab] Adapt v2.0.2; [052768ef] CUDA v1.3.3; [a8cc5b0e] Crayons v4.0.4; [7a1cc6ca] FFTW v1.2.4; [033835bb] JLD2 v0.1.14; [63c18a36] KernelAbstractions v0.4.0; [85f8d34a] NCDatasets v0.10.4; [6fe1bfb0] OffsetArrays v1.1.3; [bac558e1] OrderedCollections v1.3.0; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.0; [90137ffa] StaticArrays v0.12.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [10745b16] Statistics; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1026
https://github.com/CliMA/Oceananigans.jl/issues/1026:5684,Modifiability,Adapt,Adapt,5684,""")}, ::Any) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:214; [5] display(::REPL.REPLDisplay, ::Any) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:218; [6] display(::Any) at ./multimedia.jl:328; [7] #invokelatest#1 at ./essentials.jl:710 [inlined]; [8] invokelatest at ./essentials.jl:709 [inlined]; [9] print_response(::IO, ::Any, ::Bool, ::Bool, ::Any) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:238; [10] print_response(::REPL.AbstractREPL, ::Any, ::Bool, ::Bool) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:223; [11] (::REPL.var""#do_respond#54""{Bool,Bool,REPL.var""#64#73""{REPL.LineEditREPL,REPL.REPLHistoryProvider},REPL.LineEditREPL,REPL.LineEdit.Prompt})(::Any, ::Any, ::Any) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:822; [12] #invokelatest#1 at ./essentials.jl:710 [inlined]; [13] invokelatest at ./essentials.jl:709 [inlined]; [14] run_interface(::REPL.Terminals.TextTerminal, ::REPL.LineEdit.ModalInterface, ::REPL.LineEdit.MIState) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/LineEdit.jl:2355; [15] run_frontend(::REPL.LineEditREPL, ::REPL.REPLBackendRef) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:1144; [16] (::REPL.var""#38#42""{REPL.LineEditREPL,REPL.REPLBackendRef})() at ./task.jl:356. (Oceananigans) pkg> st; Project Oceananigans v0.40.0; Status `~/Research/Oceananigans.jl/Project.toml`; [79e6a3ab] Adapt v2.0.2; [052768ef] CUDA v1.3.3; [a8cc5b0e] Crayons v4.0.4; [7a1cc6ca] FFTW v1.2.4; [033835bb] JLD2 v0.1.14; [63c18a36] KernelAbstractions v0.4.0; [85f8d34a] NCDatasets v0.10.4; [6fe1bfb0] OffsetArrays v1.1.3; [bac558e1] OrderedCollections v1.3.0; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.0; [90137ffa] StaticArrays v0.12.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [10745b16] Statistics; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1026
https://github.com/CliMA/Oceananigans.jl/issues/1026:5948,Safety,Safe,SafeTestsets,5948,""")}, ::Any) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:214; [5] display(::REPL.REPLDisplay, ::Any) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:218; [6] display(::Any) at ./multimedia.jl:328; [7] #invokelatest#1 at ./essentials.jl:710 [inlined]; [8] invokelatest at ./essentials.jl:709 [inlined]; [9] print_response(::IO, ::Any, ::Bool, ::Bool, ::Any) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:238; [10] print_response(::REPL.AbstractREPL, ::Any, ::Bool, ::Bool) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:223; [11] (::REPL.var""#do_respond#54""{Bool,Bool,REPL.var""#64#73""{REPL.LineEditREPL,REPL.REPLHistoryProvider},REPL.LineEditREPL,REPL.LineEdit.Prompt})(::Any, ::Any, ::Any) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:822; [12] #invokelatest#1 at ./essentials.jl:710 [inlined]; [13] invokelatest at ./essentials.jl:709 [inlined]; [14] run_interface(::REPL.Terminals.TextTerminal, ::REPL.LineEdit.ModalInterface, ::REPL.LineEdit.MIState) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/LineEdit.jl:2355; [15] run_frontend(::REPL.LineEditREPL, ::REPL.REPLBackendRef) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:1144; [16] (::REPL.var""#38#42""{REPL.LineEditREPL,REPL.REPLBackendRef})() at ./task.jl:356. (Oceananigans) pkg> st; Project Oceananigans v0.40.0; Status `~/Research/Oceananigans.jl/Project.toml`; [79e6a3ab] Adapt v2.0.2; [052768ef] CUDA v1.3.3; [a8cc5b0e] Crayons v4.0.4; [7a1cc6ca] FFTW v1.2.4; [033835bb] JLD2 v0.1.14; [63c18a36] KernelAbstractions v0.4.0; [85f8d34a] NCDatasets v0.10.4; [6fe1bfb0] OffsetArrays v1.1.3; [bac558e1] OrderedCollections v1.3.0; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.0; [90137ffa] StaticArrays v0.12.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [10745b16] Statistics; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1026
https://github.com/CliMA/Oceananigans.jl/issues/1026:6125,Testability,Log,Logging,6125,""")}, ::Any) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:214; [5] display(::REPL.REPLDisplay, ::Any) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:218; [6] display(::Any) at ./multimedia.jl:328; [7] #invokelatest#1 at ./essentials.jl:710 [inlined]; [8] invokelatest at ./essentials.jl:709 [inlined]; [9] print_response(::IO, ::Any, ::Bool, ::Bool, ::Any) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:238; [10] print_response(::REPL.AbstractREPL, ::Any, ::Bool, ::Bool) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:223; [11] (::REPL.var""#do_respond#54""{Bool,Bool,REPL.var""#64#73""{REPL.LineEditREPL,REPL.REPLHistoryProvider},REPL.LineEditREPL,REPL.LineEdit.Prompt})(::Any, ::Any, ::Any) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:822; [12] #invokelatest#1 at ./essentials.jl:710 [inlined]; [13] invokelatest at ./essentials.jl:709 [inlined]; [14] run_interface(::REPL.Terminals.TextTerminal, ::REPL.LineEdit.ModalInterface, ::REPL.LineEdit.MIState) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/LineEdit.jl:2355; [15] run_frontend(::REPL.LineEditREPL, ::REPL.REPLBackendRef) at /Users/navid/julia/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:1144; [16] (::REPL.var""#38#42""{REPL.LineEditREPL,REPL.REPLBackendRef})() at ./task.jl:356. (Oceananigans) pkg> st; Project Oceananigans v0.40.0; Status `~/Research/Oceananigans.jl/Project.toml`; [79e6a3ab] Adapt v2.0.2; [052768ef] CUDA v1.3.3; [a8cc5b0e] Crayons v4.0.4; [7a1cc6ca] FFTW v1.2.4; [033835bb] JLD2 v0.1.14; [63c18a36] KernelAbstractions v0.4.0; [85f8d34a] NCDatasets v0.10.4; [6fe1bfb0] OffsetArrays v1.1.3; [bac558e1] OrderedCollections v1.3.0; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.0; [90137ffa] StaticArrays v0.12.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [10745b16] Statistics; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1026
https://github.com/CliMA/Oceananigans.jl/issues/1027:151,Usability,clear,clearly,151,"For example, here:; https://github.com/CliMA/Oceananigans.jl/blob/6b2cea36d5782f5a73402b97f4d7476de9237c93/examples/two_dimensional_turbulence.jl#L38; clearly the initial condition is not incompressible. `set!` should somehow remove the compressible part of the initial conditions and perhaps also print out a warning so that the user knows that the model is not initialized exactly with the fields they provided?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1027
https://github.com/CliMA/Oceananigans.jl/pull/1031:232,Availability,down,downloads,232,"Kind of a work-in-progress but would be good to merge as PR #997 depends on these changes. Not the final form of the Buildkite pipeline as I'm still working on improving and expanding it but so far there's an initial job/stage that downloads Julia and instantiates, precompiles, etc. Then all the other jobs can use this new Julia environment to run their tests. Past behavior was just to reuse my Julia environment. I think it's important that CI always creates a fresh environment from scratch as this is how users will install the code usually, and it will help us catch issues like #991 early.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1031
https://github.com/CliMA/Oceananigans.jl/pull/1031:127,Deployability,pipeline,pipeline,127,"Kind of a work-in-progress but would be good to merge as PR #997 depends on these changes. Not the final form of the Buildkite pipeline as I'm still working on improving and expanding it but so far there's an initial job/stage that downloads Julia and instantiates, precompiles, etc. Then all the other jobs can use this new Julia environment to run their tests. Past behavior was just to reuse my Julia environment. I think it's important that CI always creates a fresh environment from scratch as this is how users will install the code usually, and it will help us catch issues like #991 early.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1031
https://github.com/CliMA/Oceananigans.jl/pull/1031:522,Deployability,install,install,522,"Kind of a work-in-progress but would be good to merge as PR #997 depends on these changes. Not the final form of the Buildkite pipeline as I'm still working on improving and expanding it but so far there's an initial job/stage that downloads Julia and instantiates, precompiles, etc. Then all the other jobs can use this new Julia environment to run their tests. Past behavior was just to reuse my Julia environment. I think it's important that CI always creates a fresh environment from scratch as this is how users will install the code usually, and it will help us catch issues like #991 early.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1031
https://github.com/CliMA/Oceananigans.jl/pull/1031:65,Integrability,depend,depends,65,"Kind of a work-in-progress but would be good to merge as PR #997 depends on these changes. Not the final form of the Buildkite pipeline as I'm still working on improving and expanding it but so far there's an initial job/stage that downloads Julia and instantiates, precompiles, etc. Then all the other jobs can use this new Julia environment to run their tests. Past behavior was just to reuse my Julia environment. I think it's important that CI always creates a fresh environment from scratch as this is how users will install the code usually, and it will help us catch issues like #991 early.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1031
https://github.com/CliMA/Oceananigans.jl/pull/1031:356,Testability,test,tests,356,"Kind of a work-in-progress but would be good to merge as PR #997 depends on these changes. Not the final form of the Buildkite pipeline as I'm still working on improving and expanding it but so far there's an initial job/stage that downloads Julia and instantiates, precompiles, etc. Then all the other jobs can use this new Julia environment to run their tests. Past behavior was just to reuse my Julia environment. I think it's important that CI always creates a fresh environment from scratch as this is how users will install the code usually, and it will help us catch issues like #991 early.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1031
https://github.com/CliMA/Oceananigans.jl/pull/1032:17,Deployability,release,release,17,Should tag a new release once PRs #1014 and #997 are merged.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1032
https://github.com/CliMA/Oceananigans.jl/issues/1034:343,Availability,error,error,343,"I attempted to run the [eady_turbulence.jl](https://github.com/CliMA/Oceananigans.jl/blob/master/examples/eady_turbulence.jl) example with `TwoDimensionalLeith()`closure as follows:. ```; closure = (AnisotropicDiffusivity(νh=0, κh=0, νz=κᵥ, κz=κᵥ),; #AnisotropicBiharmonicDiffusivity(νh=κ₄h, κh=κ₄h)); TwoDimensionalLeith()); ```. and got the error posted below. I am using Oceananigans.jl v0.40.0. . ```; ERROR: LoadError: TaskFailedException:; MethodError: no method matching ∂ⱼ_2ν_Σ₁ⱼ(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Clock{Float64}, ::TwoDimensionalLeith{Float64,NamedTuple{(:b,),Tuple{Float64}},NamedTuple{(:b,),Tuple{Float64}}}, ::NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}}, ::NamedTuple{(:νₑ,),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}}); Closest candidates are:; ∂ⱼ_2ν_Σ₁ⱼ(::Any, ::Any, ::Any, ::AbstractGrid, ::Any, ::Tuple{C1,C2}, ::Any, ::Any) where {C1, C2} at /home/guptam/.julia/packages/Oceananigans/g8qkN/src/TurbulenceClosures/closure_tuples.jl:13; ∂ⱼ_2ν_Σ₁ⱼ(::Any, ::Any, ::Any, ::AbstractGrid{FT,TX,TY,TZ} where TZ where TY where TX, ::Any, ::Tuple, ::Any, ::Any, ::Any...) where FT at /home/guptam/.julia/packages/Oceananigans/g8qkN/src/TurbulenceClosures/TurbulenceClosures.jl:110; ∂ⱼ_2ν_Σ₁ⱼ(::Any, ::Any, ::Any, ::Any, ::Any, ::IsotropicDiffusivity, ::Any, ::Any...) at /home/guptam/.julia/packages/Oceananigans/g8qkN/src/TurbulenceClosures/turbulence_closure_implementations/isotropic_diffusivity.jl:53; ...; Stacktrace:; [1] call at /home/guptam/.julia/packages/Cassette/158rp/src/context.jl:456 [inlined]; [2] fallback at /home/guptam/.julia/packages/Cassette/158rp/src/context.jl:454 [inlined]; [3] _overdub_fallback at /home/guptam/.juli",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1034
https://github.com/CliMA/Oceananigans.jl/issues/1034:406,Availability,ERROR,ERROR,406,"I attempted to run the [eady_turbulence.jl](https://github.com/CliMA/Oceananigans.jl/blob/master/examples/eady_turbulence.jl) example with `TwoDimensionalLeith()`closure as follows:. ```; closure = (AnisotropicDiffusivity(νh=0, κh=0, νz=κᵥ, κz=κᵥ),; #AnisotropicBiharmonicDiffusivity(νh=κ₄h, κh=κ₄h)); TwoDimensionalLeith()); ```. and got the error posted below. I am using Oceananigans.jl v0.40.0. . ```; ERROR: LoadError: TaskFailedException:; MethodError: no method matching ∂ⱼ_2ν_Σ₁ⱼ(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Clock{Float64}, ::TwoDimensionalLeith{Float64,NamedTuple{(:b,),Tuple{Float64}},NamedTuple{(:b,),Tuple{Float64}}}, ::NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}}, ::NamedTuple{(:νₑ,),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}}); Closest candidates are:; ∂ⱼ_2ν_Σ₁ⱼ(::Any, ::Any, ::Any, ::AbstractGrid, ::Any, ::Tuple{C1,C2}, ::Any, ::Any) where {C1, C2} at /home/guptam/.julia/packages/Oceananigans/g8qkN/src/TurbulenceClosures/closure_tuples.jl:13; ∂ⱼ_2ν_Σ₁ⱼ(::Any, ::Any, ::Any, ::AbstractGrid{FT,TX,TY,TZ} where TZ where TY where TX, ::Any, ::Tuple, ::Any, ::Any, ::Any...) where FT at /home/guptam/.julia/packages/Oceananigans/g8qkN/src/TurbulenceClosures/TurbulenceClosures.jl:110; ∂ⱼ_2ν_Σ₁ⱼ(::Any, ::Any, ::Any, ::Any, ::Any, ::IsotropicDiffusivity, ::Any, ::Any...) at /home/guptam/.julia/packages/Oceananigans/g8qkN/src/TurbulenceClosures/turbulence_closure_implementations/isotropic_diffusivity.jl:53; ...; Stacktrace:; [1] call at /home/guptam/.julia/packages/Cassette/158rp/src/context.jl:456 [inlined]; [2] fallback at /home/guptam/.julia/packages/Cassette/158rp/src/context.jl:454 [inlined]; [3] _overdub_fallback at /home/guptam/.juli",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1034
https://github.com/CliMA/Oceananigans.jl/issues/1034:15541,Modifiability,Parameteriz,ParameterizedDiscreteBoundaryFunction,15541,"eriodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Float64,BuoyancyTracer,FPlane{Float64},Nothing,NamedTuple{(:u, :v, :w),Tuple{Field{Face,Cell,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Oceananigans.BoundaryConditions.ParameterizedDiscreteBoundaryFunction{typeof(τ₁₃_linear_drag),NamedTuple{(:μ, :H),Tuple{Float64,Float64}}}},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Face,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Oceananigans.BoundaryConditions.ParameterizedDiscreteBoundaryFunction{typeof(τ₂₃_linear_drag),NamedTuple{(:μ, :H),Tuple{Float64,Float64}}}},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Cell,Face,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Period",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1034
https://github.com/CliMA/Oceananigans.jl/issues/1034:16377,Modifiability,Parameteriz,ParameterizedDiscreteBoundaryFunction,16377,"eBoundaryConditions{BoundaryCondition{Flux,Oceananigans.BoundaryConditions.ParameterizedDiscreteBoundaryFunction{typeof(τ₁₃_linear_drag),NamedTuple{(:μ, :H),Tuple{Float64,Float64}}}},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Face,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Oceananigans.BoundaryConditions.ParameterizedDiscreteBoundaryFunction{typeof(τ₂₃_linear_drag),NamedTuple{(:μ, :H),Tuple{Float64,Float64}}}},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Cell,Face,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{NormalFlow,Nothing},BoundaryCondition{NormalFlow,Nothing}}}}}}},NamedTuple{(:b,),Tuple{Field{Cell,Cell,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecisio",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1034
https://github.com/CliMA/Oceananigans.jl/issues/1034:25501,Modifiability,Parameteriz,ParameterizedDiscreteBoundaryFunction,25501,"eriodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Float64,BuoyancyTracer,FPlane{Float64},Nothing,NamedTuple{(:u, :v, :w),Tuple{Field{Face,Cell,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Oceananigans.BoundaryConditions.ParameterizedDiscreteBoundaryFunction{typeof(τ₁₃_linear_drag),NamedTuple{(:μ, :H),Tuple{Float64,Float64}}}},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Face,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Oceananigans.BoundaryConditions.ParameterizedDiscreteBoundaryFunction{typeof(τ₂₃_linear_drag),NamedTuple{(:μ, :H),Tuple{Float64,Float64}}}},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Cell,Face,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Period",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1034
https://github.com/CliMA/Oceananigans.jl/issues/1034:26337,Modifiability,Parameteriz,ParameterizedDiscreteBoundaryFunction,26337,"eBoundaryConditions{BoundaryCondition{Flux,Oceananigans.BoundaryConditions.ParameterizedDiscreteBoundaryFunction{typeof(τ₁₃_linear_drag),NamedTuple{(:μ, :H),Tuple{Float64,Float64}}}},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Face,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Oceananigans.BoundaryConditions.ParameterizedDiscreteBoundaryFunction{typeof(τ₂₃_linear_drag),NamedTuple{(:μ, :H),Tuple{Float64,Float64}}}},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Cell,Face,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{NormalFlow,Nothing},BoundaryCondition{NormalFlow,Nothing}}}}}}},NamedTuple{(:b,),Tuple{Field{Cell,Cell,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecisio",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1034
https://github.com/CliMA/Oceananigans.jl/issues/1034:413,Performance,Load,LoadError,413,"I attempted to run the [eady_turbulence.jl](https://github.com/CliMA/Oceananigans.jl/blob/master/examples/eady_turbulence.jl) example with `TwoDimensionalLeith()`closure as follows:. ```; closure = (AnisotropicDiffusivity(νh=0, κh=0, νz=κᵥ, κz=κᵥ),; #AnisotropicBiharmonicDiffusivity(νh=κ₄h, κh=κ₄h)); TwoDimensionalLeith()); ```. and got the error posted below. I am using Oceananigans.jl v0.40.0. . ```; ERROR: LoadError: TaskFailedException:; MethodError: no method matching ∂ⱼ_2ν_Σ₁ⱼ(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Clock{Float64}, ::TwoDimensionalLeith{Float64,NamedTuple{(:b,),Tuple{Float64}},NamedTuple{(:b,),Tuple{Float64}}}, ::NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}}, ::NamedTuple{(:νₑ,),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}}); Closest candidates are:; ∂ⱼ_2ν_Σ₁ⱼ(::Any, ::Any, ::Any, ::AbstractGrid, ::Any, ::Tuple{C1,C2}, ::Any, ::Any) where {C1, C2} at /home/guptam/.julia/packages/Oceananigans/g8qkN/src/TurbulenceClosures/closure_tuples.jl:13; ∂ⱼ_2ν_Σ₁ⱼ(::Any, ::Any, ::Any, ::AbstractGrid{FT,TX,TY,TZ} where TZ where TY where TX, ::Any, ::Tuple, ::Any, ::Any, ::Any...) where FT at /home/guptam/.julia/packages/Oceananigans/g8qkN/src/TurbulenceClosures/TurbulenceClosures.jl:110; ∂ⱼ_2ν_Σ₁ⱼ(::Any, ::Any, ::Any, ::Any, ::Any, ::IsotropicDiffusivity, ::Any, ::Any...) at /home/guptam/.julia/packages/Oceananigans/g8qkN/src/TurbulenceClosures/turbulence_closure_implementations/isotropic_diffusivity.jl:53; ...; Stacktrace:; [1] call at /home/guptam/.julia/packages/Cassette/158rp/src/context.jl:456 [inlined]; [2] fallback at /home/guptam/.julia/packages/Cassette/158rp/src/context.jl:454 [inlined]; [3] _overdub_fallback at /home/guptam/.juli",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1034
https://github.com/CliMA/Oceananigans.jl/issues/1035:136,Availability,down,downloads,136,"Dear Oceananigans developers,; I want to run an example on a HPC server where GPU nodes have no network access. Is it possible to force downloads on the frontend even if GPU is not available ?; Thanks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1035
https://github.com/CliMA/Oceananigans.jl/issues/1035:181,Availability,avail,available,181,"Dear Oceananigans developers,; I want to run an example on a HPC server where GPU nodes have no network access. Is it possible to force downloads on the frontend even if GPU is not available ?; Thanks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1035
https://github.com/CliMA/Oceananigans.jl/issues/1035:104,Security,access,access,104,"Dear Oceananigans developers,; I want to run an example on a HPC server where GPU nodes have no network access. Is it possible to force downloads on the frontend even if GPU is not available ?; Thanks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1035
https://github.com/CliMA/Oceananigans.jl/issues/1036:2454,Availability,mask,masking,2454,"area. Then, an added forcing term incorporates the boundary conditions into the equations. [Mittal and Iaccarino (2003)](https://www.annualreviews.org/doi/abs/10.1146/annurev.fluid.37.061903.175743), outline several ways we could do this, which all fall into two large categories:. 1. Continuous Forcing: We add a forcing term to the continuous equations, discretize the new system, and solve as normal. If the IB is set to coincide with the mesh nodes, then you get a “stairstep” like boundary, whereas if the IB intersects the mesh arbitrarily, you must distribute the forcing to several nearby nodes. Either way, it may not give you a sharp enough boundary, and you get stability constraints on rigid boundaries. . 2. Discrete Forcing: We discretize, then determine what the forcing needs to be at each time step to satisfy the boundary conditions. This method usually takes a predictor-corrector type approach as described by [Balaras (2004)](https://www.sciencedirect.com/science/article/abs/pii/S0045793003000586). You would use a predictor step to interpolate the correct values at the boundary with nearby nodes. Then, you can solve for the necessary forcing in the discretized time stepper. Finally, you recompute the true solution for the next time step, with the correct forcing term. This method does not have the stability constraints and can create a sharper boundary, but implementation will involve more changes to create this routine. . I'm leaning towards the discrete forcing, since it seems like continuous just won't work well for rigid boundaries. I haven't fully worked out how the predictor-corrector idea will work with the pressure solver, etc. . [WRF](https://journals.ametsoc.org/mwr/article/146/9/2781/103105/Large-Eddy-Simulation-over-Complex-Terrain-Using) uses Discrete forcing in their LES IBM code, while [PALM](https://gmd.copernicus.org/articles/8/2515/2015/gmd-8-2515-2015.pdf) uses a masking method that involves stair step representation for complex topography.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036
https://github.com/CliMA/Oceananigans.jl/issues/1036:817,Deployability,Continuous,Continuous,817,"@christophernhill @glwagner @weymouth ; I have been looking into what is the best way to implement an immersed boundary method here, and I hope to be able to model complex topography and possibly moving boundaries with it, for at least Dirichlet and Neumann boundary conditions, within the next year. The immersed boundary method (IBM) is a way to deal with complex topography without a complicated mesh or coordinate transformations. Instead of conforming the mesh to the fluid domain, a cartesian grid is generated over the whole area. Then, an added forcing term incorporates the boundary conditions into the equations. [Mittal and Iaccarino (2003)](https://www.annualreviews.org/doi/abs/10.1146/annurev.fluid.37.061903.175743), outline several ways we could do this, which all fall into two large categories:. 1. Continuous Forcing: We add a forcing term to the continuous equations, discretize the new system, and solve as normal. If the IB is set to coincide with the mesh nodes, then you get a “stairstep” like boundary, whereas if the IB intersects the mesh arbitrarily, you must distribute the forcing to several nearby nodes. Either way, it may not give you a sharp enough boundary, and you get stability constraints on rigid boundaries. . 2. Discrete Forcing: We discretize, then determine what the forcing needs to be at each time step to satisfy the boundary conditions. This method usually takes a predictor-corrector type approach as described by [Balaras (2004)](https://www.sciencedirect.com/science/article/abs/pii/S0045793003000586). You would use a predictor step to interpolate the correct values at the boundary with nearby nodes. Then, you can solve for the necessary forcing in the discretized time stepper. Finally, you recompute the true solution for the next time step, with the correct forcing term. This method does not have the stability constraints and can create a sharper boundary, but implementation will involve more changes to create this routine. . I'm leaning tow",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036
https://github.com/CliMA/Oceananigans.jl/issues/1036:866,Deployability,continuous,continuous,866,"@christophernhill @glwagner @weymouth ; I have been looking into what is the best way to implement an immersed boundary method here, and I hope to be able to model complex topography and possibly moving boundaries with it, for at least Dirichlet and Neumann boundary conditions, within the next year. The immersed boundary method (IBM) is a way to deal with complex topography without a complicated mesh or coordinate transformations. Instead of conforming the mesh to the fluid domain, a cartesian grid is generated over the whole area. Then, an added forcing term incorporates the boundary conditions into the equations. [Mittal and Iaccarino (2003)](https://www.annualreviews.org/doi/abs/10.1146/annurev.fluid.37.061903.175743), outline several ways we could do this, which all fall into two large categories:. 1. Continuous Forcing: We add a forcing term to the continuous equations, discretize the new system, and solve as normal. If the IB is set to coincide with the mesh nodes, then you get a “stairstep” like boundary, whereas if the IB intersects the mesh arbitrarily, you must distribute the forcing to several nearby nodes. Either way, it may not give you a sharp enough boundary, and you get stability constraints on rigid boundaries. . 2. Discrete Forcing: We discretize, then determine what the forcing needs to be at each time step to satisfy the boundary conditions. This method usually takes a predictor-corrector type approach as described by [Balaras (2004)](https://www.sciencedirect.com/science/article/abs/pii/S0045793003000586). You would use a predictor step to interpolate the correct values at the boundary with nearby nodes. Then, you can solve for the necessary forcing in the discretized time stepper. Finally, you recompute the true solution for the next time step, with the correct forcing term. This method does not have the stability constraints and can create a sharper boundary, but implementation will involve more changes to create this routine. . I'm leaning tow",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036
https://github.com/CliMA/Oceananigans.jl/issues/1036:2048,Deployability,continuous,continuous,2048,"area. Then, an added forcing term incorporates the boundary conditions into the equations. [Mittal and Iaccarino (2003)](https://www.annualreviews.org/doi/abs/10.1146/annurev.fluid.37.061903.175743), outline several ways we could do this, which all fall into two large categories:. 1. Continuous Forcing: We add a forcing term to the continuous equations, discretize the new system, and solve as normal. If the IB is set to coincide with the mesh nodes, then you get a “stairstep” like boundary, whereas if the IB intersects the mesh arbitrarily, you must distribute the forcing to several nearby nodes. Either way, it may not give you a sharp enough boundary, and you get stability constraints on rigid boundaries. . 2. Discrete Forcing: We discretize, then determine what the forcing needs to be at each time step to satisfy the boundary conditions. This method usually takes a predictor-corrector type approach as described by [Balaras (2004)](https://www.sciencedirect.com/science/article/abs/pii/S0045793003000586). You would use a predictor step to interpolate the correct values at the boundary with nearby nodes. Then, you can solve for the necessary forcing in the discretized time stepper. Finally, you recompute the true solution for the next time step, with the correct forcing term. This method does not have the stability constraints and can create a sharper boundary, but implementation will involve more changes to create this routine. . I'm leaning towards the discrete forcing, since it seems like continuous just won't work well for rigid boundaries. I haven't fully worked out how the predictor-corrector idea will work with the pressure solver, etc. . [WRF](https://journals.ametsoc.org/mwr/article/146/9/2781/103105/Large-Eddy-Simulation-over-Complex-Terrain-Using) uses Discrete forcing in their LES IBM code, while [PALM](https://gmd.copernicus.org/articles/8/2515/2015/gmd-8-2515-2015.pdf) uses a masking method that involves stair step representation for complex topography.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036
https://github.com/CliMA/Oceananigans.jl/issues/1036:1975,Integrability,rout,routine,1975,"area. Then, an added forcing term incorporates the boundary conditions into the equations. [Mittal and Iaccarino (2003)](https://www.annualreviews.org/doi/abs/10.1146/annurev.fluid.37.061903.175743), outline several ways we could do this, which all fall into two large categories:. 1. Continuous Forcing: We add a forcing term to the continuous equations, discretize the new system, and solve as normal. If the IB is set to coincide with the mesh nodes, then you get a “stairstep” like boundary, whereas if the IB intersects the mesh arbitrarily, you must distribute the forcing to several nearby nodes. Either way, it may not give you a sharp enough boundary, and you get stability constraints on rigid boundaries. . 2. Discrete Forcing: We discretize, then determine what the forcing needs to be at each time step to satisfy the boundary conditions. This method usually takes a predictor-corrector type approach as described by [Balaras (2004)](https://www.sciencedirect.com/science/article/abs/pii/S0045793003000586). You would use a predictor step to interpolate the correct values at the boundary with nearby nodes. Then, you can solve for the necessary forcing in the discretized time stepper. Finally, you recompute the true solution for the next time step, with the correct forcing term. This method does not have the stability constraints and can create a sharper boundary, but implementation will involve more changes to create this routine. . I'm leaning towards the discrete forcing, since it seems like continuous just won't work well for rigid boundaries. I haven't fully worked out how the predictor-corrector idea will work with the pressure solver, etc. . [WRF](https://journals.ametsoc.org/mwr/article/146/9/2781/103105/Large-Eddy-Simulation-over-Complex-Terrain-Using) uses Discrete forcing in their LES IBM code, while [PALM](https://gmd.copernicus.org/articles/8/2515/2015/gmd-8-2515-2015.pdf) uses a masking method that involves stair step representation for complex topography.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036
https://github.com/CliMA/Oceananigans.jl/issues/1036:1412,Safety,predict,predictor-corrector,1412,"stead of conforming the mesh to the fluid domain, a cartesian grid is generated over the whole area. Then, an added forcing term incorporates the boundary conditions into the equations. [Mittal and Iaccarino (2003)](https://www.annualreviews.org/doi/abs/10.1146/annurev.fluid.37.061903.175743), outline several ways we could do this, which all fall into two large categories:. 1. Continuous Forcing: We add a forcing term to the continuous equations, discretize the new system, and solve as normal. If the IB is set to coincide with the mesh nodes, then you get a “stairstep” like boundary, whereas if the IB intersects the mesh arbitrarily, you must distribute the forcing to several nearby nodes. Either way, it may not give you a sharp enough boundary, and you get stability constraints on rigid boundaries. . 2. Discrete Forcing: We discretize, then determine what the forcing needs to be at each time step to satisfy the boundary conditions. This method usually takes a predictor-corrector type approach as described by [Balaras (2004)](https://www.sciencedirect.com/science/article/abs/pii/S0045793003000586). You would use a predictor step to interpolate the correct values at the boundary with nearby nodes. Then, you can solve for the necessary forcing in the discretized time stepper. Finally, you recompute the true solution for the next time step, with the correct forcing term. This method does not have the stability constraints and can create a sharper boundary, but implementation will involve more changes to create this routine. . I'm leaning towards the discrete forcing, since it seems like continuous just won't work well for rigid boundaries. I haven't fully worked out how the predictor-corrector idea will work with the pressure solver, etc. . [WRF](https://journals.ametsoc.org/mwr/article/146/9/2781/103105/Large-Eddy-Simulation-over-Complex-Terrain-Using) uses Discrete forcing in their LES IBM code, while [PALM](https://gmd.copernicus.org/articles/8/2515/2015/gmd-8-2515-",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036
https://github.com/CliMA/Oceananigans.jl/issues/1036:1569,Safety,predict,predictor,1569,"area. Then, an added forcing term incorporates the boundary conditions into the equations. [Mittal and Iaccarino (2003)](https://www.annualreviews.org/doi/abs/10.1146/annurev.fluid.37.061903.175743), outline several ways we could do this, which all fall into two large categories:. 1. Continuous Forcing: We add a forcing term to the continuous equations, discretize the new system, and solve as normal. If the IB is set to coincide with the mesh nodes, then you get a “stairstep” like boundary, whereas if the IB intersects the mesh arbitrarily, you must distribute the forcing to several nearby nodes. Either way, it may not give you a sharp enough boundary, and you get stability constraints on rigid boundaries. . 2. Discrete Forcing: We discretize, then determine what the forcing needs to be at each time step to satisfy the boundary conditions. This method usually takes a predictor-corrector type approach as described by [Balaras (2004)](https://www.sciencedirect.com/science/article/abs/pii/S0045793003000586). You would use a predictor step to interpolate the correct values at the boundary with nearby nodes. Then, you can solve for the necessary forcing in the discretized time stepper. Finally, you recompute the true solution for the next time step, with the correct forcing term. This method does not have the stability constraints and can create a sharper boundary, but implementation will involve more changes to create this routine. . I'm leaning towards the discrete forcing, since it seems like continuous just won't work well for rigid boundaries. I haven't fully worked out how the predictor-corrector idea will work with the pressure solver, etc. . [WRF](https://journals.ametsoc.org/mwr/article/146/9/2781/103105/Large-Eddy-Simulation-over-Complex-Terrain-Using) uses Discrete forcing in their LES IBM code, while [PALM](https://gmd.copernicus.org/articles/8/2515/2015/gmd-8-2515-2015.pdf) uses a masking method that involves stair step representation for complex topography.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036
https://github.com/CliMA/Oceananigans.jl/issues/1036:2137,Safety,predict,predictor-corrector,2137,"area. Then, an added forcing term incorporates the boundary conditions into the equations. [Mittal and Iaccarino (2003)](https://www.annualreviews.org/doi/abs/10.1146/annurev.fluid.37.061903.175743), outline several ways we could do this, which all fall into two large categories:. 1. Continuous Forcing: We add a forcing term to the continuous equations, discretize the new system, and solve as normal. If the IB is set to coincide with the mesh nodes, then you get a “stairstep” like boundary, whereas if the IB intersects the mesh arbitrarily, you must distribute the forcing to several nearby nodes. Either way, it may not give you a sharp enough boundary, and you get stability constraints on rigid boundaries. . 2. Discrete Forcing: We discretize, then determine what the forcing needs to be at each time step to satisfy the boundary conditions. This method usually takes a predictor-corrector type approach as described by [Balaras (2004)](https://www.sciencedirect.com/science/article/abs/pii/S0045793003000586). You would use a predictor step to interpolate the correct values at the boundary with nearby nodes. Then, you can solve for the necessary forcing in the discretized time stepper. Finally, you recompute the true solution for the next time step, with the correct forcing term. This method does not have the stability constraints and can create a sharper boundary, but implementation will involve more changes to create this routine. . I'm leaning towards the discrete forcing, since it seems like continuous just won't work well for rigid boundaries. I haven't fully worked out how the predictor-corrector idea will work with the pressure solver, etc. . [WRF](https://journals.ametsoc.org/mwr/article/146/9/2781/103105/Large-Eddy-Simulation-over-Complex-Terrain-Using) uses Discrete forcing in their LES IBM code, while [PALM](https://gmd.copernicus.org/articles/8/2515/2015/gmd-8-2515-2015.pdf) uses a masking method that involves stair step representation for complex topography.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036
https://github.com/CliMA/Oceananigans.jl/pull/1038:65,Availability,down,downloads,65,"Was accidently running on the Caltech cluster. Also, now it only downloads Julia if the server version is newer than an existing local file (`wget -N`).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1038
https://github.com/CliMA/Oceananigans.jl/pull/1039:0,Availability,Checkpoint,Checkpointer,0,Checkpointer was failing due to an upstream bug in JLD2.jl that has now been fixed: https://github.com/JuliaIO/JLD2.jl/issues/247,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1039
https://github.com/CliMA/Oceananigans.jl/pull/1040:924,Integrability,interface,interface,924,"This PR refactors the `NetCDFOutputWriter` to use `FieldSlicer` (which cleans it up a bit) and adds support for time-averaging for NetCDF. All the existing NetCDF tests pass (of which there are quite a few). I also added a test for strided windowed time averaging of horizontal averages for `NetCDFOutputWriter`. Oceananigans solves `∂c/∂t = - λ(x, y, z) c` where `λ(x, y, z) = x + (1 - y)^2 + tanh(z)` which is independent exoponential decay at every grid point so you can analytically compute what the output of the horizontal average and the strided windowed time average should be. Thankfully the test passes :tada:. I also reorganized `test_output_writers.jl` quite a bit. I think it's big enough that it should be split up into multiple files but I'll leave this for a future PR since it would make reviewing this PR's diff difficult. Would be nice if NetCDF accepted a named tuple for `outputs` and had a less clunky interface than just dicts for everything. Might have to wait for a future PR though... X-Ref: https://github.com/Alexander-Barth/NCDatasets.jl/issues/105. Resolves #876",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1040
https://github.com/CliMA/Oceananigans.jl/pull/1040:8,Modifiability,refactor,refactors,8,"This PR refactors the `NetCDFOutputWriter` to use `FieldSlicer` (which cleans it up a bit) and adds support for time-averaging for NetCDF. All the existing NetCDF tests pass (of which there are quite a few). I also added a test for strided windowed time averaging of horizontal averages for `NetCDFOutputWriter`. Oceananigans solves `∂c/∂t = - λ(x, y, z) c` where `λ(x, y, z) = x + (1 - y)^2 + tanh(z)` which is independent exoponential decay at every grid point so you can analytically compute what the output of the horizontal average and the strided windowed time average should be. Thankfully the test passes :tada:. I also reorganized `test_output_writers.jl` quite a bit. I think it's big enough that it should be split up into multiple files but I'll leave this for a future PR since it would make reviewing this PR's diff difficult. Would be nice if NetCDF accepted a named tuple for `outputs` and had a less clunky interface than just dicts for everything. Might have to wait for a future PR though... X-Ref: https://github.com/Alexander-Barth/NCDatasets.jl/issues/105. Resolves #876",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1040
https://github.com/CliMA/Oceananigans.jl/pull/1040:163,Testability,test,tests,163,"This PR refactors the `NetCDFOutputWriter` to use `FieldSlicer` (which cleans it up a bit) and adds support for time-averaging for NetCDF. All the existing NetCDF tests pass (of which there are quite a few). I also added a test for strided windowed time averaging of horizontal averages for `NetCDFOutputWriter`. Oceananigans solves `∂c/∂t = - λ(x, y, z) c` where `λ(x, y, z) = x + (1 - y)^2 + tanh(z)` which is independent exoponential decay at every grid point so you can analytically compute what the output of the horizontal average and the strided windowed time average should be. Thankfully the test passes :tada:. I also reorganized `test_output_writers.jl` quite a bit. I think it's big enough that it should be split up into multiple files but I'll leave this for a future PR since it would make reviewing this PR's diff difficult. Would be nice if NetCDF accepted a named tuple for `outputs` and had a less clunky interface than just dicts for everything. Might have to wait for a future PR though... X-Ref: https://github.com/Alexander-Barth/NCDatasets.jl/issues/105. Resolves #876",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1040
https://github.com/CliMA/Oceananigans.jl/pull/1040:223,Testability,test,test,223,"This PR refactors the `NetCDFOutputWriter` to use `FieldSlicer` (which cleans it up a bit) and adds support for time-averaging for NetCDF. All the existing NetCDF tests pass (of which there are quite a few). I also added a test for strided windowed time averaging of horizontal averages for `NetCDFOutputWriter`. Oceananigans solves `∂c/∂t = - λ(x, y, z) c` where `λ(x, y, z) = x + (1 - y)^2 + tanh(z)` which is independent exoponential decay at every grid point so you can analytically compute what the output of the horizontal average and the strided windowed time average should be. Thankfully the test passes :tada:. I also reorganized `test_output_writers.jl` quite a bit. I think it's big enough that it should be split up into multiple files but I'll leave this for a future PR since it would make reviewing this PR's diff difficult. Would be nice if NetCDF accepted a named tuple for `outputs` and had a less clunky interface than just dicts for everything. Might have to wait for a future PR though... X-Ref: https://github.com/Alexander-Barth/NCDatasets.jl/issues/105. Resolves #876",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1040
https://github.com/CliMA/Oceananigans.jl/pull/1040:601,Testability,test,test,601,"This PR refactors the `NetCDFOutputWriter` to use `FieldSlicer` (which cleans it up a bit) and adds support for time-averaging for NetCDF. All the existing NetCDF tests pass (of which there are quite a few). I also added a test for strided windowed time averaging of horizontal averages for `NetCDFOutputWriter`. Oceananigans solves `∂c/∂t = - λ(x, y, z) c` where `λ(x, y, z) = x + (1 - y)^2 + tanh(z)` which is independent exoponential decay at every grid point so you can analytically compute what the output of the horizontal average and the strided windowed time average should be. Thankfully the test passes :tada:. I also reorganized `test_output_writers.jl` quite a bit. I think it's big enough that it should be split up into multiple files but I'll leave this for a future PR since it would make reviewing this PR's diff difficult. Would be nice if NetCDF accepted a named tuple for `outputs` and had a less clunky interface than just dicts for everything. Might have to wait for a future PR though... X-Ref: https://github.com/Alexander-Barth/NCDatasets.jl/issues/105. Resolves #876",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1040
https://github.com/CliMA/Oceananigans.jl/pull/1041:175,Testability,test,tested,175,"This pull request changes the compat entry for the `JLD2` package from `^0.1.2, ^1` to `^0.1.2, ^1, 0.2`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1041
https://github.com/CliMA/Oceananigans.jl/pull/1041:280,Testability,test,tests,280,"This pull request changes the compat entry for the `JLD2` package from `^0.1.2, ^1` to `^0.1.2, ^1, 0.2`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1041
https://github.com/CliMA/Oceananigans.jl/pull/1042:175,Testability,test,tested,175,"This pull request changes the compat entry for the `JLD2` package from `^0.1.2, ^1` to `^0.1.2, ^1, 0.2`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1042
https://github.com/CliMA/Oceananigans.jl/pull/1042:280,Testability,test,tests,280,"This pull request changes the compat entry for the `JLD2` package from `^0.1.2, ^1` to `^0.1.2, ^1, 0.2`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1042
https://github.com/CliMA/Oceananigans.jl/issues/1044:19,Usability,guid,guide,19,Seems like a solid guide and we already follow some of the guidlines: https://github.com/SciML/ColPrac. This would modify https://github.com/CliMA/Oceananigans.jl/blob/master/CONTRIBUTING.md. We also get a nice badge:. [![ColPrac: Contributor's Guide on Collaborative Practices for Community Packages](https://img.shields.io/badge/ColPrac-Contributor's%20Guide-blueviolet)](https://github.com/SciML/ColPrac),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1044
https://github.com/CliMA/Oceananigans.jl/issues/1044:59,Usability,guid,guidlines,59,Seems like a solid guide and we already follow some of the guidlines: https://github.com/SciML/ColPrac. This would modify https://github.com/CliMA/Oceananigans.jl/blob/master/CONTRIBUTING.md. We also get a nice badge:. [![ColPrac: Contributor's Guide on Collaborative Practices for Community Packages](https://img.shields.io/badge/ColPrac-Contributor's%20Guide-blueviolet)](https://github.com/SciML/ColPrac),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1044
https://github.com/CliMA/Oceananigans.jl/issues/1044:245,Usability,Guid,Guide,245,Seems like a solid guide and we already follow some of the guidlines: https://github.com/SciML/ColPrac. This would modify https://github.com/CliMA/Oceananigans.jl/blob/master/CONTRIBUTING.md. We also get a nice badge:. [![ColPrac: Contributor's Guide on Collaborative Practices for Community Packages](https://img.shields.io/badge/ColPrac-Contributor's%20Guide-blueviolet)](https://github.com/SciML/ColPrac),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1044
https://github.com/CliMA/Oceananigans.jl/issues/1045:251,Availability,error,error,251,"For example, when running on MIT's Satori cluster one must use a magic incantation to obtain useful output (and also to run 4 simulations on a single node):. ```bash; #!/bin/bash. #SBATCH --job-name=eady; #SBATCH --output=slurm-eady-%j.out; #SBATCH --error=slurm-eady-%j.err; #SBATCH --time=12:00:00; #SBARCH --mem=0; #SBATCH --nodes=1; #SBATCH --ntasks-per-node=4; #SBATCH --gres=""gpu:4"" # GPUs per Node; #SBATCH --cpus-per-task=4. # Clear the environment from any previously loaded modules; module purge > /dev/null 2>&1. module load spack/0.1; module load gcc/8.3.0 # to get libquadmath; module load julia/1.4.1; module load cuda/10.1.243; module load openmpi/3.1.4-pmi-cuda; module load py-matplotlib/3.1.1. DIR=""$( cd ""$( dirname ""${BASH_SOURCE[0]}"" )"" >/dev/null 2>&1 && pwd )"". cd $DIR/../Oceananigans/. CUDA_VISIBLE_DEVICES=0 unbuffer julia --project run_small_eady_problem.jl --Nh 128 --Nz 96 --geostrophic-shear 0.25 --years 2.0 2>&1 | tee quarter_shear.out &; CUDA_VISIBLE_DEVICES=1 unbuffer julia --project run_small_eady_problem.jl --Nh 128 --Nz 96 --geostrophic-shear 0.1 --years 2.0 2>&1 | tee tenth_shear.out &; CUDA_VISIBLE_DEVICES=2 unbuffer julia --project run_small_eady_problem.jl --Nh 192 --Nz 96 --geostrophic-shear 0.25 --years 2.0 2>&1 | tee quarter_shear_hires.out &; CUDA_VISIBLE_DEVICES=3 unbuffer julia --project run_small_eady_problem.jl --Nh 192 --Nz 96 --geostrophic-shear 0.1 --years 2.0 2>&1 | tee tenth_shear_hires.out. sleep 42480 # sleep for 11.8 hours; ```. (and explanations for each part of the script might be helpful)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1045
https://github.com/CliMA/Oceananigans.jl/issues/1045:477,Performance,load,loaded,477,"For example, when running on MIT's Satori cluster one must use a magic incantation to obtain useful output (and also to run 4 simulations on a single node):. ```bash; #!/bin/bash. #SBATCH --job-name=eady; #SBATCH --output=slurm-eady-%j.out; #SBATCH --error=slurm-eady-%j.err; #SBATCH --time=12:00:00; #SBARCH --mem=0; #SBATCH --nodes=1; #SBATCH --ntasks-per-node=4; #SBATCH --gres=""gpu:4"" # GPUs per Node; #SBATCH --cpus-per-task=4. # Clear the environment from any previously loaded modules; module purge > /dev/null 2>&1. module load spack/0.1; module load gcc/8.3.0 # to get libquadmath; module load julia/1.4.1; module load cuda/10.1.243; module load openmpi/3.1.4-pmi-cuda; module load py-matplotlib/3.1.1. DIR=""$( cd ""$( dirname ""${BASH_SOURCE[0]}"" )"" >/dev/null 2>&1 && pwd )"". cd $DIR/../Oceananigans/. CUDA_VISIBLE_DEVICES=0 unbuffer julia --project run_small_eady_problem.jl --Nh 128 --Nz 96 --geostrophic-shear 0.25 --years 2.0 2>&1 | tee quarter_shear.out &; CUDA_VISIBLE_DEVICES=1 unbuffer julia --project run_small_eady_problem.jl --Nh 128 --Nz 96 --geostrophic-shear 0.1 --years 2.0 2>&1 | tee tenth_shear.out &; CUDA_VISIBLE_DEVICES=2 unbuffer julia --project run_small_eady_problem.jl --Nh 192 --Nz 96 --geostrophic-shear 0.25 --years 2.0 2>&1 | tee quarter_shear_hires.out &; CUDA_VISIBLE_DEVICES=3 unbuffer julia --project run_small_eady_problem.jl --Nh 192 --Nz 96 --geostrophic-shear 0.1 --years 2.0 2>&1 | tee tenth_shear_hires.out. sleep 42480 # sleep for 11.8 hours; ```. (and explanations for each part of the script might be helpful)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1045
https://github.com/CliMA/Oceananigans.jl/issues/1045:531,Performance,load,load,531,"For example, when running on MIT's Satori cluster one must use a magic incantation to obtain useful output (and also to run 4 simulations on a single node):. ```bash; #!/bin/bash. #SBATCH --job-name=eady; #SBATCH --output=slurm-eady-%j.out; #SBATCH --error=slurm-eady-%j.err; #SBATCH --time=12:00:00; #SBARCH --mem=0; #SBATCH --nodes=1; #SBATCH --ntasks-per-node=4; #SBATCH --gres=""gpu:4"" # GPUs per Node; #SBATCH --cpus-per-task=4. # Clear the environment from any previously loaded modules; module purge > /dev/null 2>&1. module load spack/0.1; module load gcc/8.3.0 # to get libquadmath; module load julia/1.4.1; module load cuda/10.1.243; module load openmpi/3.1.4-pmi-cuda; module load py-matplotlib/3.1.1. DIR=""$( cd ""$( dirname ""${BASH_SOURCE[0]}"" )"" >/dev/null 2>&1 && pwd )"". cd $DIR/../Oceananigans/. CUDA_VISIBLE_DEVICES=0 unbuffer julia --project run_small_eady_problem.jl --Nh 128 --Nz 96 --geostrophic-shear 0.25 --years 2.0 2>&1 | tee quarter_shear.out &; CUDA_VISIBLE_DEVICES=1 unbuffer julia --project run_small_eady_problem.jl --Nh 128 --Nz 96 --geostrophic-shear 0.1 --years 2.0 2>&1 | tee tenth_shear.out &; CUDA_VISIBLE_DEVICES=2 unbuffer julia --project run_small_eady_problem.jl --Nh 192 --Nz 96 --geostrophic-shear 0.25 --years 2.0 2>&1 | tee quarter_shear_hires.out &; CUDA_VISIBLE_DEVICES=3 unbuffer julia --project run_small_eady_problem.jl --Nh 192 --Nz 96 --geostrophic-shear 0.1 --years 2.0 2>&1 | tee tenth_shear_hires.out. sleep 42480 # sleep for 11.8 hours; ```. (and explanations for each part of the script might be helpful)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1045
https://github.com/CliMA/Oceananigans.jl/issues/1045:554,Performance,load,load,554,"For example, when running on MIT's Satori cluster one must use a magic incantation to obtain useful output (and also to run 4 simulations on a single node):. ```bash; #!/bin/bash. #SBATCH --job-name=eady; #SBATCH --output=slurm-eady-%j.out; #SBATCH --error=slurm-eady-%j.err; #SBATCH --time=12:00:00; #SBARCH --mem=0; #SBATCH --nodes=1; #SBATCH --ntasks-per-node=4; #SBATCH --gres=""gpu:4"" # GPUs per Node; #SBATCH --cpus-per-task=4. # Clear the environment from any previously loaded modules; module purge > /dev/null 2>&1. module load spack/0.1; module load gcc/8.3.0 # to get libquadmath; module load julia/1.4.1; module load cuda/10.1.243; module load openmpi/3.1.4-pmi-cuda; module load py-matplotlib/3.1.1. DIR=""$( cd ""$( dirname ""${BASH_SOURCE[0]}"" )"" >/dev/null 2>&1 && pwd )"". cd $DIR/../Oceananigans/. CUDA_VISIBLE_DEVICES=0 unbuffer julia --project run_small_eady_problem.jl --Nh 128 --Nz 96 --geostrophic-shear 0.25 --years 2.0 2>&1 | tee quarter_shear.out &; CUDA_VISIBLE_DEVICES=1 unbuffer julia --project run_small_eady_problem.jl --Nh 128 --Nz 96 --geostrophic-shear 0.1 --years 2.0 2>&1 | tee tenth_shear.out &; CUDA_VISIBLE_DEVICES=2 unbuffer julia --project run_small_eady_problem.jl --Nh 192 --Nz 96 --geostrophic-shear 0.25 --years 2.0 2>&1 | tee quarter_shear_hires.out &; CUDA_VISIBLE_DEVICES=3 unbuffer julia --project run_small_eady_problem.jl --Nh 192 --Nz 96 --geostrophic-shear 0.1 --years 2.0 2>&1 | tee tenth_shear_hires.out. sleep 42480 # sleep for 11.8 hours; ```. (and explanations for each part of the script might be helpful)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1045
https://github.com/CliMA/Oceananigans.jl/issues/1045:598,Performance,load,load,598,"For example, when running on MIT's Satori cluster one must use a magic incantation to obtain useful output (and also to run 4 simulations on a single node):. ```bash; #!/bin/bash. #SBATCH --job-name=eady; #SBATCH --output=slurm-eady-%j.out; #SBATCH --error=slurm-eady-%j.err; #SBATCH --time=12:00:00; #SBARCH --mem=0; #SBATCH --nodes=1; #SBATCH --ntasks-per-node=4; #SBATCH --gres=""gpu:4"" # GPUs per Node; #SBATCH --cpus-per-task=4. # Clear the environment from any previously loaded modules; module purge > /dev/null 2>&1. module load spack/0.1; module load gcc/8.3.0 # to get libquadmath; module load julia/1.4.1; module load cuda/10.1.243; module load openmpi/3.1.4-pmi-cuda; module load py-matplotlib/3.1.1. DIR=""$( cd ""$( dirname ""${BASH_SOURCE[0]}"" )"" >/dev/null 2>&1 && pwd )"". cd $DIR/../Oceananigans/. CUDA_VISIBLE_DEVICES=0 unbuffer julia --project run_small_eady_problem.jl --Nh 128 --Nz 96 --geostrophic-shear 0.25 --years 2.0 2>&1 | tee quarter_shear.out &; CUDA_VISIBLE_DEVICES=1 unbuffer julia --project run_small_eady_problem.jl --Nh 128 --Nz 96 --geostrophic-shear 0.1 --years 2.0 2>&1 | tee tenth_shear.out &; CUDA_VISIBLE_DEVICES=2 unbuffer julia --project run_small_eady_problem.jl --Nh 192 --Nz 96 --geostrophic-shear 0.25 --years 2.0 2>&1 | tee quarter_shear_hires.out &; CUDA_VISIBLE_DEVICES=3 unbuffer julia --project run_small_eady_problem.jl --Nh 192 --Nz 96 --geostrophic-shear 0.1 --years 2.0 2>&1 | tee tenth_shear_hires.out. sleep 42480 # sleep for 11.8 hours; ```. (and explanations for each part of the script might be helpful)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1045
https://github.com/CliMA/Oceananigans.jl/issues/1045:623,Performance,load,load,623,"For example, when running on MIT's Satori cluster one must use a magic incantation to obtain useful output (and also to run 4 simulations on a single node):. ```bash; #!/bin/bash. #SBATCH --job-name=eady; #SBATCH --output=slurm-eady-%j.out; #SBATCH --error=slurm-eady-%j.err; #SBATCH --time=12:00:00; #SBARCH --mem=0; #SBATCH --nodes=1; #SBATCH --ntasks-per-node=4; #SBATCH --gres=""gpu:4"" # GPUs per Node; #SBATCH --cpus-per-task=4. # Clear the environment from any previously loaded modules; module purge > /dev/null 2>&1. module load spack/0.1; module load gcc/8.3.0 # to get libquadmath; module load julia/1.4.1; module load cuda/10.1.243; module load openmpi/3.1.4-pmi-cuda; module load py-matplotlib/3.1.1. DIR=""$( cd ""$( dirname ""${BASH_SOURCE[0]}"" )"" >/dev/null 2>&1 && pwd )"". cd $DIR/../Oceananigans/. CUDA_VISIBLE_DEVICES=0 unbuffer julia --project run_small_eady_problem.jl --Nh 128 --Nz 96 --geostrophic-shear 0.25 --years 2.0 2>&1 | tee quarter_shear.out &; CUDA_VISIBLE_DEVICES=1 unbuffer julia --project run_small_eady_problem.jl --Nh 128 --Nz 96 --geostrophic-shear 0.1 --years 2.0 2>&1 | tee tenth_shear.out &; CUDA_VISIBLE_DEVICES=2 unbuffer julia --project run_small_eady_problem.jl --Nh 192 --Nz 96 --geostrophic-shear 0.25 --years 2.0 2>&1 | tee quarter_shear_hires.out &; CUDA_VISIBLE_DEVICES=3 unbuffer julia --project run_small_eady_problem.jl --Nh 192 --Nz 96 --geostrophic-shear 0.1 --years 2.0 2>&1 | tee tenth_shear_hires.out. sleep 42480 # sleep for 11.8 hours; ```. (and explanations for each part of the script might be helpful)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1045
https://github.com/CliMA/Oceananigans.jl/issues/1045:650,Performance,load,load,650,"For example, when running on MIT's Satori cluster one must use a magic incantation to obtain useful output (and also to run 4 simulations on a single node):. ```bash; #!/bin/bash. #SBATCH --job-name=eady; #SBATCH --output=slurm-eady-%j.out; #SBATCH --error=slurm-eady-%j.err; #SBATCH --time=12:00:00; #SBARCH --mem=0; #SBATCH --nodes=1; #SBATCH --ntasks-per-node=4; #SBATCH --gres=""gpu:4"" # GPUs per Node; #SBATCH --cpus-per-task=4. # Clear the environment from any previously loaded modules; module purge > /dev/null 2>&1. module load spack/0.1; module load gcc/8.3.0 # to get libquadmath; module load julia/1.4.1; module load cuda/10.1.243; module load openmpi/3.1.4-pmi-cuda; module load py-matplotlib/3.1.1. DIR=""$( cd ""$( dirname ""${BASH_SOURCE[0]}"" )"" >/dev/null 2>&1 && pwd )"". cd $DIR/../Oceananigans/. CUDA_VISIBLE_DEVICES=0 unbuffer julia --project run_small_eady_problem.jl --Nh 128 --Nz 96 --geostrophic-shear 0.25 --years 2.0 2>&1 | tee quarter_shear.out &; CUDA_VISIBLE_DEVICES=1 unbuffer julia --project run_small_eady_problem.jl --Nh 128 --Nz 96 --geostrophic-shear 0.1 --years 2.0 2>&1 | tee tenth_shear.out &; CUDA_VISIBLE_DEVICES=2 unbuffer julia --project run_small_eady_problem.jl --Nh 192 --Nz 96 --geostrophic-shear 0.25 --years 2.0 2>&1 | tee quarter_shear_hires.out &; CUDA_VISIBLE_DEVICES=3 unbuffer julia --project run_small_eady_problem.jl --Nh 192 --Nz 96 --geostrophic-shear 0.1 --years 2.0 2>&1 | tee tenth_shear_hires.out. sleep 42480 # sleep for 11.8 hours; ```. (and explanations for each part of the script might be helpful)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1045
https://github.com/CliMA/Oceananigans.jl/issues/1045:686,Performance,load,load,686,"For example, when running on MIT's Satori cluster one must use a magic incantation to obtain useful output (and also to run 4 simulations on a single node):. ```bash; #!/bin/bash. #SBATCH --job-name=eady; #SBATCH --output=slurm-eady-%j.out; #SBATCH --error=slurm-eady-%j.err; #SBATCH --time=12:00:00; #SBARCH --mem=0; #SBATCH --nodes=1; #SBATCH --ntasks-per-node=4; #SBATCH --gres=""gpu:4"" # GPUs per Node; #SBATCH --cpus-per-task=4. # Clear the environment from any previously loaded modules; module purge > /dev/null 2>&1. module load spack/0.1; module load gcc/8.3.0 # to get libquadmath; module load julia/1.4.1; module load cuda/10.1.243; module load openmpi/3.1.4-pmi-cuda; module load py-matplotlib/3.1.1. DIR=""$( cd ""$( dirname ""${BASH_SOURCE[0]}"" )"" >/dev/null 2>&1 && pwd )"". cd $DIR/../Oceananigans/. CUDA_VISIBLE_DEVICES=0 unbuffer julia --project run_small_eady_problem.jl --Nh 128 --Nz 96 --geostrophic-shear 0.25 --years 2.0 2>&1 | tee quarter_shear.out &; CUDA_VISIBLE_DEVICES=1 unbuffer julia --project run_small_eady_problem.jl --Nh 128 --Nz 96 --geostrophic-shear 0.1 --years 2.0 2>&1 | tee tenth_shear.out &; CUDA_VISIBLE_DEVICES=2 unbuffer julia --project run_small_eady_problem.jl --Nh 192 --Nz 96 --geostrophic-shear 0.25 --years 2.0 2>&1 | tee quarter_shear_hires.out &; CUDA_VISIBLE_DEVICES=3 unbuffer julia --project run_small_eady_problem.jl --Nh 192 --Nz 96 --geostrophic-shear 0.1 --years 2.0 2>&1 | tee tenth_shear_hires.out. sleep 42480 # sleep for 11.8 hours; ```. (and explanations for each part of the script might be helpful)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1045
https://github.com/CliMA/Oceananigans.jl/issues/1045:435,Usability,Clear,Clear,435,"For example, when running on MIT's Satori cluster one must use a magic incantation to obtain useful output (and also to run 4 simulations on a single node):. ```bash; #!/bin/bash. #SBATCH --job-name=eady; #SBATCH --output=slurm-eady-%j.out; #SBATCH --error=slurm-eady-%j.err; #SBATCH --time=12:00:00; #SBARCH --mem=0; #SBATCH --nodes=1; #SBATCH --ntasks-per-node=4; #SBATCH --gres=""gpu:4"" # GPUs per Node; #SBATCH --cpus-per-task=4. # Clear the environment from any previously loaded modules; module purge > /dev/null 2>&1. module load spack/0.1; module load gcc/8.3.0 # to get libquadmath; module load julia/1.4.1; module load cuda/10.1.243; module load openmpi/3.1.4-pmi-cuda; module load py-matplotlib/3.1.1. DIR=""$( cd ""$( dirname ""${BASH_SOURCE[0]}"" )"" >/dev/null 2>&1 && pwd )"". cd $DIR/../Oceananigans/. CUDA_VISIBLE_DEVICES=0 unbuffer julia --project run_small_eady_problem.jl --Nh 128 --Nz 96 --geostrophic-shear 0.25 --years 2.0 2>&1 | tee quarter_shear.out &; CUDA_VISIBLE_DEVICES=1 unbuffer julia --project run_small_eady_problem.jl --Nh 128 --Nz 96 --geostrophic-shear 0.1 --years 2.0 2>&1 | tee tenth_shear.out &; CUDA_VISIBLE_DEVICES=2 unbuffer julia --project run_small_eady_problem.jl --Nh 192 --Nz 96 --geostrophic-shear 0.25 --years 2.0 2>&1 | tee quarter_shear_hires.out &; CUDA_VISIBLE_DEVICES=3 unbuffer julia --project run_small_eady_problem.jl --Nh 192 --Nz 96 --geostrophic-shear 0.1 --years 2.0 2>&1 | tee tenth_shear_hires.out. sleep 42480 # sleep for 11.8 hours; ```. (and explanations for each part of the script might be helpful)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1045
https://github.com/CliMA/Oceananigans.jl/issues/1046:21,Deployability,install,install,21,"The first step is to install the `buildkite-agent` utility on the local machine:. https://buildkite.com/organizations/clima/agents. Then a tag needs to be added to the `buildkite-agent.cfg` file (for example, when buildkite is installed with a system package manager the default configuration file is located at `/etc/buildkite-agent.cfg`). We use two tags (for example):. ```; tags=""queue=Oceananigans,architecture=GPU""; ```. Note that you may not be able to use a space after the comma between two tags. We also set the number of agents via the `spawn` keyword. To start the buildkite agent as a system process, type. ```; sudo systemctl start buildkite-agent; ```. To stop a buildkite agent running as a system process, type. ```; sudo systemctl stop buildkite-agent; ```. Alternatively, `buildkite-agent` can be run in the background via `tmux` or `screen`. When `buildkite-agent` is run as a system process, their status is viewed by typing. ```; sudo systemctl status buildkite-agent; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1046
https://github.com/CliMA/Oceananigans.jl/issues/1046:227,Deployability,install,installed,227,"The first step is to install the `buildkite-agent` utility on the local machine:. https://buildkite.com/organizations/clima/agents. Then a tag needs to be added to the `buildkite-agent.cfg` file (for example, when buildkite is installed with a system package manager the default configuration file is located at `/etc/buildkite-agent.cfg`). We use two tags (for example):. ```; tags=""queue=Oceananigans,architecture=GPU""; ```. Note that you may not be able to use a space after the comma between two tags. We also set the number of agents via the `spawn` keyword. To start the buildkite agent as a system process, type. ```; sudo systemctl start buildkite-agent; ```. To stop a buildkite agent running as a system process, type. ```; sudo systemctl stop buildkite-agent; ```. Alternatively, `buildkite-agent` can be run in the background via `tmux` or `screen`. When `buildkite-agent` is run as a system process, their status is viewed by typing. ```; sudo systemctl status buildkite-agent; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1046
https://github.com/CliMA/Oceananigans.jl/issues/1046:279,Deployability,configurat,configuration,279,"The first step is to install the `buildkite-agent` utility on the local machine:. https://buildkite.com/organizations/clima/agents. Then a tag needs to be added to the `buildkite-agent.cfg` file (for example, when buildkite is installed with a system package manager the default configuration file is located at `/etc/buildkite-agent.cfg`). We use two tags (for example):. ```; tags=""queue=Oceananigans,architecture=GPU""; ```. Note that you may not be able to use a space after the comma between two tags. We also set the number of agents via the `spawn` keyword. To start the buildkite agent as a system process, type. ```; sudo systemctl start buildkite-agent; ```. To stop a buildkite agent running as a system process, type. ```; sudo systemctl stop buildkite-agent; ```. Alternatively, `buildkite-agent` can be run in the background via `tmux` or `screen`. When `buildkite-agent` is run as a system process, their status is viewed by typing. ```; sudo systemctl status buildkite-agent; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1046
https://github.com/CliMA/Oceananigans.jl/issues/1046:279,Modifiability,config,configuration,279,"The first step is to install the `buildkite-agent` utility on the local machine:. https://buildkite.com/organizations/clima/agents. Then a tag needs to be added to the `buildkite-agent.cfg` file (for example, when buildkite is installed with a system package manager the default configuration file is located at `/etc/buildkite-agent.cfg`). We use two tags (for example):. ```; tags=""queue=Oceananigans,architecture=GPU""; ```. Note that you may not be able to use a space after the comma between two tags. We also set the number of agents via the `spawn` keyword. To start the buildkite agent as a system process, type. ```; sudo systemctl start buildkite-agent; ```. To stop a buildkite agent running as a system process, type. ```; sudo systemctl stop buildkite-agent; ```. Alternatively, `buildkite-agent` can be run in the background via `tmux` or `screen`. When `buildkite-agent` is run as a system process, their status is viewed by typing. ```; sudo systemctl status buildkite-agent; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1046
https://github.com/CliMA/Oceananigans.jl/issues/1046:384,Performance,queue,queue,384,"The first step is to install the `buildkite-agent` utility on the local machine:. https://buildkite.com/organizations/clima/agents. Then a tag needs to be added to the `buildkite-agent.cfg` file (for example, when buildkite is installed with a system package manager the default configuration file is located at `/etc/buildkite-agent.cfg`). We use two tags (for example):. ```; tags=""queue=Oceananigans,architecture=GPU""; ```. Note that you may not be able to use a space after the comma between two tags. We also set the number of agents via the `spawn` keyword. To start the buildkite agent as a system process, type. ```; sudo systemctl start buildkite-agent; ```. To stop a buildkite agent running as a system process, type. ```; sudo systemctl stop buildkite-agent; ```. Alternatively, `buildkite-agent` can be run in the background via `tmux` or `screen`. When `buildkite-agent` is run as a system process, their status is viewed by typing. ```; sudo systemctl status buildkite-agent; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1046
https://github.com/CliMA/Oceananigans.jl/issues/1048:108,Testability,test,test,108,Right now the `model` `TEST_GROUP` takes about 48 minutes to run on sverdrup. So it'd be nice to split this test group up so that each test build is < 30 minutes.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1048
https://github.com/CliMA/Oceananigans.jl/issues/1048:135,Testability,test,test,135,Right now the `model` `TEST_GROUP` takes about 48 minutes to run on sverdrup. So it'd be nice to split this test group up so that each test build is < 30 minutes.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1048
https://github.com/CliMA/Oceananigans.jl/issues/1049:94,Deployability,pipeline,pipeline,94,Linux CPU+GPU tests are running on Buildkite so we can stop testing on GitLab CI. One less CI pipeline to maintain.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1049
https://github.com/CliMA/Oceananigans.jl/issues/1049:14,Testability,test,tests,14,Linux CPU+GPU tests are running on Buildkite so we can stop testing on GitLab CI. One less CI pipeline to maintain.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1049
https://github.com/CliMA/Oceananigans.jl/issues/1049:60,Testability,test,testing,60,Linux CPU+GPU tests are running on Buildkite so we can stop testing on GitLab CI. One less CI pipeline to maintain.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1049
https://github.com/CliMA/Oceananigans.jl/issues/1050:27,Testability,test,testing,27,We dumped Appveyor Windows testing since it was super slow. @jakebolewski suggested that CliMA has a lot of Windows testing resources through GitHub Actions so we should try to set something up.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1050
https://github.com/CliMA/Oceananigans.jl/issues/1050:116,Testability,test,testing,116,We dumped Appveyor Windows testing since it was super slow. @jakebolewski suggested that CliMA has a lot of Windows testing resources through GitHub Actions so we should try to set something up.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1050
https://github.com/CliMA/Oceananigans.jl/issues/1051:72,Deployability,deploy,deploy,72,Right now it's done through Travis which is very slow. We can build and deploy docs much faster on Buildkite as Tartarus has lots of CPU resources.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1051
https://github.com/CliMA/Oceananigans.jl/issues/1052:62,Testability,test,tests,62,"Currently I think Travis and GitLab upload them but since GPU tests are moving to Buildkite, coverage artifacts should be uploaded from there.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1052
https://github.com/CliMA/Oceananigans.jl/issues/1053:29,Deployability,deploy,deploying,29,This would make building and deploying docs much faster and allow us to scale up to having higher-resolution examples (and more of them). X-Ref: #1051,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1053
https://github.com/CliMA/Oceananigans.jl/issues/1055:98,Deployability,pipeline,pipeline,98,https://github.com/CliMA/Oceananigans.jl/blob/0908bbdf8f1eed491043d7a9bf1a230c934be7a7/.buildkite/pipeline.yml#L207-L224. does not actually delete the `.julia` depots which can build up and cause future builds to run out of space. I think Buildkite or Linux is limiting the amount of space Buildkite can take up in `/var/lib/buildkite-agent/`. It's just executing `rm -rf`: https://buildkite.com/clima/oceananigans/builds/205. Potential victim builds:; https://buildkite.com/clima/oceananigans/builds/209; https://buildkite.com/clima/oceananigans/builds/210. I removed the old depots on Tartarus but @glwagner you might have to clean up Sverdrup.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1055
https://github.com/CliMA/Oceananigans.jl/issues/1056:101,Availability,down,down,101,"Right now tests cannot proceed until both CPU and GPU environments have been initialized. This slows down testing, especially on the CPU as there are fewer GPU agents (and GPU tests take longer). We should switch to using explicit Buildkite dependencies so GPU tests can start once the GPU environment has been initialized (and same for CPU): https://buildkite.com/docs/pipelines/dependencies#defining-explicit-dependencies",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1056
https://github.com/CliMA/Oceananigans.jl/issues/1056:370,Deployability,pipeline,pipelines,370,"Right now tests cannot proceed until both CPU and GPU environments have been initialized. This slows down testing, especially on the CPU as there are fewer GPU agents (and GPU tests take longer). We should switch to using explicit Buildkite dependencies so GPU tests can start once the GPU environment has been initialized (and same for CPU): https://buildkite.com/docs/pipelines/dependencies#defining-explicit-dependencies",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1056
https://github.com/CliMA/Oceananigans.jl/issues/1056:241,Integrability,depend,dependencies,241,"Right now tests cannot proceed until both CPU and GPU environments have been initialized. This slows down testing, especially on the CPU as there are fewer GPU agents (and GPU tests take longer). We should switch to using explicit Buildkite dependencies so GPU tests can start once the GPU environment has been initialized (and same for CPU): https://buildkite.com/docs/pipelines/dependencies#defining-explicit-dependencies",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1056
https://github.com/CliMA/Oceananigans.jl/issues/1056:380,Integrability,depend,dependencies,380,"Right now tests cannot proceed until both CPU and GPU environments have been initialized. This slows down testing, especially on the CPU as there are fewer GPU agents (and GPU tests take longer). We should switch to using explicit Buildkite dependencies so GPU tests can start once the GPU environment has been initialized (and same for CPU): https://buildkite.com/docs/pipelines/dependencies#defining-explicit-dependencies",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1056
https://github.com/CliMA/Oceananigans.jl/issues/1056:411,Integrability,depend,dependencies,411,"Right now tests cannot proceed until both CPU and GPU environments have been initialized. This slows down testing, especially on the CPU as there are fewer GPU agents (and GPU tests take longer). We should switch to using explicit Buildkite dependencies so GPU tests can start once the GPU environment has been initialized (and same for CPU): https://buildkite.com/docs/pipelines/dependencies#defining-explicit-dependencies",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1056
https://github.com/CliMA/Oceananigans.jl/issues/1056:10,Testability,test,tests,10,"Right now tests cannot proceed until both CPU and GPU environments have been initialized. This slows down testing, especially on the CPU as there are fewer GPU agents (and GPU tests take longer). We should switch to using explicit Buildkite dependencies so GPU tests can start once the GPU environment has been initialized (and same for CPU): https://buildkite.com/docs/pipelines/dependencies#defining-explicit-dependencies",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1056
https://github.com/CliMA/Oceananigans.jl/issues/1056:106,Testability,test,testing,106,"Right now tests cannot proceed until both CPU and GPU environments have been initialized. This slows down testing, especially on the CPU as there are fewer GPU agents (and GPU tests take longer). We should switch to using explicit Buildkite dependencies so GPU tests can start once the GPU environment has been initialized (and same for CPU): https://buildkite.com/docs/pipelines/dependencies#defining-explicit-dependencies",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1056
https://github.com/CliMA/Oceananigans.jl/issues/1056:176,Testability,test,tests,176,"Right now tests cannot proceed until both CPU and GPU environments have been initialized. This slows down testing, especially on the CPU as there are fewer GPU agents (and GPU tests take longer). We should switch to using explicit Buildkite dependencies so GPU tests can start once the GPU environment has been initialized (and same for CPU): https://buildkite.com/docs/pipelines/dependencies#defining-explicit-dependencies",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1056
https://github.com/CliMA/Oceananigans.jl/issues/1056:261,Testability,test,tests,261,"Right now tests cannot proceed until both CPU and GPU environments have been initialized. This slows down testing, especially on the CPU as there are fewer GPU agents (and GPU tests take longer). We should switch to using explicit Buildkite dependencies so GPU tests can start once the GPU environment has been initialized (and same for CPU): https://buildkite.com/docs/pipelines/dependencies#defining-explicit-dependencies",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1056
https://github.com/CliMA/Oceananigans.jl/pull/1057:20,Energy Efficiency,Adapt,Adapt,20,"This PR writes new `Adapt.adapt_structure` methods for `Field`, `AveragedField`, and `ComputedField`:. * `Field` and `ComputedField` are adapted to their data (thus shedding location information, the grid, and boundary conditions). This is fine because we don't reference location information or boundary conditions _inside_ GPU kernels. * `AveragedField` sheds `operand` and `grid` when adapted to the GPU. `AveragedField` still needs location information for `getindex` to work correctly. This obviates the need for `datatuple` (we still keep the function around however because its useful for tests). It also obviates the need for `gpufriendly`. ~~We can now use `AveragedField` and `ComputedField` inside kernels.~~ This still doesn't work. We need to open an issue once this PR is merged. This PR supersedes #746 . Finally, we can dramatically simplify the time-stepping routine since we don't need to ""unwrap"" fields anymore. It's probably worthwhile running a benchmark before merging but hopefully there's no issue. Resolves #722 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1057
https://github.com/CliMA/Oceananigans.jl/pull/1057:137,Energy Efficiency,adapt,adapted,137,"This PR writes new `Adapt.adapt_structure` methods for `Field`, `AveragedField`, and `ComputedField`:. * `Field` and `ComputedField` are adapted to their data (thus shedding location information, the grid, and boundary conditions). This is fine because we don't reference location information or boundary conditions _inside_ GPU kernels. * `AveragedField` sheds `operand` and `grid` when adapted to the GPU. `AveragedField` still needs location information for `getindex` to work correctly. This obviates the need for `datatuple` (we still keep the function around however because its useful for tests). It also obviates the need for `gpufriendly`. ~~We can now use `AveragedField` and `ComputedField` inside kernels.~~ This still doesn't work. We need to open an issue once this PR is merged. This PR supersedes #746 . Finally, we can dramatically simplify the time-stepping routine since we don't need to ""unwrap"" fields anymore. It's probably worthwhile running a benchmark before merging but hopefully there's no issue. Resolves #722 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1057
https://github.com/CliMA/Oceananigans.jl/pull/1057:388,Energy Efficiency,adapt,adapted,388,"This PR writes new `Adapt.adapt_structure` methods for `Field`, `AveragedField`, and `ComputedField`:. * `Field` and `ComputedField` are adapted to their data (thus shedding location information, the grid, and boundary conditions). This is fine because we don't reference location information or boundary conditions _inside_ GPU kernels. * `AveragedField` sheds `operand` and `grid` when adapted to the GPU. `AveragedField` still needs location information for `getindex` to work correctly. This obviates the need for `datatuple` (we still keep the function around however because its useful for tests). It also obviates the need for `gpufriendly`. ~~We can now use `AveragedField` and `ComputedField` inside kernels.~~ This still doesn't work. We need to open an issue once this PR is merged. This PR supersedes #746 . Finally, we can dramatically simplify the time-stepping routine since we don't need to ""unwrap"" fields anymore. It's probably worthwhile running a benchmark before merging but hopefully there's no issue. Resolves #722 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1057
https://github.com/CliMA/Oceananigans.jl/pull/1057:876,Integrability,rout,routine,876,"This PR writes new `Adapt.adapt_structure` methods for `Field`, `AveragedField`, and `ComputedField`:. * `Field` and `ComputedField` are adapted to their data (thus shedding location information, the grid, and boundary conditions). This is fine because we don't reference location information or boundary conditions _inside_ GPU kernels. * `AveragedField` sheds `operand` and `grid` when adapted to the GPU. `AveragedField` still needs location information for `getindex` to work correctly. This obviates the need for `datatuple` (we still keep the function around however because its useful for tests). It also obviates the need for `gpufriendly`. ~~We can now use `AveragedField` and `ComputedField` inside kernels.~~ This still doesn't work. We need to open an issue once this PR is merged. This PR supersedes #746 . Finally, we can dramatically simplify the time-stepping routine since we don't need to ""unwrap"" fields anymore. It's probably worthwhile running a benchmark before merging but hopefully there's no issue. Resolves #722 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1057
https://github.com/CliMA/Oceananigans.jl/pull/1057:20,Modifiability,Adapt,Adapt,20,"This PR writes new `Adapt.adapt_structure` methods for `Field`, `AveragedField`, and `ComputedField`:. * `Field` and `ComputedField` are adapted to their data (thus shedding location information, the grid, and boundary conditions). This is fine because we don't reference location information or boundary conditions _inside_ GPU kernels. * `AveragedField` sheds `operand` and `grid` when adapted to the GPU. `AveragedField` still needs location information for `getindex` to work correctly. This obviates the need for `datatuple` (we still keep the function around however because its useful for tests). It also obviates the need for `gpufriendly`. ~~We can now use `AveragedField` and `ComputedField` inside kernels.~~ This still doesn't work. We need to open an issue once this PR is merged. This PR supersedes #746 . Finally, we can dramatically simplify the time-stepping routine since we don't need to ""unwrap"" fields anymore. It's probably worthwhile running a benchmark before merging but hopefully there's no issue. Resolves #722 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1057
https://github.com/CliMA/Oceananigans.jl/pull/1057:137,Modifiability,adapt,adapted,137,"This PR writes new `Adapt.adapt_structure` methods for `Field`, `AveragedField`, and `ComputedField`:. * `Field` and `ComputedField` are adapted to their data (thus shedding location information, the grid, and boundary conditions). This is fine because we don't reference location information or boundary conditions _inside_ GPU kernels. * `AveragedField` sheds `operand` and `grid` when adapted to the GPU. `AveragedField` still needs location information for `getindex` to work correctly. This obviates the need for `datatuple` (we still keep the function around however because its useful for tests). It also obviates the need for `gpufriendly`. ~~We can now use `AveragedField` and `ComputedField` inside kernels.~~ This still doesn't work. We need to open an issue once this PR is merged. This PR supersedes #746 . Finally, we can dramatically simplify the time-stepping routine since we don't need to ""unwrap"" fields anymore. It's probably worthwhile running a benchmark before merging but hopefully there's no issue. Resolves #722 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1057
https://github.com/CliMA/Oceananigans.jl/pull/1057:388,Modifiability,adapt,adapted,388,"This PR writes new `Adapt.adapt_structure` methods for `Field`, `AveragedField`, and `ComputedField`:. * `Field` and `ComputedField` are adapted to their data (thus shedding location information, the grid, and boundary conditions). This is fine because we don't reference location information or boundary conditions _inside_ GPU kernels. * `AveragedField` sheds `operand` and `grid` when adapted to the GPU. `AveragedField` still needs location information for `getindex` to work correctly. This obviates the need for `datatuple` (we still keep the function around however because its useful for tests). It also obviates the need for `gpufriendly`. ~~We can now use `AveragedField` and `ComputedField` inside kernels.~~ This still doesn't work. We need to open an issue once this PR is merged. This PR supersedes #746 . Finally, we can dramatically simplify the time-stepping routine since we don't need to ""unwrap"" fields anymore. It's probably worthwhile running a benchmark before merging but hopefully there's no issue. Resolves #722 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1057
https://github.com/CliMA/Oceananigans.jl/pull/1057:596,Testability,test,tests,596,"This PR writes new `Adapt.adapt_structure` methods for `Field`, `AveragedField`, and `ComputedField`:. * `Field` and `ComputedField` are adapted to their data (thus shedding location information, the grid, and boundary conditions). This is fine because we don't reference location information or boundary conditions _inside_ GPU kernels. * `AveragedField` sheds `operand` and `grid` when adapted to the GPU. `AveragedField` still needs location information for `getindex` to work correctly. This obviates the need for `datatuple` (we still keep the function around however because its useful for tests). It also obviates the need for `gpufriendly`. ~~We can now use `AveragedField` and `ComputedField` inside kernels.~~ This still doesn't work. We need to open an issue once this PR is merged. This PR supersedes #746 . Finally, we can dramatically simplify the time-stepping routine since we don't need to ""unwrap"" fields anymore. It's probably worthwhile running a benchmark before merging but hopefully there's no issue. Resolves #722 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1057
https://github.com/CliMA/Oceananigans.jl/pull/1057:967,Testability,benchmark,benchmark,967,"This PR writes new `Adapt.adapt_structure` methods for `Field`, `AveragedField`, and `ComputedField`:. * `Field` and `ComputedField` are adapted to their data (thus shedding location information, the grid, and boundary conditions). This is fine because we don't reference location information or boundary conditions _inside_ GPU kernels. * `AveragedField` sheds `operand` and `grid` when adapted to the GPU. `AveragedField` still needs location information for `getindex` to work correctly. This obviates the need for `datatuple` (we still keep the function around however because its useful for tests). It also obviates the need for `gpufriendly`. ~~We can now use `AveragedField` and `ComputedField` inside kernels.~~ This still doesn't work. We need to open an issue once this PR is merged. This PR supersedes #746 . Finally, we can dramatically simplify the time-stepping routine since we don't need to ""unwrap"" fields anymore. It's probably worthwhile running a benchmark before merging but hopefully there's no issue. Resolves #722 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1057
https://github.com/CliMA/Oceananigans.jl/pull/1057:849,Usability,simpl,simplify,849,"This PR writes new `Adapt.adapt_structure` methods for `Field`, `AveragedField`, and `ComputedField`:. * `Field` and `ComputedField` are adapted to their data (thus shedding location information, the grid, and boundary conditions). This is fine because we don't reference location information or boundary conditions _inside_ GPU kernels. * `AveragedField` sheds `operand` and `grid` when adapted to the GPU. `AveragedField` still needs location information for `getindex` to work correctly. This obviates the need for `datatuple` (we still keep the function around however because its useful for tests). It also obviates the need for `gpufriendly`. ~~We can now use `AveragedField` and `ComputedField` inside kernels.~~ This still doesn't work. We need to open an issue once this PR is merged. This PR supersedes #746 . Finally, we can dramatically simplify the time-stepping routine since we don't need to ""unwrap"" fields anymore. It's probably worthwhile running a benchmark before merging but hopefully there's no issue. Resolves #722 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1057
https://github.com/CliMA/Oceananigans.jl/issues/1059:341,Availability,mask,mask,341,"We test `ContinuousForcing` on the GPU. For example:. https://github.com/CliMA/Oceananigans.jl/blob/d0ed71db9a294c344a1fa76f558767f57456d14b/test/test_forcings.jl#L93-L108. but changing this test to involve `AnisotropicMinimumDissipation` makes it fail, eg:. ```julia; function relaxed_time_stepping(arch); x_relax = Relaxation(rate = 1/60, mask = GaussianMask{:x}(center=0.5, width=0.1), ; target = LinearTarget{:x}(intercept=π, gradient=ℯ)). y_relax = Relaxation(rate = 1/60, mask = GaussianMask{:y}(center=0.5, width=0.1),; target = LinearTarget{:y}(intercept=π, gradient=ℯ)). z_relax = Relaxation(rate = 1/60, mask = GaussianMask{:z}(center=0.5, width=0.1),; target = π). grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 1, 1)) ; model = IncompressibleModel(grid=grid,; architecture=arch,; closure=AnisotropicMinimumDissipation(),; forcing=(u=x_relax, v=y_relax, w=z_relax)); time_step!(model, 1, euler=true). return true; end; ```. produces something like. ```; [2020/10/13 17:36:39.154] INFO Testing relaxation forcing functions [GPU]...; Relaxation forcing functions [GPU]: Error During Test at /archive1/glwagner/Projects/Oceananigans.jl/test/test_forcings.jl:145; Test threw exception; Expression: relaxed_time_stepping(arch); InvalidIRError: compiling kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!), OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, Cen",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1059
https://github.com/CliMA/Oceananigans.jl/issues/1059:478,Availability,mask,mask,478,"We test `ContinuousForcing` on the GPU. For example:. https://github.com/CliMA/Oceananigans.jl/blob/d0ed71db9a294c344a1fa76f558767f57456d14b/test/test_forcings.jl#L93-L108. but changing this test to involve `AnisotropicMinimumDissipation` makes it fail, eg:. ```julia; function relaxed_time_stepping(arch); x_relax = Relaxation(rate = 1/60, mask = GaussianMask{:x}(center=0.5, width=0.1), ; target = LinearTarget{:x}(intercept=π, gradient=ℯ)). y_relax = Relaxation(rate = 1/60, mask = GaussianMask{:y}(center=0.5, width=0.1),; target = LinearTarget{:y}(intercept=π, gradient=ℯ)). z_relax = Relaxation(rate = 1/60, mask = GaussianMask{:z}(center=0.5, width=0.1),; target = π). grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 1, 1)) ; model = IncompressibleModel(grid=grid,; architecture=arch,; closure=AnisotropicMinimumDissipation(),; forcing=(u=x_relax, v=y_relax, w=z_relax)); time_step!(model, 1, euler=true). return true; end; ```. produces something like. ```; [2020/10/13 17:36:39.154] INFO Testing relaxation forcing functions [GPU]...; Relaxation forcing functions [GPU]: Error During Test at /archive1/glwagner/Projects/Oceananigans.jl/test/test_forcings.jl:145; Test threw exception; Expression: relaxed_time_stepping(arch); InvalidIRError: compiling kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!), OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, Cen",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1059
https://github.com/CliMA/Oceananigans.jl/issues/1059:614,Availability,mask,mask,614,"We test `ContinuousForcing` on the GPU. For example:. https://github.com/CliMA/Oceananigans.jl/blob/d0ed71db9a294c344a1fa76f558767f57456d14b/test/test_forcings.jl#L93-L108. but changing this test to involve `AnisotropicMinimumDissipation` makes it fail, eg:. ```julia; function relaxed_time_stepping(arch); x_relax = Relaxation(rate = 1/60, mask = GaussianMask{:x}(center=0.5, width=0.1), ; target = LinearTarget{:x}(intercept=π, gradient=ℯ)). y_relax = Relaxation(rate = 1/60, mask = GaussianMask{:y}(center=0.5, width=0.1),; target = LinearTarget{:y}(intercept=π, gradient=ℯ)). z_relax = Relaxation(rate = 1/60, mask = GaussianMask{:z}(center=0.5, width=0.1),; target = π). grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 1, 1)) ; model = IncompressibleModel(grid=grid,; architecture=arch,; closure=AnisotropicMinimumDissipation(),; forcing=(u=x_relax, v=y_relax, w=z_relax)); time_step!(model, 1, euler=true). return true; end; ```. produces something like. ```; [2020/10/13 17:36:39.154] INFO Testing relaxation forcing functions [GPU]...; Relaxation forcing functions [GPU]: Error During Test at /archive1/glwagner/Projects/Oceananigans.jl/test/test_forcings.jl:145; Test threw exception; Expression: relaxed_time_stepping(arch); InvalidIRError: compiling kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!), OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, Cen",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1059
https://github.com/CliMA/Oceananigans.jl/issues/1059:1087,Availability,Error,Error,1087,"/d0ed71db9a294c344a1fa76f558767f57456d14b/test/test_forcings.jl#L93-L108. but changing this test to involve `AnisotropicMinimumDissipation` makes it fail, eg:. ```julia; function relaxed_time_stepping(arch); x_relax = Relaxation(rate = 1/60, mask = GaussianMask{:x}(center=0.5, width=0.1), ; target = LinearTarget{:x}(intercept=π, gradient=ℯ)). y_relax = Relaxation(rate = 1/60, mask = GaussianMask{:y}(center=0.5, width=0.1),; target = LinearTarget{:y}(intercept=π, gradient=ℯ)). z_relax = Relaxation(rate = 1/60, mask = GaussianMask{:z}(center=0.5, width=0.1),; target = π). grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 1, 1)) ; model = IncompressibleModel(grid=grid,; architecture=arch,; closure=AnisotropicMinimumDissipation(),; forcing=(u=x_relax, v=y_relax, w=z_relax)); time_step!(model, 1, euler=true). return true; end; ```. produces something like. ```; [2020/10/13 17:36:39.154] INFO Testing relaxation forcing functions [GPU]...; Relaxation forcing functions [GPU]: Error During Test at /archive1/glwagner/Projects/Oceananigans.jl/test/test_forcings.jl:145; Test threw exception; Expression: relaxed_time_stepping(arch); InvalidIRError: compiling kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!), OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, CenteredSecondOrder, Nothing, Nothing, VerstappenAnisotropicMinimumDissipation{Float64,NamedTuple{(:T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1059
https://github.com/CliMA/Oceananigans.jl/issues/1059:4771,Availability,error,error,4771,"nt64},Tuple{typeof(identity)}},ContinuousForcing{Cell,Cell,Face,Nothing,Relaxation{Float64,GaussianMask{:z,Float64},Irrational{:π}},Nothing,Tuple{Int64},Tuple{typeof(identity)}},typeof(Oceananigans.Forcings.zeroforcing),typeof(Oceananigans.Forcings.zeroforcing)}}, OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}, NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}) resulted in invalid LLVM IR; Reason: unsupported call to the Julia runtime (call to jl_f_getfield); Stacktrace:; [1] getindex at namedtuple.jl:94; [2] field_arguments at /archive1/glwagner/Projects/Oceananigans.jl/src/Forcings/continuous_forcing.jl:118; [3] forcing_func_arguments at /archive1/glwagner/Projects/Oceananigans.jl/src/Forcings/continuous_forcing.jl:139; [4] ContinuousForcing at /archive1/glwagner/Projects/Oceananigans.jl/src/Forcings/continuous_forcing.jl:156; [5] u_velocity_tendency at /archive1/glwagner/Projects/Oceananigans.jl/src/TimeSteppers/velocity_and_tracer_tendencies.jl:56; [6] macro expansion at /archive1/glwagner/Projects/Oceananigans.jl/src/TimeSteppers/calculate_tendencies.jl:124; [7] gpu_calculate_Gu! at /data5/glwagner/.julia/packages/KernelAbstractions/QQ583/src/macros.jl:80; [8] overdub at /data5/glwagner/.julia/packages/Cassette/158rp/src/overdub.jl:0; Reason: unsupported dynamic function invocation (call to getindex); ```. What's happening? The error comes from `continuous_forcing.jl`:. https://github.com/CliMA/Oceananigans.jl/blob/d0ed71db9a294c344a1fa76f558767f57456d14b/src/Forcings/continuous_forcing.jl#L118-L119. the difference between the above two cases is that, in the first, `model_fields` contains only velocities and tracers. In the second, however, `model_fields` also contains `diffusivities`. For `AnisotropicMinimumDissipation`, `diffusivities` is a _nested_ `NamedTuple` with an eddy viscosity field and a tuple of eddy diffusivity fields for each tracer. This problem has affected some scripts I'm working with as well as @raphaelouillon",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1059
https://github.com/CliMA/Oceananigans.jl/issues/1059:9,Deployability,Continuous,ContinuousForcing,9,"We test `ContinuousForcing` on the GPU. For example:. https://github.com/CliMA/Oceananigans.jl/blob/d0ed71db9a294c344a1fa76f558767f57456d14b/test/test_forcings.jl#L93-L108. but changing this test to involve `AnisotropicMinimumDissipation` makes it fail, eg:. ```julia; function relaxed_time_stepping(arch); x_relax = Relaxation(rate = 1/60, mask = GaussianMask{:x}(center=0.5, width=0.1), ; target = LinearTarget{:x}(intercept=π, gradient=ℯ)). y_relax = Relaxation(rate = 1/60, mask = GaussianMask{:y}(center=0.5, width=0.1),; target = LinearTarget{:y}(intercept=π, gradient=ℯ)). z_relax = Relaxation(rate = 1/60, mask = GaussianMask{:z}(center=0.5, width=0.1),; target = π). grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 1, 1)) ; model = IncompressibleModel(grid=grid,; architecture=arch,; closure=AnisotropicMinimumDissipation(),; forcing=(u=x_relax, v=y_relax, w=z_relax)); time_step!(model, 1, euler=true). return true; end; ```. produces something like. ```; [2020/10/13 17:36:39.154] INFO Testing relaxation forcing functions [GPU]...; Relaxation forcing functions [GPU]: Error During Test at /archive1/glwagner/Projects/Oceananigans.jl/test/test_forcings.jl:145; Test threw exception; Expression: relaxed_time_stepping(arch); InvalidIRError: compiling kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!), OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, Cen",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1059
https://github.com/CliMA/Oceananigans.jl/issues/1059:3100,Deployability,Continuous,ContinuousForcing,3100,"Oceananigans.Fields.ZeroField}},NamedTuple{(:T, :S),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}}}}, NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, NamedTuple{(:νₑ, :κₑ),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}}}}, NamedTuple{(:u, :v, :w, :T, :S),Tuple{ContinuousForcing{Face,Cell,Cell,Nothing,Relaxation{Float64,GaussianMask{:x,Float64},LinearTarget{:x,Float64}},Nothing,Tuple{Int64},Tuple{typeof(identity)}},ContinuousForcing{Cell,Face,Cell,Nothing,Relaxation{Float64,GaussianMask{:y,Float64},LinearTarget{:y,Float64}},Nothing,Tuple{Int64},Tuple{typeof(identity)}},ContinuousForcing{Cell,Cell,Face,Nothing,Relaxation{Float64,GaussianMask{:z,Float64},Irrational{:π}},Nothing,Tuple{Int64},Tuple{typeof(identity)}},typeof(Oceananigans.Forcings.zeroforcing),typeof(Oceananigans.Forcings.zeroforcing)}}, OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}, NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}) resulted in invalid LLVM IR; Reason: unsupported call to the Julia runtime (call to jl_f_getfield); Stacktrace:; [1] getindex at namedtuple.jl:94; [2] field_arguments at /archive1/glwagner/Projects/Oceananigans.jl/src/Forcings/continuous_forcing.jl:118; [3] forcing_func_arguments at /archive1/glwagner/Projects/Oceananigans.jl/src/Forcings/continuous_forcing.jl:139; [4] ContinuousForcing at /archive1/glwagner/Projects/Oceananigans.jl/src/Forcings/continuous_forcing.jl:156; [5] u_velocity_tendency at /archive1/glwagner/Projects/Oce",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1059
https://github.com/CliMA/Oceananigans.jl/issues/1059:3257,Deployability,Continuous,ContinuousForcing,3257,"Oceananigans.Fields.ZeroField}},NamedTuple{(:T, :S),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}}}}, NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, NamedTuple{(:νₑ, :κₑ),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}}}}, NamedTuple{(:u, :v, :w, :T, :S),Tuple{ContinuousForcing{Face,Cell,Cell,Nothing,Relaxation{Float64,GaussianMask{:x,Float64},LinearTarget{:x,Float64}},Nothing,Tuple{Int64},Tuple{typeof(identity)}},ContinuousForcing{Cell,Face,Cell,Nothing,Relaxation{Float64,GaussianMask{:y,Float64},LinearTarget{:y,Float64}},Nothing,Tuple{Int64},Tuple{typeof(identity)}},ContinuousForcing{Cell,Cell,Face,Nothing,Relaxation{Float64,GaussianMask{:z,Float64},Irrational{:π}},Nothing,Tuple{Int64},Tuple{typeof(identity)}},typeof(Oceananigans.Forcings.zeroforcing),typeof(Oceananigans.Forcings.zeroforcing)}}, OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}, NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}) resulted in invalid LLVM IR; Reason: unsupported call to the Julia runtime (call to jl_f_getfield); Stacktrace:; [1] getindex at namedtuple.jl:94; [2] field_arguments at /archive1/glwagner/Projects/Oceananigans.jl/src/Forcings/continuous_forcing.jl:118; [3] forcing_func_arguments at /archive1/glwagner/Projects/Oceananigans.jl/src/Forcings/continuous_forcing.jl:139; [4] ContinuousForcing at /archive1/glwagner/Projects/Oceananigans.jl/src/Forcings/continuous_forcing.jl:156; [5] u_velocity_tendency at /archive1/glwagner/Projects/Oce",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1059
https://github.com/CliMA/Oceananigans.jl/issues/1059:3414,Deployability,Continuous,ContinuousForcing,3414,"Oceananigans.Fields.ZeroField}},NamedTuple{(:T, :S),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}}}}, NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, NamedTuple{(:νₑ, :κₑ),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}}}}, NamedTuple{(:u, :v, :w, :T, :S),Tuple{ContinuousForcing{Face,Cell,Cell,Nothing,Relaxation{Float64,GaussianMask{:x,Float64},LinearTarget{:x,Float64}},Nothing,Tuple{Int64},Tuple{typeof(identity)}},ContinuousForcing{Cell,Face,Cell,Nothing,Relaxation{Float64,GaussianMask{:y,Float64},LinearTarget{:y,Float64}},Nothing,Tuple{Int64},Tuple{typeof(identity)}},ContinuousForcing{Cell,Cell,Face,Nothing,Relaxation{Float64,GaussianMask{:z,Float64},Irrational{:π}},Nothing,Tuple{Int64},Tuple{typeof(identity)}},typeof(Oceananigans.Forcings.zeroforcing),typeof(Oceananigans.Forcings.zeroforcing)}}, OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}, NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}) resulted in invalid LLVM IR; Reason: unsupported call to the Julia runtime (call to jl_f_getfield); Stacktrace:; [1] getindex at namedtuple.jl:94; [2] field_arguments at /archive1/glwagner/Projects/Oceananigans.jl/src/Forcings/continuous_forcing.jl:118; [3] forcing_func_arguments at /archive1/glwagner/Projects/Oceananigans.jl/src/Forcings/continuous_forcing.jl:139; [4] ContinuousForcing at /archive1/glwagner/Projects/Oceananigans.jl/src/Forcings/continuous_forcing.jl:156; [5] u_velocity_tendency at /archive1/glwagner/Projects/Oce",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1059
https://github.com/CliMA/Oceananigans.jl/issues/1059:4152,Deployability,Continuous,ContinuousForcing,4152,"loat64},LinearTarget{:x,Float64}},Nothing,Tuple{Int64},Tuple{typeof(identity)}},ContinuousForcing{Cell,Face,Cell,Nothing,Relaxation{Float64,GaussianMask{:y,Float64},LinearTarget{:y,Float64}},Nothing,Tuple{Int64},Tuple{typeof(identity)}},ContinuousForcing{Cell,Cell,Face,Nothing,Relaxation{Float64,GaussianMask{:z,Float64},Irrational{:π}},Nothing,Tuple{Int64},Tuple{typeof(identity)}},typeof(Oceananigans.Forcings.zeroforcing),typeof(Oceananigans.Forcings.zeroforcing)}}, OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}, NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}) resulted in invalid LLVM IR; Reason: unsupported call to the Julia runtime (call to jl_f_getfield); Stacktrace:; [1] getindex at namedtuple.jl:94; [2] field_arguments at /archive1/glwagner/Projects/Oceananigans.jl/src/Forcings/continuous_forcing.jl:118; [3] forcing_func_arguments at /archive1/glwagner/Projects/Oceananigans.jl/src/Forcings/continuous_forcing.jl:139; [4] ContinuousForcing at /archive1/glwagner/Projects/Oceananigans.jl/src/Forcings/continuous_forcing.jl:156; [5] u_velocity_tendency at /archive1/glwagner/Projects/Oceananigans.jl/src/TimeSteppers/velocity_and_tracer_tendencies.jl:56; [6] macro expansion at /archive1/glwagner/Projects/Oceananigans.jl/src/TimeSteppers/calculate_tendencies.jl:124; [7] gpu_calculate_Gu! at /data5/glwagner/.julia/packages/KernelAbstractions/QQ583/src/macros.jl:80; [8] overdub at /data5/glwagner/.julia/packages/Cassette/158rp/src/overdub.jl:0; Reason: unsupported dynamic function invocation (call to getindex); ```. What's happening? The error comes from `continuous_forcing.jl`:. https://github.com/CliMA/Oceananigans.jl/blob/d0ed71db9a294c344a1fa76f558767f57456d14b/src/Forcings/continuous_forcing.jl#L118-L119. the difference between the above two cases is that, in the first, `model_fields` contains only velocities and tracers. In the second, however, `model_fields` also contains `diffusivities`. For `AnisotropicMinimumDissipation`, `dif",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1059
https://github.com/CliMA/Oceananigans.jl/issues/1059:3,Testability,test,test,3,"We test `ContinuousForcing` on the GPU. For example:. https://github.com/CliMA/Oceananigans.jl/blob/d0ed71db9a294c344a1fa76f558767f57456d14b/test/test_forcings.jl#L93-L108. but changing this test to involve `AnisotropicMinimumDissipation` makes it fail, eg:. ```julia; function relaxed_time_stepping(arch); x_relax = Relaxation(rate = 1/60, mask = GaussianMask{:x}(center=0.5, width=0.1), ; target = LinearTarget{:x}(intercept=π, gradient=ℯ)). y_relax = Relaxation(rate = 1/60, mask = GaussianMask{:y}(center=0.5, width=0.1),; target = LinearTarget{:y}(intercept=π, gradient=ℯ)). z_relax = Relaxation(rate = 1/60, mask = GaussianMask{:z}(center=0.5, width=0.1),; target = π). grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 1, 1)) ; model = IncompressibleModel(grid=grid,; architecture=arch,; closure=AnisotropicMinimumDissipation(),; forcing=(u=x_relax, v=y_relax, w=z_relax)); time_step!(model, 1, euler=true). return true; end; ```. produces something like. ```; [2020/10/13 17:36:39.154] INFO Testing relaxation forcing functions [GPU]...; Relaxation forcing functions [GPU]: Error During Test at /archive1/glwagner/Projects/Oceananigans.jl/test/test_forcings.jl:145; Test threw exception; Expression: relaxed_time_stepping(arch); InvalidIRError: compiling kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!), OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, Cen",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1059
https://github.com/CliMA/Oceananigans.jl/issues/1059:141,Testability,test,test,141,"We test `ContinuousForcing` on the GPU. For example:. https://github.com/CliMA/Oceananigans.jl/blob/d0ed71db9a294c344a1fa76f558767f57456d14b/test/test_forcings.jl#L93-L108. but changing this test to involve `AnisotropicMinimumDissipation` makes it fail, eg:. ```julia; function relaxed_time_stepping(arch); x_relax = Relaxation(rate = 1/60, mask = GaussianMask{:x}(center=0.5, width=0.1), ; target = LinearTarget{:x}(intercept=π, gradient=ℯ)). y_relax = Relaxation(rate = 1/60, mask = GaussianMask{:y}(center=0.5, width=0.1),; target = LinearTarget{:y}(intercept=π, gradient=ℯ)). z_relax = Relaxation(rate = 1/60, mask = GaussianMask{:z}(center=0.5, width=0.1),; target = π). grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 1, 1)) ; model = IncompressibleModel(grid=grid,; architecture=arch,; closure=AnisotropicMinimumDissipation(),; forcing=(u=x_relax, v=y_relax, w=z_relax)); time_step!(model, 1, euler=true). return true; end; ```. produces something like. ```; [2020/10/13 17:36:39.154] INFO Testing relaxation forcing functions [GPU]...; Relaxation forcing functions [GPU]: Error During Test at /archive1/glwagner/Projects/Oceananigans.jl/test/test_forcings.jl:145; Test threw exception; Expression: relaxed_time_stepping(arch); InvalidIRError: compiling kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!), OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, Cen",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1059
https://github.com/CliMA/Oceananigans.jl/issues/1059:191,Testability,test,test,191,"We test `ContinuousForcing` on the GPU. For example:. https://github.com/CliMA/Oceananigans.jl/blob/d0ed71db9a294c344a1fa76f558767f57456d14b/test/test_forcings.jl#L93-L108. but changing this test to involve `AnisotropicMinimumDissipation` makes it fail, eg:. ```julia; function relaxed_time_stepping(arch); x_relax = Relaxation(rate = 1/60, mask = GaussianMask{:x}(center=0.5, width=0.1), ; target = LinearTarget{:x}(intercept=π, gradient=ℯ)). y_relax = Relaxation(rate = 1/60, mask = GaussianMask{:y}(center=0.5, width=0.1),; target = LinearTarget{:y}(intercept=π, gradient=ℯ)). z_relax = Relaxation(rate = 1/60, mask = GaussianMask{:z}(center=0.5, width=0.1),; target = π). grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 1, 1)) ; model = IncompressibleModel(grid=grid,; architecture=arch,; closure=AnisotropicMinimumDissipation(),; forcing=(u=x_relax, v=y_relax, w=z_relax)); time_step!(model, 1, euler=true). return true; end; ```. produces something like. ```; [2020/10/13 17:36:39.154] INFO Testing relaxation forcing functions [GPU]...; Relaxation forcing functions [GPU]: Error During Test at /archive1/glwagner/Projects/Oceananigans.jl/test/test_forcings.jl:145; Test threw exception; Expression: relaxed_time_stepping(arch); InvalidIRError: compiling kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!), OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, Cen",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1059
https://github.com/CliMA/Oceananigans.jl/issues/1059:1004,Testability,Test,Testing,1004,"orcing` on the GPU. For example:. https://github.com/CliMA/Oceananigans.jl/blob/d0ed71db9a294c344a1fa76f558767f57456d14b/test/test_forcings.jl#L93-L108. but changing this test to involve `AnisotropicMinimumDissipation` makes it fail, eg:. ```julia; function relaxed_time_stepping(arch); x_relax = Relaxation(rate = 1/60, mask = GaussianMask{:x}(center=0.5, width=0.1), ; target = LinearTarget{:x}(intercept=π, gradient=ℯ)). y_relax = Relaxation(rate = 1/60, mask = GaussianMask{:y}(center=0.5, width=0.1),; target = LinearTarget{:y}(intercept=π, gradient=ℯ)). z_relax = Relaxation(rate = 1/60, mask = GaussianMask{:z}(center=0.5, width=0.1),; target = π). grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 1, 1)) ; model = IncompressibleModel(grid=grid,; architecture=arch,; closure=AnisotropicMinimumDissipation(),; forcing=(u=x_relax, v=y_relax, w=z_relax)); time_step!(model, 1, euler=true). return true; end; ```. produces something like. ```; [2020/10/13 17:36:39.154] INFO Testing relaxation forcing functions [GPU]...; Relaxation forcing functions [GPU]: Error During Test at /archive1/glwagner/Projects/Oceananigans.jl/test/test_forcings.jl:145; Test threw exception; Expression: relaxed_time_stepping(arch); InvalidIRError: compiling kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!), OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, CenteredSecondOrder, No",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1059
https://github.com/CliMA/Oceananigans.jl/issues/1059:1100,Testability,Test,Test,1100,"/d0ed71db9a294c344a1fa76f558767f57456d14b/test/test_forcings.jl#L93-L108. but changing this test to involve `AnisotropicMinimumDissipation` makes it fail, eg:. ```julia; function relaxed_time_stepping(arch); x_relax = Relaxation(rate = 1/60, mask = GaussianMask{:x}(center=0.5, width=0.1), ; target = LinearTarget{:x}(intercept=π, gradient=ℯ)). y_relax = Relaxation(rate = 1/60, mask = GaussianMask{:y}(center=0.5, width=0.1),; target = LinearTarget{:y}(intercept=π, gradient=ℯ)). z_relax = Relaxation(rate = 1/60, mask = GaussianMask{:z}(center=0.5, width=0.1),; target = π). grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 1, 1)) ; model = IncompressibleModel(grid=grid,; architecture=arch,; closure=AnisotropicMinimumDissipation(),; forcing=(u=x_relax, v=y_relax, w=z_relax)); time_step!(model, 1, euler=true). return true; end; ```. produces something like. ```; [2020/10/13 17:36:39.154] INFO Testing relaxation forcing functions [GPU]...; Relaxation forcing functions [GPU]: Error During Test at /archive1/glwagner/Projects/Oceananigans.jl/test/test_forcings.jl:145; Test threw exception; Expression: relaxed_time_stepping(arch); InvalidIRError: compiling kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!), OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, CenteredSecondOrder, Nothing, Nothing, VerstappenAnisotropicMinimumDissipation{Float64,NamedTuple{(:T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1059
https://github.com/CliMA/Oceananigans.jl/issues/1059:1152,Testability,test,test,1152,"jl#L93-L108. but changing this test to involve `AnisotropicMinimumDissipation` makes it fail, eg:. ```julia; function relaxed_time_stepping(arch); x_relax = Relaxation(rate = 1/60, mask = GaussianMask{:x}(center=0.5, width=0.1), ; target = LinearTarget{:x}(intercept=π, gradient=ℯ)). y_relax = Relaxation(rate = 1/60, mask = GaussianMask{:y}(center=0.5, width=0.1),; target = LinearTarget{:y}(intercept=π, gradient=ℯ)). z_relax = Relaxation(rate = 1/60, mask = GaussianMask{:z}(center=0.5, width=0.1),; target = π). grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 1, 1)) ; model = IncompressibleModel(grid=grid,; architecture=arch,; closure=AnisotropicMinimumDissipation(),; forcing=(u=x_relax, v=y_relax, w=z_relax)); time_step!(model, 1, euler=true). return true; end; ```. produces something like. ```; [2020/10/13 17:36:39.154] INFO Testing relaxation forcing functions [GPU]...; Relaxation forcing functions [GPU]: Error During Test at /archive1/glwagner/Projects/Oceananigans.jl/test/test_forcings.jl:145; Test threw exception; Expression: relaxed_time_stepping(arch); InvalidIRError: compiling kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!), OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, CenteredSecondOrder, Nothing, Nothing, VerstappenAnisotropicMinimumDissipation{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}},Float64,NamedTuple{(:T, :S),Tup",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1059
https://github.com/CliMA/Oceananigans.jl/issues/1059:1179,Testability,Test,Test,1179,"n` makes it fail, eg:. ```julia; function relaxed_time_stepping(arch); x_relax = Relaxation(rate = 1/60, mask = GaussianMask{:x}(center=0.5, width=0.1), ; target = LinearTarget{:x}(intercept=π, gradient=ℯ)). y_relax = Relaxation(rate = 1/60, mask = GaussianMask{:y}(center=0.5, width=0.1),; target = LinearTarget{:y}(intercept=π, gradient=ℯ)). z_relax = Relaxation(rate = 1/60, mask = GaussianMask{:z}(center=0.5, width=0.1),; target = π). grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 1, 1)) ; model = IncompressibleModel(grid=grid,; architecture=arch,; closure=AnisotropicMinimumDissipation(),; forcing=(u=x_relax, v=y_relax, w=z_relax)); time_step!(model, 1, euler=true). return true; end; ```. produces something like. ```; [2020/10/13 17:36:39.154] INFO Testing relaxation forcing functions [GPU]...; Relaxation forcing functions [GPU]: Error During Test at /archive1/glwagner/Projects/Oceananigans.jl/test/test_forcings.jl:145; Test threw exception; Expression: relaxed_time_stepping(arch); InvalidIRError: compiling kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},KernelAbstractions.NDIteration.StaticSize{(1, 1, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!), OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, CenteredSecondOrder, Nothing, Nothing, VerstappenAnisotropicMinimumDissipation{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}},Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}}, NamedTuple{(:velocities, :tracers),Tuple{NamedTuple{(:",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1059
https://github.com/CliMA/Oceananigans.jl/pull/1061:188,Deployability,Continuous,ContinuousForcing,188,"While in a perfect world we would include diffusivities in `model_fields` for both forcing functions and boundary condition functions, including them makes trouble for the compilation of `ContinuousForcing` (see #1059). We should have had a test that `ContinuousForcing` works with non-trivial turbulence closures (and perhaps tuples of closures as well). Since we don't include `diffusivities` in `model_fields` anymore, there's no need for such a test. But let it be noted that if `diffusivities` is ever restored to `model_fields`, we'll need to test that this works with various forcing functions and boundary condition functions (perhaps the problem will disappear as the julia versions march ever onwards...). This PR relies on #1057 (though it shouldn't...). Resolves #1059",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1061
https://github.com/CliMA/Oceananigans.jl/pull/1061:252,Deployability,Continuous,ContinuousForcing,252,"While in a perfect world we would include diffusivities in `model_fields` for both forcing functions and boundary condition functions, including them makes trouble for the compilation of `ContinuousForcing` (see #1059). We should have had a test that `ContinuousForcing` works with non-trivial turbulence closures (and perhaps tuples of closures as well). Since we don't include `diffusivities` in `model_fields` anymore, there's no need for such a test. But let it be noted that if `diffusivities` is ever restored to `model_fields`, we'll need to test that this works with various forcing functions and boundary condition functions (perhaps the problem will disappear as the julia versions march ever onwards...). This PR relies on #1057 (though it shouldn't...). Resolves #1059",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1061
https://github.com/CliMA/Oceananigans.jl/pull/1061:241,Testability,test,test,241,"While in a perfect world we would include diffusivities in `model_fields` for both forcing functions and boundary condition functions, including them makes trouble for the compilation of `ContinuousForcing` (see #1059). We should have had a test that `ContinuousForcing` works with non-trivial turbulence closures (and perhaps tuples of closures as well). Since we don't include `diffusivities` in `model_fields` anymore, there's no need for such a test. But let it be noted that if `diffusivities` is ever restored to `model_fields`, we'll need to test that this works with various forcing functions and boundary condition functions (perhaps the problem will disappear as the julia versions march ever onwards...). This PR relies on #1057 (though it shouldn't...). Resolves #1059",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1061
https://github.com/CliMA/Oceananigans.jl/pull/1061:449,Testability,test,test,449,"While in a perfect world we would include diffusivities in `model_fields` for both forcing functions and boundary condition functions, including them makes trouble for the compilation of `ContinuousForcing` (see #1059). We should have had a test that `ContinuousForcing` works with non-trivial turbulence closures (and perhaps tuples of closures as well). Since we don't include `diffusivities` in `model_fields` anymore, there's no need for such a test. But let it be noted that if `diffusivities` is ever restored to `model_fields`, we'll need to test that this works with various forcing functions and boundary condition functions (perhaps the problem will disappear as the julia versions march ever onwards...). This PR relies on #1057 (though it shouldn't...). Resolves #1059",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1061
https://github.com/CliMA/Oceananigans.jl/pull/1061:549,Testability,test,test,549,"While in a perfect world we would include diffusivities in `model_fields` for both forcing functions and boundary condition functions, including them makes trouble for the compilation of `ContinuousForcing` (see #1059). We should have had a test that `ContinuousForcing` works with non-trivial turbulence closures (and perhaps tuples of closures as well). Since we don't include `diffusivities` in `model_fields` anymore, there's no need for such a test. But let it be noted that if `diffusivities` is ever restored to `model_fields`, we'll need to test that this works with various forcing functions and boundary condition functions (perhaps the problem will disappear as the julia versions march ever onwards...). This PR relies on #1057 (though it shouldn't...). Resolves #1059",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1061
https://github.com/CliMA/Oceananigans.jl/issues/1062:34,Deployability,update,updated,34,"The `Diagnostics` docs need to be updated to use `AveragedField`:. https://clima.github.io/OceananigansDocumentation/stable/model_setup/diagnostics/. but perhaps more importantly, we should probably merge this page with `OutputWriters`:. https://clima.github.io/OceananigansDocumentation/stable/model_setup/output_writers/. We also need to add docs for `WindowedTimeAverage`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1062
https://github.com/CliMA/Oceananigans.jl/issues/1063:864,Availability,redundant,redundantly,864,"Currently halo regions are filled _prior_ to performing a time-step. This means that _after_ the time-step, they are incorrect. We therefore cannot output fields with correct halo regions, since data is outputted after a time-step is taken. But it gets worse. If the average of a field is taken, we zero out the halo regions. Zeroing out the halo regions corrupts near-boundary data for all subsequent computations with the fields. Currently, abstract operations cannot be trusted in boundary-adjacent cells. To remedy this we need to fill halo regions on fields prior to performing computations. One way we might do this is to write a `compute!` method for fields:. ```julia; compute!(field::Field) = fill_halo_regions!(field); ```. We can also define a `conditional_compute!` method for `Field`s and add a `status` property, so that halo regions are not filled ""redundantly"". For this to work, we also need to invalidate `field.status` when halo regions are zeroed out by `compute!(averaged_field::AveragedField)`, (for example by setting `field.status.time = NaN`). This won't work currently, of course, due to #971 . So this issue cannot be resolved until #971 is resolved.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1063
https://github.com/CliMA/Oceananigans.jl/issues/1063:45,Performance,perform,performing,45,"Currently halo regions are filled _prior_ to performing a time-step. This means that _after_ the time-step, they are incorrect. We therefore cannot output fields with correct halo regions, since data is outputted after a time-step is taken. But it gets worse. If the average of a field is taken, we zero out the halo regions. Zeroing out the halo regions corrupts near-boundary data for all subsequent computations with the fields. Currently, abstract operations cannot be trusted in boundary-adjacent cells. To remedy this we need to fill halo regions on fields prior to performing computations. One way we might do this is to write a `compute!` method for fields:. ```julia; compute!(field::Field) = fill_halo_regions!(field); ```. We can also define a `conditional_compute!` method for `Field`s and add a `status` property, so that halo regions are not filled ""redundantly"". For this to work, we also need to invalidate `field.status` when halo regions are zeroed out by `compute!(averaged_field::AveragedField)`, (for example by setting `field.status.time = NaN`). This won't work currently, of course, due to #971 . So this issue cannot be resolved until #971 is resolved.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1063
https://github.com/CliMA/Oceananigans.jl/issues/1063:572,Performance,perform,performing,572,"Currently halo regions are filled _prior_ to performing a time-step. This means that _after_ the time-step, they are incorrect. We therefore cannot output fields with correct halo regions, since data is outputted after a time-step is taken. But it gets worse. If the average of a field is taken, we zero out the halo regions. Zeroing out the halo regions corrupts near-boundary data for all subsequent computations with the fields. Currently, abstract operations cannot be trusted in boundary-adjacent cells. To remedy this we need to fill halo regions on fields prior to performing computations. One way we might do this is to write a `compute!` method for fields:. ```julia; compute!(field::Field) = fill_halo_regions!(field); ```. We can also define a `conditional_compute!` method for `Field`s and add a `status` property, so that halo regions are not filled ""redundantly"". For this to work, we also need to invalidate `field.status` when halo regions are zeroed out by `compute!(averaged_field::AveragedField)`, (for example by setting `field.status.time = NaN`). This won't work currently, of course, due to #971 . So this issue cannot be resolved until #971 is resolved.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1063
https://github.com/CliMA/Oceananigans.jl/issues/1063:864,Safety,redund,redundantly,864,"Currently halo regions are filled _prior_ to performing a time-step. This means that _after_ the time-step, they are incorrect. We therefore cannot output fields with correct halo regions, since data is outputted after a time-step is taken. But it gets worse. If the average of a field is taken, we zero out the halo regions. Zeroing out the halo regions corrupts near-boundary data for all subsequent computations with the fields. Currently, abstract operations cannot be trusted in boundary-adjacent cells. To remedy this we need to fill halo regions on fields prior to performing computations. One way we might do this is to write a `compute!` method for fields:. ```julia; compute!(field::Field) = fill_halo_regions!(field); ```. We can also define a `conditional_compute!` method for `Field`s and add a `status` property, so that halo regions are not filled ""redundantly"". For this to work, we also need to invalidate `field.status` when halo regions are zeroed out by `compute!(averaged_field::AveragedField)`, (for example by setting `field.status.time = NaN`). This won't work currently, of course, due to #971 . So this issue cannot be resolved until #971 is resolved.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1063
https://github.com/CliMA/Oceananigans.jl/pull/1064:61,Integrability,depend,dependencies,61,This PR splits up the model tests into two and adds explicit dependencies for Buildkite jobs. Both these changes should speed up testing. Resolves #1048 ; Resolves #1056,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1064
https://github.com/CliMA/Oceananigans.jl/pull/1064:28,Testability,test,tests,28,This PR splits up the model tests into two and adds explicit dependencies for Buildkite jobs. Both these changes should speed up testing. Resolves #1048 ; Resolves #1056,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1064
https://github.com/CliMA/Oceananigans.jl/pull/1064:129,Testability,test,testing,129,This PR splits up the model tests into two and adds explicit dependencies for Buildkite jobs. Both these changes should speed up testing. Resolves #1048 ; Resolves #1056,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1064
https://github.com/CliMA/Oceananigans.jl/pull/1067:0,Deployability,Release,Release,0,"Release notes:. This release adds support for time averaging and field slicing to `NetCDFOutputWriter`. **Breaking changes**:; * `NetCDFOutputWriter` constructor: The `filename` keyword argument is now `filepath`.; * `NetCDFOutputWriter` constructor: To specify slices, pass a `FieldSlicer(i, j, k; with_halos)` instead of using the `xC`, `xF`, `yC`, `yF`, `zC`, and `zF` keyword arguments.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1067
https://github.com/CliMA/Oceananigans.jl/pull/1067:21,Deployability,release,release,21,"Release notes:. This release adds support for time averaging and field slicing to `NetCDFOutputWriter`. **Breaking changes**:; * `NetCDFOutputWriter` constructor: The `filename` keyword argument is now `filepath`.; * `NetCDFOutputWriter` constructor: To specify slices, pass a `FieldSlicer(i, j, k; with_halos)` instead of using the `xC`, `xF`, `yC`, `yF`, `zC`, and `zF` keyword arguments.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1067
https://github.com/CliMA/Oceananigans.jl/issues/1068:35,Availability,checkpoint,checkpoint,35,"Currently restoring a model from a checkpoint uses the function `restore_from_checkpoint`. However, this design can be difficult to use because, in general, restoring a model requires passing the forcing functions and boundary condition functions explicitly to `restore_from_checkpoint`. This means that part of the setup script needs to be replicated in the script that restores a model from the checkpoint. A different solution is possible that may require less work on the part of users to restore a model from a checkpoint: if we extend `run!` with the keyword argument `pickup`. . If `pickup=true` (and a checkpointer has been added to `simulation.output_writers`), then prior to executing the `run!` loop,. 1. The checkpointer file correpsonding to the most recent model iteration will be identified;; 2. Checkpointer data will be synced with `model.velocities`, `model.tracers`, `model.clock`, and, for `QuasiAdamsBashforth2` timesteppers, the tendency `model.timesteppers.Gⁿ`. For this to work seamlessly when a `JLD2OutputWriter` is involved we might need to modify the constructor for `JLD2OutputWriter`. Currently the constructor runs an arbitrary `init(file, model)` function, and saves certain properties identified in the constructor signature:. https://github.com/CliMA/Oceananigans.jl/blob/9cfb568ec3a8e6f7efe8c7c41300ea9673c6b103/src/OutputWriters/jld2_output_writer.jl#L157-L160. This will fail if the output file already exists; thus it's not possible to pickup from a checkpoint with the same script used to initialize the model (without destroying prior output). A simple change could just be to allow `init` and `save_properties!` to fail with `try/catch` (or to avoid running those functions if a file already exists). There are also some shenanigans that'd have to be done for output files split into multiple `part`s. (We could, potentially, require `pickup=true` in the `JLD2OutputWriter` constructor, rather than changing its default behavior to accommodate auto-checkpoint-",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068
https://github.com/CliMA/Oceananigans.jl/issues/1068:397,Availability,checkpoint,checkpoint,397,"Currently restoring a model from a checkpoint uses the function `restore_from_checkpoint`. However, this design can be difficult to use because, in general, restoring a model requires passing the forcing functions and boundary condition functions explicitly to `restore_from_checkpoint`. This means that part of the setup script needs to be replicated in the script that restores a model from the checkpoint. A different solution is possible that may require less work on the part of users to restore a model from a checkpoint: if we extend `run!` with the keyword argument `pickup`. . If `pickup=true` (and a checkpointer has been added to `simulation.output_writers`), then prior to executing the `run!` loop,. 1. The checkpointer file correpsonding to the most recent model iteration will be identified;; 2. Checkpointer data will be synced with `model.velocities`, `model.tracers`, `model.clock`, and, for `QuasiAdamsBashforth2` timesteppers, the tendency `model.timesteppers.Gⁿ`. For this to work seamlessly when a `JLD2OutputWriter` is involved we might need to modify the constructor for `JLD2OutputWriter`. Currently the constructor runs an arbitrary `init(file, model)` function, and saves certain properties identified in the constructor signature:. https://github.com/CliMA/Oceananigans.jl/blob/9cfb568ec3a8e6f7efe8c7c41300ea9673c6b103/src/OutputWriters/jld2_output_writer.jl#L157-L160. This will fail if the output file already exists; thus it's not possible to pickup from a checkpoint with the same script used to initialize the model (without destroying prior output). A simple change could just be to allow `init` and `save_properties!` to fail with `try/catch` (or to avoid running those functions if a file already exists). There are also some shenanigans that'd have to be done for output files split into multiple `part`s. (We could, potentially, require `pickup=true` in the `JLD2OutputWriter` constructor, rather than changing its default behavior to accommodate auto-checkpoint-",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068
https://github.com/CliMA/Oceananigans.jl/issues/1068:516,Availability,checkpoint,checkpoint,516,"Currently restoring a model from a checkpoint uses the function `restore_from_checkpoint`. However, this design can be difficult to use because, in general, restoring a model requires passing the forcing functions and boundary condition functions explicitly to `restore_from_checkpoint`. This means that part of the setup script needs to be replicated in the script that restores a model from the checkpoint. A different solution is possible that may require less work on the part of users to restore a model from a checkpoint: if we extend `run!` with the keyword argument `pickup`. . If `pickup=true` (and a checkpointer has been added to `simulation.output_writers`), then prior to executing the `run!` loop,. 1. The checkpointer file correpsonding to the most recent model iteration will be identified;; 2. Checkpointer data will be synced with `model.velocities`, `model.tracers`, `model.clock`, and, for `QuasiAdamsBashforth2` timesteppers, the tendency `model.timesteppers.Gⁿ`. For this to work seamlessly when a `JLD2OutputWriter` is involved we might need to modify the constructor for `JLD2OutputWriter`. Currently the constructor runs an arbitrary `init(file, model)` function, and saves certain properties identified in the constructor signature:. https://github.com/CliMA/Oceananigans.jl/blob/9cfb568ec3a8e6f7efe8c7c41300ea9673c6b103/src/OutputWriters/jld2_output_writer.jl#L157-L160. This will fail if the output file already exists; thus it's not possible to pickup from a checkpoint with the same script used to initialize the model (without destroying prior output). A simple change could just be to allow `init` and `save_properties!` to fail with `try/catch` (or to avoid running those functions if a file already exists). There are also some shenanigans that'd have to be done for output files split into multiple `part`s. (We could, potentially, require `pickup=true` in the `JLD2OutputWriter` constructor, rather than changing its default behavior to accommodate auto-checkpoint-",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068
https://github.com/CliMA/Oceananigans.jl/issues/1068:610,Availability,checkpoint,checkpointer,610,"Currently restoring a model from a checkpoint uses the function `restore_from_checkpoint`. However, this design can be difficult to use because, in general, restoring a model requires passing the forcing functions and boundary condition functions explicitly to `restore_from_checkpoint`. This means that part of the setup script needs to be replicated in the script that restores a model from the checkpoint. A different solution is possible that may require less work on the part of users to restore a model from a checkpoint: if we extend `run!` with the keyword argument `pickup`. . If `pickup=true` (and a checkpointer has been added to `simulation.output_writers`), then prior to executing the `run!` loop,. 1. The checkpointer file correpsonding to the most recent model iteration will be identified;; 2. Checkpointer data will be synced with `model.velocities`, `model.tracers`, `model.clock`, and, for `QuasiAdamsBashforth2` timesteppers, the tendency `model.timesteppers.Gⁿ`. For this to work seamlessly when a `JLD2OutputWriter` is involved we might need to modify the constructor for `JLD2OutputWriter`. Currently the constructor runs an arbitrary `init(file, model)` function, and saves certain properties identified in the constructor signature:. https://github.com/CliMA/Oceananigans.jl/blob/9cfb568ec3a8e6f7efe8c7c41300ea9673c6b103/src/OutputWriters/jld2_output_writer.jl#L157-L160. This will fail if the output file already exists; thus it's not possible to pickup from a checkpoint with the same script used to initialize the model (without destroying prior output). A simple change could just be to allow `init` and `save_properties!` to fail with `try/catch` (or to avoid running those functions if a file already exists). There are also some shenanigans that'd have to be done for output files split into multiple `part`s. (We could, potentially, require `pickup=true` in the `JLD2OutputWriter` constructor, rather than changing its default behavior to accommodate auto-checkpoint-",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068
https://github.com/CliMA/Oceananigans.jl/issues/1068:720,Availability,checkpoint,checkpointer,720,"Currently restoring a model from a checkpoint uses the function `restore_from_checkpoint`. However, this design can be difficult to use because, in general, restoring a model requires passing the forcing functions and boundary condition functions explicitly to `restore_from_checkpoint`. This means that part of the setup script needs to be replicated in the script that restores a model from the checkpoint. A different solution is possible that may require less work on the part of users to restore a model from a checkpoint: if we extend `run!` with the keyword argument `pickup`. . If `pickup=true` (and a checkpointer has been added to `simulation.output_writers`), then prior to executing the `run!` loop,. 1. The checkpointer file correpsonding to the most recent model iteration will be identified;; 2. Checkpointer data will be synced with `model.velocities`, `model.tracers`, `model.clock`, and, for `QuasiAdamsBashforth2` timesteppers, the tendency `model.timesteppers.Gⁿ`. For this to work seamlessly when a `JLD2OutputWriter` is involved we might need to modify the constructor for `JLD2OutputWriter`. Currently the constructor runs an arbitrary `init(file, model)` function, and saves certain properties identified in the constructor signature:. https://github.com/CliMA/Oceananigans.jl/blob/9cfb568ec3a8e6f7efe8c7c41300ea9673c6b103/src/OutputWriters/jld2_output_writer.jl#L157-L160. This will fail if the output file already exists; thus it's not possible to pickup from a checkpoint with the same script used to initialize the model (without destroying prior output). A simple change could just be to allow `init` and `save_properties!` to fail with `try/catch` (or to avoid running those functions if a file already exists). There are also some shenanigans that'd have to be done for output files split into multiple `part`s. (We could, potentially, require `pickup=true` in the `JLD2OutputWriter` constructor, rather than changing its default behavior to accommodate auto-checkpoint-",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068
https://github.com/CliMA/Oceananigans.jl/issues/1068:811,Availability,Checkpoint,Checkpointer,811,"Currently restoring a model from a checkpoint uses the function `restore_from_checkpoint`. However, this design can be difficult to use because, in general, restoring a model requires passing the forcing functions and boundary condition functions explicitly to `restore_from_checkpoint`. This means that part of the setup script needs to be replicated in the script that restores a model from the checkpoint. A different solution is possible that may require less work on the part of users to restore a model from a checkpoint: if we extend `run!` with the keyword argument `pickup`. . If `pickup=true` (and a checkpointer has been added to `simulation.output_writers`), then prior to executing the `run!` loop,. 1. The checkpointer file correpsonding to the most recent model iteration will be identified;; 2. Checkpointer data will be synced with `model.velocities`, `model.tracers`, `model.clock`, and, for `QuasiAdamsBashforth2` timesteppers, the tendency `model.timesteppers.Gⁿ`. For this to work seamlessly when a `JLD2OutputWriter` is involved we might need to modify the constructor for `JLD2OutputWriter`. Currently the constructor runs an arbitrary `init(file, model)` function, and saves certain properties identified in the constructor signature:. https://github.com/CliMA/Oceananigans.jl/blob/9cfb568ec3a8e6f7efe8c7c41300ea9673c6b103/src/OutputWriters/jld2_output_writer.jl#L157-L160. This will fail if the output file already exists; thus it's not possible to pickup from a checkpoint with the same script used to initialize the model (without destroying prior output). A simple change could just be to allow `init` and `save_properties!` to fail with `try/catch` (or to avoid running those functions if a file already exists). There are also some shenanigans that'd have to be done for output files split into multiple `part`s. (We could, potentially, require `pickup=true` in the `JLD2OutputWriter` constructor, rather than changing its default behavior to accommodate auto-checkpoint-",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068
https://github.com/CliMA/Oceananigans.jl/issues/1068:1488,Availability,checkpoint,checkpoint,1488,"to restore a model from a checkpoint: if we extend `run!` with the keyword argument `pickup`. . If `pickup=true` (and a checkpointer has been added to `simulation.output_writers`), then prior to executing the `run!` loop,. 1. The checkpointer file correpsonding to the most recent model iteration will be identified;; 2. Checkpointer data will be synced with `model.velocities`, `model.tracers`, `model.clock`, and, for `QuasiAdamsBashforth2` timesteppers, the tendency `model.timesteppers.Gⁿ`. For this to work seamlessly when a `JLD2OutputWriter` is involved we might need to modify the constructor for `JLD2OutputWriter`. Currently the constructor runs an arbitrary `init(file, model)` function, and saves certain properties identified in the constructor signature:. https://github.com/CliMA/Oceananigans.jl/blob/9cfb568ec3a8e6f7efe8c7c41300ea9673c6b103/src/OutputWriters/jld2_output_writer.jl#L157-L160. This will fail if the output file already exists; thus it's not possible to pickup from a checkpoint with the same script used to initialize the model (without destroying prior output). A simple change could just be to allow `init` and `save_properties!` to fail with `try/catch` (or to avoid running those functions if a file already exists). There are also some shenanigans that'd have to be done for output files split into multiple `part`s. (We could, potentially, require `pickup=true` in the `JLD2OutputWriter` constructor, rather than changing its default behavior to accommodate auto-checkpoint-pickup). Another caveat is that this method of restoring checkpointed data will not work for large CPU models that consume almost all of the CPU memory (such that a single field cannot be loaded from file after `model` has been instantiated). These cases are relatively rare right now, since such large models would typically run very slowly on a typical single node. The basic idea is:. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068
https://github.com/CliMA/Oceananigans.jl/issues/1068:1990,Availability,checkpoint,checkpoint-pickup,1990,"forth2` timesteppers, the tendency `model.timesteppers.Gⁿ`. For this to work seamlessly when a `JLD2OutputWriter` is involved we might need to modify the constructor for `JLD2OutputWriter`. Currently the constructor runs an arbitrary `init(file, model)` function, and saves certain properties identified in the constructor signature:. https://github.com/CliMA/Oceananigans.jl/blob/9cfb568ec3a8e6f7efe8c7c41300ea9673c6b103/src/OutputWriters/jld2_output_writer.jl#L157-L160. This will fail if the output file already exists; thus it's not possible to pickup from a checkpoint with the same script used to initialize the model (without destroying prior output). A simple change could just be to allow `init` and `save_properties!` to fail with `try/catch` (or to avoid running those functions if a file already exists). There are also some shenanigans that'd have to be done for output files split into multiple `part`s. (We could, potentially, require `pickup=true` in the `JLD2OutputWriter` constructor, rather than changing its default behavior to accommodate auto-checkpoint-pickup). Another caveat is that this method of restoring checkpointed data will not work for large CPU models that consume almost all of the CPU memory (such that a single field cannot be loaded from file after `model` has been instantiated). These cases are relatively rare right now, since such large models would typically run very slowly on a typical single node. The basic idea is:. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...). run!(simulation, pickup=true); ```. We could also allow `pickup` to be an iteration number, eg. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...). run!(simulation, pickup=10138); ```. It may also be possible to enable this functionality with an environment variable; eg. ```bash; PICKUP=true julia --project run_cool_simulation.jl; ```. Note that this design works even if `model.cloc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068
https://github.com/CliMA/Oceananigans.jl/issues/1068:2058,Availability,checkpoint,checkpointed,2058,"this to work seamlessly when a `JLD2OutputWriter` is involved we might need to modify the constructor for `JLD2OutputWriter`. Currently the constructor runs an arbitrary `init(file, model)` function, and saves certain properties identified in the constructor signature:. https://github.com/CliMA/Oceananigans.jl/blob/9cfb568ec3a8e6f7efe8c7c41300ea9673c6b103/src/OutputWriters/jld2_output_writer.jl#L157-L160. This will fail if the output file already exists; thus it's not possible to pickup from a checkpoint with the same script used to initialize the model (without destroying prior output). A simple change could just be to allow `init` and `save_properties!` to fail with `try/catch` (or to avoid running those functions if a file already exists). There are also some shenanigans that'd have to be done for output files split into multiple `part`s. (We could, potentially, require `pickup=true` in the `JLD2OutputWriter` constructor, rather than changing its default behavior to accommodate auto-checkpoint-pickup). Another caveat is that this method of restoring checkpointed data will not work for large CPU models that consume almost all of the CPU memory (such that a single field cannot be loaded from file after `model` has been instantiated). These cases are relatively rare right now, since such large models would typically run very slowly on a typical single node. The basic idea is:. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...). run!(simulation, pickup=true); ```. We could also allow `pickup` to be an iteration number, eg. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...). run!(simulation, pickup=10138); ```. It may also be possible to enable this functionality with an environment variable; eg. ```bash; PICKUP=true julia --project run_cool_simulation.jl; ```. Note that this design works even if `model.clock.iteration==0`, since the initial checkpoint can be picked up.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068
https://github.com/CliMA/Oceananigans.jl/issues/1068:2456,Availability,checkpoint,checkpointer,2456,"this to work seamlessly when a `JLD2OutputWriter` is involved we might need to modify the constructor for `JLD2OutputWriter`. Currently the constructor runs an arbitrary `init(file, model)` function, and saves certain properties identified in the constructor signature:. https://github.com/CliMA/Oceananigans.jl/blob/9cfb568ec3a8e6f7efe8c7c41300ea9673c6b103/src/OutputWriters/jld2_output_writer.jl#L157-L160. This will fail if the output file already exists; thus it's not possible to pickup from a checkpoint with the same script used to initialize the model (without destroying prior output). A simple change could just be to allow `init` and `save_properties!` to fail with `try/catch` (or to avoid running those functions if a file already exists). There are also some shenanigans that'd have to be done for output files split into multiple `part`s. (We could, potentially, require `pickup=true` in the `JLD2OutputWriter` constructor, rather than changing its default behavior to accommodate auto-checkpoint-pickup). Another caveat is that this method of restoring checkpointed data will not work for large CPU models that consume almost all of the CPU memory (such that a single field cannot be loaded from file after `model` has been instantiated). These cases are relatively rare right now, since such large models would typically run very slowly on a typical single node. The basic idea is:. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...). run!(simulation, pickup=true); ```. We could also allow `pickup` to be an iteration number, eg. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...). run!(simulation, pickup=10138); ```. It may also be possible to enable this functionality with an environment variable; eg. ```bash; PICKUP=true julia --project run_cool_simulation.jl; ```. Note that this design works even if `model.clock.iteration==0`, since the initial checkpoint can be picked up.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068
https://github.com/CliMA/Oceananigans.jl/issues/1068:2472,Availability,Checkpoint,Checkpointer,2472,"this to work seamlessly when a `JLD2OutputWriter` is involved we might need to modify the constructor for `JLD2OutputWriter`. Currently the constructor runs an arbitrary `init(file, model)` function, and saves certain properties identified in the constructor signature:. https://github.com/CliMA/Oceananigans.jl/blob/9cfb568ec3a8e6f7efe8c7c41300ea9673c6b103/src/OutputWriters/jld2_output_writer.jl#L157-L160. This will fail if the output file already exists; thus it's not possible to pickup from a checkpoint with the same script used to initialize the model (without destroying prior output). A simple change could just be to allow `init` and `save_properties!` to fail with `try/catch` (or to avoid running those functions if a file already exists). There are also some shenanigans that'd have to be done for output files split into multiple `part`s. (We could, potentially, require `pickup=true` in the `JLD2OutputWriter` constructor, rather than changing its default behavior to accommodate auto-checkpoint-pickup). Another caveat is that this method of restoring checkpointed data will not work for large CPU models that consume almost all of the CPU memory (such that a single field cannot be loaded from file after `model` has been instantiated). These cases are relatively rare right now, since such large models would typically run very slowly on a typical single node. The basic idea is:. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...). run!(simulation, pickup=true); ```. We could also allow `pickup` to be an iteration number, eg. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...). run!(simulation, pickup=10138); ```. It may also be possible to enable this functionality with an environment variable; eg. ```bash; PICKUP=true julia --project run_cool_simulation.jl; ```. Note that this design works even if `model.clock.iteration==0`, since the initial checkpoint can be picked up.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068
https://github.com/CliMA/Oceananigans.jl/issues/1068:2654,Availability,checkpoint,checkpointer,2654,"this to work seamlessly when a `JLD2OutputWriter` is involved we might need to modify the constructor for `JLD2OutputWriter`. Currently the constructor runs an arbitrary `init(file, model)` function, and saves certain properties identified in the constructor signature:. https://github.com/CliMA/Oceananigans.jl/blob/9cfb568ec3a8e6f7efe8c7c41300ea9673c6b103/src/OutputWriters/jld2_output_writer.jl#L157-L160. This will fail if the output file already exists; thus it's not possible to pickup from a checkpoint with the same script used to initialize the model (without destroying prior output). A simple change could just be to allow `init` and `save_properties!` to fail with `try/catch` (or to avoid running those functions if a file already exists). There are also some shenanigans that'd have to be done for output files split into multiple `part`s. (We could, potentially, require `pickup=true` in the `JLD2OutputWriter` constructor, rather than changing its default behavior to accommodate auto-checkpoint-pickup). Another caveat is that this method of restoring checkpointed data will not work for large CPU models that consume almost all of the CPU memory (such that a single field cannot be loaded from file after `model` has been instantiated). These cases are relatively rare right now, since such large models would typically run very slowly on a typical single node. The basic idea is:. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...). run!(simulation, pickup=true); ```. We could also allow `pickup` to be an iteration number, eg. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...). run!(simulation, pickup=10138); ```. It may also be possible to enable this functionality with an environment variable; eg. ```bash; PICKUP=true julia --project run_cool_simulation.jl; ```. Note that this design works even if `model.clock.iteration==0`, since the initial checkpoint can be picked up.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068
https://github.com/CliMA/Oceananigans.jl/issues/1068:2670,Availability,Checkpoint,Checkpointer,2670,"this to work seamlessly when a `JLD2OutputWriter` is involved we might need to modify the constructor for `JLD2OutputWriter`. Currently the constructor runs an arbitrary `init(file, model)` function, and saves certain properties identified in the constructor signature:. https://github.com/CliMA/Oceananigans.jl/blob/9cfb568ec3a8e6f7efe8c7c41300ea9673c6b103/src/OutputWriters/jld2_output_writer.jl#L157-L160. This will fail if the output file already exists; thus it's not possible to pickup from a checkpoint with the same script used to initialize the model (without destroying prior output). A simple change could just be to allow `init` and `save_properties!` to fail with `try/catch` (or to avoid running those functions if a file already exists). There are also some shenanigans that'd have to be done for output files split into multiple `part`s. (We could, potentially, require `pickup=true` in the `JLD2OutputWriter` constructor, rather than changing its default behavior to accommodate auto-checkpoint-pickup). Another caveat is that this method of restoring checkpointed data will not work for large CPU models that consume almost all of the CPU memory (such that a single field cannot be loaded from file after `model` has been instantiated). These cases are relatively rare right now, since such large models would typically run very slowly on a typical single node. The basic idea is:. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...). run!(simulation, pickup=true); ```. We could also allow `pickup` to be an iteration number, eg. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...). run!(simulation, pickup=10138); ```. It may also be possible to enable this functionality with an environment variable; eg. ```bash; PICKUP=true julia --project run_cool_simulation.jl; ```. Note that this design works even if `model.clock.iteration==0`, since the initial checkpoint can be picked up.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068
https://github.com/CliMA/Oceananigans.jl/issues/1068:2961,Availability,checkpoint,checkpoint,2961,"this to work seamlessly when a `JLD2OutputWriter` is involved we might need to modify the constructor for `JLD2OutputWriter`. Currently the constructor runs an arbitrary `init(file, model)` function, and saves certain properties identified in the constructor signature:. https://github.com/CliMA/Oceananigans.jl/blob/9cfb568ec3a8e6f7efe8c7c41300ea9673c6b103/src/OutputWriters/jld2_output_writer.jl#L157-L160. This will fail if the output file already exists; thus it's not possible to pickup from a checkpoint with the same script used to initialize the model (without destroying prior output). A simple change could just be to allow `init` and `save_properties!` to fail with `try/catch` (or to avoid running those functions if a file already exists). There are also some shenanigans that'd have to be done for output files split into multiple `part`s. (We could, potentially, require `pickup=true` in the `JLD2OutputWriter` constructor, rather than changing its default behavior to accommodate auto-checkpoint-pickup). Another caveat is that this method of restoring checkpointed data will not work for large CPU models that consume almost all of the CPU memory (such that a single field cannot be loaded from file after `model` has been instantiated). These cases are relatively rare right now, since such large models would typically run very slowly on a typical single node. The basic idea is:. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...). run!(simulation, pickup=true); ```. We could also allow `pickup` to be an iteration number, eg. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...). run!(simulation, pickup=10138); ```. It may also be possible to enable this functionality with an environment variable; eg. ```bash; PICKUP=true julia --project run_cool_simulation.jl; ```. Note that this design works even if `model.clock.iteration==0`, since the initial checkpoint can be picked up.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068
https://github.com/CliMA/Oceananigans.jl/issues/1068:534,Modifiability,extend,extend,534,"Currently restoring a model from a checkpoint uses the function `restore_from_checkpoint`. However, this design can be difficult to use because, in general, restoring a model requires passing the forcing functions and boundary condition functions explicitly to `restore_from_checkpoint`. This means that part of the setup script needs to be replicated in the script that restores a model from the checkpoint. A different solution is possible that may require less work on the part of users to restore a model from a checkpoint: if we extend `run!` with the keyword argument `pickup`. . If `pickup=true` (and a checkpointer has been added to `simulation.output_writers`), then prior to executing the `run!` loop,. 1. The checkpointer file correpsonding to the most recent model iteration will be identified;; 2. Checkpointer data will be synced with `model.velocities`, `model.tracers`, `model.clock`, and, for `QuasiAdamsBashforth2` timesteppers, the tendency `model.timesteppers.Gⁿ`. For this to work seamlessly when a `JLD2OutputWriter` is involved we might need to modify the constructor for `JLD2OutputWriter`. Currently the constructor runs an arbitrary `init(file, model)` function, and saves certain properties identified in the constructor signature:. https://github.com/CliMA/Oceananigans.jl/blob/9cfb568ec3a8e6f7efe8c7c41300ea9673c6b103/src/OutputWriters/jld2_output_writer.jl#L157-L160. This will fail if the output file already exists; thus it's not possible to pickup from a checkpoint with the same script used to initialize the model (without destroying prior output). A simple change could just be to allow `init` and `save_properties!` to fail with `try/catch` (or to avoid running those functions if a file already exists). There are also some shenanigans that'd have to be done for output files split into multiple `part`s. (We could, potentially, require `pickup=true` in the `JLD2OutputWriter` constructor, rather than changing its default behavior to accommodate auto-checkpoint-",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068
https://github.com/CliMA/Oceananigans.jl/issues/1068:2799,Modifiability,variab,variable,2799,"this to work seamlessly when a `JLD2OutputWriter` is involved we might need to modify the constructor for `JLD2OutputWriter`. Currently the constructor runs an arbitrary `init(file, model)` function, and saves certain properties identified in the constructor signature:. https://github.com/CliMA/Oceananigans.jl/blob/9cfb568ec3a8e6f7efe8c7c41300ea9673c6b103/src/OutputWriters/jld2_output_writer.jl#L157-L160. This will fail if the output file already exists; thus it's not possible to pickup from a checkpoint with the same script used to initialize the model (without destroying prior output). A simple change could just be to allow `init` and `save_properties!` to fail with `try/catch` (or to avoid running those functions if a file already exists). There are also some shenanigans that'd have to be done for output files split into multiple `part`s. (We could, potentially, require `pickup=true` in the `JLD2OutputWriter` constructor, rather than changing its default behavior to accommodate auto-checkpoint-pickup). Another caveat is that this method of restoring checkpointed data will not work for large CPU models that consume almost all of the CPU memory (such that a single field cannot be loaded from file after `model` has been instantiated). These cases are relatively rare right now, since such large models would typically run very slowly on a typical single node. The basic idea is:. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...). run!(simulation, pickup=true); ```. We could also allow `pickup` to be an iteration number, eg. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...). run!(simulation, pickup=10138); ```. It may also be possible to enable this functionality with an environment variable; eg. ```bash; PICKUP=true julia --project run_cool_simulation.jl; ```. Note that this design works even if `model.clock.iteration==0`, since the initial checkpoint can be picked up.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068
https://github.com/CliMA/Oceananigans.jl/issues/1068:2189,Performance,load,loaded,2189,"this to work seamlessly when a `JLD2OutputWriter` is involved we might need to modify the constructor for `JLD2OutputWriter`. Currently the constructor runs an arbitrary `init(file, model)` function, and saves certain properties identified in the constructor signature:. https://github.com/CliMA/Oceananigans.jl/blob/9cfb568ec3a8e6f7efe8c7c41300ea9673c6b103/src/OutputWriters/jld2_output_writer.jl#L157-L160. This will fail if the output file already exists; thus it's not possible to pickup from a checkpoint with the same script used to initialize the model (without destroying prior output). A simple change could just be to allow `init` and `save_properties!` to fail with `try/catch` (or to avoid running those functions if a file already exists). There are also some shenanigans that'd have to be done for output files split into multiple `part`s. (We could, potentially, require `pickup=true` in the `JLD2OutputWriter` constructor, rather than changing its default behavior to accommodate auto-checkpoint-pickup). Another caveat is that this method of restoring checkpointed data will not work for large CPU models that consume almost all of the CPU memory (such that a single field cannot be loaded from file after `model` has been instantiated). These cases are relatively rare right now, since such large models would typically run very slowly on a typical single node. The basic idea is:. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...). run!(simulation, pickup=true); ```. We could also allow `pickup` to be an iteration number, eg. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...). run!(simulation, pickup=10138); ```. It may also be possible to enable this functionality with an environment variable; eg. ```bash; PICKUP=true julia --project run_cool_simulation.jl; ```. Note that this design works even if `model.clock.iteration==0`, since the initial checkpoint can be picked up.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068
https://github.com/CliMA/Oceananigans.jl/issues/1068:1685,Safety,avoid,avoid,1685,"iters`), then prior to executing the `run!` loop,. 1. The checkpointer file correpsonding to the most recent model iteration will be identified;; 2. Checkpointer data will be synced with `model.velocities`, `model.tracers`, `model.clock`, and, for `QuasiAdamsBashforth2` timesteppers, the tendency `model.timesteppers.Gⁿ`. For this to work seamlessly when a `JLD2OutputWriter` is involved we might need to modify the constructor for `JLD2OutputWriter`. Currently the constructor runs an arbitrary `init(file, model)` function, and saves certain properties identified in the constructor signature:. https://github.com/CliMA/Oceananigans.jl/blob/9cfb568ec3a8e6f7efe8c7c41300ea9673c6b103/src/OutputWriters/jld2_output_writer.jl#L157-L160. This will fail if the output file already exists; thus it's not possible to pickup from a checkpoint with the same script used to initialize the model (without destroying prior output). A simple change could just be to allow `init` and `save_properties!` to fail with `try/catch` (or to avoid running those functions if a file already exists). There are also some shenanigans that'd have to be done for output files split into multiple `part`s. (We could, potentially, require `pickup=true` in the `JLD2OutputWriter` constructor, rather than changing its default behavior to accommodate auto-checkpoint-pickup). Another caveat is that this method of restoring checkpointed data will not work for large CPU models that consume almost all of the CPU memory (such that a single field cannot be loaded from file after `model` has been instantiated). These cases are relatively rare right now, since such large models would typically run very slowly on a typical single node. The basic idea is:. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...). run!(simulation, pickup=true); ```. We could also allow `pickup` to be an iteration number, eg. ```julia; # Model and simulation setup. simulation.output_writers[:checkpoi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068
https://github.com/CliMA/Oceananigans.jl/issues/1068:1586,Usability,simpl,simple,1586,"iters`), then prior to executing the `run!` loop,. 1. The checkpointer file correpsonding to the most recent model iteration will be identified;; 2. Checkpointer data will be synced with `model.velocities`, `model.tracers`, `model.clock`, and, for `QuasiAdamsBashforth2` timesteppers, the tendency `model.timesteppers.Gⁿ`. For this to work seamlessly when a `JLD2OutputWriter` is involved we might need to modify the constructor for `JLD2OutputWriter`. Currently the constructor runs an arbitrary `init(file, model)` function, and saves certain properties identified in the constructor signature:. https://github.com/CliMA/Oceananigans.jl/blob/9cfb568ec3a8e6f7efe8c7c41300ea9673c6b103/src/OutputWriters/jld2_output_writer.jl#L157-L160. This will fail if the output file already exists; thus it's not possible to pickup from a checkpoint with the same script used to initialize the model (without destroying prior output). A simple change could just be to allow `init` and `save_properties!` to fail with `try/catch` (or to avoid running those functions if a file already exists). There are also some shenanigans that'd have to be done for output files split into multiple `part`s. (We could, potentially, require `pickup=true` in the `JLD2OutputWriter` constructor, rather than changing its default behavior to accommodate auto-checkpoint-pickup). Another caveat is that this method of restoring checkpointed data will not work for large CPU models that consume almost all of the CPU memory (such that a single field cannot be loaded from file after `model` has been instantiated). These cases are relatively rare right now, since such large models would typically run very slowly on a typical single node. The basic idea is:. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...). run!(simulation, pickup=true); ```. We could also allow `pickup` to be an iteration number, eg. ```julia; # Model and simulation setup. simulation.output_writers[:checkpoi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068
https://github.com/CliMA/Oceananigans.jl/issues/1069:475,Energy Efficiency,energy,energy,475,"I think we want to consider calling `precomputations!(model)` (and perhaps changing its name) _after_ a time-step is complete, rather than before. The reason to do this is that it ensures _all_ fields are _entirely_ up-to-date and synchronized between time-steps. Currently, for example, field halo regions, hydrostatic pressure, and diffusivities are a ""step behind"" model.velocities and model.tracers. This is a problem for some diagnostics; for example, turbulent kinetic energy dissipation cannot be correctly calculated during output. Correct halo regions also cannot be saved. Having the entire model state synced at the end of a time-step is thus important for correct output. There's no extra computational cost to this procedure. However, we will have to execute one special call to `precomputations!(model)` inside `run!(simulation)` to initialize a time-stepping loop. I think this price is worth it. This change will mean that all aspects of the model state are ""untouchable"" between time-steps. In other words, one cannot change halos or the pressure fields at whim. I think this is ok, since this is already true for the majority of the model data (interior parts of the model velocities and tracer fields). This issue is entangled with #1063 since we cannot resolve this issue until we have standard output that does not change a field's halo regions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1069
https://github.com/CliMA/Oceananigans.jl/issues/1069:231,Integrability,synchroniz,synchronized,231,"I think we want to consider calling `precomputations!(model)` (and perhaps changing its name) _after_ a time-step is complete, rather than before. The reason to do this is that it ensures _all_ fields are _entirely_ up-to-date and synchronized between time-steps. Currently, for example, field halo regions, hydrostatic pressure, and diffusivities are a ""step behind"" model.velocities and model.tracers. This is a problem for some diagnostics; for example, turbulent kinetic energy dissipation cannot be correctly calculated during output. Correct halo regions also cannot be saved. Having the entire model state synced at the end of a time-step is thus important for correct output. There's no extra computational cost to this procedure. However, we will have to execute one special call to `precomputations!(model)` inside `run!(simulation)` to initialize a time-stepping loop. I think this price is worth it. This change will mean that all aspects of the model state are ""untouchable"" between time-steps. In other words, one cannot change halos or the pressure fields at whim. I think this is ok, since this is already true for the majority of the model data (interior parts of the model velocities and tracer fields). This issue is entangled with #1063 since we cannot resolve this issue until we have standard output that does not change a field's halo regions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1069
https://github.com/CliMA/Oceananigans.jl/pull/1070:60,Energy Efficiency,schedul,scheduling,60,"This PR provides a substantial rewrite to the user API for ""scheduling"" output and diagnostics. Previously, output was scheduled by specifying one of two keyword arguments when constructing the `AbstractOutputWriter`: `time_interval`, and `iteration_interval`. An example from the documentation is. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filename=""output_fields.nc"", time_interval=60). # output; NetCDFOutputWriter (time_interval=60): output_fields.nc; ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); └── 2 outputs: [""T"", ""u""]; ```. Time-averaging was specified by providing one or two additional keyword arguments: `time_average_interval` and (optionally) `time_average_stride`. This PR eliminates these keyword arguments in favor of a single argument `schedule`. In general, the `schedule` is an object which returns `true` (when output should be written, or a diagnostic calculated) and `false` (otherwise). This PR implements four `AbstractSchedule`s, and more are possible:. * `TimeInterval`: periodic schedule that reoccurs on a interval of model time.; * `IterationInterval`: periodic schedule that reoccurs on an iteration of model iterations; * `WallClockInterval` periodic schedule that reoccurs on an interval of ""wall time"", as kept by the clock on your wall; * `AveragedTimeInterval`: periodic schedule that reoccurs on an interval of model time, and specifies time-averaging of output over a `window` (and a default `window` equal to `interval` is now provided for friendliness). The old syntax thus becomes. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=TimeInterval(60)); ```. and averaging is specified (with a time window of 20 seconds) by writing. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=AveragedTimeInterval(60, window=20)); ```. This PR starts updating t",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1070
https://github.com/CliMA/Oceananigans.jl/pull/1070:119,Energy Efficiency,schedul,scheduled,119,"This PR provides a substantial rewrite to the user API for ""scheduling"" output and diagnostics. Previously, output was scheduled by specifying one of two keyword arguments when constructing the `AbstractOutputWriter`: `time_interval`, and `iteration_interval`. An example from the documentation is. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filename=""output_fields.nc"", time_interval=60). # output; NetCDFOutputWriter (time_interval=60): output_fields.nc; ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); └── 2 outputs: [""T"", ""u""]; ```. Time-averaging was specified by providing one or two additional keyword arguments: `time_average_interval` and (optionally) `time_average_stride`. This PR eliminates these keyword arguments in favor of a single argument `schedule`. In general, the `schedule` is an object which returns `true` (when output should be written, or a diagnostic calculated) and `false` (otherwise). This PR implements four `AbstractSchedule`s, and more are possible:. * `TimeInterval`: periodic schedule that reoccurs on a interval of model time.; * `IterationInterval`: periodic schedule that reoccurs on an iteration of model iterations; * `WallClockInterval` periodic schedule that reoccurs on an interval of ""wall time"", as kept by the clock on your wall; * `AveragedTimeInterval`: periodic schedule that reoccurs on an interval of model time, and specifies time-averaging of output over a `window` (and a default `window` equal to `interval` is now provided for friendliness). The old syntax thus becomes. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=TimeInterval(60)); ```. and averaging is specified (with a time window of 20 seconds) by writing. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=AveragedTimeInterval(60, window=20)); ```. This PR starts updating t",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1070
https://github.com/CliMA/Oceananigans.jl/pull/1070:828,Energy Efficiency,schedul,schedule,828,"This PR provides a substantial rewrite to the user API for ""scheduling"" output and diagnostics. Previously, output was scheduled by specifying one of two keyword arguments when constructing the `AbstractOutputWriter`: `time_interval`, and `iteration_interval`. An example from the documentation is. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filename=""output_fields.nc"", time_interval=60). # output; NetCDFOutputWriter (time_interval=60): output_fields.nc; ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); └── 2 outputs: [""T"", ""u""]; ```. Time-averaging was specified by providing one or two additional keyword arguments: `time_average_interval` and (optionally) `time_average_stride`. This PR eliminates these keyword arguments in favor of a single argument `schedule`. In general, the `schedule` is an object which returns `true` (when output should be written, or a diagnostic calculated) and `false` (otherwise). This PR implements four `AbstractSchedule`s, and more are possible:. * `TimeInterval`: periodic schedule that reoccurs on a interval of model time.; * `IterationInterval`: periodic schedule that reoccurs on an iteration of model iterations; * `WallClockInterval` periodic schedule that reoccurs on an interval of ""wall time"", as kept by the clock on your wall; * `AveragedTimeInterval`: periodic schedule that reoccurs on an interval of model time, and specifies time-averaging of output over a `window` (and a default `window` equal to `interval` is now provided for friendliness). The old syntax thus becomes. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=TimeInterval(60)); ```. and averaging is specified (with a time window of 20 seconds) by writing. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=AveragedTimeInterval(60, window=20)); ```. This PR starts updating t",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1070
https://github.com/CliMA/Oceananigans.jl/pull/1070:856,Energy Efficiency,schedul,schedule,856,"This PR provides a substantial rewrite to the user API for ""scheduling"" output and diagnostics. Previously, output was scheduled by specifying one of two keyword arguments when constructing the `AbstractOutputWriter`: `time_interval`, and `iteration_interval`. An example from the documentation is. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filename=""output_fields.nc"", time_interval=60). # output; NetCDFOutputWriter (time_interval=60): output_fields.nc; ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); └── 2 outputs: [""T"", ""u""]; ```. Time-averaging was specified by providing one or two additional keyword arguments: `time_average_interval` and (optionally) `time_average_stride`. This PR eliminates these keyword arguments in favor of a single argument `schedule`. In general, the `schedule` is an object which returns `true` (when output should be written, or a diagnostic calculated) and `false` (otherwise). This PR implements four `AbstractSchedule`s, and more are possible:. * `TimeInterval`: periodic schedule that reoccurs on a interval of model time.; * `IterationInterval`: periodic schedule that reoccurs on an iteration of model iterations; * `WallClockInterval` periodic schedule that reoccurs on an interval of ""wall time"", as kept by the clock on your wall; * `AveragedTimeInterval`: periodic schedule that reoccurs on an interval of model time, and specifies time-averaging of output over a `window` (and a default `window` equal to `interval` is now provided for friendliness). The old syntax thus becomes. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=TimeInterval(60)); ```. and averaging is specified (with a time window of 20 seconds) by writing. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=AveragedTimeInterval(60, window=20)); ```. This PR starts updating t",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1070
https://github.com/CliMA/Oceananigans.jl/pull/1070:1081,Energy Efficiency,schedul,schedule,1081,"cs. Previously, output was scheduled by specifying one of two keyword arguments when constructing the `AbstractOutputWriter`: `time_interval`, and `iteration_interval`. An example from the documentation is. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filename=""output_fields.nc"", time_interval=60). # output; NetCDFOutputWriter (time_interval=60): output_fields.nc; ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); └── 2 outputs: [""T"", ""u""]; ```. Time-averaging was specified by providing one or two additional keyword arguments: `time_average_interval` and (optionally) `time_average_stride`. This PR eliminates these keyword arguments in favor of a single argument `schedule`. In general, the `schedule` is an object which returns `true` (when output should be written, or a diagnostic calculated) and `false` (otherwise). This PR implements four `AbstractSchedule`s, and more are possible:. * `TimeInterval`: periodic schedule that reoccurs on a interval of model time.; * `IterationInterval`: periodic schedule that reoccurs on an iteration of model iterations; * `WallClockInterval` periodic schedule that reoccurs on an interval of ""wall time"", as kept by the clock on your wall; * `AveragedTimeInterval`: periodic schedule that reoccurs on an interval of model time, and specifies time-averaging of output over a `window` (and a default `window` equal to `interval` is now provided for friendliness). The old syntax thus becomes. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=TimeInterval(60)); ```. and averaging is specified (with a time window of 20 seconds) by writing. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=AveragedTimeInterval(60, window=20)); ```. This PR starts updating the examples and docs, though we still need to. - [x] finish updating verification scripts; -",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1070
https://github.com/CliMA/Oceananigans.jl/pull/1070:1166,Energy Efficiency,schedul,schedule,1166," =; NetCDFOutputWriter(model, fields, filename=""output_fields.nc"", time_interval=60). # output; NetCDFOutputWriter (time_interval=60): output_fields.nc; ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); └── 2 outputs: [""T"", ""u""]; ```. Time-averaging was specified by providing one or two additional keyword arguments: `time_average_interval` and (optionally) `time_average_stride`. This PR eliminates these keyword arguments in favor of a single argument `schedule`. In general, the `schedule` is an object which returns `true` (when output should be written, or a diagnostic calculated) and `false` (otherwise). This PR implements four `AbstractSchedule`s, and more are possible:. * `TimeInterval`: periodic schedule that reoccurs on a interval of model time.; * `IterationInterval`: periodic schedule that reoccurs on an iteration of model iterations; * `WallClockInterval` periodic schedule that reoccurs on an interval of ""wall time"", as kept by the clock on your wall; * `AveragedTimeInterval`: periodic schedule that reoccurs on an interval of model time, and specifies time-averaging of output over a `window` (and a default `window` equal to `interval` is now provided for friendliness). The old syntax thus becomes. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=TimeInterval(60)); ```. and averaging is specified (with a time window of 20 seconds) by writing. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=AveragedTimeInterval(60, window=20)); ```. This PR starts updating the examples and docs, though we still need to. - [x] finish updating verification scripts; - [x] finish updating docs. Since we now have a fairly convincing test about the accuracy of `WindowedTimeAverage`, I think we should also. - [x] add documentation for `WindowedTimeAverage`. which is apropos to this PR since it changes the syntax through whi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1070
https://github.com/CliMA/Oceananigans.jl/pull/1070:1257,Energy Efficiency,schedul,schedule,1257," =; NetCDFOutputWriter(model, fields, filename=""output_fields.nc"", time_interval=60). # output; NetCDFOutputWriter (time_interval=60): output_fields.nc; ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); └── 2 outputs: [""T"", ""u""]; ```. Time-averaging was specified by providing one or two additional keyword arguments: `time_average_interval` and (optionally) `time_average_stride`. This PR eliminates these keyword arguments in favor of a single argument `schedule`. In general, the `schedule` is an object which returns `true` (when output should be written, or a diagnostic calculated) and `false` (otherwise). This PR implements four `AbstractSchedule`s, and more are possible:. * `TimeInterval`: periodic schedule that reoccurs on a interval of model time.; * `IterationInterval`: periodic schedule that reoccurs on an iteration of model iterations; * `WallClockInterval` periodic schedule that reoccurs on an interval of ""wall time"", as kept by the clock on your wall; * `AveragedTimeInterval`: periodic schedule that reoccurs on an interval of model time, and specifies time-averaging of output over a `window` (and a default `window` equal to `interval` is now provided for friendliness). The old syntax thus becomes. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=TimeInterval(60)); ```. and averaging is specified (with a time window of 20 seconds) by writing. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=AveragedTimeInterval(60, window=20)); ```. This PR starts updating the examples and docs, though we still need to. - [x] finish updating verification scripts; - [x] finish updating docs. Since we now have a fairly convincing test about the accuracy of `WindowedTimeAverage`, I think we should also. - [x] add documentation for `WindowedTimeAverage`. which is apropos to this PR since it changes the syntax through whi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1070
https://github.com/CliMA/Oceananigans.jl/pull/1070:1381,Energy Efficiency,schedul,schedule,1381," =; NetCDFOutputWriter(model, fields, filename=""output_fields.nc"", time_interval=60). # output; NetCDFOutputWriter (time_interval=60): output_fields.nc; ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); └── 2 outputs: [""T"", ""u""]; ```. Time-averaging was specified by providing one or two additional keyword arguments: `time_average_interval` and (optionally) `time_average_stride`. This PR eliminates these keyword arguments in favor of a single argument `schedule`. In general, the `schedule` is an object which returns `true` (when output should be written, or a diagnostic calculated) and `false` (otherwise). This PR implements four `AbstractSchedule`s, and more are possible:. * `TimeInterval`: periodic schedule that reoccurs on a interval of model time.; * `IterationInterval`: periodic schedule that reoccurs on an iteration of model iterations; * `WallClockInterval` periodic schedule that reoccurs on an interval of ""wall time"", as kept by the clock on your wall; * `AveragedTimeInterval`: periodic schedule that reoccurs on an interval of model time, and specifies time-averaging of output over a `window` (and a default `window` equal to `interval` is now provided for friendliness). The old syntax thus becomes. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=TimeInterval(60)); ```. and averaging is specified (with a time window of 20 seconds) by writing. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=AveragedTimeInterval(60, window=20)); ```. This PR starts updating the examples and docs, though we still need to. - [x] finish updating verification scripts; - [x] finish updating docs. Since we now have a fairly convincing test about the accuracy of `WindowedTimeAverage`, I think we should also. - [x] add documentation for `WindowedTimeAverage`. which is apropos to this PR since it changes the syntax through whi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1070
https://github.com/CliMA/Oceananigans.jl/pull/1070:1707,Energy Efficiency,schedul,schedule,1707,"ptionally) `time_average_stride`. This PR eliminates these keyword arguments in favor of a single argument `schedule`. In general, the `schedule` is an object which returns `true` (when output should be written, or a diagnostic calculated) and `false` (otherwise). This PR implements four `AbstractSchedule`s, and more are possible:. * `TimeInterval`: periodic schedule that reoccurs on a interval of model time.; * `IterationInterval`: periodic schedule that reoccurs on an iteration of model iterations; * `WallClockInterval` periodic schedule that reoccurs on an interval of ""wall time"", as kept by the clock on your wall; * `AveragedTimeInterval`: periodic schedule that reoccurs on an interval of model time, and specifies time-averaging of output over a `window` (and a default `window` equal to `interval` is now provided for friendliness). The old syntax thus becomes. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=TimeInterval(60)); ```. and averaging is specified (with a time window of 20 seconds) by writing. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=AveragedTimeInterval(60, window=20)); ```. This PR starts updating the examples and docs, though we still need to. - [x] finish updating verification scripts; - [x] finish updating docs. Since we now have a fairly convincing test about the accuracy of `WindowedTimeAverage`, I think we should also. - [x] add documentation for `WindowedTimeAverage`. which is apropos to this PR since it changes the syntax through which averaging is specified. Eventually, we should use the ""scheduling"" concept for both callafter function in `run!(simulation)` and the `TimeStepWizard` (separately), which will get rid of the `iteration_interval` argument in `run!(simulation)`. PS: should we use `WindowAveragedTimeInterval` rather than `AveragedTimeInterval`? I wasn't sure if the added verbosity added",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1070
https://github.com/CliMA/Oceananigans.jl/pull/1070:1924,Energy Efficiency,schedul,schedule,1924,"e `schedule` is an object which returns `true` (when output should be written, or a diagnostic calculated) and `false` (otherwise). This PR implements four `AbstractSchedule`s, and more are possible:. * `TimeInterval`: periodic schedule that reoccurs on a interval of model time.; * `IterationInterval`: periodic schedule that reoccurs on an iteration of model iterations; * `WallClockInterval` periodic schedule that reoccurs on an interval of ""wall time"", as kept by the clock on your wall; * `AveragedTimeInterval`: periodic schedule that reoccurs on an interval of model time, and specifies time-averaging of output over a `window` (and a default `window` equal to `interval` is now provided for friendliness). The old syntax thus becomes. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=TimeInterval(60)); ```. and averaging is specified (with a time window of 20 seconds) by writing. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=AveragedTimeInterval(60, window=20)); ```. This PR starts updating the examples and docs, though we still need to. - [x] finish updating verification scripts; - [x] finish updating docs. Since we now have a fairly convincing test about the accuracy of `WindowedTimeAverage`, I think we should also. - [x] add documentation for `WindowedTimeAverage`. which is apropos to this PR since it changes the syntax through which averaging is specified. Eventually, we should use the ""scheduling"" concept for both callafter function in `run!(simulation)` and the `TimeStepWizard` (separately), which will get rid of the `iteration_interval` argument in `run!(simulation)`. PS: should we use `WindowAveragedTimeInterval` rather than `AveragedTimeInterval`? I wasn't sure if the added verbosity added clarity here (the important part is the ""Averaging"") but I'm open to considering it. Resolves #1019 ; Resolves #853 ; Resolves #845",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1070
https://github.com/CliMA/Oceananigans.jl/pull/1070:2408,Energy Efficiency,schedul,scheduling,2408,"e `schedule` is an object which returns `true` (when output should be written, or a diagnostic calculated) and `false` (otherwise). This PR implements four `AbstractSchedule`s, and more are possible:. * `TimeInterval`: periodic schedule that reoccurs on a interval of model time.; * `IterationInterval`: periodic schedule that reoccurs on an iteration of model iterations; * `WallClockInterval` periodic schedule that reoccurs on an interval of ""wall time"", as kept by the clock on your wall; * `AveragedTimeInterval`: periodic schedule that reoccurs on an interval of model time, and specifies time-averaging of output over a `window` (and a default `window` equal to `interval` is now provided for friendliness). The old syntax thus becomes. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=TimeInterval(60)); ```. and averaging is specified (with a time window of 20 seconds) by writing. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=AveragedTimeInterval(60, window=20)); ```. This PR starts updating the examples and docs, though we still need to. - [x] finish updating verification scripts; - [x] finish updating docs. Since we now have a fairly convincing test about the accuracy of `WindowedTimeAverage`, I think we should also. - [x] add documentation for `WindowedTimeAverage`. which is apropos to this PR since it changes the syntax through which averaging is specified. Eventually, we should use the ""scheduling"" concept for both callafter function in `run!(simulation)` and the `TimeStepWizard` (separately), which will get rid of the `iteration_interval` argument in `run!(simulation)`. PS: should we use `WindowAveragedTimeInterval` rather than `AveragedTimeInterval`? I wasn't sure if the added verbosity added clarity here (the important part is the ""Averaging"") but I'm open to considering it. Resolves #1019 ; Resolves #853 ; Resolves #845",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1070
https://github.com/CliMA/Oceananigans.jl/pull/1070:31,Modifiability,rewrite,rewrite,31,"This PR provides a substantial rewrite to the user API for ""scheduling"" output and diagnostics. Previously, output was scheduled by specifying one of two keyword arguments when constructing the `AbstractOutputWriter`: `time_interval`, and `iteration_interval`. An example from the documentation is. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filename=""output_fields.nc"", time_interval=60). # output; NetCDFOutputWriter (time_interval=60): output_fields.nc; ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); └── 2 outputs: [""T"", ""u""]; ```. Time-averaging was specified by providing one or two additional keyword arguments: `time_average_interval` and (optionally) `time_average_stride`. This PR eliminates these keyword arguments in favor of a single argument `schedule`. In general, the `schedule` is an object which returns `true` (when output should be written, or a diagnostic calculated) and `false` (otherwise). This PR implements four `AbstractSchedule`s, and more are possible:. * `TimeInterval`: periodic schedule that reoccurs on a interval of model time.; * `IterationInterval`: periodic schedule that reoccurs on an iteration of model iterations; * `WallClockInterval` periodic schedule that reoccurs on an interval of ""wall time"", as kept by the clock on your wall; * `AveragedTimeInterval`: periodic schedule that reoccurs on an interval of model time, and specifies time-averaging of output over a `window` (and a default `window` equal to `interval` is now provided for friendliness). The old syntax thus becomes. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=TimeInterval(60)); ```. and averaging is specified (with a time window of 20 seconds) by writing. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=AveragedTimeInterval(60, window=20)); ```. This PR starts updating t",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1070
https://github.com/CliMA/Oceananigans.jl/pull/1070:2158,Testability,test,test,2158,"e `schedule` is an object which returns `true` (when output should be written, or a diagnostic calculated) and `false` (otherwise). This PR implements four `AbstractSchedule`s, and more are possible:. * `TimeInterval`: periodic schedule that reoccurs on a interval of model time.; * `IterationInterval`: periodic schedule that reoccurs on an iteration of model iterations; * `WallClockInterval` periodic schedule that reoccurs on an interval of ""wall time"", as kept by the clock on your wall; * `AveragedTimeInterval`: periodic schedule that reoccurs on an interval of model time, and specifies time-averaging of output over a `window` (and a default `window` equal to `interval` is now provided for friendliness). The old syntax thus becomes. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=TimeInterval(60)); ```. and averaging is specified (with a time window of 20 seconds) by writing. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=AveragedTimeInterval(60, window=20)); ```. This PR starts updating the examples and docs, though we still need to. - [x] finish updating verification scripts; - [x] finish updating docs. Since we now have a fairly convincing test about the accuracy of `WindowedTimeAverage`, I think we should also. - [x] add documentation for `WindowedTimeAverage`. which is apropos to this PR since it changes the syntax through which averaging is specified. Eventually, we should use the ""scheduling"" concept for both callafter function in `run!(simulation)` and the `TimeStepWizard` (separately), which will get rid of the `iteration_interval` argument in `run!(simulation)`. PS: should we use `WindowAveragedTimeInterval` rather than `AveragedTimeInterval`? I wasn't sure if the added verbosity added clarity here (the important part is the ""Averaging"") but I'm open to considering it. Resolves #1019 ; Resolves #853 ; Resolves #845",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1070
https://github.com/CliMA/Oceananigans.jl/pull/1072:361,Availability,ERROR,ERROR,361,"I couldn't run docs locally to make sure all is good... running ; ```bash; julia --project=docs/ -e 'using Pkg; Pkg.instantiate(); Pkg.develop(PackageSpec(path=pwd()))'; julia --project=docs/ docs/make.jl;; ```. returns. ```bash; ...; [ Info: Expanding citation: Kundu15.; [ Info: CheckDocument: running document checks.; [ Info: Populate: populating indices.; ERROR: LoadError: `makedocs` encountered an error. Terminating build; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /Users/navid/.julia/packages/Documenter/pjwqp/src/Builder.jl:255; [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /Users/navid/.julia/packages/Documenter/pjwqp/src/Utilities/Selectors.jl:167; [4] #2 at /Users/navid/.julia/packages/Documenter/pjwqp/src/Documenter.jl:241 [inlined]; [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104; [6] #makedocs#1 at /Users/navid/.julia/packages/Documenter/pjwqp/src/Documenter.jl:240 [inlined]; [7] top-level scope at /Users/navid/Research/Oceananigans.jl/docs/make.jl:141; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /Users/navid/Research/Oceananigans.jl/docs/make.jl:141; ```. which I couldn't trace down...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1072
https://github.com/CliMA/Oceananigans.jl/pull/1072:405,Availability,error,error,405,"I couldn't run docs locally to make sure all is good... running ; ```bash; julia --project=docs/ -e 'using Pkg; Pkg.instantiate(); Pkg.develop(PackageSpec(path=pwd()))'; julia --project=docs/ docs/make.jl;; ```. returns. ```bash; ...; [ Info: Expanding citation: Kundu15.; [ Info: CheckDocument: running document checks.; [ Info: Populate: populating indices.; ERROR: LoadError: `makedocs` encountered an error. Terminating build; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /Users/navid/.julia/packages/Documenter/pjwqp/src/Builder.jl:255; [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /Users/navid/.julia/packages/Documenter/pjwqp/src/Utilities/Selectors.jl:167; [4] #2 at /Users/navid/.julia/packages/Documenter/pjwqp/src/Documenter.jl:241 [inlined]; [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104; [6] #makedocs#1 at /Users/navid/.julia/packages/Documenter/pjwqp/src/Documenter.jl:240 [inlined]; [7] top-level scope at /Users/navid/Research/Oceananigans.jl/docs/make.jl:141; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /Users/navid/Research/Oceananigans.jl/docs/make.jl:141; ```. which I couldn't trace down...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1072
https://github.com/CliMA/Oceananigans.jl/pull/1072:448,Availability,error,error,448,"I couldn't run docs locally to make sure all is good... running ; ```bash; julia --project=docs/ -e 'using Pkg; Pkg.instantiate(); Pkg.develop(PackageSpec(path=pwd()))'; julia --project=docs/ docs/make.jl;; ```. returns. ```bash; ...; [ Info: Expanding citation: Kundu15.; [ Info: CheckDocument: running document checks.; [ Info: Populate: populating indices.; ERROR: LoadError: `makedocs` encountered an error. Terminating build; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /Users/navid/.julia/packages/Documenter/pjwqp/src/Builder.jl:255; [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /Users/navid/.julia/packages/Documenter/pjwqp/src/Utilities/Selectors.jl:167; [4] #2 at /Users/navid/.julia/packages/Documenter/pjwqp/src/Documenter.jl:241 [inlined]; [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104; [6] #makedocs#1 at /Users/navid/.julia/packages/Documenter/pjwqp/src/Documenter.jl:240 [inlined]; [7] top-level scope at /Users/navid/Research/Oceananigans.jl/docs/make.jl:141; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /Users/navid/Research/Oceananigans.jl/docs/make.jl:141; ```. which I couldn't trace down...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1072
https://github.com/CliMA/Oceananigans.jl/pull/1072:469,Availability,error,error,469,"I couldn't run docs locally to make sure all is good... running ; ```bash; julia --project=docs/ -e 'using Pkg; Pkg.instantiate(); Pkg.develop(PackageSpec(path=pwd()))'; julia --project=docs/ docs/make.jl;; ```. returns. ```bash; ...; [ Info: Expanding citation: Kundu15.; [ Info: CheckDocument: running document checks.; [ Info: Populate: populating indices.; ERROR: LoadError: `makedocs` encountered an error. Terminating build; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /Users/navid/.julia/packages/Documenter/pjwqp/src/Builder.jl:255; [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /Users/navid/.julia/packages/Documenter/pjwqp/src/Utilities/Selectors.jl:167; [4] #2 at /Users/navid/.julia/packages/Documenter/pjwqp/src/Documenter.jl:241 [inlined]; [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104; [6] #makedocs#1 at /Users/navid/.julia/packages/Documenter/pjwqp/src/Documenter.jl:240 [inlined]; [7] top-level scope at /Users/navid/Research/Oceananigans.jl/docs/make.jl:141; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /Users/navid/Research/Oceananigans.jl/docs/make.jl:141; ```. which I couldn't trace down...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1072
https://github.com/CliMA/Oceananigans.jl/pull/1072:1478,Availability,down,down,1478,"I couldn't run docs locally to make sure all is good... running ; ```bash; julia --project=docs/ -e 'using Pkg; Pkg.instantiate(); Pkg.develop(PackageSpec(path=pwd()))'; julia --project=docs/ docs/make.jl;; ```. returns. ```bash; ...; [ Info: Expanding citation: Kundu15.; [ Info: CheckDocument: running document checks.; [ Info: Populate: populating indices.; ERROR: LoadError: `makedocs` encountered an error. Terminating build; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /Users/navid/.julia/packages/Documenter/pjwqp/src/Builder.jl:255; [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /Users/navid/.julia/packages/Documenter/pjwqp/src/Utilities/Selectors.jl:167; [4] #2 at /Users/navid/.julia/packages/Documenter/pjwqp/src/Documenter.jl:241 [inlined]; [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104; [6] #makedocs#1 at /Users/navid/.julia/packages/Documenter/pjwqp/src/Documenter.jl:240 [inlined]; [7] top-level scope at /Users/navid/Research/Oceananigans.jl/docs/make.jl:141; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /Users/navid/Research/Oceananigans.jl/docs/make.jl:141; ```. which I couldn't trace down...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1072
https://github.com/CliMA/Oceananigans.jl/pull/1072:368,Performance,Load,LoadError,368,"I couldn't run docs locally to make sure all is good... running ; ```bash; julia --project=docs/ -e 'using Pkg; Pkg.instantiate(); Pkg.develop(PackageSpec(path=pwd()))'; julia --project=docs/ docs/make.jl;; ```. returns. ```bash; ...; [ Info: Expanding citation: Kundu15.; [ Info: CheckDocument: running document checks.; [ Info: Populate: populating indices.; ERROR: LoadError: `makedocs` encountered an error. Terminating build; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /Users/navid/.julia/packages/Documenter/pjwqp/src/Builder.jl:255; [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /Users/navid/.julia/packages/Documenter/pjwqp/src/Utilities/Selectors.jl:167; [4] #2 at /Users/navid/.julia/packages/Documenter/pjwqp/src/Documenter.jl:241 [inlined]; [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104; [6] #makedocs#1 at /Users/navid/.julia/packages/Documenter/pjwqp/src/Documenter.jl:240 [inlined]; [7] top-level scope at /Users/navid/Research/Oceananigans.jl/docs/make.jl:141; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /Users/navid/Research/Oceananigans.jl/docs/make.jl:141; ```. which I couldn't trace down...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1072
https://github.com/CliMA/Oceananigans.jl/issues/1073:1867,Availability,mainten,maintenance,1867,"ype that looks something like. ```julia; struct FunctionOperand{F, G, A}; func :: F; grid :: G; args :: A; end. @inline Base.getindex(o::FunctionOperand, i, j, k) = o.func(i, j, k, o.grid, o.args...); ```. This works because the kernel that computes a `ComputedField`'s data is. https://github.com/CliMA/Oceananigans.jl/blob/c5f47e01ef0fab0cd1e99260e578ace7ad04084c/src/Fields/computed_field.jl#L85-L88. Then with a bit of boilerplate we can define constructors for all the terms we might need, eg. ```julia; TendencyTermField(X, Y, Z, term_func, grid; args, data=nothing) =; ComputedField{X, Y, Z}(FunctionOperand(term_func, grid, args), data=data). using Oceananigans.Advection: momentum_flux_uu, momentum_flux_uw. uu = TendencyTermField(Cell, Cell, Cell, momentum_flux_uu, grid, args=(model.advection, model.velocities.u, model.velocities.u)); wu = TendencyTermField(Cell, Cell, Face, momentum_flux_uw, grid, args=(model.advection, model.velocities.w, model.velocities.u)); ```. We probably want to define aliases for all the terms that appear in our tendency equations, as well as the advective and diffusive fluxes, so that we can ensure they are correct and correctly located on the staggered grid. Unfortunately this does involve a lot of boiler plate and introduces a maintenance and testing burden. If we can push responsibility more to users I am open to that, but I'm not 100% how to make this process more programmatic. Ideas very welcome. If functions like `momentum_flux_uu` are going to emerge from darkness into users' scripts, we may want to have a discussion about whether our names / naming convention is sensible. By the way, `ComputedField` seems to assume that `operand` has a property called `grid`:. https://github.com/CliMA/Oceananigans.jl/blob/c5f47e01ef0fab0cd1e99260e578ace7ad04084c/src/Fields/computed_field.jl#L43-L47. We could create a type called `AbstractOperand`, of which `AbstractOperation` (and other concrete operands) are subtypes. cc @qingli411, @BrodiePearson",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1073
https://github.com/CliMA/Oceananigans.jl/issues/1073:1883,Testability,test,testing,1883,"ype that looks something like. ```julia; struct FunctionOperand{F, G, A}; func :: F; grid :: G; args :: A; end. @inline Base.getindex(o::FunctionOperand, i, j, k) = o.func(i, j, k, o.grid, o.args...); ```. This works because the kernel that computes a `ComputedField`'s data is. https://github.com/CliMA/Oceananigans.jl/blob/c5f47e01ef0fab0cd1e99260e578ace7ad04084c/src/Fields/computed_field.jl#L85-L88. Then with a bit of boilerplate we can define constructors for all the terms we might need, eg. ```julia; TendencyTermField(X, Y, Z, term_func, grid; args, data=nothing) =; ComputedField{X, Y, Z}(FunctionOperand(term_func, grid, args), data=data). using Oceananigans.Advection: momentum_flux_uu, momentum_flux_uw. uu = TendencyTermField(Cell, Cell, Cell, momentum_flux_uu, grid, args=(model.advection, model.velocities.u, model.velocities.u)); wu = TendencyTermField(Cell, Cell, Face, momentum_flux_uw, grid, args=(model.advection, model.velocities.w, model.velocities.u)); ```. We probably want to define aliases for all the terms that appear in our tendency equations, as well as the advective and diffusive fluxes, so that we can ensure they are correct and correctly located on the staggered grid. Unfortunately this does involve a lot of boiler plate and introduces a maintenance and testing burden. If we can push responsibility more to users I am open to that, but I'm not 100% how to make this process more programmatic. Ideas very welcome. If functions like `momentum_flux_uu` are going to emerge from darkness into users' scripts, we may want to have a discussion about whether our names / naming convention is sensible. By the way, `ComputedField` seems to assume that `operand` has a property called `grid`:. https://github.com/CliMA/Oceananigans.jl/blob/c5f47e01ef0fab0cd1e99260e578ace7ad04084c/src/Fields/computed_field.jl#L43-L47. We could create a type called `AbstractOperand`, of which `AbstractOperation` (and other concrete operands) are subtypes. cc @qingli411, @BrodiePearson",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1073
https://github.com/CliMA/Oceananigans.jl/pull/1074:198,Testability,test,test,198,"The Leith closure uses the isotropic operators for viscosity, but defines special operators for tracer diffusivities (so that tracer fluxes lie in a local isopycnal). I re-enabled the time-stepping test for Leith. We'll see if it works. Resolves #1034",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1074
https://github.com/CliMA/Oceananigans.jl/issues/1075:87,Availability,down,downside,87,"> Is this for examples and docs? It does obviously read better; I'm not sure about the downside of name proliferation. Maybe we can stew on it and update in a future PR?. I was thinking both, i.e. encourage their use to improve script readability. Yeah we can just update things as we go along. I guess the downside is that new users may not immediately notice that these common words, e.g. `minutes`, are actually being exported by `Oceananigans.Utils`. Perhaps if they were exported by a submodule like `Oceananigans.Units` that would be clearer. Also, newcomers to Julia may not realize that you can write things like `2π` or `3hours` but this should not stop us from using this nice language feature. _Originally posted by @ali-ramadhan in https://github.com/CliMA/Oceananigans.jl/pull/1070#issuecomment-711026555_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1075
https://github.com/CliMA/Oceananigans.jl/issues/1075:307,Availability,down,downside,307,"> Is this for examples and docs? It does obviously read better; I'm not sure about the downside of name proliferation. Maybe we can stew on it and update in a future PR?. I was thinking both, i.e. encourage their use to improve script readability. Yeah we can just update things as we go along. I guess the downside is that new users may not immediately notice that these common words, e.g. `minutes`, are actually being exported by `Oceananigans.Utils`. Perhaps if they were exported by a submodule like `Oceananigans.Units` that would be clearer. Also, newcomers to Julia may not realize that you can write things like `2π` or `3hours` but this should not stop us from using this nice language feature. _Originally posted by @ali-ramadhan in https://github.com/CliMA/Oceananigans.jl/pull/1070#issuecomment-711026555_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1075
https://github.com/CliMA/Oceananigans.jl/issues/1075:147,Deployability,update,update,147,"> Is this for examples and docs? It does obviously read better; I'm not sure about the downside of name proliferation. Maybe we can stew on it and update in a future PR?. I was thinking both, i.e. encourage their use to improve script readability. Yeah we can just update things as we go along. I guess the downside is that new users may not immediately notice that these common words, e.g. `minutes`, are actually being exported by `Oceananigans.Utils`. Perhaps if they were exported by a submodule like `Oceananigans.Units` that would be clearer. Also, newcomers to Julia may not realize that you can write things like `2π` or `3hours` but this should not stop us from using this nice language feature. _Originally posted by @ali-ramadhan in https://github.com/CliMA/Oceananigans.jl/pull/1070#issuecomment-711026555_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1075
https://github.com/CliMA/Oceananigans.jl/issues/1075:265,Deployability,update,update,265,"> Is this for examples and docs? It does obviously read better; I'm not sure about the downside of name proliferation. Maybe we can stew on it and update in a future PR?. I was thinking both, i.e. encourage their use to improve script readability. Yeah we can just update things as we go along. I guess the downside is that new users may not immediately notice that these common words, e.g. `minutes`, are actually being exported by `Oceananigans.Utils`. Perhaps if they were exported by a submodule like `Oceananigans.Units` that would be clearer. Also, newcomers to Julia may not realize that you can write things like `2π` or `3hours` but this should not stop us from using this nice language feature. _Originally posted by @ali-ramadhan in https://github.com/CliMA/Oceananigans.jl/pull/1070#issuecomment-711026555_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1075
https://github.com/CliMA/Oceananigans.jl/issues/1075:540,Usability,clear,clearer,540,"> Is this for examples and docs? It does obviously read better; I'm not sure about the downside of name proliferation. Maybe we can stew on it and update in a future PR?. I was thinking both, i.e. encourage their use to improve script readability. Yeah we can just update things as we go along. I guess the downside is that new users may not immediately notice that these common words, e.g. `minutes`, are actually being exported by `Oceananigans.Utils`. Perhaps if they were exported by a submodule like `Oceananigans.Units` that would be clearer. Also, newcomers to Julia may not realize that you can write things like `2π` or `3hours` but this should not stop us from using this nice language feature. _Originally posted by @ali-ramadhan in https://github.com/CliMA/Oceananigans.jl/pull/1070#issuecomment-711026555_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1075
https://github.com/CliMA/Oceananigans.jl/issues/1076:19,Energy Efficiency,reduce,reduced,19,This significantly reduced the time to first plot for Plots.jl: https://github.com/JuliaPlots/Plots.jl/pull/2544. I guess the idea is we don't care about performance when running our tests. Most of the time is spent compiling so if we can reduce compile time (at the cost of having sub-optimal code) then our tests will run faster.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1076
https://github.com/CliMA/Oceananigans.jl/issues/1076:239,Energy Efficiency,reduce,reduce,239,This significantly reduced the time to first plot for Plots.jl: https://github.com/JuliaPlots/Plots.jl/pull/2544. I guess the idea is we don't care about performance when running our tests. Most of the time is spent compiling so if we can reduce compile time (at the cost of having sub-optimal code) then our tests will run faster.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1076
https://github.com/CliMA/Oceananigans.jl/issues/1076:154,Performance,perform,performance,154,This significantly reduced the time to first plot for Plots.jl: https://github.com/JuliaPlots/Plots.jl/pull/2544. I guess the idea is we don't care about performance when running our tests. Most of the time is spent compiling so if we can reduce compile time (at the cost of having sub-optimal code) then our tests will run faster.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1076
https://github.com/CliMA/Oceananigans.jl/issues/1076:183,Testability,test,tests,183,This significantly reduced the time to first plot for Plots.jl: https://github.com/JuliaPlots/Plots.jl/pull/2544. I guess the idea is we don't care about performance when running our tests. Most of the time is spent compiling so if we can reduce compile time (at the cost of having sub-optimal code) then our tests will run faster.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1076
https://github.com/CliMA/Oceananigans.jl/issues/1076:309,Testability,test,tests,309,This significantly reduced the time to first plot for Plots.jl: https://github.com/JuliaPlots/Plots.jl/pull/2544. I guess the idea is we don't care about performance when running our tests. Most of the time is spent compiling so if we can reduce compile time (at the cost of having sub-optimal code) then our tests will run faster.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1076
https://github.com/CliMA/Oceananigans.jl/pull/1077:1537,Availability,Checkpoint,Checkpointer,1537,"In the spirit of getting closer to continuous delivery (see https://www.oxinabox.net/2019/09/28/Continuous-Delivery-For-Julia-Packages.html#what-if-i-dont-want-to-release-right-now--dev-versions) we should probably tag and release v0.43.0 soon since PRs #1070, #1057, and #1061 + couple of bug fix PRs would be useful to have. Release notes:. * Fixes a bug in `TwoDimensionalLeith` (PR #1073, issue #1034). Previously tests were being skipped due to extreme slowness. Now we run tests on GPU (but not CPU, where the closure is much slower to compile). * Rewrites the interface for ""scheduling"" output and diagnostics (PR #1070). Previously output and diagnostics were usually scheduled by specifying either `time_interval` or `iteration_interval` kwargs in the constrcutor for the object in question. Now, the relevant kwarg is called `schedule` and takes a callable `AbstractSchedule` object (or any user-defined function `func` that returns `true` or `false` depending on the single argument `func(model)`). This design is more flexible and extensible, and also simplifies underlying code. Four schedules are provided:. - `TimeInterval(interval)`; - `IterationInterval(interval)`; - `WallTimeInterval(interval)`; - `AveragedTimeInterval(interval; window=interval, stride=1)` (for time-averaging output). Breaking changes:. * Output writers and diagnostics no longer have the keyword arguments `time_interval` or `iteration_interval`. The most commonly-used features that are affected are `JLD2OutputWriter`, `NetCDFOutputWriter`, and `Checkpointer`. `JLD2OutputWriter` and `NetCDFOutputWriter` no longer have the kwargs `time_averaging_window` and `time_averaging_stride`. The specific syntax changes are:. * `time_interval=T` becomes `schedule=TimeInterval(T)`; * `iteration_interval=I` becomes `schedule=IterationInterval(I)`; * `time_interval=T, time_averaging_window=W` becomes `schedule=AveragedTimeInterval(T, window=W)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1077
https://github.com/CliMA/Oceananigans.jl/pull/1077:35,Deployability,continuous,continuous,35,"In the spirit of getting closer to continuous delivery (see https://www.oxinabox.net/2019/09/28/Continuous-Delivery-For-Julia-Packages.html#what-if-i-dont-want-to-release-right-now--dev-versions) we should probably tag and release v0.43.0 soon since PRs #1070, #1057, and #1061 + couple of bug fix PRs would be useful to have. Release notes:. * Fixes a bug in `TwoDimensionalLeith` (PR #1073, issue #1034). Previously tests were being skipped due to extreme slowness. Now we run tests on GPU (but not CPU, where the closure is much slower to compile). * Rewrites the interface for ""scheduling"" output and diagnostics (PR #1070). Previously output and diagnostics were usually scheduled by specifying either `time_interval` or `iteration_interval` kwargs in the constrcutor for the object in question. Now, the relevant kwarg is called `schedule` and takes a callable `AbstractSchedule` object (or any user-defined function `func` that returns `true` or `false` depending on the single argument `func(model)`). This design is more flexible and extensible, and also simplifies underlying code. Four schedules are provided:. - `TimeInterval(interval)`; - `IterationInterval(interval)`; - `WallTimeInterval(interval)`; - `AveragedTimeInterval(interval; window=interval, stride=1)` (for time-averaging output). Breaking changes:. * Output writers and diagnostics no longer have the keyword arguments `time_interval` or `iteration_interval`. The most commonly-used features that are affected are `JLD2OutputWriter`, `NetCDFOutputWriter`, and `Checkpointer`. `JLD2OutputWriter` and `NetCDFOutputWriter` no longer have the kwargs `time_averaging_window` and `time_averaging_stride`. The specific syntax changes are:. * `time_interval=T` becomes `schedule=TimeInterval(T)`; * `iteration_interval=I` becomes `schedule=IterationInterval(I)`; * `time_interval=T, time_averaging_window=W` becomes `schedule=AveragedTimeInterval(T, window=W)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1077
https://github.com/CliMA/Oceananigans.jl/pull/1077:96,Deployability,Continuous,Continuous-Delivery-For-Julia-Packages,96,"In the spirit of getting closer to continuous delivery (see https://www.oxinabox.net/2019/09/28/Continuous-Delivery-For-Julia-Packages.html#what-if-i-dont-want-to-release-right-now--dev-versions) we should probably tag and release v0.43.0 soon since PRs #1070, #1057, and #1061 + couple of bug fix PRs would be useful to have. Release notes:. * Fixes a bug in `TwoDimensionalLeith` (PR #1073, issue #1034). Previously tests were being skipped due to extreme slowness. Now we run tests on GPU (but not CPU, where the closure is much slower to compile). * Rewrites the interface for ""scheduling"" output and diagnostics (PR #1070). Previously output and diagnostics were usually scheduled by specifying either `time_interval` or `iteration_interval` kwargs in the constrcutor for the object in question. Now, the relevant kwarg is called `schedule` and takes a callable `AbstractSchedule` object (or any user-defined function `func` that returns `true` or `false` depending on the single argument `func(model)`). This design is more flexible and extensible, and also simplifies underlying code. Four schedules are provided:. - `TimeInterval(interval)`; - `IterationInterval(interval)`; - `WallTimeInterval(interval)`; - `AveragedTimeInterval(interval; window=interval, stride=1)` (for time-averaging output). Breaking changes:. * Output writers and diagnostics no longer have the keyword arguments `time_interval` or `iteration_interval`. The most commonly-used features that are affected are `JLD2OutputWriter`, `NetCDFOutputWriter`, and `Checkpointer`. `JLD2OutputWriter` and `NetCDFOutputWriter` no longer have the kwargs `time_averaging_window` and `time_averaging_stride`. The specific syntax changes are:. * `time_interval=T` becomes `schedule=TimeInterval(T)`; * `iteration_interval=I` becomes `schedule=IterationInterval(I)`; * `time_interval=T, time_averaging_window=W` becomes `schedule=AveragedTimeInterval(T, window=W)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1077
https://github.com/CliMA/Oceananigans.jl/pull/1077:163,Deployability,release,release-right-now--dev-versions,163,"In the spirit of getting closer to continuous delivery (see https://www.oxinabox.net/2019/09/28/Continuous-Delivery-For-Julia-Packages.html#what-if-i-dont-want-to-release-right-now--dev-versions) we should probably tag and release v0.43.0 soon since PRs #1070, #1057, and #1061 + couple of bug fix PRs would be useful to have. Release notes:. * Fixes a bug in `TwoDimensionalLeith` (PR #1073, issue #1034). Previously tests were being skipped due to extreme slowness. Now we run tests on GPU (but not CPU, where the closure is much slower to compile). * Rewrites the interface for ""scheduling"" output and diagnostics (PR #1070). Previously output and diagnostics were usually scheduled by specifying either `time_interval` or `iteration_interval` kwargs in the constrcutor for the object in question. Now, the relevant kwarg is called `schedule` and takes a callable `AbstractSchedule` object (or any user-defined function `func` that returns `true` or `false` depending on the single argument `func(model)`). This design is more flexible and extensible, and also simplifies underlying code. Four schedules are provided:. - `TimeInterval(interval)`; - `IterationInterval(interval)`; - `WallTimeInterval(interval)`; - `AveragedTimeInterval(interval; window=interval, stride=1)` (for time-averaging output). Breaking changes:. * Output writers and diagnostics no longer have the keyword arguments `time_interval` or `iteration_interval`. The most commonly-used features that are affected are `JLD2OutputWriter`, `NetCDFOutputWriter`, and `Checkpointer`. `JLD2OutputWriter` and `NetCDFOutputWriter` no longer have the kwargs `time_averaging_window` and `time_averaging_stride`. The specific syntax changes are:. * `time_interval=T` becomes `schedule=TimeInterval(T)`; * `iteration_interval=I` becomes `schedule=IterationInterval(I)`; * `time_interval=T, time_averaging_window=W` becomes `schedule=AveragedTimeInterval(T, window=W)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1077
https://github.com/CliMA/Oceananigans.jl/pull/1077:223,Deployability,release,release,223,"In the spirit of getting closer to continuous delivery (see https://www.oxinabox.net/2019/09/28/Continuous-Delivery-For-Julia-Packages.html#what-if-i-dont-want-to-release-right-now--dev-versions) we should probably tag and release v0.43.0 soon since PRs #1070, #1057, and #1061 + couple of bug fix PRs would be useful to have. Release notes:. * Fixes a bug in `TwoDimensionalLeith` (PR #1073, issue #1034). Previously tests were being skipped due to extreme slowness. Now we run tests on GPU (but not CPU, where the closure is much slower to compile). * Rewrites the interface for ""scheduling"" output and diagnostics (PR #1070). Previously output and diagnostics were usually scheduled by specifying either `time_interval` or `iteration_interval` kwargs in the constrcutor for the object in question. Now, the relevant kwarg is called `schedule` and takes a callable `AbstractSchedule` object (or any user-defined function `func` that returns `true` or `false` depending on the single argument `func(model)`). This design is more flexible and extensible, and also simplifies underlying code. Four schedules are provided:. - `TimeInterval(interval)`; - `IterationInterval(interval)`; - `WallTimeInterval(interval)`; - `AveragedTimeInterval(interval; window=interval, stride=1)` (for time-averaging output). Breaking changes:. * Output writers and diagnostics no longer have the keyword arguments `time_interval` or `iteration_interval`. The most commonly-used features that are affected are `JLD2OutputWriter`, `NetCDFOutputWriter`, and `Checkpointer`. `JLD2OutputWriter` and `NetCDFOutputWriter` no longer have the kwargs `time_averaging_window` and `time_averaging_stride`. The specific syntax changes are:. * `time_interval=T` becomes `schedule=TimeInterval(T)`; * `iteration_interval=I` becomes `schedule=IterationInterval(I)`; * `time_interval=T, time_averaging_window=W` becomes `schedule=AveragedTimeInterval(T, window=W)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1077
https://github.com/CliMA/Oceananigans.jl/pull/1077:327,Deployability,Release,Release,327,"In the spirit of getting closer to continuous delivery (see https://www.oxinabox.net/2019/09/28/Continuous-Delivery-For-Julia-Packages.html#what-if-i-dont-want-to-release-right-now--dev-versions) we should probably tag and release v0.43.0 soon since PRs #1070, #1057, and #1061 + couple of bug fix PRs would be useful to have. Release notes:. * Fixes a bug in `TwoDimensionalLeith` (PR #1073, issue #1034). Previously tests were being skipped due to extreme slowness. Now we run tests on GPU (but not CPU, where the closure is much slower to compile). * Rewrites the interface for ""scheduling"" output and diagnostics (PR #1070). Previously output and diagnostics were usually scheduled by specifying either `time_interval` or `iteration_interval` kwargs in the constrcutor for the object in question. Now, the relevant kwarg is called `schedule` and takes a callable `AbstractSchedule` object (or any user-defined function `func` that returns `true` or `false` depending on the single argument `func(model)`). This design is more flexible and extensible, and also simplifies underlying code. Four schedules are provided:. - `TimeInterval(interval)`; - `IterationInterval(interval)`; - `WallTimeInterval(interval)`; - `AveragedTimeInterval(interval; window=interval, stride=1)` (for time-averaging output). Breaking changes:. * Output writers and diagnostics no longer have the keyword arguments `time_interval` or `iteration_interval`. The most commonly-used features that are affected are `JLD2OutputWriter`, `NetCDFOutputWriter`, and `Checkpointer`. `JLD2OutputWriter` and `NetCDFOutputWriter` no longer have the kwargs `time_averaging_window` and `time_averaging_stride`. The specific syntax changes are:. * `time_interval=T` becomes `schedule=TimeInterval(T)`; * `iteration_interval=I` becomes `schedule=IterationInterval(I)`; * `time_interval=T, time_averaging_window=W` becomes `schedule=AveragedTimeInterval(T, window=W)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1077
https://github.com/CliMA/Oceananigans.jl/pull/1077:582,Energy Efficiency,schedul,scheduling,582,"In the spirit of getting closer to continuous delivery (see https://www.oxinabox.net/2019/09/28/Continuous-Delivery-For-Julia-Packages.html#what-if-i-dont-want-to-release-right-now--dev-versions) we should probably tag and release v0.43.0 soon since PRs #1070, #1057, and #1061 + couple of bug fix PRs would be useful to have. Release notes:. * Fixes a bug in `TwoDimensionalLeith` (PR #1073, issue #1034). Previously tests were being skipped due to extreme slowness. Now we run tests on GPU (but not CPU, where the closure is much slower to compile). * Rewrites the interface for ""scheduling"" output and diagnostics (PR #1070). Previously output and diagnostics were usually scheduled by specifying either `time_interval` or `iteration_interval` kwargs in the constrcutor for the object in question. Now, the relevant kwarg is called `schedule` and takes a callable `AbstractSchedule` object (or any user-defined function `func` that returns `true` or `false` depending on the single argument `func(model)`). This design is more flexible and extensible, and also simplifies underlying code. Four schedules are provided:. - `TimeInterval(interval)`; - `IterationInterval(interval)`; - `WallTimeInterval(interval)`; - `AveragedTimeInterval(interval; window=interval, stride=1)` (for time-averaging output). Breaking changes:. * Output writers and diagnostics no longer have the keyword arguments `time_interval` or `iteration_interval`. The most commonly-used features that are affected are `JLD2OutputWriter`, `NetCDFOutputWriter`, and `Checkpointer`. `JLD2OutputWriter` and `NetCDFOutputWriter` no longer have the kwargs `time_averaging_window` and `time_averaging_stride`. The specific syntax changes are:. * `time_interval=T` becomes `schedule=TimeInterval(T)`; * `iteration_interval=I` becomes `schedule=IterationInterval(I)`; * `time_interval=T, time_averaging_window=W` becomes `schedule=AveragedTimeInterval(T, window=W)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1077
https://github.com/CliMA/Oceananigans.jl/pull/1077:676,Energy Efficiency,schedul,scheduled,676,"In the spirit of getting closer to continuous delivery (see https://www.oxinabox.net/2019/09/28/Continuous-Delivery-For-Julia-Packages.html#what-if-i-dont-want-to-release-right-now--dev-versions) we should probably tag and release v0.43.0 soon since PRs #1070, #1057, and #1061 + couple of bug fix PRs would be useful to have. Release notes:. * Fixes a bug in `TwoDimensionalLeith` (PR #1073, issue #1034). Previously tests were being skipped due to extreme slowness. Now we run tests on GPU (but not CPU, where the closure is much slower to compile). * Rewrites the interface for ""scheduling"" output and diagnostics (PR #1070). Previously output and diagnostics were usually scheduled by specifying either `time_interval` or `iteration_interval` kwargs in the constrcutor for the object in question. Now, the relevant kwarg is called `schedule` and takes a callable `AbstractSchedule` object (or any user-defined function `func` that returns `true` or `false` depending on the single argument `func(model)`). This design is more flexible and extensible, and also simplifies underlying code. Four schedules are provided:. - `TimeInterval(interval)`; - `IterationInterval(interval)`; - `WallTimeInterval(interval)`; - `AveragedTimeInterval(interval; window=interval, stride=1)` (for time-averaging output). Breaking changes:. * Output writers and diagnostics no longer have the keyword arguments `time_interval` or `iteration_interval`. The most commonly-used features that are affected are `JLD2OutputWriter`, `NetCDFOutputWriter`, and `Checkpointer`. `JLD2OutputWriter` and `NetCDFOutputWriter` no longer have the kwargs `time_averaging_window` and `time_averaging_stride`. The specific syntax changes are:. * `time_interval=T` becomes `schedule=TimeInterval(T)`; * `iteration_interval=I` becomes `schedule=IterationInterval(I)`; * `time_interval=T, time_averaging_window=W` becomes `schedule=AveragedTimeInterval(T, window=W)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1077
https://github.com/CliMA/Oceananigans.jl/pull/1077:836,Energy Efficiency,schedul,schedule,836,"In the spirit of getting closer to continuous delivery (see https://www.oxinabox.net/2019/09/28/Continuous-Delivery-For-Julia-Packages.html#what-if-i-dont-want-to-release-right-now--dev-versions) we should probably tag and release v0.43.0 soon since PRs #1070, #1057, and #1061 + couple of bug fix PRs would be useful to have. Release notes:. * Fixes a bug in `TwoDimensionalLeith` (PR #1073, issue #1034). Previously tests were being skipped due to extreme slowness. Now we run tests on GPU (but not CPU, where the closure is much slower to compile). * Rewrites the interface for ""scheduling"" output and diagnostics (PR #1070). Previously output and diagnostics were usually scheduled by specifying either `time_interval` or `iteration_interval` kwargs in the constrcutor for the object in question. Now, the relevant kwarg is called `schedule` and takes a callable `AbstractSchedule` object (or any user-defined function `func` that returns `true` or `false` depending on the single argument `func(model)`). This design is more flexible and extensible, and also simplifies underlying code. Four schedules are provided:. - `TimeInterval(interval)`; - `IterationInterval(interval)`; - `WallTimeInterval(interval)`; - `AveragedTimeInterval(interval; window=interval, stride=1)` (for time-averaging output). Breaking changes:. * Output writers and diagnostics no longer have the keyword arguments `time_interval` or `iteration_interval`. The most commonly-used features that are affected are `JLD2OutputWriter`, `NetCDFOutputWriter`, and `Checkpointer`. `JLD2OutputWriter` and `NetCDFOutputWriter` no longer have the kwargs `time_averaging_window` and `time_averaging_stride`. The specific syntax changes are:. * `time_interval=T` becomes `schedule=TimeInterval(T)`; * `iteration_interval=I` becomes `schedule=IterationInterval(I)`; * `time_interval=T, time_averaging_window=W` becomes `schedule=AveragedTimeInterval(T, window=W)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1077
https://github.com/CliMA/Oceananigans.jl/pull/1077:1097,Energy Efficiency,schedul,schedules,1097,"In the spirit of getting closer to continuous delivery (see https://www.oxinabox.net/2019/09/28/Continuous-Delivery-For-Julia-Packages.html#what-if-i-dont-want-to-release-right-now--dev-versions) we should probably tag and release v0.43.0 soon since PRs #1070, #1057, and #1061 + couple of bug fix PRs would be useful to have. Release notes:. * Fixes a bug in `TwoDimensionalLeith` (PR #1073, issue #1034). Previously tests were being skipped due to extreme slowness. Now we run tests on GPU (but not CPU, where the closure is much slower to compile). * Rewrites the interface for ""scheduling"" output and diagnostics (PR #1070). Previously output and diagnostics were usually scheduled by specifying either `time_interval` or `iteration_interval` kwargs in the constrcutor for the object in question. Now, the relevant kwarg is called `schedule` and takes a callable `AbstractSchedule` object (or any user-defined function `func` that returns `true` or `false` depending on the single argument `func(model)`). This design is more flexible and extensible, and also simplifies underlying code. Four schedules are provided:. - `TimeInterval(interval)`; - `IterationInterval(interval)`; - `WallTimeInterval(interval)`; - `AveragedTimeInterval(interval; window=interval, stride=1)` (for time-averaging output). Breaking changes:. * Output writers and diagnostics no longer have the keyword arguments `time_interval` or `iteration_interval`. The most commonly-used features that are affected are `JLD2OutputWriter`, `NetCDFOutputWriter`, and `Checkpointer`. `JLD2OutputWriter` and `NetCDFOutputWriter` no longer have the kwargs `time_averaging_window` and `time_averaging_stride`. The specific syntax changes are:. * `time_interval=T` becomes `schedule=TimeInterval(T)`; * `iteration_interval=I` becomes `schedule=IterationInterval(I)`; * `time_interval=T, time_averaging_window=W` becomes `schedule=AveragedTimeInterval(T, window=W)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1077
https://github.com/CliMA/Oceananigans.jl/pull/1077:1738,Energy Efficiency,schedul,schedule,1738,"In the spirit of getting closer to continuous delivery (see https://www.oxinabox.net/2019/09/28/Continuous-Delivery-For-Julia-Packages.html#what-if-i-dont-want-to-release-right-now--dev-versions) we should probably tag and release v0.43.0 soon since PRs #1070, #1057, and #1061 + couple of bug fix PRs would be useful to have. Release notes:. * Fixes a bug in `TwoDimensionalLeith` (PR #1073, issue #1034). Previously tests were being skipped due to extreme slowness. Now we run tests on GPU (but not CPU, where the closure is much slower to compile). * Rewrites the interface for ""scheduling"" output and diagnostics (PR #1070). Previously output and diagnostics were usually scheduled by specifying either `time_interval` or `iteration_interval` kwargs in the constrcutor for the object in question. Now, the relevant kwarg is called `schedule` and takes a callable `AbstractSchedule` object (or any user-defined function `func` that returns `true` or `false` depending on the single argument `func(model)`). This design is more flexible and extensible, and also simplifies underlying code. Four schedules are provided:. - `TimeInterval(interval)`; - `IterationInterval(interval)`; - `WallTimeInterval(interval)`; - `AveragedTimeInterval(interval; window=interval, stride=1)` (for time-averaging output). Breaking changes:. * Output writers and diagnostics no longer have the keyword arguments `time_interval` or `iteration_interval`. The most commonly-used features that are affected are `JLD2OutputWriter`, `NetCDFOutputWriter`, and `Checkpointer`. `JLD2OutputWriter` and `NetCDFOutputWriter` no longer have the kwargs `time_averaging_window` and `time_averaging_stride`. The specific syntax changes are:. * `time_interval=T` becomes `schedule=TimeInterval(T)`; * `iteration_interval=I` becomes `schedule=IterationInterval(I)`; * `time_interval=T, time_averaging_window=W` becomes `schedule=AveragedTimeInterval(T, window=W)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1077
https://github.com/CliMA/Oceananigans.jl/pull/1077:1799,Energy Efficiency,schedul,schedule,1799,"In the spirit of getting closer to continuous delivery (see https://www.oxinabox.net/2019/09/28/Continuous-Delivery-For-Julia-Packages.html#what-if-i-dont-want-to-release-right-now--dev-versions) we should probably tag and release v0.43.0 soon since PRs #1070, #1057, and #1061 + couple of bug fix PRs would be useful to have. Release notes:. * Fixes a bug in `TwoDimensionalLeith` (PR #1073, issue #1034). Previously tests were being skipped due to extreme slowness. Now we run tests on GPU (but not CPU, where the closure is much slower to compile). * Rewrites the interface for ""scheduling"" output and diagnostics (PR #1070). Previously output and diagnostics were usually scheduled by specifying either `time_interval` or `iteration_interval` kwargs in the constrcutor for the object in question. Now, the relevant kwarg is called `schedule` and takes a callable `AbstractSchedule` object (or any user-defined function `func` that returns `true` or `false` depending on the single argument `func(model)`). This design is more flexible and extensible, and also simplifies underlying code. Four schedules are provided:. - `TimeInterval(interval)`; - `IterationInterval(interval)`; - `WallTimeInterval(interval)`; - `AveragedTimeInterval(interval; window=interval, stride=1)` (for time-averaging output). Breaking changes:. * Output writers and diagnostics no longer have the keyword arguments `time_interval` or `iteration_interval`. The most commonly-used features that are affected are `JLD2OutputWriter`, `NetCDFOutputWriter`, and `Checkpointer`. `JLD2OutputWriter` and `NetCDFOutputWriter` no longer have the kwargs `time_averaging_window` and `time_averaging_stride`. The specific syntax changes are:. * `time_interval=T` becomes `schedule=TimeInterval(T)`; * `iteration_interval=I` becomes `schedule=IterationInterval(I)`; * `time_interval=T, time_averaging_window=W` becomes `schedule=AveragedTimeInterval(T, window=W)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1077
https://github.com/CliMA/Oceananigans.jl/pull/1077:1885,Energy Efficiency,schedul,schedule,1885,"In the spirit of getting closer to continuous delivery (see https://www.oxinabox.net/2019/09/28/Continuous-Delivery-For-Julia-Packages.html#what-if-i-dont-want-to-release-right-now--dev-versions) we should probably tag and release v0.43.0 soon since PRs #1070, #1057, and #1061 + couple of bug fix PRs would be useful to have. Release notes:. * Fixes a bug in `TwoDimensionalLeith` (PR #1073, issue #1034). Previously tests were being skipped due to extreme slowness. Now we run tests on GPU (but not CPU, where the closure is much slower to compile). * Rewrites the interface for ""scheduling"" output and diagnostics (PR #1070). Previously output and diagnostics were usually scheduled by specifying either `time_interval` or `iteration_interval` kwargs in the constrcutor for the object in question. Now, the relevant kwarg is called `schedule` and takes a callable `AbstractSchedule` object (or any user-defined function `func` that returns `true` or `false` depending on the single argument `func(model)`). This design is more flexible and extensible, and also simplifies underlying code. Four schedules are provided:. - `TimeInterval(interval)`; - `IterationInterval(interval)`; - `WallTimeInterval(interval)`; - `AveragedTimeInterval(interval; window=interval, stride=1)` (for time-averaging output). Breaking changes:. * Output writers and diagnostics no longer have the keyword arguments `time_interval` or `iteration_interval`. The most commonly-used features that are affected are `JLD2OutputWriter`, `NetCDFOutputWriter`, and `Checkpointer`. `JLD2OutputWriter` and `NetCDFOutputWriter` no longer have the kwargs `time_averaging_window` and `time_averaging_stride`. The specific syntax changes are:. * `time_interval=T` becomes `schedule=TimeInterval(T)`; * `iteration_interval=I` becomes `schedule=IterationInterval(I)`; * `time_interval=T, time_averaging_window=W` becomes `schedule=AveragedTimeInterval(T, window=W)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1077
https://github.com/CliMA/Oceananigans.jl/pull/1077:567,Integrability,interface,interface,567,"In the spirit of getting closer to continuous delivery (see https://www.oxinabox.net/2019/09/28/Continuous-Delivery-For-Julia-Packages.html#what-if-i-dont-want-to-release-right-now--dev-versions) we should probably tag and release v0.43.0 soon since PRs #1070, #1057, and #1061 + couple of bug fix PRs would be useful to have. Release notes:. * Fixes a bug in `TwoDimensionalLeith` (PR #1073, issue #1034). Previously tests were being skipped due to extreme slowness. Now we run tests on GPU (but not CPU, where the closure is much slower to compile). * Rewrites the interface for ""scheduling"" output and diagnostics (PR #1070). Previously output and diagnostics were usually scheduled by specifying either `time_interval` or `iteration_interval` kwargs in the constrcutor for the object in question. Now, the relevant kwarg is called `schedule` and takes a callable `AbstractSchedule` object (or any user-defined function `func` that returns `true` or `false` depending on the single argument `func(model)`). This design is more flexible and extensible, and also simplifies underlying code. Four schedules are provided:. - `TimeInterval(interval)`; - `IterationInterval(interval)`; - `WallTimeInterval(interval)`; - `AveragedTimeInterval(interval; window=interval, stride=1)` (for time-averaging output). Breaking changes:. * Output writers and diagnostics no longer have the keyword arguments `time_interval` or `iteration_interval`. The most commonly-used features that are affected are `JLD2OutputWriter`, `NetCDFOutputWriter`, and `Checkpointer`. `JLD2OutputWriter` and `NetCDFOutputWriter` no longer have the kwargs `time_averaging_window` and `time_averaging_stride`. The specific syntax changes are:. * `time_interval=T` becomes `schedule=TimeInterval(T)`; * `iteration_interval=I` becomes `schedule=IterationInterval(I)`; * `time_interval=T, time_averaging_window=W` becomes `schedule=AveragedTimeInterval(T, window=W)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1077
https://github.com/CliMA/Oceananigans.jl/pull/1077:961,Integrability,depend,depending,961,"In the spirit of getting closer to continuous delivery (see https://www.oxinabox.net/2019/09/28/Continuous-Delivery-For-Julia-Packages.html#what-if-i-dont-want-to-release-right-now--dev-versions) we should probably tag and release v0.43.0 soon since PRs #1070, #1057, and #1061 + couple of bug fix PRs would be useful to have. Release notes:. * Fixes a bug in `TwoDimensionalLeith` (PR #1073, issue #1034). Previously tests were being skipped due to extreme slowness. Now we run tests on GPU (but not CPU, where the closure is much slower to compile). * Rewrites the interface for ""scheduling"" output and diagnostics (PR #1070). Previously output and diagnostics were usually scheduled by specifying either `time_interval` or `iteration_interval` kwargs in the constrcutor for the object in question. Now, the relevant kwarg is called `schedule` and takes a callable `AbstractSchedule` object (or any user-defined function `func` that returns `true` or `false` depending on the single argument `func(model)`). This design is more flexible and extensible, and also simplifies underlying code. Four schedules are provided:. - `TimeInterval(interval)`; - `IterationInterval(interval)`; - `WallTimeInterval(interval)`; - `AveragedTimeInterval(interval; window=interval, stride=1)` (for time-averaging output). Breaking changes:. * Output writers and diagnostics no longer have the keyword arguments `time_interval` or `iteration_interval`. The most commonly-used features that are affected are `JLD2OutputWriter`, `NetCDFOutputWriter`, and `Checkpointer`. `JLD2OutputWriter` and `NetCDFOutputWriter` no longer have the kwargs `time_averaging_window` and `time_averaging_stride`. The specific syntax changes are:. * `time_interval=T` becomes `schedule=TimeInterval(T)`; * `iteration_interval=I` becomes `schedule=IterationInterval(I)`; * `time_interval=T, time_averaging_window=W` becomes `schedule=AveragedTimeInterval(T, window=W)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1077
https://github.com/CliMA/Oceananigans.jl/pull/1077:554,Modifiability,Rewrite,Rewrites,554,"In the spirit of getting closer to continuous delivery (see https://www.oxinabox.net/2019/09/28/Continuous-Delivery-For-Julia-Packages.html#what-if-i-dont-want-to-release-right-now--dev-versions) we should probably tag and release v0.43.0 soon since PRs #1070, #1057, and #1061 + couple of bug fix PRs would be useful to have. Release notes:. * Fixes a bug in `TwoDimensionalLeith` (PR #1073, issue #1034). Previously tests were being skipped due to extreme slowness. Now we run tests on GPU (but not CPU, where the closure is much slower to compile). * Rewrites the interface for ""scheduling"" output and diagnostics (PR #1070). Previously output and diagnostics were usually scheduled by specifying either `time_interval` or `iteration_interval` kwargs in the constrcutor for the object in question. Now, the relevant kwarg is called `schedule` and takes a callable `AbstractSchedule` object (or any user-defined function `func` that returns `true` or `false` depending on the single argument `func(model)`). This design is more flexible and extensible, and also simplifies underlying code. Four schedules are provided:. - `TimeInterval(interval)`; - `IterationInterval(interval)`; - `WallTimeInterval(interval)`; - `AveragedTimeInterval(interval; window=interval, stride=1)` (for time-averaging output). Breaking changes:. * Output writers and diagnostics no longer have the keyword arguments `time_interval` or `iteration_interval`. The most commonly-used features that are affected are `JLD2OutputWriter`, `NetCDFOutputWriter`, and `Checkpointer`. `JLD2OutputWriter` and `NetCDFOutputWriter` no longer have the kwargs `time_averaging_window` and `time_averaging_stride`. The specific syntax changes are:. * `time_interval=T` becomes `schedule=TimeInterval(T)`; * `iteration_interval=I` becomes `schedule=IterationInterval(I)`; * `time_interval=T, time_averaging_window=W` becomes `schedule=AveragedTimeInterval(T, window=W)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1077
https://github.com/CliMA/Oceananigans.jl/pull/1077:1030,Modifiability,flexible,flexible,1030,"In the spirit of getting closer to continuous delivery (see https://www.oxinabox.net/2019/09/28/Continuous-Delivery-For-Julia-Packages.html#what-if-i-dont-want-to-release-right-now--dev-versions) we should probably tag and release v0.43.0 soon since PRs #1070, #1057, and #1061 + couple of bug fix PRs would be useful to have. Release notes:. * Fixes a bug in `TwoDimensionalLeith` (PR #1073, issue #1034). Previously tests were being skipped due to extreme slowness. Now we run tests on GPU (but not CPU, where the closure is much slower to compile). * Rewrites the interface for ""scheduling"" output and diagnostics (PR #1070). Previously output and diagnostics were usually scheduled by specifying either `time_interval` or `iteration_interval` kwargs in the constrcutor for the object in question. Now, the relevant kwarg is called `schedule` and takes a callable `AbstractSchedule` object (or any user-defined function `func` that returns `true` or `false` depending on the single argument `func(model)`). This design is more flexible and extensible, and also simplifies underlying code. Four schedules are provided:. - `TimeInterval(interval)`; - `IterationInterval(interval)`; - `WallTimeInterval(interval)`; - `AveragedTimeInterval(interval; window=interval, stride=1)` (for time-averaging output). Breaking changes:. * Output writers and diagnostics no longer have the keyword arguments `time_interval` or `iteration_interval`. The most commonly-used features that are affected are `JLD2OutputWriter`, `NetCDFOutputWriter`, and `Checkpointer`. `JLD2OutputWriter` and `NetCDFOutputWriter` no longer have the kwargs `time_averaging_window` and `time_averaging_stride`. The specific syntax changes are:. * `time_interval=T` becomes `schedule=TimeInterval(T)`; * `iteration_interval=I` becomes `schedule=IterationInterval(I)`; * `time_interval=T, time_averaging_window=W` becomes `schedule=AveragedTimeInterval(T, window=W)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1077
https://github.com/CliMA/Oceananigans.jl/pull/1077:418,Testability,test,tests,418,"In the spirit of getting closer to continuous delivery (see https://www.oxinabox.net/2019/09/28/Continuous-Delivery-For-Julia-Packages.html#what-if-i-dont-want-to-release-right-now--dev-versions) we should probably tag and release v0.43.0 soon since PRs #1070, #1057, and #1061 + couple of bug fix PRs would be useful to have. Release notes:. * Fixes a bug in `TwoDimensionalLeith` (PR #1073, issue #1034). Previously tests were being skipped due to extreme slowness. Now we run tests on GPU (but not CPU, where the closure is much slower to compile). * Rewrites the interface for ""scheduling"" output and diagnostics (PR #1070). Previously output and diagnostics were usually scheduled by specifying either `time_interval` or `iteration_interval` kwargs in the constrcutor for the object in question. Now, the relevant kwarg is called `schedule` and takes a callable `AbstractSchedule` object (or any user-defined function `func` that returns `true` or `false` depending on the single argument `func(model)`). This design is more flexible and extensible, and also simplifies underlying code. Four schedules are provided:. - `TimeInterval(interval)`; - `IterationInterval(interval)`; - `WallTimeInterval(interval)`; - `AveragedTimeInterval(interval; window=interval, stride=1)` (for time-averaging output). Breaking changes:. * Output writers and diagnostics no longer have the keyword arguments `time_interval` or `iteration_interval`. The most commonly-used features that are affected are `JLD2OutputWriter`, `NetCDFOutputWriter`, and `Checkpointer`. `JLD2OutputWriter` and `NetCDFOutputWriter` no longer have the kwargs `time_averaging_window` and `time_averaging_stride`. The specific syntax changes are:. * `time_interval=T` becomes `schedule=TimeInterval(T)`; * `iteration_interval=I` becomes `schedule=IterationInterval(I)`; * `time_interval=T, time_averaging_window=W` becomes `schedule=AveragedTimeInterval(T, window=W)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1077
https://github.com/CliMA/Oceananigans.jl/pull/1077:479,Testability,test,tests,479,"In the spirit of getting closer to continuous delivery (see https://www.oxinabox.net/2019/09/28/Continuous-Delivery-For-Julia-Packages.html#what-if-i-dont-want-to-release-right-now--dev-versions) we should probably tag and release v0.43.0 soon since PRs #1070, #1057, and #1061 + couple of bug fix PRs would be useful to have. Release notes:. * Fixes a bug in `TwoDimensionalLeith` (PR #1073, issue #1034). Previously tests were being skipped due to extreme slowness. Now we run tests on GPU (but not CPU, where the closure is much slower to compile). * Rewrites the interface for ""scheduling"" output and diagnostics (PR #1070). Previously output and diagnostics were usually scheduled by specifying either `time_interval` or `iteration_interval` kwargs in the constrcutor for the object in question. Now, the relevant kwarg is called `schedule` and takes a callable `AbstractSchedule` object (or any user-defined function `func` that returns `true` or `false` depending on the single argument `func(model)`). This design is more flexible and extensible, and also simplifies underlying code. Four schedules are provided:. - `TimeInterval(interval)`; - `IterationInterval(interval)`; - `WallTimeInterval(interval)`; - `AveragedTimeInterval(interval; window=interval, stride=1)` (for time-averaging output). Breaking changes:. * Output writers and diagnostics no longer have the keyword arguments `time_interval` or `iteration_interval`. The most commonly-used features that are affected are `JLD2OutputWriter`, `NetCDFOutputWriter`, and `Checkpointer`. `JLD2OutputWriter` and `NetCDFOutputWriter` no longer have the kwargs `time_averaging_window` and `time_averaging_stride`. The specific syntax changes are:. * `time_interval=T` becomes `schedule=TimeInterval(T)`; * `iteration_interval=I` becomes `schedule=IterationInterval(I)`; * `time_interval=T, time_averaging_window=W` becomes `schedule=AveragedTimeInterval(T, window=W)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1077
https://github.com/CliMA/Oceananigans.jl/pull/1077:1064,Usability,simpl,simplifies,1064,"In the spirit of getting closer to continuous delivery (see https://www.oxinabox.net/2019/09/28/Continuous-Delivery-For-Julia-Packages.html#what-if-i-dont-want-to-release-right-now--dev-versions) we should probably tag and release v0.43.0 soon since PRs #1070, #1057, and #1061 + couple of bug fix PRs would be useful to have. Release notes:. * Fixes a bug in `TwoDimensionalLeith` (PR #1073, issue #1034). Previously tests were being skipped due to extreme slowness. Now we run tests on GPU (but not CPU, where the closure is much slower to compile). * Rewrites the interface for ""scheduling"" output and diagnostics (PR #1070). Previously output and diagnostics were usually scheduled by specifying either `time_interval` or `iteration_interval` kwargs in the constrcutor for the object in question. Now, the relevant kwarg is called `schedule` and takes a callable `AbstractSchedule` object (or any user-defined function `func` that returns `true` or `false` depending on the single argument `func(model)`). This design is more flexible and extensible, and also simplifies underlying code. Four schedules are provided:. - `TimeInterval(interval)`; - `IterationInterval(interval)`; - `WallTimeInterval(interval)`; - `AveragedTimeInterval(interval; window=interval, stride=1)` (for time-averaging output). Breaking changes:. * Output writers and diagnostics no longer have the keyword arguments `time_interval` or `iteration_interval`. The most commonly-used features that are affected are `JLD2OutputWriter`, `NetCDFOutputWriter`, and `Checkpointer`. `JLD2OutputWriter` and `NetCDFOutputWriter` no longer have the kwargs `time_averaging_window` and `time_averaging_stride`. The specific syntax changes are:. * `time_interval=T` becomes `schedule=TimeInterval(T)`; * `iteration_interval=I` becomes `schedule=IterationInterval(I)`; * `time_interval=T, time_averaging_window=W` becomes `schedule=AveragedTimeInterval(T, window=W)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1077
https://github.com/CliMA/Oceananigans.jl/pull/1079:723,Availability,avail,available,723,"This PR adds a GPU-enabled `CompressibleModel`, developed with @thabbott and @RaphaelRR in a separate repository (https://github.com/ali-ramadhan/Atmosfoolery.jl). This is a large PR and I'm not even sure if it makes sense to merge it into Oceananigans.jl. The main purpose of opening this PR is to document progress made and ultimately decide on what to do with this feature. I don't think I can continue working on it. # Description. The compressible model implements the conservative Scheme by Satoh (2003), suitable for compressible non-hydrostatic models with moist processes, and is valid in the limit of a condensable gas/atmosphere with multiple moist species. Two choices of prognostic thermodynamic variables are available, internal energy and entropy, although in the Oceananigans spirit adding new thermodynamic variables is pretty easy!. @thabbott implemented the Satoh (2003) equation set. I initially implemented the Klemp et al. (2007) equation set which is only valid in the limit of a dry atmosphere with trace amounts of moist species. An RK3 time-stepper is used that is apparently 3rd-order accurate for linear terms but only 2nd-order accurate for non-linear terms. This is because it's developed to allow for acoustic time stepping between RK stages. This split-explicit time-stepping scheme is described by Wicker & Skamarock (2002), Klemp et al. (2007), and Satoh (2003). It's essentially the same one used by the NCAR WRF model (Skamarock et al., 2019). No acoustic time stepper is implemented yet. Explicit acoustic time stepping could make sense for regular Cartesian grids while a vertically implicit acoustic time stepper would make sense for vertically stretched grids (possible with `Oceananigans.Solver.BatchedTridiagonalSolver`). Building the compressible model on top of Oceananigans.jl has allowed it to run on GPUs and make use of the same operators, grids, Coriolis terms, forcing function and boundary conditions, diagnostics, output writers, higher-order advect",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:2783,Availability,down,down,2783,"`Oceananigans.Solver.BatchedTridiagonalSolver`). Building the compressible model on top of Oceananigans.jl has allowed it to run on GPUs and make use of the same operators, grids, Coriolis terms, forcing function and boundary conditions, diagnostics, output writers, higher-order advection schemes, and user-interface niceties. Turbulent diffusivity closures may take more work to integrate and not all of them can be shared as the stress tensor is not traceless when the fluid is compressible (see #654 for more discussion). # Reasons why we may consider adding a compressible model to the Oceananigans.jl ecosystem. 1. I see Oceananigans.jl as a general-purpose package for fluid dynamics even though we mostly apply it to ocean problems. With both incompressible and compressible models, Oceananigans.jl would appeal to a larger audience and may be used to investigate a greater range of problems.; 2. One potential use of the `CompressibleModel` is to simulate a compressible ocean (with pressure as a prognostic variable) in which sound waves artificially slowed down for practical purposes. There were some discussions around this idea and @johncmarshall54 might still be interested.; 3. With PR #590, Oceananigans.jl will support distributed parallelism via MPI. While incompressible models (and anelastic models) don't scale that well to many nodes due to the need to solve an elliptic Poission equation globally across all ranks, a compressible model is completely local and might easily scale well on many GPUs. So even if the scalability of incompressible models on many GPUs is dissapointing, we may get a very scalable compressible model almost for free. Actually, the efficiency of the Oceananigans MPI algorithm might be best tested using a compressible model.; 4. Since distributed FFTs aren't generally available on GPUs (CuFFT only goes up to 16 GPUs), CUDA-aware MPI for incompressible models might take some time and effort to support once PR #590 is merged. However, CUDA-aware M",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:3535,Availability,avail,available,3535,"ter range of problems.; 2. One potential use of the `CompressibleModel` is to simulate a compressible ocean (with pressure as a prognostic variable) in which sound waves artificially slowed down for practical purposes. There were some discussions around this idea and @johncmarshall54 might still be interested.; 3. With PR #590, Oceananigans.jl will support distributed parallelism via MPI. While incompressible models (and anelastic models) don't scale that well to many nodes due to the need to solve an elliptic Poission equation globally across all ranks, a compressible model is completely local and might easily scale well on many GPUs. So even if the scalability of incompressible models on many GPUs is dissapointing, we may get a very scalable compressible model almost for free. Actually, the efficiency of the Oceananigans MPI algorithm might be best tested using a compressible model.; 4. Since distributed FFTs aren't generally available on GPUs (CuFFT only goes up to 16 GPUs), CUDA-aware MPI for incompressible models might take some time and effort to support once PR #590 is merged. However, CUDA-aware MPI should work out of the box for compressible models as there are no FFTs to worry about.; 5. Due to the need for a fast pressure solver for incompressible models, we are not considering more general grids beyond the vertically stretched Cartesian grid. The compressible model does not have this limitation and can easily make use of a more general Cartesian grid (stretching in all dimensions).; 6. The incompressible model is limited to a certain number of topologies, particularly on the GPU, due to the pressure solver. A compressible model would work with all possible topologies out of the box.; 7. Since `CompressibleModel` and `IncompressibleModel` share so much common infrastructure they also share a common user interface by construction which makes it easy to switch between the two. I think this is a valueble feature. Most existing packages do not have compressibl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:2096,Deployability,integrat,integrate,2096," only 2nd-order accurate for non-linear terms. This is because it's developed to allow for acoustic time stepping between RK stages. This split-explicit time-stepping scheme is described by Wicker & Skamarock (2002), Klemp et al. (2007), and Satoh (2003). It's essentially the same one used by the NCAR WRF model (Skamarock et al., 2019). No acoustic time stepper is implemented yet. Explicit acoustic time stepping could make sense for regular Cartesian grids while a vertically implicit acoustic time stepper would make sense for vertically stretched grids (possible with `Oceananigans.Solver.BatchedTridiagonalSolver`). Building the compressible model on top of Oceananigans.jl has allowed it to run on GPUs and make use of the same operators, grids, Coriolis terms, forcing function and boundary conditions, diagnostics, output writers, higher-order advection schemes, and user-interface niceties. Turbulent diffusivity closures may take more work to integrate and not all of them can be shared as the stress tensor is not traceless when the fluid is compressible (see #654 for more discussion). # Reasons why we may consider adding a compressible model to the Oceananigans.jl ecosystem. 1. I see Oceananigans.jl as a general-purpose package for fluid dynamics even though we mostly apply it to ocean problems. With both incompressible and compressible models, Oceananigans.jl would appeal to a larger audience and may be used to investigate a greater range of problems.; 2. One potential use of the `CompressibleModel` is to simulate a compressible ocean (with pressure as a prognostic variable) in which sound waves artificially slowed down for practical purposes. There were some discussions around this idea and @johncmarshall54 might still be interested.; 3. With PR #590, Oceananigans.jl will support distributed parallelism via MPI. While incompressible models (and anelastic models) don't scale that well to many nodes due to the need to solve an elliptic Poission equation globally acros",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:743,Energy Efficiency,energy,energy,743,"This PR adds a GPU-enabled `CompressibleModel`, developed with @thabbott and @RaphaelRR in a separate repository (https://github.com/ali-ramadhan/Atmosfoolery.jl). This is a large PR and I'm not even sure if it makes sense to merge it into Oceananigans.jl. The main purpose of opening this PR is to document progress made and ultimately decide on what to do with this feature. I don't think I can continue working on it. # Description. The compressible model implements the conservative Scheme by Satoh (2003), suitable for compressible non-hydrostatic models with moist processes, and is valid in the limit of a condensable gas/atmosphere with multiple moist species. Two choices of prognostic thermodynamic variables are available, internal energy and entropy, although in the Oceananigans spirit adding new thermodynamic variables is pretty easy!. @thabbott implemented the Satoh (2003) equation set. I initially implemented the Klemp et al. (2007) equation set which is only valid in the limit of a dry atmosphere with trace amounts of moist species. An RK3 time-stepper is used that is apparently 3rd-order accurate for linear terms but only 2nd-order accurate for non-linear terms. This is because it's developed to allow for acoustic time stepping between RK stages. This split-explicit time-stepping scheme is described by Wicker & Skamarock (2002), Klemp et al. (2007), and Satoh (2003). It's essentially the same one used by the NCAR WRF model (Skamarock et al., 2019). No acoustic time stepper is implemented yet. Explicit acoustic time stepping could make sense for regular Cartesian grids while a vertically implicit acoustic time stepper would make sense for vertically stretched grids (possible with `Oceananigans.Solver.BatchedTridiagonalSolver`). Building the compressible model on top of Oceananigans.jl has allowed it to run on GPUs and make use of the same operators, grids, Coriolis terms, forcing function and boundary conditions, diagnostics, output writers, higher-order advect",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:6982,Energy Efficiency,energy,energy,6982,"h. For example, Oceananigans.jl could provide the `CompressibleModel` and `IncompressibleModel` but ocean-specific modules could live in separate packages. We did this with SeawaterPolynomials.jl and could probably do it with other modules to further limit scope if we decide to pursue this approach. So this is still a multiple packages approach but for ancillary features. # Tests and validation experiments. We spent quite some time ensuring the `CompressibleModel` can simulate some known atmospheric test cases. Following recent trials and tribulations I also decided to add some simple 1D tests. Here I list the tests but will post a followup comment for each test with a figure or animation. Hopefully together these tests act as a starting point to start believing that the `CompressibleModel` indeed does work as expected. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large models when comparing a single CPU core to a single Titan V GPU on Tartarus. Not as good as the incompressible model as some of the functions that diagnose temperature and pressure need some optimizing, especially in the case of multiple gases. ```; Compressible model benchmarks ; ┌──────┬──────┬───────────┬───────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Arch │ Size │ Gases │ ThermoVar │ min │ median │ mean │ max │ memory │ allocs │; ├──────┼──────┼───────────┼───────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ 32³ │ DryE",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:7084,Energy Efficiency,energy,energy,7084,"compressibleModel` but ocean-specific modules could live in separate packages. We did this with SeawaterPolynomials.jl and could probably do it with other modules to further limit scope if we decide to pursue this approach. So this is still a multiple packages approach but for ancillary features. # Tests and validation experiments. We spent quite some time ensuring the `CompressibleModel` can simulate some known atmospheric test cases. Following recent trials and tribulations I also decided to add some simple 1D tests. Here I list the tests but will post a followup comment for each test with a figure or animation. Hopefully together these tests act as a starting point to start believing that the `CompressibleModel` indeed does work as expected. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large models when comparing a single CPU core to a single Titan V GPU on Tartarus. Not as good as the incompressible model as some of the functions that diagnose temperature and pressure need some optimizing, especially in the case of multiple gases. ```; Compressible model benchmarks ; ┌──────┬──────┬───────────┬───────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Arch │ Size │ Gases │ ThermoVar │ min │ median │ mean │ max │ memory │ allocs │; ├──────┼──────┼───────────┼───────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ 32³ │ DryEarth │ Energy │ 37.682 ms │ 38.012 ms │ 37.982 ms │ 38.199 ms │ 646.33 KiB │",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:7988,Energy Efficiency,Energy,Energy,7988,"cted. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large models when comparing a single CPU core to a single Titan V GPU on Tartarus. Not as good as the incompressible model as some of the functions that diagnose temperature and pressure need some optimizing, especially in the case of multiple gases. ```; Compressible model benchmarks ; ┌──────┬──────┬───────────┬───────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Arch │ Size │ Gases │ ThermoVar │ min │ median │ mean │ max │ memory │ allocs │; ├──────┼──────┼───────────┼───────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ 32³ │ DryEarth │ Energy │ 37.682 ms │ 38.012 ms │ 37.982 ms │ 38.199 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth │ Entropy │ 32.325 ms │ 32.920 ms │ 32.928 ms │ 33.628 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth3 │ Energy │ 52.473 ms │ 52.815 ms │ 52.896 ms │ 53.413 ms │ 816.50 KiB │ 5635 │; │ CPU │ 32³ │ DryEarth3 │ Entropy │ 69.928 ms │ 70.388 ms │ 70.402 ms │ 71.224 ms │ 816.50 KiB │ 5635 │; │ CPU │ 192³ │ DryEarth │ Energy │ 7.438 s │ 7.438 s │ 7.438 s │ 7.438 s │ 646.33 KiB │ 4499 │; │ CPU │ 192³ │ DryEarth │ Entropy │ 6.501 s │ 6.501 s │ 6.501 s │ 6.501 s │ 646.58 KiB │ 4512 │; │ CPU │ 192³ │ DryEarth3 │ Energy │ 11.265 s │ 11.265 s │ 11.265 s │ 11.265 s │ 816.75 KiB │ 5648 │; │ CPU │ 192³ │ DryEarth3 │ Entropy │ 15.038 s │ 15.038 s │ 15.038 s │ 15.038 s │ 816.50 KiB │ 5635 │; │ GPU │ 32³ │ DryEarth │ Energy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:8196,Energy Efficiency,Energy,Energy,8196,"ies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large models when comparing a single CPU core to a single Titan V GPU on Tartarus. Not as good as the incompressible model as some of the functions that diagnose temperature and pressure need some optimizing, especially in the case of multiple gases. ```; Compressible model benchmarks ; ┌──────┬──────┬───────────┬───────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Arch │ Size │ Gases │ ThermoVar │ min │ median │ mean │ max │ memory │ allocs │; ├──────┼──────┼───────────┼───────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ 32³ │ DryEarth │ Energy │ 37.682 ms │ 38.012 ms │ 37.982 ms │ 38.199 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth │ Entropy │ 32.325 ms │ 32.920 ms │ 32.928 ms │ 33.628 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth3 │ Energy │ 52.473 ms │ 52.815 ms │ 52.896 ms │ 53.413 ms │ 816.50 KiB │ 5635 │; │ CPU │ 32³ │ DryEarth3 │ Entropy │ 69.928 ms │ 70.388 ms │ 70.402 ms │ 71.224 ms │ 816.50 KiB │ 5635 │; │ CPU │ 192³ │ DryEarth │ Energy │ 7.438 s │ 7.438 s │ 7.438 s │ 7.438 s │ 646.33 KiB │ 4499 │; │ CPU │ 192³ │ DryEarth │ Entropy │ 6.501 s │ 6.501 s │ 6.501 s │ 6.501 s │ 646.58 KiB │ 4512 │; │ CPU │ 192³ │ DryEarth3 │ Energy │ 11.265 s │ 11.265 s │ 11.265 s │ 11.265 s │ 816.75 KiB │ 5648 │; │ CPU │ 192³ │ DryEarth3 │ Entropy │ 15.038 s │ 15.038 s │ 15.038 s │ 15.038 s │ 816.50 KiB │ 5635 │; │ GPU │ 32³ │ DryEarth │ Energy │ 8.328 ms │ 8.513 ms │ 8.608 ms │ 9.676 ms │ 2.00 MiB │ 30129 │; │ GPU │ 32³ │ DryEarth │ Entropy │ 7.863 ms │ 8.500 ms │ 8.529 ms │ 9.515 ms │ 2.00 MiB │ 30129 │; │ GPU │ 32³ │ DryEarth3 │ Energy │ 10.133 ms │ 10.754 ms │ 10.751 ms │ 11.281 ms │ 2.54 MiB │ 37805 │; │ GPU │ 32³ │ DryEarth3 │ Entropy │ 9.992 ms │ 10.572 ms │ 10.542 ms │ 10.836 ms │ 2.54 MiB │ 37839 │; │ G",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:8405,Energy Efficiency,Energy,Energy,8405," a single CPU core to a single Titan V GPU on Tartarus. Not as good as the incompressible model as some of the functions that diagnose temperature and pressure need some optimizing, especially in the case of multiple gases. ```; Compressible model benchmarks ; ┌──────┬──────┬───────────┬───────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Arch │ Size │ Gases │ ThermoVar │ min │ median │ mean │ max │ memory │ allocs │; ├──────┼──────┼───────────┼───────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ 32³ │ DryEarth │ Energy │ 37.682 ms │ 38.012 ms │ 37.982 ms │ 38.199 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth │ Entropy │ 32.325 ms │ 32.920 ms │ 32.928 ms │ 33.628 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth3 │ Energy │ 52.473 ms │ 52.815 ms │ 52.896 ms │ 53.413 ms │ 816.50 KiB │ 5635 │; │ CPU │ 32³ │ DryEarth3 │ Entropy │ 69.928 ms │ 70.388 ms │ 70.402 ms │ 71.224 ms │ 816.50 KiB │ 5635 │; │ CPU │ 192³ │ DryEarth │ Energy │ 7.438 s │ 7.438 s │ 7.438 s │ 7.438 s │ 646.33 KiB │ 4499 │; │ CPU │ 192³ │ DryEarth │ Entropy │ 6.501 s │ 6.501 s │ 6.501 s │ 6.501 s │ 646.58 KiB │ 4512 │; │ CPU │ 192³ │ DryEarth3 │ Energy │ 11.265 s │ 11.265 s │ 11.265 s │ 11.265 s │ 816.75 KiB │ 5648 │; │ CPU │ 192³ │ DryEarth3 │ Entropy │ 15.038 s │ 15.038 s │ 15.038 s │ 15.038 s │ 816.50 KiB │ 5635 │; │ GPU │ 32³ │ DryEarth │ Energy │ 8.328 ms │ 8.513 ms │ 8.608 ms │ 9.676 ms │ 2.00 MiB │ 30129 │; │ GPU │ 32³ │ DryEarth │ Entropy │ 7.863 ms │ 8.500 ms │ 8.529 ms │ 9.515 ms │ 2.00 MiB │ 30129 │; │ GPU │ 32³ │ DryEarth3 │ Energy │ 10.133 ms │ 10.754 ms │ 10.751 ms │ 11.281 ms │ 2.54 MiB │ 37805 │; │ GPU │ 32³ │ DryEarth3 │ Entropy │ 9.992 ms │ 10.572 ms │ 10.542 ms │ 10.836 ms │ 2.54 MiB │ 37839 │; │ GPU │ 192³ │ DryEarth │ Energy │ 101.341 ms │ 101.612 ms │ 101.589 ms │ 101.709 ms │ 2.01 MiB │ 30270 │; │ GPU │ 192³ │ DryEarth │ Entropy │ 86.051 ms │ 86.195 ms │ 86.226 ms │ 86.710 ms │ 2.01 MiB │ 30270 │; ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:8599,Energy Efficiency,Energy,Energy,8599,n the case of multiple gases. ```; Compressible model benchmarks ; ┌──────┬──────┬───────────┬───────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Arch │ Size │ Gases │ ThermoVar │ min │ median │ mean │ max │ memory │ allocs │; ├──────┼──────┼───────────┼───────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ 32³ │ DryEarth │ Energy │ 37.682 ms │ 38.012 ms │ 37.982 ms │ 38.199 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth │ Entropy │ 32.325 ms │ 32.920 ms │ 32.928 ms │ 33.628 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth3 │ Energy │ 52.473 ms │ 52.815 ms │ 52.896 ms │ 53.413 ms │ 816.50 KiB │ 5635 │; │ CPU │ 32³ │ DryEarth3 │ Entropy │ 69.928 ms │ 70.388 ms │ 70.402 ms │ 71.224 ms │ 816.50 KiB │ 5635 │; │ CPU │ 192³ │ DryEarth │ Energy │ 7.438 s │ 7.438 s │ 7.438 s │ 7.438 s │ 646.33 KiB │ 4499 │; │ CPU │ 192³ │ DryEarth │ Entropy │ 6.501 s │ 6.501 s │ 6.501 s │ 6.501 s │ 646.58 KiB │ 4512 │; │ CPU │ 192³ │ DryEarth3 │ Energy │ 11.265 s │ 11.265 s │ 11.265 s │ 11.265 s │ 816.75 KiB │ 5648 │; │ CPU │ 192³ │ DryEarth3 │ Entropy │ 15.038 s │ 15.038 s │ 15.038 s │ 15.038 s │ 816.50 KiB │ 5635 │; │ GPU │ 32³ │ DryEarth │ Energy │ 8.328 ms │ 8.513 ms │ 8.608 ms │ 9.676 ms │ 2.00 MiB │ 30129 │; │ GPU │ 32³ │ DryEarth │ Entropy │ 7.863 ms │ 8.500 ms │ 8.529 ms │ 9.515 ms │ 2.00 MiB │ 30129 │; │ GPU │ 32³ │ DryEarth3 │ Energy │ 10.133 ms │ 10.754 ms │ 10.751 ms │ 11.281 ms │ 2.54 MiB │ 37805 │; │ GPU │ 32³ │ DryEarth3 │ Entropy │ 9.992 ms │ 10.572 ms │ 10.542 ms │ 10.836 ms │ 2.54 MiB │ 37839 │; │ GPU │ 192³ │ DryEarth │ Energy │ 101.341 ms │ 101.612 ms │ 101.589 ms │ 101.709 ms │ 2.01 MiB │ 30270 │; │ GPU │ 192³ │ DryEarth │ Entropy │ 86.051 ms │ 86.195 ms │ 86.226 ms │ 86.710 ms │ 2.01 MiB │ 30270 │; │ GPU │ 192³ │ DryEarth3 │ Energy │ 139.732 ms │ 140.009 ms │ 139.957 ms │ 140.079 ms │ 2.54 MiB │ 37983 │; │ GPU │ 192³ │ DryEarth3 │ Entropy │ 375.725 ms │ 376.142 ms │ 376.123 ms │ 376.399 ms,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:8800,Energy Efficiency,Energy,Energy,8800,es │ ThermoVar │ min │ median │ mean │ max │ memory │ allocs │; ├──────┼──────┼───────────┼───────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ 32³ │ DryEarth │ Energy │ 37.682 ms │ 38.012 ms │ 37.982 ms │ 38.199 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth │ Entropy │ 32.325 ms │ 32.920 ms │ 32.928 ms │ 33.628 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth3 │ Energy │ 52.473 ms │ 52.815 ms │ 52.896 ms │ 53.413 ms │ 816.50 KiB │ 5635 │; │ CPU │ 32³ │ DryEarth3 │ Entropy │ 69.928 ms │ 70.388 ms │ 70.402 ms │ 71.224 ms │ 816.50 KiB │ 5635 │; │ CPU │ 192³ │ DryEarth │ Energy │ 7.438 s │ 7.438 s │ 7.438 s │ 7.438 s │ 646.33 KiB │ 4499 │; │ CPU │ 192³ │ DryEarth │ Entropy │ 6.501 s │ 6.501 s │ 6.501 s │ 6.501 s │ 646.58 KiB │ 4512 │; │ CPU │ 192³ │ DryEarth3 │ Energy │ 11.265 s │ 11.265 s │ 11.265 s │ 11.265 s │ 816.75 KiB │ 5648 │; │ CPU │ 192³ │ DryEarth3 │ Entropy │ 15.038 s │ 15.038 s │ 15.038 s │ 15.038 s │ 816.50 KiB │ 5635 │; │ GPU │ 32³ │ DryEarth │ Energy │ 8.328 ms │ 8.513 ms │ 8.608 ms │ 9.676 ms │ 2.00 MiB │ 30129 │; │ GPU │ 32³ │ DryEarth │ Entropy │ 7.863 ms │ 8.500 ms │ 8.529 ms │ 9.515 ms │ 2.00 MiB │ 30129 │; │ GPU │ 32³ │ DryEarth3 │ Energy │ 10.133 ms │ 10.754 ms │ 10.751 ms │ 11.281 ms │ 2.54 MiB │ 37805 │; │ GPU │ 32³ │ DryEarth3 │ Entropy │ 9.992 ms │ 10.572 ms │ 10.542 ms │ 10.836 ms │ 2.54 MiB │ 37839 │; │ GPU │ 192³ │ DryEarth │ Energy │ 101.341 ms │ 101.612 ms │ 101.589 ms │ 101.709 ms │ 2.01 MiB │ 30270 │; │ GPU │ 192³ │ DryEarth │ Entropy │ 86.051 ms │ 86.195 ms │ 86.226 ms │ 86.710 ms │ 2.01 MiB │ 30270 │; │ GPU │ 192³ │ DryEarth3 │ Energy │ 139.732 ms │ 140.009 ms │ 139.957 ms │ 140.079 ms │ 2.54 MiB │ 37983 │; │ GPU │ 192³ │ DryEarth3 │ Entropy │ 375.725 ms │ 376.142 ms │ 376.123 ms │ 376.399 ms │ 2.54 MiB │ 37983 │; └──────┴──────┴───────────┴───────────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; ```. ```; Compressible model speedups ; ┌──────┬───────────┬────,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:8998,Energy Efficiency,Energy,Energy,8998,rth │ Energy │ 37.682 ms │ 38.012 ms │ 37.982 ms │ 38.199 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth │ Entropy │ 32.325 ms │ 32.920 ms │ 32.928 ms │ 33.628 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth3 │ Energy │ 52.473 ms │ 52.815 ms │ 52.896 ms │ 53.413 ms │ 816.50 KiB │ 5635 │; │ CPU │ 32³ │ DryEarth3 │ Entropy │ 69.928 ms │ 70.388 ms │ 70.402 ms │ 71.224 ms │ 816.50 KiB │ 5635 │; │ CPU │ 192³ │ DryEarth │ Energy │ 7.438 s │ 7.438 s │ 7.438 s │ 7.438 s │ 646.33 KiB │ 4499 │; │ CPU │ 192³ │ DryEarth │ Entropy │ 6.501 s │ 6.501 s │ 6.501 s │ 6.501 s │ 646.58 KiB │ 4512 │; │ CPU │ 192³ │ DryEarth3 │ Energy │ 11.265 s │ 11.265 s │ 11.265 s │ 11.265 s │ 816.75 KiB │ 5648 │; │ CPU │ 192³ │ DryEarth3 │ Entropy │ 15.038 s │ 15.038 s │ 15.038 s │ 15.038 s │ 816.50 KiB │ 5635 │; │ GPU │ 32³ │ DryEarth │ Energy │ 8.328 ms │ 8.513 ms │ 8.608 ms │ 9.676 ms │ 2.00 MiB │ 30129 │; │ GPU │ 32³ │ DryEarth │ Entropy │ 7.863 ms │ 8.500 ms │ 8.529 ms │ 9.515 ms │ 2.00 MiB │ 30129 │; │ GPU │ 32³ │ DryEarth3 │ Energy │ 10.133 ms │ 10.754 ms │ 10.751 ms │ 11.281 ms │ 2.54 MiB │ 37805 │; │ GPU │ 32³ │ DryEarth3 │ Entropy │ 9.992 ms │ 10.572 ms │ 10.542 ms │ 10.836 ms │ 2.54 MiB │ 37839 │; │ GPU │ 192³ │ DryEarth │ Energy │ 101.341 ms │ 101.612 ms │ 101.589 ms │ 101.709 ms │ 2.01 MiB │ 30270 │; │ GPU │ 192³ │ DryEarth │ Entropy │ 86.051 ms │ 86.195 ms │ 86.226 ms │ 86.710 ms │ 2.01 MiB │ 30270 │; │ GPU │ 192³ │ DryEarth3 │ Energy │ 139.732 ms │ 140.009 ms │ 139.957 ms │ 140.079 ms │ 2.54 MiB │ 37983 │; │ GPU │ 192³ │ DryEarth3 │ Entropy │ 375.725 ms │ 376.142 ms │ 376.123 ms │ 376.399 ms │ 2.54 MiB │ 37983 │; └──────┴──────┴───────────┴───────────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; ```. ```; Compressible model speedups ; ┌──────┬───────────┬───────────┬─────────┐; │ Size │ Gases │ ThermoVar │ speedup │; ├──────┼───────────┼───────────┼─────────┤; │ 32³ │ DryEarth │ Energy │ 4.465x │; │ 32³ │ DryEarth │ Entropy │ 3.873x │; │ 32³ │ DryEarth,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:9204,Energy Efficiency,Energy,Energy,9204,arth3 │ Energy │ 52.473 ms │ 52.815 ms │ 52.896 ms │ 53.413 ms │ 816.50 KiB │ 5635 │; │ CPU │ 32³ │ DryEarth3 │ Entropy │ 69.928 ms │ 70.388 ms │ 70.402 ms │ 71.224 ms │ 816.50 KiB │ 5635 │; │ CPU │ 192³ │ DryEarth │ Energy │ 7.438 s │ 7.438 s │ 7.438 s │ 7.438 s │ 646.33 KiB │ 4499 │; │ CPU │ 192³ │ DryEarth │ Entropy │ 6.501 s │ 6.501 s │ 6.501 s │ 6.501 s │ 646.58 KiB │ 4512 │; │ CPU │ 192³ │ DryEarth3 │ Energy │ 11.265 s │ 11.265 s │ 11.265 s │ 11.265 s │ 816.75 KiB │ 5648 │; │ CPU │ 192³ │ DryEarth3 │ Entropy │ 15.038 s │ 15.038 s │ 15.038 s │ 15.038 s │ 816.50 KiB │ 5635 │; │ GPU │ 32³ │ DryEarth │ Energy │ 8.328 ms │ 8.513 ms │ 8.608 ms │ 9.676 ms │ 2.00 MiB │ 30129 │; │ GPU │ 32³ │ DryEarth │ Entropy │ 7.863 ms │ 8.500 ms │ 8.529 ms │ 9.515 ms │ 2.00 MiB │ 30129 │; │ GPU │ 32³ │ DryEarth3 │ Energy │ 10.133 ms │ 10.754 ms │ 10.751 ms │ 11.281 ms │ 2.54 MiB │ 37805 │; │ GPU │ 32³ │ DryEarth3 │ Entropy │ 9.992 ms │ 10.572 ms │ 10.542 ms │ 10.836 ms │ 2.54 MiB │ 37839 │; │ GPU │ 192³ │ DryEarth │ Energy │ 101.341 ms │ 101.612 ms │ 101.589 ms │ 101.709 ms │ 2.01 MiB │ 30270 │; │ GPU │ 192³ │ DryEarth │ Entropy │ 86.051 ms │ 86.195 ms │ 86.226 ms │ 86.710 ms │ 2.01 MiB │ 30270 │; │ GPU │ 192³ │ DryEarth3 │ Energy │ 139.732 ms │ 140.009 ms │ 139.957 ms │ 140.079 ms │ 2.54 MiB │ 37983 │; │ GPU │ 192³ │ DryEarth3 │ Entropy │ 375.725 ms │ 376.142 ms │ 376.123 ms │ 376.399 ms │ 2.54 MiB │ 37983 │; └──────┴──────┴───────────┴───────────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; ```. ```; Compressible model speedups ; ┌──────┬───────────┬───────────┬─────────┐; │ Size │ Gases │ ThermoVar │ speedup │; ├──────┼───────────┼───────────┼─────────┤; │ 32³ │ DryEarth │ Energy │ 4.465x │; │ 32³ │ DryEarth │ Entropy │ 3.873x │; │ 32³ │ DryEarth3 │ Energy │ 4.911x │; │ 32³ │ DryEarth3 │ Entropy │ 6.658x │; │ 192³ │ DryEarth │ Energy │ 73.203x │; │ 192³ │ DryEarth │ Entropy │ 75.421x │; │ 192³ │ DryEarth3 │ Energy │ 80.457x │; │ 192³ │ DryEarth3 │ E,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:9416,Energy Efficiency,Energy,Energy,9416,th │ Energy │ 7.438 s │ 7.438 s │ 7.438 s │ 7.438 s │ 646.33 KiB │ 4499 │; │ CPU │ 192³ │ DryEarth │ Entropy │ 6.501 s │ 6.501 s │ 6.501 s │ 6.501 s │ 646.58 KiB │ 4512 │; │ CPU │ 192³ │ DryEarth3 │ Energy │ 11.265 s │ 11.265 s │ 11.265 s │ 11.265 s │ 816.75 KiB │ 5648 │; │ CPU │ 192³ │ DryEarth3 │ Entropy │ 15.038 s │ 15.038 s │ 15.038 s │ 15.038 s │ 816.50 KiB │ 5635 │; │ GPU │ 32³ │ DryEarth │ Energy │ 8.328 ms │ 8.513 ms │ 8.608 ms │ 9.676 ms │ 2.00 MiB │ 30129 │; │ GPU │ 32³ │ DryEarth │ Entropy │ 7.863 ms │ 8.500 ms │ 8.529 ms │ 9.515 ms │ 2.00 MiB │ 30129 │; │ GPU │ 32³ │ DryEarth3 │ Energy │ 10.133 ms │ 10.754 ms │ 10.751 ms │ 11.281 ms │ 2.54 MiB │ 37805 │; │ GPU │ 32³ │ DryEarth3 │ Entropy │ 9.992 ms │ 10.572 ms │ 10.542 ms │ 10.836 ms │ 2.54 MiB │ 37839 │; │ GPU │ 192³ │ DryEarth │ Energy │ 101.341 ms │ 101.612 ms │ 101.589 ms │ 101.709 ms │ 2.01 MiB │ 30270 │; │ GPU │ 192³ │ DryEarth │ Entropy │ 86.051 ms │ 86.195 ms │ 86.226 ms │ 86.710 ms │ 2.01 MiB │ 30270 │; │ GPU │ 192³ │ DryEarth3 │ Energy │ 139.732 ms │ 140.009 ms │ 139.957 ms │ 140.079 ms │ 2.54 MiB │ 37983 │; │ GPU │ 192³ │ DryEarth3 │ Entropy │ 375.725 ms │ 376.142 ms │ 376.123 ms │ 376.399 ms │ 2.54 MiB │ 37983 │; └──────┴──────┴───────────┴───────────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; ```. ```; Compressible model speedups ; ┌──────┬───────────┬───────────┬─────────┐; │ Size │ Gases │ ThermoVar │ speedup │; ├──────┼───────────┼───────────┼─────────┤; │ 32³ │ DryEarth │ Energy │ 4.465x │; │ 32³ │ DryEarth │ Entropy │ 3.873x │; │ 32³ │ DryEarth3 │ Energy │ 4.911x │; │ 32³ │ DryEarth3 │ Entropy │ 6.658x │; │ 192³ │ DryEarth │ Energy │ 73.203x │; │ 192³ │ DryEarth │ Entropy │ 75.421x │; │ 192³ │ DryEarth3 │ Energy │ 80.457x │; │ 192³ │ DryEarth3 │ Entropy │ 39.981x │; └──────┴───────────┴───────────┴─────────┘; ```. # TODO. Right now everything lives in a `compressible` directory to keep it separate. There are many improvements that could be made to the `C,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:9908,Energy Efficiency,Energy,Energy,9908,"513 ms │ 8.608 ms │ 9.676 ms │ 2.00 MiB │ 30129 │; │ GPU │ 32³ │ DryEarth │ Entropy │ 7.863 ms │ 8.500 ms │ 8.529 ms │ 9.515 ms │ 2.00 MiB │ 30129 │; │ GPU │ 32³ │ DryEarth3 │ Energy │ 10.133 ms │ 10.754 ms │ 10.751 ms │ 11.281 ms │ 2.54 MiB │ 37805 │; │ GPU │ 32³ │ DryEarth3 │ Entropy │ 9.992 ms │ 10.572 ms │ 10.542 ms │ 10.836 ms │ 2.54 MiB │ 37839 │; │ GPU │ 192³ │ DryEarth │ Energy │ 101.341 ms │ 101.612 ms │ 101.589 ms │ 101.709 ms │ 2.01 MiB │ 30270 │; │ GPU │ 192³ │ DryEarth │ Entropy │ 86.051 ms │ 86.195 ms │ 86.226 ms │ 86.710 ms │ 2.01 MiB │ 30270 │; │ GPU │ 192³ │ DryEarth3 │ Energy │ 139.732 ms │ 140.009 ms │ 139.957 ms │ 140.079 ms │ 2.54 MiB │ 37983 │; │ GPU │ 192³ │ DryEarth3 │ Entropy │ 375.725 ms │ 376.142 ms │ 376.123 ms │ 376.399 ms │ 2.54 MiB │ 37983 │; └──────┴──────┴───────────┴───────────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; ```. ```; Compressible model speedups ; ┌──────┬───────────┬───────────┬─────────┐; │ Size │ Gases │ ThermoVar │ speedup │; ├──────┼───────────┼───────────┼─────────┤; │ 32³ │ DryEarth │ Energy │ 4.465x │; │ 32³ │ DryEarth │ Entropy │ 3.873x │; │ 32³ │ DryEarth3 │ Energy │ 4.911x │; │ 32³ │ DryEarth3 │ Entropy │ 6.658x │; │ 192³ │ DryEarth │ Energy │ 73.203x │; │ 192³ │ DryEarth │ Entropy │ 75.421x │; │ 192³ │ DryEarth3 │ Energy │ 80.457x │; │ 192³ │ DryEarth3 │ Entropy │ 39.981x │; └──────┴───────────┴───────────┴─────────┘; ```. # TODO. Right now everything lives in a `compressible` directory to keep it separate. There are many improvements that could be made to the `CompressibleModel`, starting first with how reference states are initialized and how initial conditions are set (see verification scripts), but this is a list of TODO items in case we decide to merge this PR. - [ ] Add some documentation, especially for the numerical methods. I should probably LaTeX some notes first [@thabbot has some but might be for the Klemp et al. (2007) equations?].; - [ ] Transfer issues from JULE",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:9986,Energy Efficiency,Energy,Energy,9986," │ 32³ │ DryEarth3 │ Energy │ 10.133 ms │ 10.754 ms │ 10.751 ms │ 11.281 ms │ 2.54 MiB │ 37805 │; │ GPU │ 32³ │ DryEarth3 │ Entropy │ 9.992 ms │ 10.572 ms │ 10.542 ms │ 10.836 ms │ 2.54 MiB │ 37839 │; │ GPU │ 192³ │ DryEarth │ Energy │ 101.341 ms │ 101.612 ms │ 101.589 ms │ 101.709 ms │ 2.01 MiB │ 30270 │; │ GPU │ 192³ │ DryEarth │ Entropy │ 86.051 ms │ 86.195 ms │ 86.226 ms │ 86.710 ms │ 2.01 MiB │ 30270 │; │ GPU │ 192³ │ DryEarth3 │ Energy │ 139.732 ms │ 140.009 ms │ 139.957 ms │ 140.079 ms │ 2.54 MiB │ 37983 │; │ GPU │ 192³ │ DryEarth3 │ Entropy │ 375.725 ms │ 376.142 ms │ 376.123 ms │ 376.399 ms │ 2.54 MiB │ 37983 │; └──────┴──────┴───────────┴───────────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; ```. ```; Compressible model speedups ; ┌──────┬───────────┬───────────┬─────────┐; │ Size │ Gases │ ThermoVar │ speedup │; ├──────┼───────────┼───────────┼─────────┤; │ 32³ │ DryEarth │ Energy │ 4.465x │; │ 32³ │ DryEarth │ Entropy │ 3.873x │; │ 32³ │ DryEarth3 │ Energy │ 4.911x │; │ 32³ │ DryEarth3 │ Entropy │ 6.658x │; │ 192³ │ DryEarth │ Energy │ 73.203x │; │ 192³ │ DryEarth │ Entropy │ 75.421x │; │ 192³ │ DryEarth3 │ Energy │ 80.457x │; │ 192³ │ DryEarth3 │ Entropy │ 39.981x │; └──────┴───────────┴───────────┴─────────┘; ```. # TODO. Right now everything lives in a `compressible` directory to keep it separate. There are many improvements that could be made to the `CompressibleModel`, starting first with how reference states are initialized and how initial conditions are set (see verification scripts), but this is a list of TODO items in case we decide to merge this PR. - [ ] Add some documentation, especially for the numerical methods. I should probably LaTeX some notes first [@thabbot has some but might be for the Klemp et al. (2007) equations?].; - [ ] Transfer issues from JULES.jl to Oceananigans.jl to preserve useful discussions and action items.; - [ ] Merge modules, tests, and verification experiments from `compressible` direc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:10065,Energy Efficiency,Energy,Energy,10065,"54 MiB │ 37805 │; │ GPU │ 32³ │ DryEarth3 │ Entropy │ 9.992 ms │ 10.572 ms │ 10.542 ms │ 10.836 ms │ 2.54 MiB │ 37839 │; │ GPU │ 192³ │ DryEarth │ Energy │ 101.341 ms │ 101.612 ms │ 101.589 ms │ 101.709 ms │ 2.01 MiB │ 30270 │; │ GPU │ 192³ │ DryEarth │ Entropy │ 86.051 ms │ 86.195 ms │ 86.226 ms │ 86.710 ms │ 2.01 MiB │ 30270 │; │ GPU │ 192³ │ DryEarth3 │ Energy │ 139.732 ms │ 140.009 ms │ 139.957 ms │ 140.079 ms │ 2.54 MiB │ 37983 │; │ GPU │ 192³ │ DryEarth3 │ Entropy │ 375.725 ms │ 376.142 ms │ 376.123 ms │ 376.399 ms │ 2.54 MiB │ 37983 │; └──────┴──────┴───────────┴───────────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; ```. ```; Compressible model speedups ; ┌──────┬───────────┬───────────┬─────────┐; │ Size │ Gases │ ThermoVar │ speedup │; ├──────┼───────────┼───────────┼─────────┤; │ 32³ │ DryEarth │ Energy │ 4.465x │; │ 32³ │ DryEarth │ Entropy │ 3.873x │; │ 32³ │ DryEarth3 │ Energy │ 4.911x │; │ 32³ │ DryEarth3 │ Entropy │ 6.658x │; │ 192³ │ DryEarth │ Energy │ 73.203x │; │ 192³ │ DryEarth │ Entropy │ 75.421x │; │ 192³ │ DryEarth3 │ Energy │ 80.457x │; │ 192³ │ DryEarth3 │ Entropy │ 39.981x │; └──────┴───────────┴───────────┴─────────┘; ```. # TODO. Right now everything lives in a `compressible` directory to keep it separate. There are many improvements that could be made to the `CompressibleModel`, starting first with how reference states are initialized and how initial conditions are set (see verification scripts), but this is a list of TODO items in case we decide to merge this PR. - [ ] Add some documentation, especially for the numerical methods. I should probably LaTeX some notes first [@thabbot has some but might be for the Klemp et al. (2007) equations?].; - [ ] Transfer issues from JULES.jl to Oceananigans.jl to preserve useful discussions and action items.; - [ ] Merge modules, tests, and verification experiments from `compressible` directory. # References. Jahn et al. (2015): https://doi.org/10.5194/gmd-8-317-2015;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:10147,Energy Efficiency,Energy,Energy,10147,"42 ms │ 10.836 ms │ 2.54 MiB │ 37839 │; │ GPU │ 192³ │ DryEarth │ Energy │ 101.341 ms │ 101.612 ms │ 101.589 ms │ 101.709 ms │ 2.01 MiB │ 30270 │; │ GPU │ 192³ │ DryEarth │ Entropy │ 86.051 ms │ 86.195 ms │ 86.226 ms │ 86.710 ms │ 2.01 MiB │ 30270 │; │ GPU │ 192³ │ DryEarth3 │ Energy │ 139.732 ms │ 140.009 ms │ 139.957 ms │ 140.079 ms │ 2.54 MiB │ 37983 │; │ GPU │ 192³ │ DryEarth3 │ Entropy │ 375.725 ms │ 376.142 ms │ 376.123 ms │ 376.399 ms │ 2.54 MiB │ 37983 │; └──────┴──────┴───────────┴───────────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; ```. ```; Compressible model speedups ; ┌──────┬───────────┬───────────┬─────────┐; │ Size │ Gases │ ThermoVar │ speedup │; ├──────┼───────────┼───────────┼─────────┤; │ 32³ │ DryEarth │ Energy │ 4.465x │; │ 32³ │ DryEarth │ Entropy │ 3.873x │; │ 32³ │ DryEarth3 │ Energy │ 4.911x │; │ 32³ │ DryEarth3 │ Entropy │ 6.658x │; │ 192³ │ DryEarth │ Energy │ 73.203x │; │ 192³ │ DryEarth │ Entropy │ 75.421x │; │ 192³ │ DryEarth3 │ Energy │ 80.457x │; │ 192³ │ DryEarth3 │ Entropy │ 39.981x │; └──────┴───────────┴───────────┴─────────┘; ```. # TODO. Right now everything lives in a `compressible` directory to keep it separate. There are many improvements that could be made to the `CompressibleModel`, starting first with how reference states are initialized and how initial conditions are set (see verification scripts), but this is a list of TODO items in case we decide to merge this PR. - [ ] Add some documentation, especially for the numerical methods. I should probably LaTeX some notes first [@thabbot has some but might be for the Klemp et al. (2007) equations?].; - [ ] Transfer issues from JULES.jl to Oceananigans.jl to preserve useful discussions and action items.; - [ ] Merge modules, tests, and verification experiments from `compressible` directory. # References. Jahn et al. (2015): https://doi.org/10.5194/gmd-8-317-2015; Klemp et al. (2007): https://doi.org/10.1175/MWR3440.1; Satoh (2003): https://doi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:2023,Integrability,interface,interface,2023,"e Klemp et al. (2007) equation set which is only valid in the limit of a dry atmosphere with trace amounts of moist species. An RK3 time-stepper is used that is apparently 3rd-order accurate for linear terms but only 2nd-order accurate for non-linear terms. This is because it's developed to allow for acoustic time stepping between RK stages. This split-explicit time-stepping scheme is described by Wicker & Skamarock (2002), Klemp et al. (2007), and Satoh (2003). It's essentially the same one used by the NCAR WRF model (Skamarock et al., 2019). No acoustic time stepper is implemented yet. Explicit acoustic time stepping could make sense for regular Cartesian grids while a vertically implicit acoustic time stepper would make sense for vertically stretched grids (possible with `Oceananigans.Solver.BatchedTridiagonalSolver`). Building the compressible model on top of Oceananigans.jl has allowed it to run on GPUs and make use of the same operators, grids, Coriolis terms, forcing function and boundary conditions, diagnostics, output writers, higher-order advection schemes, and user-interface niceties. Turbulent diffusivity closures may take more work to integrate and not all of them can be shared as the stress tensor is not traceless when the fluid is compressible (see #654 for more discussion). # Reasons why we may consider adding a compressible model to the Oceananigans.jl ecosystem. 1. I see Oceananigans.jl as a general-purpose package for fluid dynamics even though we mostly apply it to ocean problems. With both incompressible and compressible models, Oceananigans.jl would appeal to a larger audience and may be used to investigate a greater range of problems.; 2. One potential use of the `CompressibleModel` is to simulate a compressible ocean (with pressure as a prognostic variable) in which sound waves artificially slowed down for practical purposes. There were some discussions around this idea and @johncmarshall54 might still be interested.; 3. With PR #590, Oceanani",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:2096,Integrability,integrat,integrate,2096," only 2nd-order accurate for non-linear terms. This is because it's developed to allow for acoustic time stepping between RK stages. This split-explicit time-stepping scheme is described by Wicker & Skamarock (2002), Klemp et al. (2007), and Satoh (2003). It's essentially the same one used by the NCAR WRF model (Skamarock et al., 2019). No acoustic time stepper is implemented yet. Explicit acoustic time stepping could make sense for regular Cartesian grids while a vertically implicit acoustic time stepper would make sense for vertically stretched grids (possible with `Oceananigans.Solver.BatchedTridiagonalSolver`). Building the compressible model on top of Oceananigans.jl has allowed it to run on GPUs and make use of the same operators, grids, Coriolis terms, forcing function and boundary conditions, diagnostics, output writers, higher-order advection schemes, and user-interface niceties. Turbulent diffusivity closures may take more work to integrate and not all of them can be shared as the stress tensor is not traceless when the fluid is compressible (see #654 for more discussion). # Reasons why we may consider adding a compressible model to the Oceananigans.jl ecosystem. 1. I see Oceananigans.jl as a general-purpose package for fluid dynamics even though we mostly apply it to ocean problems. With both incompressible and compressible models, Oceananigans.jl would appeal to a larger audience and may be used to investigate a greater range of problems.; 2. One potential use of the `CompressibleModel` is to simulate a compressible ocean (with pressure as a prognostic variable) in which sound waves artificially slowed down for practical purposes. There were some discussions around this idea and @johncmarshall54 might still be interested.; 3. With PR #590, Oceananigans.jl will support distributed parallelism via MPI. While incompressible models (and anelastic models) don't scale that well to many nodes due to the need to solve an elliptic Poission equation globally acros",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:4439,Integrability,interface,interface,4439,"Oceananigans MPI algorithm might be best tested using a compressible model.; 4. Since distributed FFTs aren't generally available on GPUs (CuFFT only goes up to 16 GPUs), CUDA-aware MPI for incompressible models might take some time and effort to support once PR #590 is merged. However, CUDA-aware MPI should work out of the box for compressible models as there are no FFTs to worry about.; 5. Due to the need for a fast pressure solver for incompressible models, we are not considering more general grids beyond the vertically stretched Cartesian grid. The compressible model does not have this limitation and can easily make use of a more general Cartesian grid (stretching in all dimensions).; 6. The incompressible model is limited to a certain number of topologies, particularly on the GPU, due to the pressure solver. A compressible model would work with all possible topologies out of the box.; 7. Since `CompressibleModel` and `IncompressibleModel` share so much common infrastructure they also share a common user interface by construction which makes it easy to switch between the two. I think this is a valueble feature. Most existing packages do not have compressible/incompressible or ocean/atmosphere capabilities within the same package.; 8. Under a shared package and user interface, Oceananigans.jl will allow users to easily switch between simulating compressible and incompressible fluids and might also allow for _fast and friendly_ coupled large-eddy simulation (although the amount of work needed to reach this would be non-trivial). # Mono-repo vs. multiple packages. I think merging this PR puts the Oceananigans.jl repo in danger of becoming a mono-repo so we should be careful. One big reason why we haven't kept the compressible model in a separate repo is because we just don't have a good name for it yet. A potential pathway to multiple packages would be to split out the Oceananigans.jl package into four packages: OceananigansBase.jl, OceananigansIncompressible.jl, Oc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:4705,Integrability,interface,interface,4705,"r, CUDA-aware MPI should work out of the box for compressible models as there are no FFTs to worry about.; 5. Due to the need for a fast pressure solver for incompressible models, we are not considering more general grids beyond the vertically stretched Cartesian grid. The compressible model does not have this limitation and can easily make use of a more general Cartesian grid (stretching in all dimensions).; 6. The incompressible model is limited to a certain number of topologies, particularly on the GPU, due to the pressure solver. A compressible model would work with all possible topologies out of the box.; 7. Since `CompressibleModel` and `IncompressibleModel` share so much common infrastructure they also share a common user interface by construction which makes it easy to switch between the two. I think this is a valueble feature. Most existing packages do not have compressible/incompressible or ocean/atmosphere capabilities within the same package.; 8. Under a shared package and user interface, Oceananigans.jl will allow users to easily switch between simulating compressible and incompressible fluids and might also allow for _fast and friendly_ coupled large-eddy simulation (although the amount of work needed to reach this would be non-trivial). # Mono-repo vs. multiple packages. I think merging this PR puts the Oceananigans.jl repo in danger of becoming a mono-repo so we should be careful. One big reason why we haven't kept the compressible model in a separate repo is because we just don't have a good name for it yet. A potential pathway to multiple packages would be to split out the Oceananigans.jl package into four packages: OceananigansBase.jl, OceananigansIncompressible.jl, OceananigansCompressible.jl, and Oceananigans.jl. I'm not sure which modules would go where but the idea is that users will only have to keep interfacing with Oceananigans.jl. An added advantage of keeping everything under some Oceananigans.jl umbrella is that the name is getting more w",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:709,Modifiability,variab,variables,709,"This PR adds a GPU-enabled `CompressibleModel`, developed with @thabbott and @RaphaelRR in a separate repository (https://github.com/ali-ramadhan/Atmosfoolery.jl). This is a large PR and I'm not even sure if it makes sense to merge it into Oceananigans.jl. The main purpose of opening this PR is to document progress made and ultimately decide on what to do with this feature. I don't think I can continue working on it. # Description. The compressible model implements the conservative Scheme by Satoh (2003), suitable for compressible non-hydrostatic models with moist processes, and is valid in the limit of a condensable gas/atmosphere with multiple moist species. Two choices of prognostic thermodynamic variables are available, internal energy and entropy, although in the Oceananigans spirit adding new thermodynamic variables is pretty easy!. @thabbott implemented the Satoh (2003) equation set. I initially implemented the Klemp et al. (2007) equation set which is only valid in the limit of a dry atmosphere with trace amounts of moist species. An RK3 time-stepper is used that is apparently 3rd-order accurate for linear terms but only 2nd-order accurate for non-linear terms. This is because it's developed to allow for acoustic time stepping between RK stages. This split-explicit time-stepping scheme is described by Wicker & Skamarock (2002), Klemp et al. (2007), and Satoh (2003). It's essentially the same one used by the NCAR WRF model (Skamarock et al., 2019). No acoustic time stepper is implemented yet. Explicit acoustic time stepping could make sense for regular Cartesian grids while a vertically implicit acoustic time stepper would make sense for vertically stretched grids (possible with `Oceananigans.Solver.BatchedTridiagonalSolver`). Building the compressible model on top of Oceananigans.jl has allowed it to run on GPUs and make use of the same operators, grids, Coriolis terms, forcing function and boundary conditions, diagnostics, output writers, higher-order advect",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:824,Modifiability,variab,variables,824,"This PR adds a GPU-enabled `CompressibleModel`, developed with @thabbott and @RaphaelRR in a separate repository (https://github.com/ali-ramadhan/Atmosfoolery.jl). This is a large PR and I'm not even sure if it makes sense to merge it into Oceananigans.jl. The main purpose of opening this PR is to document progress made and ultimately decide on what to do with this feature. I don't think I can continue working on it. # Description. The compressible model implements the conservative Scheme by Satoh (2003), suitable for compressible non-hydrostatic models with moist processes, and is valid in the limit of a condensable gas/atmosphere with multiple moist species. Two choices of prognostic thermodynamic variables are available, internal energy and entropy, although in the Oceananigans spirit adding new thermodynamic variables is pretty easy!. @thabbott implemented the Satoh (2003) equation set. I initially implemented the Klemp et al. (2007) equation set which is only valid in the limit of a dry atmosphere with trace amounts of moist species. An RK3 time-stepper is used that is apparently 3rd-order accurate for linear terms but only 2nd-order accurate for non-linear terms. This is because it's developed to allow for acoustic time stepping between RK stages. This split-explicit time-stepping scheme is described by Wicker & Skamarock (2002), Klemp et al. (2007), and Satoh (2003). It's essentially the same one used by the NCAR WRF model (Skamarock et al., 2019). No acoustic time stepper is implemented yet. Explicit acoustic time stepping could make sense for regular Cartesian grids while a vertically implicit acoustic time stepper would make sense for vertically stretched grids (possible with `Oceananigans.Solver.BatchedTridiagonalSolver`). Building the compressible model on top of Oceananigans.jl has allowed it to run on GPUs and make use of the same operators, grids, Coriolis terms, forcing function and boundary conditions, diagnostics, output writers, higher-order advect",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:2732,Modifiability,variab,variable,2732,"`Oceananigans.Solver.BatchedTridiagonalSolver`). Building the compressible model on top of Oceananigans.jl has allowed it to run on GPUs and make use of the same operators, grids, Coriolis terms, forcing function and boundary conditions, diagnostics, output writers, higher-order advection schemes, and user-interface niceties. Turbulent diffusivity closures may take more work to integrate and not all of them can be shared as the stress tensor is not traceless when the fluid is compressible (see #654 for more discussion). # Reasons why we may consider adding a compressible model to the Oceananigans.jl ecosystem. 1. I see Oceananigans.jl as a general-purpose package for fluid dynamics even though we mostly apply it to ocean problems. With both incompressible and compressible models, Oceananigans.jl would appeal to a larger audience and may be used to investigate a greater range of problems.; 2. One potential use of the `CompressibleModel` is to simulate a compressible ocean (with pressure as a prognostic variable) in which sound waves artificially slowed down for practical purposes. There were some discussions around this idea and @johncmarshall54 might still be interested.; 3. With PR #590, Oceananigans.jl will support distributed parallelism via MPI. While incompressible models (and anelastic models) don't scale that well to many nodes due to the need to solve an elliptic Poission equation globally across all ranks, a compressible model is completely local and might easily scale well on many GPUs. So even if the scalability of incompressible models on many GPUs is dissapointing, we may get a very scalable compressible model almost for free. Actually, the efficiency of the Oceananigans MPI algorithm might be best tested using a compressible model.; 4. Since distributed FFTs aren't generally available on GPUs (CuFFT only goes up to 16 GPUs), CUDA-aware MPI for incompressible models might take some time and effort to support once PR #590 is merged. However, CUDA-aware M",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:3252,Performance,scalab,scalability,3252,"ananigans.jl ecosystem. 1. I see Oceananigans.jl as a general-purpose package for fluid dynamics even though we mostly apply it to ocean problems. With both incompressible and compressible models, Oceananigans.jl would appeal to a larger audience and may be used to investigate a greater range of problems.; 2. One potential use of the `CompressibleModel` is to simulate a compressible ocean (with pressure as a prognostic variable) in which sound waves artificially slowed down for practical purposes. There were some discussions around this idea and @johncmarshall54 might still be interested.; 3. With PR #590, Oceananigans.jl will support distributed parallelism via MPI. While incompressible models (and anelastic models) don't scale that well to many nodes due to the need to solve an elliptic Poission equation globally across all ranks, a compressible model is completely local and might easily scale well on many GPUs. So even if the scalability of incompressible models on many GPUs is dissapointing, we may get a very scalable compressible model almost for free. Actually, the efficiency of the Oceananigans MPI algorithm might be best tested using a compressible model.; 4. Since distributed FFTs aren't generally available on GPUs (CuFFT only goes up to 16 GPUs), CUDA-aware MPI for incompressible models might take some time and effort to support once PR #590 is merged. However, CUDA-aware MPI should work out of the box for compressible models as there are no FFTs to worry about.; 5. Due to the need for a fast pressure solver for incompressible models, we are not considering more general grids beyond the vertically stretched Cartesian grid. The compressible model does not have this limitation and can easily make use of a more general Cartesian grid (stretching in all dimensions).; 6. The incompressible model is limited to a certain number of topologies, particularly on the GPU, due to the pressure solver. A compressible model would work with all possible topologies out of t",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:3338,Performance,scalab,scalable,3338,"ananigans.jl ecosystem. 1. I see Oceananigans.jl as a general-purpose package for fluid dynamics even though we mostly apply it to ocean problems. With both incompressible and compressible models, Oceananigans.jl would appeal to a larger audience and may be used to investigate a greater range of problems.; 2. One potential use of the `CompressibleModel` is to simulate a compressible ocean (with pressure as a prognostic variable) in which sound waves artificially slowed down for practical purposes. There were some discussions around this idea and @johncmarshall54 might still be interested.; 3. With PR #590, Oceananigans.jl will support distributed parallelism via MPI. While incompressible models (and anelastic models) don't scale that well to many nodes due to the need to solve an elliptic Poission equation globally across all ranks, a compressible model is completely local and might easily scale well on many GPUs. So even if the scalability of incompressible models on many GPUs is dissapointing, we may get a very scalable compressible model almost for free. Actually, the efficiency of the Oceananigans MPI algorithm might be best tested using a compressible model.; 4. Since distributed FFTs aren't generally available on GPUs (CuFFT only goes up to 16 GPUs), CUDA-aware MPI for incompressible models might take some time and effort to support once PR #590 is merged. However, CUDA-aware MPI should work out of the box for compressible models as there are no FFTs to worry about.; 5. Due to the need for a fast pressure solver for incompressible models, we are not considering more general grids beyond the vertically stretched Cartesian grid. The compressible model does not have this limitation and can easily make use of a more general Cartesian grid (stretching in all dimensions).; 6. The incompressible model is limited to a certain number of topologies, particularly on the GPU, due to the pressure solver. A compressible model would work with all possible topologies out of t",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:7289,Performance,perform,performance,7289," a multiple packages approach but for ancillary features. # Tests and validation experiments. We spent quite some time ensuring the `CompressibleModel` can simulate some known atmospheric test cases. Following recent trials and tribulations I also decided to add some simple 1D tests. Here I list the tests but will post a followup comment for each test with a figure or animation. Hopefully together these tests act as a starting point to start believing that the `CompressibleModel` indeed does work as expected. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large models when comparing a single CPU core to a single Titan V GPU on Tartarus. Not as good as the incompressible model as some of the functions that diagnose temperature and pressure need some optimizing, especially in the case of multiple gases. ```; Compressible model benchmarks ; ┌──────┬──────┬───────────┬───────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Arch │ Size │ Gases │ ThermoVar │ min │ median │ mean │ max │ memory │ allocs │; ├──────┼──────┼───────────┼───────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ 32³ │ DryEarth │ Energy │ 37.682 ms │ 38.012 ms │ 37.982 ms │ 38.199 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth │ Entropy │ 32.325 ms │ 32.920 ms │ 32.928 ms │ 33.628 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth3 │ Energy │ 52.473 ms │ 52.815 ms │ 52.896 ms │ 53.413 ms │ 816.50 KiB │ 5635 │; │ CPU │ 32³ │ DryEarth3",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:7559,Performance,optimiz,optimizing,7559,"bulations I also decided to add some simple 1D tests. Here I list the tests but will post a followup comment for each test with a figure or animation. Hopefully together these tests act as a starting point to start believing that the `CompressibleModel` indeed does work as expected. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large models when comparing a single CPU core to a single Titan V GPU on Tartarus. Not as good as the incompressible model as some of the functions that diagnose temperature and pressure need some optimizing, especially in the case of multiple gases. ```; Compressible model benchmarks ; ┌──────┬──────┬───────────┬───────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Arch │ Size │ Gases │ ThermoVar │ min │ median │ mean │ max │ memory │ allocs │; ├──────┼──────┼───────────┼───────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ 32³ │ DryEarth │ Energy │ 37.682 ms │ 38.012 ms │ 37.982 ms │ 38.199 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth │ Entropy │ 32.325 ms │ 32.920 ms │ 32.928 ms │ 33.628 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth3 │ Energy │ 52.473 ms │ 52.815 ms │ 52.896 ms │ 53.413 ms │ 816.50 KiB │ 5635 │; │ CPU │ 32³ │ DryEarth3 │ Entropy │ 69.928 ms │ 70.388 ms │ 70.402 ms │ 71.224 ms │ 816.50 KiB │ 5635 │; │ CPU │ 192³ │ DryEarth │ Energy │ 7.438 s │ 7.438 s │ 7.438 s │ 7.438 s │ 646.33 KiB │ 4499 │; │ CPU │ 192³ │ DryEarth │ Entropy │ 6.501 s │ 6.501 s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:6367,Security,validat,validation,6367,"nsBase.jl, OceananigansIncompressible.jl, OceananigansCompressible.jl, and Oceananigans.jl. I'm not sure which modules would go where but the idea is that users will only have to keep interfacing with Oceananigans.jl. An added advantage of keeping everything under some Oceananigans.jl umbrella is that the name is getting more well-known (and we have a JOSS paper) so I don't think it makes sense to start a second package with a new name that nobody knows (unless it's a good name!). That said, I would not be opposed to a mono-repo with a well-defined scope. I actually think that this is a better approach. For example, Oceananigans.jl could provide the `CompressibleModel` and `IncompressibleModel` but ocean-specific modules could live in separate packages. We did this with SeawaterPolynomials.jl and could probably do it with other modules to further limit scope if we decide to pursue this approach. So this is still a multiple packages approach but for ancillary features. # Tests and validation experiments. We spent quite some time ensuring the `CompressibleModel` can simulate some known atmospheric test cases. Following recent trials and tribulations I also decided to add some simple 1D tests. Here I list the tests but will post a followup comment for each test with a figure or animation. Hopefully together these tests act as a starting point to start believing that the `CompressibleModel` indeed does work as expected. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large mode",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:3456,Testability,test,tested,3456," to ocean problems. With both incompressible and compressible models, Oceananigans.jl would appeal to a larger audience and may be used to investigate a greater range of problems.; 2. One potential use of the `CompressibleModel` is to simulate a compressible ocean (with pressure as a prognostic variable) in which sound waves artificially slowed down for practical purposes. There were some discussions around this idea and @johncmarshall54 might still be interested.; 3. With PR #590, Oceananigans.jl will support distributed parallelism via MPI. While incompressible models (and anelastic models) don't scale that well to many nodes due to the need to solve an elliptic Poission equation globally across all ranks, a compressible model is completely local and might easily scale well on many GPUs. So even if the scalability of incompressible models on many GPUs is dissapointing, we may get a very scalable compressible model almost for free. Actually, the efficiency of the Oceananigans MPI algorithm might be best tested using a compressible model.; 4. Since distributed FFTs aren't generally available on GPUs (CuFFT only goes up to 16 GPUs), CUDA-aware MPI for incompressible models might take some time and effort to support once PR #590 is merged. However, CUDA-aware MPI should work out of the box for compressible models as there are no FFTs to worry about.; 5. Due to the need for a fast pressure solver for incompressible models, we are not considering more general grids beyond the vertically stretched Cartesian grid. The compressible model does not have this limitation and can easily make use of a more general Cartesian grid (stretching in all dimensions).; 6. The incompressible model is limited to a certain number of topologies, particularly on the GPU, due to the pressure solver. A compressible model would work with all possible topologies out of the box.; 7. Since `CompressibleModel` and `IncompressibleModel` share so much common infrastructure they also share a common us",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:6357,Testability,Test,Tests,6357,"nsBase.jl, OceananigansIncompressible.jl, OceananigansCompressible.jl, and Oceananigans.jl. I'm not sure which modules would go where but the idea is that users will only have to keep interfacing with Oceananigans.jl. An added advantage of keeping everything under some Oceananigans.jl umbrella is that the name is getting more well-known (and we have a JOSS paper) so I don't think it makes sense to start a second package with a new name that nobody knows (unless it's a good name!). That said, I would not be opposed to a mono-repo with a well-defined scope. I actually think that this is a better approach. For example, Oceananigans.jl could provide the `CompressibleModel` and `IncompressibleModel` but ocean-specific modules could live in separate packages. We did this with SeawaterPolynomials.jl and could probably do it with other modules to further limit scope if we decide to pursue this approach. So this is still a multiple packages approach but for ancillary features. # Tests and validation experiments. We spent quite some time ensuring the `CompressibleModel` can simulate some known atmospheric test cases. Following recent trials and tribulations I also decided to add some simple 1D tests. Here I list the tests but will post a followup comment for each test with a figure or animation. Hopefully together these tests act as a starting point to start believing that the `CompressibleModel` indeed does work as expected. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large mode",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:6485,Testability,test,test,6485,"and Oceananigans.jl. I'm not sure which modules would go where but the idea is that users will only have to keep interfacing with Oceananigans.jl. An added advantage of keeping everything under some Oceananigans.jl umbrella is that the name is getting more well-known (and we have a JOSS paper) so I don't think it makes sense to start a second package with a new name that nobody knows (unless it's a good name!). That said, I would not be opposed to a mono-repo with a well-defined scope. I actually think that this is a better approach. For example, Oceananigans.jl could provide the `CompressibleModel` and `IncompressibleModel` but ocean-specific modules could live in separate packages. We did this with SeawaterPolynomials.jl and could probably do it with other modules to further limit scope if we decide to pursue this approach. So this is still a multiple packages approach but for ancillary features. # Tests and validation experiments. We spent quite some time ensuring the `CompressibleModel` can simulate some known atmospheric test cases. Following recent trials and tribulations I also decided to add some simple 1D tests. Here I list the tests but will post a followup comment for each test with a figure or animation. Hopefully together these tests act as a starting point to start believing that the `CompressibleModel` indeed does work as expected. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large models when comparing a single CPU core to a single Titan V GPU on Tartarus",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:6575,Testability,test,tests,6575,"only have to keep interfacing with Oceananigans.jl. An added advantage of keeping everything under some Oceananigans.jl umbrella is that the name is getting more well-known (and we have a JOSS paper) so I don't think it makes sense to start a second package with a new name that nobody knows (unless it's a good name!). That said, I would not be opposed to a mono-repo with a well-defined scope. I actually think that this is a better approach. For example, Oceananigans.jl could provide the `CompressibleModel` and `IncompressibleModel` but ocean-specific modules could live in separate packages. We did this with SeawaterPolynomials.jl and could probably do it with other modules to further limit scope if we decide to pursue this approach. So this is still a multiple packages approach but for ancillary features. # Tests and validation experiments. We spent quite some time ensuring the `CompressibleModel` can simulate some known atmospheric test cases. Following recent trials and tribulations I also decided to add some simple 1D tests. Here I list the tests but will post a followup comment for each test with a figure or animation. Hopefully together these tests act as a starting point to start believing that the `CompressibleModel` indeed does work as expected. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large models when comparing a single CPU core to a single Titan V GPU on Tartarus. Not as good as the incompressible model as some of the functions that diagnose temperature and",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:6598,Testability,test,tests,6598,"g under some Oceananigans.jl umbrella is that the name is getting more well-known (and we have a JOSS paper) so I don't think it makes sense to start a second package with a new name that nobody knows (unless it's a good name!). That said, I would not be opposed to a mono-repo with a well-defined scope. I actually think that this is a better approach. For example, Oceananigans.jl could provide the `CompressibleModel` and `IncompressibleModel` but ocean-specific modules could live in separate packages. We did this with SeawaterPolynomials.jl and could probably do it with other modules to further limit scope if we decide to pursue this approach. So this is still a multiple packages approach but for ancillary features. # Tests and validation experiments. We spent quite some time ensuring the `CompressibleModel` can simulate some known atmospheric test cases. Following recent trials and tribulations I also decided to add some simple 1D tests. Here I list the tests but will post a followup comment for each test with a figure or animation. Hopefully together these tests act as a starting point to start believing that the `CompressibleModel` indeed does work as expected. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large models when comparing a single CPU core to a single Titan V GPU on Tartarus. Not as good as the incompressible model as some of the functions that diagnose temperature and pressure need some optimizing, especially in the case of multiple gases. ```; Compressible",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:6646,Testability,test,test,6646,"g under some Oceananigans.jl umbrella is that the name is getting more well-known (and we have a JOSS paper) so I don't think it makes sense to start a second package with a new name that nobody knows (unless it's a good name!). That said, I would not be opposed to a mono-repo with a well-defined scope. I actually think that this is a better approach. For example, Oceananigans.jl could provide the `CompressibleModel` and `IncompressibleModel` but ocean-specific modules could live in separate packages. We did this with SeawaterPolynomials.jl and could probably do it with other modules to further limit scope if we decide to pursue this approach. So this is still a multiple packages approach but for ancillary features. # Tests and validation experiments. We spent quite some time ensuring the `CompressibleModel` can simulate some known atmospheric test cases. Following recent trials and tribulations I also decided to add some simple 1D tests. Here I list the tests but will post a followup comment for each test with a figure or animation. Hopefully together these tests act as a starting point to start believing that the `CompressibleModel` indeed does work as expected. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large models when comparing a single CPU core to a single Titan V GPU on Tartarus. Not as good as the incompressible model as some of the functions that diagnose temperature and pressure need some optimizing, especially in the case of multiple gases. ```; Compressible",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:6704,Testability,test,tests,6704,"on't think it makes sense to start a second package with a new name that nobody knows (unless it's a good name!). That said, I would not be opposed to a mono-repo with a well-defined scope. I actually think that this is a better approach. For example, Oceananigans.jl could provide the `CompressibleModel` and `IncompressibleModel` but ocean-specific modules could live in separate packages. We did this with SeawaterPolynomials.jl and could probably do it with other modules to further limit scope if we decide to pursue this approach. So this is still a multiple packages approach but for ancillary features. # Tests and validation experiments. We spent quite some time ensuring the `CompressibleModel` can simulate some known atmospheric test cases. Following recent trials and tribulations I also decided to add some simple 1D tests. Here I list the tests but will post a followup comment for each test with a figure or animation. Hopefully together these tests act as a starting point to start believing that the `CompressibleModel` indeed does work as expected. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large models when comparing a single CPU core to a single Titan V GPU on Tartarus. Not as good as the incompressible model as some of the functions that diagnose temperature and pressure need some optimizing, especially in the case of multiple gases. ```; Compressible model benchmarks ; ┌──────┬──────┬───────────┬───────────┬────────────┬────────────┬────────────┬────────────┬────",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:7274,Testability,test,testing,7274," if we decide to pursue this approach. So this is still a multiple packages approach but for ancillary features. # Tests and validation experiments. We spent quite some time ensuring the `CompressibleModel` can simulate some known atmospheric test cases. Following recent trials and tribulations I also decided to add some simple 1D tests. Here I list the tests but will post a followup comment for each test with a figure or animation. Hopefully together these tests act as a starting point to start believing that the `CompressibleModel` indeed does work as expected. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large models when comparing a single CPU core to a single Titan V GPU on Tartarus. Not as good as the incompressible model as some of the functions that diagnose temperature and pressure need some optimizing, especially in the case of multiple gases. ```; Compressible model benchmarks ; ┌──────┬──────┬───────────┬───────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Arch │ Size │ Gases │ ThermoVar │ min │ median │ mean │ max │ memory │ allocs │; ├──────┼──────┼───────────┼───────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ 32³ │ DryEarth │ Energy │ 37.682 ms │ 38.012 ms │ 37.982 ms │ 38.199 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth │ Entropy │ 32.325 ms │ 32.920 ms │ 32.928 ms │ 33.628 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth3 │ Energy │ 52.473 ms │ 52.815 ms │ 52.896 ms │ 5",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:7301,Testability,benchmark,benchmarks,7301," a multiple packages approach but for ancillary features. # Tests and validation experiments. We spent quite some time ensuring the `CompressibleModel` can simulate some known atmospheric test cases. Following recent trials and tribulations I also decided to add some simple 1D tests. Here I list the tests but will post a followup comment for each test with a figure or animation. Hopefully together these tests act as a starting point to start believing that the `CompressibleModel` indeed does work as expected. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large models when comparing a single CPU core to a single Titan V GPU on Tartarus. Not as good as the incompressible model as some of the functions that diagnose temperature and pressure need some optimizing, especially in the case of multiple gases. ```; Compressible model benchmarks ; ┌──────┬──────┬───────────┬───────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Arch │ Size │ Gases │ ThermoVar │ min │ median │ mean │ max │ memory │ allocs │; ├──────┼──────┼───────────┼───────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ 32³ │ DryEarth │ Energy │ 37.682 ms │ 38.012 ms │ 37.982 ms │ 38.199 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth │ Entropy │ 32.325 ms │ 32.920 ms │ 32.928 ms │ 33.628 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth3 │ Energy │ 52.473 ms │ 52.815 ms │ 52.896 ms │ 53.413 ms │ 816.50 KiB │ 5635 │; │ CPU │ 32³ │ DryEarth3",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:7325,Testability,benchmark,benchmarks,7325,"experiments. We spent quite some time ensuring the `CompressibleModel` can simulate some known atmospheric test cases. Following recent trials and tribulations I also decided to add some simple 1D tests. Here I list the tests but will post a followup comment for each test with a figure or animation. Hopefully together these tests act as a starting point to start believing that the `CompressibleModel` indeed does work as expected. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large models when comparing a single CPU core to a single Titan V GPU on Tartarus. Not as good as the incompressible model as some of the functions that diagnose temperature and pressure need some optimizing, especially in the case of multiple gases. ```; Compressible model benchmarks ; ┌──────┬──────┬───────────┬───────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Arch │ Size │ Gases │ ThermoVar │ min │ median │ mean │ max │ memory │ allocs │; ├──────┼──────┼───────────┼───────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ 32³ │ DryEarth │ Energy │ 37.682 ms │ 38.012 ms │ 37.982 ms │ 38.199 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth │ Entropy │ 32.325 ms │ 32.920 ms │ 32.928 ms │ 33.628 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth3 │ Energy │ 52.473 ms │ 52.815 ms │ 52.896 ms │ 53.413 ms │ 816.50 KiB │ 5635 │; │ CPU │ 32³ │ DryEarth3 │ Entropy │ 69.928 ms │ 70.388 ms │ 70.402 ms │ 71.224 ms │ 816.50 KiB │ 5635 │;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:7637,Testability,benchmark,benchmarks,7637,"cted. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large models when comparing a single CPU core to a single Titan V GPU on Tartarus. Not as good as the incompressible model as some of the functions that diagnose temperature and pressure need some optimizing, especially in the case of multiple gases. ```; Compressible model benchmarks ; ┌──────┬──────┬───────────┬───────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Arch │ Size │ Gases │ ThermoVar │ min │ median │ mean │ max │ memory │ allocs │; ├──────┼──────┼───────────┼───────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ 32³ │ DryEarth │ Energy │ 37.682 ms │ 38.012 ms │ 37.982 ms │ 38.199 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth │ Entropy │ 32.325 ms │ 32.920 ms │ 32.928 ms │ 33.628 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth3 │ Energy │ 52.473 ms │ 52.815 ms │ 52.896 ms │ 53.413 ms │ 816.50 KiB │ 5635 │; │ CPU │ 32³ │ DryEarth3 │ Entropy │ 69.928 ms │ 70.388 ms │ 70.402 ms │ 71.224 ms │ 816.50 KiB │ 5635 │; │ CPU │ 192³ │ DryEarth │ Energy │ 7.438 s │ 7.438 s │ 7.438 s │ 7.438 s │ 646.33 KiB │ 4499 │; │ CPU │ 192³ │ DryEarth │ Entropy │ 6.501 s │ 6.501 s │ 6.501 s │ 6.501 s │ 646.58 KiB │ 4512 │; │ CPU │ 192³ │ DryEarth3 │ Energy │ 11.265 s │ 11.265 s │ 11.265 s │ 11.265 s │ 816.75 KiB │ 5648 │; │ CPU │ 192³ │ DryEarth3 │ Entropy │ 15.038 s │ 15.038 s │ 15.038 s │ 15.038 s │ 816.50 KiB │ 5635 │; │ GPU │ 32³ │ DryEarth │ Energy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:10917,Testability,test,tests,10917," │ GPU │ 192³ │ DryEarth3 │ Entropy │ 375.725 ms │ 376.142 ms │ 376.123 ms │ 376.399 ms │ 2.54 MiB │ 37983 │; └──────┴──────┴───────────┴───────────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; ```. ```; Compressible model speedups ; ┌──────┬───────────┬───────────┬─────────┐; │ Size │ Gases │ ThermoVar │ speedup │; ├──────┼───────────┼───────────┼─────────┤; │ 32³ │ DryEarth │ Energy │ 4.465x │; │ 32³ │ DryEarth │ Entropy │ 3.873x │; │ 32³ │ DryEarth3 │ Energy │ 4.911x │; │ 32³ │ DryEarth3 │ Entropy │ 6.658x │; │ 192³ │ DryEarth │ Energy │ 73.203x │; │ 192³ │ DryEarth │ Entropy │ 75.421x │; │ 192³ │ DryEarth3 │ Energy │ 80.457x │; │ 192³ │ DryEarth3 │ Entropy │ 39.981x │; └──────┴───────────┴───────────┴─────────┘; ```. # TODO. Right now everything lives in a `compressible` directory to keep it separate. There are many improvements that could be made to the `CompressibleModel`, starting first with how reference states are initialized and how initial conditions are set (see verification scripts), but this is a list of TODO items in case we decide to merge this PR. - [ ] Add some documentation, especially for the numerical methods. I should probably LaTeX some notes first [@thabbot has some but might be for the Klemp et al. (2007) equations?].; - [ ] Transfer issues from JULES.jl to Oceananigans.jl to preserve useful discussions and action items.; - [ ] Merge modules, tests, and verification experiments from `compressible` directory. # References. Jahn et al. (2015): https://doi.org/10.5194/gmd-8-317-2015; Klemp et al. (2007): https://doi.org/10.1175/MWR3440.1; Satoh (2003): https://doi.org/10.1175/1520-0493(2003)131%3C1033:CSFACN%3E2.0.CO;2; Skamarock et al. (2019): https://opensky.ucar.edu/islandora/object/opensky%3A2898; Sod (1978): https://doi.org/10.1016/0021-9991(78)90023-2; Straka et al. (1993): https://doi.org/10.1002/fld.1650170103; Wicker and Skamarock (1998): https://doi.org/10.1175/1520-0493(1998)126%3C1992:ATSSFT%3E2.0.CO;2",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1079:6565,Usability,simpl,simple,6565,"only have to keep interfacing with Oceananigans.jl. An added advantage of keeping everything under some Oceananigans.jl umbrella is that the name is getting more well-known (and we have a JOSS paper) so I don't think it makes sense to start a second package with a new name that nobody knows (unless it's a good name!). That said, I would not be opposed to a mono-repo with a well-defined scope. I actually think that this is a better approach. For example, Oceananigans.jl could provide the `CompressibleModel` and `IncompressibleModel` but ocean-specific modules could live in separate packages. We did this with SeawaterPolynomials.jl and could probably do it with other modules to further limit scope if we decide to pursue this approach. So this is still a multiple packages approach but for ancillary features. # Tests and validation experiments. We spent quite some time ensuring the `CompressibleModel` can simulate some known atmospheric test cases. Following recent trials and tribulations I also decided to add some simple 1D tests. Here I list the tests but will post a followup comment for each test with a figure or animation. Hopefully together these tests act as a starting point to start believing that the `CompressibleModel` indeed does work as expected. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large models when comparing a single CPU core to a single Titan V GPU on Tartarus. Not as good as the incompressible model as some of the functions that diagnose temperature and",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079
https://github.com/CliMA/Oceananigans.jl/pull/1082:52,Availability,Checkpoint,Checkpointer,52,"This PR adds two new features for interacting with `Checkpointer`s. The first is the method. ```julia; set!(model, checkpointer_filepath::AbstractString); ```. that sets all the checkpointed data in `checkpointer_filepath` to `model`, including tendencies, and synchronizes the model clock and iteration with the checkpointed clock and iteration. The second is a kwarg in `run!` meant to be used as either. ```julia; run!(simulation, pickup=true); ```. or . ```julia; run!(simulation, pickup=n); ```. or . ```julia; run!(simulation, pickup=filepath); ```. where `n` is an integer that refers to an iteration number of a checkpointer file to be ""picked up"" and run from, and `filepath` is a string that indicates the path to checkpoint data. `pickup=true` looks for the latest checkpointed file and picks up the simulation from there. To do:. - [x] actually add run!(simulation, pickup=true); - [x] tests for `set!`; - [x] tests for `run!`; - [x] modify `JLD2OutputWriter` so it doesn't fail in common use cases. Resolves #1068 ; Resolves #602",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1082
https://github.com/CliMA/Oceananigans.jl/pull/1082:178,Availability,checkpoint,checkpointed,178,"This PR adds two new features for interacting with `Checkpointer`s. The first is the method. ```julia; set!(model, checkpointer_filepath::AbstractString); ```. that sets all the checkpointed data in `checkpointer_filepath` to `model`, including tendencies, and synchronizes the model clock and iteration with the checkpointed clock and iteration. The second is a kwarg in `run!` meant to be used as either. ```julia; run!(simulation, pickup=true); ```. or . ```julia; run!(simulation, pickup=n); ```. or . ```julia; run!(simulation, pickup=filepath); ```. where `n` is an integer that refers to an iteration number of a checkpointer file to be ""picked up"" and run from, and `filepath` is a string that indicates the path to checkpoint data. `pickup=true` looks for the latest checkpointed file and picks up the simulation from there. To do:. - [x] actually add run!(simulation, pickup=true); - [x] tests for `set!`; - [x] tests for `run!`; - [x] modify `JLD2OutputWriter` so it doesn't fail in common use cases. Resolves #1068 ; Resolves #602",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1082
https://github.com/CliMA/Oceananigans.jl/pull/1082:313,Availability,checkpoint,checkpointed,313,"This PR adds two new features for interacting with `Checkpointer`s. The first is the method. ```julia; set!(model, checkpointer_filepath::AbstractString); ```. that sets all the checkpointed data in `checkpointer_filepath` to `model`, including tendencies, and synchronizes the model clock and iteration with the checkpointed clock and iteration. The second is a kwarg in `run!` meant to be used as either. ```julia; run!(simulation, pickup=true); ```. or . ```julia; run!(simulation, pickup=n); ```. or . ```julia; run!(simulation, pickup=filepath); ```. where `n` is an integer that refers to an iteration number of a checkpointer file to be ""picked up"" and run from, and `filepath` is a string that indicates the path to checkpoint data. `pickup=true` looks for the latest checkpointed file and picks up the simulation from there. To do:. - [x] actually add run!(simulation, pickup=true); - [x] tests for `set!`; - [x] tests for `run!`; - [x] modify `JLD2OutputWriter` so it doesn't fail in common use cases. Resolves #1068 ; Resolves #602",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1082
https://github.com/CliMA/Oceananigans.jl/pull/1082:620,Availability,checkpoint,checkpointer,620,"This PR adds two new features for interacting with `Checkpointer`s. The first is the method. ```julia; set!(model, checkpointer_filepath::AbstractString); ```. that sets all the checkpointed data in `checkpointer_filepath` to `model`, including tendencies, and synchronizes the model clock and iteration with the checkpointed clock and iteration. The second is a kwarg in `run!` meant to be used as either. ```julia; run!(simulation, pickup=true); ```. or . ```julia; run!(simulation, pickup=n); ```. or . ```julia; run!(simulation, pickup=filepath); ```. where `n` is an integer that refers to an iteration number of a checkpointer file to be ""picked up"" and run from, and `filepath` is a string that indicates the path to checkpoint data. `pickup=true` looks for the latest checkpointed file and picks up the simulation from there. To do:. - [x] actually add run!(simulation, pickup=true); - [x] tests for `set!`; - [x] tests for `run!`; - [x] modify `JLD2OutputWriter` so it doesn't fail in common use cases. Resolves #1068 ; Resolves #602",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1082
https://github.com/CliMA/Oceananigans.jl/pull/1082:724,Availability,checkpoint,checkpoint,724,"This PR adds two new features for interacting with `Checkpointer`s. The first is the method. ```julia; set!(model, checkpointer_filepath::AbstractString); ```. that sets all the checkpointed data in `checkpointer_filepath` to `model`, including tendencies, and synchronizes the model clock and iteration with the checkpointed clock and iteration. The second is a kwarg in `run!` meant to be used as either. ```julia; run!(simulation, pickup=true); ```. or . ```julia; run!(simulation, pickup=n); ```. or . ```julia; run!(simulation, pickup=filepath); ```. where `n` is an integer that refers to an iteration number of a checkpointer file to be ""picked up"" and run from, and `filepath` is a string that indicates the path to checkpoint data. `pickup=true` looks for the latest checkpointed file and picks up the simulation from there. To do:. - [x] actually add run!(simulation, pickup=true); - [x] tests for `set!`; - [x] tests for `run!`; - [x] modify `JLD2OutputWriter` so it doesn't fail in common use cases. Resolves #1068 ; Resolves #602",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1082
https://github.com/CliMA/Oceananigans.jl/pull/1082:776,Availability,checkpoint,checkpointed,776,"This PR adds two new features for interacting with `Checkpointer`s. The first is the method. ```julia; set!(model, checkpointer_filepath::AbstractString); ```. that sets all the checkpointed data in `checkpointer_filepath` to `model`, including tendencies, and synchronizes the model clock and iteration with the checkpointed clock and iteration. The second is a kwarg in `run!` meant to be used as either. ```julia; run!(simulation, pickup=true); ```. or . ```julia; run!(simulation, pickup=n); ```. or . ```julia; run!(simulation, pickup=filepath); ```. where `n` is an integer that refers to an iteration number of a checkpointer file to be ""picked up"" and run from, and `filepath` is a string that indicates the path to checkpoint data. `pickup=true` looks for the latest checkpointed file and picks up the simulation from there. To do:. - [x] actually add run!(simulation, pickup=true); - [x] tests for `set!`; - [x] tests for `run!`; - [x] modify `JLD2OutputWriter` so it doesn't fail in common use cases. Resolves #1068 ; Resolves #602",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1082
https://github.com/CliMA/Oceananigans.jl/pull/1082:261,Integrability,synchroniz,synchronizes,261,"This PR adds two new features for interacting with `Checkpointer`s. The first is the method. ```julia; set!(model, checkpointer_filepath::AbstractString); ```. that sets all the checkpointed data in `checkpointer_filepath` to `model`, including tendencies, and synchronizes the model clock and iteration with the checkpointed clock and iteration. The second is a kwarg in `run!` meant to be used as either. ```julia; run!(simulation, pickup=true); ```. or . ```julia; run!(simulation, pickup=n); ```. or . ```julia; run!(simulation, pickup=filepath); ```. where `n` is an integer that refers to an iteration number of a checkpointer file to be ""picked up"" and run from, and `filepath` is a string that indicates the path to checkpoint data. `pickup=true` looks for the latest checkpointed file and picks up the simulation from there. To do:. - [x] actually add run!(simulation, pickup=true); - [x] tests for `set!`; - [x] tests for `run!`; - [x] modify `JLD2OutputWriter` so it doesn't fail in common use cases. Resolves #1068 ; Resolves #602",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1082
https://github.com/CliMA/Oceananigans.jl/pull/1082:898,Testability,test,tests,898,"This PR adds two new features for interacting with `Checkpointer`s. The first is the method. ```julia; set!(model, checkpointer_filepath::AbstractString); ```. that sets all the checkpointed data in `checkpointer_filepath` to `model`, including tendencies, and synchronizes the model clock and iteration with the checkpointed clock and iteration. The second is a kwarg in `run!` meant to be used as either. ```julia; run!(simulation, pickup=true); ```. or . ```julia; run!(simulation, pickup=n); ```. or . ```julia; run!(simulation, pickup=filepath); ```. where `n` is an integer that refers to an iteration number of a checkpointer file to be ""picked up"" and run from, and `filepath` is a string that indicates the path to checkpoint data. `pickup=true` looks for the latest checkpointed file and picks up the simulation from there. To do:. - [x] actually add run!(simulation, pickup=true); - [x] tests for `set!`; - [x] tests for `run!`; - [x] modify `JLD2OutputWriter` so it doesn't fail in common use cases. Resolves #1068 ; Resolves #602",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1082
https://github.com/CliMA/Oceananigans.jl/pull/1082:922,Testability,test,tests,922,"This PR adds two new features for interacting with `Checkpointer`s. The first is the method. ```julia; set!(model, checkpointer_filepath::AbstractString); ```. that sets all the checkpointed data in `checkpointer_filepath` to `model`, including tendencies, and synchronizes the model clock and iteration with the checkpointed clock and iteration. The second is a kwarg in `run!` meant to be used as either. ```julia; run!(simulation, pickup=true); ```. or . ```julia; run!(simulation, pickup=n); ```. or . ```julia; run!(simulation, pickup=filepath); ```. where `n` is an integer that refers to an iteration number of a checkpointer file to be ""picked up"" and run from, and `filepath` is a string that indicates the path to checkpoint data. `pickup=true` looks for the latest checkpointed file and picks up the simulation from there. To do:. - [x] actually add run!(simulation, pickup=true); - [x] tests for `set!`; - [x] tests for `run!`; - [x] modify `JLD2OutputWriter` so it doesn't fail in common use cases. Resolves #1068 ; Resolves #602",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1082
https://github.com/CliMA/Oceananigans.jl/pull/1083:16,Integrability,depend,depends,16,Resolves #1063 (depends on #1081),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1083
https://github.com/CliMA/Oceananigans.jl/issues/1086:682,Availability,failure,failure,682,"Right now regression data takes up a significant amount of space in the repo. I suppose this is not a huge issue as only developers/contributors `git clone` the repo while users can just `] add Oceananigans`. But a potential solution would be to store regression data elsewhere and access it using DataDeps.jl. This might be especially good if we want more/larger regression tests. And it wouldn't increase the repo size every time you have to change the regression data. We could maybe the store on engaging? Ideally it should be hosted somewhere with near 100% uptime as we're already maintaining Buildkite which fails sometimes, so we should try to reduce the number of possible failure points in our CI pipeline. ---. Copy pasted some analysis below:. I think regression files currently take up ~17.1 MiB of space in the git repo while a fresh clone of the repo is ~43 MiB (images and convergence plots probably take up several MiB). Here's a listing of all files in git history over 300 KiB (command from https://stackoverflow.com/a/42544963):; ```; 018186272590 328KiB test/data_rayleigh_benard_regression_000001100.jld; 19db949aaae8 328KiB test/data_rayleigh_benard_regression_000001000.jld; 424080660c53 328KiB test/data_rayleigh_benard_regression_000001000.jld; a7e1d690d6b5 328KiB test/data_rayleigh_benard_regression_000001100.jld; 72744372e5c4 361KiB test/regression_tests/data/thermal_bubble_regression.nc; 4ce9699176ee 363KiB test/deep_convection_regression_10.nc; c15f95e2bf3a 364KiB test/regression_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086
https://github.com/CliMA/Oceananigans.jl/issues/1086:707,Deployability,pipeline,pipeline,707,"Right now regression data takes up a significant amount of space in the repo. I suppose this is not a huge issue as only developers/contributors `git clone` the repo while users can just `] add Oceananigans`. But a potential solution would be to store regression data elsewhere and access it using DataDeps.jl. This might be especially good if we want more/larger regression tests. And it wouldn't increase the repo size every time you have to change the regression data. We could maybe the store on engaging? Ideally it should be hosted somewhere with near 100% uptime as we're already maintaining Buildkite which fails sometimes, so we should try to reduce the number of possible failure points in our CI pipeline. ---. Copy pasted some analysis below:. I think regression files currently take up ~17.1 MiB of space in the git repo while a fresh clone of the repo is ~43 MiB (images and convergence plots probably take up several MiB). Here's a listing of all files in git history over 300 KiB (command from https://stackoverflow.com/a/42544963):; ```; 018186272590 328KiB test/data_rayleigh_benard_regression_000001100.jld; 19db949aaae8 328KiB test/data_rayleigh_benard_regression_000001000.jld; 424080660c53 328KiB test/data_rayleigh_benard_regression_000001000.jld; a7e1d690d6b5 328KiB test/data_rayleigh_benard_regression_000001100.jld; 72744372e5c4 361KiB test/regression_tests/data/thermal_bubble_regression.nc; 4ce9699176ee 363KiB test/deep_convection_regression_10.nc; c15f95e2bf3a 364KiB test/regression_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086
https://github.com/CliMA/Oceananigans.jl/issues/1086:652,Energy Efficiency,reduce,reduce,652,"Right now regression data takes up a significant amount of space in the repo. I suppose this is not a huge issue as only developers/contributors `git clone` the repo while users can just `] add Oceananigans`. But a potential solution would be to store regression data elsewhere and access it using DataDeps.jl. This might be especially good if we want more/larger regression tests. And it wouldn't increase the repo size every time you have to change the regression data. We could maybe the store on engaging? Ideally it should be hosted somewhere with near 100% uptime as we're already maintaining Buildkite which fails sometimes, so we should try to reduce the number of possible failure points in our CI pipeline. ---. Copy pasted some analysis below:. I think regression files currently take up ~17.1 MiB of space in the git repo while a fresh clone of the repo is ~43 MiB (images and convergence plots probably take up several MiB). Here's a listing of all files in git history over 300 KiB (command from https://stackoverflow.com/a/42544963):; ```; 018186272590 328KiB test/data_rayleigh_benard_regression_000001100.jld; 19db949aaae8 328KiB test/data_rayleigh_benard_regression_000001000.jld; 424080660c53 328KiB test/data_rayleigh_benard_regression_000001000.jld; a7e1d690d6b5 328KiB test/data_rayleigh_benard_regression_000001100.jld; 72744372e5c4 361KiB test/regression_tests/data/thermal_bubble_regression.nc; 4ce9699176ee 363KiB test/deep_convection_regression_10.nc; c15f95e2bf3a 364KiB test/regression_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086
https://github.com/CliMA/Oceananigans.jl/issues/1086:282,Security,access,access,282,"Right now regression data takes up a significant amount of space in the repo. I suppose this is not a huge issue as only developers/contributors `git clone` the repo while users can just `] add Oceananigans`. But a potential solution would be to store regression data elsewhere and access it using DataDeps.jl. This might be especially good if we want more/larger regression tests. And it wouldn't increase the repo size every time you have to change the regression data. We could maybe the store on engaging? Ideally it should be hosted somewhere with near 100% uptime as we're already maintaining Buildkite which fails sometimes, so we should try to reduce the number of possible failure points in our CI pipeline. ---. Copy pasted some analysis below:. I think regression files currently take up ~17.1 MiB of space in the git repo while a fresh clone of the repo is ~43 MiB (images and convergence plots probably take up several MiB). Here's a listing of all files in git history over 300 KiB (command from https://stackoverflow.com/a/42544963):; ```; 018186272590 328KiB test/data_rayleigh_benard_regression_000001100.jld; 19db949aaae8 328KiB test/data_rayleigh_benard_regression_000001000.jld; 424080660c53 328KiB test/data_rayleigh_benard_regression_000001000.jld; a7e1d690d6b5 328KiB test/data_rayleigh_benard_regression_000001100.jld; 72744372e5c4 361KiB test/regression_tests/data/thermal_bubble_regression.nc; 4ce9699176ee 363KiB test/deep_convection_regression_10.nc; c15f95e2bf3a 364KiB test/regression_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086
https://github.com/CliMA/Oceananigans.jl/issues/1086:375,Testability,test,tests,375,"Right now regression data takes up a significant amount of space in the repo. I suppose this is not a huge issue as only developers/contributors `git clone` the repo while users can just `] add Oceananigans`. But a potential solution would be to store regression data elsewhere and access it using DataDeps.jl. This might be especially good if we want more/larger regression tests. And it wouldn't increase the repo size every time you have to change the regression data. We could maybe the store on engaging? Ideally it should be hosted somewhere with near 100% uptime as we're already maintaining Buildkite which fails sometimes, so we should try to reduce the number of possible failure points in our CI pipeline. ---. Copy pasted some analysis below:. I think regression files currently take up ~17.1 MiB of space in the git repo while a fresh clone of the repo is ~43 MiB (images and convergence plots probably take up several MiB). Here's a listing of all files in git history over 300 KiB (command from https://stackoverflow.com/a/42544963):; ```; 018186272590 328KiB test/data_rayleigh_benard_regression_000001100.jld; 19db949aaae8 328KiB test/data_rayleigh_benard_regression_000001000.jld; 424080660c53 328KiB test/data_rayleigh_benard_regression_000001000.jld; a7e1d690d6b5 328KiB test/data_rayleigh_benard_regression_000001100.jld; 72744372e5c4 361KiB test/regression_tests/data/thermal_bubble_regression.nc; 4ce9699176ee 363KiB test/deep_convection_regression_10.nc; c15f95e2bf3a 364KiB test/regression_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086
https://github.com/CliMA/Oceananigans.jl/issues/1086:1075,Testability,test,test,1075," I suppose this is not a huge issue as only developers/contributors `git clone` the repo while users can just `] add Oceananigans`. But a potential solution would be to store regression data elsewhere and access it using DataDeps.jl. This might be especially good if we want more/larger regression tests. And it wouldn't increase the repo size every time you have to change the regression data. We could maybe the store on engaging? Ideally it should be hosted somewhere with near 100% uptime as we're already maintaining Buildkite which fails sometimes, so we should try to reduce the number of possible failure points in our CI pipeline. ---. Copy pasted some analysis below:. I think regression files currently take up ~17.1 MiB of space in the git repo while a fresh clone of the repo is ~43 MiB (images and convergence plots probably take up several MiB). Here's a listing of all files in git history over 300 KiB (command from https://stackoverflow.com/a/42544963):; ```; 018186272590 328KiB test/data_rayleigh_benard_regression_000001100.jld; 19db949aaae8 328KiB test/data_rayleigh_benard_regression_000001000.jld; 424080660c53 328KiB test/data_rayleigh_benard_regression_000001000.jld; a7e1d690d6b5 328KiB test/data_rayleigh_benard_regression_000001100.jld; 72744372e5c4 361KiB test/regression_tests/data/thermal_bubble_regression.nc; 4ce9699176ee 363KiB test/deep_convection_regression_10.nc; c15f95e2bf3a 364KiB test/regression_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0de880b2b97b 468KiB docs/src/verification/plots_stratified_couette_flow_strat",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086
https://github.com/CliMA/Oceananigans.jl/issues/1086:1147,Testability,test,test,1147,"he repo while users can just `] add Oceananigans`. But a potential solution would be to store regression data elsewhere and access it using DataDeps.jl. This might be especially good if we want more/larger regression tests. And it wouldn't increase the repo size every time you have to change the regression data. We could maybe the store on engaging? Ideally it should be hosted somewhere with near 100% uptime as we're already maintaining Buildkite which fails sometimes, so we should try to reduce the number of possible failure points in our CI pipeline. ---. Copy pasted some analysis below:. I think regression files currently take up ~17.1 MiB of space in the git repo while a fresh clone of the repo is ~43 MiB (images and convergence plots probably take up several MiB). Here's a listing of all files in git history over 300 KiB (command from https://stackoverflow.com/a/42544963):; ```; 018186272590 328KiB test/data_rayleigh_benard_regression_000001100.jld; 19db949aaae8 328KiB test/data_rayleigh_benard_regression_000001000.jld; 424080660c53 328KiB test/data_rayleigh_benard_regression_000001000.jld; a7e1d690d6b5 328KiB test/data_rayleigh_benard_regression_000001100.jld; 72744372e5c4 361KiB test/regression_tests/data/thermal_bubble_regression.nc; 4ce9699176ee 363KiB test/deep_convection_regression_10.nc; c15f95e2bf3a 364KiB test/regression_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0de880b2b97b 468KiB docs/src/verification/plots_stratified_couette_flow_stratified_couette_flow_velocity_temperature_slices.png; d277a4e5393b 650KiB test/regr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086
https://github.com/CliMA/Oceananigans.jl/issues/1086:1219,Testability,test,test,1219,"ion would be to store regression data elsewhere and access it using DataDeps.jl. This might be especially good if we want more/larger regression tests. And it wouldn't increase the repo size every time you have to change the regression data. We could maybe the store on engaging? Ideally it should be hosted somewhere with near 100% uptime as we're already maintaining Buildkite which fails sometimes, so we should try to reduce the number of possible failure points in our CI pipeline. ---. Copy pasted some analysis below:. I think regression files currently take up ~17.1 MiB of space in the git repo while a fresh clone of the repo is ~43 MiB (images and convergence plots probably take up several MiB). Here's a listing of all files in git history over 300 KiB (command from https://stackoverflow.com/a/42544963):; ```; 018186272590 328KiB test/data_rayleigh_benard_regression_000001100.jld; 19db949aaae8 328KiB test/data_rayleigh_benard_regression_000001000.jld; 424080660c53 328KiB test/data_rayleigh_benard_regression_000001000.jld; a7e1d690d6b5 328KiB test/data_rayleigh_benard_regression_000001100.jld; 72744372e5c4 361KiB test/regression_tests/data/thermal_bubble_regression.nc; 4ce9699176ee 363KiB test/deep_convection_regression_10.nc; c15f95e2bf3a 364KiB test/regression_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0de880b2b97b 468KiB docs/src/verification/plots_stratified_couette_flow_stratified_couette_flow_velocity_temperature_slices.png; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086
https://github.com/CliMA/Oceananigans.jl/issues/1086:1291,Testability,test,test,1291,"Deps.jl. This might be especially good if we want more/larger regression tests. And it wouldn't increase the repo size every time you have to change the regression data. We could maybe the store on engaging? Ideally it should be hosted somewhere with near 100% uptime as we're already maintaining Buildkite which fails sometimes, so we should try to reduce the number of possible failure points in our CI pipeline. ---. Copy pasted some analysis below:. I think regression files currently take up ~17.1 MiB of space in the git repo while a fresh clone of the repo is ~43 MiB (images and convergence plots probably take up several MiB). Here's a listing of all files in git history over 300 KiB (command from https://stackoverflow.com/a/42544963):; ```; 018186272590 328KiB test/data_rayleigh_benard_regression_000001100.jld; 19db949aaae8 328KiB test/data_rayleigh_benard_regression_000001000.jld; 424080660c53 328KiB test/data_rayleigh_benard_regression_000001000.jld; a7e1d690d6b5 328KiB test/data_rayleigh_benard_regression_000001100.jld; 72744372e5c4 361KiB test/regression_tests/data/thermal_bubble_regression.nc; 4ce9699176ee 363KiB test/deep_convection_regression_10.nc; c15f95e2bf3a 364KiB test/regression_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0de880b2b97b 468KiB docs/src/verification/plots_stratified_couette_flow_stratified_couette_flow_velocity_temperature_slices.png; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAni",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086
https://github.com/CliMA/Oceananigans.jl/issues/1086:1363,Testability,test,test,1363,"sts. And it wouldn't increase the repo size every time you have to change the regression data. We could maybe the store on engaging? Ideally it should be hosted somewhere with near 100% uptime as we're already maintaining Buildkite which fails sometimes, so we should try to reduce the number of possible failure points in our CI pipeline. ---. Copy pasted some analysis below:. I think regression files currently take up ~17.1 MiB of space in the git repo while a fresh clone of the repo is ~43 MiB (images and convergence plots probably take up several MiB). Here's a listing of all files in git history over 300 KiB (command from https://stackoverflow.com/a/42544963):; ```; 018186272590 328KiB test/data_rayleigh_benard_regression_000001100.jld; 19db949aaae8 328KiB test/data_rayleigh_benard_regression_000001000.jld; 424080660c53 328KiB test/data_rayleigh_benard_regression_000001000.jld; a7e1d690d6b5 328KiB test/data_rayleigh_benard_regression_000001100.jld; 72744372e5c4 361KiB test/regression_tests/data/thermal_bubble_regression.nc; 4ce9699176ee 363KiB test/deep_convection_regression_10.nc; c15f95e2bf3a 364KiB test/regression_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0de880b2b97b 468KiB docs/src/verification/plots_stratified_couette_flow_stratified_couette_flow_velocity_temperature_slices.png; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086
https://github.com/CliMA/Oceananigans.jl/issues/1086:1440,Testability,test,test,1440,"hange the regression data. We could maybe the store on engaging? Ideally it should be hosted somewhere with near 100% uptime as we're already maintaining Buildkite which fails sometimes, so we should try to reduce the number of possible failure points in our CI pipeline. ---. Copy pasted some analysis below:. I think regression files currently take up ~17.1 MiB of space in the git repo while a fresh clone of the repo is ~43 MiB (images and convergence plots probably take up several MiB). Here's a listing of all files in git history over 300 KiB (command from https://stackoverflow.com/a/42544963):; ```; 018186272590 328KiB test/data_rayleigh_benard_regression_000001100.jld; 19db949aaae8 328KiB test/data_rayleigh_benard_regression_000001000.jld; 424080660c53 328KiB test/data_rayleigh_benard_regression_000001000.jld; a7e1d690d6b5 328KiB test/data_rayleigh_benard_regression_000001100.jld; 72744372e5c4 361KiB test/regression_tests/data/thermal_bubble_regression.nc; 4ce9699176ee 363KiB test/deep_convection_regression_10.nc; c15f95e2bf3a 364KiB test/regression_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0de880b2b97b 468KiB docs/src/verification/plots_stratified_couette_flow_stratified_couette_flow_velocity_temperature_slices.png; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086
https://github.com/CliMA/Oceananigans.jl/issues/1086:1499,Testability,test,test,1499,"ally it should be hosted somewhere with near 100% uptime as we're already maintaining Buildkite which fails sometimes, so we should try to reduce the number of possible failure points in our CI pipeline. ---. Copy pasted some analysis below:. I think regression files currently take up ~17.1 MiB of space in the git repo while a fresh clone of the repo is ~43 MiB (images and convergence plots probably take up several MiB). Here's a listing of all files in git history over 300 KiB (command from https://stackoverflow.com/a/42544963):; ```; 018186272590 328KiB test/data_rayleigh_benard_regression_000001100.jld; 19db949aaae8 328KiB test/data_rayleigh_benard_regression_000001000.jld; 424080660c53 328KiB test/data_rayleigh_benard_regression_000001000.jld; a7e1d690d6b5 328KiB test/data_rayleigh_benard_regression_000001100.jld; 72744372e5c4 361KiB test/regression_tests/data/thermal_bubble_regression.nc; 4ce9699176ee 363KiB test/deep_convection_regression_10.nc; c15f95e2bf3a 364KiB test/regression_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0de880b2b97b 468KiB docs/src/verification/plots_stratified_couette_flow_stratified_couette_flow_velocity_temperature_slices.png; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086
https://github.com/CliMA/Oceananigans.jl/issues/1086:2149,Testability,test,test,2149,benard_regression_000001000.jld; 424080660c53 328KiB test/data_rayleigh_benard_regression_000001000.jld; a7e1d690d6b5 328KiB test/data_rayleigh_benard_regression_000001100.jld; 72744372e5c4 361KiB test/regression_tests/data/thermal_bubble_regression.nc; 4ce9699176ee 363KiB test/deep_convection_regression_10.nc; c15f95e2bf3a 364KiB test/regression_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0de880b2b97b 468KiB docs/src/verification/plots_stratified_couette_flow_stratified_couette_flow_velocity_temperature_slices.png; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9879b0da29c0 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; c170cc80cd64 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/reg,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086
https://github.com/CliMA/Oceananigans.jl/issues/1086:2234,Testability,test,test,2234,a7e1d690d6b5 328KiB test/data_rayleigh_benard_regression_000001100.jld; 72744372e5c4 361KiB test/regression_tests/data/thermal_bubble_regression.nc; 4ce9699176ee 363KiB test/deep_convection_regression_10.nc; c15f95e2bf3a 364KiB test/regression_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0de880b2b97b 468KiB docs/src/verification/plots_stratified_couette_flow_stratified_couette_flow_velocity_temperature_slices.png; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9879b0da29c0 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; c170cc80cd64 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayl,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086
https://github.com/CliMA/Oceananigans.jl/issues/1086:2361,Testability,test,test,2361,bubble_regression.nc; 4ce9699176ee 363KiB test/deep_convection_regression_10.nc; c15f95e2bf3a 364KiB test/regression_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0de880b2b97b 468KiB docs/src/verification/plots_stratified_couette_flow_stratified_couette_flow_velocity_temperature_slices.png; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9879b0da29c0 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; c170cc80cd64 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_ite,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086
https://github.com/CliMA/Oceananigans.jl/issues/1086:2488,Testability,test,test,2488,_tests/data/thermal_bubble_regression.nc; 6f28044e3b56 366KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0de880b2b97b 468KiB docs/src/verification/plots_stratified_couette_flow_stratified_couette_flow_velocity_temperature_slices.png; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9879b0da29c0 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; c170cc80cd64 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_itera,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086
https://github.com/CliMA/Oceananigans.jl/issues/1086:2592,Testability,test,test,2592,ussian_advection_diffusion_error_convergence.png; 194fdf47099b 392KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0de880b2b97b 468KiB docs/src/verification/plots_stratified_couette_flow_stratified_couette_flow_velocity_temperature_slices.png; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9879b0da29c0 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; c170cc80cd64 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 3519eeb0dea0 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAni,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086
https://github.com/CliMA/Oceananigans.jl/issues/1086:2696,Testability,test,test,2696,ian_advection_diffusion_error_convergence.png; 2f9d5e8650d7 420KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0de880b2b97b 468KiB docs/src/verification/plots_stratified_couette_flow_stratified_couette_flow_velocity_temperature_slices.png; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9879b0da29c0 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; c170cc80cd64 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 3519eeb0dea0 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; fbf720bf84dc 718KiB test/regression_tests/data/ocean_large_eddy_simu,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086
https://github.com/CliMA/Oceananigans.jl/issues/1086:2823,Testability,test,test,2823,fusion_error_convergence.png; db8f742e7c95 446KiB docs/src/verification/convergence_plots/cosine_advection_diffusion_error_convergence.png; 0de880b2b97b 468KiB docs/src/verification/plots_stratified_couette_flow_stratified_couette_flow_velocity_temperature_slices.png; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9879b0da29c0 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; c170cc80cd64 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 3519eeb0dea0 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; fbf720bf84dc 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 51891abf2cd1 719KiB test/regression_tests/data/ocean_large_,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086
https://github.com/CliMA/Oceananigans.jl/issues/1086:2950,Testability,test,test,2950,_error_convergence.png; 0de880b2b97b 468KiB docs/src/verification/plots_stratified_couette_flow_stratified_couette_flow_velocity_temperature_slices.png; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9879b0da29c0 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; c170cc80cd64 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 3519eeb0dea0 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; fbf720bf84dc 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 51891abf2cd1 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; c48525b35c1b 719KiB test/regression_tests/data/ocean_large_ed,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086
https://github.com/CliMA/Oceananigans.jl/issues/1086:3054,Testability,test,test,3054,ed_couette_flow_velocity_temperature_slices.png; d277a4e5393b 650KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9879b0da29c0 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; c170cc80cd64 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 3519eeb0dea0 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; fbf720bf84dc 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 51891abf2cd1 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; c48525b35c1b 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 41f8e56c345f 719KiB test/regression_tests/data/ocean,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086
https://github.com/CliMA/Oceananigans.jl/issues/1086:3158,Testability,test,test,3158,ta/data_rayleigh_benard_regression.jld2; b125bc6f8e9d 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9879b0da29c0 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; c170cc80cd64 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 3519eeb0dea0 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; fbf720bf84dc 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 51891abf2cd1 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; c48525b35c1b 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 41f8e56c345f 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; a7a57fa8fd,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086
https://github.com/CliMA/Oceananigans.jl/issues/1086:3241,Testability,test,test,3241,data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; f5c1a7736324 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9879b0da29c0 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; c170cc80cd64 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 3519eeb0dea0 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; fbf720bf84dc 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 51891abf2cd1 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; c48525b35c1b 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 41f8e56c345f 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; a7a57fa8fdc7 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotro,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086
https://github.com/CliMA/Oceananigans.jl/issues/1086:3324,Testability,test,test,3324,709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9879b0da29c0 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; c170cc80cd64 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 3519eeb0dea0 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; fbf720bf84dc 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 51891abf2cd1 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; c48525b35c1b 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 41f8e56c345f 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; a7a57fa8fdc7 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 0ee7298c84ad 731KiB test/thermal_bubble_golden_master_m,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086
https://github.com/CliMA/Oceananigans.jl/issues/1086:3437,Testability,test,test,3437, 0b493fa7dd14 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; ad020f12370b 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9879b0da29c0 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; c170cc80cd64 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 3519eeb0dea0 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; fbf720bf84dc 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 51891abf2cd1 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; c48525b35c1b 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 41f8e56c345f 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; a7a57fa8fdc7 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 0ee7298c84ad 731KiB test/thermal_bubble_golden_master_model_checkpoint_10.jld; bddab0c2f590 924KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; 9379,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086
https://github.com/CliMA/Oceananigans.jl/issues/1086:3550,Testability,test,test,3550,test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9879b0da29c0 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; c170cc80cd64 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 3519eeb0dea0 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; fbf720bf84dc 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 51891abf2cd1 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; c48525b35c1b 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 41f8e56c345f 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; a7a57fa8fdc7 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 0ee7298c84ad 731KiB test/thermal_bubble_golden_master_model_checkpoint_10.jld; bddab0c2f590 924KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; 937939cc1ef2 990KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 841a7461932f 1.0MiB docs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086
https://github.com/CliMA/Oceananigans.jl/issues/1086:3686,Testability,test,test,3686,_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10010.jld2; c170cc80cd64 709KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 3519eeb0dea0 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; fbf720bf84dc 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 51891abf2cd1 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; c48525b35c1b 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 41f8e56c345f 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; a7a57fa8fdc7 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 0ee7298c84ad 731KiB test/thermal_bubble_golden_master_model_checkpoint_10.jld; bddab0c2f590 924KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; 937939cc1ef2 990KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 841a7461932f 1.0MiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 061ab36b8d44 1.3MiB docs/src/verification/convergence_pl,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086
https://github.com/CliMA/Oceananigans.jl/issues/1086:3822,Testability,test,test,3822,ean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_10000.jld2; a5a23cbaaace 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 3519eeb0dea0 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; fbf720bf84dc 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 51891abf2cd1 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; c48525b35c1b 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 41f8e56c345f 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; a7a57fa8fdc7 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 0ee7298c84ad 731KiB test/thermal_bubble_golden_master_model_checkpoint_10.jld; bddab0c2f590 924KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; 937939cc1ef2 990KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 841a7461932f 1.0MiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 061ab36b8d44 1.3MiB docs/src/verification/convergence_plots/cosine_advection_diffusion_solutions.png; 2f48fac8a7f5 1.4MiB paper/free_convection_and_baroclinic_instability.png; 7ef3d,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086
https://github.com/CliMA/Oceananigans.jl/issues/1086:3935,Testability,test,test,3935,t/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 3519eeb0dea0 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; fbf720bf84dc 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 51891abf2cd1 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; c48525b35c1b 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 41f8e56c345f 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; a7a57fa8fdc7 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 0ee7298c84ad 731KiB test/thermal_bubble_golden_master_model_checkpoint_10.jld; bddab0c2f590 924KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; 937939cc1ef2 990KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 841a7461932f 1.0MiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 061ab36b8d44 1.3MiB docs/src/verification/convergence_plots/cosine_advection_diffusion_solutions.png; 2f48fac8a7f5 1.4MiB paper/free_convection_and_baroclinic_instability.png; 7ef3d2c84f36 1.4MiB docs/src/verification/convergence_plots/cosine_advection_diffusion_solutions.png; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086
https://github.com/CliMA/Oceananigans.jl/issues/1086:4048,Testability,test,test,4048,t/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 3519eeb0dea0 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; fbf720bf84dc 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 51891abf2cd1 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; c48525b35c1b 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 41f8e56c345f 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; a7a57fa8fdc7 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 0ee7298c84ad 731KiB test/thermal_bubble_golden_master_model_checkpoint_10.jld; bddab0c2f590 924KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; 937939cc1ef2 990KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 841a7461932f 1.0MiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 061ab36b8d44 1.3MiB docs/src/verification/convergence_plots/cosine_advection_diffusion_solutions.png; 2f48fac8a7f5 1.4MiB paper/free_convection_and_baroclinic_instability.png; 7ef3d2c84f36 1.4MiB docs/src/verification/convergence_plots/cosine_advection_diffusion_solutions.png; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086
https://github.com/CliMA/Oceananigans.jl/issues/1086:4184,Testability,test,test,4184,t/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 3519eeb0dea0 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; fbf720bf84dc 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 51891abf2cd1 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; c48525b35c1b 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 41f8e56c345f 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; a7a57fa8fdc7 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 0ee7298c84ad 731KiB test/thermal_bubble_golden_master_model_checkpoint_10.jld; bddab0c2f590 924KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; 937939cc1ef2 990KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 841a7461932f 1.0MiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 061ab36b8d44 1.3MiB docs/src/verification/convergence_plots/cosine_advection_diffusion_solutions.png; 2f48fac8a7f5 1.4MiB paper/free_convection_and_baroclinic_instability.png; 7ef3d2c84f36 1.4MiB docs/src/verification/convergence_plots/cosine_advection_diffusion_solutions.png; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086
https://github.com/CliMA/Oceananigans.jl/issues/1086:4320,Testability,test,test,4320,t/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 3519eeb0dea0 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; fbf720bf84dc 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 51891abf2cd1 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; c48525b35c1b 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 41f8e56c345f 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; a7a57fa8fdc7 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 0ee7298c84ad 731KiB test/thermal_bubble_golden_master_model_checkpoint_10.jld; bddab0c2f590 924KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; 937939cc1ef2 990KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 841a7461932f 1.0MiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 061ab36b8d44 1.3MiB docs/src/verification/convergence_plots/cosine_advection_diffusion_solutions.png; 2f48fac8a7f5 1.4MiB paper/free_convection_and_baroclinic_instability.png; 7ef3d2c84f36 1.4MiB docs/src/verification/convergence_plots/cosine_advection_diffusion_solutions.png; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086
https://github.com/CliMA/Oceananigans.jl/issues/1086:4399,Testability,test,test,4399,t/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10000.jld2; b62c38aea554 709KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_10010.jld2; 9765742b042b 713KiB test/regression_tests/data/rayleigh_benard_iteration1000.jld2; d6932dc59613 713KiB test/regression_tests/data/rayleigh_benard_iteration1100.jld2; 5b796cdfdf8e 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; ba4645921310 718KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 3519eeb0dea0 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; fbf720bf84dc 718KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; 51891abf2cd1 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10010.jld2; c48525b35c1b 719KiB test/regression_tests/data/ocean_large_eddy_simulation_SmagorinskyLilly_iteration10000.jld2; 41f8e56c345f 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10000.jld2; a7a57fa8fdc7 719KiB test/regression_tests/data/ocean_large_eddy_simulation_VerstappenAnisotropicMinimumDissipation_iteration10010.jld2; 0ee7298c84ad 731KiB test/thermal_bubble_golden_master_model_checkpoint_10.jld; bddab0c2f590 924KiB test/regression_tests/data/data_rayleigh_benard_regression.jld2; 937939cc1ef2 990KiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 841a7461932f 1.0MiB docs/src/verification/convergence_plots/gaussian_advection_diffusion_solutions.png; 061ab36b8d44 1.3MiB docs/src/verification/convergence_plots/cosine_advection_diffusion_solutions.png; 2f48fac8a7f5 1.4MiB paper/free_convection_and_baroclinic_instability.png; 7ef3d2c84f36 1.4MiB docs/src/verification/convergence_plots/cosine_advection_diffusion_solutions.png; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1086
https://github.com/CliMA/Oceananigans.jl/issues/1088:104,Energy Efficiency,power,powerful,104,"Using `BenchmarkGroup` from BenchmarkTools.jl, DataFrames.jl, and PrettyTables.jl we can develop a more powerful and elegant benchmarking framework, allowing us to easily perform more benchmarks and compare them. `BenchmarkGroup` is serializable so we can use BSON.jl or JLD2.jl to save multiple benchmarks or suites of benchmarks to disk and collect them afterwards. This would allow us to automate multi-threading benchmarks and run benchmarks for large models that almost fill memory (GPU garbage collection doesn't always seem to free memory in these cases?). Using `BenchmarkGroup` will also allow us to automate benchmarking between branches so we can easily discover performance regressions. Right now I do this manually. Here is a crude first working example: https://github.com/CliMA/Oceananigans.jl/blob/fd6e173042497464d78e4f03f4e850f55171c74a/compressible/benchmarks/benchmark_compressible_model.jl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1088
https://github.com/CliMA/Oceananigans.jl/issues/1088:171,Performance,perform,perform,171,"Using `BenchmarkGroup` from BenchmarkTools.jl, DataFrames.jl, and PrettyTables.jl we can develop a more powerful and elegant benchmarking framework, allowing us to easily perform more benchmarks and compare them. `BenchmarkGroup` is serializable so we can use BSON.jl or JLD2.jl to save multiple benchmarks or suites of benchmarks to disk and collect them afterwards. This would allow us to automate multi-threading benchmarks and run benchmarks for large models that almost fill memory (GPU garbage collection doesn't always seem to free memory in these cases?). Using `BenchmarkGroup` will also allow us to automate benchmarking between branches so we can easily discover performance regressions. Right now I do this manually. Here is a crude first working example: https://github.com/CliMA/Oceananigans.jl/blob/fd6e173042497464d78e4f03f4e850f55171c74a/compressible/benchmarks/benchmark_compressible_model.jl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1088
https://github.com/CliMA/Oceananigans.jl/issues/1088:400,Performance,multi-thread,multi-threading,400,"Using `BenchmarkGroup` from BenchmarkTools.jl, DataFrames.jl, and PrettyTables.jl we can develop a more powerful and elegant benchmarking framework, allowing us to easily perform more benchmarks and compare them. `BenchmarkGroup` is serializable so we can use BSON.jl or JLD2.jl to save multiple benchmarks or suites of benchmarks to disk and collect them afterwards. This would allow us to automate multi-threading benchmarks and run benchmarks for large models that almost fill memory (GPU garbage collection doesn't always seem to free memory in these cases?). Using `BenchmarkGroup` will also allow us to automate benchmarking between branches so we can easily discover performance regressions. Right now I do this manually. Here is a crude first working example: https://github.com/CliMA/Oceananigans.jl/blob/fd6e173042497464d78e4f03f4e850f55171c74a/compressible/benchmarks/benchmark_compressible_model.jl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1088
https://github.com/CliMA/Oceananigans.jl/issues/1088:674,Performance,perform,performance,674,"Using `BenchmarkGroup` from BenchmarkTools.jl, DataFrames.jl, and PrettyTables.jl we can develop a more powerful and elegant benchmarking framework, allowing us to easily perform more benchmarks and compare them. `BenchmarkGroup` is serializable so we can use BSON.jl or JLD2.jl to save multiple benchmarks or suites of benchmarks to disk and collect them afterwards. This would allow us to automate multi-threading benchmarks and run benchmarks for large models that almost fill memory (GPU garbage collection doesn't always seem to free memory in these cases?). Using `BenchmarkGroup` will also allow us to automate benchmarking between branches so we can easily discover performance regressions. Right now I do this manually. Here is a crude first working example: https://github.com/CliMA/Oceananigans.jl/blob/fd6e173042497464d78e4f03f4e850f55171c74a/compressible/benchmarks/benchmark_compressible_model.jl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1088
https://github.com/CliMA/Oceananigans.jl/issues/1088:7,Testability,Benchmark,BenchmarkGroup,7,"Using `BenchmarkGroup` from BenchmarkTools.jl, DataFrames.jl, and PrettyTables.jl we can develop a more powerful and elegant benchmarking framework, allowing us to easily perform more benchmarks and compare them. `BenchmarkGroup` is serializable so we can use BSON.jl or JLD2.jl to save multiple benchmarks or suites of benchmarks to disk and collect them afterwards. This would allow us to automate multi-threading benchmarks and run benchmarks for large models that almost fill memory (GPU garbage collection doesn't always seem to free memory in these cases?). Using `BenchmarkGroup` will also allow us to automate benchmarking between branches so we can easily discover performance regressions. Right now I do this manually. Here is a crude first working example: https://github.com/CliMA/Oceananigans.jl/blob/fd6e173042497464d78e4f03f4e850f55171c74a/compressible/benchmarks/benchmark_compressible_model.jl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1088
https://github.com/CliMA/Oceananigans.jl/issues/1088:28,Testability,Benchmark,BenchmarkTools,28,"Using `BenchmarkGroup` from BenchmarkTools.jl, DataFrames.jl, and PrettyTables.jl we can develop a more powerful and elegant benchmarking framework, allowing us to easily perform more benchmarks and compare them. `BenchmarkGroup` is serializable so we can use BSON.jl or JLD2.jl to save multiple benchmarks or suites of benchmarks to disk and collect them afterwards. This would allow us to automate multi-threading benchmarks and run benchmarks for large models that almost fill memory (GPU garbage collection doesn't always seem to free memory in these cases?). Using `BenchmarkGroup` will also allow us to automate benchmarking between branches so we can easily discover performance regressions. Right now I do this manually. Here is a crude first working example: https://github.com/CliMA/Oceananigans.jl/blob/fd6e173042497464d78e4f03f4e850f55171c74a/compressible/benchmarks/benchmark_compressible_model.jl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1088
https://github.com/CliMA/Oceananigans.jl/issues/1088:125,Testability,benchmark,benchmarking,125,"Using `BenchmarkGroup` from BenchmarkTools.jl, DataFrames.jl, and PrettyTables.jl we can develop a more powerful and elegant benchmarking framework, allowing us to easily perform more benchmarks and compare them. `BenchmarkGroup` is serializable so we can use BSON.jl or JLD2.jl to save multiple benchmarks or suites of benchmarks to disk and collect them afterwards. This would allow us to automate multi-threading benchmarks and run benchmarks for large models that almost fill memory (GPU garbage collection doesn't always seem to free memory in these cases?). Using `BenchmarkGroup` will also allow us to automate benchmarking between branches so we can easily discover performance regressions. Right now I do this manually. Here is a crude first working example: https://github.com/CliMA/Oceananigans.jl/blob/fd6e173042497464d78e4f03f4e850f55171c74a/compressible/benchmarks/benchmark_compressible_model.jl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1088
https://github.com/CliMA/Oceananigans.jl/issues/1088:184,Testability,benchmark,benchmarks,184,"Using `BenchmarkGroup` from BenchmarkTools.jl, DataFrames.jl, and PrettyTables.jl we can develop a more powerful and elegant benchmarking framework, allowing us to easily perform more benchmarks and compare them. `BenchmarkGroup` is serializable so we can use BSON.jl or JLD2.jl to save multiple benchmarks or suites of benchmarks to disk and collect them afterwards. This would allow us to automate multi-threading benchmarks and run benchmarks for large models that almost fill memory (GPU garbage collection doesn't always seem to free memory in these cases?). Using `BenchmarkGroup` will also allow us to automate benchmarking between branches so we can easily discover performance regressions. Right now I do this manually. Here is a crude first working example: https://github.com/CliMA/Oceananigans.jl/blob/fd6e173042497464d78e4f03f4e850f55171c74a/compressible/benchmarks/benchmark_compressible_model.jl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1088
https://github.com/CliMA/Oceananigans.jl/issues/1088:214,Testability,Benchmark,BenchmarkGroup,214,"Using `BenchmarkGroup` from BenchmarkTools.jl, DataFrames.jl, and PrettyTables.jl we can develop a more powerful and elegant benchmarking framework, allowing us to easily perform more benchmarks and compare them. `BenchmarkGroup` is serializable so we can use BSON.jl or JLD2.jl to save multiple benchmarks or suites of benchmarks to disk and collect them afterwards. This would allow us to automate multi-threading benchmarks and run benchmarks for large models that almost fill memory (GPU garbage collection doesn't always seem to free memory in these cases?). Using `BenchmarkGroup` will also allow us to automate benchmarking between branches so we can easily discover performance regressions. Right now I do this manually. Here is a crude first working example: https://github.com/CliMA/Oceananigans.jl/blob/fd6e173042497464d78e4f03f4e850f55171c74a/compressible/benchmarks/benchmark_compressible_model.jl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1088
https://github.com/CliMA/Oceananigans.jl/issues/1088:296,Testability,benchmark,benchmarks,296,"Using `BenchmarkGroup` from BenchmarkTools.jl, DataFrames.jl, and PrettyTables.jl we can develop a more powerful and elegant benchmarking framework, allowing us to easily perform more benchmarks and compare them. `BenchmarkGroup` is serializable so we can use BSON.jl or JLD2.jl to save multiple benchmarks or suites of benchmarks to disk and collect them afterwards. This would allow us to automate multi-threading benchmarks and run benchmarks for large models that almost fill memory (GPU garbage collection doesn't always seem to free memory in these cases?). Using `BenchmarkGroup` will also allow us to automate benchmarking between branches so we can easily discover performance regressions. Right now I do this manually. Here is a crude first working example: https://github.com/CliMA/Oceananigans.jl/blob/fd6e173042497464d78e4f03f4e850f55171c74a/compressible/benchmarks/benchmark_compressible_model.jl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1088
https://github.com/CliMA/Oceananigans.jl/issues/1088:320,Testability,benchmark,benchmarks,320,"Using `BenchmarkGroup` from BenchmarkTools.jl, DataFrames.jl, and PrettyTables.jl we can develop a more powerful and elegant benchmarking framework, allowing us to easily perform more benchmarks and compare them. `BenchmarkGroup` is serializable so we can use BSON.jl or JLD2.jl to save multiple benchmarks or suites of benchmarks to disk and collect them afterwards. This would allow us to automate multi-threading benchmarks and run benchmarks for large models that almost fill memory (GPU garbage collection doesn't always seem to free memory in these cases?). Using `BenchmarkGroup` will also allow us to automate benchmarking between branches so we can easily discover performance regressions. Right now I do this manually. Here is a crude first working example: https://github.com/CliMA/Oceananigans.jl/blob/fd6e173042497464d78e4f03f4e850f55171c74a/compressible/benchmarks/benchmark_compressible_model.jl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1088
https://github.com/CliMA/Oceananigans.jl/issues/1088:416,Testability,benchmark,benchmarks,416,"Using `BenchmarkGroup` from BenchmarkTools.jl, DataFrames.jl, and PrettyTables.jl we can develop a more powerful and elegant benchmarking framework, allowing us to easily perform more benchmarks and compare them. `BenchmarkGroup` is serializable so we can use BSON.jl or JLD2.jl to save multiple benchmarks or suites of benchmarks to disk and collect them afterwards. This would allow us to automate multi-threading benchmarks and run benchmarks for large models that almost fill memory (GPU garbage collection doesn't always seem to free memory in these cases?). Using `BenchmarkGroup` will also allow us to automate benchmarking between branches so we can easily discover performance regressions. Right now I do this manually. Here is a crude first working example: https://github.com/CliMA/Oceananigans.jl/blob/fd6e173042497464d78e4f03f4e850f55171c74a/compressible/benchmarks/benchmark_compressible_model.jl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1088
https://github.com/CliMA/Oceananigans.jl/issues/1088:435,Testability,benchmark,benchmarks,435,"Using `BenchmarkGroup` from BenchmarkTools.jl, DataFrames.jl, and PrettyTables.jl we can develop a more powerful and elegant benchmarking framework, allowing us to easily perform more benchmarks and compare them. `BenchmarkGroup` is serializable so we can use BSON.jl or JLD2.jl to save multiple benchmarks or suites of benchmarks to disk and collect them afterwards. This would allow us to automate multi-threading benchmarks and run benchmarks for large models that almost fill memory (GPU garbage collection doesn't always seem to free memory in these cases?). Using `BenchmarkGroup` will also allow us to automate benchmarking between branches so we can easily discover performance regressions. Right now I do this manually. Here is a crude first working example: https://github.com/CliMA/Oceananigans.jl/blob/fd6e173042497464d78e4f03f4e850f55171c74a/compressible/benchmarks/benchmark_compressible_model.jl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1088
https://github.com/CliMA/Oceananigans.jl/issues/1088:571,Testability,Benchmark,BenchmarkGroup,571,"Using `BenchmarkGroup` from BenchmarkTools.jl, DataFrames.jl, and PrettyTables.jl we can develop a more powerful and elegant benchmarking framework, allowing us to easily perform more benchmarks and compare them. `BenchmarkGroup` is serializable so we can use BSON.jl or JLD2.jl to save multiple benchmarks or suites of benchmarks to disk and collect them afterwards. This would allow us to automate multi-threading benchmarks and run benchmarks for large models that almost fill memory (GPU garbage collection doesn't always seem to free memory in these cases?). Using `BenchmarkGroup` will also allow us to automate benchmarking between branches so we can easily discover performance regressions. Right now I do this manually. Here is a crude first working example: https://github.com/CliMA/Oceananigans.jl/blob/fd6e173042497464d78e4f03f4e850f55171c74a/compressible/benchmarks/benchmark_compressible_model.jl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1088
https://github.com/CliMA/Oceananigans.jl/issues/1088:618,Testability,benchmark,benchmarking,618,"Using `BenchmarkGroup` from BenchmarkTools.jl, DataFrames.jl, and PrettyTables.jl we can develop a more powerful and elegant benchmarking framework, allowing us to easily perform more benchmarks and compare them. `BenchmarkGroup` is serializable so we can use BSON.jl or JLD2.jl to save multiple benchmarks or suites of benchmarks to disk and collect them afterwards. This would allow us to automate multi-threading benchmarks and run benchmarks for large models that almost fill memory (GPU garbage collection doesn't always seem to free memory in these cases?). Using `BenchmarkGroup` will also allow us to automate benchmarking between branches so we can easily discover performance regressions. Right now I do this manually. Here is a crude first working example: https://github.com/CliMA/Oceananigans.jl/blob/fd6e173042497464d78e4f03f4e850f55171c74a/compressible/benchmarks/benchmark_compressible_model.jl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1088
https://github.com/CliMA/Oceananigans.jl/issues/1088:868,Testability,benchmark,benchmarks,868,"Using `BenchmarkGroup` from BenchmarkTools.jl, DataFrames.jl, and PrettyTables.jl we can develop a more powerful and elegant benchmarking framework, allowing us to easily perform more benchmarks and compare them. `BenchmarkGroup` is serializable so we can use BSON.jl or JLD2.jl to save multiple benchmarks or suites of benchmarks to disk and collect them afterwards. This would allow us to automate multi-threading benchmarks and run benchmarks for large models that almost fill memory (GPU garbage collection doesn't always seem to free memory in these cases?). Using `BenchmarkGroup` will also allow us to automate benchmarking between branches so we can easily discover performance regressions. Right now I do this manually. Here is a crude first working example: https://github.com/CliMA/Oceananigans.jl/blob/fd6e173042497464d78e4f03f4e850f55171c74a/compressible/benchmarks/benchmark_compressible_model.jl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1088
https://github.com/CliMA/Oceananigans.jl/issues/1089:38,Performance,load,loaded,38,"We should add a benchmark for a fully loaded model, e.g. WENO-5 + RK3 + multiple passive tracers + TEOS-10(?) + output writing + time averaging + ... With #1088 we can serialize such a `BenchmarkGroup` to disk and compare with results from `benchmark_static_ocean.jl` to automatically generate tables of slowdown values for barebones simulation -> fully loaded simulation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1089
https://github.com/CliMA/Oceananigans.jl/issues/1089:354,Performance,load,loaded,354,"We should add a benchmark for a fully loaded model, e.g. WENO-5 + RK3 + multiple passive tracers + TEOS-10(?) + output writing + time averaging + ... With #1088 we can serialize such a `BenchmarkGroup` to disk and compare with results from `benchmark_static_ocean.jl` to automatically generate tables of slowdown values for barebones simulation -> fully loaded simulation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1089
https://github.com/CliMA/Oceananigans.jl/issues/1089:16,Testability,benchmark,benchmark,16,"We should add a benchmark for a fully loaded model, e.g. WENO-5 + RK3 + multiple passive tracers + TEOS-10(?) + output writing + time averaging + ... With #1088 we can serialize such a `BenchmarkGroup` to disk and compare with results from `benchmark_static_ocean.jl` to automatically generate tables of slowdown values for barebones simulation -> fully loaded simulation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1089
https://github.com/CliMA/Oceananigans.jl/issues/1089:186,Testability,Benchmark,BenchmarkGroup,186,"We should add a benchmark for a fully loaded model, e.g. WENO-5 + RK3 + multiple passive tracers + TEOS-10(?) + output writing + time averaging + ... With #1088 we can serialize such a `BenchmarkGroup` to disk and compare with results from `benchmark_static_ocean.jl` to automatically generate tables of slowdown values for barebones simulation -> fully loaded simulation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1089
https://github.com/CliMA/Oceananigans.jl/pull/1090:241,Availability,checkpoint,checkpoint,241,"This PR adds a new function `interpolate(field, x, y, z)` that interpolates `field` to the physical point `(x, y, z)` using trilinear interpolation. This may be used for Lagrangian particle tracking (X-Ref #511), output on custom grids, and checkpoint restoration onto a new grid. No guarantees when `(x, y, z)` lies outside the domain of the field. I think it interpolates into the halo regions and I can test for this if we think it's important (actually this might be an important case...). Worrying about out of bounds, boundary conditions, extrapolation, etc. could slow down the `interpolate` function so it assumes the input makes sense. I think it's the particle's job to stay within the domain of the field. Output on a new grid is possible via. ```julia; new_field_data = interpolate.(Ref(field), nodes(loc, new_grid, reshape=true)...); ```. or. ```julia; new_field_data = interpolate.(Ref(field), xs, ys, zs); ```. so I did not feel the need to define any new types like `InterpolatedField` or `Interpolator`. @glwagner has pointed out that when restoring onto a new grid, you may want to respect global budgets in which case `interpolate` may not be appropriate for checkpoint restoration and an `integrator` (?) of some kind might be needed to ensure conservation of field quantities (momentum, tracers) via Gaussian quadrature. Is this a problem with linear interpolation though? Seems like linear interpolation should preserve global integrals?. Resolves #975",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1090
https://github.com/CliMA/Oceananigans.jl/pull/1090:576,Availability,down,down,576,"This PR adds a new function `interpolate(field, x, y, z)` that interpolates `field` to the physical point `(x, y, z)` using trilinear interpolation. This may be used for Lagrangian particle tracking (X-Ref #511), output on custom grids, and checkpoint restoration onto a new grid. No guarantees when `(x, y, z)` lies outside the domain of the field. I think it interpolates into the halo regions and I can test for this if we think it's important (actually this might be an important case...). Worrying about out of bounds, boundary conditions, extrapolation, etc. could slow down the `interpolate` function so it assumes the input makes sense. I think it's the particle's job to stay within the domain of the field. Output on a new grid is possible via. ```julia; new_field_data = interpolate.(Ref(field), nodes(loc, new_grid, reshape=true)...); ```. or. ```julia; new_field_data = interpolate.(Ref(field), xs, ys, zs); ```. so I did not feel the need to define any new types like `InterpolatedField` or `Interpolator`. @glwagner has pointed out that when restoring onto a new grid, you may want to respect global budgets in which case `interpolate` may not be appropriate for checkpoint restoration and an `integrator` (?) of some kind might be needed to ensure conservation of field quantities (momentum, tracers) via Gaussian quadrature. Is this a problem with linear interpolation though? Seems like linear interpolation should preserve global integrals?. Resolves #975",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1090
https://github.com/CliMA/Oceananigans.jl/pull/1090:1178,Availability,checkpoint,checkpoint,1178,"This PR adds a new function `interpolate(field, x, y, z)` that interpolates `field` to the physical point `(x, y, z)` using trilinear interpolation. This may be used for Lagrangian particle tracking (X-Ref #511), output on custom grids, and checkpoint restoration onto a new grid. No guarantees when `(x, y, z)` lies outside the domain of the field. I think it interpolates into the halo regions and I can test for this if we think it's important (actually this might be an important case...). Worrying about out of bounds, boundary conditions, extrapolation, etc. could slow down the `interpolate` function so it assumes the input makes sense. I think it's the particle's job to stay within the domain of the field. Output on a new grid is possible via. ```julia; new_field_data = interpolate.(Ref(field), nodes(loc, new_grid, reshape=true)...); ```. or. ```julia; new_field_data = interpolate.(Ref(field), xs, ys, zs); ```. so I did not feel the need to define any new types like `InterpolatedField` or `Interpolator`. @glwagner has pointed out that when restoring onto a new grid, you may want to respect global budgets in which case `interpolate` may not be appropriate for checkpoint restoration and an `integrator` (?) of some kind might be needed to ensure conservation of field quantities (momentum, tracers) via Gaussian quadrature. Is this a problem with linear interpolation though? Seems like linear interpolation should preserve global integrals?. Resolves #975",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1090
https://github.com/CliMA/Oceananigans.jl/pull/1090:1209,Deployability,integrat,integrator,1209,"This PR adds a new function `interpolate(field, x, y, z)` that interpolates `field` to the physical point `(x, y, z)` using trilinear interpolation. This may be used for Lagrangian particle tracking (X-Ref #511), output on custom grids, and checkpoint restoration onto a new grid. No guarantees when `(x, y, z)` lies outside the domain of the field. I think it interpolates into the halo regions and I can test for this if we think it's important (actually this might be an important case...). Worrying about out of bounds, boundary conditions, extrapolation, etc. could slow down the `interpolate` function so it assumes the input makes sense. I think it's the particle's job to stay within the domain of the field. Output on a new grid is possible via. ```julia; new_field_data = interpolate.(Ref(field), nodes(loc, new_grid, reshape=true)...); ```. or. ```julia; new_field_data = interpolate.(Ref(field), xs, ys, zs); ```. so I did not feel the need to define any new types like `InterpolatedField` or `Interpolator`. @glwagner has pointed out that when restoring onto a new grid, you may want to respect global budgets in which case `interpolate` may not be appropriate for checkpoint restoration and an `integrator` (?) of some kind might be needed to ensure conservation of field quantities (momentum, tracers) via Gaussian quadrature. Is this a problem with linear interpolation though? Seems like linear interpolation should preserve global integrals?. Resolves #975",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1090
https://github.com/CliMA/Oceananigans.jl/pull/1090:1209,Integrability,integrat,integrator,1209,"This PR adds a new function `interpolate(field, x, y, z)` that interpolates `field` to the physical point `(x, y, z)` using trilinear interpolation. This may be used for Lagrangian particle tracking (X-Ref #511), output on custom grids, and checkpoint restoration onto a new grid. No guarantees when `(x, y, z)` lies outside the domain of the field. I think it interpolates into the halo regions and I can test for this if we think it's important (actually this might be an important case...). Worrying about out of bounds, boundary conditions, extrapolation, etc. could slow down the `interpolate` function so it assumes the input makes sense. I think it's the particle's job to stay within the domain of the field. Output on a new grid is possible via. ```julia; new_field_data = interpolate.(Ref(field), nodes(loc, new_grid, reshape=true)...); ```. or. ```julia; new_field_data = interpolate.(Ref(field), xs, ys, zs); ```. so I did not feel the need to define any new types like `InterpolatedField` or `Interpolator`. @glwagner has pointed out that when restoring onto a new grid, you may want to respect global budgets in which case `interpolate` may not be appropriate for checkpoint restoration and an `integrator` (?) of some kind might be needed to ensure conservation of field quantities (momentum, tracers) via Gaussian quadrature. Is this a problem with linear interpolation though? Seems like linear interpolation should preserve global integrals?. Resolves #975",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1090
https://github.com/CliMA/Oceananigans.jl/pull/1090:406,Testability,test,test,406,"This PR adds a new function `interpolate(field, x, y, z)` that interpolates `field` to the physical point `(x, y, z)` using trilinear interpolation. This may be used for Lagrangian particle tracking (X-Ref #511), output on custom grids, and checkpoint restoration onto a new grid. No guarantees when `(x, y, z)` lies outside the domain of the field. I think it interpolates into the halo regions and I can test for this if we think it's important (actually this might be an important case...). Worrying about out of bounds, boundary conditions, extrapolation, etc. could slow down the `interpolate` function so it assumes the input makes sense. I think it's the particle's job to stay within the domain of the field. Output on a new grid is possible via. ```julia; new_field_data = interpolate.(Ref(field), nodes(loc, new_grid, reshape=true)...); ```. or. ```julia; new_field_data = interpolate.(Ref(field), xs, ys, zs); ```. so I did not feel the need to define any new types like `InterpolatedField` or `Interpolator`. @glwagner has pointed out that when restoring onto a new grid, you may want to respect global budgets in which case `interpolate` may not be appropriate for checkpoint restoration and an `integrator` (?) of some kind might be needed to ensure conservation of field quantities (momentum, tracers) via Gaussian quadrature. Is this a problem with linear interpolation though? Seems like linear interpolation should preserve global integrals?. Resolves #975",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1090
https://github.com/CliMA/Oceananigans.jl/pull/1091:836,Modifiability,evolve,evolved,836,"This PR adds Lagrangian particle tracking for incompressible models. You construct `LagrangianParticles` by passing in a bunch of x, y, z coordinates as 1D arrays (`xs`, `ys`, `zs`) when constructing an incompressible model:. ```julia; model = IncompressibleModel(grid = grid, ..., particles = LagrangianParticles(x=xs, y=ys, z=zs)); ```. then the particles are advected with the flow at every time step (i.e. online particle advection). If arrays are used for `x`, `y`, `z` then I think you should be able to add/remove/birth/kill/breed/split/combine/beach/teleport/etc. particles at any time since arrays are mutable and the type signature of the `LagrangianParticles` won't change. In a futue PR we might want to add `LagrangianParticles` parameters, forcing functions (?), and callafters so that particle properties can be tracked, evolved, and interacted with tracers to model biogeochemistry (https://github.com/JuliaOcean/PlanktonIndividuals.jl) or play ecological games (https://github.com/ali-ramadhan/lagrangian-microbes). Right now I suppose it only advects particles using forward Euler. Using the model's RK3 for particle advection would double (or triple?) the memory usage of the particle tracker as we would have to store previous tendencies (velocities). I wonder if the accuracy of forward Euler is acceptable for Lagrangian particle tracking. I'm also wondering whether it makes sense to support both forward Euler and RK3 in case you want to advect a huge number of particles and memory is limiting the amount of particles you can track? I guess you can do RK3 or RK4 inside the `advect_particles!` kernel but it would assume that the velocity field is constant between stages. Perhaps a convergence test is needed to answer these questions. I think there are a lot of things that can be done at boundaries (see e.g. https://github.com/OceanParcels/parcels/issues/37, https://github.com/OceanParcels/parcels/issues/47, https://github.com/OceanParcels/parcels/issues/61) so I think ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091
https://github.com/CliMA/Oceananigans.jl/pull/1091:1720,Testability,test,test,1720,"anParticles` parameters, forcing functions (?), and callafters so that particle properties can be tracked, evolved, and interacted with tracers to model biogeochemistry (https://github.com/JuliaOcean/PlanktonIndividuals.jl) or play ecological games (https://github.com/ali-ramadhan/lagrangian-microbes). Right now I suppose it only advects particles using forward Euler. Using the model's RK3 for particle advection would double (or triple?) the memory usage of the particle tracker as we would have to store previous tendencies (velocities). I wonder if the accuracy of forward Euler is acceptable for Lagrangian particle tracking. I'm also wondering whether it makes sense to support both forward Euler and RK3 in case you want to advect a huge number of particles and memory is limiting the amount of particles you can track? I guess you can do RK3 or RK4 inside the `advect_particles!` kernel but it would assume that the velocity field is constant between stages. Perhaps a convergence test is needed to answer these questions. I think there are a lot of things that can be done at boundaries (see e.g. https://github.com/OceanParcels/parcels/issues/37, https://github.com/OceanParcels/parcels/issues/47, https://github.com/OceanParcels/parcels/issues/61) so I think we should pick a decent default and leave other options for future PRs. Right now, periodic dimensions are handled correctly but otherwise if a particle goes through a wall it will be placed back at the wall. This may cause it to get stuck at the wall. cc @suyash @zhenwu0728 Would something like this work for you guys?. TODO:. - [x] Figure out how we want to time step particle advection.; - [x] Decide on a default way of handling boundary conditions.; - [x] Tell NetCDF and JLD2 output writers how to write `LagrangianParticles` locations to disk.; - [x] Test that particle locations are correct after advection. Can test with an analytic solution produced by a constant flow field.; - [x] Write documentation for how to use",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091
https://github.com/CliMA/Oceananigans.jl/pull/1091:2560,Testability,Test,Test,2560,"b.com/JuliaOcean/PlanktonIndividuals.jl) or play ecological games (https://github.com/ali-ramadhan/lagrangian-microbes). Right now I suppose it only advects particles using forward Euler. Using the model's RK3 for particle advection would double (or triple?) the memory usage of the particle tracker as we would have to store previous tendencies (velocities). I wonder if the accuracy of forward Euler is acceptable for Lagrangian particle tracking. I'm also wondering whether it makes sense to support both forward Euler and RK3 in case you want to advect a huge number of particles and memory is limiting the amount of particles you can track? I guess you can do RK3 or RK4 inside the `advect_particles!` kernel but it would assume that the velocity field is constant between stages. Perhaps a convergence test is needed to answer these questions. I think there are a lot of things that can be done at boundaries (see e.g. https://github.com/OceanParcels/parcels/issues/37, https://github.com/OceanParcels/parcels/issues/47, https://github.com/OceanParcels/parcels/issues/61) so I think we should pick a decent default and leave other options for future PRs. Right now, periodic dimensions are handled correctly but otherwise if a particle goes through a wall it will be placed back at the wall. This may cause it to get stuck at the wall. cc @suyash @zhenwu0728 Would something like this work for you guys?. TODO:. - [x] Figure out how we want to time step particle advection.; - [x] Decide on a default way of handling boundary conditions.; - [x] Tell NetCDF and JLD2 output writers how to write `LagrangianParticles` locations to disk.; - [x] Test that particle locations are correct after advection. Can test with an analytic solution produced by a constant flow field.; - [x] Write documentation for how to use Lagrangian particle tracking (add a page to the model setup docs).; - [x] Benchmark Lagrangian particle tracking with 1 - 100,000,000 particles.; - [x] Make cool movie. Resolves #511",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091
https://github.com/CliMA/Oceananigans.jl/pull/1091:2622,Testability,test,test,2622,"b.com/JuliaOcean/PlanktonIndividuals.jl) or play ecological games (https://github.com/ali-ramadhan/lagrangian-microbes). Right now I suppose it only advects particles using forward Euler. Using the model's RK3 for particle advection would double (or triple?) the memory usage of the particle tracker as we would have to store previous tendencies (velocities). I wonder if the accuracy of forward Euler is acceptable for Lagrangian particle tracking. I'm also wondering whether it makes sense to support both forward Euler and RK3 in case you want to advect a huge number of particles and memory is limiting the amount of particles you can track? I guess you can do RK3 or RK4 inside the `advect_particles!` kernel but it would assume that the velocity field is constant between stages. Perhaps a convergence test is needed to answer these questions. I think there are a lot of things that can be done at boundaries (see e.g. https://github.com/OceanParcels/parcels/issues/37, https://github.com/OceanParcels/parcels/issues/47, https://github.com/OceanParcels/parcels/issues/61) so I think we should pick a decent default and leave other options for future PRs. Right now, periodic dimensions are handled correctly but otherwise if a particle goes through a wall it will be placed back at the wall. This may cause it to get stuck at the wall. cc @suyash @zhenwu0728 Would something like this work for you guys?. TODO:. - [x] Figure out how we want to time step particle advection.; - [x] Decide on a default way of handling boundary conditions.; - [x] Tell NetCDF and JLD2 output writers how to write `LagrangianParticles` locations to disk.; - [x] Test that particle locations are correct after advection. Can test with an analytic solution produced by a constant flow field.; - [x] Write documentation for how to use Lagrangian particle tracking (add a page to the model setup docs).; - [x] Benchmark Lagrangian particle tracking with 1 - 100,000,000 particles.; - [x] Make cool movie. Resolves #511",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091
https://github.com/CliMA/Oceananigans.jl/pull/1091:2804,Testability,Benchmark,Benchmark,2804,"b.com/JuliaOcean/PlanktonIndividuals.jl) or play ecological games (https://github.com/ali-ramadhan/lagrangian-microbes). Right now I suppose it only advects particles using forward Euler. Using the model's RK3 for particle advection would double (or triple?) the memory usage of the particle tracker as we would have to store previous tendencies (velocities). I wonder if the accuracy of forward Euler is acceptable for Lagrangian particle tracking. I'm also wondering whether it makes sense to support both forward Euler and RK3 in case you want to advect a huge number of particles and memory is limiting the amount of particles you can track? I guess you can do RK3 or RK4 inside the `advect_particles!` kernel but it would assume that the velocity field is constant between stages. Perhaps a convergence test is needed to answer these questions. I think there are a lot of things that can be done at boundaries (see e.g. https://github.com/OceanParcels/parcels/issues/37, https://github.com/OceanParcels/parcels/issues/47, https://github.com/OceanParcels/parcels/issues/61) so I think we should pick a decent default and leave other options for future PRs. Right now, periodic dimensions are handled correctly but otherwise if a particle goes through a wall it will be placed back at the wall. This may cause it to get stuck at the wall. cc @suyash @zhenwu0728 Would something like this work for you guys?. TODO:. - [x] Figure out how we want to time step particle advection.; - [x] Decide on a default way of handling boundary conditions.; - [x] Tell NetCDF and JLD2 output writers how to write `LagrangianParticles` locations to disk.; - [x] Test that particle locations are correct after advection. Can test with an analytic solution produced by a constant flow field.; - [x] Write documentation for how to use Lagrangian particle tracking (add a page to the model setup docs).; - [x] Benchmark Lagrangian particle tracking with 1 - 100,000,000 particles.; - [x] Make cool movie. Resolves #511",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091
https://github.com/CliMA/Oceananigans.jl/pull/1093:1147,Deployability,update,update,1147,"This PR implements a field-dependent boundary conditions feature. This is an extension to the boundary conditions API that leaves existing functionality unchanged. The functionality is similar to that for `Forcing`. For quadratic bottom stress acting on the `u`-velocity we'd write. ```julia; u_bottom_stress(x, y, t, u, v, Cd) = - Cd * u * sqrt(u^2 + v^2). bottom_bc = BoundaryCondition(Flux, u_bottom_stress, field_dependencies=(:u, :v), parameters=1e-3); ```. Dealing with the wall-normal velocity components is a bit annoying. For now we don't interpolate them, which leads to different behavior at left and right boundaries (due to the fact that the wall-normal index is assumed to refer to cell centers). Right now this is not much of a practical issue --- it would only affect cases in which wall-normal velocities were non-zero _and_ those values were used in boundary conditions on other fields. One solution is to store ""wall-normal"" indices separately for each of the `field_dependencies`. Then we can correctly infer the boundary index in `regularize_boundary_condition` because we know field locations there. We still need to:. - [x] update boundary conditions docs; - [x] see if any examples can be simplified?. Resolves #897",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1093
https://github.com/CliMA/Oceananigans.jl/pull/1093:27,Integrability,depend,dependent,27,"This PR implements a field-dependent boundary conditions feature. This is an extension to the boundary conditions API that leaves existing functionality unchanged. The functionality is similar to that for `Forcing`. For quadratic bottom stress acting on the `u`-velocity we'd write. ```julia; u_bottom_stress(x, y, t, u, v, Cd) = - Cd * u * sqrt(u^2 + v^2). bottom_bc = BoundaryCondition(Flux, u_bottom_stress, field_dependencies=(:u, :v), parameters=1e-3); ```. Dealing with the wall-normal velocity components is a bit annoying. For now we don't interpolate them, which leads to different behavior at left and right boundaries (due to the fact that the wall-normal index is assumed to refer to cell centers). Right now this is not much of a practical issue --- it would only affect cases in which wall-normal velocities were non-zero _and_ those values were used in boundary conditions on other fields. One solution is to store ""wall-normal"" indices separately for each of the `field_dependencies`. Then we can correctly infer the boundary index in `regularize_boundary_condition` because we know field locations there. We still need to:. - [x] update boundary conditions docs; - [x] see if any examples can be simplified?. Resolves #897",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1093
https://github.com/CliMA/Oceananigans.jl/pull/1093:1213,Usability,simpl,simplified,1213,"This PR implements a field-dependent boundary conditions feature. This is an extension to the boundary conditions API that leaves existing functionality unchanged. The functionality is similar to that for `Forcing`. For quadratic bottom stress acting on the `u`-velocity we'd write. ```julia; u_bottom_stress(x, y, t, u, v, Cd) = - Cd * u * sqrt(u^2 + v^2). bottom_bc = BoundaryCondition(Flux, u_bottom_stress, field_dependencies=(:u, :v), parameters=1e-3); ```. Dealing with the wall-normal velocity components is a bit annoying. For now we don't interpolate them, which leads to different behavior at left and right boundaries (due to the fact that the wall-normal index is assumed to refer to cell centers). Right now this is not much of a practical issue --- it would only affect cases in which wall-normal velocities were non-zero _and_ those values were used in boundary conditions on other fields. One solution is to store ""wall-normal"" indices separately for each of the `field_dependencies`. Then we can correctly infer the boundary index in `regularize_boundary_condition` because we know field locations there. We still need to:. - [x] update boundary conditions docs; - [x] see if any examples can be simplified?. Resolves #897",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1093
https://github.com/CliMA/Oceananigans.jl/issues/1095:1882,Energy Efficiency,schedul,scheduling,1882,"run!`. Right now `run!` is barebones. It will take one more argument `pickup` when #1082 is merged. I think `run!` should have more kwargs like `diagnostics`, any of the `stop_criteria`, `Δt`, and `progress`, since these parameters are currently _only_ used in `run!`. We currently require these parameters to be specified in the `Simulation` constructor`:. https://github.com/CliMA/Oceananigans.jl/blob/e1026b08b6489d8fd8bc1d9a1bde591ffbb27251/src/Simulations/simulation.jl#L51-L60. However, I think its better if we encourage them to be set in `run!` where they are used (producing scripts that are more ""locally understandable""). Note that storing these parameters in `Simulation` is really a convenience feature (eg if you want to reference them after using `run!`, you can) rather than essential to how `run!` functions. This would clean up cases where users want to embed `run!` within a loop, because they can then write. ```julia; for i = 1:10; run!(simulation, stop_iteration=model.clock.iteration+10); end; ```. or even (see below). ```julia; for i = 1:10; run!(simulation, stop=Iteration(model.clock.iteration+10)); end; ```. rather than the [slightly more convoluted approach](https://github.com/CliMA/Oceananigans.jl/blob/e1026b08b6489d8fd8bc1d9a1bde591ffbb27251/examples/ocean_convection_with_plankton.jl#L83-L84) (its not a lot of code, but slightly more confusing I think) that is still used in some examples. `run!` might also need a make-over, since I think we should do away with `iteration_interval` and use `AbstractSchedules` for `progress` (or perhaps ""`callafter`"") and the `TimeStepWizard`. We may also want to design `AbstractCriteria` that mirror the design of `AbstractSchedules` for stopping a simulation, so we can have a similar interface for stop criteria as output scheduling, eg something like `stop=SimulationTime(1day)`. I suggest we collect and discussl the extant issues we see with the current design of `Simulation` here. PS do we need `Simulation.parameters`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1095
https://github.com/CliMA/Oceananigans.jl/issues/1095:48,Integrability,interface,interface,48,"I think there's a bit of cleanup to do with the interface to both `Simulation` and `run!`. Right now `run!` is barebones. It will take one more argument `pickup` when #1082 is merged. I think `run!` should have more kwargs like `diagnostics`, any of the `stop_criteria`, `Δt`, and `progress`, since these parameters are currently _only_ used in `run!`. We currently require these parameters to be specified in the `Simulation` constructor`:. https://github.com/CliMA/Oceananigans.jl/blob/e1026b08b6489d8fd8bc1d9a1bde591ffbb27251/src/Simulations/simulation.jl#L51-L60. However, I think its better if we encourage them to be set in `run!` where they are used (producing scripts that are more ""locally understandable""). Note that storing these parameters in `Simulation` is really a convenience feature (eg if you want to reference them after using `run!`, you can) rather than essential to how `run!` functions. This would clean up cases where users want to embed `run!` within a loop, because they can then write. ```julia; for i = 1:10; run!(simulation, stop_iteration=model.clock.iteration+10); end; ```. or even (see below). ```julia; for i = 1:10; run!(simulation, stop=Iteration(model.clock.iteration+10)); end; ```. rather than the [slightly more convoluted approach](https://github.com/CliMA/Oceananigans.jl/blob/e1026b08b6489d8fd8bc1d9a1bde591ffbb27251/examples/ocean_convection_with_plankton.jl#L83-L84) (its not a lot of code, but slightly more confusing I think) that is still used in some examples. `run!` might also need a make-over, since I think we should do away with `iteration_interval` and use `AbstractSchedules` for `progress` (or perhaps ""`callafter`"") and the `TimeStepWizard`. We may also want to design `AbstractCriteria` that mirror the design of `AbstractSchedules` for stopping a simulation, so we can have a similar interface for stop criteria as output scheduling, eg something like `stop=SimulationTime(1day)`. I suggest we collect and discussl the extant issues we see w",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1095
https://github.com/CliMA/Oceananigans.jl/issues/1095:1844,Integrability,interface,interface,1844,"run!`. Right now `run!` is barebones. It will take one more argument `pickup` when #1082 is merged. I think `run!` should have more kwargs like `diagnostics`, any of the `stop_criteria`, `Δt`, and `progress`, since these parameters are currently _only_ used in `run!`. We currently require these parameters to be specified in the `Simulation` constructor`:. https://github.com/CliMA/Oceananigans.jl/blob/e1026b08b6489d8fd8bc1d9a1bde591ffbb27251/src/Simulations/simulation.jl#L51-L60. However, I think its better if we encourage them to be set in `run!` where they are used (producing scripts that are more ""locally understandable""). Note that storing these parameters in `Simulation` is really a convenience feature (eg if you want to reference them after using `run!`, you can) rather than essential to how `run!` functions. This would clean up cases where users want to embed `run!` within a loop, because they can then write. ```julia; for i = 1:10; run!(simulation, stop_iteration=model.clock.iteration+10); end; ```. or even (see below). ```julia; for i = 1:10; run!(simulation, stop=Iteration(model.clock.iteration+10)); end; ```. rather than the [slightly more convoluted approach](https://github.com/CliMA/Oceananigans.jl/blob/e1026b08b6489d8fd8bc1d9a1bde591ffbb27251/examples/ocean_convection_with_plankton.jl#L83-L84) (its not a lot of code, but slightly more confusing I think) that is still used in some examples. `run!` might also need a make-over, since I think we should do away with `iteration_interval` and use `AbstractSchedules` for `progress` (or perhaps ""`callafter`"") and the `TimeStepWizard`. We may also want to design `AbstractCriteria` that mirror the design of `AbstractSchedules` for stopping a simulation, so we can have a similar interface for stop criteria as output scheduling, eg something like `stop=SimulationTime(1day)`. I suggest we collect and discussl the extant issues we see with the current design of `Simulation` here. PS do we need `Simulation.parameters`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1095
https://github.com/CliMA/Oceananigans.jl/issues/1096:118,Modifiability,plugin,plugin,118,Now that https://github.com/ali-ramadhan/DocumenterCitations.jl v0.1.0 has been tagged and is used as a Documenter.jl plugin we should switch to using it.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1096
https://github.com/CliMA/Oceananigans.jl/issues/1098:686,Security,access,accessible,686,"There's a growing number of users of Oceananigans, and we want share knowledge, share ideas, chat, science together, and maybe even work together. Currently the only way for users to ask questions is by posting an issue to github like this one. . But the issue tracker is _supposedly_ supposed to be used for issues related to the source code and code development. Other questions like:. * Why is my code slow?; * How do I implement my science idea?; * What does Oceananigans _mean_?; * Why is @navidcy so passionate about documentation?. don't have a place to be asked except for, perhaps, emailing developers and other normal humans directly. But unfortunately private emails are not accessible to all, and thus knowledge is lost or not disseminated. We do now have a channel on the julia slack:. https://julialang.slack.com/archives/C01D24C0CAH. which may, or may not, suffice for now.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1098
https://github.com/CliMA/Oceananigans.jl/pull/1099:292,Integrability,Depend,Depends,292,"Some of the examples had typos and incorrect comments. Also, some of the plotting is improved now that we know beautiful plots means `contourf` with `linewidth=0`. I added a few features to some of the examples, most notably `AveragedField`. Finally, we now always visualize in post-process. Depends on #1093, since that PR beautifies a few of the examples as well with field-dependent boundary conditions. Resolves #676",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1099
https://github.com/CliMA/Oceananigans.jl/pull/1099:376,Integrability,depend,dependent,376,"Some of the examples had typos and incorrect comments. Also, some of the plotting is improved now that we know beautiful plots means `contourf` with `linewidth=0`. I added a few features to some of the examples, most notably `AveragedField`. Finally, we now always visualize in post-process. Depends on #1093, since that PR beautifies a few of the examples as well with field-dependent boundary conditions. Resolves #676",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1099
https://github.com/CliMA/Oceananigans.jl/issues/1100:115,Testability,test,testing,115,"Does it make sense to aim for 100% code coverage (by some metric)? Maybe not until v1.0.0 as it would increase the testing burden and tests need to be maintained. 100% line coverage shouldn't be too hard to achieve. 100% [MC/DC coverage](https://en.wikipedia.org/wiki/Modified_condition/decision_coverage) would be much harder, and I'm not sure whether it would benefit a package like Oceananigans.jl. Presumably 100% physics coverage is what we want. Although not sure how to quantify % here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1100
https://github.com/CliMA/Oceananigans.jl/issues/1100:134,Testability,test,tests,134,"Does it make sense to aim for 100% code coverage (by some metric)? Maybe not until v1.0.0 as it would increase the testing burden and tests need to be maintained. 100% line coverage shouldn't be too hard to achieve. 100% [MC/DC coverage](https://en.wikipedia.org/wiki/Modified_condition/decision_coverage) would be much harder, and I'm not sure whether it would benefit a package like Oceananigans.jl. Presumably 100% physics coverage is what we want. Although not sure how to quantify % here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1100
https://github.com/CliMA/Oceananigans.jl/issues/1101:163,Availability,redundant,redundant,163,"Should probably add a note on citing Oceananigans.jl to the README and docs. A lot of other packages do this. Would also make the ""Development team"" section kinda redundant so we could remove it then.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1101
https://github.com/CliMA/Oceananigans.jl/issues/1101:163,Safety,redund,redundant,163,"Should probably add a note on citing Oceananigans.jl to the README and docs. A lot of other packages do this. Would also make the ""Development team"" section kinda redundant so we could remove it then.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1101
https://github.com/CliMA/Oceananigans.jl/pull/1102:421,Availability,down,downstream,421,"This pull request sets the compat entry for the `Glob` package to `1.3`. This is a brand new compat entry. Previously, you did not have a compat entry for the `Glob` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1102
https://github.com/CliMA/Oceananigans.jl/pull/1102:369,Deployability,patch,patch,369,"This pull request sets the compat entry for the `Glob` package to `1.3`. This is a brand new compat entry. Previously, you did not have a compat entry for the `Glob` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1102
https://github.com/CliMA/Oceananigans.jl/pull/1102:375,Deployability,release,release,375,"This pull request sets the compat entry for the `Glob` package to `1.3`. This is a brand new compat entry. Previously, you did not have a compat entry for the `Glob` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1102
https://github.com/CliMA/Oceananigans.jl/pull/1102:445,Integrability,depend,depend,445,"This pull request sets the compat entry for the `Glob` package to `1.3`. This is a brand new compat entry. Previously, you did not have a compat entry for the `Glob` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1102
https://github.com/CliMA/Oceananigans.jl/pull/1102:192,Testability,test,tested,192,"This pull request sets the compat entry for the `Glob` package to `1.3`. This is a brand new compat entry. Previously, you did not have a compat entry for the `Glob` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1102
https://github.com/CliMA/Oceananigans.jl/pull/1102:297,Testability,test,tests,297,"This pull request sets the compat entry for the `Glob` package to `1.3`. This is a brand new compat entry. Previously, you did not have a compat entry for the `Glob` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1102
https://github.com/CliMA/Oceananigans.jl/pull/1102:464,Testability,test,tests,464,"This pull request sets the compat entry for the `Glob` package to `1.3`. This is a brand new compat entry. Previously, you did not have a compat entry for the `Glob` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1102
https://github.com/CliMA/Oceananigans.jl/pull/1103:110,Availability,checkpoint,checkpoint,110,"To be merged once #1093 and #1099 are in. Release notes:. * Adds support for ""picking up"" a simulation from a checkpoint via the keyword `pickup=true`, `pickup=checkpoint_iteration::Int` and `pickup=checkpont_filepath::String` in `run!(simulation)` (#1082). * Adds a function `set!(model, checkpoint_filepath)` for ""setting"" a model state to the state recorded in a checkpoint file (#1082). * Adds support for ""field-dependent"" boundary conditions similar to field-dependent forcing terms (#1093). * Beautifies and cleans up many of the examples, including getting them to build faster on Travis (#1099)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1103
https://github.com/CliMA/Oceananigans.jl/pull/1103:366,Availability,checkpoint,checkpoint,366,"To be merged once #1093 and #1099 are in. Release notes:. * Adds support for ""picking up"" a simulation from a checkpoint via the keyword `pickup=true`, `pickup=checkpoint_iteration::Int` and `pickup=checkpont_filepath::String` in `run!(simulation)` (#1082). * Adds a function `set!(model, checkpoint_filepath)` for ""setting"" a model state to the state recorded in a checkpoint file (#1082). * Adds support for ""field-dependent"" boundary conditions similar to field-dependent forcing terms (#1093). * Beautifies and cleans up many of the examples, including getting them to build faster on Travis (#1099)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1103
https://github.com/CliMA/Oceananigans.jl/pull/1103:42,Deployability,Release,Release,42,"To be merged once #1093 and #1099 are in. Release notes:. * Adds support for ""picking up"" a simulation from a checkpoint via the keyword `pickup=true`, `pickup=checkpoint_iteration::Int` and `pickup=checkpont_filepath::String` in `run!(simulation)` (#1082). * Adds a function `set!(model, checkpoint_filepath)` for ""setting"" a model state to the state recorded in a checkpoint file (#1082). * Adds support for ""field-dependent"" boundary conditions similar to field-dependent forcing terms (#1093). * Beautifies and cleans up many of the examples, including getting them to build faster on Travis (#1099)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1103
https://github.com/CliMA/Oceananigans.jl/pull/1103:417,Integrability,depend,dependent,417,"To be merged once #1093 and #1099 are in. Release notes:. * Adds support for ""picking up"" a simulation from a checkpoint via the keyword `pickup=true`, `pickup=checkpoint_iteration::Int` and `pickup=checkpont_filepath::String` in `run!(simulation)` (#1082). * Adds a function `set!(model, checkpoint_filepath)` for ""setting"" a model state to the state recorded in a checkpoint file (#1082). * Adds support for ""field-dependent"" boundary conditions similar to field-dependent forcing terms (#1093). * Beautifies and cleans up many of the examples, including getting them to build faster on Travis (#1099)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1103
https://github.com/CliMA/Oceananigans.jl/pull/1103:465,Integrability,depend,dependent,465,"To be merged once #1093 and #1099 are in. Release notes:. * Adds support for ""picking up"" a simulation from a checkpoint via the keyword `pickup=true`, `pickup=checkpoint_iteration::Int` and `pickup=checkpont_filepath::String` in `run!(simulation)` (#1082). * Adds a function `set!(model, checkpoint_filepath)` for ""setting"" a model state to the state recorded in a checkpoint file (#1082). * Adds support for ""field-dependent"" boundary conditions similar to field-dependent forcing terms (#1093). * Beautifies and cleans up many of the examples, including getting them to build faster on Travis (#1099)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1103
https://github.com/CliMA/Oceananigans.jl/issues/1104:37,Availability,error,error,37,"@mukund-gupta reported the following error:. ```; [ Info: Oceananigans will use 16 threads; [ Info: Starting the simulation...; [ Info: i: 0010, t: 1.667 minutes, Δt: 10 seconds; ERROR: LoadError: MethodError: no method matching isless(::typeof(depth_dependent_κ), ::typeof(depth_dependent_κ)); Closest candidates are:; isless(!Matched::Missing, ::Any) at missing.jl:87; isless(::Any, !Matched::Missing) at missing.jl:88; Stacktrace:; [1] max(::Function, ::Function) at ./operators.jl:417; [2] BottomRF at ./reduce.jl:81 [inlined]; [3] _foldl_impl(::Base.BottomRF{typeof(max)}, ::Base._InitialValue, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:62; [4] foldl_impl(::Base.BottomRF{typeof(max)}, ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:48; [5] mapfoldl_impl(::typeof(identity), ::typeof(max), ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:44; [6] mapfoldl(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}; kw::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at ./reduce.jl:160; [7] mapfoldl at ./reduce.jl:160 [inlined]; [8] #mapreduce#208 at ./reduce.jl:287 [inlined]; [9] mapreduce(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:287; [10] maximum(::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:652; [11] cell_diffusion_timescale(::AnisotropicDiffusivity{Int64,Int64,typeof(depth_dependent_κ),NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}}, ::Tuple{Nothing,Nothing}, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRange",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1104
https://github.com/CliMA/Oceananigans.jl/issues/1104:179,Availability,ERROR,ERROR,179,"@mukund-gupta reported the following error:. ```; [ Info: Oceananigans will use 16 threads; [ Info: Starting the simulation...; [ Info: i: 0010, t: 1.667 minutes, Δt: 10 seconds; ERROR: LoadError: MethodError: no method matching isless(::typeof(depth_dependent_κ), ::typeof(depth_dependent_κ)); Closest candidates are:; isless(!Matched::Missing, ::Any) at missing.jl:87; isless(::Any, !Matched::Missing) at missing.jl:88; Stacktrace:; [1] max(::Function, ::Function) at ./operators.jl:417; [2] BottomRF at ./reduce.jl:81 [inlined]; [3] _foldl_impl(::Base.BottomRF{typeof(max)}, ::Base._InitialValue, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:62; [4] foldl_impl(::Base.BottomRF{typeof(max)}, ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:48; [5] mapfoldl_impl(::typeof(identity), ::typeof(max), ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:44; [6] mapfoldl(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}; kw::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at ./reduce.jl:160; [7] mapfoldl at ./reduce.jl:160 [inlined]; [8] #mapreduce#208 at ./reduce.jl:287 [inlined]; [9] mapreduce(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:287; [10] maximum(::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:652; [11] cell_diffusion_timescale(::AnisotropicDiffusivity{Int64,Int64,typeof(depth_dependent_κ),NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}}, ::Tuple{Nothing,Nothing}, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRange",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1104
https://github.com/CliMA/Oceananigans.jl/issues/1104:508,Energy Efficiency,reduce,reduce,508,"@mukund-gupta reported the following error:. ```; [ Info: Oceananigans will use 16 threads; [ Info: Starting the simulation...; [ Info: i: 0010, t: 1.667 minutes, Δt: 10 seconds; ERROR: LoadError: MethodError: no method matching isless(::typeof(depth_dependent_κ), ::typeof(depth_dependent_κ)); Closest candidates are:; isless(!Matched::Missing, ::Any) at missing.jl:87; isless(::Any, !Matched::Missing) at missing.jl:88; Stacktrace:; [1] max(::Function, ::Function) at ./operators.jl:417; [2] BottomRF at ./reduce.jl:81 [inlined]; [3] _foldl_impl(::Base.BottomRF{typeof(max)}, ::Base._InitialValue, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:62; [4] foldl_impl(::Base.BottomRF{typeof(max)}, ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:48; [5] mapfoldl_impl(::typeof(identity), ::typeof(max), ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:44; [6] mapfoldl(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}; kw::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at ./reduce.jl:160; [7] mapfoldl at ./reduce.jl:160 [inlined]; [8] #mapreduce#208 at ./reduce.jl:287 [inlined]; [9] mapreduce(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:287; [10] maximum(::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:652; [11] cell_diffusion_timescale(::AnisotropicDiffusivity{Int64,Int64,typeof(depth_dependent_κ),NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}}, ::Tuple{Nothing,Nothing}, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRange",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1104
https://github.com/CliMA/Oceananigans.jl/issues/1104:688,Energy Efficiency,reduce,reduce,688,"@mukund-gupta reported the following error:. ```; [ Info: Oceananigans will use 16 threads; [ Info: Starting the simulation...; [ Info: i: 0010, t: 1.667 minutes, Δt: 10 seconds; ERROR: LoadError: MethodError: no method matching isless(::typeof(depth_dependent_κ), ::typeof(depth_dependent_κ)); Closest candidates are:; isless(!Matched::Missing, ::Any) at missing.jl:87; isless(::Any, !Matched::Missing) at missing.jl:88; Stacktrace:; [1] max(::Function, ::Function) at ./operators.jl:417; [2] BottomRF at ./reduce.jl:81 [inlined]; [3] _foldl_impl(::Base.BottomRF{typeof(max)}, ::Base._InitialValue, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:62; [4] foldl_impl(::Base.BottomRF{typeof(max)}, ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:48; [5] mapfoldl_impl(::typeof(identity), ::typeof(max), ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:44; [6] mapfoldl(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}; kw::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at ./reduce.jl:160; [7] mapfoldl at ./reduce.jl:160 [inlined]; [8] #mapreduce#208 at ./reduce.jl:287 [inlined]; [9] mapreduce(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:287; [10] maximum(::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:652; [11] cell_diffusion_timescale(::AnisotropicDiffusivity{Int64,Int64,typeof(depth_dependent_κ),NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}}, ::Tuple{Nothing,Nothing}, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRange",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1104
https://github.com/CliMA/Oceananigans.jl/issues/1104:861,Energy Efficiency,reduce,reduce,861,"@mukund-gupta reported the following error:. ```; [ Info: Oceananigans will use 16 threads; [ Info: Starting the simulation...; [ Info: i: 0010, t: 1.667 minutes, Δt: 10 seconds; ERROR: LoadError: MethodError: no method matching isless(::typeof(depth_dependent_κ), ::typeof(depth_dependent_κ)); Closest candidates are:; isless(!Matched::Missing, ::Any) at missing.jl:87; isless(::Any, !Matched::Missing) at missing.jl:88; Stacktrace:; [1] max(::Function, ::Function) at ./operators.jl:417; [2] BottomRF at ./reduce.jl:81 [inlined]; [3] _foldl_impl(::Base.BottomRF{typeof(max)}, ::Base._InitialValue, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:62; [4] foldl_impl(::Base.BottomRF{typeof(max)}, ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:48; [5] mapfoldl_impl(::typeof(identity), ::typeof(max), ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:44; [6] mapfoldl(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}; kw::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at ./reduce.jl:160; [7] mapfoldl at ./reduce.jl:160 [inlined]; [8] #mapreduce#208 at ./reduce.jl:287 [inlined]; [9] mapreduce(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:287; [10] maximum(::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:652; [11] cell_diffusion_timescale(::AnisotropicDiffusivity{Int64,Int64,typeof(depth_dependent_κ),NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}}, ::Tuple{Nothing,Nothing}, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRange",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1104
https://github.com/CliMA/Oceananigans.jl/issues/1104:1042,Energy Efficiency,reduce,reduce,1042,"```; [ Info: Oceananigans will use 16 threads; [ Info: Starting the simulation...; [ Info: i: 0010, t: 1.667 minutes, Δt: 10 seconds; ERROR: LoadError: MethodError: no method matching isless(::typeof(depth_dependent_κ), ::typeof(depth_dependent_κ)); Closest candidates are:; isless(!Matched::Missing, ::Any) at missing.jl:87; isless(::Any, !Matched::Missing) at missing.jl:88; Stacktrace:; [1] max(::Function, ::Function) at ./operators.jl:417; [2] BottomRF at ./reduce.jl:81 [inlined]; [3] _foldl_impl(::Base.BottomRF{typeof(max)}, ::Base._InitialValue, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:62; [4] foldl_impl(::Base.BottomRF{typeof(max)}, ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:48; [5] mapfoldl_impl(::typeof(identity), ::typeof(max), ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:44; [6] mapfoldl(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}; kw::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at ./reduce.jl:160; [7] mapfoldl at ./reduce.jl:160 [inlined]; [8] #mapreduce#208 at ./reduce.jl:287 [inlined]; [9] mapreduce(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:287; [10] maximum(::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:652; [11] cell_diffusion_timescale(::AnisotropicDiffusivity{Int64,Int64,typeof(depth_dependent_κ),NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}}, ::Tuple{Nothing,Nothing}, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Bas",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1104
https://github.com/CliMA/Oceananigans.jl/issues/1104:1255,Energy Efficiency,reduce,reduce,1255,"nt_κ), ::typeof(depth_dependent_κ)); Closest candidates are:; isless(!Matched::Missing, ::Any) at missing.jl:87; isless(::Any, !Matched::Missing) at missing.jl:88; Stacktrace:; [1] max(::Function, ::Function) at ./operators.jl:417; [2] BottomRF at ./reduce.jl:81 [inlined]; [3] _foldl_impl(::Base.BottomRF{typeof(max)}, ::Base._InitialValue, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:62; [4] foldl_impl(::Base.BottomRF{typeof(max)}, ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:48; [5] mapfoldl_impl(::typeof(identity), ::typeof(max), ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:44; [6] mapfoldl(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}; kw::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at ./reduce.jl:160; [7] mapfoldl at ./reduce.jl:160 [inlined]; [8] #mapreduce#208 at ./reduce.jl:287 [inlined]; [9] mapreduce(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:287; [10] maximum(::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:652; [11] cell_diffusion_timescale(::AnisotropicDiffusivity{Int64,Int64,typeof(depth_dependent_κ),NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}}, ::Tuple{Nothing,Nothing}, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}) at /home/guptam/.julia/packages/Oceananigans/nKAWY/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:43; [12] (::Oceananigans.TurbulenceClosures.var""#37#38""{Tuple{Nothing,Nothi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1104
https://github.com/CliMA/Oceananigans.jl/issues/1104:1288,Energy Efficiency,reduce,reduce,1288,")); Closest candidates are:; isless(!Matched::Missing, ::Any) at missing.jl:87; isless(::Any, !Matched::Missing) at missing.jl:88; Stacktrace:; [1] max(::Function, ::Function) at ./operators.jl:417; [2] BottomRF at ./reduce.jl:81 [inlined]; [3] _foldl_impl(::Base.BottomRF{typeof(max)}, ::Base._InitialValue, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:62; [4] foldl_impl(::Base.BottomRF{typeof(max)}, ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:48; [5] mapfoldl_impl(::typeof(identity), ::typeof(max), ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:44; [6] mapfoldl(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}; kw::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at ./reduce.jl:160; [7] mapfoldl at ./reduce.jl:160 [inlined]; [8] #mapreduce#208 at ./reduce.jl:287 [inlined]; [9] mapreduce(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:287; [10] maximum(::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:652; [11] cell_diffusion_timescale(::AnisotropicDiffusivity{Int64,Int64,typeof(depth_dependent_κ),NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}}, ::Tuple{Nothing,Nothing}, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}) at /home/guptam/.julia/packages/Oceananigans/nKAWY/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:43; [12] (::Oceananigans.TurbulenceClosures.var""#37#38""{Tuple{Nothing,Nothing},RegularCartesianGrid{Float64,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1104
https://github.com/CliMA/Oceananigans.jl/issues/1104:1337,Energy Efficiency,reduce,reduce,1337,"sing, ::Any) at missing.jl:87; isless(::Any, !Matched::Missing) at missing.jl:88; Stacktrace:; [1] max(::Function, ::Function) at ./operators.jl:417; [2] BottomRF at ./reduce.jl:81 [inlined]; [3] _foldl_impl(::Base.BottomRF{typeof(max)}, ::Base._InitialValue, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:62; [4] foldl_impl(::Base.BottomRF{typeof(max)}, ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:48; [5] mapfoldl_impl(::typeof(identity), ::typeof(max), ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:44; [6] mapfoldl(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}; kw::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at ./reduce.jl:160; [7] mapfoldl at ./reduce.jl:160 [inlined]; [8] #mapreduce#208 at ./reduce.jl:287 [inlined]; [9] mapreduce(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:287; [10] maximum(::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:652; [11] cell_diffusion_timescale(::AnisotropicDiffusivity{Int64,Int64,typeof(depth_dependent_κ),NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}}, ::Tuple{Nothing,Nothing}, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}) at /home/guptam/.julia/packages/Oceananigans/nKAWY/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:43; [12] (::Oceananigans.TurbulenceClosures.var""#37#38""{Tuple{Nothing,Nothing},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArra",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1104
https://github.com/CliMA/Oceananigans.jl/issues/1104:1488,Energy Efficiency,reduce,reduce,1488,"2] BottomRF at ./reduce.jl:81 [inlined]; [3] _foldl_impl(::Base.BottomRF{typeof(max)}, ::Base._InitialValue, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:62; [4] foldl_impl(::Base.BottomRF{typeof(max)}, ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:48; [5] mapfoldl_impl(::typeof(identity), ::typeof(max), ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:44; [6] mapfoldl(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}; kw::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at ./reduce.jl:160; [7] mapfoldl at ./reduce.jl:160 [inlined]; [8] #mapreduce#208 at ./reduce.jl:287 [inlined]; [9] mapreduce(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:287; [10] maximum(::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:652; [11] cell_diffusion_timescale(::AnisotropicDiffusivity{Int64,Int64,typeof(depth_dependent_κ),NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}}, ::Tuple{Nothing,Nothing}, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}) at /home/guptam/.julia/packages/Oceananigans/nKAWY/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:43; [12] (::Oceananigans.TurbulenceClosures.var""#37#38""{Tuple{Nothing,Nothing},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}})(::AnisotropicDiffusivity{Int64,Int64,typeof(depth_depen",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1104
https://github.com/CliMA/Oceananigans.jl/issues/1104:1604,Energy Efficiency,reduce,reduce,1604,"Tuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:62; [4] foldl_impl(::Base.BottomRF{typeof(max)}, ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:48; [5] mapfoldl_impl(::typeof(identity), ::typeof(max), ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:44; [6] mapfoldl(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}; kw::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at ./reduce.jl:160; [7] mapfoldl at ./reduce.jl:160 [inlined]; [8] #mapreduce#208 at ./reduce.jl:287 [inlined]; [9] mapreduce(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:287; [10] maximum(::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:652; [11] cell_diffusion_timescale(::AnisotropicDiffusivity{Int64,Int64,typeof(depth_dependent_κ),NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}}, ::Tuple{Nothing,Nothing}, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}) at /home/guptam/.julia/packages/Oceananigans/nKAWY/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:43; [12] (::Oceananigans.TurbulenceClosures.var""#37#38""{Tuple{Nothing,Nothing},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}})(::AnisotropicDiffusivity{Int64,Int64,typeof(depth_dependent_κ),NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{ty",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1104
https://github.com/CliMA/Oceananigans.jl/issues/1104:11798,Modifiability,Parameteriz,ParameterizedDiscreteBoundaryFunction,11798,",Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Cell,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Oceananigans.BoundaryConditions.ParameterizedDiscreteBoundaryFunction{typeof(circular_salinity_flux),NamedTuple{(:melt_rate, :xb, :yb, :Rb),NTuple{4,Float64}}}}}}}}}},NamedTuple{(:pHY′, :pNHS),Tuple{Field{Cell,Cell,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Cell,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePreci",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1104
https://github.com/CliMA/Oceananigans.jl/issues/1104:22360,Modifiability,Parameteriz,ParameterizedDiscreteBoundaryFunction,22360,",Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Cell,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Oceananigans.BoundaryConditions.ParameterizedDiscreteBoundaryFunction{typeof(circular_salinity_flux),NamedTuple{(:melt_rate, :xb, :yb, :Rb),NTuple{4,Float64}}}}}}}}}},NamedTuple{(:pHY′, :pNHS),Tuple{Field{Cell,Cell,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Cell,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePreci",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1104
https://github.com/CliMA/Oceananigans.jl/issues/1104:186,Performance,Load,LoadError,186,"@mukund-gupta reported the following error:. ```; [ Info: Oceananigans will use 16 threads; [ Info: Starting the simulation...; [ Info: i: 0010, t: 1.667 minutes, Δt: 10 seconds; ERROR: LoadError: MethodError: no method matching isless(::typeof(depth_dependent_κ), ::typeof(depth_dependent_κ)); Closest candidates are:; isless(!Matched::Missing, ::Any) at missing.jl:87; isless(::Any, !Matched::Missing) at missing.jl:88; Stacktrace:; [1] max(::Function, ::Function) at ./operators.jl:417; [2] BottomRF at ./reduce.jl:81 [inlined]; [3] _foldl_impl(::Base.BottomRF{typeof(max)}, ::Base._InitialValue, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:62; [4] foldl_impl(::Base.BottomRF{typeof(max)}, ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:48; [5] mapfoldl_impl(::typeof(identity), ::typeof(max), ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:44; [6] mapfoldl(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}; kw::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at ./reduce.jl:160; [7] mapfoldl at ./reduce.jl:160 [inlined]; [8] #mapreduce#208 at ./reduce.jl:287 [inlined]; [9] mapreduce(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:287; [10] maximum(::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:652; [11] cell_diffusion_timescale(::AnisotropicDiffusivity{Int64,Int64,typeof(depth_dependent_κ),NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}}, ::Tuple{Nothing,Nothing}, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRange",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1104
https://github.com/CliMA/Oceananigans.jl/issues/1104:25643,Performance,Load,Loaded,25643,"ditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T, :S),NTuple{5,typeof(Oceananigans.Forcings.zeroforcing)}},CenteredFourthOrder,Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,CPU,NamedTuple{(:kx², :ky², :kz²),Tuple{Array{Float64,3},Array{Float64,3},Array{Float64,3}}},Array{Complex{Float64},3},NamedTuple{(:FFTxy!, :DCTz!, :IFFTxy!, :IDCTz!),Tuple{FFTW.cFFTWPlan{Complex{Float64},-1,true,3,Array{Int64,1}},FFTW.r2rFFTWPlan{Complex{Float64},(5,),true,3,Int64},AbstractFFTs.ScaledPlan{Complex{Float64},FFTW.cFFTWPlan{Complex{Float64},1,true,3,Array{Int64,1}},Float64},FFTW.r2rFFTWPlan{Complex{Float64},(4,),true,3,Int64}}},Nothing},Tuple{Nothing,Nothing},NamedTuple{(:velocities, :tracers),Tuple{NamedTuple{(:u, :v, :w),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}},NamedTuple{(:T, :S),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}}}}},TimeStepWizard{Float64},Array{Any,1},Float64,Int64,Float64,Float64,OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractDiagnostic},OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractOutputWriter},typeof(progress),Int64,Nothing}) at /home/guptam/.julia/packages/Oceananigans/nKAWY/src/Simulations/run.jl:102; [21] top-level scope at /central/home/guptam/ocean_floes/turb-closures/expt/biharmonic_1e5_4thOrder_kappaV_profile1_Z_2p5.jl:135; [22] include(::Function, ::Module, ::String) at ./Base.jl:380; [23] include(::Module, ::String) at ./Base.jl:368; [24] exec_options(::Base.JLOptions) at ./client.jl:296; [25] _start() at ./client.jl:506; in expression starting at /central/home/guptam/ocean_floes/turb-closures/expt/biharmonic_1e5_4thOrder_kappaV_profile1_Z_2p5.jl:135; Loaded all modules; ```. which occurs because `TimeStepWizard` doesn't know how to compute the maximum diffusivity when diffusivity is a function (it shouldn't even try!)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1104
https://github.com/CliMA/Oceananigans.jl/pull/1105:156,Energy Efficiency,power,powerful,156,"@mukund-gupta discovered a bug (see #1104) that prevents the use of function diffusivities with the `TimeStepWizard`. We don't want the wizard to be so all-powerful that it samples a diffusivity function over the whole grid just to compute it's maximum value. So, this PR does the simple thing and avoids limiting the time-step by the diffusivity when it's a function. A better solution would require users to explicitly ask their time-step to be limited by diffusivities, and for that step to fail when the diffusivity is a function (eg #1087). It could make sense to add a test for all possible combinations of diffusivities and wizards, but it might be better to wait for a more comprehensive PR that addresses #1087... Resolves #1104",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1105
https://github.com/CliMA/Oceananigans.jl/pull/1105:298,Safety,avoid,avoids,298,"@mukund-gupta discovered a bug (see #1104) that prevents the use of function diffusivities with the `TimeStepWizard`. We don't want the wizard to be so all-powerful that it samples a diffusivity function over the whole grid just to compute it's maximum value. So, this PR does the simple thing and avoids limiting the time-step by the diffusivity when it's a function. A better solution would require users to explicitly ask their time-step to be limited by diffusivities, and for that step to fail when the diffusivity is a function (eg #1087). It could make sense to add a test for all possible combinations of diffusivities and wizards, but it might be better to wait for a more comprehensive PR that addresses #1087... Resolves #1104",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1105
https://github.com/CliMA/Oceananigans.jl/pull/1105:575,Testability,test,test,575,"@mukund-gupta discovered a bug (see #1104) that prevents the use of function diffusivities with the `TimeStepWizard`. We don't want the wizard to be so all-powerful that it samples a diffusivity function over the whole grid just to compute it's maximum value. So, this PR does the simple thing and avoids limiting the time-step by the diffusivity when it's a function. A better solution would require users to explicitly ask their time-step to be limited by diffusivities, and for that step to fail when the diffusivity is a function (eg #1087). It could make sense to add a test for all possible combinations of diffusivities and wizards, but it might be better to wait for a more comprehensive PR that addresses #1087... Resolves #1104",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1105
https://github.com/CliMA/Oceananigans.jl/pull/1105:281,Usability,simpl,simple,281,"@mukund-gupta discovered a bug (see #1104) that prevents the use of function diffusivities with the `TimeStepWizard`. We don't want the wizard to be so all-powerful that it samples a diffusivity function over the whole grid just to compute it's maximum value. So, this PR does the simple thing and avoids limiting the time-step by the diffusivity when it's a function. A better solution would require users to explicitly ask their time-step to be limited by diffusivities, and for that step to fail when the diffusivity is a function (eg #1087). It could make sense to add a test for all possible combinations of diffusivities and wizards, but it might be better to wait for a more comprehensive PR that addresses #1087... Resolves #1104",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1105
https://github.com/CliMA/Oceananigans.jl/pull/1108:398,Integrability,contract,contracts,398,"I guess we agreed to make this change a while back after reading [Oreskes et al. (1994)](https://doi.org/10.1126/science.263.5147.641). On verification vs. validation:. > In contrast to the term verification, the term validation does not necessarily denote an establishment of truth (although truth is not precluded). Rather, it denotes the establishment of legitimacy, typically given in terms of contracts, arguments, and methods. We have some convergence tests which should fall under _validation experiments_ as well. Oreskes et al. (1994) comment on the fact that comparison of analytical vs. numerical solutions for Earth science models is an exercise in validation as e.g. users of Oceananigans.jl intend to model the real ocean (no analytical solutions) and not necessarily the Boussinesq equations.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1108
https://github.com/CliMA/Oceananigans.jl/pull/1108:156,Security,validat,validation,156,"I guess we agreed to make this change a while back after reading [Oreskes et al. (1994)](https://doi.org/10.1126/science.263.5147.641). On verification vs. validation:. > In contrast to the term verification, the term validation does not necessarily denote an establishment of truth (although truth is not precluded). Rather, it denotes the establishment of legitimacy, typically given in terms of contracts, arguments, and methods. We have some convergence tests which should fall under _validation experiments_ as well. Oreskes et al. (1994) comment on the fact that comparison of analytical vs. numerical solutions for Earth science models is an exercise in validation as e.g. users of Oceananigans.jl intend to model the real ocean (no analytical solutions) and not necessarily the Boussinesq equations.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1108
https://github.com/CliMA/Oceananigans.jl/pull/1108:218,Security,validat,validation,218,"I guess we agreed to make this change a while back after reading [Oreskes et al. (1994)](https://doi.org/10.1126/science.263.5147.641). On verification vs. validation:. > In contrast to the term verification, the term validation does not necessarily denote an establishment of truth (although truth is not precluded). Rather, it denotes the establishment of legitimacy, typically given in terms of contracts, arguments, and methods. We have some convergence tests which should fall under _validation experiments_ as well. Oreskes et al. (1994) comment on the fact that comparison of analytical vs. numerical solutions for Earth science models is an exercise in validation as e.g. users of Oceananigans.jl intend to model the real ocean (no analytical solutions) and not necessarily the Boussinesq equations.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1108
https://github.com/CliMA/Oceananigans.jl/pull/1108:661,Security,validat,validation,661,"I guess we agreed to make this change a while back after reading [Oreskes et al. (1994)](https://doi.org/10.1126/science.263.5147.641). On verification vs. validation:. > In contrast to the term verification, the term validation does not necessarily denote an establishment of truth (although truth is not precluded). Rather, it denotes the establishment of legitimacy, typically given in terms of contracts, arguments, and methods. We have some convergence tests which should fall under _validation experiments_ as well. Oreskes et al. (1994) comment on the fact that comparison of analytical vs. numerical solutions for Earth science models is an exercise in validation as e.g. users of Oceananigans.jl intend to model the real ocean (no analytical solutions) and not necessarily the Boussinesq equations.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1108
https://github.com/CliMA/Oceananigans.jl/pull/1108:458,Testability,test,tests,458,"I guess we agreed to make this change a while back after reading [Oreskes et al. (1994)](https://doi.org/10.1126/science.263.5147.641). On verification vs. validation:. > In contrast to the term verification, the term validation does not necessarily denote an establishment of truth (although truth is not precluded). Rather, it denotes the establishment of legitimacy, typically given in terms of contracts, arguments, and methods. We have some convergence tests which should fall under _validation experiments_ as well. Oreskes et al. (1994) comment on the fact that comparison of analytical vs. numerical solutions for Earth science models is an exercise in validation as e.g. users of Oceananigans.jl intend to model the real ocean (no analytical solutions) and not necessarily the Boussinesq equations.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1108
https://github.com/CliMA/Oceananigans.jl/issues/1111:254,Deployability,update,update,254,"We never made one. Might be good to do some advertising, point to the examples, and say it's ready for research use. https://discourse.julialang.org/c/community/packages/47. TODO (by @glwagner):. * [ ] stabilze JLD2OutputWriter API (resolve #963); * [ ] update README (resolve #961); * [ ] a few more cool movies (we can just pluck from current projects, eg eady turbulence, boundary layer turbulence, Andre’s); * [ ] YouTube channel for the movies?; * [ ] More benchmarks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1111
https://github.com/CliMA/Oceananigans.jl/issues/1111:462,Testability,benchmark,benchmarks,462,"We never made one. Might be good to do some advertising, point to the examples, and say it's ready for research use. https://discourse.julialang.org/c/community/packages/47. TODO (by @glwagner):. * [ ] stabilze JLD2OutputWriter API (resolve #963); * [ ] update README (resolve #961); * [ ] a few more cool movies (we can just pluck from current projects, eg eady turbulence, boundary layer turbulence, Andre’s); * [ ] YouTube channel for the movies?; * [ ] More benchmarks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1111
https://github.com/CliMA/Oceananigans.jl/issues/1113:68,Testability,benchmark,benchmarks,68,Super easy fix. Suggested by @vchuravy. Should rerun multithreading benchmarks after this.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1113
https://github.com/CliMA/Oceananigans.jl/issues/1116:330,Modifiability,refactor,refactoring,330,"https://painterqubits.github.io/Unitful.jl/stable/. The obvious use case would be to replace the units (e.g. `minutes` and `years`) in `Oceananigans.Utils` with ""proper units"" from Unitful.jl. Not sure if we want to use it absolutely everywhere. Would be cool and there should be no performance hit, but might take quite a bit of refactoring. Could also be useful for defining constants in examples and scripts? Might be cool to play around with it a bit. Apparently @alanedelman is gonna be making fun of us for not using it.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1116
https://github.com/CliMA/Oceananigans.jl/issues/1116:283,Performance,perform,performance,283,"https://painterqubits.github.io/Unitful.jl/stable/. The obvious use case would be to replace the units (e.g. `minutes` and `years`) in `Oceananigans.Utils` with ""proper units"" from Unitful.jl. Not sure if we want to use it absolutely everywhere. Would be cool and there should be no performance hit, but might take quite a bit of refactoring. Could also be useful for defining constants in examples and scripts? Might be cool to play around with it a bit. Apparently @alanedelman is gonna be making fun of us for not using it.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1116
https://github.com/CliMA/Oceananigans.jl/issues/1118:137,Availability,error,error,137,"Passing `architecture = CPU` instead of `architecture = CPU()` when constructing an `IncompressibleModel` can produce a rather punishing error message as @glwagner and I found out with @vchuravy. Would be very easy to do a quick check for this and save future users the potential headache. ```; ERROR: LoadError: type NamedTuple has no field grid; Stacktrace:; [1] getbc at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/BoundaryConditions/field_boundary_conditions.jl:199 [inlined]; [2] getproperty at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/BoundaryConditions/field_boundary_conditions.jl:197 [inlined]; [3] topology at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/Fields/abstract_field.jl:117 [inlined]; [4] topology(::NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Float64}}}}, ::Int64) at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/Grids/Grids.jl:81; [5] NamedTuple{(:x, :y, :z),T} where T<:Tuple(::NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Float64}}}}, ::Tuple{DataType,DataType,DataType}) at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/BoundaryConditions/field_boundary_conditions.jl:85; [6] UVelocityBoundaryConditions(::NamedTuple{(:x, :y",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1118
https://github.com/CliMA/Oceananigans.jl/issues/1118:295,Availability,ERROR,ERROR,295,"Passing `architecture = CPU` instead of `architecture = CPU()` when constructing an `IncompressibleModel` can produce a rather punishing error message as @glwagner and I found out with @vchuravy. Would be very easy to do a quick check for this and save future users the potential headache. ```; ERROR: LoadError: type NamedTuple has no field grid; Stacktrace:; [1] getbc at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/BoundaryConditions/field_boundary_conditions.jl:199 [inlined]; [2] getproperty at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/BoundaryConditions/field_boundary_conditions.jl:197 [inlined]; [3] topology at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/Fields/abstract_field.jl:117 [inlined]; [4] topology(::NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Float64}}}}, ::Int64) at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/Grids/Grids.jl:81; [5] NamedTuple{(:x, :y, :z),T} where T<:Tuple(::NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Float64}}}}, ::Tuple{DataType,DataType,DataType}) at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/BoundaryConditions/field_boundary_conditions.jl:85; [6] UVelocityBoundaryConditions(::NamedTuple{(:x, :y",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1118
https://github.com/CliMA/Oceananigans.jl/issues/1118:143,Integrability,message,message,143,"Passing `architecture = CPU` instead of `architecture = CPU()` when constructing an `IncompressibleModel` can produce a rather punishing error message as @glwagner and I found out with @vchuravy. Would be very easy to do a quick check for this and save future users the potential headache. ```; ERROR: LoadError: type NamedTuple has no field grid; Stacktrace:; [1] getbc at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/BoundaryConditions/field_boundary_conditions.jl:199 [inlined]; [2] getproperty at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/BoundaryConditions/field_boundary_conditions.jl:197 [inlined]; [3] topology at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/Fields/abstract_field.jl:117 [inlined]; [4] topology(::NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Float64}}}}, ::Int64) at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/Grids/Grids.jl:81; [5] NamedTuple{(:x, :y, :z),T} where T<:Tuple(::NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Float64}}}}, ::Tuple{DataType,DataType,DataType}) at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/BoundaryConditions/field_boundary_conditions.jl:85; [6] UVelocityBoundaryConditions(::NamedTuple{(:x, :y",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1118
https://github.com/CliMA/Oceananigans.jl/issues/1118:302,Performance,Load,LoadError,302,"Passing `architecture = CPU` instead of `architecture = CPU()` when constructing an `IncompressibleModel` can produce a rather punishing error message as @glwagner and I found out with @vchuravy. Would be very easy to do a quick check for this and save future users the potential headache. ```; ERROR: LoadError: type NamedTuple has no field grid; Stacktrace:; [1] getbc at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/BoundaryConditions/field_boundary_conditions.jl:199 [inlined]; [2] getproperty at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/BoundaryConditions/field_boundary_conditions.jl:197 [inlined]; [3] topology at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/Fields/abstract_field.jl:117 [inlined]; [4] topology(::NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Float64}}}}, ::Int64) at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/Grids/Grids.jl:81; [5] NamedTuple{(:x, :y, :z),T} where T<:Tuple(::NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Float64}}}}, ::Tuple{DataType,DataType,DataType}) at /home/vchuravy/.julia/packages/Oceananigans/IbUoB/src/BoundaryConditions/field_boundary_conditions.jl:85; [6] UVelocityBoundaryConditions(::NamedTuple{(:x, :y",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1118
https://github.com/CliMA/Oceananigans.jl/issues/1119:834,Availability,robust,robust,834,"More of a general issue that #1118 made me think about is that we've been mixing data types and instantiated types. For example, we use data types when constructing grid topologies and specifying locations for abstract operations:. ```julia; topology = (Periodic, Bounded, Bounded); kinetic_energy @at (Cell, Cell, Cell) (u^2 + v^2) / 2; ```. but instantiated types when specifying which architecture and advection scheme to use. ```julia; model = IncompressibleModel(grid=grid, architecture=GPU(), advection=WENO5()); ```. It seems there's some element of memorization to know which one to use when. Maybe this will confuse future users (certainly it confused us in #1118). Changing this behavior would require a lot of refactoring but probably worth discussing whether changing makes sense or if we can make the user interface more robust and friendly to mismatches between data types and instantiated types?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1119
https://github.com/CliMA/Oceananigans.jl/issues/1119:819,Integrability,interface,interface,819,"More of a general issue that #1118 made me think about is that we've been mixing data types and instantiated types. For example, we use data types when constructing grid topologies and specifying locations for abstract operations:. ```julia; topology = (Periodic, Bounded, Bounded); kinetic_energy @at (Cell, Cell, Cell) (u^2 + v^2) / 2; ```. but instantiated types when specifying which architecture and advection scheme to use. ```julia; model = IncompressibleModel(grid=grid, architecture=GPU(), advection=WENO5()); ```. It seems there's some element of memorization to know which one to use when. Maybe this will confuse future users (certainly it confused us in #1118). Changing this behavior would require a lot of refactoring but probably worth discussing whether changing makes sense or if we can make the user interface more robust and friendly to mismatches between data types and instantiated types?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1119
https://github.com/CliMA/Oceananigans.jl/issues/1119:721,Modifiability,refactor,refactoring,721,"More of a general issue that #1118 made me think about is that we've been mixing data types and instantiated types. For example, we use data types when constructing grid topologies and specifying locations for abstract operations:. ```julia; topology = (Periodic, Bounded, Bounded); kinetic_energy @at (Cell, Cell, Cell) (u^2 + v^2) / 2; ```. but instantiated types when specifying which architecture and advection scheme to use. ```julia; model = IncompressibleModel(grid=grid, architecture=GPU(), advection=WENO5()); ```. It seems there's some element of memorization to know which one to use when. Maybe this will confuse future users (certainly it confused us in #1118). Changing this behavior would require a lot of refactoring but probably worth discussing whether changing makes sense or if we can make the user interface more robust and friendly to mismatches between data types and instantiated types?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1119
https://github.com/CliMA/Oceananigans.jl/pull/1120:27,Performance,multi-thread,multi-threading,27,Resolves #1113 . Needs new multi-threading benchmarks. Will do as part of #1088 (need to add nice multithreading benchmark script on `ar/benchmarks` branch).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1120
https://github.com/CliMA/Oceananigans.jl/pull/1120:43,Testability,benchmark,benchmarks,43,Resolves #1113 . Needs new multi-threading benchmarks. Will do as part of #1088 (need to add nice multithreading benchmark script on `ar/benchmarks` branch).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1120
https://github.com/CliMA/Oceananigans.jl/pull/1120:113,Testability,benchmark,benchmark,113,Resolves #1113 . Needs new multi-threading benchmarks. Will do as part of #1088 (need to add nice multithreading benchmark script on `ar/benchmarks` branch).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1120
https://github.com/CliMA/Oceananigans.jl/pull/1120:137,Testability,benchmark,benchmarks,137,Resolves #1113 . Needs new multi-threading benchmarks. Will do as part of #1088 (need to add nice multithreading benchmark script on `ar/benchmarks` branch).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1120
https://github.com/CliMA/Oceananigans.jl/pull/1122:209,Energy Efficiency,power,power,209,"This PR contributes a barotropic instability example co-authored with @navidcy . The main contribution of this example is to illustrate how to use Oceananigans to calculate instability growth rates using the ""power"" method. The example illustrates some of the strengths of Oceananigans' flexibility (and also some weaknesses that we might improve on). Ways to make the example more interesting are definitely welcome too! It's also a bit expensive right now, so we'll probably want to find ways to reduce its computational cost.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1122
https://github.com/CliMA/Oceananigans.jl/pull/1122:498,Energy Efficiency,reduce,reduce,498,"This PR contributes a barotropic instability example co-authored with @navidcy . The main contribution of this example is to illustrate how to use Oceananigans to calculate instability growth rates using the ""power"" method. The example illustrates some of the strengths of Oceananigans' flexibility (and also some weaknesses that we might improve on). Ways to make the example more interesting are definitely welcome too! It's also a bit expensive right now, so we'll probably want to find ways to reduce its computational cost.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1122
https://github.com/CliMA/Oceananigans.jl/pull/1123:209,Energy Efficiency,power,power,209,"This PR contributes a barotropic instability example co-authored with @navidcy . The main contribution of this example is to illustrate how to use Oceananigans to calculate instability growth rates using the ""power"" method. The example illustrates some of the strengths of Oceananigans' flexibility (and also some weaknesses that we might improve on). Ways to make the example more interesting are definitely welcome too! It's also a bit expensive right now, so we'll probably want to find ways to reduce its computational cost.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1123
https://github.com/CliMA/Oceananigans.jl/pull/1123:498,Energy Efficiency,reduce,reduce,498,"This PR contributes a barotropic instability example co-authored with @navidcy . The main contribution of this example is to illustrate how to use Oceananigans to calculate instability growth rates using the ""power"" method. The example illustrates some of the strengths of Oceananigans' flexibility (and also some weaknesses that we might improve on). Ways to make the example more interesting are definitely welcome too! It's also a bit expensive right now, so we'll probably want to find ways to reduce its computational cost.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1123
https://github.com/CliMA/Oceananigans.jl/pull/1125:164,Modifiability,evolve,evolves,164,This PR adds an example that computes the linear instability of a vertically shear mean flow profile U(z) accompanied with a sheared buoyancy profile B(z) and then evolves the unstable eigenmode to its nonlinear equilibration. [preview of the docs](https://clima.github.io/OceananigansDocumentation/previews/PR1125/generated/kelvin_helmholtz_instability/),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1125
https://github.com/CliMA/Oceananigans.jl/issues/1127:580,Availability,checkpoint,checkpointing,580,"Interacting with modeling software via scripts is novel for some users. We (and many others) are accumulating knowledge in this area, including:. * Scripting philosophy and its advantages.; * Literate scripting style for ""paper-like"" code, tutorials and pedagogical applications.; * Best practices for parameter exploration (eg how to replicate the functionality of a parameter file or namelist in your script, and why divorcing parameter lists from model setup should be considered carefully).; * Best practices for reproducibility (naming conventions, using output directories, checkpointing, script reuse).; * The use of external packages to achieve these goals (like `ArgParse`, or perhaps `DrWatson`). Oceananigans tries to give users great power and flexibility for designing numerical experiments. However, with this power comes great responsibility for users to write and use their scripts for Good. We can possibly help by adding some documentation. I also think the writers of said documentation might benefit if said documentation stimulates community input / outside contributions to these best practices. cc @ali-ramadhan @navidcy @kpamnany @kburns",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1127
https://github.com/CliMA/Oceananigans.jl/issues/1127:746,Energy Efficiency,power,power,746,"Interacting with modeling software via scripts is novel for some users. We (and many others) are accumulating knowledge in this area, including:. * Scripting philosophy and its advantages.; * Literate scripting style for ""paper-like"" code, tutorials and pedagogical applications.; * Best practices for parameter exploration (eg how to replicate the functionality of a parameter file or namelist in your script, and why divorcing parameter lists from model setup should be considered carefully).; * Best practices for reproducibility (naming conventions, using output directories, checkpointing, script reuse).; * The use of external packages to achieve these goals (like `ArgParse`, or perhaps `DrWatson`). Oceananigans tries to give users great power and flexibility for designing numerical experiments. However, with this power comes great responsibility for users to write and use their scripts for Good. We can possibly help by adding some documentation. I also think the writers of said documentation might benefit if said documentation stimulates community input / outside contributions to these best practices. cc @ali-ramadhan @navidcy @kpamnany @kburns",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1127
https://github.com/CliMA/Oceananigans.jl/issues/1127:824,Energy Efficiency,power,power,824,"Interacting with modeling software via scripts is novel for some users. We (and many others) are accumulating knowledge in this area, including:. * Scripting philosophy and its advantages.; * Literate scripting style for ""paper-like"" code, tutorials and pedagogical applications.; * Best practices for parameter exploration (eg how to replicate the functionality of a parameter file or namelist in your script, and why divorcing parameter lists from model setup should be considered carefully).; * Best practices for reproducibility (naming conventions, using output directories, checkpointing, script reuse).; * The use of external packages to achieve these goals (like `ArgParse`, or perhaps `DrWatson`). Oceananigans tries to give users great power and flexibility for designing numerical experiments. However, with this power comes great responsibility for users to write and use their scripts for Good. We can possibly help by adding some documentation. I also think the writers of said documentation might benefit if said documentation stimulates community input / outside contributions to these best practices. cc @ali-ramadhan @navidcy @kpamnany @kburns",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1127
https://github.com/CliMA/Oceananigans.jl/pull/1128:311,Availability,down,down,311,"This PR enhances the convecting plankton example to simulate nonlinear plankton dynamics embedded in transient convection with a time-dependent, decreasing buoyancy flux. . As described by [Taylor and Ferrari (2011)](https://aslopubs.onlinelibrary.wiley.com/doi/abs/10.4319/lo.2011.56.6.2293), turbulence shuts down shortly after the surface buoyancy flux vanishes, precipitating a ""bloom"" of phytoplankton in the well-mixed, nutrient-rich waters. This is a canonical model for the spring bloom of phytoplankton. I was worried these changes dilute the pedagogical potential of this example, but ultimately decided that the changes are minor enough that it's worth it for the great increase of relevancy of this problem to oceanography. The main additional complications are the ""nonlinearization"" of the plankton dynamics (which now depend on the local plankton concentration), and the addition of time-dependent rather than constant buoyancy flux. [Preview of the example in documentation.](https://clima.github.io/OceananigansDocumentation/previews/PR1128/generated/convecting_plankton/)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1128
https://github.com/CliMA/Oceananigans.jl/pull/1128:134,Integrability,depend,dependent,134,"This PR enhances the convecting plankton example to simulate nonlinear plankton dynamics embedded in transient convection with a time-dependent, decreasing buoyancy flux. . As described by [Taylor and Ferrari (2011)](https://aslopubs.onlinelibrary.wiley.com/doi/abs/10.4319/lo.2011.56.6.2293), turbulence shuts down shortly after the surface buoyancy flux vanishes, precipitating a ""bloom"" of phytoplankton in the well-mixed, nutrient-rich waters. This is a canonical model for the spring bloom of phytoplankton. I was worried these changes dilute the pedagogical potential of this example, but ultimately decided that the changes are minor enough that it's worth it for the great increase of relevancy of this problem to oceanography. The main additional complications are the ""nonlinearization"" of the plankton dynamics (which now depend on the local plankton concentration), and the addition of time-dependent rather than constant buoyancy flux. [Preview of the example in documentation.](https://clima.github.io/OceananigansDocumentation/previews/PR1128/generated/convecting_plankton/)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1128
https://github.com/CliMA/Oceananigans.jl/pull/1128:833,Integrability,depend,depend,833,"This PR enhances the convecting plankton example to simulate nonlinear plankton dynamics embedded in transient convection with a time-dependent, decreasing buoyancy flux. . As described by [Taylor and Ferrari (2011)](https://aslopubs.onlinelibrary.wiley.com/doi/abs/10.4319/lo.2011.56.6.2293), turbulence shuts down shortly after the surface buoyancy flux vanishes, precipitating a ""bloom"" of phytoplankton in the well-mixed, nutrient-rich waters. This is a canonical model for the spring bloom of phytoplankton. I was worried these changes dilute the pedagogical potential of this example, but ultimately decided that the changes are minor enough that it's worth it for the great increase of relevancy of this problem to oceanography. The main additional complications are the ""nonlinearization"" of the plankton dynamics (which now depend on the local plankton concentration), and the addition of time-dependent rather than constant buoyancy flux. [Preview of the example in documentation.](https://clima.github.io/OceananigansDocumentation/previews/PR1128/generated/convecting_plankton/)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1128
https://github.com/CliMA/Oceananigans.jl/pull/1128:903,Integrability,depend,dependent,903,"This PR enhances the convecting plankton example to simulate nonlinear plankton dynamics embedded in transient convection with a time-dependent, decreasing buoyancy flux. . As described by [Taylor and Ferrari (2011)](https://aslopubs.onlinelibrary.wiley.com/doi/abs/10.4319/lo.2011.56.6.2293), turbulence shuts down shortly after the surface buoyancy flux vanishes, precipitating a ""bloom"" of phytoplankton in the well-mixed, nutrient-rich waters. This is a canonical model for the spring bloom of phytoplankton. I was worried these changes dilute the pedagogical potential of this example, but ultimately decided that the changes are minor enough that it's worth it for the great increase of relevancy of this problem to oceanography. The main additional complications are the ""nonlinearization"" of the plankton dynamics (which now depend on the local plankton concentration), and the addition of time-dependent rather than constant buoyancy flux. [Preview of the example in documentation.](https://clima.github.io/OceananigansDocumentation/previews/PR1128/generated/convecting_plankton/)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1128
https://github.com/CliMA/Oceananigans.jl/pull/1128:8,Modifiability,enhance,enhances,8,"This PR enhances the convecting plankton example to simulate nonlinear plankton dynamics embedded in transient convection with a time-dependent, decreasing buoyancy flux. . As described by [Taylor and Ferrari (2011)](https://aslopubs.onlinelibrary.wiley.com/doi/abs/10.4319/lo.2011.56.6.2293), turbulence shuts down shortly after the surface buoyancy flux vanishes, precipitating a ""bloom"" of phytoplankton in the well-mixed, nutrient-rich waters. This is a canonical model for the spring bloom of phytoplankton. I was worried these changes dilute the pedagogical potential of this example, but ultimately decided that the changes are minor enough that it's worth it for the great increase of relevancy of this problem to oceanography. The main additional complications are the ""nonlinearization"" of the plankton dynamics (which now depend on the local plankton concentration), and the addition of time-dependent rather than constant buoyancy flux. [Preview of the example in documentation.](https://clima.github.io/OceananigansDocumentation/previews/PR1128/generated/convecting_plankton/)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1128
https://github.com/CliMA/Oceananigans.jl/pull/1129:8,Deployability,update,updates,8,"This PR updates the Langmuir turbulence example to have an initial mixed layer 33 meters deep. This initial mixed layer was prescribed by [McWilliams et al. (1997)](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/langmuir-turbulence-in-the-ocean/638FD0E368140E5972144348DB930A38), which escaped me when I first read that paper. Thanks to @qingli411 for alerting me to this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1129
https://github.com/CliMA/Oceananigans.jl/pull/1129:82,Energy Efficiency,meter,meters,82,"This PR updates the Langmuir turbulence example to have an initial mixed layer 33 meters deep. This initial mixed layer was prescribed by [McWilliams et al. (1997)](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/langmuir-turbulence-in-the-ocean/638FD0E368140E5972144348DB930A38), which escaped me when I first read that paper. Thanks to @qingli411 for alerting me to this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1129
https://github.com/CliMA/Oceananigans.jl/issues/1130:2627,Integrability,depend,depends,2627,"larCartesianGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=2); ├── operand: BinaryOperation at (Cell, Cell, Cell); └── status: time=0.0. julia> dz_two_c = ComputedField(∂z(two_c)); ComputedField located at (Cell, Cell, Face) of Derivative at (Cell, Cell, Face); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (3, 3, 5); ├── grid: RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=2); ├── operand: Derivative at (Cell, Cell, Face); └── status: time=0.0. julia> set!(c, (x, y, z) -> rand()); 1×1×2 view(OffsetArray(::Array{Float64,3}, 0:2, 0:2, 0:3), 1:1, 1:1, 1:2) with eltype Float64:; [:, :, 1] =; 0.8753467111937931. [:, :, 2] =; 0.649695162761919. julia> compute!(dz_two_c). julia> two_c.data[1, 1, :]; 4-element OffsetArray(::Array{Float64,1}, 0:3) with eltype Float64 with indices 0:3:; 0.0; 1.7506934223875863; 1.299390325523838; 0.0. julia> interior(dz_two_c); 1×1×3 view(OffsetArray(::Array{Float64,3}, 0:2, 0:2, 0:4), 1:1, 1:1, 1:3) with eltype Float64:; [:, :, 1] =; 1.7506934223875863. [:, :, 2] =; -0.45130309686374837. [:, :, 3] =; -1.299390325523838; ```. The values of `dz_two_c` at the top and bottom boundary simply reflect the interior values of `two_c`. This is not what's expected: the vertical derivative of `2 * c` across boundaries actually depends on the boundary conditions imposed on `c`. This is a tricky issue to resolve. I'm not sure we can determine correct halo region values for computed fields in general. However, we can allow `ComputedField`s to have boundary conditions, like `Field`s currently do. In this case, users may specify boundary conditions on `ComputedField`s and we can reuse existing defaults if boundary conditions are not specified (or we can use `boundary_conditions = nothing` as a default). At the very least, this will ensure that `ComputedField`s are correct across periodic boundaries and at best users who need correct boundary conditions imposed on `ComputedField`s can provide them.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1130
https://github.com/CliMA/Oceananigans.jl/issues/1130:2489,Usability,simpl,simply,2489,"larCartesianGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=2); ├── operand: BinaryOperation at (Cell, Cell, Cell); └── status: time=0.0. julia> dz_two_c = ComputedField(∂z(two_c)); ComputedField located at (Cell, Cell, Face) of Derivative at (Cell, Cell, Face); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (3, 3, 5); ├── grid: RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=2); ├── operand: Derivative at (Cell, Cell, Face); └── status: time=0.0. julia> set!(c, (x, y, z) -> rand()); 1×1×2 view(OffsetArray(::Array{Float64,3}, 0:2, 0:2, 0:3), 1:1, 1:1, 1:2) with eltype Float64:; [:, :, 1] =; 0.8753467111937931. [:, :, 2] =; 0.649695162761919. julia> compute!(dz_two_c). julia> two_c.data[1, 1, :]; 4-element OffsetArray(::Array{Float64,1}, 0:3) with eltype Float64 with indices 0:3:; 0.0; 1.7506934223875863; 1.299390325523838; 0.0. julia> interior(dz_two_c); 1×1×3 view(OffsetArray(::Array{Float64,3}, 0:2, 0:2, 0:4), 1:1, 1:1, 1:3) with eltype Float64:; [:, :, 1] =; 1.7506934223875863. [:, :, 2] =; -0.45130309686374837. [:, :, 3] =; -1.299390325523838; ```. The values of `dz_two_c` at the top and bottom boundary simply reflect the interior values of `two_c`. This is not what's expected: the vertical derivative of `2 * c` across boundaries actually depends on the boundary conditions imposed on `c`. This is a tricky issue to resolve. I'm not sure we can determine correct halo region values for computed fields in general. However, we can allow `ComputedField`s to have boundary conditions, like `Field`s currently do. In this case, users may specify boundary conditions on `ComputedField`s and we can reuse existing defaults if boundary conditions are not specified (or we can use `boundary_conditions = nothing` as a default). At the very least, this will ensure that `ComputedField`s are correct across periodic boundaries and at best users who need correct boundary conditions imposed on `ComputedField`s can provide them.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1130
https://github.com/CliMA/Oceananigans.jl/issues/1131:365,Availability,error,errors,365,"Currently schedules are exported from `Oceananigans.Diagnostics` and `Oceananigans.OutputWriters` while being defined in `Oceananigans.Utils`. I guess an inconsistency is that we export output writers from the top-level `Oceananigans` module so users can end up with access to output writers via `using Oceananigans` but without any schedules/intervals, leading to errors like. ```; ERROR: LoadError: UndefVarError: TimeInterval not defined; ```; cc @mukund-gupta @qwert2266. Might make sense to either export schedules at the top-level or stop exporting output writers at the top-level. Both seem like consistent solutions to me but I'll argue",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1131
https://github.com/CliMA/Oceananigans.jl/issues/1131:383,Availability,ERROR,ERROR,383,"Currently schedules are exported from `Oceananigans.Diagnostics` and `Oceananigans.OutputWriters` while being defined in `Oceananigans.Utils`. I guess an inconsistency is that we export output writers from the top-level `Oceananigans` module so users can end up with access to output writers via `using Oceananigans` but without any schedules/intervals, leading to errors like. ```; ERROR: LoadError: UndefVarError: TimeInterval not defined; ```; cc @mukund-gupta @qwert2266. Might make sense to either export schedules at the top-level or stop exporting output writers at the top-level. Both seem like consistent solutions to me but I'll argue",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1131
https://github.com/CliMA/Oceananigans.jl/issues/1131:10,Energy Efficiency,schedul,schedules,10,"Currently schedules are exported from `Oceananigans.Diagnostics` and `Oceananigans.OutputWriters` while being defined in `Oceananigans.Utils`. I guess an inconsistency is that we export output writers from the top-level `Oceananigans` module so users can end up with access to output writers via `using Oceananigans` but without any schedules/intervals, leading to errors like. ```; ERROR: LoadError: UndefVarError: TimeInterval not defined; ```; cc @mukund-gupta @qwert2266. Might make sense to either export schedules at the top-level or stop exporting output writers at the top-level. Both seem like consistent solutions to me but I'll argue",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1131
https://github.com/CliMA/Oceananigans.jl/issues/1131:333,Energy Efficiency,schedul,schedules,333,"Currently schedules are exported from `Oceananigans.Diagnostics` and `Oceananigans.OutputWriters` while being defined in `Oceananigans.Utils`. I guess an inconsistency is that we export output writers from the top-level `Oceananigans` module so users can end up with access to output writers via `using Oceananigans` but without any schedules/intervals, leading to errors like. ```; ERROR: LoadError: UndefVarError: TimeInterval not defined; ```; cc @mukund-gupta @qwert2266. Might make sense to either export schedules at the top-level or stop exporting output writers at the top-level. Both seem like consistent solutions to me but I'll argue",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1131
https://github.com/CliMA/Oceananigans.jl/issues/1131:510,Energy Efficiency,schedul,schedules,510,"Currently schedules are exported from `Oceananigans.Diagnostics` and `Oceananigans.OutputWriters` while being defined in `Oceananigans.Utils`. I guess an inconsistency is that we export output writers from the top-level `Oceananigans` module so users can end up with access to output writers via `using Oceananigans` but without any schedules/intervals, leading to errors like. ```; ERROR: LoadError: UndefVarError: TimeInterval not defined; ```; cc @mukund-gupta @qwert2266. Might make sense to either export schedules at the top-level or stop exporting output writers at the top-level. Both seem like consistent solutions to me but I'll argue",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1131
https://github.com/CliMA/Oceananigans.jl/issues/1131:390,Performance,Load,LoadError,390,"Currently schedules are exported from `Oceananigans.Diagnostics` and `Oceananigans.OutputWriters` while being defined in `Oceananigans.Utils`. I guess an inconsistency is that we export output writers from the top-level `Oceananigans` module so users can end up with access to output writers via `using Oceananigans` but without any schedules/intervals, leading to errors like. ```; ERROR: LoadError: UndefVarError: TimeInterval not defined; ```; cc @mukund-gupta @qwert2266. Might make sense to either export schedules at the top-level or stop exporting output writers at the top-level. Both seem like consistent solutions to me but I'll argue",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1131
https://github.com/CliMA/Oceananigans.jl/issues/1131:267,Security,access,access,267,"Currently schedules are exported from `Oceananigans.Diagnostics` and `Oceananigans.OutputWriters` while being defined in `Oceananigans.Utils`. I guess an inconsistency is that we export output writers from the top-level `Oceananigans` module so users can end up with access to output writers via `using Oceananigans` but without any schedules/intervals, leading to errors like. ```; ERROR: LoadError: UndefVarError: TimeInterval not defined; ```; cc @mukund-gupta @qwert2266. Might make sense to either export schedules at the top-level or stop exporting output writers at the top-level. Both seem like consistent solutions to me but I'll argue",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1131
https://github.com/CliMA/Oceananigans.jl/issues/1132:106,Availability,avail,available,106,"I think it would be to good to export the entire user interface at the top-level module so it's all fully available to the user with just `using Oceananigans`. Some thoughts:; 1. Would make it much easier to set up scripts. Many times I've found that users add something to their scripts, e.g. `AveragedField` or a `NetCDFOutputWriter`, and forget to add `using Oceananigans.Fields` or `using Oceananigans.OutputWriters`. It can be hard for a user to figure out exactly which import statement they're missing without consulting the docs (this could be considered a pain point). 2. Our current approach is not consistent either. The top level `Oceananigans` module exports a lot of the user interface but not all of it, so users are expected to import submodules but the submodules themselves export way more than just the user interface including functions that are not part of the user interface (example: https://github.com/CliMA/Oceananigans.jl/blob/master/src/Fields/Fields.jl). 3. I think we should export the entire user-interface at the top-level and be mindful of not exporting too much. Everything that gets exported at the top-level requires a docstring (this would allow us to enable strict checking for exported docstrings in `makedocs`: https://github.com/CliMA/Oceananigans.jl/blob/9026438047fe3e5d4805edcebe42560268dc65fb/docs/make.jl#L150).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1132
https://github.com/CliMA/Oceananigans.jl/issues/1132:54,Integrability,interface,interface,54,"I think it would be to good to export the entire user interface at the top-level module so it's all fully available to the user with just `using Oceananigans`. Some thoughts:; 1. Would make it much easier to set up scripts. Many times I've found that users add something to their scripts, e.g. `AveragedField` or a `NetCDFOutputWriter`, and forget to add `using Oceananigans.Fields` or `using Oceananigans.OutputWriters`. It can be hard for a user to figure out exactly which import statement they're missing without consulting the docs (this could be considered a pain point). 2. Our current approach is not consistent either. The top level `Oceananigans` module exports a lot of the user interface but not all of it, so users are expected to import submodules but the submodules themselves export way more than just the user interface including functions that are not part of the user interface (example: https://github.com/CliMA/Oceananigans.jl/blob/master/src/Fields/Fields.jl). 3. I think we should export the entire user-interface at the top-level and be mindful of not exporting too much. Everything that gets exported at the top-level requires a docstring (this would allow us to enable strict checking for exported docstrings in `makedocs`: https://github.com/CliMA/Oceananigans.jl/blob/9026438047fe3e5d4805edcebe42560268dc65fb/docs/make.jl#L150).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1132
https://github.com/CliMA/Oceananigans.jl/issues/1132:690,Integrability,interface,interface,690,"I think it would be to good to export the entire user interface at the top-level module so it's all fully available to the user with just `using Oceananigans`. Some thoughts:; 1. Would make it much easier to set up scripts. Many times I've found that users add something to their scripts, e.g. `AveragedField` or a `NetCDFOutputWriter`, and forget to add `using Oceananigans.Fields` or `using Oceananigans.OutputWriters`. It can be hard for a user to figure out exactly which import statement they're missing without consulting the docs (this could be considered a pain point). 2. Our current approach is not consistent either. The top level `Oceananigans` module exports a lot of the user interface but not all of it, so users are expected to import submodules but the submodules themselves export way more than just the user interface including functions that are not part of the user interface (example: https://github.com/CliMA/Oceananigans.jl/blob/master/src/Fields/Fields.jl). 3. I think we should export the entire user-interface at the top-level and be mindful of not exporting too much. Everything that gets exported at the top-level requires a docstring (this would allow us to enable strict checking for exported docstrings in `makedocs`: https://github.com/CliMA/Oceananigans.jl/blob/9026438047fe3e5d4805edcebe42560268dc65fb/docs/make.jl#L150).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1132
https://github.com/CliMA/Oceananigans.jl/issues/1132:827,Integrability,interface,interface,827,"I think it would be to good to export the entire user interface at the top-level module so it's all fully available to the user with just `using Oceananigans`. Some thoughts:; 1. Would make it much easier to set up scripts. Many times I've found that users add something to their scripts, e.g. `AveragedField` or a `NetCDFOutputWriter`, and forget to add `using Oceananigans.Fields` or `using Oceananigans.OutputWriters`. It can be hard for a user to figure out exactly which import statement they're missing without consulting the docs (this could be considered a pain point). 2. Our current approach is not consistent either. The top level `Oceananigans` module exports a lot of the user interface but not all of it, so users are expected to import submodules but the submodules themselves export way more than just the user interface including functions that are not part of the user interface (example: https://github.com/CliMA/Oceananigans.jl/blob/master/src/Fields/Fields.jl). 3. I think we should export the entire user-interface at the top-level and be mindful of not exporting too much. Everything that gets exported at the top-level requires a docstring (this would allow us to enable strict checking for exported docstrings in `makedocs`: https://github.com/CliMA/Oceananigans.jl/blob/9026438047fe3e5d4805edcebe42560268dc65fb/docs/make.jl#L150).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1132
https://github.com/CliMA/Oceananigans.jl/issues/1132:887,Integrability,interface,interface,887,"I think it would be to good to export the entire user interface at the top-level module so it's all fully available to the user with just `using Oceananigans`. Some thoughts:; 1. Would make it much easier to set up scripts. Many times I've found that users add something to their scripts, e.g. `AveragedField` or a `NetCDFOutputWriter`, and forget to add `using Oceananigans.Fields` or `using Oceananigans.OutputWriters`. It can be hard for a user to figure out exactly which import statement they're missing without consulting the docs (this could be considered a pain point). 2. Our current approach is not consistent either. The top level `Oceananigans` module exports a lot of the user interface but not all of it, so users are expected to import submodules but the submodules themselves export way more than just the user interface including functions that are not part of the user interface (example: https://github.com/CliMA/Oceananigans.jl/blob/master/src/Fields/Fields.jl). 3. I think we should export the entire user-interface at the top-level and be mindful of not exporting too much. Everything that gets exported at the top-level requires a docstring (this would allow us to enable strict checking for exported docstrings in `makedocs`: https://github.com/CliMA/Oceananigans.jl/blob/9026438047fe3e5d4805edcebe42560268dc65fb/docs/make.jl#L150).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1132
https://github.com/CliMA/Oceananigans.jl/issues/1132:1027,Integrability,interface,interface,1027,"I think it would be to good to export the entire user interface at the top-level module so it's all fully available to the user with just `using Oceananigans`. Some thoughts:; 1. Would make it much easier to set up scripts. Many times I've found that users add something to their scripts, e.g. `AveragedField` or a `NetCDFOutputWriter`, and forget to add `using Oceananigans.Fields` or `using Oceananigans.OutputWriters`. It can be hard for a user to figure out exactly which import statement they're missing without consulting the docs (this could be considered a pain point). 2. Our current approach is not consistent either. The top level `Oceananigans` module exports a lot of the user interface but not all of it, so users are expected to import submodules but the submodules themselves export way more than just the user interface including functions that are not part of the user interface (example: https://github.com/CliMA/Oceananigans.jl/blob/master/src/Fields/Fields.jl). 3. I think we should export the entire user-interface at the top-level and be mindful of not exporting too much. Everything that gets exported at the top-level requires a docstring (this would allow us to enable strict checking for exported docstrings in `makedocs`: https://github.com/CliMA/Oceananigans.jl/blob/9026438047fe3e5d4805edcebe42560268dc65fb/docs/make.jl#L150).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1132
https://github.com/CliMA/Oceananigans.jl/issues/1135:67,Testability,log,logs,67,Would be useful to have some kind of state checker diagnostic that logs the min/max/mean/std/etc. of every model field for debugging purposes. Would be good to resolve #1117 first (which would make the state checker implementation cleaner).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1135
https://github.com/CliMA/Oceananigans.jl/issues/1136:232,Availability,checkpoint,checkpointing,232,"Would be very useful as it's a pretty common use case. Could probably be very short since it's not a complex procedure. With PR # #1082 merged, maybe now is a good time to consider adding such an example/tutorial since we think the checkpointing/pickup API won't change too much?. X-Ref: #779",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1136
https://github.com/CliMA/Oceananigans.jl/issues/1137:683,Availability,checkpoint,checkpointed,683,"PJ Tuckman (@qwert2266) recently wrote a pretty sweet Julia script for doing automated parameter exploration with Slurm on Satori (see https://github.com/ali-ramadhan/JuicyMoons.jl/pull/14). The script itself can be found at: https://github.com/ali-ramadhan/JuicyMoons.jl/blob/pjt/enceladus-slurm/slurm/20201031ScriptCreator.jl (needs some refactoring and might have bugs). The automation was complicated by the fact that Satori only allows you 1 Slurm job (through which you can request 4 GPUs and cram 4 GPU simulations on one node) and there's a 12 hour time limit on all jobs. So the idea/hack we came up with was for the simulation scripts to touch a file to indicate they have checkpointed themselves and to touch another file to indicate they have reached steady state. The Julia script keeps creating and submitting Slurm scripts until all simulations have reached steady state (""checkpointed"" simulations are queued/scheduled again while simulation that have reached ""steady state"" are not queued/scheduled any more). The point of this issue is to discuss whether it makes sense to add an example/tutorial of automating parameter exploration with Slurm? The specific workflow discussed above is specific to Satori so it might not make sense to include it in the docs (might be more of an internal resource). We looked at ClusterManagers.jl but don't think it's super useful since we're working around only have 1 job, and we don't know what the next job will be until the 4 simulations crammed into the first job are done running. X-Ref: #1045 proposes adding example Slurm scripts would is definitely a good idea. cc @sandreza @suyashbire1 might be interested.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1137
https://github.com/CliMA/Oceananigans.jl/issues/1137:888,Availability,checkpoint,checkpointed,888,"PJ Tuckman (@qwert2266) recently wrote a pretty sweet Julia script for doing automated parameter exploration with Slurm on Satori (see https://github.com/ali-ramadhan/JuicyMoons.jl/pull/14). The script itself can be found at: https://github.com/ali-ramadhan/JuicyMoons.jl/blob/pjt/enceladus-slurm/slurm/20201031ScriptCreator.jl (needs some refactoring and might have bugs). The automation was complicated by the fact that Satori only allows you 1 Slurm job (through which you can request 4 GPUs and cram 4 GPU simulations on one node) and there's a 12 hour time limit on all jobs. So the idea/hack we came up with was for the simulation scripts to touch a file to indicate they have checkpointed themselves and to touch another file to indicate they have reached steady state. The Julia script keeps creating and submitting Slurm scripts until all simulations have reached steady state (""checkpointed"" simulations are queued/scheduled again while simulation that have reached ""steady state"" are not queued/scheduled any more). The point of this issue is to discuss whether it makes sense to add an example/tutorial of automating parameter exploration with Slurm? The specific workflow discussed above is specific to Satori so it might not make sense to include it in the docs (might be more of an internal resource). We looked at ClusterManagers.jl but don't think it's super useful since we're working around only have 1 job, and we don't know what the next job will be until the 4 simulations crammed into the first job are done running. X-Ref: #1045 proposes adding example Slurm scripts would is definitely a good idea. cc @sandreza @suyashbire1 might be interested.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1137
https://github.com/CliMA/Oceananigans.jl/issues/1137:925,Energy Efficiency,schedul,scheduled,925,"PJ Tuckman (@qwert2266) recently wrote a pretty sweet Julia script for doing automated parameter exploration with Slurm on Satori (see https://github.com/ali-ramadhan/JuicyMoons.jl/pull/14). The script itself can be found at: https://github.com/ali-ramadhan/JuicyMoons.jl/blob/pjt/enceladus-slurm/slurm/20201031ScriptCreator.jl (needs some refactoring and might have bugs). The automation was complicated by the fact that Satori only allows you 1 Slurm job (through which you can request 4 GPUs and cram 4 GPU simulations on one node) and there's a 12 hour time limit on all jobs. So the idea/hack we came up with was for the simulation scripts to touch a file to indicate they have checkpointed themselves and to touch another file to indicate they have reached steady state. The Julia script keeps creating and submitting Slurm scripts until all simulations have reached steady state (""checkpointed"" simulations are queued/scheduled again while simulation that have reached ""steady state"" are not queued/scheduled any more). The point of this issue is to discuss whether it makes sense to add an example/tutorial of automating parameter exploration with Slurm? The specific workflow discussed above is specific to Satori so it might not make sense to include it in the docs (might be more of an internal resource). We looked at ClusterManagers.jl but don't think it's super useful since we're working around only have 1 job, and we don't know what the next job will be until the 4 simulations crammed into the first job are done running. X-Ref: #1045 proposes adding example Slurm scripts would is definitely a good idea. cc @sandreza @suyashbire1 might be interested.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1137
https://github.com/CliMA/Oceananigans.jl/issues/1137:1006,Energy Efficiency,schedul,scheduled,1006,"PJ Tuckman (@qwert2266) recently wrote a pretty sweet Julia script for doing automated parameter exploration with Slurm on Satori (see https://github.com/ali-ramadhan/JuicyMoons.jl/pull/14). The script itself can be found at: https://github.com/ali-ramadhan/JuicyMoons.jl/blob/pjt/enceladus-slurm/slurm/20201031ScriptCreator.jl (needs some refactoring and might have bugs). The automation was complicated by the fact that Satori only allows you 1 Slurm job (through which you can request 4 GPUs and cram 4 GPU simulations on one node) and there's a 12 hour time limit on all jobs. So the idea/hack we came up with was for the simulation scripts to touch a file to indicate they have checkpointed themselves and to touch another file to indicate they have reached steady state. The Julia script keeps creating and submitting Slurm scripts until all simulations have reached steady state (""checkpointed"" simulations are queued/scheduled again while simulation that have reached ""steady state"" are not queued/scheduled any more). The point of this issue is to discuss whether it makes sense to add an example/tutorial of automating parameter exploration with Slurm? The specific workflow discussed above is specific to Satori so it might not make sense to include it in the docs (might be more of an internal resource). We looked at ClusterManagers.jl but don't think it's super useful since we're working around only have 1 job, and we don't know what the next job will be until the 4 simulations crammed into the first job are done running. X-Ref: #1045 proposes adding example Slurm scripts would is definitely a good idea. cc @sandreza @suyashbire1 might be interested.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1137
https://github.com/CliMA/Oceananigans.jl/issues/1137:340,Modifiability,refactor,refactoring,340,"PJ Tuckman (@qwert2266) recently wrote a pretty sweet Julia script for doing automated parameter exploration with Slurm on Satori (see https://github.com/ali-ramadhan/JuicyMoons.jl/pull/14). The script itself can be found at: https://github.com/ali-ramadhan/JuicyMoons.jl/blob/pjt/enceladus-slurm/slurm/20201031ScriptCreator.jl (needs some refactoring and might have bugs). The automation was complicated by the fact that Satori only allows you 1 Slurm job (through which you can request 4 GPUs and cram 4 GPU simulations on one node) and there's a 12 hour time limit on all jobs. So the idea/hack we came up with was for the simulation scripts to touch a file to indicate they have checkpointed themselves and to touch another file to indicate they have reached steady state. The Julia script keeps creating and submitting Slurm scripts until all simulations have reached steady state (""checkpointed"" simulations are queued/scheduled again while simulation that have reached ""steady state"" are not queued/scheduled any more). The point of this issue is to discuss whether it makes sense to add an example/tutorial of automating parameter exploration with Slurm? The specific workflow discussed above is specific to Satori so it might not make sense to include it in the docs (might be more of an internal resource). We looked at ClusterManagers.jl but don't think it's super useful since we're working around only have 1 job, and we don't know what the next job will be until the 4 simulations crammed into the first job are done running. X-Ref: #1045 proposes adding example Slurm scripts would is definitely a good idea. cc @sandreza @suyashbire1 might be interested.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1137
https://github.com/CliMA/Oceananigans.jl/issues/1137:918,Performance,queue,queued,918,"PJ Tuckman (@qwert2266) recently wrote a pretty sweet Julia script for doing automated parameter exploration with Slurm on Satori (see https://github.com/ali-ramadhan/JuicyMoons.jl/pull/14). The script itself can be found at: https://github.com/ali-ramadhan/JuicyMoons.jl/blob/pjt/enceladus-slurm/slurm/20201031ScriptCreator.jl (needs some refactoring and might have bugs). The automation was complicated by the fact that Satori only allows you 1 Slurm job (through which you can request 4 GPUs and cram 4 GPU simulations on one node) and there's a 12 hour time limit on all jobs. So the idea/hack we came up with was for the simulation scripts to touch a file to indicate they have checkpointed themselves and to touch another file to indicate they have reached steady state. The Julia script keeps creating and submitting Slurm scripts until all simulations have reached steady state (""checkpointed"" simulations are queued/scheduled again while simulation that have reached ""steady state"" are not queued/scheduled any more). The point of this issue is to discuss whether it makes sense to add an example/tutorial of automating parameter exploration with Slurm? The specific workflow discussed above is specific to Satori so it might not make sense to include it in the docs (might be more of an internal resource). We looked at ClusterManagers.jl but don't think it's super useful since we're working around only have 1 job, and we don't know what the next job will be until the 4 simulations crammed into the first job are done running. X-Ref: #1045 proposes adding example Slurm scripts would is definitely a good idea. cc @sandreza @suyashbire1 might be interested.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1137
https://github.com/CliMA/Oceananigans.jl/issues/1137:999,Performance,queue,queued,999,"PJ Tuckman (@qwert2266) recently wrote a pretty sweet Julia script for doing automated parameter exploration with Slurm on Satori (see https://github.com/ali-ramadhan/JuicyMoons.jl/pull/14). The script itself can be found at: https://github.com/ali-ramadhan/JuicyMoons.jl/blob/pjt/enceladus-slurm/slurm/20201031ScriptCreator.jl (needs some refactoring and might have bugs). The automation was complicated by the fact that Satori only allows you 1 Slurm job (through which you can request 4 GPUs and cram 4 GPU simulations on one node) and there's a 12 hour time limit on all jobs. So the idea/hack we came up with was for the simulation scripts to touch a file to indicate they have checkpointed themselves and to touch another file to indicate they have reached steady state. The Julia script keeps creating and submitting Slurm scripts until all simulations have reached steady state (""checkpointed"" simulations are queued/scheduled again while simulation that have reached ""steady state"" are not queued/scheduled any more). The point of this issue is to discuss whether it makes sense to add an example/tutorial of automating parameter exploration with Slurm? The specific workflow discussed above is specific to Satori so it might not make sense to include it in the docs (might be more of an internal resource). We looked at ClusterManagers.jl but don't think it's super useful since we're working around only have 1 job, and we don't know what the next job will be until the 4 simulations crammed into the first job are done running. X-Ref: #1045 proposes adding example Slurm scripts would is definitely a good idea. cc @sandreza @suyashbire1 might be interested.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1137
https://github.com/CliMA/Oceananigans.jl/issues/1138:1369,Availability,checkpoint,checkpointer,1369," and diagnostics. All callbacks are required to possess `callback.schedule`, and we can provide convenience objects for coupling simple callback functions to `AbstractSchedule`. 2. Within the time-stepping loop, execute `simulation.callbacks` prior to writing output. This ensures that data calculated in a callback can be output during the same time-step, such as `WindowedTimeAverage` and other non-local-in-time output. 3. Wrap the time-stepping loop inside a `try / catch` block and throw exceptions to stop a simulation. This generalizes the concept of stopping a simulation and also means that a simulation can be stopped inside any callback. Further, when an `AbstractStopException` is called we will loop over the `OutputWriter` callbacks a final time, passing the exception into the `OutputWriter` callback functions. This allows output behavior specialized on the type of exception. For example: . * If `NaNsDetected` is thrown, no output will be written.; * If `WallTimeExceeded` is thrown, the checkpointer may write output. 4. `simulation.Δt` becomes a number corresponding to the next time-step, always (rather than sometimes being a `TimeStepWizard`). The `TimeStepWizard` callback changes this number on its `schedule`. Otherwise, the time-step is held constant. This changes the API, since the initial time-step must now be provided to `Simulation`. 5. (Somewhat unrelated, but enabled by the new pattern) Use a new function `align!(simulation.Δt, writer.schedule, simulation.model)` to adjust a subsequent time-step if output writing is scheduled. This ensures output writing on `TimeInterval`s will always be on `schedule` rather than chronically late as it is now. Since output is called after all the other callbacks, the output writers get the final say as to the next time-step. These changes will break the existing API. Notably, we'll use. ```julia; push!(simulation.callbacks, TimeStepWizard(cfl=1)); ```. rather than setting `simulation.Δt` to be a `TimeStepWizard`. This is",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1138
https://github.com/CliMA/Oceananigans.jl/issues/1138:429,Energy Efficiency,schedul,schedule,429,"@ali-ramadhan and I have discussed a potential redesign of `Simulation` and `run!` that has several key features:. 1. Coalesce all of the ""callbacks"" (arbitrary functions that are executed during a time-stepping loop) other than `OutputWriter`s into a single list. Current objects that we can classify / redesign as callbacks are: stop criteria, `TimeStepWizard`, and diagnostics. All callbacks are required to possess `callback.schedule`, and we can provide convenience objects for coupling simple callback functions to `AbstractSchedule`. 2. Within the time-stepping loop, execute `simulation.callbacks` prior to writing output. This ensures that data calculated in a callback can be output during the same time-step, such as `WindowedTimeAverage` and other non-local-in-time output. 3. Wrap the time-stepping loop inside a `try / catch` block and throw exceptions to stop a simulation. This generalizes the concept of stopping a simulation and also means that a simulation can be stopped inside any callback. Further, when an `AbstractStopException` is called we will loop over the `OutputWriter` callbacks a final time, passing the exception into the `OutputWriter` callback functions. This allows output behavior specialized on the type of exception. For example: . * If `NaNsDetected` is thrown, no output will be written.; * If `WallTimeExceeded` is thrown, the checkpointer may write output. 4. `simulation.Δt` becomes a number corresponding to the next time-step, always (rather than sometimes being a `TimeStepWizard`). The `TimeStepWizard` callback changes this number on its `schedule`. Otherwise, the time-step is held constant. This changes the API, since the initial time-step must now be provided to `Simulation`. 5. (Somewhat unrelated, but enabled by the new pattern) Use a new function `align!(simulation.Δt, writer.schedule, simulation.model)` to adjust a subsequent time-step if output writing is scheduled. This ensures output writing on `TimeInterval`s will always be on `schedu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1138
https://github.com/CliMA/Oceananigans.jl/issues/1138:1588,Energy Efficiency,schedul,schedule,1588,"pping loop, execute `simulation.callbacks` prior to writing output. This ensures that data calculated in a callback can be output during the same time-step, such as `WindowedTimeAverage` and other non-local-in-time output. 3. Wrap the time-stepping loop inside a `try / catch` block and throw exceptions to stop a simulation. This generalizes the concept of stopping a simulation and also means that a simulation can be stopped inside any callback. Further, when an `AbstractStopException` is called we will loop over the `OutputWriter` callbacks a final time, passing the exception into the `OutputWriter` callback functions. This allows output behavior specialized on the type of exception. For example: . * If `NaNsDetected` is thrown, no output will be written.; * If `WallTimeExceeded` is thrown, the checkpointer may write output. 4. `simulation.Δt` becomes a number corresponding to the next time-step, always (rather than sometimes being a `TimeStepWizard`). The `TimeStepWizard` callback changes this number on its `schedule`. Otherwise, the time-step is held constant. This changes the API, since the initial time-step must now be provided to `Simulation`. 5. (Somewhat unrelated, but enabled by the new pattern) Use a new function `align!(simulation.Δt, writer.schedule, simulation.model)` to adjust a subsequent time-step if output writing is scheduled. This ensures output writing on `TimeInterval`s will always be on `schedule` rather than chronically late as it is now. Since output is called after all the other callbacks, the output writers get the final say as to the next time-step. These changes will break the existing API. Notably, we'll use. ```julia; push!(simulation.callbacks, TimeStepWizard(cfl=1)); ```. rather than setting `simulation.Δt` to be a `TimeStepWizard`. This is probably an improvement. We can still provide the keywords `stop_time` and `stop_iteration` in the `Simulation` constructor as a convenience; however rather than being properties of `Simulation` we w",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1138
https://github.com/CliMA/Oceananigans.jl/issues/1138:1835,Energy Efficiency,schedul,schedule,1835,"p inside a `try / catch` block and throw exceptions to stop a simulation. This generalizes the concept of stopping a simulation and also means that a simulation can be stopped inside any callback. Further, when an `AbstractStopException` is called we will loop over the `OutputWriter` callbacks a final time, passing the exception into the `OutputWriter` callback functions. This allows output behavior specialized on the type of exception. For example: . * If `NaNsDetected` is thrown, no output will be written.; * If `WallTimeExceeded` is thrown, the checkpointer may write output. 4. `simulation.Δt` becomes a number corresponding to the next time-step, always (rather than sometimes being a `TimeStepWizard`). The `TimeStepWizard` callback changes this number on its `schedule`. Otherwise, the time-step is held constant. This changes the API, since the initial time-step must now be provided to `Simulation`. 5. (Somewhat unrelated, but enabled by the new pattern) Use a new function `align!(simulation.Δt, writer.schedule, simulation.model)` to adjust a subsequent time-step if output writing is scheduled. This ensures output writing on `TimeInterval`s will always be on `schedule` rather than chronically late as it is now. Since output is called after all the other callbacks, the output writers get the final say as to the next time-step. These changes will break the existing API. Notably, we'll use. ```julia; push!(simulation.callbacks, TimeStepWizard(cfl=1)); ```. rather than setting `simulation.Δt` to be a `TimeStepWizard`. This is probably an improvement. We can still provide the keywords `stop_time` and `stop_iteration` in the `Simulation` constructor as a convenience; however rather than being properties of `Simulation` we will create callback objects that get scheduled every iteration and add them to `simulation.callbacks`. I think we should also provide a few other features, like to ability to pass `Δt` to `run!`, perhaps along with a few other `run!`-specific objects.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1138
https://github.com/CliMA/Oceananigans.jl/issues/1138:1918,Energy Efficiency,schedul,scheduled,1918,"p inside a `try / catch` block and throw exceptions to stop a simulation. This generalizes the concept of stopping a simulation and also means that a simulation can be stopped inside any callback. Further, when an `AbstractStopException` is called we will loop over the `OutputWriter` callbacks a final time, passing the exception into the `OutputWriter` callback functions. This allows output behavior specialized on the type of exception. For example: . * If `NaNsDetected` is thrown, no output will be written.; * If `WallTimeExceeded` is thrown, the checkpointer may write output. 4. `simulation.Δt` becomes a number corresponding to the next time-step, always (rather than sometimes being a `TimeStepWizard`). The `TimeStepWizard` callback changes this number on its `schedule`. Otherwise, the time-step is held constant. This changes the API, since the initial time-step must now be provided to `Simulation`. 5. (Somewhat unrelated, but enabled by the new pattern) Use a new function `align!(simulation.Δt, writer.schedule, simulation.model)` to adjust a subsequent time-step if output writing is scheduled. This ensures output writing on `TimeInterval`s will always be on `schedule` rather than chronically late as it is now. Since output is called after all the other callbacks, the output writers get the final say as to the next time-step. These changes will break the existing API. Notably, we'll use. ```julia; push!(simulation.callbacks, TimeStepWizard(cfl=1)); ```. rather than setting `simulation.Δt` to be a `TimeStepWizard`. This is probably an improvement. We can still provide the keywords `stop_time` and `stop_iteration` in the `Simulation` constructor as a convenience; however rather than being properties of `Simulation` we will create callback objects that get scheduled every iteration and add them to `simulation.callbacks`. I think we should also provide a few other features, like to ability to pass `Δt` to `run!`, perhaps along with a few other `run!`-specific objects.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1138
https://github.com/CliMA/Oceananigans.jl/issues/1138:1995,Energy Efficiency,schedul,schedule,1995,"p inside a `try / catch` block and throw exceptions to stop a simulation. This generalizes the concept of stopping a simulation and also means that a simulation can be stopped inside any callback. Further, when an `AbstractStopException` is called we will loop over the `OutputWriter` callbacks a final time, passing the exception into the `OutputWriter` callback functions. This allows output behavior specialized on the type of exception. For example: . * If `NaNsDetected` is thrown, no output will be written.; * If `WallTimeExceeded` is thrown, the checkpointer may write output. 4. `simulation.Δt` becomes a number corresponding to the next time-step, always (rather than sometimes being a `TimeStepWizard`). The `TimeStepWizard` callback changes this number on its `schedule`. Otherwise, the time-step is held constant. This changes the API, since the initial time-step must now be provided to `Simulation`. 5. (Somewhat unrelated, but enabled by the new pattern) Use a new function `align!(simulation.Δt, writer.schedule, simulation.model)` to adjust a subsequent time-step if output writing is scheduled. This ensures output writing on `TimeInterval`s will always be on `schedule` rather than chronically late as it is now. Since output is called after all the other callbacks, the output writers get the final say as to the next time-step. These changes will break the existing API. Notably, we'll use. ```julia; push!(simulation.callbacks, TimeStepWizard(cfl=1)); ```. rather than setting `simulation.Δt` to be a `TimeStepWizard`. This is probably an improvement. We can still provide the keywords `stop_time` and `stop_iteration` in the `Simulation` constructor as a convenience; however rather than being properties of `Simulation` we will create callback objects that get scheduled every iteration and add them to `simulation.callbacks`. I think we should also provide a few other features, like to ability to pass `Δt` to `run!`, perhaps along with a few other `run!`-specific objects.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1138
https://github.com/CliMA/Oceananigans.jl/issues/1138:2601,Energy Efficiency,schedul,scheduled,2601,"p inside a `try / catch` block and throw exceptions to stop a simulation. This generalizes the concept of stopping a simulation and also means that a simulation can be stopped inside any callback. Further, when an `AbstractStopException` is called we will loop over the `OutputWriter` callbacks a final time, passing the exception into the `OutputWriter` callback functions. This allows output behavior specialized on the type of exception. For example: . * If `NaNsDetected` is thrown, no output will be written.; * If `WallTimeExceeded` is thrown, the checkpointer may write output. 4. `simulation.Δt` becomes a number corresponding to the next time-step, always (rather than sometimes being a `TimeStepWizard`). The `TimeStepWizard` callback changes this number on its `schedule`. Otherwise, the time-step is held constant. This changes the API, since the initial time-step must now be provided to `Simulation`. 5. (Somewhat unrelated, but enabled by the new pattern) Use a new function `align!(simulation.Δt, writer.schedule, simulation.model)` to adjust a subsequent time-step if output writing is scheduled. This ensures output writing on `TimeInterval`s will always be on `schedule` rather than chronically late as it is now. Since output is called after all the other callbacks, the output writers get the final say as to the next time-step. These changes will break the existing API. Notably, we'll use. ```julia; push!(simulation.callbacks, TimeStepWizard(cfl=1)); ```. rather than setting `simulation.Δt` to be a `TimeStepWizard`. This is probably an improvement. We can still provide the keywords `stop_time` and `stop_iteration` in the `Simulation` constructor as a convenience; however rather than being properties of `Simulation` we will create callback objects that get scheduled every iteration and add them to `simulation.callbacks`. I think we should also provide a few other features, like to ability to pass `Δt` to `run!`, perhaps along with a few other `run!`-specific objects.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1138
https://github.com/CliMA/Oceananigans.jl/issues/1138:789,Integrability,Wrap,Wrap,789,"@ali-ramadhan and I have discussed a potential redesign of `Simulation` and `run!` that has several key features:. 1. Coalesce all of the ""callbacks"" (arbitrary functions that are executed during a time-stepping loop) other than `OutputWriter`s into a single list. Current objects that we can classify / redesign as callbacks are: stop criteria, `TimeStepWizard`, and diagnostics. All callbacks are required to possess `callback.schedule`, and we can provide convenience objects for coupling simple callback functions to `AbstractSchedule`. 2. Within the time-stepping loop, execute `simulation.callbacks` prior to writing output. This ensures that data calculated in a callback can be output during the same time-step, such as `WindowedTimeAverage` and other non-local-in-time output. 3. Wrap the time-stepping loop inside a `try / catch` block and throw exceptions to stop a simulation. This generalizes the concept of stopping a simulation and also means that a simulation can be stopped inside any callback. Further, when an `AbstractStopException` is called we will loop over the `OutputWriter` callbacks a final time, passing the exception into the `OutputWriter` callback functions. This allows output behavior specialized on the type of exception. For example: . * If `NaNsDetected` is thrown, no output will be written.; * If `WallTimeExceeded` is thrown, the checkpointer may write output. 4. `simulation.Δt` becomes a number corresponding to the next time-step, always (rather than sometimes being a `TimeStepWizard`). The `TimeStepWizard` callback changes this number on its `schedule`. Otherwise, the time-step is held constant. This changes the API, since the initial time-step must now be provided to `Simulation`. 5. (Somewhat unrelated, but enabled by the new pattern) Use a new function `align!(simulation.Δt, writer.schedule, simulation.model)` to adjust a subsequent time-step if output writing is scheduled. This ensures output writing on `TimeInterval`s will always be on `schedu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1138
https://github.com/CliMA/Oceananigans.jl/issues/1138:483,Modifiability,coupling,coupling,483,"@ali-ramadhan and I have discussed a potential redesign of `Simulation` and `run!` that has several key features:. 1. Coalesce all of the ""callbacks"" (arbitrary functions that are executed during a time-stepping loop) other than `OutputWriter`s into a single list. Current objects that we can classify / redesign as callbacks are: stop criteria, `TimeStepWizard`, and diagnostics. All callbacks are required to possess `callback.schedule`, and we can provide convenience objects for coupling simple callback functions to `AbstractSchedule`. 2. Within the time-stepping loop, execute `simulation.callbacks` prior to writing output. This ensures that data calculated in a callback can be output during the same time-step, such as `WindowedTimeAverage` and other non-local-in-time output. 3. Wrap the time-stepping loop inside a `try / catch` block and throw exceptions to stop a simulation. This generalizes the concept of stopping a simulation and also means that a simulation can be stopped inside any callback. Further, when an `AbstractStopException` is called we will loop over the `OutputWriter` callbacks a final time, passing the exception into the `OutputWriter` callback functions. This allows output behavior specialized on the type of exception. For example: . * If `NaNsDetected` is thrown, no output will be written.; * If `WallTimeExceeded` is thrown, the checkpointer may write output. 4. `simulation.Δt` becomes a number corresponding to the next time-step, always (rather than sometimes being a `TimeStepWizard`). The `TimeStepWizard` callback changes this number on its `schedule`. Otherwise, the time-step is held constant. This changes the API, since the initial time-step must now be provided to `Simulation`. 5. (Somewhat unrelated, but enabled by the new pattern) Use a new function `align!(simulation.Δt, writer.schedule, simulation.model)` to adjust a subsequent time-step if output writing is scheduled. This ensures output writing on `TimeInterval`s will always be on `schedu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1138
https://github.com/CliMA/Oceananigans.jl/issues/1138:492,Usability,simpl,simple,492,"@ali-ramadhan and I have discussed a potential redesign of `Simulation` and `run!` that has several key features:. 1. Coalesce all of the ""callbacks"" (arbitrary functions that are executed during a time-stepping loop) other than `OutputWriter`s into a single list. Current objects that we can classify / redesign as callbacks are: stop criteria, `TimeStepWizard`, and diagnostics. All callbacks are required to possess `callback.schedule`, and we can provide convenience objects for coupling simple callback functions to `AbstractSchedule`. 2. Within the time-stepping loop, execute `simulation.callbacks` prior to writing output. This ensures that data calculated in a callback can be output during the same time-step, such as `WindowedTimeAverage` and other non-local-in-time output. 3. Wrap the time-stepping loop inside a `try / catch` block and throw exceptions to stop a simulation. This generalizes the concept of stopping a simulation and also means that a simulation can be stopped inside any callback. Further, when an `AbstractStopException` is called we will loop over the `OutputWriter` callbacks a final time, passing the exception into the `OutputWriter` callback functions. This allows output behavior specialized on the type of exception. For example: . * If `NaNsDetected` is thrown, no output will be written.; * If `WallTimeExceeded` is thrown, the checkpointer may write output. 4. `simulation.Δt` becomes a number corresponding to the next time-step, always (rather than sometimes being a `TimeStepWizard`). The `TimeStepWizard` callback changes this number on its `schedule`. Otherwise, the time-step is held constant. This changes the API, since the initial time-step must now be provided to `Simulation`. 5. (Somewhat unrelated, but enabled by the new pattern) Use a new function `align!(simulation.Δt, writer.schedule, simulation.model)` to adjust a subsequent time-step if output writing is scheduled. This ensures output writing on `TimeInterval`s will always be on `schedu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1138
https://github.com/CliMA/Oceananigans.jl/issues/1140:235,Energy Efficiency,reduce,reduce,235,"Currently the `Oceananigans` module exports. ```julia; Flux, Value, Gradient, NormalFlow,; FluxBoundaryCondition, ValueBoundaryCondition, GradientBoundaryCondition,; ```. so there's some redundancy (perhaps we should export one set to reduce namespace pollution) but a minor practical issue is that the `Flux` type conflicts with the popular Flux.jl package (I guess I'm the only one using them together right now but there may be more in the future?). There's also some inconsistency in exporting `NormalFlow` but not `NormalFlowBoundaryCondition`. In deciding on what to export for the user interface (see #1132) I'm wondering what do people think about only exporting the long-name version, e.g. `FluxBoundaryCondition` instead of `Flux`. I think this will have a few benefits:; 1. Lower probability for conflicts. `Flux` is one example, but `Value` and `Gradient` are pretty generic terms so I wouldn't be surprised if they conflict with exports from other packages future users may want to work with.; 2. Scripts might read more intuitively, e.g. because you say ""a flux boundary condition"" and not ""a boundary condition of type flux"".; 3. If we decide to export the complete set of boundary conditions we could do it by exporting `PeriodicBoundaryCondition` without having to worry about conflicting with the `Periodic` topology. X-Ref: #1132",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1140
https://github.com/CliMA/Oceananigans.jl/issues/1140:593,Integrability,interface,interface,593,"Currently the `Oceananigans` module exports. ```julia; Flux, Value, Gradient, NormalFlow,; FluxBoundaryCondition, ValueBoundaryCondition, GradientBoundaryCondition,; ```. so there's some redundancy (perhaps we should export one set to reduce namespace pollution) but a minor practical issue is that the `Flux` type conflicts with the popular Flux.jl package (I guess I'm the only one using them together right now but there may be more in the future?). There's also some inconsistency in exporting `NormalFlow` but not `NormalFlowBoundaryCondition`. In deciding on what to export for the user interface (see #1132) I'm wondering what do people think about only exporting the long-name version, e.g. `FluxBoundaryCondition` instead of `Flux`. I think this will have a few benefits:; 1. Lower probability for conflicts. `Flux` is one example, but `Value` and `Gradient` are pretty generic terms so I wouldn't be surprised if they conflict with exports from other packages future users may want to work with.; 2. Scripts might read more intuitively, e.g. because you say ""a flux boundary condition"" and not ""a boundary condition of type flux"".; 3. If we decide to export the complete set of boundary conditions we could do it by exporting `PeriodicBoundaryCondition` without having to worry about conflicting with the `Periodic` topology. X-Ref: #1132",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1140
https://github.com/CliMA/Oceananigans.jl/issues/1140:187,Safety,redund,redundancy,187,"Currently the `Oceananigans` module exports. ```julia; Flux, Value, Gradient, NormalFlow,; FluxBoundaryCondition, ValueBoundaryCondition, GradientBoundaryCondition,; ```. so there's some redundancy (perhaps we should export one set to reduce namespace pollution) but a minor practical issue is that the `Flux` type conflicts with the popular Flux.jl package (I guess I'm the only one using them together right now but there may be more in the future?). There's also some inconsistency in exporting `NormalFlow` but not `NormalFlowBoundaryCondition`. In deciding on what to export for the user interface (see #1132) I'm wondering what do people think about only exporting the long-name version, e.g. `FluxBoundaryCondition` instead of `Flux`. I think this will have a few benefits:; 1. Lower probability for conflicts. `Flux` is one example, but `Value` and `Gradient` are pretty generic terms so I wouldn't be surprised if they conflict with exports from other packages future users may want to work with.; 2. Scripts might read more intuitively, e.g. because you say ""a flux boundary condition"" and not ""a boundary condition of type flux"".; 3. If we decide to export the complete set of boundary conditions we could do it by exporting `PeriodicBoundaryCondition` without having to worry about conflicting with the `Periodic` topology. X-Ref: #1132",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1140
https://github.com/CliMA/Oceananigans.jl/issues/1140:1034,Usability,intuit,intuitively,1034,"Currently the `Oceananigans` module exports. ```julia; Flux, Value, Gradient, NormalFlow,; FluxBoundaryCondition, ValueBoundaryCondition, GradientBoundaryCondition,; ```. so there's some redundancy (perhaps we should export one set to reduce namespace pollution) but a minor practical issue is that the `Flux` type conflicts with the popular Flux.jl package (I guess I'm the only one using them together right now but there may be more in the future?). There's also some inconsistency in exporting `NormalFlow` but not `NormalFlowBoundaryCondition`. In deciding on what to export for the user interface (see #1132) I'm wondering what do people think about only exporting the long-name version, e.g. `FluxBoundaryCondition` instead of `Flux`. I think this will have a few benefits:; 1. Lower probability for conflicts. `Flux` is one example, but `Value` and `Gradient` are pretty generic terms so I wouldn't be surprised if they conflict with exports from other packages future users may want to work with.; 2. Scripts might read more intuitively, e.g. because you say ""a flux boundary condition"" and not ""a boundary condition of type flux"".; 3. If we decide to export the complete set of boundary conditions we could do it by exporting `PeriodicBoundaryCondition` without having to worry about conflicting with the `Periodic` topology. X-Ref: #1132",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1140
https://github.com/CliMA/Oceananigans.jl/issues/1141:149,Energy Efficiency,adapt,adapts,149,"Thanks to @vchuravy's work, a two-year old PR was finally merged! https://github.com/JuliaArrays/OffsetArrays.jl/pull/57. So OffsetArrays v1.4.0 now adapts OffsetArrays. This means we can should rid of this file: https://github.com/CliMA/Oceananigans.jl/blob/a48f284ca7341193254ddb3fc44daa9f5e9f318d/src/Utils/adapt_structure.jl. because right now we get a method redefinition warning:. ```julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition adapt_structure(Any, OffsetArrays.OffsetArray{T, N, AA} where AA<:AbstractArray{T, N} where N where T) in module OffsetArrays at /home/alir/.julia/packages/OffsetArrays/ExQCD/src/OffsetArrays.jl:486 overwritten in module Utils at /home/alir/Oceananigans.jl/src/Utils/adapt_structure.jl:5.; ** incremental compilation may be fatally broken for this module **; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1141
https://github.com/CliMA/Oceananigans.jl/issues/1141:149,Modifiability,adapt,adapts,149,"Thanks to @vchuravy's work, a two-year old PR was finally merged! https://github.com/JuliaArrays/OffsetArrays.jl/pull/57. So OffsetArrays v1.4.0 now adapts OffsetArrays. This means we can should rid of this file: https://github.com/CliMA/Oceananigans.jl/blob/a48f284ca7341193254ddb3fc44daa9f5e9f318d/src/Utils/adapt_structure.jl. because right now we get a method redefinition warning:. ```julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition adapt_structure(Any, OffsetArrays.OffsetArray{T, N, AA} where AA<:AbstractArray{T, N} where N where T) in module OffsetArrays at /home/alir/.julia/packages/OffsetArrays/ExQCD/src/OffsetArrays.jl:486 overwritten in module Utils at /home/alir/Oceananigans.jl/src/Utils/adapt_structure.jl:5.; ** incremental compilation may be fatally broken for this module **; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1141
https://github.com/CliMA/Oceananigans.jl/pull/1142:29,Deployability,release,release,29,Should probably tag a bugfix release v0.44.1 with this PR. Resolves #1141,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1142
https://github.com/CliMA/Oceananigans.jl/pull/1148:20,Availability,avail,available,20,The preview will be available here:. https://clima.github.io/OceananigansDocumentation/previews/PR1148/generated/langmuir_turbulence/,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1148
https://github.com/CliMA/Oceananigans.jl/issues/1149:61,Availability,down,downloaded,61,"The installation instructions are helpful for users who have downloaded julia. However, to run examples one needs to know how to use git, and also to have a text editor. Neither of these is necessarily trivial so it might be nice both to provide some simple explanations about how to get started with running the examples, and also to link to info about text editing, IDEs, and using github.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1149
https://github.com/CliMA/Oceananigans.jl/issues/1149:4,Deployability,install,installation,4,"The installation instructions are helpful for users who have downloaded julia. However, to run examples one needs to know how to use git, and also to have a text editor. Neither of these is necessarily trivial so it might be nice both to provide some simple explanations about how to get started with running the examples, and also to link to info about text editing, IDEs, and using github.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1149
https://github.com/CliMA/Oceananigans.jl/issues/1149:251,Usability,simpl,simple,251,"The installation instructions are helpful for users who have downloaded julia. However, to run examples one needs to know how to use git, and also to have a text editor. Neither of these is necessarily trivial so it might be nice both to provide some simple explanations about how to get started with running the examples, and also to link to info about text editing, IDEs, and using github.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1149
https://github.com/CliMA/Oceananigans.jl/issues/1153:278,Usability,learn,learn,278,"After discovering FourierFlows I guess it was only time before I came across Oceananigans. Great name by the way!. I would be interested in contributing to this and might even be able to get students to work on this as well. I am brand new to this repo and CliMA but am keen to learn more and work on something. . I have some ideas but also wonder what are the top 10 things that you want to have done now. If chatting would be easier, I'm happy to organize that sometime.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1153
https://github.com/CliMA/Oceananigans.jl/issues/1154:99,Deployability,update,update,99,"This issue is used to trigger TagBot; feel free to unsubscribe. If you haven't already, you should update your `TagBot.yml` to include issue comment triggers.; Please see [this post on Discourse](https://discourse.julialang.org/t/ann-required-updates-to-tagbot-yml/49249) for instructions and more details.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1154
https://github.com/CliMA/Oceananigans.jl/issues/1154:243,Deployability,update,updates-to-tagbot-yml,243,"This issue is used to trigger TagBot; feel free to unsubscribe. If you haven't already, you should update your `TagBot.yml` to include issue comment triggers.; Please see [this post on Discourse](https://discourse.julialang.org/t/ann-required-updates-to-tagbot-yml/49249) for instructions and more details.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1154
https://github.com/CliMA/Oceananigans.jl/pull/1155:34,Usability,guid,guide,34,"This PR changes our contributor's guide to [ColPrac](https://github.com/SciML/ColPrac), which I think is a pretty useful guide on how to work collaboratively on packages. We already follow some of the guide's suggestions around PRs so might as well follow the entire guide. What do people think about it?. Might be good to adopt something like ColPrac as more people start working together on Oceananigans. cc @navidcy @whitleyv @francispoulin. Resolves #1044",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1155
https://github.com/CliMA/Oceananigans.jl/pull/1155:121,Usability,guid,guide,121,"This PR changes our contributor's guide to [ColPrac](https://github.com/SciML/ColPrac), which I think is a pretty useful guide on how to work collaboratively on packages. We already follow some of the guide's suggestions around PRs so might as well follow the entire guide. What do people think about it?. Might be good to adopt something like ColPrac as more people start working together on Oceananigans. cc @navidcy @whitleyv @francispoulin. Resolves #1044",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1155
https://github.com/CliMA/Oceananigans.jl/pull/1155:201,Usability,guid,guide,201,"This PR changes our contributor's guide to [ColPrac](https://github.com/SciML/ColPrac), which I think is a pretty useful guide on how to work collaboratively on packages. We already follow some of the guide's suggestions around PRs so might as well follow the entire guide. What do people think about it?. Might be good to adopt something like ColPrac as more people start working together on Oceananigans. cc @navidcy @whitleyv @francispoulin. Resolves #1044",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1155
https://github.com/CliMA/Oceananigans.jl/pull/1155:267,Usability,guid,guide,267,"This PR changes our contributor's guide to [ColPrac](https://github.com/SciML/ColPrac), which I think is a pretty useful guide on how to work collaboratively on packages. We already follow some of the guide's suggestions around PRs so might as well follow the entire guide. What do people think about it?. Might be good to adopt something like ColPrac as more people start working together on Oceananigans. cc @navidcy @whitleyv @francispoulin. Resolves #1044",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1155
https://github.com/CliMA/Oceananigans.jl/issues/1156:237,Deployability,update,updated,237,"Wall-normal velocities can depend on `model_fields`:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/BoundaryConditions/fill_halo_regions_normal_flow.jl#L15-L18. and wall-normal velocities are updated _after_ an RK3 substep, but _before_ the pressure solve:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/pressure_correction.jl#L6-L10. Thus for some problems the wall-normal velocity fields are updated based on the predictor model fields (both the predictor velocity and the updated tracer fields) that result from an RK3 substep. This devious bug can be avoided simply by _not updating wall-normal velocity components on the boundary_ in the RK3 substep by changing the indexing in the rk3 substep as well as the worksize here:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/runge_kutta_3.jl#L124. Then we don't have to fill halo regions before performing the pressure correction. The resulting algorithm is both more correct and computationally less expensive. Note that doing this could require a bit of gymnastics to get the indexing right in the rk3 substep kernel:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/runge_kutta_3.jl#L178-L186",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1156
https://github.com/CliMA/Oceananigans.jl/issues/1156:497,Deployability,update,updated,497,"Wall-normal velocities can depend on `model_fields`:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/BoundaryConditions/fill_halo_regions_normal_flow.jl#L15-L18. and wall-normal velocities are updated _after_ an RK3 substep, but _before_ the pressure solve:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/pressure_correction.jl#L6-L10. Thus for some problems the wall-normal velocity fields are updated based on the predictor model fields (both the predictor velocity and the updated tracer fields) that result from an RK3 substep. This devious bug can be avoided simply by _not updating wall-normal velocity components on the boundary_ in the RK3 substep by changing the indexing in the rk3 substep as well as the worksize here:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/runge_kutta_3.jl#L124. Then we don't have to fill halo regions before performing the pressure correction. The resulting algorithm is both more correct and computationally less expensive. Note that doing this could require a bit of gymnastics to get the indexing right in the rk3 substep kernel:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/runge_kutta_3.jl#L178-L186",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1156
https://github.com/CliMA/Oceananigans.jl/issues/1156:578,Deployability,update,updated,578,"Wall-normal velocities can depend on `model_fields`:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/BoundaryConditions/fill_halo_regions_normal_flow.jl#L15-L18. and wall-normal velocities are updated _after_ an RK3 substep, but _before_ the pressure solve:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/pressure_correction.jl#L6-L10. Thus for some problems the wall-normal velocity fields are updated based on the predictor model fields (both the predictor velocity and the updated tracer fields) that result from an RK3 substep. This devious bug can be avoided simply by _not updating wall-normal velocity components on the boundary_ in the RK3 substep by changing the indexing in the rk3 substep as well as the worksize here:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/runge_kutta_3.jl#L124. Then we don't have to fill halo regions before performing the pressure correction. The resulting algorithm is both more correct and computationally less expensive. Note that doing this could require a bit of gymnastics to get the indexing right in the rk3 substep kernel:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/runge_kutta_3.jl#L178-L186",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1156
https://github.com/CliMA/Oceananigans.jl/issues/1156:27,Integrability,depend,depend,27,"Wall-normal velocities can depend on `model_fields`:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/BoundaryConditions/fill_halo_regions_normal_flow.jl#L15-L18. and wall-normal velocities are updated _after_ an RK3 substep, but _before_ the pressure solve:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/pressure_correction.jl#L6-L10. Thus for some problems the wall-normal velocity fields are updated based on the predictor model fields (both the predictor velocity and the updated tracer fields) that result from an RK3 substep. This devious bug can be avoided simply by _not updating wall-normal velocity components on the boundary_ in the RK3 substep by changing the indexing in the rk3 substep as well as the worksize here:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/runge_kutta_3.jl#L124. Then we don't have to fill halo regions before performing the pressure correction. The resulting algorithm is both more correct and computationally less expensive. Note that doing this could require a bit of gymnastics to get the indexing right in the rk3 substep kernel:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/runge_kutta_3.jl#L178-L186",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1156
https://github.com/CliMA/Oceananigans.jl/issues/1156:1007,Performance,perform,performing,1007,"Wall-normal velocities can depend on `model_fields`:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/BoundaryConditions/fill_halo_regions_normal_flow.jl#L15-L18. and wall-normal velocities are updated _after_ an RK3 substep, but _before_ the pressure solve:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/pressure_correction.jl#L6-L10. Thus for some problems the wall-normal velocity fields are updated based on the predictor model fields (both the predictor velocity and the updated tracer fields) that result from an RK3 substep. This devious bug can be avoided simply by _not updating wall-normal velocity components on the boundary_ in the RK3 substep by changing the indexing in the rk3 substep as well as the worksize here:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/runge_kutta_3.jl#L124. Then we don't have to fill halo regions before performing the pressure correction. The resulting algorithm is both more correct and computationally less expensive. Note that doing this could require a bit of gymnastics to get the indexing right in the rk3 substep kernel:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/runge_kutta_3.jl#L178-L186",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1156
https://github.com/CliMA/Oceananigans.jl/issues/1156:518,Safety,predict,predictor,518,"Wall-normal velocities can depend on `model_fields`:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/BoundaryConditions/fill_halo_regions_normal_flow.jl#L15-L18. and wall-normal velocities are updated _after_ an RK3 substep, but _before_ the pressure solve:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/pressure_correction.jl#L6-L10. Thus for some problems the wall-normal velocity fields are updated based on the predictor model fields (both the predictor velocity and the updated tracer fields) that result from an RK3 substep. This devious bug can be avoided simply by _not updating wall-normal velocity components on the boundary_ in the RK3 substep by changing the indexing in the rk3 substep as well as the worksize here:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/runge_kutta_3.jl#L124. Then we don't have to fill halo regions before performing the pressure correction. The resulting algorithm is both more correct and computationally less expensive. Note that doing this could require a bit of gymnastics to get the indexing right in the rk3 substep kernel:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/runge_kutta_3.jl#L178-L186",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1156
https://github.com/CliMA/Oceananigans.jl/issues/1156:551,Safety,predict,predictor,551,"Wall-normal velocities can depend on `model_fields`:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/BoundaryConditions/fill_halo_regions_normal_flow.jl#L15-L18. and wall-normal velocities are updated _after_ an RK3 substep, but _before_ the pressure solve:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/pressure_correction.jl#L6-L10. Thus for some problems the wall-normal velocity fields are updated based on the predictor model fields (both the predictor velocity and the updated tracer fields) that result from an RK3 substep. This devious bug can be avoided simply by _not updating wall-normal velocity components on the boundary_ in the RK3 substep by changing the indexing in the rk3 substep as well as the worksize here:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/runge_kutta_3.jl#L124. Then we don't have to fill halo regions before performing the pressure correction. The resulting algorithm is both more correct and computationally less expensive. Note that doing this could require a bit of gymnastics to get the indexing right in the rk3 substep kernel:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/runge_kutta_3.jl#L178-L186",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1156
https://github.com/CliMA/Oceananigans.jl/issues/1156:658,Safety,avoid,avoided,658,"Wall-normal velocities can depend on `model_fields`:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/BoundaryConditions/fill_halo_regions_normal_flow.jl#L15-L18. and wall-normal velocities are updated _after_ an RK3 substep, but _before_ the pressure solve:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/pressure_correction.jl#L6-L10. Thus for some problems the wall-normal velocity fields are updated based on the predictor model fields (both the predictor velocity and the updated tracer fields) that result from an RK3 substep. This devious bug can be avoided simply by _not updating wall-normal velocity components on the boundary_ in the RK3 substep by changing the indexing in the rk3 substep as well as the worksize here:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/runge_kutta_3.jl#L124. Then we don't have to fill halo regions before performing the pressure correction. The resulting algorithm is both more correct and computationally less expensive. Note that doing this could require a bit of gymnastics to get the indexing right in the rk3 substep kernel:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/runge_kutta_3.jl#L178-L186",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1156
https://github.com/CliMA/Oceananigans.jl/issues/1156:666,Usability,simpl,simply,666,"Wall-normal velocities can depend on `model_fields`:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/BoundaryConditions/fill_halo_regions_normal_flow.jl#L15-L18. and wall-normal velocities are updated _after_ an RK3 substep, but _before_ the pressure solve:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/pressure_correction.jl#L6-L10. Thus for some problems the wall-normal velocity fields are updated based on the predictor model fields (both the predictor velocity and the updated tracer fields) that result from an RK3 substep. This devious bug can be avoided simply by _not updating wall-normal velocity components on the boundary_ in the RK3 substep by changing the indexing in the rk3 substep as well as the worksize here:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/runge_kutta_3.jl#L124. Then we don't have to fill halo regions before performing the pressure correction. The resulting algorithm is both more correct and computationally less expensive. Note that doing this could require a bit of gymnastics to get the indexing right in the rk3 substep kernel:. https://github.com/CliMA/Oceananigans.jl/blob/5aafe8ee1d3e49a53906e7225a01fc18f1a5f165/src/TimeSteppers/runge_kutta_3.jl#L178-L186",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1156
https://github.com/CliMA/Oceananigans.jl/pull/1158:51,Deployability,update,updates-to-tagbot-yml,51,see https://discourse.julialang.org/t/ann-required-updates-to-tagbot-yml/49249,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1158
https://github.com/CliMA/Oceananigans.jl/issues/1159:31,Availability,checkpoint,checkpointing,31,"If you use the same script for checkpointing and pickup (i.e. you just keep running the same script) then `run!(simulation, pickup=true)` will fail the first time:. ```julia; julia> using Oceananigans;; julia> grid = RegularCartesianGrid(size=(100, 100, 50), extent=(2π, 2π, 1));; julia> model = IncompressibleModel(grid=grid);; julia> simulation = Simulation(model, Δt=60, stop_time=60); julia> run!(simulation, pickup=true); ```. ```; ERROR: No checkpointers found: cannot pickup simulation!; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] checkpoint_path(::Bool, ::Array{Oceananigans.AbstractOutputWriter,1}) at /home/alir/.julia/packages/Oceananigans/RxUYW/src/Simulations/run.jl:158; [3] run!(::Simulation{IncompressibleModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.Bou",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1159
https://github.com/CliMA/Oceananigans.jl/issues/1159:437,Availability,ERROR,ERROR,437,"If you use the same script for checkpointing and pickup (i.e. you just keep running the same script) then `run!(simulation, pickup=true)` will fail the first time:. ```julia; julia> using Oceananigans;; julia> grid = RegularCartesianGrid(size=(100, 100, 50), extent=(2π, 2π, 1));; julia> model = IncompressibleModel(grid=grid);; julia> simulation = Simulation(model, Δt=60, stop_time=60); julia> run!(simulation, pickup=true); ```. ```; ERROR: No checkpointers found: cannot pickup simulation!; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] checkpoint_path(::Bool, ::Array{Oceananigans.AbstractOutputWriter,1}) at /home/alir/.julia/packages/Oceananigans/RxUYW/src/Simulations/run.jl:158; [3] run!(::Simulation{IncompressibleModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.Bou",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1159
https://github.com/CliMA/Oceananigans.jl/issues/1159:447,Availability,checkpoint,checkpointers,447,"If you use the same script for checkpointing and pickup (i.e. you just keep running the same script) then `run!(simulation, pickup=true)` will fail the first time:. ```julia; julia> using Oceananigans;; julia> grid = RegularCartesianGrid(size=(100, 100, 50), extent=(2π, 2π, 1));; julia> model = IncompressibleModel(grid=grid);; julia> simulation = Simulation(model, Δt=60, stop_time=60); julia> run!(simulation, pickup=true); ```. ```; ERROR: No checkpointers found: cannot pickup simulation!; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] checkpoint_path(::Bool, ::Array{Oceananigans.AbstractOutputWriter,1}) at /home/alir/.julia/packages/Oceananigans/RxUYW/src/Simulations/run.jl:158; [3] run!(::Simulation{IncompressibleModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.Bou",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1159
https://github.com/CliMA/Oceananigans.jl/issues/1159:512,Availability,error,error,512,"If you use the same script for checkpointing and pickup (i.e. you just keep running the same script) then `run!(simulation, pickup=true)` will fail the first time:. ```julia; julia> using Oceananigans;; julia> grid = RegularCartesianGrid(size=(100, 100, 50), extent=(2π, 2π, 1));; julia> model = IncompressibleModel(grid=grid);; julia> simulation = Simulation(model, Δt=60, stop_time=60); julia> run!(simulation, pickup=true); ```. ```; ERROR: No checkpointers found: cannot pickup simulation!; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] checkpoint_path(::Bool, ::Array{Oceananigans.AbstractOutputWriter,1}) at /home/alir/.julia/packages/Oceananigans/RxUYW/src/Simulations/run.jl:158; [3] run!(::Simulation{IncompressibleModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.Bou",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1159
https://github.com/CliMA/Oceananigans.jl/issues/1159:533,Availability,error,error,533,"If you use the same script for checkpointing and pickup (i.e. you just keep running the same script) then `run!(simulation, pickup=true)` will fail the first time:. ```julia; julia> using Oceananigans;; julia> grid = RegularCartesianGrid(size=(100, 100, 50), extent=(2π, 2π, 1));; julia> model = IncompressibleModel(grid=grid);; julia> simulation = Simulation(model, Δt=60, stop_time=60); julia> run!(simulation, pickup=true); ```. ```; ERROR: No checkpointers found: cannot pickup simulation!; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] checkpoint_path(::Bool, ::Array{Oceananigans.AbstractOutputWriter,1}) at /home/alir/.julia/packages/Oceananigans/RxUYW/src/Simulations/run.jl:158; [3] run!(::Simulation{IncompressibleModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.Bou",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1159
https://github.com/CliMA/Oceananigans.jl/issues/1159:11900,Availability,checkpoint,checkpoints,11900,"tions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T, :S),NTuple{5,typeof(Oceananigans.Forcings.zeroforcing)}},Oceananigans.Advection.CenteredSecondOrder,Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,CPU,NamedTuple{(:kx², :ky², :kz²),Tuple{Array{Float64,3},Array{Float64,3},Array{Float64,3}}},Array{Complex{Float64},3},NamedTuple{(:FFTxy!, :DCTz!, :IFFTxy!, :IDCTz!),Tuple{FFTW.cFFTWPlan{Complex{Float64},-1,true,3,Array{Int64,1}},FFTW.r2rFFTWPlan{Complex{Float64},(5,),true,3,Int64},AbstractFFTs.ScaledPlan{Complex{Float64},FFTW.cFFTWPlan{Complex{Float64},1,true,3,Array{Int64,1}},Float64},FFTW.r2rFFTWPlan{Complex{Float64},(4,),true,3,Int64}}},Nothing},Nothing,NamedTuple{(:velocities, :tracers),Tuple{NamedTuple{(:u, :v, :w),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}},NamedTuple{(:T, :S),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}}}}},Int64,Array{Any,1},Float64,Int64,Float64,Float64,OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractDiagnostic},OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractOutputWriter},typeof(Oceananigans.Simulations.default_progress),Int64,Nothing}; pickup::Bool) at /home/alir/.julia/packages/Oceananigans/RxUYW/src/Simulations/run.jl:106; [4] top-level scope at REPL[6]:1; ```. But this mean you have to add boilerplate logic like. ```julia; searchdir(path, key) = filter(x -> occursin(key, x), readdir(path)); checkpoints = searchdir(base_dir, ""iteration""). n_checkpoints = length(checkpoints); checkpointed = n_checkpoints > 0 ? true : false. if checkpointed; run!(simulation, pickup=true); else; run!(simulation, pickup=false); end; ```. I think `pickup=true` should print a warning if no checkpoints were found, allowing such scripts to run simulations without boilerplate logic. `pickup::Int` and `pickup::String` should error of course.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1159
https://github.com/CliMA/Oceananigans.jl/issues/1159:11971,Availability,checkpoint,checkpoints,11971,"tions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T, :S),NTuple{5,typeof(Oceananigans.Forcings.zeroforcing)}},Oceananigans.Advection.CenteredSecondOrder,Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,CPU,NamedTuple{(:kx², :ky², :kz²),Tuple{Array{Float64,3},Array{Float64,3},Array{Float64,3}}},Array{Complex{Float64},3},NamedTuple{(:FFTxy!, :DCTz!, :IFFTxy!, :IDCTz!),Tuple{FFTW.cFFTWPlan{Complex{Float64},-1,true,3,Array{Int64,1}},FFTW.r2rFFTWPlan{Complex{Float64},(5,),true,3,Int64},AbstractFFTs.ScaledPlan{Complex{Float64},FFTW.cFFTWPlan{Complex{Float64},1,true,3,Array{Int64,1}},Float64},FFTW.r2rFFTWPlan{Complex{Float64},(4,),true,3,Int64}}},Nothing},Nothing,NamedTuple{(:velocities, :tracers),Tuple{NamedTuple{(:u, :v, :w),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}},NamedTuple{(:T, :S),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}}}}},Int64,Array{Any,1},Float64,Int64,Float64,Float64,OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractDiagnostic},OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractOutputWriter},typeof(Oceananigans.Simulations.default_progress),Int64,Nothing}; pickup::Bool) at /home/alir/.julia/packages/Oceananigans/RxUYW/src/Simulations/run.jl:106; [4] top-level scope at REPL[6]:1; ```. But this mean you have to add boilerplate logic like. ```julia; searchdir(path, key) = filter(x -> occursin(key, x), readdir(path)); checkpoints = searchdir(base_dir, ""iteration""). n_checkpoints = length(checkpoints); checkpointed = n_checkpoints > 0 ? true : false. if checkpointed; run!(simulation, pickup=true); else; run!(simulation, pickup=false); end; ```. I think `pickup=true` should print a warning if no checkpoints were found, allowing such scripts to run simulations without boilerplate logic. `pickup::Int` and `pickup::String` should error of course.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1159
https://github.com/CliMA/Oceananigans.jl/issues/1159:11985,Availability,checkpoint,checkpointed,11985,"tions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T, :S),NTuple{5,typeof(Oceananigans.Forcings.zeroforcing)}},Oceananigans.Advection.CenteredSecondOrder,Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,CPU,NamedTuple{(:kx², :ky², :kz²),Tuple{Array{Float64,3},Array{Float64,3},Array{Float64,3}}},Array{Complex{Float64},3},NamedTuple{(:FFTxy!, :DCTz!, :IFFTxy!, :IDCTz!),Tuple{FFTW.cFFTWPlan{Complex{Float64},-1,true,3,Array{Int64,1}},FFTW.r2rFFTWPlan{Complex{Float64},(5,),true,3,Int64},AbstractFFTs.ScaledPlan{Complex{Float64},FFTW.cFFTWPlan{Complex{Float64},1,true,3,Array{Int64,1}},Float64},FFTW.r2rFFTWPlan{Complex{Float64},(4,),true,3,Int64}}},Nothing},Nothing,NamedTuple{(:velocities, :tracers),Tuple{NamedTuple{(:u, :v, :w),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}},NamedTuple{(:T, :S),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}}}}},Int64,Array{Any,1},Float64,Int64,Float64,Float64,OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractDiagnostic},OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractOutputWriter},typeof(Oceananigans.Simulations.default_progress),Int64,Nothing}; pickup::Bool) at /home/alir/.julia/packages/Oceananigans/RxUYW/src/Simulations/run.jl:106; [4] top-level scope at REPL[6]:1; ```. But this mean you have to add boilerplate logic like. ```julia; searchdir(path, key) = filter(x -> occursin(key, x), readdir(path)); checkpoints = searchdir(base_dir, ""iteration""). n_checkpoints = length(checkpoints); checkpointed = n_checkpoints > 0 ? true : false. if checkpointed; run!(simulation, pickup=true); else; run!(simulation, pickup=false); end; ```. I think `pickup=true` should print a warning if no checkpoints were found, allowing such scripts to run simulations without boilerplate logic. `pickup::Int` and `pickup::String` should error of course.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1159
https://github.com/CliMA/Oceananigans.jl/issues/1159:12037,Availability,checkpoint,checkpointed,12037,"tions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T, :S),NTuple{5,typeof(Oceananigans.Forcings.zeroforcing)}},Oceananigans.Advection.CenteredSecondOrder,Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,CPU,NamedTuple{(:kx², :ky², :kz²),Tuple{Array{Float64,3},Array{Float64,3},Array{Float64,3}}},Array{Complex{Float64},3},NamedTuple{(:FFTxy!, :DCTz!, :IFFTxy!, :IDCTz!),Tuple{FFTW.cFFTWPlan{Complex{Float64},-1,true,3,Array{Int64,1}},FFTW.r2rFFTWPlan{Complex{Float64},(5,),true,3,Int64},AbstractFFTs.ScaledPlan{Complex{Float64},FFTW.cFFTWPlan{Complex{Float64},1,true,3,Array{Int64,1}},Float64},FFTW.r2rFFTWPlan{Complex{Float64},(4,),true,3,Int64}}},Nothing},Nothing,NamedTuple{(:velocities, :tracers),Tuple{NamedTuple{(:u, :v, :w),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}},NamedTuple{(:T, :S),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}}}}},Int64,Array{Any,1},Float64,Int64,Float64,Float64,OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractDiagnostic},OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractOutputWriter},typeof(Oceananigans.Simulations.default_progress),Int64,Nothing}; pickup::Bool) at /home/alir/.julia/packages/Oceananigans/RxUYW/src/Simulations/run.jl:106; [4] top-level scope at REPL[6]:1; ```. But this mean you have to add boilerplate logic like. ```julia; searchdir(path, key) = filter(x -> occursin(key, x), readdir(path)); checkpoints = searchdir(base_dir, ""iteration""). n_checkpoints = length(checkpoints); checkpointed = n_checkpoints > 0 ? true : false. if checkpointed; run!(simulation, pickup=true); else; run!(simulation, pickup=false); end; ```. I think `pickup=true` should print a warning if no checkpoints were found, allowing such scripts to run simulations without boilerplate logic. `pickup::Int` and `pickup::String` should error of course.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1159
https://github.com/CliMA/Oceananigans.jl/issues/1159:12181,Availability,checkpoint,checkpoints,12181,"tions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T, :S),NTuple{5,typeof(Oceananigans.Forcings.zeroforcing)}},Oceananigans.Advection.CenteredSecondOrder,Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,CPU,NamedTuple{(:kx², :ky², :kz²),Tuple{Array{Float64,3},Array{Float64,3},Array{Float64,3}}},Array{Complex{Float64},3},NamedTuple{(:FFTxy!, :DCTz!, :IFFTxy!, :IDCTz!),Tuple{FFTW.cFFTWPlan{Complex{Float64},-1,true,3,Array{Int64,1}},FFTW.r2rFFTWPlan{Complex{Float64},(5,),true,3,Int64},AbstractFFTs.ScaledPlan{Complex{Float64},FFTW.cFFTWPlan{Complex{Float64},1,true,3,Array{Int64,1}},Float64},FFTW.r2rFFTWPlan{Complex{Float64},(4,),true,3,Int64}}},Nothing},Nothing,NamedTuple{(:velocities, :tracers),Tuple{NamedTuple{(:u, :v, :w),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}},NamedTuple{(:T, :S),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}}}}},Int64,Array{Any,1},Float64,Int64,Float64,Float64,OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractDiagnostic},OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractOutputWriter},typeof(Oceananigans.Simulations.default_progress),Int64,Nothing}; pickup::Bool) at /home/alir/.julia/packages/Oceananigans/RxUYW/src/Simulations/run.jl:106; [4] top-level scope at REPL[6]:1; ```. But this mean you have to add boilerplate logic like. ```julia; searchdir(path, key) = filter(x -> occursin(key, x), readdir(path)); checkpoints = searchdir(base_dir, ""iteration""). n_checkpoints = length(checkpoints); checkpointed = n_checkpoints > 0 ? true : false. if checkpointed; run!(simulation, pickup=true); else; run!(simulation, pickup=false); end; ```. I think `pickup=true` should print a warning if no checkpoints were found, allowing such scripts to run simulations without boilerplate logic. `pickup::Int` and `pickup::String` should error of course.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1159
https://github.com/CliMA/Oceananigans.jl/issues/1159:12315,Availability,error,error,12315,"tions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T, :S),NTuple{5,typeof(Oceananigans.Forcings.zeroforcing)}},Oceananigans.Advection.CenteredSecondOrder,Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,CPU,NamedTuple{(:kx², :ky², :kz²),Tuple{Array{Float64,3},Array{Float64,3},Array{Float64,3}}},Array{Complex{Float64},3},NamedTuple{(:FFTxy!, :DCTz!, :IFFTxy!, :IDCTz!),Tuple{FFTW.cFFTWPlan{Complex{Float64},-1,true,3,Array{Int64,1}},FFTW.r2rFFTWPlan{Complex{Float64},(5,),true,3,Int64},AbstractFFTs.ScaledPlan{Complex{Float64},FFTW.cFFTWPlan{Complex{Float64},1,true,3,Array{Int64,1}},Float64},FFTW.r2rFFTWPlan{Complex{Float64},(4,),true,3,Int64}}},Nothing},Nothing,NamedTuple{(:velocities, :tracers),Tuple{NamedTuple{(:u, :v, :w),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}},NamedTuple{(:T, :S),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}}}}},Int64,Array{Any,1},Float64,Int64,Float64,Float64,OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractDiagnostic},OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractOutputWriter},typeof(Oceananigans.Simulations.default_progress),Int64,Nothing}; pickup::Bool) at /home/alir/.julia/packages/Oceananigans/RxUYW/src/Simulations/run.jl:106; [4] top-level scope at REPL[6]:1; ```. But this mean you have to add boilerplate logic like. ```julia; searchdir(path, key) = filter(x -> occursin(key, x), readdir(path)); checkpoints = searchdir(base_dir, ""iteration""). n_checkpoints = length(checkpoints); checkpointed = n_checkpoints > 0 ? true : false. if checkpointed; run!(simulation, pickup=true); else; run!(simulation, pickup=false); end; ```. I think `pickup=true` should print a warning if no checkpoints were found, allowing such scripts to run simulations without boilerplate logic. `pickup::Int` and `pickup::String` should error of course.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1159
https://github.com/CliMA/Oceananigans.jl/issues/1159:11809,Testability,log,logic,11809,"tions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T, :S),NTuple{5,typeof(Oceananigans.Forcings.zeroforcing)}},Oceananigans.Advection.CenteredSecondOrder,Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,CPU,NamedTuple{(:kx², :ky², :kz²),Tuple{Array{Float64,3},Array{Float64,3},Array{Float64,3}}},Array{Complex{Float64},3},NamedTuple{(:FFTxy!, :DCTz!, :IFFTxy!, :IDCTz!),Tuple{FFTW.cFFTWPlan{Complex{Float64},-1,true,3,Array{Int64,1}},FFTW.r2rFFTWPlan{Complex{Float64},(5,),true,3,Int64},AbstractFFTs.ScaledPlan{Complex{Float64},FFTW.cFFTWPlan{Complex{Float64},1,true,3,Array{Int64,1}},Float64},FFTW.r2rFFTWPlan{Complex{Float64},(4,),true,3,Int64}}},Nothing},Nothing,NamedTuple{(:velocities, :tracers),Tuple{NamedTuple{(:u, :v, :w),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}},NamedTuple{(:T, :S),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}}}}},Int64,Array{Any,1},Float64,Int64,Float64,Float64,OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractDiagnostic},OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractOutputWriter},typeof(Oceananigans.Simulations.default_progress),Int64,Nothing}; pickup::Bool) at /home/alir/.julia/packages/Oceananigans/RxUYW/src/Simulations/run.jl:106; [4] top-level scope at REPL[6]:1; ```. But this mean you have to add boilerplate logic like. ```julia; searchdir(path, key) = filter(x -> occursin(key, x), readdir(path)); checkpoints = searchdir(base_dir, ""iteration""). n_checkpoints = length(checkpoints); checkpointed = n_checkpoints > 0 ? true : false. if checkpointed; run!(simulation, pickup=true); else; run!(simulation, pickup=false); end; ```. I think `pickup=true` should print a warning if no checkpoints were found, allowing such scripts to run simulations without boilerplate logic. `pickup::Int` and `pickup::String` should error of course.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1159
https://github.com/CliMA/Oceananigans.jl/issues/1159:12266,Testability,log,logic,12266,"tions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T, :S),NTuple{5,typeof(Oceananigans.Forcings.zeroforcing)}},Oceananigans.Advection.CenteredSecondOrder,Oceananigans.Solvers.PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,CPU,NamedTuple{(:kx², :ky², :kz²),Tuple{Array{Float64,3},Array{Float64,3},Array{Float64,3}}},Array{Complex{Float64},3},NamedTuple{(:FFTxy!, :DCTz!, :IFFTxy!, :IDCTz!),Tuple{FFTW.cFFTWPlan{Complex{Float64},-1,true,3,Array{Int64,1}},FFTW.r2rFFTWPlan{Complex{Float64},(5,),true,3,Int64},AbstractFFTs.ScaledPlan{Complex{Float64},FFTW.cFFTWPlan{Complex{Float64},1,true,3,Array{Int64,1}},Float64},FFTW.r2rFFTWPlan{Complex{Float64},(4,),true,3,Int64}}},Nothing},Nothing,NamedTuple{(:velocities, :tracers),Tuple{NamedTuple{(:u, :v, :w),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}},NamedTuple{(:T, :S),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}}}}},Int64,Array{Any,1},Float64,Int64,Float64,Float64,OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractDiagnostic},OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractOutputWriter},typeof(Oceananigans.Simulations.default_progress),Int64,Nothing}; pickup::Bool) at /home/alir/.julia/packages/Oceananigans/RxUYW/src/Simulations/run.jl:106; [4] top-level scope at REPL[6]:1; ```. But this mean you have to add boilerplate logic like. ```julia; searchdir(path, key) = filter(x -> occursin(key, x), readdir(path)); checkpoints = searchdir(base_dir, ""iteration""). n_checkpoints = length(checkpoints); checkpointed = n_checkpoints > 0 ? true : false. if checkpointed; run!(simulation, pickup=true); else; run!(simulation, pickup=false); end; ```. I think `pickup=true` should print a warning if no checkpoints were found, allowing such scripts to run simulations without boilerplate logic. `pickup::Int` and `pickup::String` should error of course.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1159
https://github.com/CliMA/Oceananigans.jl/issues/1160:132,Availability,checkpoint,checkpoint,132,"By default `NetCDFOutputWriter` uses `mode = ""c""` which overwrites existing files. The problem arises when using the same script to checkpoint and pickup (i.e. running the same script over and over): `mode = ""c""` is fine the first run but after that you want `mode = ""a""`. Making the user explicitly select the `mode` will force the user to check if there's a checkpoint to select a mode, which will add boilerplate code like. ```julia; searchdir(path, key) = filter(x -> occursin(key, x), readdir(path)); checkpoints = searchdir(base_dir, ""iteration""). n_checkpoints = length(checkpoints); checkpointed = n_checkpoints > 0 ? true : false. mode = checkpointed ? ""a"" : ""c""; ```. Would be nice if `NetCDFOutputWriter` switched to `mode = ""a""` if a file exists (and print a warning).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1160
https://github.com/CliMA/Oceananigans.jl/issues/1160:360,Availability,checkpoint,checkpoint,360,"By default `NetCDFOutputWriter` uses `mode = ""c""` which overwrites existing files. The problem arises when using the same script to checkpoint and pickup (i.e. running the same script over and over): `mode = ""c""` is fine the first run but after that you want `mode = ""a""`. Making the user explicitly select the `mode` will force the user to check if there's a checkpoint to select a mode, which will add boilerplate code like. ```julia; searchdir(path, key) = filter(x -> occursin(key, x), readdir(path)); checkpoints = searchdir(base_dir, ""iteration""). n_checkpoints = length(checkpoints); checkpointed = n_checkpoints > 0 ? true : false. mode = checkpointed ? ""a"" : ""c""; ```. Would be nice if `NetCDFOutputWriter` switched to `mode = ""a""` if a file exists (and print a warning).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1160
https://github.com/CliMA/Oceananigans.jl/issues/1160:506,Availability,checkpoint,checkpoints,506,"By default `NetCDFOutputWriter` uses `mode = ""c""` which overwrites existing files. The problem arises when using the same script to checkpoint and pickup (i.e. running the same script over and over): `mode = ""c""` is fine the first run but after that you want `mode = ""a""`. Making the user explicitly select the `mode` will force the user to check if there's a checkpoint to select a mode, which will add boilerplate code like. ```julia; searchdir(path, key) = filter(x -> occursin(key, x), readdir(path)); checkpoints = searchdir(base_dir, ""iteration""). n_checkpoints = length(checkpoints); checkpointed = n_checkpoints > 0 ? true : false. mode = checkpointed ? ""a"" : ""c""; ```. Would be nice if `NetCDFOutputWriter` switched to `mode = ""a""` if a file exists (and print a warning).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1160
https://github.com/CliMA/Oceananigans.jl/issues/1160:577,Availability,checkpoint,checkpoints,577,"By default `NetCDFOutputWriter` uses `mode = ""c""` which overwrites existing files. The problem arises when using the same script to checkpoint and pickup (i.e. running the same script over and over): `mode = ""c""` is fine the first run but after that you want `mode = ""a""`. Making the user explicitly select the `mode` will force the user to check if there's a checkpoint to select a mode, which will add boilerplate code like. ```julia; searchdir(path, key) = filter(x -> occursin(key, x), readdir(path)); checkpoints = searchdir(base_dir, ""iteration""). n_checkpoints = length(checkpoints); checkpointed = n_checkpoints > 0 ? true : false. mode = checkpointed ? ""a"" : ""c""; ```. Would be nice if `NetCDFOutputWriter` switched to `mode = ""a""` if a file exists (and print a warning).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1160
https://github.com/CliMA/Oceananigans.jl/issues/1160:591,Availability,checkpoint,checkpointed,591,"By default `NetCDFOutputWriter` uses `mode = ""c""` which overwrites existing files. The problem arises when using the same script to checkpoint and pickup (i.e. running the same script over and over): `mode = ""c""` is fine the first run but after that you want `mode = ""a""`. Making the user explicitly select the `mode` will force the user to check if there's a checkpoint to select a mode, which will add boilerplate code like. ```julia; searchdir(path, key) = filter(x -> occursin(key, x), readdir(path)); checkpoints = searchdir(base_dir, ""iteration""). n_checkpoints = length(checkpoints); checkpointed = n_checkpoints > 0 ? true : false. mode = checkpointed ? ""a"" : ""c""; ```. Would be nice if `NetCDFOutputWriter` switched to `mode = ""a""` if a file exists (and print a warning).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1160
https://github.com/CliMA/Oceananigans.jl/issues/1160:647,Availability,checkpoint,checkpointed,647,"By default `NetCDFOutputWriter` uses `mode = ""c""` which overwrites existing files. The problem arises when using the same script to checkpoint and pickup (i.e. running the same script over and over): `mode = ""c""` is fine the first run but after that you want `mode = ""a""`. Making the user explicitly select the `mode` will force the user to check if there's a checkpoint to select a mode, which will add boilerplate code like. ```julia; searchdir(path, key) = filter(x -> occursin(key, x), readdir(path)); checkpoints = searchdir(base_dir, ""iteration""). n_checkpoints = length(checkpoints); checkpointed = n_checkpoints > 0 ? true : false. mode = checkpointed ? ""a"" : ""c""; ```. Would be nice if `NetCDFOutputWriter` switched to `mode = ""a""` if a file exists (and print a warning).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1160
https://github.com/CliMA/Oceananigans.jl/issues/1163:1295,Performance,perform,performed,1295,"writer should be separated from output writer ""initialization"". Currently both JLD2 and NetCDF output writers open their files and save a bunch of data when they are constructed. For example, . https://github.com/CliMA/Oceananigans.jl/blob/7b029a75b8e17d3ca818db27eba41fd5d3a0397e/src/OutputWriters/netcdf_output_writer.jl#L300-L328. and. https://github.com/CliMA/Oceananigans.jl/blob/7b029a75b8e17d3ca818db27eba41fd5d3a0397e/src/OutputWriters/jld2_output_writer.jl#L170-L181. This initialization can make ""pickup"" of a simulation annoying. For example, the JLD2 writer will _remove_ an existing file if `force=true`:. https://github.com/CliMA/Oceananigans.jl/blob/7b029a75b8e17d3ca818db27eba41fd5d3a0397e/src/OutputWriters/jld2_output_writer.jl#L172. This is desirable when experimenting with a script and setting up (and thus we usually set `force=true` in examples as a matter of user-friendliness). But if you're picking up a simulation you certainly don't want to set `force=true`, since this will overwrite existing data. Another example is the warning implemented in #1162 , which I suppose one must resign themselves to always receiving if they are picking up a simulation?. Debacles such as these might be avoided if we performed initialization in `run!` rather than when the output writers are created --- because then we can implement special behavior in the case that we are picking up a simulation. More or less I think the point here is that we don't _know_ if we want to create / destroy a file until `run!` is called with appropriate arguments. If `run!` is never called, there will not be output (so maybe we don't want to create a file). If `run!` is called and we are not picking up and `force` or `overwrite_existing=true` then we should do that. But if `run!` is called and `pickup=true` we can likely assume that existing files should not be deleted. Output writing only occurs in `run!`, so it might make sense to let `run!` also manage the creation / deletion of output files.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1163
https://github.com/CliMA/Oceananigans.jl/issues/1163:1281,Safety,avoid,avoided,1281,"writer should be separated from output writer ""initialization"". Currently both JLD2 and NetCDF output writers open their files and save a bunch of data when they are constructed. For example, . https://github.com/CliMA/Oceananigans.jl/blob/7b029a75b8e17d3ca818db27eba41fd5d3a0397e/src/OutputWriters/netcdf_output_writer.jl#L300-L328. and. https://github.com/CliMA/Oceananigans.jl/blob/7b029a75b8e17d3ca818db27eba41fd5d3a0397e/src/OutputWriters/jld2_output_writer.jl#L170-L181. This initialization can make ""pickup"" of a simulation annoying. For example, the JLD2 writer will _remove_ an existing file if `force=true`:. https://github.com/CliMA/Oceananigans.jl/blob/7b029a75b8e17d3ca818db27eba41fd5d3a0397e/src/OutputWriters/jld2_output_writer.jl#L172. This is desirable when experimenting with a script and setting up (and thus we usually set `force=true` in examples as a matter of user-friendliness). But if you're picking up a simulation you certainly don't want to set `force=true`, since this will overwrite existing data. Another example is the warning implemented in #1162 , which I suppose one must resign themselves to always receiving if they are picking up a simulation?. Debacles such as these might be avoided if we performed initialization in `run!` rather than when the output writers are created --- because then we can implement special behavior in the case that we are picking up a simulation. More or less I think the point here is that we don't _know_ if we want to create / destroy a file until `run!` is called with appropriate arguments. If `run!` is never called, there will not be output (so maybe we don't want to create a file). If `run!` is called and we are not picking up and `force` or `overwrite_existing=true` then we should do that. But if `run!` is called and `pickup=true` we can likely assume that existing files should not be deleted. Output writing only occurs in `run!`, so it might make sense to let `run!` also manage the creation / deletion of output files.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1163
https://github.com/CliMA/Oceananigans.jl/issues/1165:124,Modifiability,refactor,refactor,124,"As discussed on #1153 we may start developing a `ShallowWaterModel` soon. To reuse as much code as possible, we may want to refactor the `TimeSteppers` and `Models` modules. Right now, `TimeSteppers` is included after `Models`:. https://github.com/CliMA/Oceananigans.jl/blob/4b972b580e7db9f49c314ab09280a2f99e5c1e32/src/Oceananigans.jl#L136-L137. However, with more than one model, we probably want to use dispatch to control the behavior of key functions in the time-steppers. For example, we'd have. ```julia; calculate_pressure_correction!(::ShallowWaterModel) = nothing; pressure_correct_velocities!(::ShallowWaterModel) = nothing; ```. Thus I think what we want to do is to include the `TimeSteppers` module first, with the definitions. ```julia; function calculate_pressure_correction! end; function pressure_correct_velocities! end; ```. and subsequently add methods in the `Models` submodule appropriate to the physics / formulation of each model.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1165
https://github.com/CliMA/Oceananigans.jl/pull/1169:1949,Availability,down,down,1949,"alyze, visualize, and compare benchmark results. It's also easier to add new benchmarks. And we have automated multithreading benchmarks (we can approach MPI benchmarking in a similar manner). We used to use TimerOutputs.jl for benchmarking but really it's made more for profiling. This PR; 1. switches to using the `BenchmarkGroup` from BenchmarkTools.jl which makes it easy to compare benchmarks (e.g. check for CPU -> GPU performance and for performance relative to a base case).; 2. Dataframes.jl and PrettyTables.jl are used to visualize benchmarks, which are prettier, and you can output HTML tables that can be easily embedded into documentation.; 3. PkgBenchmark.jl allows use to compare benchmarks between two commits or branches (right now only via `benchmark_regression.jl`) which should make it easy to automate checking for performance regressions between PRs and the master branch. The next big step for benchmarking would be to create a Buildkite benchmarks pipeline that can be triggered via GitHub comments (this would involve looking into https://github.com/buildkite/trigger-pipeline-action). I started embedding HTML tables into the docs but it's going to be hard for users to parse tables full of numbers. Plots and bar graphs might be much more useful here, but this might require a Buildkite pipeline to generate the figures to embed into the documentation. So I'll leave this important step for a different PR. I also want to add a script that generates a better version of the benchmark plots in the README, but this might have to wait for a future PR. It's a little rough around the edges but I think it's polished enough to be considered for merging. Feels like benchmarks share a lot of boilerplate but might try to reduce it in a future PR. Some fun benchmarking facts:; * GPU models using WENO-5 are 250x faster than CPU models using WENO-5!; * TEOS-10 slows down your CPU model by ~30%, but only ~3% for GPU models!; * 2D Leith is most expensive closure. Resolves #1088",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169
https://github.com/CliMA/Oceananigans.jl/pull/1169:1033,Deployability,pipeline,pipeline,1033,"it's easier to analyze, visualize, and compare benchmark results. It's also easier to add new benchmarks. And we have automated multithreading benchmarks (we can approach MPI benchmarking in a similar manner). We used to use TimerOutputs.jl for benchmarking but really it's made more for profiling. This PR; 1. switches to using the `BenchmarkGroup` from BenchmarkTools.jl which makes it easy to compare benchmarks (e.g. check for CPU -> GPU performance and for performance relative to a base case).; 2. Dataframes.jl and PrettyTables.jl are used to visualize benchmarks, which are prettier, and you can output HTML tables that can be easily embedded into documentation.; 3. PkgBenchmark.jl allows use to compare benchmarks between two commits or branches (right now only via `benchmark_regression.jl`) which should make it easy to automate checking for performance regressions between PRs and the master branch. The next big step for benchmarking would be to create a Buildkite benchmarks pipeline that can be triggered via GitHub comments (this would involve looking into https://github.com/buildkite/trigger-pipeline-action). I started embedding HTML tables into the docs but it's going to be hard for users to parse tables full of numbers. Plots and bar graphs might be much more useful here, but this might require a Buildkite pipeline to generate the figures to embed into the documentation. So I'll leave this important step for a different PR. I also want to add a script that generates a better version of the benchmark plots in the README, but this might have to wait for a future PR. It's a little rough around the edges but I think it's polished enough to be considered for merging. Feels like benchmarks share a lot of boilerplate but might try to reduce it in a future PR. Some fun benchmarking facts:; * GPU models using WENO-5 are 250x faster than CPU models using WENO-5!; * TEOS-10 slows down your CPU model by ~30%, but only ~3% for GPU models!; * 2D Leith is most expensive closure",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169
https://github.com/CliMA/Oceananigans.jl/pull/1169:1154,Deployability,pipeline,pipeline-action,1154,"alyze, visualize, and compare benchmark results. It's also easier to add new benchmarks. And we have automated multithreading benchmarks (we can approach MPI benchmarking in a similar manner). We used to use TimerOutputs.jl for benchmarking but really it's made more for profiling. This PR; 1. switches to using the `BenchmarkGroup` from BenchmarkTools.jl which makes it easy to compare benchmarks (e.g. check for CPU -> GPU performance and for performance relative to a base case).; 2. Dataframes.jl and PrettyTables.jl are used to visualize benchmarks, which are prettier, and you can output HTML tables that can be easily embedded into documentation.; 3. PkgBenchmark.jl allows use to compare benchmarks between two commits or branches (right now only via `benchmark_regression.jl`) which should make it easy to automate checking for performance regressions between PRs and the master branch. The next big step for benchmarking would be to create a Buildkite benchmarks pipeline that can be triggered via GitHub comments (this would involve looking into https://github.com/buildkite/trigger-pipeline-action). I started embedding HTML tables into the docs but it's going to be hard for users to parse tables full of numbers. Plots and bar graphs might be much more useful here, but this might require a Buildkite pipeline to generate the figures to embed into the documentation. So I'll leave this important step for a different PR. I also want to add a script that generates a better version of the benchmark plots in the README, but this might have to wait for a future PR. It's a little rough around the edges but I think it's polished enough to be considered for merging. Feels like benchmarks share a lot of boilerplate but might try to reduce it in a future PR. Some fun benchmarking facts:; * GPU models using WENO-5 are 250x faster than CPU models using WENO-5!; * TEOS-10 slows down your CPU model by ~30%, but only ~3% for GPU models!; * 2D Leith is most expensive closure. Resolves #1088",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169
https://github.com/CliMA/Oceananigans.jl/pull/1169:1375,Deployability,pipeline,pipeline,1375,"alyze, visualize, and compare benchmark results. It's also easier to add new benchmarks. And we have automated multithreading benchmarks (we can approach MPI benchmarking in a similar manner). We used to use TimerOutputs.jl for benchmarking but really it's made more for profiling. This PR; 1. switches to using the `BenchmarkGroup` from BenchmarkTools.jl which makes it easy to compare benchmarks (e.g. check for CPU -> GPU performance and for performance relative to a base case).; 2. Dataframes.jl and PrettyTables.jl are used to visualize benchmarks, which are prettier, and you can output HTML tables that can be easily embedded into documentation.; 3. PkgBenchmark.jl allows use to compare benchmarks between two commits or branches (right now only via `benchmark_regression.jl`) which should make it easy to automate checking for performance regressions between PRs and the master branch. The next big step for benchmarking would be to create a Buildkite benchmarks pipeline that can be triggered via GitHub comments (this would involve looking into https://github.com/buildkite/trigger-pipeline-action). I started embedding HTML tables into the docs but it's going to be hard for users to parse tables full of numbers. Plots and bar graphs might be much more useful here, but this might require a Buildkite pipeline to generate the figures to embed into the documentation. So I'll leave this important step for a different PR. I also want to add a script that generates a better version of the benchmark plots in the README, but this might have to wait for a future PR. It's a little rough around the edges but I think it's polished enough to be considered for merging. Feels like benchmarks share a lot of boilerplate but might try to reduce it in a future PR. Some fun benchmarking facts:; * GPU models using WENO-5 are 250x faster than CPU models using WENO-5!; * TEOS-10 slows down your CPU model by ~30%, but only ~3% for GPU models!; * 2D Leith is most expensive closure. Resolves #1088",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169
https://github.com/CliMA/Oceananigans.jl/pull/1169:1804,Energy Efficiency,reduce,reduce,1804,"alyze, visualize, and compare benchmark results. It's also easier to add new benchmarks. And we have automated multithreading benchmarks (we can approach MPI benchmarking in a similar manner). We used to use TimerOutputs.jl for benchmarking but really it's made more for profiling. This PR; 1. switches to using the `BenchmarkGroup` from BenchmarkTools.jl which makes it easy to compare benchmarks (e.g. check for CPU -> GPU performance and for performance relative to a base case).; 2. Dataframes.jl and PrettyTables.jl are used to visualize benchmarks, which are prettier, and you can output HTML tables that can be easily embedded into documentation.; 3. PkgBenchmark.jl allows use to compare benchmarks between two commits or branches (right now only via `benchmark_regression.jl`) which should make it easy to automate checking for performance regressions between PRs and the master branch. The next big step for benchmarking would be to create a Buildkite benchmarks pipeline that can be triggered via GitHub comments (this would involve looking into https://github.com/buildkite/trigger-pipeline-action). I started embedding HTML tables into the docs but it's going to be hard for users to parse tables full of numbers. Plots and bar graphs might be much more useful here, but this might require a Buildkite pipeline to generate the figures to embed into the documentation. So I'll leave this important step for a different PR. I also want to add a script that generates a better version of the benchmark plots in the README, but this might have to wait for a future PR. It's a little rough around the edges but I think it's polished enough to be considered for merging. Feels like benchmarks share a lot of boilerplate but might try to reduce it in a future PR. Some fun benchmarking facts:; * GPU models using WENO-5 are 250x faster than CPU models using WENO-5!; * TEOS-10 slows down your CPU model by ~30%, but only ~3% for GPU models!; * 2D Leith is most expensive closure. Resolves #1088",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169
https://github.com/CliMA/Oceananigans.jl/pull/1169:8,Modifiability,rewrite,rewrites,8,"This PR rewrites how we do benchmarking so it's easier to analyze, visualize, and compare benchmark results. It's also easier to add new benchmarks. And we have automated multithreading benchmarks (we can approach MPI benchmarking in a similar manner). We used to use TimerOutputs.jl for benchmarking but really it's made more for profiling. This PR; 1. switches to using the `BenchmarkGroup` from BenchmarkTools.jl which makes it easy to compare benchmarks (e.g. check for CPU -> GPU performance and for performance relative to a base case).; 2. Dataframes.jl and PrettyTables.jl are used to visualize benchmarks, which are prettier, and you can output HTML tables that can be easily embedded into documentation.; 3. PkgBenchmark.jl allows use to compare benchmarks between two commits or branches (right now only via `benchmark_regression.jl`) which should make it easy to automate checking for performance regressions between PRs and the master branch. The next big step for benchmarking would be to create a Buildkite benchmarks pipeline that can be triggered via GitHub comments (this would involve looking into https://github.com/buildkite/trigger-pipeline-action). I started embedding HTML tables into the docs but it's going to be hard for users to parse tables full of numbers. Plots and bar graphs might be much more useful here, but this might require a Buildkite pipeline to generate the figures to embed into the documentation. So I'll leave this important step for a different PR. I also want to add a script that generates a better version of the benchmark plots in the README, but this might have to wait for a future PR. It's a little rough around the edges but I think it's polished enough to be considered for merging. Feels like benchmarks share a lot of boilerplate but might try to reduce it in a future PR. Some fun benchmarking facts:; * GPU models using WENO-5 are 250x faster than CPU models using WENO-5!; * TEOS-10 slows down your CPU model by ~30%, but only ~3% for GPU mo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169
https://github.com/CliMA/Oceananigans.jl/pull/1169:485,Performance,perform,performance,485,"This PR rewrites how we do benchmarking so it's easier to analyze, visualize, and compare benchmark results. It's also easier to add new benchmarks. And we have automated multithreading benchmarks (we can approach MPI benchmarking in a similar manner). We used to use TimerOutputs.jl for benchmarking but really it's made more for profiling. This PR; 1. switches to using the `BenchmarkGroup` from BenchmarkTools.jl which makes it easy to compare benchmarks (e.g. check for CPU -> GPU performance and for performance relative to a base case).; 2. Dataframes.jl and PrettyTables.jl are used to visualize benchmarks, which are prettier, and you can output HTML tables that can be easily embedded into documentation.; 3. PkgBenchmark.jl allows use to compare benchmarks between two commits or branches (right now only via `benchmark_regression.jl`) which should make it easy to automate checking for performance regressions between PRs and the master branch. The next big step for benchmarking would be to create a Buildkite benchmarks pipeline that can be triggered via GitHub comments (this would involve looking into https://github.com/buildkite/trigger-pipeline-action). I started embedding HTML tables into the docs but it's going to be hard for users to parse tables full of numbers. Plots and bar graphs might be much more useful here, but this might require a Buildkite pipeline to generate the figures to embed into the documentation. So I'll leave this important step for a different PR. I also want to add a script that generates a better version of the benchmark plots in the README, but this might have to wait for a future PR. It's a little rough around the edges but I think it's polished enough to be considered for merging. Feels like benchmarks share a lot of boilerplate but might try to reduce it in a future PR. Some fun benchmarking facts:; * GPU models using WENO-5 are 250x faster than CPU models using WENO-5!; * TEOS-10 slows down your CPU model by ~30%, but only ~3% for GPU mo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169
https://github.com/CliMA/Oceananigans.jl/pull/1169:505,Performance,perform,performance,505,"This PR rewrites how we do benchmarking so it's easier to analyze, visualize, and compare benchmark results. It's also easier to add new benchmarks. And we have automated multithreading benchmarks (we can approach MPI benchmarking in a similar manner). We used to use TimerOutputs.jl for benchmarking but really it's made more for profiling. This PR; 1. switches to using the `BenchmarkGroup` from BenchmarkTools.jl which makes it easy to compare benchmarks (e.g. check for CPU -> GPU performance and for performance relative to a base case).; 2. Dataframes.jl and PrettyTables.jl are used to visualize benchmarks, which are prettier, and you can output HTML tables that can be easily embedded into documentation.; 3. PkgBenchmark.jl allows use to compare benchmarks between two commits or branches (right now only via `benchmark_regression.jl`) which should make it easy to automate checking for performance regressions between PRs and the master branch. The next big step for benchmarking would be to create a Buildkite benchmarks pipeline that can be triggered via GitHub comments (this would involve looking into https://github.com/buildkite/trigger-pipeline-action). I started embedding HTML tables into the docs but it's going to be hard for users to parse tables full of numbers. Plots and bar graphs might be much more useful here, but this might require a Buildkite pipeline to generate the figures to embed into the documentation. So I'll leave this important step for a different PR. I also want to add a script that generates a better version of the benchmark plots in the README, but this might have to wait for a future PR. It's a little rough around the edges but I think it's polished enough to be considered for merging. Feels like benchmarks share a lot of boilerplate but might try to reduce it in a future PR. Some fun benchmarking facts:; * GPU models using WENO-5 are 250x faster than CPU models using WENO-5!; * TEOS-10 slows down your CPU model by ~30%, but only ~3% for GPU mo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169
https://github.com/CliMA/Oceananigans.jl/pull/1169:897,Performance,perform,performance,897,"This PR rewrites how we do benchmarking so it's easier to analyze, visualize, and compare benchmark results. It's also easier to add new benchmarks. And we have automated multithreading benchmarks (we can approach MPI benchmarking in a similar manner). We used to use TimerOutputs.jl for benchmarking but really it's made more for profiling. This PR; 1. switches to using the `BenchmarkGroup` from BenchmarkTools.jl which makes it easy to compare benchmarks (e.g. check for CPU -> GPU performance and for performance relative to a base case).; 2. Dataframes.jl and PrettyTables.jl are used to visualize benchmarks, which are prettier, and you can output HTML tables that can be easily embedded into documentation.; 3. PkgBenchmark.jl allows use to compare benchmarks between two commits or branches (right now only via `benchmark_regression.jl`) which should make it easy to automate checking for performance regressions between PRs and the master branch. The next big step for benchmarking would be to create a Buildkite benchmarks pipeline that can be triggered via GitHub comments (this would involve looking into https://github.com/buildkite/trigger-pipeline-action). I started embedding HTML tables into the docs but it's going to be hard for users to parse tables full of numbers. Plots and bar graphs might be much more useful here, but this might require a Buildkite pipeline to generate the figures to embed into the documentation. So I'll leave this important step for a different PR. I also want to add a script that generates a better version of the benchmark plots in the README, but this might have to wait for a future PR. It's a little rough around the edges but I think it's polished enough to be considered for merging. Feels like benchmarks share a lot of boilerplate but might try to reduce it in a future PR. Some fun benchmarking facts:; * GPU models using WENO-5 are 250x faster than CPU models using WENO-5!; * TEOS-10 slows down your CPU model by ~30%, but only ~3% for GPU mo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169
https://github.com/CliMA/Oceananigans.jl/pull/1169:27,Testability,benchmark,benchmarking,27,"This PR rewrites how we do benchmarking so it's easier to analyze, visualize, and compare benchmark results. It's also easier to add new benchmarks. And we have automated multithreading benchmarks (we can approach MPI benchmarking in a similar manner). We used to use TimerOutputs.jl for benchmarking but really it's made more for profiling. This PR; 1. switches to using the `BenchmarkGroup` from BenchmarkTools.jl which makes it easy to compare benchmarks (e.g. check for CPU -> GPU performance and for performance relative to a base case).; 2. Dataframes.jl and PrettyTables.jl are used to visualize benchmarks, which are prettier, and you can output HTML tables that can be easily embedded into documentation.; 3. PkgBenchmark.jl allows use to compare benchmarks between two commits or branches (right now only via `benchmark_regression.jl`) which should make it easy to automate checking for performance regressions between PRs and the master branch. The next big step for benchmarking would be to create a Buildkite benchmarks pipeline that can be triggered via GitHub comments (this would involve looking into https://github.com/buildkite/trigger-pipeline-action). I started embedding HTML tables into the docs but it's going to be hard for users to parse tables full of numbers. Plots and bar graphs might be much more useful here, but this might require a Buildkite pipeline to generate the figures to embed into the documentation. So I'll leave this important step for a different PR. I also want to add a script that generates a better version of the benchmark plots in the README, but this might have to wait for a future PR. It's a little rough around the edges but I think it's polished enough to be considered for merging. Feels like benchmarks share a lot of boilerplate but might try to reduce it in a future PR. Some fun benchmarking facts:; * GPU models using WENO-5 are 250x faster than CPU models using WENO-5!; * TEOS-10 slows down your CPU model by ~30%, but only ~3% for GPU mo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169
https://github.com/CliMA/Oceananigans.jl/pull/1169:90,Testability,benchmark,benchmark,90,"This PR rewrites how we do benchmarking so it's easier to analyze, visualize, and compare benchmark results. It's also easier to add new benchmarks. And we have automated multithreading benchmarks (we can approach MPI benchmarking in a similar manner). We used to use TimerOutputs.jl for benchmarking but really it's made more for profiling. This PR; 1. switches to using the `BenchmarkGroup` from BenchmarkTools.jl which makes it easy to compare benchmarks (e.g. check for CPU -> GPU performance and for performance relative to a base case).; 2. Dataframes.jl and PrettyTables.jl are used to visualize benchmarks, which are prettier, and you can output HTML tables that can be easily embedded into documentation.; 3. PkgBenchmark.jl allows use to compare benchmarks between two commits or branches (right now only via `benchmark_regression.jl`) which should make it easy to automate checking for performance regressions between PRs and the master branch. The next big step for benchmarking would be to create a Buildkite benchmarks pipeline that can be triggered via GitHub comments (this would involve looking into https://github.com/buildkite/trigger-pipeline-action). I started embedding HTML tables into the docs but it's going to be hard for users to parse tables full of numbers. Plots and bar graphs might be much more useful here, but this might require a Buildkite pipeline to generate the figures to embed into the documentation. So I'll leave this important step for a different PR. I also want to add a script that generates a better version of the benchmark plots in the README, but this might have to wait for a future PR. It's a little rough around the edges but I think it's polished enough to be considered for merging. Feels like benchmarks share a lot of boilerplate but might try to reduce it in a future PR. Some fun benchmarking facts:; * GPU models using WENO-5 are 250x faster than CPU models using WENO-5!; * TEOS-10 slows down your CPU model by ~30%, but only ~3% for GPU mo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169
https://github.com/CliMA/Oceananigans.jl/pull/1169:137,Testability,benchmark,benchmarks,137,"This PR rewrites how we do benchmarking so it's easier to analyze, visualize, and compare benchmark results. It's also easier to add new benchmarks. And we have automated multithreading benchmarks (we can approach MPI benchmarking in a similar manner). We used to use TimerOutputs.jl for benchmarking but really it's made more for profiling. This PR; 1. switches to using the `BenchmarkGroup` from BenchmarkTools.jl which makes it easy to compare benchmarks (e.g. check for CPU -> GPU performance and for performance relative to a base case).; 2. Dataframes.jl and PrettyTables.jl are used to visualize benchmarks, which are prettier, and you can output HTML tables that can be easily embedded into documentation.; 3. PkgBenchmark.jl allows use to compare benchmarks between two commits or branches (right now only via `benchmark_regression.jl`) which should make it easy to automate checking for performance regressions between PRs and the master branch. The next big step for benchmarking would be to create a Buildkite benchmarks pipeline that can be triggered via GitHub comments (this would involve looking into https://github.com/buildkite/trigger-pipeline-action). I started embedding HTML tables into the docs but it's going to be hard for users to parse tables full of numbers. Plots and bar graphs might be much more useful here, but this might require a Buildkite pipeline to generate the figures to embed into the documentation. So I'll leave this important step for a different PR. I also want to add a script that generates a better version of the benchmark plots in the README, but this might have to wait for a future PR. It's a little rough around the edges but I think it's polished enough to be considered for merging. Feels like benchmarks share a lot of boilerplate but might try to reduce it in a future PR. Some fun benchmarking facts:; * GPU models using WENO-5 are 250x faster than CPU models using WENO-5!; * TEOS-10 slows down your CPU model by ~30%, but only ~3% for GPU mo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169
https://github.com/CliMA/Oceananigans.jl/pull/1169:186,Testability,benchmark,benchmarks,186,"This PR rewrites how we do benchmarking so it's easier to analyze, visualize, and compare benchmark results. It's also easier to add new benchmarks. And we have automated multithreading benchmarks (we can approach MPI benchmarking in a similar manner). We used to use TimerOutputs.jl for benchmarking but really it's made more for profiling. This PR; 1. switches to using the `BenchmarkGroup` from BenchmarkTools.jl which makes it easy to compare benchmarks (e.g. check for CPU -> GPU performance and for performance relative to a base case).; 2. Dataframes.jl and PrettyTables.jl are used to visualize benchmarks, which are prettier, and you can output HTML tables that can be easily embedded into documentation.; 3. PkgBenchmark.jl allows use to compare benchmarks between two commits or branches (right now only via `benchmark_regression.jl`) which should make it easy to automate checking for performance regressions between PRs and the master branch. The next big step for benchmarking would be to create a Buildkite benchmarks pipeline that can be triggered via GitHub comments (this would involve looking into https://github.com/buildkite/trigger-pipeline-action). I started embedding HTML tables into the docs but it's going to be hard for users to parse tables full of numbers. Plots and bar graphs might be much more useful here, but this might require a Buildkite pipeline to generate the figures to embed into the documentation. So I'll leave this important step for a different PR. I also want to add a script that generates a better version of the benchmark plots in the README, but this might have to wait for a future PR. It's a little rough around the edges but I think it's polished enough to be considered for merging. Feels like benchmarks share a lot of boilerplate but might try to reduce it in a future PR. Some fun benchmarking facts:; * GPU models using WENO-5 are 250x faster than CPU models using WENO-5!; * TEOS-10 slows down your CPU model by ~30%, but only ~3% for GPU mo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169
https://github.com/CliMA/Oceananigans.jl/pull/1169:218,Testability,benchmark,benchmarking,218,"This PR rewrites how we do benchmarking so it's easier to analyze, visualize, and compare benchmark results. It's also easier to add new benchmarks. And we have automated multithreading benchmarks (we can approach MPI benchmarking in a similar manner). We used to use TimerOutputs.jl for benchmarking but really it's made more for profiling. This PR; 1. switches to using the `BenchmarkGroup` from BenchmarkTools.jl which makes it easy to compare benchmarks (e.g. check for CPU -> GPU performance and for performance relative to a base case).; 2. Dataframes.jl and PrettyTables.jl are used to visualize benchmarks, which are prettier, and you can output HTML tables that can be easily embedded into documentation.; 3. PkgBenchmark.jl allows use to compare benchmarks between two commits or branches (right now only via `benchmark_regression.jl`) which should make it easy to automate checking for performance regressions between PRs and the master branch. The next big step for benchmarking would be to create a Buildkite benchmarks pipeline that can be triggered via GitHub comments (this would involve looking into https://github.com/buildkite/trigger-pipeline-action). I started embedding HTML tables into the docs but it's going to be hard for users to parse tables full of numbers. Plots and bar graphs might be much more useful here, but this might require a Buildkite pipeline to generate the figures to embed into the documentation. So I'll leave this important step for a different PR. I also want to add a script that generates a better version of the benchmark plots in the README, but this might have to wait for a future PR. It's a little rough around the edges but I think it's polished enough to be considered for merging. Feels like benchmarks share a lot of boilerplate but might try to reduce it in a future PR. Some fun benchmarking facts:; * GPU models using WENO-5 are 250x faster than CPU models using WENO-5!; * TEOS-10 slows down your CPU model by ~30%, but only ~3% for GPU mo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169
https://github.com/CliMA/Oceananigans.jl/pull/1169:288,Testability,benchmark,benchmarking,288,"This PR rewrites how we do benchmarking so it's easier to analyze, visualize, and compare benchmark results. It's also easier to add new benchmarks. And we have automated multithreading benchmarks (we can approach MPI benchmarking in a similar manner). We used to use TimerOutputs.jl for benchmarking but really it's made more for profiling. This PR; 1. switches to using the `BenchmarkGroup` from BenchmarkTools.jl which makes it easy to compare benchmarks (e.g. check for CPU -> GPU performance and for performance relative to a base case).; 2. Dataframes.jl and PrettyTables.jl are used to visualize benchmarks, which are prettier, and you can output HTML tables that can be easily embedded into documentation.; 3. PkgBenchmark.jl allows use to compare benchmarks between two commits or branches (right now only via `benchmark_regression.jl`) which should make it easy to automate checking for performance regressions between PRs and the master branch. The next big step for benchmarking would be to create a Buildkite benchmarks pipeline that can be triggered via GitHub comments (this would involve looking into https://github.com/buildkite/trigger-pipeline-action). I started embedding HTML tables into the docs but it's going to be hard for users to parse tables full of numbers. Plots and bar graphs might be much more useful here, but this might require a Buildkite pipeline to generate the figures to embed into the documentation. So I'll leave this important step for a different PR. I also want to add a script that generates a better version of the benchmark plots in the README, but this might have to wait for a future PR. It's a little rough around the edges but I think it's polished enough to be considered for merging. Feels like benchmarks share a lot of boilerplate but might try to reduce it in a future PR. Some fun benchmarking facts:; * GPU models using WENO-5 are 250x faster than CPU models using WENO-5!; * TEOS-10 slows down your CPU model by ~30%, but only ~3% for GPU mo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169
https://github.com/CliMA/Oceananigans.jl/pull/1169:377,Testability,Benchmark,BenchmarkGroup,377,"This PR rewrites how we do benchmarking so it's easier to analyze, visualize, and compare benchmark results. It's also easier to add new benchmarks. And we have automated multithreading benchmarks (we can approach MPI benchmarking in a similar manner). We used to use TimerOutputs.jl for benchmarking but really it's made more for profiling. This PR; 1. switches to using the `BenchmarkGroup` from BenchmarkTools.jl which makes it easy to compare benchmarks (e.g. check for CPU -> GPU performance and for performance relative to a base case).; 2. Dataframes.jl and PrettyTables.jl are used to visualize benchmarks, which are prettier, and you can output HTML tables that can be easily embedded into documentation.; 3. PkgBenchmark.jl allows use to compare benchmarks between two commits or branches (right now only via `benchmark_regression.jl`) which should make it easy to automate checking for performance regressions between PRs and the master branch. The next big step for benchmarking would be to create a Buildkite benchmarks pipeline that can be triggered via GitHub comments (this would involve looking into https://github.com/buildkite/trigger-pipeline-action). I started embedding HTML tables into the docs but it's going to be hard for users to parse tables full of numbers. Plots and bar graphs might be much more useful here, but this might require a Buildkite pipeline to generate the figures to embed into the documentation. So I'll leave this important step for a different PR. I also want to add a script that generates a better version of the benchmark plots in the README, but this might have to wait for a future PR. It's a little rough around the edges but I think it's polished enough to be considered for merging. Feels like benchmarks share a lot of boilerplate but might try to reduce it in a future PR. Some fun benchmarking facts:; * GPU models using WENO-5 are 250x faster than CPU models using WENO-5!; * TEOS-10 slows down your CPU model by ~30%, but only ~3% for GPU mo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169
https://github.com/CliMA/Oceananigans.jl/pull/1169:398,Testability,Benchmark,BenchmarkTools,398,"This PR rewrites how we do benchmarking so it's easier to analyze, visualize, and compare benchmark results. It's also easier to add new benchmarks. And we have automated multithreading benchmarks (we can approach MPI benchmarking in a similar manner). We used to use TimerOutputs.jl for benchmarking but really it's made more for profiling. This PR; 1. switches to using the `BenchmarkGroup` from BenchmarkTools.jl which makes it easy to compare benchmarks (e.g. check for CPU -> GPU performance and for performance relative to a base case).; 2. Dataframes.jl and PrettyTables.jl are used to visualize benchmarks, which are prettier, and you can output HTML tables that can be easily embedded into documentation.; 3. PkgBenchmark.jl allows use to compare benchmarks between two commits or branches (right now only via `benchmark_regression.jl`) which should make it easy to automate checking for performance regressions between PRs and the master branch. The next big step for benchmarking would be to create a Buildkite benchmarks pipeline that can be triggered via GitHub comments (this would involve looking into https://github.com/buildkite/trigger-pipeline-action). I started embedding HTML tables into the docs but it's going to be hard for users to parse tables full of numbers. Plots and bar graphs might be much more useful here, but this might require a Buildkite pipeline to generate the figures to embed into the documentation. So I'll leave this important step for a different PR. I also want to add a script that generates a better version of the benchmark plots in the README, but this might have to wait for a future PR. It's a little rough around the edges but I think it's polished enough to be considered for merging. Feels like benchmarks share a lot of boilerplate but might try to reduce it in a future PR. Some fun benchmarking facts:; * GPU models using WENO-5 are 250x faster than CPU models using WENO-5!; * TEOS-10 slows down your CPU model by ~30%, but only ~3% for GPU mo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169
https://github.com/CliMA/Oceananigans.jl/pull/1169:447,Testability,benchmark,benchmarks,447,"This PR rewrites how we do benchmarking so it's easier to analyze, visualize, and compare benchmark results. It's also easier to add new benchmarks. And we have automated multithreading benchmarks (we can approach MPI benchmarking in a similar manner). We used to use TimerOutputs.jl for benchmarking but really it's made more for profiling. This PR; 1. switches to using the `BenchmarkGroup` from BenchmarkTools.jl which makes it easy to compare benchmarks (e.g. check for CPU -> GPU performance and for performance relative to a base case).; 2. Dataframes.jl and PrettyTables.jl are used to visualize benchmarks, which are prettier, and you can output HTML tables that can be easily embedded into documentation.; 3. PkgBenchmark.jl allows use to compare benchmarks between two commits or branches (right now only via `benchmark_regression.jl`) which should make it easy to automate checking for performance regressions between PRs and the master branch. The next big step for benchmarking would be to create a Buildkite benchmarks pipeline that can be triggered via GitHub comments (this would involve looking into https://github.com/buildkite/trigger-pipeline-action). I started embedding HTML tables into the docs but it's going to be hard for users to parse tables full of numbers. Plots and bar graphs might be much more useful here, but this might require a Buildkite pipeline to generate the figures to embed into the documentation. So I'll leave this important step for a different PR. I also want to add a script that generates a better version of the benchmark plots in the README, but this might have to wait for a future PR. It's a little rough around the edges but I think it's polished enough to be considered for merging. Feels like benchmarks share a lot of boilerplate but might try to reduce it in a future PR. Some fun benchmarking facts:; * GPU models using WENO-5 are 250x faster than CPU models using WENO-5!; * TEOS-10 slows down your CPU model by ~30%, but only ~3% for GPU mo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169
https://github.com/CliMA/Oceananigans.jl/pull/1169:603,Testability,benchmark,benchmarks,603,"This PR rewrites how we do benchmarking so it's easier to analyze, visualize, and compare benchmark results. It's also easier to add new benchmarks. And we have automated multithreading benchmarks (we can approach MPI benchmarking in a similar manner). We used to use TimerOutputs.jl for benchmarking but really it's made more for profiling. This PR; 1. switches to using the `BenchmarkGroup` from BenchmarkTools.jl which makes it easy to compare benchmarks (e.g. check for CPU -> GPU performance and for performance relative to a base case).; 2. Dataframes.jl and PrettyTables.jl are used to visualize benchmarks, which are prettier, and you can output HTML tables that can be easily embedded into documentation.; 3. PkgBenchmark.jl allows use to compare benchmarks between two commits or branches (right now only via `benchmark_regression.jl`) which should make it easy to automate checking for performance regressions between PRs and the master branch. The next big step for benchmarking would be to create a Buildkite benchmarks pipeline that can be triggered via GitHub comments (this would involve looking into https://github.com/buildkite/trigger-pipeline-action). I started embedding HTML tables into the docs but it's going to be hard for users to parse tables full of numbers. Plots and bar graphs might be much more useful here, but this might require a Buildkite pipeline to generate the figures to embed into the documentation. So I'll leave this important step for a different PR. I also want to add a script that generates a better version of the benchmark plots in the README, but this might have to wait for a future PR. It's a little rough around the edges but I think it's polished enough to be considered for merging. Feels like benchmarks share a lot of boilerplate but might try to reduce it in a future PR. Some fun benchmarking facts:; * GPU models using WENO-5 are 250x faster than CPU models using WENO-5!; * TEOS-10 slows down your CPU model by ~30%, but only ~3% for GPU mo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169
https://github.com/CliMA/Oceananigans.jl/pull/1169:756,Testability,benchmark,benchmarks,756,"This PR rewrites how we do benchmarking so it's easier to analyze, visualize, and compare benchmark results. It's also easier to add new benchmarks. And we have automated multithreading benchmarks (we can approach MPI benchmarking in a similar manner). We used to use TimerOutputs.jl for benchmarking but really it's made more for profiling. This PR; 1. switches to using the `BenchmarkGroup` from BenchmarkTools.jl which makes it easy to compare benchmarks (e.g. check for CPU -> GPU performance and for performance relative to a base case).; 2. Dataframes.jl and PrettyTables.jl are used to visualize benchmarks, which are prettier, and you can output HTML tables that can be easily embedded into documentation.; 3. PkgBenchmark.jl allows use to compare benchmarks between two commits or branches (right now only via `benchmark_regression.jl`) which should make it easy to automate checking for performance regressions between PRs and the master branch. The next big step for benchmarking would be to create a Buildkite benchmarks pipeline that can be triggered via GitHub comments (this would involve looking into https://github.com/buildkite/trigger-pipeline-action). I started embedding HTML tables into the docs but it's going to be hard for users to parse tables full of numbers. Plots and bar graphs might be much more useful here, but this might require a Buildkite pipeline to generate the figures to embed into the documentation. So I'll leave this important step for a different PR. I also want to add a script that generates a better version of the benchmark plots in the README, but this might have to wait for a future PR. It's a little rough around the edges but I think it's polished enough to be considered for merging. Feels like benchmarks share a lot of boilerplate but might try to reduce it in a future PR. Some fun benchmarking facts:; * GPU models using WENO-5 are 250x faster than CPU models using WENO-5!; * TEOS-10 slows down your CPU model by ~30%, but only ~3% for GPU mo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169
https://github.com/CliMA/Oceananigans.jl/pull/1169:978,Testability,benchmark,benchmarking,978,"it's easier to analyze, visualize, and compare benchmark results. It's also easier to add new benchmarks. And we have automated multithreading benchmarks (we can approach MPI benchmarking in a similar manner). We used to use TimerOutputs.jl for benchmarking but really it's made more for profiling. This PR; 1. switches to using the `BenchmarkGroup` from BenchmarkTools.jl which makes it easy to compare benchmarks (e.g. check for CPU -> GPU performance and for performance relative to a base case).; 2. Dataframes.jl and PrettyTables.jl are used to visualize benchmarks, which are prettier, and you can output HTML tables that can be easily embedded into documentation.; 3. PkgBenchmark.jl allows use to compare benchmarks between two commits or branches (right now only via `benchmark_regression.jl`) which should make it easy to automate checking for performance regressions between PRs and the master branch. The next big step for benchmarking would be to create a Buildkite benchmarks pipeline that can be triggered via GitHub comments (this would involve looking into https://github.com/buildkite/trigger-pipeline-action). I started embedding HTML tables into the docs but it's going to be hard for users to parse tables full of numbers. Plots and bar graphs might be much more useful here, but this might require a Buildkite pipeline to generate the figures to embed into the documentation. So I'll leave this important step for a different PR. I also want to add a script that generates a better version of the benchmark plots in the README, but this might have to wait for a future PR. It's a little rough around the edges but I think it's polished enough to be considered for merging. Feels like benchmarks share a lot of boilerplate but might try to reduce it in a future PR. Some fun benchmarking facts:; * GPU models using WENO-5 are 250x faster than CPU models using WENO-5!; * TEOS-10 slows down your CPU model by ~30%, but only ~3% for GPU models!; * 2D Leith is most expensive closure",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169
https://github.com/CliMA/Oceananigans.jl/pull/1169:1022,Testability,benchmark,benchmarks,1022,"it's easier to analyze, visualize, and compare benchmark results. It's also easier to add new benchmarks. And we have automated multithreading benchmarks (we can approach MPI benchmarking in a similar manner). We used to use TimerOutputs.jl for benchmarking but really it's made more for profiling. This PR; 1. switches to using the `BenchmarkGroup` from BenchmarkTools.jl which makes it easy to compare benchmarks (e.g. check for CPU -> GPU performance and for performance relative to a base case).; 2. Dataframes.jl and PrettyTables.jl are used to visualize benchmarks, which are prettier, and you can output HTML tables that can be easily embedded into documentation.; 3. PkgBenchmark.jl allows use to compare benchmarks between two commits or branches (right now only via `benchmark_regression.jl`) which should make it easy to automate checking for performance regressions between PRs and the master branch. The next big step for benchmarking would be to create a Buildkite benchmarks pipeline that can be triggered via GitHub comments (this would involve looking into https://github.com/buildkite/trigger-pipeline-action). I started embedding HTML tables into the docs but it's going to be hard for users to parse tables full of numbers. Plots and bar graphs might be much more useful here, but this might require a Buildkite pipeline to generate the figures to embed into the documentation. So I'll leave this important step for a different PR. I also want to add a script that generates a better version of the benchmark plots in the README, but this might have to wait for a future PR. It's a little rough around the edges but I think it's polished enough to be considered for merging. Feels like benchmarks share a lot of boilerplate but might try to reduce it in a future PR. Some fun benchmarking facts:; * GPU models using WENO-5 are 250x faster than CPU models using WENO-5!; * TEOS-10 slows down your CPU model by ~30%, but only ~3% for GPU models!; * 2D Leith is most expensive closure",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169
https://github.com/CliMA/Oceananigans.jl/pull/1169:1562,Testability,benchmark,benchmark,1562,"alyze, visualize, and compare benchmark results. It's also easier to add new benchmarks. And we have automated multithreading benchmarks (we can approach MPI benchmarking in a similar manner). We used to use TimerOutputs.jl for benchmarking but really it's made more for profiling. This PR; 1. switches to using the `BenchmarkGroup` from BenchmarkTools.jl which makes it easy to compare benchmarks (e.g. check for CPU -> GPU performance and for performance relative to a base case).; 2. Dataframes.jl and PrettyTables.jl are used to visualize benchmarks, which are prettier, and you can output HTML tables that can be easily embedded into documentation.; 3. PkgBenchmark.jl allows use to compare benchmarks between two commits or branches (right now only via `benchmark_regression.jl`) which should make it easy to automate checking for performance regressions between PRs and the master branch. The next big step for benchmarking would be to create a Buildkite benchmarks pipeline that can be triggered via GitHub comments (this would involve looking into https://github.com/buildkite/trigger-pipeline-action). I started embedding HTML tables into the docs but it's going to be hard for users to parse tables full of numbers. Plots and bar graphs might be much more useful here, but this might require a Buildkite pipeline to generate the figures to embed into the documentation. So I'll leave this important step for a different PR. I also want to add a script that generates a better version of the benchmark plots in the README, but this might have to wait for a future PR. It's a little rough around the edges but I think it's polished enough to be considered for merging. Feels like benchmarks share a lot of boilerplate but might try to reduce it in a future PR. Some fun benchmarking facts:; * GPU models using WENO-5 are 250x faster than CPU models using WENO-5!; * TEOS-10 slows down your CPU model by ~30%, but only ~3% for GPU models!; * 2D Leith is most expensive closure. Resolves #1088",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169
https://github.com/CliMA/Oceananigans.jl/pull/1169:1749,Testability,benchmark,benchmarks,1749,"alyze, visualize, and compare benchmark results. It's also easier to add new benchmarks. And we have automated multithreading benchmarks (we can approach MPI benchmarking in a similar manner). We used to use TimerOutputs.jl for benchmarking but really it's made more for profiling. This PR; 1. switches to using the `BenchmarkGroup` from BenchmarkTools.jl which makes it easy to compare benchmarks (e.g. check for CPU -> GPU performance and for performance relative to a base case).; 2. Dataframes.jl and PrettyTables.jl are used to visualize benchmarks, which are prettier, and you can output HTML tables that can be easily embedded into documentation.; 3. PkgBenchmark.jl allows use to compare benchmarks between two commits or branches (right now only via `benchmark_regression.jl`) which should make it easy to automate checking for performance regressions between PRs and the master branch. The next big step for benchmarking would be to create a Buildkite benchmarks pipeline that can be triggered via GitHub comments (this would involve looking into https://github.com/buildkite/trigger-pipeline-action). I started embedding HTML tables into the docs but it's going to be hard for users to parse tables full of numbers. Plots and bar graphs might be much more useful here, but this might require a Buildkite pipeline to generate the figures to embed into the documentation. So I'll leave this important step for a different PR. I also want to add a script that generates a better version of the benchmark plots in the README, but this might have to wait for a future PR. It's a little rough around the edges but I think it's polished enough to be considered for merging. Feels like benchmarks share a lot of boilerplate but might try to reduce it in a future PR. Some fun benchmarking facts:; * GPU models using WENO-5 are 250x faster than CPU models using WENO-5!; * TEOS-10 slows down your CPU model by ~30%, but only ~3% for GPU models!; * 2D Leith is most expensive closure. Resolves #1088",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169
https://github.com/CliMA/Oceananigans.jl/pull/1169:1839,Testability,benchmark,benchmarking,1839,"alyze, visualize, and compare benchmark results. It's also easier to add new benchmarks. And we have automated multithreading benchmarks (we can approach MPI benchmarking in a similar manner). We used to use TimerOutputs.jl for benchmarking but really it's made more for profiling. This PR; 1. switches to using the `BenchmarkGroup` from BenchmarkTools.jl which makes it easy to compare benchmarks (e.g. check for CPU -> GPU performance and for performance relative to a base case).; 2. Dataframes.jl and PrettyTables.jl are used to visualize benchmarks, which are prettier, and you can output HTML tables that can be easily embedded into documentation.; 3. PkgBenchmark.jl allows use to compare benchmarks between two commits or branches (right now only via `benchmark_regression.jl`) which should make it easy to automate checking for performance regressions between PRs and the master branch. The next big step for benchmarking would be to create a Buildkite benchmarks pipeline that can be triggered via GitHub comments (this would involve looking into https://github.com/buildkite/trigger-pipeline-action). I started embedding HTML tables into the docs but it's going to be hard for users to parse tables full of numbers. Plots and bar graphs might be much more useful here, but this might require a Buildkite pipeline to generate the figures to embed into the documentation. So I'll leave this important step for a different PR. I also want to add a script that generates a better version of the benchmark plots in the README, but this might have to wait for a future PR. It's a little rough around the edges but I think it's polished enough to be considered for merging. Feels like benchmarks share a lot of boilerplate but might try to reduce it in a future PR. Some fun benchmarking facts:; * GPU models using WENO-5 are 250x faster than CPU models using WENO-5!; * TEOS-10 slows down your CPU model by ~30%, but only ~3% for GPU models!; * 2D Leith is most expensive closure. Resolves #1088",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169
https://github.com/CliMA/Oceananigans.jl/issues/1171:495,Energy Efficiency,schedul,schedule,495,"Building up OutputWriters can be a major source of boilerplate in ""production"" scripts that often involve multiple types of output (slices at different locations, different types of averages, etc). An example is:. https://github.com/glwagner/EadyTurbulence/blob/master/initial_value_problem/eady_initial_value_problem.jl. I think the point is more or less that output writers are often related to one another. For example, we typically want all our output in a single directory, and on the same schedule. I also pretty much always use `force=true` (I guess the equivalent for NetCDF is ""clobber"" mode). Is there a way to reduce this boilerplate or is it a fact of Oceananigans life? Can we specify some output parameters in `Simulation` rather than in each `OutputWriter` individually? Resolving #1163 might help but I'm not sure. It does seem to make sense to coordinate the output directory through the `Simulation` rather than each output writer individually. But this also contradicts some of what was discussed on #963, such as using the keyword `filepath` rather than `prefix` and `dir`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1171
https://github.com/CliMA/Oceananigans.jl/issues/1171:621,Energy Efficiency,reduce,reduce,621,"Building up OutputWriters can be a major source of boilerplate in ""production"" scripts that often involve multiple types of output (slices at different locations, different types of averages, etc). An example is:. https://github.com/glwagner/EadyTurbulence/blob/master/initial_value_problem/eady_initial_value_problem.jl. I think the point is more or less that output writers are often related to one another. For example, we typically want all our output in a single directory, and on the same schedule. I also pretty much always use `force=true` (I guess the equivalent for NetCDF is ""clobber"" mode). Is there a way to reduce this boilerplate or is it a fact of Oceananigans life? Can we specify some output parameters in `Simulation` rather than in each `OutputWriter` individually? Resolving #1163 might help but I'm not sure. It does seem to make sense to coordinate the output directory through the `Simulation` rather than each output writer individually. But this also contradicts some of what was discussed on #963, such as using the keyword `filepath` rather than `prefix` and `dir`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1171
https://github.com/CliMA/Oceananigans.jl/issues/1175:1276,Availability,checkpoint,checkpoint,1276,"Currently, `IncompressibleModel` keeps a reference to `TimeStepper`:. https://github.com/CliMA/Oceananigans.jl/blob/03a6f855f839504d94cb8cee3c2665b17afbc6d5/src/Models/incompressible_model.jl#L33. This means that every model has one time stepper, and we use `time_step!(model, dt)` to advance a model forward. Yet this is not a necessary entanglement. A perfectly valid time-stepping loop is. ```julia; for i = 1:100; time_step!(model, forward_euler_stepper, dt); time_step!(model, rk3_stepper, dt); end; ```. (obviously we don't have a forward Euler time-stepper, which is a separate issue, but hopefully the point is made.). We can disentangle the timestepper from model by moving the timestepper reference over to `Simulation`. This would also clean up the interface since we wouldn't need to use symbols to specify the time-stepping method (#1119, this might be a hint that we're on the right track...). ```julia; model = IncompressibleModel(...); simulation = Simulation(model, RungeKutta3TimeStepper(model), kwargs...); ```. I think there's a conceptual advantage to this too. `Simulation`s manage the creation of a time-series, while a `Model` is more the idealization of a discrete physical system at a particular moment in time. To make this change, we first have to checkpoint `Simulation`s rather than `Model`s to support time-steppers that require history like AB2. I think this is something we need anyways. This is a major API change, though it could be mitigated if we put a default into the `Simulation` constructor.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1175
https://github.com/CliMA/Oceananigans.jl/issues/1175:760,Integrability,interface,interface,760,"Currently, `IncompressibleModel` keeps a reference to `TimeStepper`:. https://github.com/CliMA/Oceananigans.jl/blob/03a6f855f839504d94cb8cee3c2665b17afbc6d5/src/Models/incompressible_model.jl#L33. This means that every model has one time stepper, and we use `time_step!(model, dt)` to advance a model forward. Yet this is not a necessary entanglement. A perfectly valid time-stepping loop is. ```julia; for i = 1:100; time_step!(model, forward_euler_stepper, dt); time_step!(model, rk3_stepper, dt); end; ```. (obviously we don't have a forward Euler time-stepper, which is a separate issue, but hopefully the point is made.). We can disentangle the timestepper from model by moving the timestepper reference over to `Simulation`. This would also clean up the interface since we wouldn't need to use symbols to specify the time-stepping method (#1119, this might be a hint that we're on the right track...). ```julia; model = IncompressibleModel(...); simulation = Simulation(model, RungeKutta3TimeStepper(model), kwargs...); ```. I think there's a conceptual advantage to this too. `Simulation`s manage the creation of a time-series, while a `Model` is more the idealization of a discrete physical system at a particular moment in time. To make this change, we first have to checkpoint `Simulation`s rather than `Model`s to support time-steppers that require history like AB2. I think this is something we need anyways. This is a major API change, though it could be mitigated if we put a default into the `Simulation` constructor.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1175
https://github.com/CliMA/Oceananigans.jl/issues/1177:184,Availability,error,error,184,Easy to get burned by accidentally applying e.g. no-slip boundary conditions along a periodic dimension (mixing up `east` and `north`). Oceananigans should probably print a warning or error if you apply inconsistent boundary conditions. Definitely occurred to me multiple times (and recently encountered by @whitleyv too).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1177
https://github.com/CliMA/Oceananigans.jl/issues/1178:223,Usability,usab,usable,223,"Seems like a leftover relic from a time when we only had 1 pressure solver for `(Periodic, Periodic, Bounded)`. . Might be good to be explicit about the topology, but maybe we should wait until all 9 (or 27) topologies are usable?. Would be good to be explicit since it may be unclear whether adding walls should happen via boundary conditions or via a grid topology. cc @whitleyv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1178
https://github.com/CliMA/Oceananigans.jl/issues/1179:192,Availability,failure,failures,192,"After the big changes yesterday I decided to run the tests to make sure everything was working. Thanks again @ali-ramadhan for helping me get that started. Now I'm finding that there are some failures and somethings that are broken. See below. Is it just me or do others get this now?. ```; Test Summary: | Pass Fail Broken Total; Oceananigans | 2987 8 5 3000; Unit tests | 1511 1 1512; Model and time stepping tests (part 1) | 99 99; Model and time stepping tests (part 2) | 214 1 215; Simulation tests | 1142 2 3 1147; Simulations | 26 26; Diagnostics | 12 12; Output writers | 409 2 411; FieldSlicer | 1 1; WindowedTimeAverage | 2 2; NetCDF [GPU] | 198 198; JLD2 [GPU] | 11 11; Checkpointer [GPU] | 166 2 168; Dependency adding [GPU] | 2 2; Time averaging of output [GPU] | 29 29; Abstract operations | 695 3 698; Regression | 14 6 20; Thermal bubble [GPU] | 5 5; Rayleigh–Bénard tracer [GPU] | 5 5; Ocean large eddy simulation [GPU] | 4 6 10; Scripts | 7 7; ERROR: LoadError: Some tests did not pass: 2987 passed, 8 failed, 0 errored, 5 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; ERROR: Package Oceananigans errored during testing; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1179
https://github.com/CliMA/Oceananigans.jl/issues/1179:681,Availability,Checkpoint,Checkpointer,681,"After the big changes yesterday I decided to run the tests to make sure everything was working. Thanks again @ali-ramadhan for helping me get that started. Now I'm finding that there are some failures and somethings that are broken. See below. Is it just me or do others get this now?. ```; Test Summary: | Pass Fail Broken Total; Oceananigans | 2987 8 5 3000; Unit tests | 1511 1 1512; Model and time stepping tests (part 1) | 99 99; Model and time stepping tests (part 2) | 214 1 215; Simulation tests | 1142 2 3 1147; Simulations | 26 26; Diagnostics | 12 12; Output writers | 409 2 411; FieldSlicer | 1 1; WindowedTimeAverage | 2 2; NetCDF [GPU] | 198 198; JLD2 [GPU] | 11 11; Checkpointer [GPU] | 166 2 168; Dependency adding [GPU] | 2 2; Time averaging of output [GPU] | 29 29; Abstract operations | 695 3 698; Regression | 14 6 20; Thermal bubble [GPU] | 5 5; Rayleigh–Bénard tracer [GPU] | 5 5; Ocean large eddy simulation [GPU] | 4 6 10; Scripts | 7 7; ERROR: LoadError: Some tests did not pass: 2987 passed, 8 failed, 0 errored, 5 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; ERROR: Package Oceananigans errored during testing; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1179
https://github.com/CliMA/Oceananigans.jl/issues/1179:962,Availability,ERROR,ERROR,962,"After the big changes yesterday I decided to run the tests to make sure everything was working. Thanks again @ali-ramadhan for helping me get that started. Now I'm finding that there are some failures and somethings that are broken. See below. Is it just me or do others get this now?. ```; Test Summary: | Pass Fail Broken Total; Oceananigans | 2987 8 5 3000; Unit tests | 1511 1 1512; Model and time stepping tests (part 1) | 99 99; Model and time stepping tests (part 2) | 214 1 215; Simulation tests | 1142 2 3 1147; Simulations | 26 26; Diagnostics | 12 12; Output writers | 409 2 411; FieldSlicer | 1 1; WindowedTimeAverage | 2 2; NetCDF [GPU] | 198 198; JLD2 [GPU] | 11 11; Checkpointer [GPU] | 166 2 168; Dependency adding [GPU] | 2 2; Time averaging of output [GPU] | 29 29; Abstract operations | 695 3 698; Regression | 14 6 20; Thermal bubble [GPU] | 5 5; Rayleigh–Bénard tracer [GPU] | 5 5; Ocean large eddy simulation [GPU] | 4 6 10; Scripts | 7 7; ERROR: LoadError: Some tests did not pass: 2987 passed, 8 failed, 0 errored, 5 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; ERROR: Package Oceananigans errored during testing; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1179
https://github.com/CliMA/Oceananigans.jl/issues/1179:1030,Availability,error,errored,1030,"After the big changes yesterday I decided to run the tests to make sure everything was working. Thanks again @ali-ramadhan for helping me get that started. Now I'm finding that there are some failures and somethings that are broken. See below. Is it just me or do others get this now?. ```; Test Summary: | Pass Fail Broken Total; Oceananigans | 2987 8 5 3000; Unit tests | 1511 1 1512; Model and time stepping tests (part 1) | 99 99; Model and time stepping tests (part 2) | 214 1 215; Simulation tests | 1142 2 3 1147; Simulations | 26 26; Diagnostics | 12 12; Output writers | 409 2 411; FieldSlicer | 1 1; WindowedTimeAverage | 2 2; NetCDF [GPU] | 198 198; JLD2 [GPU] | 11 11; Checkpointer [GPU] | 166 2 168; Dependency adding [GPU] | 2 2; Time averaging of output [GPU] | 29 29; Abstract operations | 695 3 698; Regression | 14 6 20; Thermal bubble [GPU] | 5 5; Rayleigh–Bénard tracer [GPU] | 5 5; Ocean large eddy simulation [GPU] | 4 6 10; Scripts | 7 7; ERROR: LoadError: Some tests did not pass: 2987 passed, 8 failed, 0 errored, 5 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; ERROR: Package Oceananigans errored during testing; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1179
https://github.com/CliMA/Oceananigans.jl/issues/1179:1136,Availability,ERROR,ERROR,1136,"After the big changes yesterday I decided to run the tests to make sure everything was working. Thanks again @ali-ramadhan for helping me get that started. Now I'm finding that there are some failures and somethings that are broken. See below. Is it just me or do others get this now?. ```; Test Summary: | Pass Fail Broken Total; Oceananigans | 2987 8 5 3000; Unit tests | 1511 1 1512; Model and time stepping tests (part 1) | 99 99; Model and time stepping tests (part 2) | 214 1 215; Simulation tests | 1142 2 3 1147; Simulations | 26 26; Diagnostics | 12 12; Output writers | 409 2 411; FieldSlicer | 1 1; WindowedTimeAverage | 2 2; NetCDF [GPU] | 198 198; JLD2 [GPU] | 11 11; Checkpointer [GPU] | 166 2 168; Dependency adding [GPU] | 2 2; Time averaging of output [GPU] | 29 29; Abstract operations | 695 3 698; Regression | 14 6 20; Thermal bubble [GPU] | 5 5; Rayleigh–Bénard tracer [GPU] | 5 5; Ocean large eddy simulation [GPU] | 4 6 10; Scripts | 7 7; ERROR: LoadError: Some tests did not pass: 2987 passed, 8 failed, 0 errored, 5 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; ERROR: Package Oceananigans errored during testing; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1179
https://github.com/CliMA/Oceananigans.jl/issues/1179:1164,Availability,error,errored,1164,"After the big changes yesterday I decided to run the tests to make sure everything was working. Thanks again @ali-ramadhan for helping me get that started. Now I'm finding that there are some failures and somethings that are broken. See below. Is it just me or do others get this now?. ```; Test Summary: | Pass Fail Broken Total; Oceananigans | 2987 8 5 3000; Unit tests | 1511 1 1512; Model and time stepping tests (part 1) | 99 99; Model and time stepping tests (part 2) | 214 1 215; Simulation tests | 1142 2 3 1147; Simulations | 26 26; Diagnostics | 12 12; Output writers | 409 2 411; FieldSlicer | 1 1; WindowedTimeAverage | 2 2; NetCDF [GPU] | 198 198; JLD2 [GPU] | 11 11; Checkpointer [GPU] | 166 2 168; Dependency adding [GPU] | 2 2; Time averaging of output [GPU] | 29 29; Abstract operations | 695 3 698; Regression | 14 6 20; Thermal bubble [GPU] | 5 5; Rayleigh–Bénard tracer [GPU] | 5 5; Ocean large eddy simulation [GPU] | 4 6 10; Scripts | 7 7; ERROR: LoadError: Some tests did not pass: 2987 passed, 8 failed, 0 errored, 5 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; ERROR: Package Oceananigans errored during testing; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1179
https://github.com/CliMA/Oceananigans.jl/issues/1179:713,Integrability,Depend,Dependency,713,"After the big changes yesterday I decided to run the tests to make sure everything was working. Thanks again @ali-ramadhan for helping me get that started. Now I'm finding that there are some failures and somethings that are broken. See below. Is it just me or do others get this now?. ```; Test Summary: | Pass Fail Broken Total; Oceananigans | 2987 8 5 3000; Unit tests | 1511 1 1512; Model and time stepping tests (part 1) | 99 99; Model and time stepping tests (part 2) | 214 1 215; Simulation tests | 1142 2 3 1147; Simulations | 26 26; Diagnostics | 12 12; Output writers | 409 2 411; FieldSlicer | 1 1; WindowedTimeAverage | 2 2; NetCDF [GPU] | 198 198; JLD2 [GPU] | 11 11; Checkpointer [GPU] | 166 2 168; Dependency adding [GPU] | 2 2; Time averaging of output [GPU] | 29 29; Abstract operations | 695 3 698; Regression | 14 6 20; Thermal bubble [GPU] | 5 5; Rayleigh–Bénard tracer [GPU] | 5 5; Ocean large eddy simulation [GPU] | 4 6 10; Scripts | 7 7; ERROR: LoadError: Some tests did not pass: 2987 passed, 8 failed, 0 errored, 5 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; ERROR: Package Oceananigans errored during testing; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1179
https://github.com/CliMA/Oceananigans.jl/issues/1179:969,Performance,Load,LoadError,969,"After the big changes yesterday I decided to run the tests to make sure everything was working. Thanks again @ali-ramadhan for helping me get that started. Now I'm finding that there are some failures and somethings that are broken. See below. Is it just me or do others get this now?. ```; Test Summary: | Pass Fail Broken Total; Oceananigans | 2987 8 5 3000; Unit tests | 1511 1 1512; Model and time stepping tests (part 1) | 99 99; Model and time stepping tests (part 2) | 214 1 215; Simulation tests | 1142 2 3 1147; Simulations | 26 26; Diagnostics | 12 12; Output writers | 409 2 411; FieldSlicer | 1 1; WindowedTimeAverage | 2 2; NetCDF [GPU] | 198 198; JLD2 [GPU] | 11 11; Checkpointer [GPU] | 166 2 168; Dependency adding [GPU] | 2 2; Time averaging of output [GPU] | 29 29; Abstract operations | 695 3 698; Regression | 14 6 20; Thermal bubble [GPU] | 5 5; Rayleigh–Bénard tracer [GPU] | 5 5; Ocean large eddy simulation [GPU] | 4 6 10; Scripts | 7 7; ERROR: LoadError: Some tests did not pass: 2987 passed, 8 failed, 0 errored, 5 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; ERROR: Package Oceananigans errored during testing; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1179
https://github.com/CliMA/Oceananigans.jl/issues/1179:53,Testability,test,tests,53,"After the big changes yesterday I decided to run the tests to make sure everything was working. Thanks again @ali-ramadhan for helping me get that started. Now I'm finding that there are some failures and somethings that are broken. See below. Is it just me or do others get this now?. ```; Test Summary: | Pass Fail Broken Total; Oceananigans | 2987 8 5 3000; Unit tests | 1511 1 1512; Model and time stepping tests (part 1) | 99 99; Model and time stepping tests (part 2) | 214 1 215; Simulation tests | 1142 2 3 1147; Simulations | 26 26; Diagnostics | 12 12; Output writers | 409 2 411; FieldSlicer | 1 1; WindowedTimeAverage | 2 2; NetCDF [GPU] | 198 198; JLD2 [GPU] | 11 11; Checkpointer [GPU] | 166 2 168; Dependency adding [GPU] | 2 2; Time averaging of output [GPU] | 29 29; Abstract operations | 695 3 698; Regression | 14 6 20; Thermal bubble [GPU] | 5 5; Rayleigh–Bénard tracer [GPU] | 5 5; Ocean large eddy simulation [GPU] | 4 6 10; Scripts | 7 7; ERROR: LoadError: Some tests did not pass: 2987 passed, 8 failed, 0 errored, 5 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; ERROR: Package Oceananigans errored during testing; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1179
https://github.com/CliMA/Oceananigans.jl/issues/1179:291,Testability,Test,Test,291,"After the big changes yesterday I decided to run the tests to make sure everything was working. Thanks again @ali-ramadhan for helping me get that started. Now I'm finding that there are some failures and somethings that are broken. See below. Is it just me or do others get this now?. ```; Test Summary: | Pass Fail Broken Total; Oceananigans | 2987 8 5 3000; Unit tests | 1511 1 1512; Model and time stepping tests (part 1) | 99 99; Model and time stepping tests (part 2) | 214 1 215; Simulation tests | 1142 2 3 1147; Simulations | 26 26; Diagnostics | 12 12; Output writers | 409 2 411; FieldSlicer | 1 1; WindowedTimeAverage | 2 2; NetCDF [GPU] | 198 198; JLD2 [GPU] | 11 11; Checkpointer [GPU] | 166 2 168; Dependency adding [GPU] | 2 2; Time averaging of output [GPU] | 29 29; Abstract operations | 695 3 698; Regression | 14 6 20; Thermal bubble [GPU] | 5 5; Rayleigh–Bénard tracer [GPU] | 5 5; Ocean large eddy simulation [GPU] | 4 6 10; Scripts | 7 7; ERROR: LoadError: Some tests did not pass: 2987 passed, 8 failed, 0 errored, 5 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; ERROR: Package Oceananigans errored during testing; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1179
https://github.com/CliMA/Oceananigans.jl/issues/1179:366,Testability,test,tests,366,"After the big changes yesterday I decided to run the tests to make sure everything was working. Thanks again @ali-ramadhan for helping me get that started. Now I'm finding that there are some failures and somethings that are broken. See below. Is it just me or do others get this now?. ```; Test Summary: | Pass Fail Broken Total; Oceananigans | 2987 8 5 3000; Unit tests | 1511 1 1512; Model and time stepping tests (part 1) | 99 99; Model and time stepping tests (part 2) | 214 1 215; Simulation tests | 1142 2 3 1147; Simulations | 26 26; Diagnostics | 12 12; Output writers | 409 2 411; FieldSlicer | 1 1; WindowedTimeAverage | 2 2; NetCDF [GPU] | 198 198; JLD2 [GPU] | 11 11; Checkpointer [GPU] | 166 2 168; Dependency adding [GPU] | 2 2; Time averaging of output [GPU] | 29 29; Abstract operations | 695 3 698; Regression | 14 6 20; Thermal bubble [GPU] | 5 5; Rayleigh–Bénard tracer [GPU] | 5 5; Ocean large eddy simulation [GPU] | 4 6 10; Scripts | 7 7; ERROR: LoadError: Some tests did not pass: 2987 passed, 8 failed, 0 errored, 5 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; ERROR: Package Oceananigans errored during testing; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1179
https://github.com/CliMA/Oceananigans.jl/issues/1179:411,Testability,test,tests,411,"After the big changes yesterday I decided to run the tests to make sure everything was working. Thanks again @ali-ramadhan for helping me get that started. Now I'm finding that there are some failures and somethings that are broken. See below. Is it just me or do others get this now?. ```; Test Summary: | Pass Fail Broken Total; Oceananigans | 2987 8 5 3000; Unit tests | 1511 1 1512; Model and time stepping tests (part 1) | 99 99; Model and time stepping tests (part 2) | 214 1 215; Simulation tests | 1142 2 3 1147; Simulations | 26 26; Diagnostics | 12 12; Output writers | 409 2 411; FieldSlicer | 1 1; WindowedTimeAverage | 2 2; NetCDF [GPU] | 198 198; JLD2 [GPU] | 11 11; Checkpointer [GPU] | 166 2 168; Dependency adding [GPU] | 2 2; Time averaging of output [GPU] | 29 29; Abstract operations | 695 3 698; Regression | 14 6 20; Thermal bubble [GPU] | 5 5; Rayleigh–Bénard tracer [GPU] | 5 5; Ocean large eddy simulation [GPU] | 4 6 10; Scripts | 7 7; ERROR: LoadError: Some tests did not pass: 2987 passed, 8 failed, 0 errored, 5 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; ERROR: Package Oceananigans errored during testing; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1179
https://github.com/CliMA/Oceananigans.jl/issues/1179:459,Testability,test,tests,459,"After the big changes yesterday I decided to run the tests to make sure everything was working. Thanks again @ali-ramadhan for helping me get that started. Now I'm finding that there are some failures and somethings that are broken. See below. Is it just me or do others get this now?. ```; Test Summary: | Pass Fail Broken Total; Oceananigans | 2987 8 5 3000; Unit tests | 1511 1 1512; Model and time stepping tests (part 1) | 99 99; Model and time stepping tests (part 2) | 214 1 215; Simulation tests | 1142 2 3 1147; Simulations | 26 26; Diagnostics | 12 12; Output writers | 409 2 411; FieldSlicer | 1 1; WindowedTimeAverage | 2 2; NetCDF [GPU] | 198 198; JLD2 [GPU] | 11 11; Checkpointer [GPU] | 166 2 168; Dependency adding [GPU] | 2 2; Time averaging of output [GPU] | 29 29; Abstract operations | 695 3 698; Regression | 14 6 20; Thermal bubble [GPU] | 5 5; Rayleigh–Bénard tracer [GPU] | 5 5; Ocean large eddy simulation [GPU] | 4 6 10; Scripts | 7 7; ERROR: LoadError: Some tests did not pass: 2987 passed, 8 failed, 0 errored, 5 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; ERROR: Package Oceananigans errored during testing; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1179
https://github.com/CliMA/Oceananigans.jl/issues/1179:498,Testability,test,tests,498,"After the big changes yesterday I decided to run the tests to make sure everything was working. Thanks again @ali-ramadhan for helping me get that started. Now I'm finding that there are some failures and somethings that are broken. See below. Is it just me or do others get this now?. ```; Test Summary: | Pass Fail Broken Total; Oceananigans | 2987 8 5 3000; Unit tests | 1511 1 1512; Model and time stepping tests (part 1) | 99 99; Model and time stepping tests (part 2) | 214 1 215; Simulation tests | 1142 2 3 1147; Simulations | 26 26; Diagnostics | 12 12; Output writers | 409 2 411; FieldSlicer | 1 1; WindowedTimeAverage | 2 2; NetCDF [GPU] | 198 198; JLD2 [GPU] | 11 11; Checkpointer [GPU] | 166 2 168; Dependency adding [GPU] | 2 2; Time averaging of output [GPU] | 29 29; Abstract operations | 695 3 698; Regression | 14 6 20; Thermal bubble [GPU] | 5 5; Rayleigh–Bénard tracer [GPU] | 5 5; Ocean large eddy simulation [GPU] | 4 6 10; Scripts | 7 7; ERROR: LoadError: Some tests did not pass: 2987 passed, 8 failed, 0 errored, 5 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; ERROR: Package Oceananigans errored during testing; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1179
https://github.com/CliMA/Oceananigans.jl/issues/1179:985,Testability,test,tests,985,"After the big changes yesterday I decided to run the tests to make sure everything was working. Thanks again @ali-ramadhan for helping me get that started. Now I'm finding that there are some failures and somethings that are broken. See below. Is it just me or do others get this now?. ```; Test Summary: | Pass Fail Broken Total; Oceananigans | 2987 8 5 3000; Unit tests | 1511 1 1512; Model and time stepping tests (part 1) | 99 99; Model and time stepping tests (part 2) | 214 1 215; Simulation tests | 1142 2 3 1147; Simulations | 26 26; Diagnostics | 12 12; Output writers | 409 2 411; FieldSlicer | 1 1; WindowedTimeAverage | 2 2; NetCDF [GPU] | 198 198; JLD2 [GPU] | 11 11; Checkpointer [GPU] | 166 2 168; Dependency adding [GPU] | 2 2; Time averaging of output [GPU] | 29 29; Abstract operations | 695 3 698; Regression | 14 6 20; Thermal bubble [GPU] | 5 5; Rayleigh–Bénard tracer [GPU] | 5 5; Ocean large eddy simulation [GPU] | 4 6 10; Scripts | 7 7; ERROR: LoadError: Some tests did not pass: 2987 passed, 8 failed, 0 errored, 5 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; ERROR: Package Oceananigans errored during testing; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1179
https://github.com/CliMA/Oceananigans.jl/issues/1179:1115,Testability,test,test,1115,"After the big changes yesterday I decided to run the tests to make sure everything was working. Thanks again @ali-ramadhan for helping me get that started. Now I'm finding that there are some failures and somethings that are broken. See below. Is it just me or do others get this now?. ```; Test Summary: | Pass Fail Broken Total; Oceananigans | 2987 8 5 3000; Unit tests | 1511 1 1512; Model and time stepping tests (part 1) | 99 99; Model and time stepping tests (part 2) | 214 1 215; Simulation tests | 1142 2 3 1147; Simulations | 26 26; Diagnostics | 12 12; Output writers | 409 2 411; FieldSlicer | 1 1; WindowedTimeAverage | 2 2; NetCDF [GPU] | 198 198; JLD2 [GPU] | 11 11; Checkpointer [GPU] | 166 2 168; Dependency adding [GPU] | 2 2; Time averaging of output [GPU] | 29 29; Abstract operations | 695 3 698; Regression | 14 6 20; Thermal bubble [GPU] | 5 5; Rayleigh–Bénard tracer [GPU] | 5 5; Ocean large eddy simulation [GPU] | 4 6 10; Scripts | 7 7; ERROR: LoadError: Some tests did not pass: 2987 passed, 8 failed, 0 errored, 5 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; ERROR: Package Oceananigans errored during testing; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1179
https://github.com/CliMA/Oceananigans.jl/issues/1179:1179,Testability,test,testing,1179,"After the big changes yesterday I decided to run the tests to make sure everything was working. Thanks again @ali-ramadhan for helping me get that started. Now I'm finding that there are some failures and somethings that are broken. See below. Is it just me or do others get this now?. ```; Test Summary: | Pass Fail Broken Total; Oceananigans | 2987 8 5 3000; Unit tests | 1511 1 1512; Model and time stepping tests (part 1) | 99 99; Model and time stepping tests (part 2) | 214 1 215; Simulation tests | 1142 2 3 1147; Simulations | 26 26; Diagnostics | 12 12; Output writers | 409 2 411; FieldSlicer | 1 1; WindowedTimeAverage | 2 2; NetCDF [GPU] | 198 198; JLD2 [GPU] | 11 11; Checkpointer [GPU] | 166 2 168; Dependency adding [GPU] | 2 2; Time averaging of output [GPU] | 29 29; Abstract operations | 695 3 698; Regression | 14 6 20; Thermal bubble [GPU] | 5 5; Rayleigh–Bénard tracer [GPU] | 5 5; Ocean large eddy simulation [GPU] | 4 6 10; Scripts | 7 7; ERROR: LoadError: Some tests did not pass: 2987 passed, 8 failed, 0 errored, 5 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; ERROR: Package Oceananigans errored during testing; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1179
https://github.com/CliMA/Oceananigans.jl/issues/1180:53,Testability,test,tests,53,Would be helpful information to have especially when tests fail. We should also print `CUDA.versioninfo()` if running GPU tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1180
https://github.com/CliMA/Oceananigans.jl/issues/1180:122,Testability,test,tests,122,Would be helpful information to have especially when tests fail. We should also print `CUDA.versioninfo()` if running GPU tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1180
https://github.com/CliMA/Oceananigans.jl/pull/1181:184,Usability,clear,clearly,184,"This PR adds a new minimal example that simulates and plots a rising buoyant bubble:. ```julia; # # Hello, ocean!; #; # > How inappropriate to call this planet Earth, when it is quite clearly _Ocean_.; #; # --Arthur C. Clark. using Oceananigans, Oceananigans.Grids, Plots. grid = RegularCartesianGrid(size = (1, 64, 64),; x = (0, 1), y = (-4, 4), z = (-4, 4),; topology = (Periodic, Bounded, Bounded)). model = IncompressibleModel(grid = grid,; architecture = CPU(),; advection = Oceananigans.Advection.WENO5(),; tracers = :b,; buoyancy = BuoyancyTracer(),; closure = IsotropicDiffusivity(ν=1e-3, κ=1e-3)). @info ""Simulating a rising buoyant bubble with"" model. set!(model, b = (x, y, z) -> exp(-y^2 - z^2)). run!(Simulation(model, Δt=0.01, stop_iteration=800)). # Analyze the data. b = model.tracers.b. plt = contourf(ynodes(b), znodes(b), interior(b)[1, :, :]',; xlabel = ""y"", ylabel = ""z"", title = ""Buoyancy"",; xlim = (grid.yF[1], grid.yF[end]), ylim = (grid.zF[1], grid.zF[end]),; aspectratio = :equal, linewidth = 0). display(plt) # hide; ```. If we do think an example like this would be nice to have, it might make sense to replace the README example with this one (and perhaps otherwise improve the README). I didn't add it to the list of examples in the docs, but it is set up (in it's minimal way) for Literate-ing. Or we can un-literate it. Suggest away and I shall commit!. The script produces. ![image](https://user-images.githubusercontent.com/15271942/99148581-9859d880-2656-11eb-989a-a137635e11df.png). Could also add a `pkg""add Oceananigans, Plots""` at the top per the discussion on #1149, but it might better to unify all the examples at once in a dedicated PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1181
https://github.com/CliMA/Oceananigans.jl/issues/1182:816,Energy Efficiency,allocate,allocate,816,"Currently, we use the constructor `output_writer.array_type` to convert array data prior to outputting:. https://github.com/CliMA/Oceananigans.jl/blob/03a6f855f839504d94cb8cee3c2665b17afbc6d5/src/OutputWriters/fetch_output.jl#L17. But we should use `convert` instead, because this avoids allocating memory when no type conversion is needed:. ```julia; julia> a = rand(1, 1, 1); 1×1×1 Array{Float64,3}:; [:, :, 1] =; 0.7727202498256802. julia> b = convert(Array{Float64}, a); 1×1×1 Array{Float64,3}:; [:, :, 1] =; 0.7727202498256802. julia> b === a; true; ```. so `b` is just a reference to `a`, but. ```julia; julia> c = Array{Float64}(a); 1×1×1 Array{Float64,3}:; [:, :, 1] =; 0.7727202498256802. julia> c === a; false; ```. `c` is not a reference to `a`. This matters very little since we basically always need to allocate memory to convert from Float64 to Float32. A related minor optimization would be to avoid converting views to the same type as the parent array, since we could just output those directly. I think we have to use dispatch on one of the type parameters of `SubArray` for that. But maybe simpler code is worth not implementing a minor optimization for an edge case.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1182
https://github.com/CliMA/Oceananigans.jl/issues/1182:884,Performance,optimiz,optimization,884,"Currently, we use the constructor `output_writer.array_type` to convert array data prior to outputting:. https://github.com/CliMA/Oceananigans.jl/blob/03a6f855f839504d94cb8cee3c2665b17afbc6d5/src/OutputWriters/fetch_output.jl#L17. But we should use `convert` instead, because this avoids allocating memory when no type conversion is needed:. ```julia; julia> a = rand(1, 1, 1); 1×1×1 Array{Float64,3}:; [:, :, 1] =; 0.7727202498256802. julia> b = convert(Array{Float64}, a); 1×1×1 Array{Float64,3}:; [:, :, 1] =; 0.7727202498256802. julia> b === a; true; ```. so `b` is just a reference to `a`, but. ```julia; julia> c = Array{Float64}(a); 1×1×1 Array{Float64,3}:; [:, :, 1] =; 0.7727202498256802. julia> c === a; false; ```. `c` is not a reference to `a`. This matters very little since we basically always need to allocate memory to convert from Float64 to Float32. A related minor optimization would be to avoid converting views to the same type as the parent array, since we could just output those directly. I think we have to use dispatch on one of the type parameters of `SubArray` for that. But maybe simpler code is worth not implementing a minor optimization for an edge case.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1182
https://github.com/CliMA/Oceananigans.jl/issues/1182:1156,Performance,optimiz,optimization,1156,"Currently, we use the constructor `output_writer.array_type` to convert array data prior to outputting:. https://github.com/CliMA/Oceananigans.jl/blob/03a6f855f839504d94cb8cee3c2665b17afbc6d5/src/OutputWriters/fetch_output.jl#L17. But we should use `convert` instead, because this avoids allocating memory when no type conversion is needed:. ```julia; julia> a = rand(1, 1, 1); 1×1×1 Array{Float64,3}:; [:, :, 1] =; 0.7727202498256802. julia> b = convert(Array{Float64}, a); 1×1×1 Array{Float64,3}:; [:, :, 1] =; 0.7727202498256802. julia> b === a; true; ```. so `b` is just a reference to `a`, but. ```julia; julia> c = Array{Float64}(a); 1×1×1 Array{Float64,3}:; [:, :, 1] =; 0.7727202498256802. julia> c === a; false; ```. `c` is not a reference to `a`. This matters very little since we basically always need to allocate memory to convert from Float64 to Float32. A related minor optimization would be to avoid converting views to the same type as the parent array, since we could just output those directly. I think we have to use dispatch on one of the type parameters of `SubArray` for that. But maybe simpler code is worth not implementing a minor optimization for an edge case.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1182
https://github.com/CliMA/Oceananigans.jl/issues/1182:281,Safety,avoid,avoids,281,"Currently, we use the constructor `output_writer.array_type` to convert array data prior to outputting:. https://github.com/CliMA/Oceananigans.jl/blob/03a6f855f839504d94cb8cee3c2665b17afbc6d5/src/OutputWriters/fetch_output.jl#L17. But we should use `convert` instead, because this avoids allocating memory when no type conversion is needed:. ```julia; julia> a = rand(1, 1, 1); 1×1×1 Array{Float64,3}:; [:, :, 1] =; 0.7727202498256802. julia> b = convert(Array{Float64}, a); 1×1×1 Array{Float64,3}:; [:, :, 1] =; 0.7727202498256802. julia> b === a; true; ```. so `b` is just a reference to `a`, but. ```julia; julia> c = Array{Float64}(a); 1×1×1 Array{Float64,3}:; [:, :, 1] =; 0.7727202498256802. julia> c === a; false; ```. `c` is not a reference to `a`. This matters very little since we basically always need to allocate memory to convert from Float64 to Float32. A related minor optimization would be to avoid converting views to the same type as the parent array, since we could just output those directly. I think we have to use dispatch on one of the type parameters of `SubArray` for that. But maybe simpler code is worth not implementing a minor optimization for an edge case.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1182
https://github.com/CliMA/Oceananigans.jl/issues/1182:909,Safety,avoid,avoid,909,"Currently, we use the constructor `output_writer.array_type` to convert array data prior to outputting:. https://github.com/CliMA/Oceananigans.jl/blob/03a6f855f839504d94cb8cee3c2665b17afbc6d5/src/OutputWriters/fetch_output.jl#L17. But we should use `convert` instead, because this avoids allocating memory when no type conversion is needed:. ```julia; julia> a = rand(1, 1, 1); 1×1×1 Array{Float64,3}:; [:, :, 1] =; 0.7727202498256802. julia> b = convert(Array{Float64}, a); 1×1×1 Array{Float64,3}:; [:, :, 1] =; 0.7727202498256802. julia> b === a; true; ```. so `b` is just a reference to `a`, but. ```julia; julia> c = Array{Float64}(a); 1×1×1 Array{Float64,3}:; [:, :, 1] =; 0.7727202498256802. julia> c === a; false; ```. `c` is not a reference to `a`. This matters very little since we basically always need to allocate memory to convert from Float64 to Float32. A related minor optimization would be to avoid converting views to the same type as the parent array, since we could just output those directly. I think we have to use dispatch on one of the type parameters of `SubArray` for that. But maybe simpler code is worth not implementing a minor optimization for an edge case.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1182
https://github.com/CliMA/Oceananigans.jl/issues/1182:1109,Usability,simpl,simpler,1109,"Currently, we use the constructor `output_writer.array_type` to convert array data prior to outputting:. https://github.com/CliMA/Oceananigans.jl/blob/03a6f855f839504d94cb8cee3c2665b17afbc6d5/src/OutputWriters/fetch_output.jl#L17. But we should use `convert` instead, because this avoids allocating memory when no type conversion is needed:. ```julia; julia> a = rand(1, 1, 1); 1×1×1 Array{Float64,3}:; [:, :, 1] =; 0.7727202498256802. julia> b = convert(Array{Float64}, a); 1×1×1 Array{Float64,3}:; [:, :, 1] =; 0.7727202498256802. julia> b === a; true; ```. so `b` is just a reference to `a`, but. ```julia; julia> c = Array{Float64}(a); 1×1×1 Array{Float64,3}:; [:, :, 1] =; 0.7727202498256802. julia> c === a; false; ```. `c` is not a reference to `a`. This matters very little since we basically always need to allocate memory to convert from Float64 to Float32. A related minor optimization would be to avoid converting views to the same type as the parent array, since we could just output those directly. I think we have to use dispatch on one of the type parameters of `SubArray` for that. But maybe simpler code is worth not implementing a minor optimization for an edge case.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1182
https://github.com/CliMA/Oceananigans.jl/issues/1183:242,Availability,down,down,242,"While we have a few examples / tutorials that demonstrate how Oceananigans can be used to model the ocean surface boundary layer, we have nothing comparable for a ocean bottom boundary layer / atmospheric boundary layer where the action goes down at rough / no-slip boundary. It might be nice to provide a bottom boundary layer example with a wall model appropriate for LES. There's a number of people interested in using Oceananigans to model the bottom boundary layer (cc @tomchor, @raphaelouillon). It'd be nice to think of some way to make it fun and interesting. A few ideas are:. * Implement a wall model appropriate for rough boundaries, and atmospheric / bottom boundary layer LES; * Model sediment-turbulence interaction, perhaps with an effect on buoyancy?; * Use the TEOS10 equation of state (not used in any examples); * Use a gravitational acceleration that's not aligned with z, once #1151 is resolved; * Drive turbulence with tides (eg perhaps reproduce @bekaiser's work in an LES setting). Could do all at once... Others might have better or more reasonable ideas.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1183
https://github.com/CliMA/Oceananigans.jl/pull/1184:22,Deployability,install,install,22,This PR adds explicit install of required packages for each example. This is related to the discussion in #1149.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1184
https://github.com/CliMA/Oceananigans.jl/pull/1185:163,Testability,test,tested,163,"This pull request changes the compat entry for the `JLD2` package from `^0.2` to `^0.2, 0.3`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1185
https://github.com/CliMA/Oceananigans.jl/pull/1185:268,Testability,test,tests,268,"This pull request changes the compat entry for the `JLD2` package from `^0.2` to `^0.2, 0.3`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1185
https://github.com/CliMA/Oceananigans.jl/pull/1187:0,Modifiability,Enhance,Enhancement,0,Enhancement in the Eady turbulence example.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1187
https://github.com/CliMA/Oceananigans.jl/pull/1188:1217,Availability,error,error,1217,"I have created a new branch called ""ShallowWaterS1waveeqn"". S1 is for step 1. It doesn't do much right now but I'm trying to set up the skeleton so that we can actually do something intereting, like evolve the equation. At the moment I have the following:. 1. Created a ShallowWaterModels folder. 2. Created a ShallowWaterModels.jl module. It doesn't do much except include shallowwater_model.jl. 3. shallowwater_model.jl defines a mutable struct and a function. I couldn't get a lot of things to work but it does regularlize the boundary condtions, set up the velocities and a new variable called layer_depth. The name is not great and can go with depth or height, as people prefer. It will be in in the governing equations. 4. Created an example, in the same folder, called onedim_shallowwater.jl. Currently, this includes the module mentioned above, defines a grid (yes, a single point!), defines the initial conditions and sets the velocity. Questions:. 1. This is pretty bare bones so far but does this follow the philosophy of Oceananigans?. 2. I have tried to inititalze the layer_depth by adding an argument into the set! command but it failed. Below is the command that I thought would work and below is the error because layer_depth is not model.velocities or model.tracers. Can someone help me to see what silliness I am doing?. ```; set!(model, u = u, v = v, layer_deth = layer_depth); fails with ""ERROR: LoadError: ArgumentError: name layer_depth not found in model.velocities or model.tracers."". After I get the initial conditions defined I then need to specify the fluxes for the PDE. That should not be difficult but one issue is the nomenclature. The vector we have now is velocities, but we actually want, velocity transport. I should use and define hu and hv instead of u and v. That should be easy enough, I think.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1188
https://github.com/CliMA/Oceananigans.jl/pull/1188:1410,Availability,ERROR,ERROR,1410,"I have created a new branch called ""ShallowWaterS1waveeqn"". S1 is for step 1. It doesn't do much right now but I'm trying to set up the skeleton so that we can actually do something intereting, like evolve the equation. At the moment I have the following:. 1. Created a ShallowWaterModels folder. 2. Created a ShallowWaterModels.jl module. It doesn't do much except include shallowwater_model.jl. 3. shallowwater_model.jl defines a mutable struct and a function. I couldn't get a lot of things to work but it does regularlize the boundary condtions, set up the velocities and a new variable called layer_depth. The name is not great and can go with depth or height, as people prefer. It will be in in the governing equations. 4. Created an example, in the same folder, called onedim_shallowwater.jl. Currently, this includes the module mentioned above, defines a grid (yes, a single point!), defines the initial conditions and sets the velocity. Questions:. 1. This is pretty bare bones so far but does this follow the philosophy of Oceananigans?. 2. I have tried to inititalze the layer_depth by adding an argument into the set! command but it failed. Below is the command that I thought would work and below is the error because layer_depth is not model.velocities or model.tracers. Can someone help me to see what silliness I am doing?. ```; set!(model, u = u, v = v, layer_deth = layer_depth); fails with ""ERROR: LoadError: ArgumentError: name layer_depth not found in model.velocities or model.tracers."". After I get the initial conditions defined I then need to specify the fluxes for the PDE. That should not be difficult but one issue is the nomenclature. The vector we have now is velocities, but we actually want, velocity transport. I should use and define hu and hv instead of u and v. That should be easy enough, I think.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1188
https://github.com/CliMA/Oceananigans.jl/pull/1188:199,Modifiability,evolve,evolve,199,"I have created a new branch called ""ShallowWaterS1waveeqn"". S1 is for step 1. It doesn't do much right now but I'm trying to set up the skeleton so that we can actually do something intereting, like evolve the equation. At the moment I have the following:. 1. Created a ShallowWaterModels folder. 2. Created a ShallowWaterModels.jl module. It doesn't do much except include shallowwater_model.jl. 3. shallowwater_model.jl defines a mutable struct and a function. I couldn't get a lot of things to work but it does regularlize the boundary condtions, set up the velocities and a new variable called layer_depth. The name is not great and can go with depth or height, as people prefer. It will be in in the governing equations. 4. Created an example, in the same folder, called onedim_shallowwater.jl. Currently, this includes the module mentioned above, defines a grid (yes, a single point!), defines the initial conditions and sets the velocity. Questions:. 1. This is pretty bare bones so far but does this follow the philosophy of Oceananigans?. 2. I have tried to inititalze the layer_depth by adding an argument into the set! command but it failed. Below is the command that I thought would work and below is the error because layer_depth is not model.velocities or model.tracers. Can someone help me to see what silliness I am doing?. ```; set!(model, u = u, v = v, layer_deth = layer_depth); fails with ""ERROR: LoadError: ArgumentError: name layer_depth not found in model.velocities or model.tracers."". After I get the initial conditions defined I then need to specify the fluxes for the PDE. That should not be difficult but one issue is the nomenclature. The vector we have now is velocities, but we actually want, velocity transport. I should use and define hu and hv instead of u and v. That should be easy enough, I think.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1188
https://github.com/CliMA/Oceananigans.jl/pull/1188:582,Modifiability,variab,variable,582,"I have created a new branch called ""ShallowWaterS1waveeqn"". S1 is for step 1. It doesn't do much right now but I'm trying to set up the skeleton so that we can actually do something intereting, like evolve the equation. At the moment I have the following:. 1. Created a ShallowWaterModels folder. 2. Created a ShallowWaterModels.jl module. It doesn't do much except include shallowwater_model.jl. 3. shallowwater_model.jl defines a mutable struct and a function. I couldn't get a lot of things to work but it does regularlize the boundary condtions, set up the velocities and a new variable called layer_depth. The name is not great and can go with depth or height, as people prefer. It will be in in the governing equations. 4. Created an example, in the same folder, called onedim_shallowwater.jl. Currently, this includes the module mentioned above, defines a grid (yes, a single point!), defines the initial conditions and sets the velocity. Questions:. 1. This is pretty bare bones so far but does this follow the philosophy of Oceananigans?. 2. I have tried to inititalze the layer_depth by adding an argument into the set! command but it failed. Below is the command that I thought would work and below is the error because layer_depth is not model.velocities or model.tracers. Can someone help me to see what silliness I am doing?. ```; set!(model, u = u, v = v, layer_deth = layer_depth); fails with ""ERROR: LoadError: ArgumentError: name layer_depth not found in model.velocities or model.tracers."". After I get the initial conditions defined I then need to specify the fluxes for the PDE. That should not be difficult but one issue is the nomenclature. The vector we have now is velocities, but we actually want, velocity transport. I should use and define hu and hv instead of u and v. That should be easy enough, I think.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1188
https://github.com/CliMA/Oceananigans.jl/pull/1188:1417,Performance,Load,LoadError,1417,"I have created a new branch called ""ShallowWaterS1waveeqn"". S1 is for step 1. It doesn't do much right now but I'm trying to set up the skeleton so that we can actually do something intereting, like evolve the equation. At the moment I have the following:. 1. Created a ShallowWaterModels folder. 2. Created a ShallowWaterModels.jl module. It doesn't do much except include shallowwater_model.jl. 3. shallowwater_model.jl defines a mutable struct and a function. I couldn't get a lot of things to work but it does regularlize the boundary condtions, set up the velocities and a new variable called layer_depth. The name is not great and can go with depth or height, as people prefer. It will be in in the governing equations. 4. Created an example, in the same folder, called onedim_shallowwater.jl. Currently, this includes the module mentioned above, defines a grid (yes, a single point!), defines the initial conditions and sets the velocity. Questions:. 1. This is pretty bare bones so far but does this follow the philosophy of Oceananigans?. 2. I have tried to inititalze the layer_depth by adding an argument into the set! command but it failed. Below is the command that I thought would work and below is the error because layer_depth is not model.velocities or model.tracers. Can someone help me to see what silliness I am doing?. ```; set!(model, u = u, v = v, layer_deth = layer_depth); fails with ""ERROR: LoadError: ArgumentError: name layer_depth not found in model.velocities or model.tracers."". After I get the initial conditions defined I then need to specify the fluxes for the PDE. That should not be difficult but one issue is the nomenclature. The vector we have now is velocities, but we actually want, velocity transport. I should use and define hu and hv instead of u and v. That should be easy enough, I think.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1188
https://github.com/CliMA/Oceananigans.jl/issues/1189:198,Availability,ERROR,ERROR,198,"I don't know what happened but yesterday I could type ""using Oceananigans"" after starting julia --project and it worked fine. This morning, after a software update on ubuntu, now I'm getting a CUDA ERROR. See below. Any ideas what I can do to try and fix this?. ```; julia> using Oceananigans; ┌ Warning: Recursion during initialization of CUDA.jl; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:41; ┌ Error: Could not initialize CUDA; │ exception =; │ CUDA error (code 803, CUDA_ERROR_SYSTEM_DRIVER_MISMATCH); │ Stacktrace:; │ [1] throw_api_error(::CUDA.cudaError_enum) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:97; │ [2] __configure__(::Bool) at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:98; │ [3] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:29 [inlined]; │ [4] macro expansion at ./lock.jl:183 [inlined]; │ [5] _functional(::Bool) at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:26; │ [6] functional(::Bool) at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:19; │ [7] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:50; │ [8] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; │ [9] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; │ [10] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; │ [11] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; │ [12] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; │ [13] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; │ [14] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); │ [15] iterate at ./iterators.jl:139 [inlined]; │ [16] iterate at ./iterators.jl:13",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189
https://github.com/CliMA/Oceananigans.jl/issues/1189:415,Availability,Error,Error,415,"I don't know what happened but yesterday I could type ""using Oceananigans"" after starting julia --project and it worked fine. This morning, after a software update on ubuntu, now I'm getting a CUDA ERROR. See below. Any ideas what I can do to try and fix this?. ```; julia> using Oceananigans; ┌ Warning: Recursion during initialization of CUDA.jl; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:41; ┌ Error: Could not initialize CUDA; │ exception =; │ CUDA error (code 803, CUDA_ERROR_SYSTEM_DRIVER_MISMATCH); │ Stacktrace:; │ [1] throw_api_error(::CUDA.cudaError_enum) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:97; │ [2] __configure__(::Bool) at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:98; │ [3] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:29 [inlined]; │ [4] macro expansion at ./lock.jl:183 [inlined]; │ [5] _functional(::Bool) at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:26; │ [6] functional(::Bool) at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:19; │ [7] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:50; │ [8] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; │ [9] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; │ [10] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; │ [11] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; │ [12] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; │ [13] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; │ [14] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); │ [15] iterate at ./iterators.jl:139 [inlined]; │ [16] iterate at ./iterators.jl:13",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189
https://github.com/CliMA/Oceananigans.jl/issues/1189:471,Availability,error,error,471,"I don't know what happened but yesterday I could type ""using Oceananigans"" after starting julia --project and it worked fine. This morning, after a software update on ubuntu, now I'm getting a CUDA ERROR. See below. Any ideas what I can do to try and fix this?. ```; julia> using Oceananigans; ┌ Warning: Recursion during initialization of CUDA.jl; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:41; ┌ Error: Could not initialize CUDA; │ exception =; │ CUDA error (code 803, CUDA_ERROR_SYSTEM_DRIVER_MISMATCH); │ Stacktrace:; │ [1] throw_api_error(::CUDA.cudaError_enum) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:97; │ [2] __configure__(::Bool) at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:98; │ [3] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:29 [inlined]; │ [4] macro expansion at ./lock.jl:183 [inlined]; │ [5] _functional(::Bool) at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:26; │ [6] functional(::Bool) at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:19; │ [7] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:50; │ [8] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; │ [9] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; │ [10] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; │ [11] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; │ [12] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; │ [13] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; │ [14] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); │ [15] iterate at ./iterators.jl:139 [inlined]; │ [16] iterate at ./iterators.jl:13",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189
https://github.com/CliMA/Oceananigans.jl/issues/1189:640,Availability,error,error,640,"I don't know what happened but yesterday I could type ""using Oceananigans"" after starting julia --project and it worked fine. This morning, after a software update on ubuntu, now I'm getting a CUDA ERROR. See below. Any ideas what I can do to try and fix this?. ```; julia> using Oceananigans; ┌ Warning: Recursion during initialization of CUDA.jl; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:41; ┌ Error: Could not initialize CUDA; │ exception =; │ CUDA error (code 803, CUDA_ERROR_SYSTEM_DRIVER_MISMATCH); │ Stacktrace:; │ [1] throw_api_error(::CUDA.cudaError_enum) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:97; │ [2] __configure__(::Bool) at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:98; │ [3] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:29 [inlined]; │ [4] macro expansion at ./lock.jl:183 [inlined]; │ [5] _functional(::Bool) at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:26; │ [6] functional(::Bool) at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:19; │ [7] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:50; │ [8] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; │ [9] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; │ [10] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; │ [11] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; │ [12] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; │ [13] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; │ [14] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); │ [15] iterate at ./iterators.jl:139 [inlined]; │ [16] iterate at ./iterators.jl:13",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189
https://github.com/CliMA/Oceananigans.jl/issues/1189:1569,Availability,error,error,1569,"i_error(::CUDA.cudaError_enum) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:97; │ [2] __configure__(::Bool) at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:98; │ [3] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:29 [inlined]; │ [4] macro expansion at ./lock.jl:183 [inlined]; │ [5] _functional(::Bool) at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:26; │ [6] functional(::Bool) at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:19; │ [7] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:50; │ [8] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; │ [9] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; │ [10] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; │ [11] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; │ [12] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; │ [13] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; │ [14] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); │ [15] iterate at ./iterators.jl:139 [inlined]; │ [16] iterate at ./iterators.jl:138 [inlined]; │ [17] __init__() at /home/fpoulin/software/Oceananigans.jl/src/Oceananigans.jl:178; │ [18] _include_from_serialized(::String, ::Array{Any,1}) at ./loading.jl:697; │ [19] _require_search_from_serialized(::Base.PkgId, ::String) at ./loading.jl:782; │ [20] _require(::Base.PkgId) at ./loading.jl:1007; │ [21] require(::Base.PkgId) at ./loading.jl:928; │ [22] require(::Module, ::Symbol) at ./loading.jl:923; │ [23] eval(::Module, ::Any) at ./boot.jl:331; │ [24] eval_user_input(::Any, ::REPL.REPLBackend) at /buildworker/worker/package_linux",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189
https://github.com/CliMA/Oceananigans.jl/issues/1189:3641,Availability,ERROR,ERROR,3641,"Backend) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:195; │ [26] start_repl_backend(::REPL.REPLBackend, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:180; │ [27] run_repl(::REPL.AbstractREPL, ::Any; backend_on_current_task::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:292; │ [28] run_repl(::REPL.AbstractREPL, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:288; │ [29] (::Base.var""#807#809""{Bool,Bool,Bool,Bool})(::Module) at ./client.jl:399; │ [30] #invokelatest#1 at ./essentials.jl:710 [inlined]; │ [31] invokelatest at ./essentials.jl:709 [inlined]; │ [32] run_main_repl(::Bool, ::Bool, ::Bool, ::Bool, ::Bool) at ./client.jl:383; │ [33] exec_options(::Base.JLOptions) at ./client.jl:313; │ [34] _start() at ./client.jl:506; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:101; ERROR: InitError: CUDA.jl did not successfully initialize, and is not usable.; If you did not see any other error message, try again in a new session; with the JULIA_DEBUG environment variable set to 'CUDA'.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:51; [3] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; [6] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; [7] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; [8] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; [9] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/l",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189
https://github.com/CliMA/Oceananigans.jl/issues/1189:3749,Availability,error,error,3749,"L.REPLBackend, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:180; │ [27] run_repl(::REPL.AbstractREPL, ::Any; backend_on_current_task::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:292; │ [28] run_repl(::REPL.AbstractREPL, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:288; │ [29] (::Base.var""#807#809""{Bool,Bool,Bool,Bool})(::Module) at ./client.jl:399; │ [30] #invokelatest#1 at ./essentials.jl:710 [inlined]; │ [31] invokelatest at ./essentials.jl:709 [inlined]; │ [32] run_main_repl(::Bool, ::Bool, ::Bool, ::Bool, ::Bool) at ./client.jl:383; │ [33] exec_options(::Base.JLOptions) at ./client.jl:313; │ [34] _start() at ./client.jl:506; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:101; ERROR: InitError: CUDA.jl did not successfully initialize, and is not usable.; If you did not see any other error message, try again in a new session; with the JULIA_DEBUG environment variable set to 'CUDA'.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:51; [3] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; [6] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; [7] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; [8] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; [9] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); [10] iterate at ./iterators.jl:139 [inlined]; [11] iterate at ./iterators.jl:13",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189
https://github.com/CliMA/Oceananigans.jl/issues/1189:3867,Availability,error,error,3867,"tdlib/v1.5/REPL/src/REPL.jl:180; │ [27] run_repl(::REPL.AbstractREPL, ::Any; backend_on_current_task::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:292; │ [28] run_repl(::REPL.AbstractREPL, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:288; │ [29] (::Base.var""#807#809""{Bool,Bool,Bool,Bool})(::Module) at ./client.jl:399; │ [30] #invokelatest#1 at ./essentials.jl:710 [inlined]; │ [31] invokelatest at ./essentials.jl:709 [inlined]; │ [32] run_main_repl(::Bool, ::Bool, ::Bool, ::Bool, ::Bool) at ./client.jl:383; │ [33] exec_options(::Base.JLOptions) at ./client.jl:313; │ [34] _start() at ./client.jl:506; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:101; ERROR: InitError: CUDA.jl did not successfully initialize, and is not usable.; If you did not see any other error message, try again in a new session; with the JULIA_DEBUG environment variable set to 'CUDA'.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:51; [3] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; [6] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; [7] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; [8] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; [9] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); [10] iterate at ./iterators.jl:139 [inlined]; [11] iterate at ./iterators.jl:138 [inlined]; [12] __init__() at /home/fpoulin/software/Oceananigans.jl/src/Oceananiga",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189
https://github.com/CliMA/Oceananigans.jl/issues/1189:3888,Availability,error,error,3888,"L.jl:180; │ [27] run_repl(::REPL.AbstractREPL, ::Any; backend_on_current_task::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:292; │ [28] run_repl(::REPL.AbstractREPL, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:288; │ [29] (::Base.var""#807#809""{Bool,Bool,Bool,Bool})(::Module) at ./client.jl:399; │ [30] #invokelatest#1 at ./essentials.jl:710 [inlined]; │ [31] invokelatest at ./essentials.jl:709 [inlined]; │ [32] run_main_repl(::Bool, ::Bool, ::Bool, ::Bool, ::Bool) at ./client.jl:383; │ [33] exec_options(::Base.JLOptions) at ./client.jl:313; │ [34] _start() at ./client.jl:506; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:101; ERROR: InitError: CUDA.jl did not successfully initialize, and is not usable.; If you did not see any other error message, try again in a new session; with the JULIA_DEBUG environment variable set to 'CUDA'.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:51; [3] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; [6] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; [7] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; [8] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; [9] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); [10] iterate at ./iterators.jl:139 [inlined]; [11] iterate at ./iterators.jl:138 [inlined]; [12] __init__() at /home/fpoulin/software/Oceananigans.jl/src/Oceananigans.jl:178; [13] _includ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189
https://github.com/CliMA/Oceananigans.jl/issues/1189:4364,Availability,error,error,4364,"09""{Bool,Bool,Bool,Bool})(::Module) at ./client.jl:399; │ [30] #invokelatest#1 at ./essentials.jl:710 [inlined]; │ [31] invokelatest at ./essentials.jl:709 [inlined]; │ [32] run_main_repl(::Bool, ::Bool, ::Bool, ::Bool, ::Bool) at ./client.jl:383; │ [33] exec_options(::Base.JLOptions) at ./client.jl:313; │ [34] _start() at ./client.jl:506; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:101; ERROR: InitError: CUDA.jl did not successfully initialize, and is not usable.; If you did not see any other error message, try again in a new session; with the JULIA_DEBUG environment variable set to 'CUDA'.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:51; [3] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; [6] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; [7] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; [8] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; [9] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); [10] iterate at ./iterators.jl:139 [inlined]; [11] iterate at ./iterators.jl:138 [inlined]; [12] __init__() at /home/fpoulin/software/Oceananigans.jl/src/Oceananigans.jl:178; [13] _include_from_serialized(::String, ::Array{Any,1}) at ./loading.jl:697; [14] _require_search_from_serialized(::Base.PkgId, ::String) at ./loading.jl:782; [15] _require(::Base.PkgId) at ./loading.jl:1007; [16] require(::Base.PkgId) at ./loading.jl:928; [17] require(::Module, ::Symbol) at ./loading.jl:923; during initialization of module Oceananigans",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189
https://github.com/CliMA/Oceananigans.jl/issues/1189:157,Deployability,update,update,157,"I don't know what happened but yesterday I could type ""using Oceananigans"" after starting julia --project and it worked fine. This morning, after a software update on ubuntu, now I'm getting a CUDA ERROR. See below. Any ideas what I can do to try and fix this?. ```; julia> using Oceananigans; ┌ Warning: Recursion during initialization of CUDA.jl; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:41; ┌ Error: Could not initialize CUDA; │ exception =; │ CUDA error (code 803, CUDA_ERROR_SYSTEM_DRIVER_MISMATCH); │ Stacktrace:; │ [1] throw_api_error(::CUDA.cudaError_enum) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:97; │ [2] __configure__(::Bool) at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:98; │ [3] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:29 [inlined]; │ [4] macro expansion at ./lock.jl:183 [inlined]; │ [5] _functional(::Bool) at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:26; │ [6] functional(::Bool) at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:19; │ [7] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:50; │ [8] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; │ [9] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; │ [10] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; │ [11] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; │ [12] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; │ [13] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; │ [14] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); │ [15] iterate at ./iterators.jl:139 [inlined]; │ [16] iterate at ./iterators.jl:13",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189
https://github.com/CliMA/Oceananigans.jl/issues/1189:3755,Integrability,message,message,3755,"L.REPLBackend, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:180; │ [27] run_repl(::REPL.AbstractREPL, ::Any; backend_on_current_task::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:292; │ [28] run_repl(::REPL.AbstractREPL, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:288; │ [29] (::Base.var""#807#809""{Bool,Bool,Bool,Bool})(::Module) at ./client.jl:399; │ [30] #invokelatest#1 at ./essentials.jl:710 [inlined]; │ [31] invokelatest at ./essentials.jl:709 [inlined]; │ [32] run_main_repl(::Bool, ::Bool, ::Bool, ::Bool, ::Bool) at ./client.jl:383; │ [33] exec_options(::Base.JLOptions) at ./client.jl:313; │ [34] _start() at ./client.jl:506; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:101; ERROR: InitError: CUDA.jl did not successfully initialize, and is not usable.; If you did not see any other error message, try again in a new session; with the JULIA_DEBUG environment variable set to 'CUDA'.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:51; [3] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; [6] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; [7] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; [8] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; [9] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); [10] iterate at ./iterators.jl:139 [inlined]; [11] iterate at ./iterators.jl:13",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189
https://github.com/CliMA/Oceananigans.jl/issues/1189:3825,Modifiability,variab,variable,3825,"L.REPLBackend, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:180; │ [27] run_repl(::REPL.AbstractREPL, ::Any; backend_on_current_task::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:292; │ [28] run_repl(::REPL.AbstractREPL, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:288; │ [29] (::Base.var""#807#809""{Bool,Bool,Bool,Bool})(::Module) at ./client.jl:399; │ [30] #invokelatest#1 at ./essentials.jl:710 [inlined]; │ [31] invokelatest at ./essentials.jl:709 [inlined]; │ [32] run_main_repl(::Bool, ::Bool, ::Bool, ::Bool, ::Bool) at ./client.jl:383; │ [33] exec_options(::Base.JLOptions) at ./client.jl:313; │ [34] _start() at ./client.jl:506; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:101; ERROR: InitError: CUDA.jl did not successfully initialize, and is not usable.; If you did not see any other error message, try again in a new session; with the JULIA_DEBUG environment variable set to 'CUDA'.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:51; [3] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; [6] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; [7] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; [8] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; [9] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); [10] iterate at ./iterators.jl:139 [inlined]; [11] iterate at ./iterators.jl:13",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189
https://github.com/CliMA/Oceananigans.jl/issues/1189:2162,Performance,load,loading,2162,"ization.jl:50; │ [8] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; │ [9] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; │ [10] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; │ [11] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; │ [12] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; │ [13] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; │ [14] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); │ [15] iterate at ./iterators.jl:139 [inlined]; │ [16] iterate at ./iterators.jl:138 [inlined]; │ [17] __init__() at /home/fpoulin/software/Oceananigans.jl/src/Oceananigans.jl:178; │ [18] _include_from_serialized(::String, ::Array{Any,1}) at ./loading.jl:697; │ [19] _require_search_from_serialized(::Base.PkgId, ::String) at ./loading.jl:782; │ [20] _require(::Base.PkgId) at ./loading.jl:1007; │ [21] require(::Base.PkgId) at ./loading.jl:928; │ [22] require(::Module, ::Symbol) at ./loading.jl:923; │ [23] eval(::Module, ::Any) at ./boot.jl:331; │ [24] eval_user_input(::Any, ::REPL.REPLBackend) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:134; │ [25] repl_backend_loop(::REPL.REPLBackend) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:195; │ [26] start_repl_backend(::REPL.REPLBackend, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:180; │ [27] run_repl(::REPL.AbstractREPL, ::Any; backend_on_current_task::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:292; │ [28] run_repl(::REPL.AbstractREPL, ::Any) at /buildworker/worker/package_linux64/build/usr/sha",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189
https://github.com/CliMA/Oceananigans.jl/issues/1189:2246,Performance,load,loading,2246,"kages/CUDA/0p5fn/lib/utils/call.jl:31; │ [9] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; │ [10] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; │ [11] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; │ [12] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; │ [13] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; │ [14] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); │ [15] iterate at ./iterators.jl:139 [inlined]; │ [16] iterate at ./iterators.jl:138 [inlined]; │ [17] __init__() at /home/fpoulin/software/Oceananigans.jl/src/Oceananigans.jl:178; │ [18] _include_from_serialized(::String, ::Array{Any,1}) at ./loading.jl:697; │ [19] _require_search_from_serialized(::Base.PkgId, ::String) at ./loading.jl:782; │ [20] _require(::Base.PkgId) at ./loading.jl:1007; │ [21] require(::Base.PkgId) at ./loading.jl:928; │ [22] require(::Module, ::Symbol) at ./loading.jl:923; │ [23] eval(::Module, ::Any) at ./boot.jl:331; │ [24] eval_user_input(::Any, ::REPL.REPLBackend) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:134; │ [25] repl_backend_loop(::REPL.REPLBackend) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:195; │ [26] start_repl_backend(::REPL.REPLBackend, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:180; │ [27] run_repl(::REPL.AbstractREPL, ::Any; backend_on_current_task::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:292; │ [28] run_repl(::REPL.AbstractREPL, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:288; │ [29] (::Base.var""#807#809""{Bool,Bool,Bo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189
https://github.com/CliMA/Oceananigans.jl/issues/1189:2297,Performance,load,loading,2297,"expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; │ [10] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; │ [11] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; │ [12] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; │ [13] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; │ [14] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); │ [15] iterate at ./iterators.jl:139 [inlined]; │ [16] iterate at ./iterators.jl:138 [inlined]; │ [17] __init__() at /home/fpoulin/software/Oceananigans.jl/src/Oceananigans.jl:178; │ [18] _include_from_serialized(::String, ::Array{Any,1}) at ./loading.jl:697; │ [19] _require_search_from_serialized(::Base.PkgId, ::String) at ./loading.jl:782; │ [20] _require(::Base.PkgId) at ./loading.jl:1007; │ [21] require(::Base.PkgId) at ./loading.jl:928; │ [22] require(::Module, ::Symbol) at ./loading.jl:923; │ [23] eval(::Module, ::Any) at ./boot.jl:331; │ [24] eval_user_input(::Any, ::REPL.REPLBackend) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:134; │ [25] repl_backend_loop(::REPL.REPLBackend) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:195; │ [26] start_repl_backend(::REPL.REPLBackend, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:180; │ [27] run_repl(::REPL.AbstractREPL, ::Any; backend_on_current_task::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:292; │ [28] run_repl(::REPL.AbstractREPL, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:288; │ [29] (::Base.var""#807#809""{Bool,Bool,Bool,Bool})(::Module) at ./client.jl:399; │ [30] #inv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189
https://github.com/CliMA/Oceananigans.jl/issues/1189:2348,Performance,load,loading,2348,"fn/lib/utils/call.jl:39 [inlined]; │ [10] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; │ [11] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; │ [12] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; │ [13] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; │ [14] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); │ [15] iterate at ./iterators.jl:139 [inlined]; │ [16] iterate at ./iterators.jl:138 [inlined]; │ [17] __init__() at /home/fpoulin/software/Oceananigans.jl/src/Oceananigans.jl:178; │ [18] _include_from_serialized(::String, ::Array{Any,1}) at ./loading.jl:697; │ [19] _require_search_from_serialized(::Base.PkgId, ::String) at ./loading.jl:782; │ [20] _require(::Base.PkgId) at ./loading.jl:1007; │ [21] require(::Base.PkgId) at ./loading.jl:928; │ [22] require(::Module, ::Symbol) at ./loading.jl:923; │ [23] eval(::Module, ::Any) at ./boot.jl:331; │ [24] eval_user_input(::Any, ::REPL.REPLBackend) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:134; │ [25] repl_backend_loop(::REPL.REPLBackend) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:195; │ [26] start_repl_backend(::REPL.REPLBackend, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:180; │ [27] run_repl(::REPL.AbstractREPL, ::Any; backend_on_current_task::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:292; │ [28] run_repl(::REPL.AbstractREPL, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:288; │ [29] (::Base.var""#807#809""{Bool,Bool,Bool,Bool})(::Module) at ./client.jl:399; │ [30] #invokelatest#1 at ./essentials.jl:710 [inlined]; │ [31",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189
https://github.com/CliMA/Oceananigans.jl/issues/1189:2404,Performance,load,loading,2404,"n at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; │ [11] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; │ [12] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; │ [13] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; │ [14] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); │ [15] iterate at ./iterators.jl:139 [inlined]; │ [16] iterate at ./iterators.jl:138 [inlined]; │ [17] __init__() at /home/fpoulin/software/Oceananigans.jl/src/Oceananigans.jl:178; │ [18] _include_from_serialized(::String, ::Array{Any,1}) at ./loading.jl:697; │ [19] _require_search_from_serialized(::Base.PkgId, ::String) at ./loading.jl:782; │ [20] _require(::Base.PkgId) at ./loading.jl:1007; │ [21] require(::Base.PkgId) at ./loading.jl:928; │ [22] require(::Module, ::Symbol) at ./loading.jl:923; │ [23] eval(::Module, ::Any) at ./boot.jl:331; │ [24] eval_user_input(::Any, ::REPL.REPLBackend) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:134; │ [25] repl_backend_loop(::REPL.REPLBackend) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:195; │ [26] start_repl_backend(::REPL.REPLBackend, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:180; │ [27] run_repl(::REPL.AbstractREPL, ::Any; backend_on_current_task::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:292; │ [28] run_repl(::REPL.AbstractREPL, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:288; │ [29] (::Base.var""#807#809""{Bool,Bool,Bool,Bool})(::Module) at ./client.jl:399; │ [30] #invokelatest#1 at ./essentials.jl:710 [inlined]; │ [31] invokelatest at ./essentials.jl:709 [inlined]; │ [32] ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189
https://github.com/CliMA/Oceananigans.jl/issues/1189:4940,Performance,load,loading,4940,"09""{Bool,Bool,Bool,Bool})(::Module) at ./client.jl:399; │ [30] #invokelatest#1 at ./essentials.jl:710 [inlined]; │ [31] invokelatest at ./essentials.jl:709 [inlined]; │ [32] run_main_repl(::Bool, ::Bool, ::Bool, ::Bool, ::Bool) at ./client.jl:383; │ [33] exec_options(::Base.JLOptions) at ./client.jl:313; │ [34] _start() at ./client.jl:506; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:101; ERROR: InitError: CUDA.jl did not successfully initialize, and is not usable.; If you did not see any other error message, try again in a new session; with the JULIA_DEBUG environment variable set to 'CUDA'.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:51; [3] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; [6] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; [7] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; [8] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; [9] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); [10] iterate at ./iterators.jl:139 [inlined]; [11] iterate at ./iterators.jl:138 [inlined]; [12] __init__() at /home/fpoulin/software/Oceananigans.jl/src/Oceananigans.jl:178; [13] _include_from_serialized(::String, ::Array{Any,1}) at ./loading.jl:697; [14] _require_search_from_serialized(::Base.PkgId, ::String) at ./loading.jl:782; [15] _require(::Base.PkgId) at ./loading.jl:1007; [16] require(::Base.PkgId) at ./loading.jl:928; [17] require(::Module, ::Symbol) at ./loading.jl:923; during initialization of module Oceananigans",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189
https://github.com/CliMA/Oceananigans.jl/issues/1189:5022,Performance,load,loading,5022,"09""{Bool,Bool,Bool,Bool})(::Module) at ./client.jl:399; │ [30] #invokelatest#1 at ./essentials.jl:710 [inlined]; │ [31] invokelatest at ./essentials.jl:709 [inlined]; │ [32] run_main_repl(::Bool, ::Bool, ::Bool, ::Bool, ::Bool) at ./client.jl:383; │ [33] exec_options(::Base.JLOptions) at ./client.jl:313; │ [34] _start() at ./client.jl:506; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:101; ERROR: InitError: CUDA.jl did not successfully initialize, and is not usable.; If you did not see any other error message, try again in a new session; with the JULIA_DEBUG environment variable set to 'CUDA'.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:51; [3] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; [6] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; [7] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; [8] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; [9] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); [10] iterate at ./iterators.jl:139 [inlined]; [11] iterate at ./iterators.jl:138 [inlined]; [12] __init__() at /home/fpoulin/software/Oceananigans.jl/src/Oceananigans.jl:178; [13] _include_from_serialized(::String, ::Array{Any,1}) at ./loading.jl:697; [14] _require_search_from_serialized(::Base.PkgId, ::String) at ./loading.jl:782; [15] _require(::Base.PkgId) at ./loading.jl:1007; [16] require(::Base.PkgId) at ./loading.jl:928; [17] require(::Module, ::Symbol) at ./loading.jl:923; during initialization of module Oceananigans",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189
https://github.com/CliMA/Oceananigans.jl/issues/1189:5071,Performance,load,loading,5071,"09""{Bool,Bool,Bool,Bool})(::Module) at ./client.jl:399; │ [30] #invokelatest#1 at ./essentials.jl:710 [inlined]; │ [31] invokelatest at ./essentials.jl:709 [inlined]; │ [32] run_main_repl(::Bool, ::Bool, ::Bool, ::Bool, ::Bool) at ./client.jl:383; │ [33] exec_options(::Base.JLOptions) at ./client.jl:313; │ [34] _start() at ./client.jl:506; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:101; ERROR: InitError: CUDA.jl did not successfully initialize, and is not usable.; If you did not see any other error message, try again in a new session; with the JULIA_DEBUG environment variable set to 'CUDA'.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:51; [3] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; [6] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; [7] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; [8] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; [9] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); [10] iterate at ./iterators.jl:139 [inlined]; [11] iterate at ./iterators.jl:138 [inlined]; [12] __init__() at /home/fpoulin/software/Oceananigans.jl/src/Oceananigans.jl:178; [13] _include_from_serialized(::String, ::Array{Any,1}) at ./loading.jl:697; [14] _require_search_from_serialized(::Base.PkgId, ::String) at ./loading.jl:782; [15] _require(::Base.PkgId) at ./loading.jl:1007; [16] require(::Base.PkgId) at ./loading.jl:928; [17] require(::Module, ::Symbol) at ./loading.jl:923; during initialization of module Oceananigans",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189
https://github.com/CliMA/Oceananigans.jl/issues/1189:5120,Performance,load,loading,5120,"09""{Bool,Bool,Bool,Bool})(::Module) at ./client.jl:399; │ [30] #invokelatest#1 at ./essentials.jl:710 [inlined]; │ [31] invokelatest at ./essentials.jl:709 [inlined]; │ [32] run_main_repl(::Bool, ::Bool, ::Bool, ::Bool, ::Bool) at ./client.jl:383; │ [33] exec_options(::Base.JLOptions) at ./client.jl:313; │ [34] _start() at ./client.jl:506; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:101; ERROR: InitError: CUDA.jl did not successfully initialize, and is not usable.; If you did not see any other error message, try again in a new session; with the JULIA_DEBUG environment variable set to 'CUDA'.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:51; [3] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; [6] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; [7] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; [8] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; [9] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); [10] iterate at ./iterators.jl:139 [inlined]; [11] iterate at ./iterators.jl:138 [inlined]; [12] __init__() at /home/fpoulin/software/Oceananigans.jl/src/Oceananigans.jl:178; [13] _include_from_serialized(::String, ::Array{Any,1}) at ./loading.jl:697; [14] _require_search_from_serialized(::Base.PkgId, ::String) at ./loading.jl:782; [15] _require(::Base.PkgId) at ./loading.jl:1007; [16] require(::Base.PkgId) at ./loading.jl:928; [17] require(::Module, ::Symbol) at ./loading.jl:923; during initialization of module Oceananigans",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189
https://github.com/CliMA/Oceananigans.jl/issues/1189:5174,Performance,load,loading,5174,"09""{Bool,Bool,Bool,Bool})(::Module) at ./client.jl:399; │ [30] #invokelatest#1 at ./essentials.jl:710 [inlined]; │ [31] invokelatest at ./essentials.jl:709 [inlined]; │ [32] run_main_repl(::Bool, ::Bool, ::Bool, ::Bool, ::Bool) at ./client.jl:383; │ [33] exec_options(::Base.JLOptions) at ./client.jl:313; │ [34] _start() at ./client.jl:506; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:101; ERROR: InitError: CUDA.jl did not successfully initialize, and is not usable.; If you did not see any other error message, try again in a new session; with the JULIA_DEBUG environment variable set to 'CUDA'.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:51; [3] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; [6] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; [7] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; [8] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; [9] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); [10] iterate at ./iterators.jl:139 [inlined]; [11] iterate at ./iterators.jl:138 [inlined]; [12] __init__() at /home/fpoulin/software/Oceananigans.jl/src/Oceananigans.jl:178; [13] _include_from_serialized(::String, ::Array{Any,1}) at ./loading.jl:697; [14] _require_search_from_serialized(::Base.PkgId, ::String) at ./loading.jl:782; [15] _require(::Base.PkgId) at ./loading.jl:1007; [16] require(::Base.PkgId) at ./loading.jl:928; [17] require(::Module, ::Symbol) at ./loading.jl:923; during initialization of module Oceananigans",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189
https://github.com/CliMA/Oceananigans.jl/issues/1189:3711,Usability,usab,usable,3711,"ux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:195; │ [26] start_repl_backend(::REPL.REPLBackend, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:180; │ [27] run_repl(::REPL.AbstractREPL, ::Any; backend_on_current_task::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:292; │ [28] run_repl(::REPL.AbstractREPL, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:288; │ [29] (::Base.var""#807#809""{Bool,Bool,Bool,Bool})(::Module) at ./client.jl:399; │ [30] #invokelatest#1 at ./essentials.jl:710 [inlined]; │ [31] invokelatest at ./essentials.jl:709 [inlined]; │ [32] run_main_repl(::Bool, ::Bool, ::Bool, ::Bool, ::Bool) at ./client.jl:383; │ [33] exec_options(::Base.JLOptions) at ./client.jl:313; │ [34] _start() at ./client.jl:506; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:101; ERROR: InitError: CUDA.jl did not successfully initialize, and is not usable.; If you did not see any other error message, try again in a new session; with the JULIA_DEBUG environment variable set to 'CUDA'.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:51; [3] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; [6] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; [7] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; [8] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; [9] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repea",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189
https://github.com/CliMA/Oceananigans.jl/issues/1190:582,Availability,down,down,582,"Hello! I am new to Julia, Oceananigans, and computational fluid dynamics, so please forgive me if I missed something obvious or made a trivial mistake. As a first exercise with Oceananigans I am trying to simulate some high salinity, low temperature water above low salinity, high temperature water (with a bit of random noise), with a small initial westward velocity component and a 10 second time step. The documentation was quite helpful (thanks for that), and the simulation works as expected until about t=50s, when small water parcels at the density interface heat up or cool down to unnatural levels (see attached gifs at bottom), and occasionally the entire temperature matrix fills with NaN's. I've tried removing all my boundary conditions to see if they were the problem, but the issue persisted. For reference, I am using Julia v1.5 with Oceananigans 0.44.1, with this platform:; OS: macOS (x86_64-apple-darwin18.7.0); CPU: Intel(R) Core(TM) i5-6360U CPU @ 2.00GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-9.0.1 (ORCJIT, skylake). And here is a minimal example, along with code to gif-ify the output. Lowering the timestep down to 1 second from the current 10 seconds also does not fix anything. Also using a time step wizard with initial del_t at 1 second and cfl=0.3 still generates unrealistic temperatures; however, it then seems to freeze before converting entirely to NaN's and would not progress given an extra (real-life) hour to run compared to the fixed timestep. ```; using Oceananigans; using Oceananigans.OutputWriters, Oceananigans.Fields; using Oceananigans.Utils:day, hour, minute, second. grid1 = RegularCartesianGrid(size=(250, 250, 250), y=(-500,500), x=(-500,500), z=(-500,0),topology = (Periodic, Periodic, Bounded)). model1=IncompressibleModel(grid=grid1,architecture = CPU(),float_type=Float64,clock = Clock(time=0.0),coriolis = BetaPlane(rotation_rate=7.292115e-5, latitude=0, radius=6371e3),; tracers=(:T, :S),buoyancy=SeawaterBuoyancy(),closure=Anisotropi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1190
https://github.com/CliMA/Oceananigans.jl/issues/1190:1143,Availability,down,down,1143,"cise with Oceananigans I am trying to simulate some high salinity, low temperature water above low salinity, high temperature water (with a bit of random noise), with a small initial westward velocity component and a 10 second time step. The documentation was quite helpful (thanks for that), and the simulation works as expected until about t=50s, when small water parcels at the density interface heat up or cool down to unnatural levels (see attached gifs at bottom), and occasionally the entire temperature matrix fills with NaN's. I've tried removing all my boundary conditions to see if they were the problem, but the issue persisted. For reference, I am using Julia v1.5 with Oceananigans 0.44.1, with this platform:; OS: macOS (x86_64-apple-darwin18.7.0); CPU: Intel(R) Core(TM) i5-6360U CPU @ 2.00GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-9.0.1 (ORCJIT, skylake). And here is a minimal example, along with code to gif-ify the output. Lowering the timestep down to 1 second from the current 10 seconds also does not fix anything. Also using a time step wizard with initial del_t at 1 second and cfl=0.3 still generates unrealistic temperatures; however, it then seems to freeze before converting entirely to NaN's and would not progress given an extra (real-life) hour to run compared to the fixed timestep. ```; using Oceananigans; using Oceananigans.OutputWriters, Oceananigans.Fields; using Oceananigans.Utils:day, hour, minute, second. grid1 = RegularCartesianGrid(size=(250, 250, 250), y=(-500,500), x=(-500,500), z=(-500,0),topology = (Periodic, Periodic, Bounded)). model1=IncompressibleModel(grid=grid1,architecture = CPU(),float_type=Float64,clock = Clock(time=0.0),coriolis = BetaPlane(rotation_rate=7.292115e-5, latitude=0, radius=6371e3),; tracers=(:T, :S),buoyancy=SeawaterBuoyancy(),closure=AnisotropicDiffusivity(νh=1e-3, νz=5e-2, κh=2e-3, κz=1e-1)). @inline thermoc(x, y, z) = 16-12*tanh((z+250)/10)+rand(Float64); @inline sal(x, y, z) = 16+12*tanh((z+250)/10)+rand(",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1190
https://github.com/CliMA/Oceananigans.jl/issues/1190:2502,Energy Efficiency,schedul,schedule,2502,"sing Oceananigans.OutputWriters, Oceananigans.Fields; using Oceananigans.Utils:day, hour, minute, second. grid1 = RegularCartesianGrid(size=(250, 250, 250), y=(-500,500), x=(-500,500), z=(-500,0),topology = (Periodic, Periodic, Bounded)). model1=IncompressibleModel(grid=grid1,architecture = CPU(),float_type=Float64,clock = Clock(time=0.0),coriolis = BetaPlane(rotation_rate=7.292115e-5, latitude=0, radius=6371e3),; tracers=(:T, :S),buoyancy=SeawaterBuoyancy(),closure=AnisotropicDiffusivity(νh=1e-3, νz=5e-2, κh=2e-3, κz=1e-1)). @inline thermoc(x, y, z) = 16-12*tanh((z+250)/10)+rand(Float64); @inline sal(x, y, z) = 16+12*tanh((z+250)/10)+rand(Float64); set!(model1, u=-0.05, v=0,T=thermoc,S=sal). simulation = Simulation(model1, Δt=10., stop_time=80second, iteration_interval=4). function init_save_some_metadata!(file, model); file[""author""] = ""oofs""; return nothing; end. simulation.output_writers[:tracers] = JLD2OutputWriter(model1, model1.tracers,; prefix = ""Temp Data"",; schedule = TimeInterval(10second),; init = init_save_some_metadata!). run!(simulation). using Plots, JLD2, Printf, Oceananigans.Grids; x, y, z = nodes(model1.tracers.T). file = jldopen(simulation.output_writers[:tracers].filepath); iterations = parse.(Int, keys(file[""timeseries/t""])); anim = @animate for (i, iter) in enumerate(iterations). @info ""Drawing frame $i from iteration $iter..."". Temp = transpose(file[""timeseries/T/$iter""][125,:,:]); timeofthing=file[""timeseries/t/$iter""]; ; display(Temp). contourf(y, z, Temp, title = ""Temperature Profile at x=14000, t=$timeofthing"",levels = 0:1:30,linewidth=0,xlabel = ""y"",ylabel = ""z"",); end; gif(anim, ""10s Timestep INFINITE TEMPERATURE REPRODUCER.gif"", fps = 1); ```. And here are some gifs showcasing the issue from the code above with slight modifications. I also forgot to change the name of my plots; they are centered in the x-direction, but are not at x=14000m. Sorry about that.; 1 second timestep; ![1 second timestep INFINITE TEMPERATURE REPRODUCER](https:",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1190
https://github.com/CliMA/Oceananigans.jl/issues/1190:556,Integrability,interface,interface,556,"Hello! I am new to Julia, Oceananigans, and computational fluid dynamics, so please forgive me if I missed something obvious or made a trivial mistake. As a first exercise with Oceananigans I am trying to simulate some high salinity, low temperature water above low salinity, high temperature water (with a bit of random noise), with a small initial westward velocity component and a 10 second time step. The documentation was quite helpful (thanks for that), and the simulation works as expected until about t=50s, when small water parcels at the density interface heat up or cool down to unnatural levels (see attached gifs at bottom), and occasionally the entire temperature matrix fills with NaN's. I've tried removing all my boundary conditions to see if they were the problem, but the issue persisted. For reference, I am using Julia v1.5 with Oceananigans 0.44.1, with this platform:; OS: macOS (x86_64-apple-darwin18.7.0); CPU: Intel(R) Core(TM) i5-6360U CPU @ 2.00GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-9.0.1 (ORCJIT, skylake). And here is a minimal example, along with code to gif-ify the output. Lowering the timestep down to 1 second from the current 10 seconds also does not fix anything. Also using a time step wizard with initial del_t at 1 second and cfl=0.3 still generates unrealistic temperatures; however, it then seems to freeze before converting entirely to NaN's and would not progress given an extra (real-life) hour to run compared to the fixed timestep. ```; using Oceananigans; using Oceananigans.OutputWriters, Oceananigans.Fields; using Oceananigans.Utils:day, hour, minute, second. grid1 = RegularCartesianGrid(size=(250, 250, 250), y=(-500,500), x=(-500,500), z=(-500,0),topology = (Periodic, Periodic, Bounded)). model1=IncompressibleModel(grid=grid1,architecture = CPU(),float_type=Float64,clock = Clock(time=0.0),coriolis = BetaPlane(rotation_rate=7.292115e-5, latitude=0, radius=6371e3),; tracers=(:T, :S),buoyancy=SeawaterBuoyancy(),closure=Anisotropi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1190
https://github.com/CliMA/Oceananigans.jl/issues/1192:220,Availability,avail,available,220,"> Not sure if I should open another issue for this, but I was trying to set-up a 2D topology like `(Bounded, Flat, Bounded)` but couldn't. Apparently, however, `(Flat, Bounded, Bounded)` works.; > ; > Is there a list of available topologies to choose from? The `topology` page on the docs leads me to believe that they're all implemented but (unless I'm missing something) they're not. Is that list somewhere in the docs? I couldn't find it.; > ; > Cheers!; > ; > _Originally posted by @tomchor in https://github.com/CliMA/Oceananigans.jl/issues/1178#issuecomment-732235261_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1192
https://github.com/CliMA/Oceananigans.jl/pull/1193:16,Availability,avail,available,16,Added a list of available topologies,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1193
https://github.com/CliMA/Oceananigans.jl/issues/1194:823,Energy Efficiency,schedul,schedule,823,"Right now JLD2 files always include the full grid (with halos) in `file[""grid""]` which can make it hard to make plots of the data, especially if it was sliced (requiring users to know how to cut out the halos). Not sure if this is a bug as `file[""grid""]` might be referring to the grid the simulation was run on in which case it makes sense to include all the coordinates including halos, but this might still surprise users wishing to make plots. Thanks to @vchuravy for helping uncover this issue!. ```julia; using Oceananigans, Oceananigans.OutputWriters, JLD2; grid = RegularCartesianGrid(size=(8, 8, 8), extent=(1, 2, 3)); model = IncompressibleModel(grid=grid); simulation = Simulation(model, Δt=1, stop_iteration=1); simulation.output_writers[:test] = JLD2OutputWriter(model, merge(model.velocities, model.tracers), schedule=IterationInterval(1), prefix=""test"", field_slicer=FieldSlicer(k=grid.Nz, with_halos=false)); run!(simulation); f = jldopen(""test.jld2""); ```. so. ```julia; julia> size(f[""timeseries/u/1""]); (8, 8, 1); ```. but. ```julia; julia> f[""grid/zC""]; 10-element Array{Float64,1}:; -3.1875; -2.8125; -2.4375; -2.0625; -1.6875; -1.3125; -0.9375; -0.5625; -0.1875; 0.1875; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1194
https://github.com/CliMA/Oceananigans.jl/issues/1194:751,Testability,test,test,751,"Right now JLD2 files always include the full grid (with halos) in `file[""grid""]` which can make it hard to make plots of the data, especially if it was sliced (requiring users to know how to cut out the halos). Not sure if this is a bug as `file[""grid""]` might be referring to the grid the simulation was run on in which case it makes sense to include all the coordinates including halos, but this might still surprise users wishing to make plots. Thanks to @vchuravy for helping uncover this issue!. ```julia; using Oceananigans, Oceananigans.OutputWriters, JLD2; grid = RegularCartesianGrid(size=(8, 8, 8), extent=(1, 2, 3)); model = IncompressibleModel(grid=grid); simulation = Simulation(model, Δt=1, stop_iteration=1); simulation.output_writers[:test] = JLD2OutputWriter(model, merge(model.velocities, model.tracers), schedule=IterationInterval(1), prefix=""test"", field_slicer=FieldSlicer(k=grid.Nz, with_halos=false)); run!(simulation); f = jldopen(""test.jld2""); ```. so. ```julia; julia> size(f[""timeseries/u/1""]); (8, 8, 1); ```. but. ```julia; julia> f[""grid/zC""]; 10-element Array{Float64,1}:; -3.1875; -2.8125; -2.4375; -2.0625; -1.6875; -1.3125; -0.9375; -0.5625; -0.1875; 0.1875; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1194
https://github.com/CliMA/Oceananigans.jl/issues/1194:862,Testability,test,test,862,"Right now JLD2 files always include the full grid (with halos) in `file[""grid""]` which can make it hard to make plots of the data, especially if it was sliced (requiring users to know how to cut out the halos). Not sure if this is a bug as `file[""grid""]` might be referring to the grid the simulation was run on in which case it makes sense to include all the coordinates including halos, but this might still surprise users wishing to make plots. Thanks to @vchuravy for helping uncover this issue!. ```julia; using Oceananigans, Oceananigans.OutputWriters, JLD2; grid = RegularCartesianGrid(size=(8, 8, 8), extent=(1, 2, 3)); model = IncompressibleModel(grid=grid); simulation = Simulation(model, Δt=1, stop_iteration=1); simulation.output_writers[:test] = JLD2OutputWriter(model, merge(model.velocities, model.tracers), schedule=IterationInterval(1), prefix=""test"", field_slicer=FieldSlicer(k=grid.Nz, with_halos=false)); run!(simulation); f = jldopen(""test.jld2""); ```. so. ```julia; julia> size(f[""timeseries/u/1""]); (8, 8, 1); ```. but. ```julia; julia> f[""grid/zC""]; 10-element Array{Float64,1}:; -3.1875; -2.8125; -2.4375; -2.0625; -1.6875; -1.3125; -0.9375; -0.5625; -0.1875; 0.1875; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1194
https://github.com/CliMA/Oceananigans.jl/issues/1194:956,Testability,test,test,956,"Right now JLD2 files always include the full grid (with halos) in `file[""grid""]` which can make it hard to make plots of the data, especially if it was sliced (requiring users to know how to cut out the halos). Not sure if this is a bug as `file[""grid""]` might be referring to the grid the simulation was run on in which case it makes sense to include all the coordinates including halos, but this might still surprise users wishing to make plots. Thanks to @vchuravy for helping uncover this issue!. ```julia; using Oceananigans, Oceananigans.OutputWriters, JLD2; grid = RegularCartesianGrid(size=(8, 8, 8), extent=(1, 2, 3)); model = IncompressibleModel(grid=grid); simulation = Simulation(model, Δt=1, stop_iteration=1); simulation.output_writers[:test] = JLD2OutputWriter(model, merge(model.velocities, model.tracers), schedule=IterationInterval(1), prefix=""test"", field_slicer=FieldSlicer(k=grid.Nz, with_halos=false)); run!(simulation); f = jldopen(""test.jld2""); ```. so. ```julia; julia> size(f[""timeseries/u/1""]); (8, 8, 1); ```. but. ```julia; julia> f[""grid/zC""]; 10-element Array{Float64,1}:; -3.1875; -2.8125; -2.4375; -2.0625; -1.6875; -1.3125; -0.9375; -0.5625; -0.1875; 0.1875; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1194
https://github.com/CliMA/Oceananigans.jl/issues/1196:1020,Availability,error,error,1020,"I am trying to reproduce a simulation similar to the one in [this paper](https://journals.ametsoc.org/jpo/article/45/6/1554/12449/The-Energetics-of-Centrifugal-Instability) and when I checked the simulation after a whole day running I found it had crashed in the first hour. (Even though I was using the TimeStepWizard.) Or at least that's what I think happened judging by the output:. ```; i: 13960, sim time: 11.103 hours, wall time: 42.767 minutes, Δt: 2.875 seconds, CFL: 1.00e+00; i: 13970, sim time: 11.111 hours, wall time: 42.797 minutes, Δt: 2.875 seconds, CFL: 1.00e+00; i: 13980, sim time: 11.119 hours, wall time: 42.827 minutes, Δt: 2.875 seconds, CFL: 1.00e+00; i: 13990, sim time: 11.127 hours, wall time: 42.856 minutes, Δt: 2.875 seconds, CFL: NaN; i: 14000, sim time: NaN years, wall time: 42.885 minutes, Δt: NaN years, CFL: NaN; i: 14010, sim time: NaN years, wall time: 42.913 minutes, Δt: NaN years, CFL: NaN; ```. I wonder if it's possible to implement a check that kills the simulation/throws an error when it notices that it crashed. In my LES Fortran code I implemented something like that and it prevented me from wasting many core-hours simulating `NaN`s. Basically it was just something that checked if there were any `NaN`s in the domain and killed it otherwise. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1196
https://github.com/CliMA/Oceananigans.jl/issues/1197:108,Safety,avoid,avoid,108,"Would be nice to be able to specify a minimum time step for the `TimeStepWizard`. For me the main use is to avoid ""slow motion blowup"" where a numerical instability causes the model to blow up but the time step wizard keeps decreasing the time step so it just blows up in slow motion when you want it to NaN and stop executing.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1197
https://github.com/CliMA/Oceananigans.jl/pull/1198:205,Availability,Error,ErrorException,205,"This PR adds a NaN checker that checks for NaNs in the `[1, 1, 1]` grid point of the velocity fields at every time step (which should be very cheap and not affect performance). When a NaN is detected, an `ErrorException` is thrown so when running in the REPL it'll error and return control to the REPL, while if running a script from the terminal, it will terminate the Julia session (seems like the behavior we all want). Resolves #938; Resolves #1196",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1198
https://github.com/CliMA/Oceananigans.jl/pull/1198:265,Availability,error,error,265,"This PR adds a NaN checker that checks for NaNs in the `[1, 1, 1]` grid point of the velocity fields at every time step (which should be very cheap and not affect performance). When a NaN is detected, an `ErrorException` is thrown so when running in the REPL it'll error and return control to the REPL, while if running a script from the terminal, it will terminate the Julia session (seems like the behavior we all want). Resolves #938; Resolves #1196",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1198
https://github.com/CliMA/Oceananigans.jl/pull/1198:163,Performance,perform,performance,163,"This PR adds a NaN checker that checks for NaNs in the `[1, 1, 1]` grid point of the velocity fields at every time step (which should be very cheap and not affect performance). When a NaN is detected, an `ErrorException` is thrown so when running in the REPL it'll error and return control to the REPL, while if running a script from the terminal, it will terminate the Julia session (seems like the behavior we all want). Resolves #938; Resolves #1196",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1198
https://github.com/CliMA/Oceananigans.jl/pull/1198:191,Safety,detect,detected,191,"This PR adds a NaN checker that checks for NaNs in the `[1, 1, 1]` grid point of the velocity fields at every time step (which should be very cheap and not affect performance). When a NaN is detected, an `ErrorException` is thrown so when running in the REPL it'll error and return control to the REPL, while if running a script from the terminal, it will terminate the Julia session (seems like the behavior we all want). Resolves #938; Resolves #1196",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1198
https://github.com/CliMA/Oceananigans.jl/pull/1200:176,Deployability,release,release,176,Been a lot of changes since v0.44.1 (including some bug fixes) but don't think there have been any breaking changes (or massive new features) so was thinking we should tag and release v0.44.2.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1200
https://github.com/CliMA/Oceananigans.jl/issues/1203:1181,Availability,mask,mask,1181,"I'm getting results that are different from what I expected. Here's how I'm setting my grid, model and sponge:. ```; #-----; Lx = Ly = 16_000; Lz = 1_000; topology = (Periodic, Periodic, Bounded); factor = 1; grid = RegularCartesianGrid(size=(2048÷factor, 1, 256÷factor),; x=(0, Lx),; y=(0, 1),; z=(-Lz/2, +Lz/2),; topology=topology); #-----. #-----; ubc = UVelocityBoundaryConditions(grid,; bottom = BoundaryCondition(Gradient, 0),; top = BoundaryCondition(Gradient, 0),; ); vbc = VVelocityBoundaryConditions(grid,; bottom = BoundaryCondition(Gradient, 0),; top = BoundaryCondition(Gradient, 0),; ); wbc = WVelocityBoundaryConditions(grid,; bottom = BoundaryCondition(Value, 0),; top = BoundaryCondition(Value, 0),; ); bbc = TracerBoundaryConditions(grid,; bottom = BoundaryCondition(Gradient, N2),; top = BoundaryCondition(Gradient, N2),; ); #-----. #-----; # Set-up sponge layer; bottom_mask = GaussianMask{:z}(center=minimum(znodes(Face, grid)), width=grid.Lz/10); mom_sponge = Relaxation(rate=1/10, mask=bottom_mask, target=0); #----. model = IncompressibleModel(; architecture = GPU(),; grid = grid,; advection = UpwindBiasedThirdOrder(),; timestepper = :RungeKutta3,; closure = IsotropicDiffusivity(ν=1e-4, κ=1e-4),; coriolis = FPlane(f=f0),; tracers = (:b,),; buoyancy = BuoyancyTracer(),; boundary_conditions = (b=bbc, u=ubc, v=vbc, w=wbc),; forcing = (u=mom_sponge, v=mom_sponge, w=mom_sponge),; ```. From the docs, I expected this to ; > relax velocity fields to zero [...] in the bottom 1/10th of the domain. which leads me to believe that there's some a sharp cut-off in the function mask so that velocities above the range `[-500, -400]`aren't affected. However, when I plot the vertical velocities (and other variables with zero mean) I get the results below, which indicate that the sponge layer is active in the approximate range `[-500, -200]`, which is around 3 times larger than what I (thought I) set up. ![Screenshot from 2020-11-24 08-45-47](https://user-images.githubuserconte",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1203
https://github.com/CliMA/Oceananigans.jl/issues/1203:1774,Availability,mask,mask,1774,"nge:. ```; #-----; Lx = Ly = 16_000; Lz = 1_000; topology = (Periodic, Periodic, Bounded); factor = 1; grid = RegularCartesianGrid(size=(2048÷factor, 1, 256÷factor),; x=(0, Lx),; y=(0, 1),; z=(-Lz/2, +Lz/2),; topology=topology); #-----. #-----; ubc = UVelocityBoundaryConditions(grid,; bottom = BoundaryCondition(Gradient, 0),; top = BoundaryCondition(Gradient, 0),; ); vbc = VVelocityBoundaryConditions(grid,; bottom = BoundaryCondition(Gradient, 0),; top = BoundaryCondition(Gradient, 0),; ); wbc = WVelocityBoundaryConditions(grid,; bottom = BoundaryCondition(Value, 0),; top = BoundaryCondition(Value, 0),; ); bbc = TracerBoundaryConditions(grid,; bottom = BoundaryCondition(Gradient, N2),; top = BoundaryCondition(Gradient, N2),; ); #-----. #-----; # Set-up sponge layer; bottom_mask = GaussianMask{:z}(center=minimum(znodes(Face, grid)), width=grid.Lz/10); mom_sponge = Relaxation(rate=1/10, mask=bottom_mask, target=0); #----. model = IncompressibleModel(; architecture = GPU(),; grid = grid,; advection = UpwindBiasedThirdOrder(),; timestepper = :RungeKutta3,; closure = IsotropicDiffusivity(ν=1e-4, κ=1e-4),; coriolis = FPlane(f=f0),; tracers = (:b,),; buoyancy = BuoyancyTracer(),; boundary_conditions = (b=bbc, u=ubc, v=vbc, w=wbc),; forcing = (u=mom_sponge, v=mom_sponge, w=mom_sponge),; ```. From the docs, I expected this to ; > relax velocity fields to zero [...] in the bottom 1/10th of the domain. which leads me to believe that there's some a sharp cut-off in the function mask so that velocities above the range `[-500, -400]`aren't affected. However, when I plot the vertical velocities (and other variables with zero mean) I get the results below, which indicate that the sponge layer is active in the approximate range `[-500, -200]`, which is around 3 times larger than what I (thought I) set up. ![Screenshot from 2020-11-24 08-45-47](https://user-images.githubusercontent.com/13205162/100126723-2e4dea00-2e33-11eb-8a80-f97c525c6e91.png). Am I missing something here?. Thanks!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1203
https://github.com/CliMA/Oceananigans.jl/issues/1203:1901,Modifiability,variab,variables,1901,"nge:. ```; #-----; Lx = Ly = 16_000; Lz = 1_000; topology = (Periodic, Periodic, Bounded); factor = 1; grid = RegularCartesianGrid(size=(2048÷factor, 1, 256÷factor),; x=(0, Lx),; y=(0, 1),; z=(-Lz/2, +Lz/2),; topology=topology); #-----. #-----; ubc = UVelocityBoundaryConditions(grid,; bottom = BoundaryCondition(Gradient, 0),; top = BoundaryCondition(Gradient, 0),; ); vbc = VVelocityBoundaryConditions(grid,; bottom = BoundaryCondition(Gradient, 0),; top = BoundaryCondition(Gradient, 0),; ); wbc = WVelocityBoundaryConditions(grid,; bottom = BoundaryCondition(Value, 0),; top = BoundaryCondition(Value, 0),; ); bbc = TracerBoundaryConditions(grid,; bottom = BoundaryCondition(Gradient, N2),; top = BoundaryCondition(Gradient, N2),; ); #-----. #-----; # Set-up sponge layer; bottom_mask = GaussianMask{:z}(center=minimum(znodes(Face, grid)), width=grid.Lz/10); mom_sponge = Relaxation(rate=1/10, mask=bottom_mask, target=0); #----. model = IncompressibleModel(; architecture = GPU(),; grid = grid,; advection = UpwindBiasedThirdOrder(),; timestepper = :RungeKutta3,; closure = IsotropicDiffusivity(ν=1e-4, κ=1e-4),; coriolis = FPlane(f=f0),; tracers = (:b,),; buoyancy = BuoyancyTracer(),; boundary_conditions = (b=bbc, u=ubc, v=vbc, w=wbc),; forcing = (u=mom_sponge, v=mom_sponge, w=mom_sponge),; ```. From the docs, I expected this to ; > relax velocity fields to zero [...] in the bottom 1/10th of the domain. which leads me to believe that there's some a sharp cut-off in the function mask so that velocities above the range `[-500, -400]`aren't affected. However, when I plot the vertical velocities (and other variables with zero mean) I get the results below, which indicate that the sponge layer is active in the approximate range `[-500, -200]`, which is around 3 times larger than what I (thought I) set up. ![Screenshot from 2020-11-24 08-45-47](https://user-images.githubusercontent.com/13205162/100126723-2e4dea00-2e33-11eb-8a80-f97c525c6e91.png). Am I missing something here?. Thanks!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1203
https://github.com/CliMA/Oceananigans.jl/issues/1204:212,Availability,error,error,212,"Some model constructor kwargs, e.g. `boundary_conditions` and `forcing` need to be named tuples otherwise things can silently fail (or fail in an obscure manner). Would be nice if the model constructors threw an error if it expected a named tuple. Could just type the kwargs, e.g. `boundary_conditions::Union{Nothing,NamedTuple}` like we did for #1118. cc @whitleyv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1204
https://github.com/CliMA/Oceananigans.jl/issues/1205:337,Availability,error,error,337,"I have been playing with the one_dimensional_diffusion.jl example and have found something a bit odd. When I run it, with everything already installed, it seems to complain about [line18](https://github.com/CliMA/Oceananigans.jl/blob/a343711f1101b1a433124f5f9697ce60b1011a40/examples/one_dimensional_diffusion.jl#L18) with the following error,. ```; ERROR: LoadError: package `Oceananigans [9e8cae18]` has same name or UUID as the active project; ```. Is this expected? . Is this something we want to avoid?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1205
https://github.com/CliMA/Oceananigans.jl/issues/1205:350,Availability,ERROR,ERROR,350,"I have been playing with the one_dimensional_diffusion.jl example and have found something a bit odd. When I run it, with everything already installed, it seems to complain about [line18](https://github.com/CliMA/Oceananigans.jl/blob/a343711f1101b1a433124f5f9697ce60b1011a40/examples/one_dimensional_diffusion.jl#L18) with the following error,. ```; ERROR: LoadError: package `Oceananigans [9e8cae18]` has same name or UUID as the active project; ```. Is this expected? . Is this something we want to avoid?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1205
https://github.com/CliMA/Oceananigans.jl/issues/1205:141,Deployability,install,installed,141,"I have been playing with the one_dimensional_diffusion.jl example and have found something a bit odd. When I run it, with everything already installed, it seems to complain about [line18](https://github.com/CliMA/Oceananigans.jl/blob/a343711f1101b1a433124f5f9697ce60b1011a40/examples/one_dimensional_diffusion.jl#L18) with the following error,. ```; ERROR: LoadError: package `Oceananigans [9e8cae18]` has same name or UUID as the active project; ```. Is this expected? . Is this something we want to avoid?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1205
https://github.com/CliMA/Oceananigans.jl/issues/1205:357,Performance,Load,LoadError,357,"I have been playing with the one_dimensional_diffusion.jl example and have found something a bit odd. When I run it, with everything already installed, it seems to complain about [line18](https://github.com/CliMA/Oceananigans.jl/blob/a343711f1101b1a433124f5f9697ce60b1011a40/examples/one_dimensional_diffusion.jl#L18) with the following error,. ```; ERROR: LoadError: package `Oceananigans [9e8cae18]` has same name or UUID as the active project; ```. Is this expected? . Is this something we want to avoid?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1205
https://github.com/CliMA/Oceananigans.jl/issues/1205:501,Safety,avoid,avoid,501,"I have been playing with the one_dimensional_diffusion.jl example and have found something a bit odd. When I run it, with everything already installed, it seems to complain about [line18](https://github.com/CliMA/Oceananigans.jl/blob/a343711f1101b1a433124f5f9697ce60b1011a40/examples/one_dimensional_diffusion.jl#L18) with the following error,. ```; ERROR: LoadError: package `Oceananigans [9e8cae18]` has same name or UUID as the active project; ```. Is this expected? . Is this something we want to avoid?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1205
https://github.com/CliMA/Oceananigans.jl/issues/1208:239,Usability,clear,clear,239,"This is a very minor thing, but I have been using netCDF files almost exclusively and I've noticed that, while all the length dimensions have their names and units very well defined in the attributes, the `time` dimension does not. . It's clear what `time` is so this isn't a big issue, but it would be nice somewhere along the line to also include that. Thanks!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1208
https://github.com/CliMA/Oceananigans.jl/issues/1212:109,Security,validat,validation,109,"Apparently the figures in the [Convergence tests](; https://clima.github.io/OceananigansDocumentation/latest/validation/convergence_tests/) and Stratified Couette flow sections of the documentation aren't showing. I suspect it's a broken link or something (probably very easy to fix). Sorry if you guys are aware of this already, but I couldn't find any issue about it. Cheer!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1212
https://github.com/CliMA/Oceananigans.jl/issues/1212:43,Testability,test,tests,43,"Apparently the figures in the [Convergence tests](; https://clima.github.io/OceananigansDocumentation/latest/validation/convergence_tests/) and Stratified Couette flow sections of the documentation aren't showing. I suspect it's a broken link or something (probably very easy to fix). Sorry if you guys are aware of this already, but I couldn't find any issue about it. Cheer!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1212
https://github.com/CliMA/Oceananigans.jl/pull/1213:167,Energy Efficiency,schedul,schedules,167,"Previous behavior was that time steps could overshoot output writing times and simulation stop times, which caused output to not be exactly aligned with the specified schedules. This PR fixes this long-complained-about fact.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1213
https://github.com/CliMA/Oceananigans.jl/pull/1214:62,Testability,benchmark,benchmarks,62,Previously if you ran `benchmark_regression.jl` it'll run the benchmarks but not print any useful results. This PR prints some benchmark results to make it a useful benchmarking script.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1214
https://github.com/CliMA/Oceananigans.jl/pull/1214:127,Testability,benchmark,benchmark,127,Previously if you ran `benchmark_regression.jl` it'll run the benchmarks but not print any useful results. This PR prints some benchmark results to make it a useful benchmarking script.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1214
https://github.com/CliMA/Oceananigans.jl/pull/1214:165,Testability,benchmark,benchmarking,165,Previously if you ran `benchmark_regression.jl` it'll run the benchmarks but not print any useful results. This PR prints some benchmark results to make it a useful benchmarking script.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1214
https://github.com/CliMA/Oceananigans.jl/pull/1217:170,Testability,test,tested,170,"This pull request changes the compat entry for the `NCDatasets` package from `0.10` to `0.10, 0.11`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1217
https://github.com/CliMA/Oceananigans.jl/pull/1217:275,Testability,test,tests,275,"This pull request changes the compat entry for the `NCDatasets` package from `0.10` to `0.10, 0.11`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1217
https://github.com/CliMA/Oceananigans.jl/issues/1218:405,Energy Efficiency,allocate,allocate,405,Running with 2 threads is the worst memory-wise. See benchmarks from https://github.com/CliMA/Oceananigans.jl/pull/1120#issuecomment-732516353 and similar results were reported by @francispoulin on a different machine from https://github.com/CliMA/Oceananigans.jl/pull/1210#issuecomment-734500922. Not sure if this is because of Oceananigans.jl or because of KernelAbstractions.jl. Multithreaded seems to allocate a ton of memory in general though.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1218
https://github.com/CliMA/Oceananigans.jl/issues/1218:53,Testability,benchmark,benchmarks,53,Running with 2 threads is the worst memory-wise. See benchmarks from https://github.com/CliMA/Oceananigans.jl/pull/1120#issuecomment-732516353 and similar results were reported by @francispoulin on a different machine from https://github.com/CliMA/Oceananigans.jl/pull/1210#issuecomment-734500922. Not sure if this is because of Oceananigans.jl or because of KernelAbstractions.jl. Multithreaded seems to allocate a ton of memory in general though.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1218
https://github.com/CliMA/Oceananigans.jl/pull/1222:171,Testability,test,tested,171,"This pull request changes the compat entry for the `StaticArrays` package from `0.12` to `0.12, 1.0`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1222
https://github.com/CliMA/Oceananigans.jl/pull/1222:276,Testability,test,tests,276,"This pull request changes the compat entry for the `StaticArrays` package from `0.12` to `0.12, 1.0`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1222
https://github.com/CliMA/Oceananigans.jl/pull/1223:29,Deployability,pipeline,pipeline,29,This PR finally sets up a CI pipeline to run convergence tests and validation experiments for CPU and GPU on Buildkite. Don't think this should run on every push like the main pipeline does and I couldn't figure out how to trigger it via a GitHub comment (see https://github.com/CliMA/slurm-buildkite/issues/13). We can trigger this pipeline manually from Buildkite and I've scheduled it to run every night at 3am EST (on the master branch). Cool thing is that it uploads the convergence plots as artifacts so we can view them from Buildkite!. ![image](https://user-images.githubusercontent.com/20099589/100450878-6b5ceb00-3084-11eb-9cec-8072098b03b9.png). Resolves #1216,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1223
https://github.com/CliMA/Oceananigans.jl/pull/1223:176,Deployability,pipeline,pipeline,176,This PR finally sets up a CI pipeline to run convergence tests and validation experiments for CPU and GPU on Buildkite. Don't think this should run on every push like the main pipeline does and I couldn't figure out how to trigger it via a GitHub comment (see https://github.com/CliMA/slurm-buildkite/issues/13). We can trigger this pipeline manually from Buildkite and I've scheduled it to run every night at 3am EST (on the master branch). Cool thing is that it uploads the convergence plots as artifacts so we can view them from Buildkite!. ![image](https://user-images.githubusercontent.com/20099589/100450878-6b5ceb00-3084-11eb-9cec-8072098b03b9.png). Resolves #1216,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1223
https://github.com/CliMA/Oceananigans.jl/pull/1223:333,Deployability,pipeline,pipeline,333,This PR finally sets up a CI pipeline to run convergence tests and validation experiments for CPU and GPU on Buildkite. Don't think this should run on every push like the main pipeline does and I couldn't figure out how to trigger it via a GitHub comment (see https://github.com/CliMA/slurm-buildkite/issues/13). We can trigger this pipeline manually from Buildkite and I've scheduled it to run every night at 3am EST (on the master branch). Cool thing is that it uploads the convergence plots as artifacts so we can view them from Buildkite!. ![image](https://user-images.githubusercontent.com/20099589/100450878-6b5ceb00-3084-11eb-9cec-8072098b03b9.png). Resolves #1216,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1223
https://github.com/CliMA/Oceananigans.jl/pull/1223:375,Energy Efficiency,schedul,scheduled,375,This PR finally sets up a CI pipeline to run convergence tests and validation experiments for CPU and GPU on Buildkite. Don't think this should run on every push like the main pipeline does and I couldn't figure out how to trigger it via a GitHub comment (see https://github.com/CliMA/slurm-buildkite/issues/13). We can trigger this pipeline manually from Buildkite and I've scheduled it to run every night at 3am EST (on the master branch). Cool thing is that it uploads the convergence plots as artifacts so we can view them from Buildkite!. ![image](https://user-images.githubusercontent.com/20099589/100450878-6b5ceb00-3084-11eb-9cec-8072098b03b9.png). Resolves #1216,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1223
https://github.com/CliMA/Oceananigans.jl/pull/1223:67,Security,validat,validation,67,This PR finally sets up a CI pipeline to run convergence tests and validation experiments for CPU and GPU on Buildkite. Don't think this should run on every push like the main pipeline does and I couldn't figure out how to trigger it via a GitHub comment (see https://github.com/CliMA/slurm-buildkite/issues/13). We can trigger this pipeline manually from Buildkite and I've scheduled it to run every night at 3am EST (on the master branch). Cool thing is that it uploads the convergence plots as artifacts so we can view them from Buildkite!. ![image](https://user-images.githubusercontent.com/20099589/100450878-6b5ceb00-3084-11eb-9cec-8072098b03b9.png). Resolves #1216,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1223
https://github.com/CliMA/Oceananigans.jl/pull/1223:57,Testability,test,tests,57,This PR finally sets up a CI pipeline to run convergence tests and validation experiments for CPU and GPU on Buildkite. Don't think this should run on every push like the main pipeline does and I couldn't figure out how to trigger it via a GitHub comment (see https://github.com/CliMA/slurm-buildkite/issues/13). We can trigger this pipeline manually from Buildkite and I've scheduled it to run every night at 3am EST (on the master branch). Cool thing is that it uploads the convergence plots as artifacts so we can view them from Buildkite!. ![image](https://user-images.githubusercontent.com/20099589/100450878-6b5ceb00-3084-11eb-9cec-8072098b03b9.png). Resolves #1216,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1223
https://github.com/CliMA/Oceananigans.jl/pull/1225:68,Deployability,deploy,deployment,68,Thanks for the heads up @vchuravy and @maleadt! Will remove the old deployment key from https://github.com/CliMA/OceananigansDocumentation and generate a new one (that'll actually stay a secret).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1225
https://github.com/CliMA/Oceananigans.jl/issues/1227:1195,Availability,error,error,1195,"I have been exclusively using the netCDF output option and, after upgrading to v0.44.2, I've noticed the behavior of `NetCDFWriter` changed. . - First thing is that I get a message that the mode hasn't been set even when it has, which seems like a bug to me. So, for example, setting the writer as . ```; using Oceananigans.OutputWriters. outputs_netcdf = (u = model.velocities.u,; v = model.velocities.v,; ). simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, outputs_netcdf,; filepath = ""mwe.nc"",; schedule = TimeInterval(5seconds),; mode = ""c""); ```. I get a warning saying `mwe.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file.`, even though the mode is clearly set to clobber. And sure enough, if I run the simulation it appends to the previous netcdf file. (Also, the docs still say that the default mode is `""c""`, but it now changed to `""a""`). - The other thing is that after I set up the `NetCDFWriter` the file is always open by the Julia REPL and unreachable from anywhere else. So for example if I want to check on the simulation by opening the output netcdf file with Python I get an error saying that the file is being used. So I need to either make a copy of the file and access the copy (which uses up space) or wait for the simulation to finish, which isn't ideal. I can't imagine opening and closing a netCDF file takes long (especially since we ideally won't write to it at every time step), so is there a reason for the netCDF file to always stay open inside Julia?. Thanks!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1227
https://github.com/CliMA/Oceananigans.jl/issues/1227:519,Energy Efficiency,schedul,schedule,519,"I have been exclusively using the netCDF output option and, after upgrading to v0.44.2, I've noticed the behavior of `NetCDFWriter` changed. . - First thing is that I get a message that the mode hasn't been set even when it has, which seems like a bug to me. So, for example, setting the writer as . ```; using Oceananigans.OutputWriters. outputs_netcdf = (u = model.velocities.u,; v = model.velocities.v,; ). simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, outputs_netcdf,; filepath = ""mwe.nc"",; schedule = TimeInterval(5seconds),; mode = ""c""); ```. I get a warning saying `mwe.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file.`, even though the mode is clearly set to clobber. And sure enough, if I run the simulation it appends to the previous netcdf file. (Also, the docs still say that the default mode is `""c""`, but it now changed to `""a""`). - The other thing is that after I set up the `NetCDFWriter` the file is always open by the Julia REPL and unreachable from anywhere else. So for example if I want to check on the simulation by opening the output netcdf file with Python I get an error saying that the file is being used. So I need to either make a copy of the file and access the copy (which uses up space) or wait for the simulation to finish, which isn't ideal. I can't imagine opening and closing a netCDF file takes long (especially since we ideally won't write to it at every time step), so is there a reason for the netCDF file to always stay open inside Julia?. Thanks!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1227
https://github.com/CliMA/Oceananigans.jl/issues/1227:173,Integrability,message,message,173,"I have been exclusively using the netCDF output option and, after upgrading to v0.44.2, I've noticed the behavior of `NetCDFWriter` changed. . - First thing is that I get a message that the mode hasn't been set even when it has, which seems like a bug to me. So, for example, setting the writer as . ```; using Oceananigans.OutputWriters. outputs_netcdf = (u = model.velocities.u,; v = model.velocities.v,; ). simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, outputs_netcdf,; filepath = ""mwe.nc"",; schedule = TimeInterval(5seconds),; mode = ""c""); ```. I get a warning saying `mwe.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file.`, even though the mode is clearly set to clobber. And sure enough, if I run the simulation it appends to the previous netcdf file. (Also, the docs still say that the default mode is `""c""`, but it now changed to `""a""`). - The other thing is that after I set up the `NetCDFWriter` the file is always open by the Julia REPL and unreachable from anywhere else. So for example if I want to check on the simulation by opening the output netcdf file with Python I get an error saying that the file is being used. So I need to either make a copy of the file and access the copy (which uses up space) or wait for the simulation to finish, which isn't ideal. I can't imagine opening and closing a netCDF file takes long (especially since we ideally won't write to it at every time step), so is there a reason for the netCDF file to always stay open inside Julia?. Thanks!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1227
https://github.com/CliMA/Oceananigans.jl/issues/1227:1285,Security,access,access,1285,"I have been exclusively using the netCDF output option and, after upgrading to v0.44.2, I've noticed the behavior of `NetCDFWriter` changed. . - First thing is that I get a message that the mode hasn't been set even when it has, which seems like a bug to me. So, for example, setting the writer as . ```; using Oceananigans.OutputWriters. outputs_netcdf = (u = model.velocities.u,; v = model.velocities.v,; ). simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, outputs_netcdf,; filepath = ""mwe.nc"",; schedule = TimeInterval(5seconds),; mode = ""c""); ```. I get a warning saying `mwe.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file.`, even though the mode is clearly set to clobber. And sure enough, if I run the simulation it appends to the previous netcdf file. (Also, the docs still say that the default mode is `""c""`, but it now changed to `""a""`). - The other thing is that after I set up the `NetCDFWriter` the file is always open by the Julia REPL and unreachable from anywhere else. So for example if I want to check on the simulation by opening the output netcdf file with Python I get an error saying that the file is being used. So I need to either make a copy of the file and access the copy (which uses up space) or wait for the simulation to finish, which isn't ideal. I can't imagine opening and closing a netCDF file takes long (especially since we ideally won't write to it at every time step), so is there a reason for the netCDF file to always stay open inside Julia?. Thanks!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1227
https://github.com/CliMA/Oceananigans.jl/issues/1227:757,Usability,clear,clearly,757,"I have been exclusively using the netCDF output option and, after upgrading to v0.44.2, I've noticed the behavior of `NetCDFWriter` changed. . - First thing is that I get a message that the mode hasn't been set even when it has, which seems like a bug to me. So, for example, setting the writer as . ```; using Oceananigans.OutputWriters. outputs_netcdf = (u = model.velocities.u,; v = model.velocities.v,; ). simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, outputs_netcdf,; filepath = ""mwe.nc"",; schedule = TimeInterval(5seconds),; mode = ""c""); ```. I get a warning saying `mwe.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file.`, even though the mode is clearly set to clobber. And sure enough, if I run the simulation it appends to the previous netcdf file. (Also, the docs still say that the default mode is `""c""`, but it now changed to `""a""`). - The other thing is that after I set up the `NetCDFWriter` the file is always open by the Julia REPL and unreachable from anywhere else. So for example if I want to check on the simulation by opening the output netcdf file with Python I get an error saying that the file is being used. So I need to either make a copy of the file and access the copy (which uses up space) or wait for the simulation to finish, which isn't ideal. I can't imagine opening and closing a netCDF file takes long (especially since we ideally won't write to it at every time step), so is there a reason for the netCDF file to always stay open inside Julia?. Thanks!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1227
https://github.com/CliMA/Oceananigans.jl/pull/1228:403,Security,access,accessing,403,"Thanks to @leios and @francispoulin for feedback that helped locate the issue!. Resolves #1170 . This PR fixes a bug in how index unpermutation is done as part of the Makhoul (1980) fast cosine transform algorithm we use for the GPU. It only affected wall-bounded dimensions of odd length (see below). Oceananigans was effectively setting the pressure to zero at the topmost grid point (it was actually accessing memory from out-of-bounds but since the bug was pretty consistent I assume it always grabbed some close-to-zero number). I'm shocked that no test picked this up... But looking at our tests, we don't test dimensions of odd length on the GPU. This is probably because in earlier versions of Oceananigans, GPU models only supported dimension lengths that were multiples of 16 (due to hard-coded thread-block layouts). So we probably don't have many, if any, comprehensive GPU tests with odd-sized wall-bounded dimensions. . TODO:; - [x] Add a test that fails due to this bug.; - [x] Confirm that the minimal icy moon setup does not blow up if Nz is even.; - [x] Commit fix. Test should pass and minimal icy moon should not blow up.; - [x] Ensure `divergence_free_poisson_solution` test runs on GPU with odd sizes (currently only even sizes are tested).; - [x] Ensure `poisson_solver_convergence` test runs on the GPU with even and odd sizes (currently it is not tested on the GPU). # Reproduction. ```julia; julia> permute(i, N) = isodd(i) ? floor(Int, i/2) + 1 : N - floor(Int, (i-1)/2); permute (generic function with 1 method). julia> unpermute(i, N) = i <= N/2 ? 2i-1 : 2(N-i+1); unpermute (generic function with 1 method); ```. This works fine for dimensions of even length:. ```julia; julia> N = 4; 4. julia> L = [permute(i, N) for i in 1:N]; 4-element Array{Int64,1}:; 1; 4; 2; 3. julia> [unpermute(i, N) for i in L]; 4-element Array{Int64,1}:; 1; 2; 3; 4; ```. but fails for dimensions of odd length:. ```julia; julia> N = 5; 5. julia> L = [permute(i, N) for i in 1:N]; 5-element Arr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1228
https://github.com/CliMA/Oceananigans.jl/pull/1228:554,Testability,test,test,554,"Thanks to @leios and @francispoulin for feedback that helped locate the issue!. Resolves #1170 . This PR fixes a bug in how index unpermutation is done as part of the Makhoul (1980) fast cosine transform algorithm we use for the GPU. It only affected wall-bounded dimensions of odd length (see below). Oceananigans was effectively setting the pressure to zero at the topmost grid point (it was actually accessing memory from out-of-bounds but since the bug was pretty consistent I assume it always grabbed some close-to-zero number). I'm shocked that no test picked this up... But looking at our tests, we don't test dimensions of odd length on the GPU. This is probably because in earlier versions of Oceananigans, GPU models only supported dimension lengths that were multiples of 16 (due to hard-coded thread-block layouts). So we probably don't have many, if any, comprehensive GPU tests with odd-sized wall-bounded dimensions. . TODO:; - [x] Add a test that fails due to this bug.; - [x] Confirm that the minimal icy moon setup does not blow up if Nz is even.; - [x] Commit fix. Test should pass and minimal icy moon should not blow up.; - [x] Ensure `divergence_free_poisson_solution` test runs on GPU with odd sizes (currently only even sizes are tested).; - [x] Ensure `poisson_solver_convergence` test runs on the GPU with even and odd sizes (currently it is not tested on the GPU). # Reproduction. ```julia; julia> permute(i, N) = isodd(i) ? floor(Int, i/2) + 1 : N - floor(Int, (i-1)/2); permute (generic function with 1 method). julia> unpermute(i, N) = i <= N/2 ? 2i-1 : 2(N-i+1); unpermute (generic function with 1 method); ```. This works fine for dimensions of even length:. ```julia; julia> N = 4; 4. julia> L = [permute(i, N) for i in 1:N]; 4-element Array{Int64,1}:; 1; 4; 2; 3. julia> [unpermute(i, N) for i in L]; 4-element Array{Int64,1}:; 1; 2; 3; 4; ```. but fails for dimensions of odd length:. ```julia; julia> N = 5; 5. julia> L = [permute(i, N) for i in 1:N]; 5-element Arr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1228
https://github.com/CliMA/Oceananigans.jl/pull/1228:596,Testability,test,tests,596,"Thanks to @leios and @francispoulin for feedback that helped locate the issue!. Resolves #1170 . This PR fixes a bug in how index unpermutation is done as part of the Makhoul (1980) fast cosine transform algorithm we use for the GPU. It only affected wall-bounded dimensions of odd length (see below). Oceananigans was effectively setting the pressure to zero at the topmost grid point (it was actually accessing memory from out-of-bounds but since the bug was pretty consistent I assume it always grabbed some close-to-zero number). I'm shocked that no test picked this up... But looking at our tests, we don't test dimensions of odd length on the GPU. This is probably because in earlier versions of Oceananigans, GPU models only supported dimension lengths that were multiples of 16 (due to hard-coded thread-block layouts). So we probably don't have many, if any, comprehensive GPU tests with odd-sized wall-bounded dimensions. . TODO:; - [x] Add a test that fails due to this bug.; - [x] Confirm that the minimal icy moon setup does not blow up if Nz is even.; - [x] Commit fix. Test should pass and minimal icy moon should not blow up.; - [x] Ensure `divergence_free_poisson_solution` test runs on GPU with odd sizes (currently only even sizes are tested).; - [x] Ensure `poisson_solver_convergence` test runs on the GPU with even and odd sizes (currently it is not tested on the GPU). # Reproduction. ```julia; julia> permute(i, N) = isodd(i) ? floor(Int, i/2) + 1 : N - floor(Int, (i-1)/2); permute (generic function with 1 method). julia> unpermute(i, N) = i <= N/2 ? 2i-1 : 2(N-i+1); unpermute (generic function with 1 method); ```. This works fine for dimensions of even length:. ```julia; julia> N = 4; 4. julia> L = [permute(i, N) for i in 1:N]; 4-element Array{Int64,1}:; 1; 4; 2; 3. julia> [unpermute(i, N) for i in L]; 4-element Array{Int64,1}:; 1; 2; 3; 4; ```. but fails for dimensions of odd length:. ```julia; julia> N = 5; 5. julia> L = [permute(i, N) for i in 1:N]; 5-element Arr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1228
https://github.com/CliMA/Oceananigans.jl/pull/1228:612,Testability,test,test,612,"Thanks to @leios and @francispoulin for feedback that helped locate the issue!. Resolves #1170 . This PR fixes a bug in how index unpermutation is done as part of the Makhoul (1980) fast cosine transform algorithm we use for the GPU. It only affected wall-bounded dimensions of odd length (see below). Oceananigans was effectively setting the pressure to zero at the topmost grid point (it was actually accessing memory from out-of-bounds but since the bug was pretty consistent I assume it always grabbed some close-to-zero number). I'm shocked that no test picked this up... But looking at our tests, we don't test dimensions of odd length on the GPU. This is probably because in earlier versions of Oceananigans, GPU models only supported dimension lengths that were multiples of 16 (due to hard-coded thread-block layouts). So we probably don't have many, if any, comprehensive GPU tests with odd-sized wall-bounded dimensions. . TODO:; - [x] Add a test that fails due to this bug.; - [x] Confirm that the minimal icy moon setup does not blow up if Nz is even.; - [x] Commit fix. Test should pass and minimal icy moon should not blow up.; - [x] Ensure `divergence_free_poisson_solution` test runs on GPU with odd sizes (currently only even sizes are tested).; - [x] Ensure `poisson_solver_convergence` test runs on the GPU with even and odd sizes (currently it is not tested on the GPU). # Reproduction. ```julia; julia> permute(i, N) = isodd(i) ? floor(Int, i/2) + 1 : N - floor(Int, (i-1)/2); permute (generic function with 1 method). julia> unpermute(i, N) = i <= N/2 ? 2i-1 : 2(N-i+1); unpermute (generic function with 1 method); ```. This works fine for dimensions of even length:. ```julia; julia> N = 4; 4. julia> L = [permute(i, N) for i in 1:N]; 4-element Array{Int64,1}:; 1; 4; 2; 3. julia> [unpermute(i, N) for i in L]; 4-element Array{Int64,1}:; 1; 2; 3; 4; ```. but fails for dimensions of odd length:. ```julia; julia> N = 5; 5. julia> L = [permute(i, N) for i in 1:N]; 5-element Arr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1228
https://github.com/CliMA/Oceananigans.jl/pull/1228:886,Testability,test,tests,886,"Thanks to @leios and @francispoulin for feedback that helped locate the issue!. Resolves #1170 . This PR fixes a bug in how index unpermutation is done as part of the Makhoul (1980) fast cosine transform algorithm we use for the GPU. It only affected wall-bounded dimensions of odd length (see below). Oceananigans was effectively setting the pressure to zero at the topmost grid point (it was actually accessing memory from out-of-bounds but since the bug was pretty consistent I assume it always grabbed some close-to-zero number). I'm shocked that no test picked this up... But looking at our tests, we don't test dimensions of odd length on the GPU. This is probably because in earlier versions of Oceananigans, GPU models only supported dimension lengths that were multiples of 16 (due to hard-coded thread-block layouts). So we probably don't have many, if any, comprehensive GPU tests with odd-sized wall-bounded dimensions. . TODO:; - [x] Add a test that fails due to this bug.; - [x] Confirm that the minimal icy moon setup does not blow up if Nz is even.; - [x] Commit fix. Test should pass and minimal icy moon should not blow up.; - [x] Ensure `divergence_free_poisson_solution` test runs on GPU with odd sizes (currently only even sizes are tested).; - [x] Ensure `poisson_solver_convergence` test runs on the GPU with even and odd sizes (currently it is not tested on the GPU). # Reproduction. ```julia; julia> permute(i, N) = isodd(i) ? floor(Int, i/2) + 1 : N - floor(Int, (i-1)/2); permute (generic function with 1 method). julia> unpermute(i, N) = i <= N/2 ? 2i-1 : 2(N-i+1); unpermute (generic function with 1 method); ```. This works fine for dimensions of even length:. ```julia; julia> N = 4; 4. julia> L = [permute(i, N) for i in 1:N]; 4-element Array{Int64,1}:; 1; 4; 2; 3. julia> [unpermute(i, N) for i in L]; 4-element Array{Int64,1}:; 1; 2; 3; 4; ```. but fails for dimensions of odd length:. ```julia; julia> N = 5; 5. julia> L = [permute(i, N) for i in 1:N]; 5-element Arr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1228
https://github.com/CliMA/Oceananigans.jl/pull/1228:953,Testability,test,test,953,"Thanks to @leios and @francispoulin for feedback that helped locate the issue!. Resolves #1170 . This PR fixes a bug in how index unpermutation is done as part of the Makhoul (1980) fast cosine transform algorithm we use for the GPU. It only affected wall-bounded dimensions of odd length (see below). Oceananigans was effectively setting the pressure to zero at the topmost grid point (it was actually accessing memory from out-of-bounds but since the bug was pretty consistent I assume it always grabbed some close-to-zero number). I'm shocked that no test picked this up... But looking at our tests, we don't test dimensions of odd length on the GPU. This is probably because in earlier versions of Oceananigans, GPU models only supported dimension lengths that were multiples of 16 (due to hard-coded thread-block layouts). So we probably don't have many, if any, comprehensive GPU tests with odd-sized wall-bounded dimensions. . TODO:; - [x] Add a test that fails due to this bug.; - [x] Confirm that the minimal icy moon setup does not blow up if Nz is even.; - [x] Commit fix. Test should pass and minimal icy moon should not blow up.; - [x] Ensure `divergence_free_poisson_solution` test runs on GPU with odd sizes (currently only even sizes are tested).; - [x] Ensure `poisson_solver_convergence` test runs on the GPU with even and odd sizes (currently it is not tested on the GPU). # Reproduction. ```julia; julia> permute(i, N) = isodd(i) ? floor(Int, i/2) + 1 : N - floor(Int, (i-1)/2); permute (generic function with 1 method). julia> unpermute(i, N) = i <= N/2 ? 2i-1 : 2(N-i+1); unpermute (generic function with 1 method); ```. This works fine for dimensions of even length:. ```julia; julia> N = 4; 4. julia> L = [permute(i, N) for i in 1:N]; 4-element Array{Int64,1}:; 1; 4; 2; 3. julia> [unpermute(i, N) for i in L]; 4-element Array{Int64,1}:; 1; 2; 3; 4; ```. but fails for dimensions of odd length:. ```julia; julia> N = 5; 5. julia> L = [permute(i, N) for i in 1:N]; 5-element Arr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1228
https://github.com/CliMA/Oceananigans.jl/pull/1228:1084,Testability,Test,Test,1084," bug in how index unpermutation is done as part of the Makhoul (1980) fast cosine transform algorithm we use for the GPU. It only affected wall-bounded dimensions of odd length (see below). Oceananigans was effectively setting the pressure to zero at the topmost grid point (it was actually accessing memory from out-of-bounds but since the bug was pretty consistent I assume it always grabbed some close-to-zero number). I'm shocked that no test picked this up... But looking at our tests, we don't test dimensions of odd length on the GPU. This is probably because in earlier versions of Oceananigans, GPU models only supported dimension lengths that were multiples of 16 (due to hard-coded thread-block layouts). So we probably don't have many, if any, comprehensive GPU tests with odd-sized wall-bounded dimensions. . TODO:; - [x] Add a test that fails due to this bug.; - [x] Confirm that the minimal icy moon setup does not blow up if Nz is even.; - [x] Commit fix. Test should pass and minimal icy moon should not blow up.; - [x] Ensure `divergence_free_poisson_solution` test runs on GPU with odd sizes (currently only even sizes are tested).; - [x] Ensure `poisson_solver_convergence` test runs on the GPU with even and odd sizes (currently it is not tested on the GPU). # Reproduction. ```julia; julia> permute(i, N) = isodd(i) ? floor(Int, i/2) + 1 : N - floor(Int, (i-1)/2); permute (generic function with 1 method). julia> unpermute(i, N) = i <= N/2 ? 2i-1 : 2(N-i+1); unpermute (generic function with 1 method); ```. This works fine for dimensions of even length:. ```julia; julia> N = 4; 4. julia> L = [permute(i, N) for i in 1:N]; 4-element Array{Int64,1}:; 1; 4; 2; 3. julia> [unpermute(i, N) for i in L]; 4-element Array{Int64,1}:; 1; 2; 3; 4; ```. but fails for dimensions of odd length:. ```julia; julia> N = 5; 5. julia> L = [permute(i, N) for i in 1:N]; 5-element Array{Int64,1}:; 1; 5; 2; 4; 3. julia> [unpermute(i, N) for i in L]; 5-element Array{Int64,1}:; 1; 2; 3; 4; 6; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1228
https://github.com/CliMA/Oceananigans.jl/pull/1228:1191,Testability,test,test,1191,"rm algorithm we use for the GPU. It only affected wall-bounded dimensions of odd length (see below). Oceananigans was effectively setting the pressure to zero at the topmost grid point (it was actually accessing memory from out-of-bounds but since the bug was pretty consistent I assume it always grabbed some close-to-zero number). I'm shocked that no test picked this up... But looking at our tests, we don't test dimensions of odd length on the GPU. This is probably because in earlier versions of Oceananigans, GPU models only supported dimension lengths that were multiples of 16 (due to hard-coded thread-block layouts). So we probably don't have many, if any, comprehensive GPU tests with odd-sized wall-bounded dimensions. . TODO:; - [x] Add a test that fails due to this bug.; - [x] Confirm that the minimal icy moon setup does not blow up if Nz is even.; - [x] Commit fix. Test should pass and minimal icy moon should not blow up.; - [x] Ensure `divergence_free_poisson_solution` test runs on GPU with odd sizes (currently only even sizes are tested).; - [x] Ensure `poisson_solver_convergence` test runs on the GPU with even and odd sizes (currently it is not tested on the GPU). # Reproduction. ```julia; julia> permute(i, N) = isodd(i) ? floor(Int, i/2) + 1 : N - floor(Int, (i-1)/2); permute (generic function with 1 method). julia> unpermute(i, N) = i <= N/2 ? 2i-1 : 2(N-i+1); unpermute (generic function with 1 method); ```. This works fine for dimensions of even length:. ```julia; julia> N = 4; 4. julia> L = [permute(i, N) for i in 1:N]; 4-element Array{Int64,1}:; 1; 4; 2; 3. julia> [unpermute(i, N) for i in L]; 4-element Array{Int64,1}:; 1; 2; 3; 4; ```. but fails for dimensions of odd length:. ```julia; julia> N = 5; 5. julia> L = [permute(i, N) for i in 1:N]; 5-element Array{Int64,1}:; 1; 5; 2; 4; 3. julia> [unpermute(i, N) for i in L]; 5-element Array{Int64,1}:; 1; 2; 3; 4; 6; ```. # Fix. ```julia; julia> unpermute(i, N) = i <= ceil(N/2) ? 2i-1 : 2(N-i+1); unpermute (g",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1228
https://github.com/CliMA/Oceananigans.jl/pull/1228:1254,Testability,test,tested,1254,"rm algorithm we use for the GPU. It only affected wall-bounded dimensions of odd length (see below). Oceananigans was effectively setting the pressure to zero at the topmost grid point (it was actually accessing memory from out-of-bounds but since the bug was pretty consistent I assume it always grabbed some close-to-zero number). I'm shocked that no test picked this up... But looking at our tests, we don't test dimensions of odd length on the GPU. This is probably because in earlier versions of Oceananigans, GPU models only supported dimension lengths that were multiples of 16 (due to hard-coded thread-block layouts). So we probably don't have many, if any, comprehensive GPU tests with odd-sized wall-bounded dimensions. . TODO:; - [x] Add a test that fails due to this bug.; - [x] Confirm that the minimal icy moon setup does not blow up if Nz is even.; - [x] Commit fix. Test should pass and minimal icy moon should not blow up.; - [x] Ensure `divergence_free_poisson_solution` test runs on GPU with odd sizes (currently only even sizes are tested).; - [x] Ensure `poisson_solver_convergence` test runs on the GPU with even and odd sizes (currently it is not tested on the GPU). # Reproduction. ```julia; julia> permute(i, N) = isodd(i) ? floor(Int, i/2) + 1 : N - floor(Int, (i-1)/2); permute (generic function with 1 method). julia> unpermute(i, N) = i <= N/2 ? 2i-1 : 2(N-i+1); unpermute (generic function with 1 method); ```. This works fine for dimensions of even length:. ```julia; julia> N = 4; 4. julia> L = [permute(i, N) for i in 1:N]; 4-element Array{Int64,1}:; 1; 4; 2; 3. julia> [unpermute(i, N) for i in L]; 4-element Array{Int64,1}:; 1; 2; 3; 4; ```. but fails for dimensions of odd length:. ```julia; julia> N = 5; 5. julia> L = [permute(i, N) for i in 1:N]; 5-element Array{Int64,1}:; 1; 5; 2; 4; 3. julia> [unpermute(i, N) for i in L]; 5-element Array{Int64,1}:; 1; 2; 3; 4; 6; ```. # Fix. ```julia; julia> unpermute(i, N) = i <= ceil(N/2) ? 2i-1 : 2(N-i+1); unpermute (g",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1228
https://github.com/CliMA/Oceananigans.jl/pull/1228:1306,Testability,test,test,1306,"vely setting the pressure to zero at the topmost grid point (it was actually accessing memory from out-of-bounds but since the bug was pretty consistent I assume it always grabbed some close-to-zero number). I'm shocked that no test picked this up... But looking at our tests, we don't test dimensions of odd length on the GPU. This is probably because in earlier versions of Oceananigans, GPU models only supported dimension lengths that were multiples of 16 (due to hard-coded thread-block layouts). So we probably don't have many, if any, comprehensive GPU tests with odd-sized wall-bounded dimensions. . TODO:; - [x] Add a test that fails due to this bug.; - [x] Confirm that the minimal icy moon setup does not blow up if Nz is even.; - [x] Commit fix. Test should pass and minimal icy moon should not blow up.; - [x] Ensure `divergence_free_poisson_solution` test runs on GPU with odd sizes (currently only even sizes are tested).; - [x] Ensure `poisson_solver_convergence` test runs on the GPU with even and odd sizes (currently it is not tested on the GPU). # Reproduction. ```julia; julia> permute(i, N) = isodd(i) ? floor(Int, i/2) + 1 : N - floor(Int, (i-1)/2); permute (generic function with 1 method). julia> unpermute(i, N) = i <= N/2 ? 2i-1 : 2(N-i+1); unpermute (generic function with 1 method); ```. This works fine for dimensions of even length:. ```julia; julia> N = 4; 4. julia> L = [permute(i, N) for i in 1:N]; 4-element Array{Int64,1}:; 1; 4; 2; 3. julia> [unpermute(i, N) for i in L]; 4-element Array{Int64,1}:; 1; 2; 3; 4; ```. but fails for dimensions of odd length:. ```julia; julia> N = 5; 5. julia> L = [permute(i, N) for i in 1:N]; 5-element Array{Int64,1}:; 1; 5; 2; 4; 3. julia> [unpermute(i, N) for i in L]; 5-element Array{Int64,1}:; 1; 2; 3; 4; 6; ```. # Fix. ```julia; julia> unpermute(i, N) = i <= ceil(N/2) ? 2i-1 : 2(N-i+1); unpermute (generic function with 1 method); ```. ```julia; julia> N = 5; 5. julia> L = [permute(i, N) for i in 1:N]; 5-element Array{Int6",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1228
https://github.com/CliMA/Oceananigans.jl/pull/1228:1372,Testability,test,tested,1372,"vely setting the pressure to zero at the topmost grid point (it was actually accessing memory from out-of-bounds but since the bug was pretty consistent I assume it always grabbed some close-to-zero number). I'm shocked that no test picked this up... But looking at our tests, we don't test dimensions of odd length on the GPU. This is probably because in earlier versions of Oceananigans, GPU models only supported dimension lengths that were multiples of 16 (due to hard-coded thread-block layouts). So we probably don't have many, if any, comprehensive GPU tests with odd-sized wall-bounded dimensions. . TODO:; - [x] Add a test that fails due to this bug.; - [x] Confirm that the minimal icy moon setup does not blow up if Nz is even.; - [x] Commit fix. Test should pass and minimal icy moon should not blow up.; - [x] Ensure `divergence_free_poisson_solution` test runs on GPU with odd sizes (currently only even sizes are tested).; - [x] Ensure `poisson_solver_convergence` test runs on the GPU with even and odd sizes (currently it is not tested on the GPU). # Reproduction. ```julia; julia> permute(i, N) = isodd(i) ? floor(Int, i/2) + 1 : N - floor(Int, (i-1)/2); permute (generic function with 1 method). julia> unpermute(i, N) = i <= N/2 ? 2i-1 : 2(N-i+1); unpermute (generic function with 1 method); ```. This works fine for dimensions of even length:. ```julia; julia> N = 4; 4. julia> L = [permute(i, N) for i in 1:N]; 4-element Array{Int64,1}:; 1; 4; 2; 3. julia> [unpermute(i, N) for i in L]; 4-element Array{Int64,1}:; 1; 2; 3; 4; ```. but fails for dimensions of odd length:. ```julia; julia> N = 5; 5. julia> L = [permute(i, N) for i in 1:N]; 5-element Array{Int64,1}:; 1; 5; 2; 4; 3. julia> [unpermute(i, N) for i in L]; 5-element Array{Int64,1}:; 1; 2; 3; 4; 6; ```. # Fix. ```julia; julia> unpermute(i, N) = i <= ceil(N/2) ? 2i-1 : 2(N-i+1); unpermute (generic function with 1 method); ```. ```julia; julia> N = 5; 5. julia> L = [permute(i, N) for i in 1:N]; 5-element Array{Int6",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1228
https://github.com/CliMA/Oceananigans.jl/pull/1228:40,Usability,feedback,feedback,40,"Thanks to @leios and @francispoulin for feedback that helped locate the issue!. Resolves #1170 . This PR fixes a bug in how index unpermutation is done as part of the Makhoul (1980) fast cosine transform algorithm we use for the GPU. It only affected wall-bounded dimensions of odd length (see below). Oceananigans was effectively setting the pressure to zero at the topmost grid point (it was actually accessing memory from out-of-bounds but since the bug was pretty consistent I assume it always grabbed some close-to-zero number). I'm shocked that no test picked this up... But looking at our tests, we don't test dimensions of odd length on the GPU. This is probably because in earlier versions of Oceananigans, GPU models only supported dimension lengths that were multiples of 16 (due to hard-coded thread-block layouts). So we probably don't have many, if any, comprehensive GPU tests with odd-sized wall-bounded dimensions. . TODO:; - [x] Add a test that fails due to this bug.; - [x] Confirm that the minimal icy moon setup does not blow up if Nz is even.; - [x] Commit fix. Test should pass and minimal icy moon should not blow up.; - [x] Ensure `divergence_free_poisson_solution` test runs on GPU with odd sizes (currently only even sizes are tested).; - [x] Ensure `poisson_solver_convergence` test runs on the GPU with even and odd sizes (currently it is not tested on the GPU). # Reproduction. ```julia; julia> permute(i, N) = isodd(i) ? floor(Int, i/2) + 1 : N - floor(Int, (i-1)/2); permute (generic function with 1 method). julia> unpermute(i, N) = i <= N/2 ? 2i-1 : 2(N-i+1); unpermute (generic function with 1 method); ```. This works fine for dimensions of even length:. ```julia; julia> N = 4; 4. julia> L = [permute(i, N) for i in 1:N]; 4-element Array{Int64,1}:; 1; 4; 2; 3. julia> [unpermute(i, N) for i in L]; 4-element Array{Int64,1}:; 1; 2; 3; 4; ```. but fails for dimensions of odd length:. ```julia; julia> N = 5; 5. julia> L = [permute(i, N) for i in 1:N]; 5-element Arr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1228
https://github.com/CliMA/Oceananigans.jl/pull/1230:170,Testability,test,tested,170,"This pull request changes the compat entry for the `NCDatasets` package from `0.10` to `0.10, 0.11`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1230
https://github.com/CliMA/Oceananigans.jl/pull/1230:275,Testability,test,tests,275,"This pull request changes the compat entry for the `NCDatasets` package from `0.10` to `0.10, 0.11`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1230
https://github.com/CliMA/Oceananigans.jl/pull/1231:30,Deployability,release,release,30,Probably important to tag and release a new version following #1228.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1231
https://github.com/CliMA/Oceananigans.jl/issues/1232:45,Energy Efficiency,charge,charge,45,"@francispoulin you are correct that a source charge is added to the Poisson RHS to facilitate a solve using eigenfunctions for the homogeneous Neumann problem. The way the source charge is added is very subtle: the source is added by setting the predictor velocity boundary values (typically this means zeroing them out, when the boundary is impermeable):. https://github.com/CliMA/Oceananigans.jl/blob/4011a3431144c3a58671e5d827ab39da8fe6e948/src/Models/IncompressibleModels/pressure_correction.jl#L12. This algorithm is very subtle because one can implement it by simply _not updating the predictor velocities_ on boundaries. Changing the wall-normal values of the predictor velocity field modifies the predictor velocity divergence that contributes to the RHS of the pressure Poisson equation. The reason this is an effective source term is because the predictor velocities _do not_ satisfy the same boundary conditions as the physical velocity field (in particular, the predictor velocities have non-zero wall normal components when there is a pressure gradient on the boundary). Thus zeroing out the wall-normal predictor velocities changes the Poisson equation RHS. With some head scratching, it turns out that the modification is precisely what is needed to describe pressure gradients on the boundary. We need to write this up somewhere, not least because there's no clear reference for this algorithm in the literature. We also would like to generalize the algorithm to work for time-varying wall-normal velocities (a separate issue but worth noting here that the current algorithm does not work for this case). _Originally posted by @glwagner in https://github.com/CliMA/Oceananigans.jl/issues/1170#issuecomment-735421171_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1232
https://github.com/CliMA/Oceananigans.jl/issues/1232:179,Energy Efficiency,charge,charge,179,"@francispoulin you are correct that a source charge is added to the Poisson RHS to facilitate a solve using eigenfunctions for the homogeneous Neumann problem. The way the source charge is added is very subtle: the source is added by setting the predictor velocity boundary values (typically this means zeroing them out, when the boundary is impermeable):. https://github.com/CliMA/Oceananigans.jl/blob/4011a3431144c3a58671e5d827ab39da8fe6e948/src/Models/IncompressibleModels/pressure_correction.jl#L12. This algorithm is very subtle because one can implement it by simply _not updating the predictor velocities_ on boundaries. Changing the wall-normal values of the predictor velocity field modifies the predictor velocity divergence that contributes to the RHS of the pressure Poisson equation. The reason this is an effective source term is because the predictor velocities _do not_ satisfy the same boundary conditions as the physical velocity field (in particular, the predictor velocities have non-zero wall normal components when there is a pressure gradient on the boundary). Thus zeroing out the wall-normal predictor velocities changes the Poisson equation RHS. With some head scratching, it turns out that the modification is precisely what is needed to describe pressure gradients on the boundary. We need to write this up somewhere, not least because there's no clear reference for this algorithm in the literature. We also would like to generalize the algorithm to work for time-varying wall-normal velocities (a separate issue but worth noting here that the current algorithm does not work for this case). _Originally posted by @glwagner in https://github.com/CliMA/Oceananigans.jl/issues/1170#issuecomment-735421171_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1232
https://github.com/CliMA/Oceananigans.jl/issues/1232:246,Safety,predict,predictor,246,"@francispoulin you are correct that a source charge is added to the Poisson RHS to facilitate a solve using eigenfunctions for the homogeneous Neumann problem. The way the source charge is added is very subtle: the source is added by setting the predictor velocity boundary values (typically this means zeroing them out, when the boundary is impermeable):. https://github.com/CliMA/Oceananigans.jl/blob/4011a3431144c3a58671e5d827ab39da8fe6e948/src/Models/IncompressibleModels/pressure_correction.jl#L12. This algorithm is very subtle because one can implement it by simply _not updating the predictor velocities_ on boundaries. Changing the wall-normal values of the predictor velocity field modifies the predictor velocity divergence that contributes to the RHS of the pressure Poisson equation. The reason this is an effective source term is because the predictor velocities _do not_ satisfy the same boundary conditions as the physical velocity field (in particular, the predictor velocities have non-zero wall normal components when there is a pressure gradient on the boundary). Thus zeroing out the wall-normal predictor velocities changes the Poisson equation RHS. With some head scratching, it turns out that the modification is precisely what is needed to describe pressure gradients on the boundary. We need to write this up somewhere, not least because there's no clear reference for this algorithm in the literature. We also would like to generalize the algorithm to work for time-varying wall-normal velocities (a separate issue but worth noting here that the current algorithm does not work for this case). _Originally posted by @glwagner in https://github.com/CliMA/Oceananigans.jl/issues/1170#issuecomment-735421171_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1232
https://github.com/CliMA/Oceananigans.jl/issues/1232:591,Safety,predict,predictor,591,"@francispoulin you are correct that a source charge is added to the Poisson RHS to facilitate a solve using eigenfunctions for the homogeneous Neumann problem. The way the source charge is added is very subtle: the source is added by setting the predictor velocity boundary values (typically this means zeroing them out, when the boundary is impermeable):. https://github.com/CliMA/Oceananigans.jl/blob/4011a3431144c3a58671e5d827ab39da8fe6e948/src/Models/IncompressibleModels/pressure_correction.jl#L12. This algorithm is very subtle because one can implement it by simply _not updating the predictor velocities_ on boundaries. Changing the wall-normal values of the predictor velocity field modifies the predictor velocity divergence that contributes to the RHS of the pressure Poisson equation. The reason this is an effective source term is because the predictor velocities _do not_ satisfy the same boundary conditions as the physical velocity field (in particular, the predictor velocities have non-zero wall normal components when there is a pressure gradient on the boundary). Thus zeroing out the wall-normal predictor velocities changes the Poisson equation RHS. With some head scratching, it turns out that the modification is precisely what is needed to describe pressure gradients on the boundary. We need to write this up somewhere, not least because there's no clear reference for this algorithm in the literature. We also would like to generalize the algorithm to work for time-varying wall-normal velocities (a separate issue but worth noting here that the current algorithm does not work for this case). _Originally posted by @glwagner in https://github.com/CliMA/Oceananigans.jl/issues/1170#issuecomment-735421171_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1232
https://github.com/CliMA/Oceananigans.jl/issues/1232:667,Safety,predict,predictor,667,"@francispoulin you are correct that a source charge is added to the Poisson RHS to facilitate a solve using eigenfunctions for the homogeneous Neumann problem. The way the source charge is added is very subtle: the source is added by setting the predictor velocity boundary values (typically this means zeroing them out, when the boundary is impermeable):. https://github.com/CliMA/Oceananigans.jl/blob/4011a3431144c3a58671e5d827ab39da8fe6e948/src/Models/IncompressibleModels/pressure_correction.jl#L12. This algorithm is very subtle because one can implement it by simply _not updating the predictor velocities_ on boundaries. Changing the wall-normal values of the predictor velocity field modifies the predictor velocity divergence that contributes to the RHS of the pressure Poisson equation. The reason this is an effective source term is because the predictor velocities _do not_ satisfy the same boundary conditions as the physical velocity field (in particular, the predictor velocities have non-zero wall normal components when there is a pressure gradient on the boundary). Thus zeroing out the wall-normal predictor velocities changes the Poisson equation RHS. With some head scratching, it turns out that the modification is precisely what is needed to describe pressure gradients on the boundary. We need to write this up somewhere, not least because there's no clear reference for this algorithm in the literature. We also would like to generalize the algorithm to work for time-varying wall-normal velocities (a separate issue but worth noting here that the current algorithm does not work for this case). _Originally posted by @glwagner in https://github.com/CliMA/Oceananigans.jl/issues/1170#issuecomment-735421171_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1232
https://github.com/CliMA/Oceananigans.jl/issues/1232:705,Safety,predict,predictor,705,"@francispoulin you are correct that a source charge is added to the Poisson RHS to facilitate a solve using eigenfunctions for the homogeneous Neumann problem. The way the source charge is added is very subtle: the source is added by setting the predictor velocity boundary values (typically this means zeroing them out, when the boundary is impermeable):. https://github.com/CliMA/Oceananigans.jl/blob/4011a3431144c3a58671e5d827ab39da8fe6e948/src/Models/IncompressibleModels/pressure_correction.jl#L12. This algorithm is very subtle because one can implement it by simply _not updating the predictor velocities_ on boundaries. Changing the wall-normal values of the predictor velocity field modifies the predictor velocity divergence that contributes to the RHS of the pressure Poisson equation. The reason this is an effective source term is because the predictor velocities _do not_ satisfy the same boundary conditions as the physical velocity field (in particular, the predictor velocities have non-zero wall normal components when there is a pressure gradient on the boundary). Thus zeroing out the wall-normal predictor velocities changes the Poisson equation RHS. With some head scratching, it turns out that the modification is precisely what is needed to describe pressure gradients on the boundary. We need to write this up somewhere, not least because there's no clear reference for this algorithm in the literature. We also would like to generalize the algorithm to work for time-varying wall-normal velocities (a separate issue but worth noting here that the current algorithm does not work for this case). _Originally posted by @glwagner in https://github.com/CliMA/Oceananigans.jl/issues/1170#issuecomment-735421171_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1232
https://github.com/CliMA/Oceananigans.jl/issues/1232:856,Safety,predict,predictor,856,"@francispoulin you are correct that a source charge is added to the Poisson RHS to facilitate a solve using eigenfunctions for the homogeneous Neumann problem. The way the source charge is added is very subtle: the source is added by setting the predictor velocity boundary values (typically this means zeroing them out, when the boundary is impermeable):. https://github.com/CliMA/Oceananigans.jl/blob/4011a3431144c3a58671e5d827ab39da8fe6e948/src/Models/IncompressibleModels/pressure_correction.jl#L12. This algorithm is very subtle because one can implement it by simply _not updating the predictor velocities_ on boundaries. Changing the wall-normal values of the predictor velocity field modifies the predictor velocity divergence that contributes to the RHS of the pressure Poisson equation. The reason this is an effective source term is because the predictor velocities _do not_ satisfy the same boundary conditions as the physical velocity field (in particular, the predictor velocities have non-zero wall normal components when there is a pressure gradient on the boundary). Thus zeroing out the wall-normal predictor velocities changes the Poisson equation RHS. With some head scratching, it turns out that the modification is precisely what is needed to describe pressure gradients on the boundary. We need to write this up somewhere, not least because there's no clear reference for this algorithm in the literature. We also would like to generalize the algorithm to work for time-varying wall-normal velocities (a separate issue but worth noting here that the current algorithm does not work for this case). _Originally posted by @glwagner in https://github.com/CliMA/Oceananigans.jl/issues/1170#issuecomment-735421171_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1232
https://github.com/CliMA/Oceananigans.jl/issues/1232:974,Safety,predict,predictor,974,"@francispoulin you are correct that a source charge is added to the Poisson RHS to facilitate a solve using eigenfunctions for the homogeneous Neumann problem. The way the source charge is added is very subtle: the source is added by setting the predictor velocity boundary values (typically this means zeroing them out, when the boundary is impermeable):. https://github.com/CliMA/Oceananigans.jl/blob/4011a3431144c3a58671e5d827ab39da8fe6e948/src/Models/IncompressibleModels/pressure_correction.jl#L12. This algorithm is very subtle because one can implement it by simply _not updating the predictor velocities_ on boundaries. Changing the wall-normal values of the predictor velocity field modifies the predictor velocity divergence that contributes to the RHS of the pressure Poisson equation. The reason this is an effective source term is because the predictor velocities _do not_ satisfy the same boundary conditions as the physical velocity field (in particular, the predictor velocities have non-zero wall normal components when there is a pressure gradient on the boundary). Thus zeroing out the wall-normal predictor velocities changes the Poisson equation RHS. With some head scratching, it turns out that the modification is precisely what is needed to describe pressure gradients on the boundary. We need to write this up somewhere, not least because there's no clear reference for this algorithm in the literature. We also would like to generalize the algorithm to work for time-varying wall-normal velocities (a separate issue but worth noting here that the current algorithm does not work for this case). _Originally posted by @glwagner in https://github.com/CliMA/Oceananigans.jl/issues/1170#issuecomment-735421171_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1232
https://github.com/CliMA/Oceananigans.jl/issues/1232:1117,Safety,predict,predictor,1117,"@francispoulin you are correct that a source charge is added to the Poisson RHS to facilitate a solve using eigenfunctions for the homogeneous Neumann problem. The way the source charge is added is very subtle: the source is added by setting the predictor velocity boundary values (typically this means zeroing them out, when the boundary is impermeable):. https://github.com/CliMA/Oceananigans.jl/blob/4011a3431144c3a58671e5d827ab39da8fe6e948/src/Models/IncompressibleModels/pressure_correction.jl#L12. This algorithm is very subtle because one can implement it by simply _not updating the predictor velocities_ on boundaries. Changing the wall-normal values of the predictor velocity field modifies the predictor velocity divergence that contributes to the RHS of the pressure Poisson equation. The reason this is an effective source term is because the predictor velocities _do not_ satisfy the same boundary conditions as the physical velocity field (in particular, the predictor velocities have non-zero wall normal components when there is a pressure gradient on the boundary). Thus zeroing out the wall-normal predictor velocities changes the Poisson equation RHS. With some head scratching, it turns out that the modification is precisely what is needed to describe pressure gradients on the boundary. We need to write this up somewhere, not least because there's no clear reference for this algorithm in the literature. We also would like to generalize the algorithm to work for time-varying wall-normal velocities (a separate issue but worth noting here that the current algorithm does not work for this case). _Originally posted by @glwagner in https://github.com/CliMA/Oceananigans.jl/issues/1170#issuecomment-735421171_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1232
https://github.com/CliMA/Oceananigans.jl/issues/1232:566,Usability,simpl,simply,566,"@francispoulin you are correct that a source charge is added to the Poisson RHS to facilitate a solve using eigenfunctions for the homogeneous Neumann problem. The way the source charge is added is very subtle: the source is added by setting the predictor velocity boundary values (typically this means zeroing them out, when the boundary is impermeable):. https://github.com/CliMA/Oceananigans.jl/blob/4011a3431144c3a58671e5d827ab39da8fe6e948/src/Models/IncompressibleModels/pressure_correction.jl#L12. This algorithm is very subtle because one can implement it by simply _not updating the predictor velocities_ on boundaries. Changing the wall-normal values of the predictor velocity field modifies the predictor velocity divergence that contributes to the RHS of the pressure Poisson equation. The reason this is an effective source term is because the predictor velocities _do not_ satisfy the same boundary conditions as the physical velocity field (in particular, the predictor velocities have non-zero wall normal components when there is a pressure gradient on the boundary). Thus zeroing out the wall-normal predictor velocities changes the Poisson equation RHS. With some head scratching, it turns out that the modification is precisely what is needed to describe pressure gradients on the boundary. We need to write this up somewhere, not least because there's no clear reference for this algorithm in the literature. We also would like to generalize the algorithm to work for time-varying wall-normal velocities (a separate issue but worth noting here that the current algorithm does not work for this case). _Originally posted by @glwagner in https://github.com/CliMA/Oceananigans.jl/issues/1170#issuecomment-735421171_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1232
https://github.com/CliMA/Oceananigans.jl/issues/1232:1375,Usability,clear,clear,1375,"@francispoulin you are correct that a source charge is added to the Poisson RHS to facilitate a solve using eigenfunctions for the homogeneous Neumann problem. The way the source charge is added is very subtle: the source is added by setting the predictor velocity boundary values (typically this means zeroing them out, when the boundary is impermeable):. https://github.com/CliMA/Oceananigans.jl/blob/4011a3431144c3a58671e5d827ab39da8fe6e948/src/Models/IncompressibleModels/pressure_correction.jl#L12. This algorithm is very subtle because one can implement it by simply _not updating the predictor velocities_ on boundaries. Changing the wall-normal values of the predictor velocity field modifies the predictor velocity divergence that contributes to the RHS of the pressure Poisson equation. The reason this is an effective source term is because the predictor velocities _do not_ satisfy the same boundary conditions as the physical velocity field (in particular, the predictor velocities have non-zero wall normal components when there is a pressure gradient on the boundary). Thus zeroing out the wall-normal predictor velocities changes the Poisson equation RHS. With some head scratching, it turns out that the modification is precisely what is needed to describe pressure gradients on the boundary. We need to write this up somewhere, not least because there's no clear reference for this algorithm in the literature. We also would like to generalize the algorithm to work for time-varying wall-normal velocities (a separate issue but worth noting here that the current algorithm does not work for this case). _Originally posted by @glwagner in https://github.com/CliMA/Oceananigans.jl/issues/1170#issuecomment-735421171_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1232
https://github.com/CliMA/Oceananigans.jl/issues/1234:55,Deployability,release,release,55,"Kinda feels like we're getting closer to a version 1.0 release, although I don't think we need to put a time frame on it. Is it worth discussing which major development milestones we think should be part of v1.0?. Since we're following [SemVer](https://semver.org/) I guess it's not really about which features we want to see in v1.0 but more about whether we think the user interface will be relatively stable. New features could be introduced in v1.1, v1.2, etc. but if we make any breaking changes we'll have to release v2.0. Maybe it's still useful to list some major milestones as they're quite likely to introduce breaking changes?. I'll start with the three big ones on my mind:; - [x] Pressure solvers for all topologies and grids (#586); - [x] MPI distributed parallelism (#590) [not necessarily super optimized, just something that works okay]; - [x] Vertically stretched grid (#471); - [ ] Abstraction for vectors. It's only for simple grids that we can really get away with referring to the velocity field component wise with `u, v, w`.; - [ ] Specifying `architecture` when building `grid` (#1825).; - [ ] Simplify grids. We really only need one `RectilinearGrid`, one `LatitudeLongitudeGrid`, and one ""arbitrary"" (not aligned with a coordinate system, like what's used for the cubed sphere); - [ ] Finalize spherical implementations; - [ ] Finalize bathymetry. Would be great to hear what people think and if anyone has any thoughts on v1.0. Might also be good to include @whitleyv's immersed boundary implementation and @francispoulin's shallow water model since both might bring some breaking changes as well. PS: Stuff added on 2021-07-23.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1234
https://github.com/CliMA/Oceananigans.jl/issues/1234:515,Deployability,release,release,515,"Kinda feels like we're getting closer to a version 1.0 release, although I don't think we need to put a time frame on it. Is it worth discussing which major development milestones we think should be part of v1.0?. Since we're following [SemVer](https://semver.org/) I guess it's not really about which features we want to see in v1.0 but more about whether we think the user interface will be relatively stable. New features could be introduced in v1.1, v1.2, etc. but if we make any breaking changes we'll have to release v2.0. Maybe it's still useful to list some major milestones as they're quite likely to introduce breaking changes?. I'll start with the three big ones on my mind:; - [x] Pressure solvers for all topologies and grids (#586); - [x] MPI distributed parallelism (#590) [not necessarily super optimized, just something that works okay]; - [x] Vertically stretched grid (#471); - [ ] Abstraction for vectors. It's only for simple grids that we can really get away with referring to the velocity field component wise with `u, v, w`.; - [ ] Specifying `architecture` when building `grid` (#1825).; - [ ] Simplify grids. We really only need one `RectilinearGrid`, one `LatitudeLongitudeGrid`, and one ""arbitrary"" (not aligned with a coordinate system, like what's used for the cubed sphere); - [ ] Finalize spherical implementations; - [ ] Finalize bathymetry. Would be great to hear what people think and if anyone has any thoughts on v1.0. Might also be good to include @whitleyv's immersed boundary implementation and @francispoulin's shallow water model since both might bring some breaking changes as well. PS: Stuff added on 2021-07-23.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1234
https://github.com/CliMA/Oceananigans.jl/issues/1234:375,Integrability,interface,interface,375,"Kinda feels like we're getting closer to a version 1.0 release, although I don't think we need to put a time frame on it. Is it worth discussing which major development milestones we think should be part of v1.0?. Since we're following [SemVer](https://semver.org/) I guess it's not really about which features we want to see in v1.0 but more about whether we think the user interface will be relatively stable. New features could be introduced in v1.1, v1.2, etc. but if we make any breaking changes we'll have to release v2.0. Maybe it's still useful to list some major milestones as they're quite likely to introduce breaking changes?. I'll start with the three big ones on my mind:; - [x] Pressure solvers for all topologies and grids (#586); - [x] MPI distributed parallelism (#590) [not necessarily super optimized, just something that works okay]; - [x] Vertically stretched grid (#471); - [ ] Abstraction for vectors. It's only for simple grids that we can really get away with referring to the velocity field component wise with `u, v, w`.; - [ ] Specifying `architecture` when building `grid` (#1825).; - [ ] Simplify grids. We really only need one `RectilinearGrid`, one `LatitudeLongitudeGrid`, and one ""arbitrary"" (not aligned with a coordinate system, like what's used for the cubed sphere); - [ ] Finalize spherical implementations; - [ ] Finalize bathymetry. Would be great to hear what people think and if anyone has any thoughts on v1.0. Might also be good to include @whitleyv's immersed boundary implementation and @francispoulin's shallow water model since both might bring some breaking changes as well. PS: Stuff added on 2021-07-23.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1234
https://github.com/CliMA/Oceananigans.jl/issues/1234:811,Performance,optimiz,optimized,811,"Kinda feels like we're getting closer to a version 1.0 release, although I don't think we need to put a time frame on it. Is it worth discussing which major development milestones we think should be part of v1.0?. Since we're following [SemVer](https://semver.org/) I guess it's not really about which features we want to see in v1.0 but more about whether we think the user interface will be relatively stable. New features could be introduced in v1.1, v1.2, etc. but if we make any breaking changes we'll have to release v2.0. Maybe it's still useful to list some major milestones as they're quite likely to introduce breaking changes?. I'll start with the three big ones on my mind:; - [x] Pressure solvers for all topologies and grids (#586); - [x] MPI distributed parallelism (#590) [not necessarily super optimized, just something that works okay]; - [x] Vertically stretched grid (#471); - [ ] Abstraction for vectors. It's only for simple grids that we can really get away with referring to the velocity field component wise with `u, v, w`.; - [ ] Specifying `architecture` when building `grid` (#1825).; - [ ] Simplify grids. We really only need one `RectilinearGrid`, one `LatitudeLongitudeGrid`, and one ""arbitrary"" (not aligned with a coordinate system, like what's used for the cubed sphere); - [ ] Finalize spherical implementations; - [ ] Finalize bathymetry. Would be great to hear what people think and if anyone has any thoughts on v1.0. Might also be good to include @whitleyv's immersed boundary implementation and @francispoulin's shallow water model since both might bring some breaking changes as well. PS: Stuff added on 2021-07-23.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1234
https://github.com/CliMA/Oceananigans.jl/issues/1234:940,Usability,simpl,simple,940,"Kinda feels like we're getting closer to a version 1.0 release, although I don't think we need to put a time frame on it. Is it worth discussing which major development milestones we think should be part of v1.0?. Since we're following [SemVer](https://semver.org/) I guess it's not really about which features we want to see in v1.0 but more about whether we think the user interface will be relatively stable. New features could be introduced in v1.1, v1.2, etc. but if we make any breaking changes we'll have to release v2.0. Maybe it's still useful to list some major milestones as they're quite likely to introduce breaking changes?. I'll start with the three big ones on my mind:; - [x] Pressure solvers for all topologies and grids (#586); - [x] MPI distributed parallelism (#590) [not necessarily super optimized, just something that works okay]; - [x] Vertically stretched grid (#471); - [ ] Abstraction for vectors. It's only for simple grids that we can really get away with referring to the velocity field component wise with `u, v, w`.; - [ ] Specifying `architecture` when building `grid` (#1825).; - [ ] Simplify grids. We really only need one `RectilinearGrid`, one `LatitudeLongitudeGrid`, and one ""arbitrary"" (not aligned with a coordinate system, like what's used for the cubed sphere); - [ ] Finalize spherical implementations; - [ ] Finalize bathymetry. Would be great to hear what people think and if anyone has any thoughts on v1.0. Might also be good to include @whitleyv's immersed boundary implementation and @francispoulin's shallow water model since both might bring some breaking changes as well. PS: Stuff added on 2021-07-23.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1234
https://github.com/CliMA/Oceananigans.jl/issues/1234:1119,Usability,Simpl,Simplify,1119,"Kinda feels like we're getting closer to a version 1.0 release, although I don't think we need to put a time frame on it. Is it worth discussing which major development milestones we think should be part of v1.0?. Since we're following [SemVer](https://semver.org/) I guess it's not really about which features we want to see in v1.0 but more about whether we think the user interface will be relatively stable. New features could be introduced in v1.1, v1.2, etc. but if we make any breaking changes we'll have to release v2.0. Maybe it's still useful to list some major milestones as they're quite likely to introduce breaking changes?. I'll start with the three big ones on my mind:; - [x] Pressure solvers for all topologies and grids (#586); - [x] MPI distributed parallelism (#590) [not necessarily super optimized, just something that works okay]; - [x] Vertically stretched grid (#471); - [ ] Abstraction for vectors. It's only for simple grids that we can really get away with referring to the velocity field component wise with `u, v, w`.; - [ ] Specifying `architecture` when building `grid` (#1825).; - [ ] Simplify grids. We really only need one `RectilinearGrid`, one `LatitudeLongitudeGrid`, and one ""arbitrary"" (not aligned with a coordinate system, like what's used for the cubed sphere); - [ ] Finalize spherical implementations; - [ ] Finalize bathymetry. Would be great to hear what people think and if anyone has any thoughts on v1.0. Might also be good to include @whitleyv's immersed boundary implementation and @francispoulin's shallow water model since both might bring some breaking changes as well. PS: Stuff added on 2021-07-23.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1234
https://github.com/CliMA/Oceananigans.jl/pull/1237:171,Testability,test,tested,171,"This pull request changes the compat entry for the `StaticArrays` package from `0.12` to `0.12, 1.0`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1237
https://github.com/CliMA/Oceananigans.jl/pull/1237:276,Testability,test,tests,276,"This pull request changes the compat entry for the `StaticArrays` package from `0.12` to `0.12, 1.0`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1237
https://github.com/CliMA/Oceananigans.jl/pull/1238:153,Energy Efficiency,efficient,efficient,153,"Originally added in PR #592 but removed in #1221, this PR reintroduces the `weno_nth_order.jl` implementation. We should look into making it as fast and efficient as the `weno_fifth_order.jl` before merging. Also this PR adds the cursed SymPy dependency which has caused problems for users in the past (see #990) so would be nice to get rid of it somehow. X-Ref: #995",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1238
https://github.com/CliMA/Oceananigans.jl/pull/1238:243,Integrability,depend,dependency,243,"Originally added in PR #592 but removed in #1221, this PR reintroduces the `weno_nth_order.jl` implementation. We should look into making it as fast and efficient as the `weno_fifth_order.jl` before merging. Also this PR adds the cursed SymPy dependency which has caused problems for users in the past (see #990) so would be nice to get rid of it somehow. X-Ref: #995",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1238
https://github.com/CliMA/Oceananigans.jl/issues/1241:880,Availability,error,error,880,"I have the following output writer set-up in my simulation:. ```julia; import Oceananigans.Fields: ComputedField; u, v, w = model.velocities.u, model.velocities.v, model.velocities.w; b, pHY′, pNHS = model.tracers.b, model.pressures.pHY′, model.pressures.pNHS; ν, νₑ = model.closure.ν, model.diffusivities.νₑ; #-----. #-----; import Oceananigans.AbstractOperations: ∂x, ∂y, ∂z. ddx = ∂x(u)^2 + ∂x(v)^2 + ∂x(w)^2; ddy = ∂y(u)^2 + ∂y(v)^2 + ∂y(w)^2; ddz = ∂z(u)^2 + ∂z(v)^2 + ∂z(w)^2; #avg_ε = AveragedField(ComputedField(ddx + ddy + ddz), dims=(1,)); avg_ε = AveragedField(ν*(ddx + ddy + ddz), dims=(1,)). outputs = (ε = avg_ε,); simulation.output_writers[:avg_field_writer] =; NetCDFOutputWriter(model, outputs,; filepath = ""avg.jd15_3dbounded.nc"",; schedule = TimeInterval(2minutes),; mode = ""c""); ```. This works successfully on CPUs, but running on GPUs I get a huge amount of error lines with some . ```; [16] compute! at /glade/u/home/tomasc/.julia/packages/Oceananigans/6JcUu/src/Fields/averaged_field.jl:86 [inlined]; ```. Running the simulation without that output works for both GPUs and CPUs. Am I doing something wrong here?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241
https://github.com/CliMA/Oceananigans.jl/issues/1241:750,Energy Efficiency,schedul,schedule,750,"I have the following output writer set-up in my simulation:. ```julia; import Oceananigans.Fields: ComputedField; u, v, w = model.velocities.u, model.velocities.v, model.velocities.w; b, pHY′, pNHS = model.tracers.b, model.pressures.pHY′, model.pressures.pNHS; ν, νₑ = model.closure.ν, model.diffusivities.νₑ; #-----. #-----; import Oceananigans.AbstractOperations: ∂x, ∂y, ∂z. ddx = ∂x(u)^2 + ∂x(v)^2 + ∂x(w)^2; ddy = ∂y(u)^2 + ∂y(v)^2 + ∂y(w)^2; ddz = ∂z(u)^2 + ∂z(v)^2 + ∂z(w)^2; #avg_ε = AveragedField(ComputedField(ddx + ddy + ddz), dims=(1,)); avg_ε = AveragedField(ν*(ddx + ddy + ddz), dims=(1,)). outputs = (ε = avg_ε,); simulation.output_writers[:avg_field_writer] =; NetCDFOutputWriter(model, outputs,; filepath = ""avg.jd15_3dbounded.nc"",; schedule = TimeInterval(2minutes),; mode = ""c""); ```. This works successfully on CPUs, but running on GPUs I get a huge amount of error lines with some . ```; [16] compute! at /glade/u/home/tomasc/.julia/packages/Oceananigans/6JcUu/src/Fields/averaged_field.jl:86 [inlined]; ```. Running the simulation without that output works for both GPUs and CPUs. Am I doing something wrong here?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241
https://github.com/CliMA/Oceananigans.jl/pull/1242:865,Modifiability,refactor,refactor,865,"This PR adds experimental support for rotating/tilting the gravity vector. I'm not even sure if it works properly but I'm opening a draft PR as it might be ready to be experimented with? I don't think we can have a non-zero gravity component along a periodic direction as the fluid just free falls along that dimension and the model blows up. But here's a thermal bubble rising with gravity tilted at 45 degrees. ![tilted_gravity_plume](https://user-images.githubusercontent.com/20099589/100940093-5ab5d600-34c5-11eb-918e-f574f284f024.gif). This is an experimental feature since it needs more rigorous testing and because full support for tilted gravity may require more work, e.g.; 1. Should AMD use `z_dot_g_b` now?; 2. Should `∂x_b` return a vector or should it be split up into `x_dot_∂x_b`, etc.? The Leith closure uses `∂x_b`.; 3. We may want to clean up and refactor the implementation, taking some suggestions from #1151. cc @tomchor . Resolves #1151",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242
https://github.com/CliMA/Oceananigans.jl/pull/1242:602,Testability,test,testing,602,"This PR adds experimental support for rotating/tilting the gravity vector. I'm not even sure if it works properly but I'm opening a draft PR as it might be ready to be experimented with? I don't think we can have a non-zero gravity component along a periodic direction as the fluid just free falls along that dimension and the model blows up. But here's a thermal bubble rising with gravity tilted at 45 degrees. ![tilted_gravity_plume](https://user-images.githubusercontent.com/20099589/100940093-5ab5d600-34c5-11eb-918e-f574f284f024.gif). This is an experimental feature since it needs more rigorous testing and because full support for tilted gravity may require more work, e.g.; 1. Should AMD use `z_dot_g_b` now?; 2. Should `∂x_b` return a vector or should it be split up into `x_dot_∂x_b`, etc.? The Leith closure uses `∂x_b`.; 3. We may want to clean up and refactor the implementation, taking some suggestions from #1151. cc @tomchor . Resolves #1151",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242
https://github.com/CliMA/Oceananigans.jl/pull/1243:37,Integrability,depend,depends,37,This PR adds a new example . This PR depends on #1091,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1243
https://github.com/CliMA/Oceananigans.jl/pull/1244:976,Integrability,depend,depends,976,"This PR adds a new example called ""Microbial rock paper scissors"" in which an idealized diurnal cycle is simulated with an agent-based model of marine microbes as Lagrangian particles playing rock paper scissors. This example is loosely based off of https://github.com/ali-ramadhan/lagrangian-microbes and can be extended to to study competition between marine microbes in an idealized setting. The purposes of this example are to show users how to:; 1. use Lagrangian particle tracking.; 2. define their own custom particle types.; 3. implement interacting particle pairs using KD trees.; 4. write fields and particles to NetCDF.; 5. easily read, analyze, and plot data from NetCDF using GeoData.jl. This example has aided me in figuring out which abstractions are needed for particle tracking in #1091 and are helping me figure out which plotting recipes would be good to implement as part of https://github.com/rafaqz/GeoData.jl/pull/106. This PR in a work-in-progress and depends on #1091. I still need to make it Literate. The example also produces a neat animation of particles being advected (too big to include as a gif) and I'm hoping to expand the data analysis a bit. ![image](https://user-images.githubusercontent.com/20099589/101072675-614b5880-356c-11eb-8537-44e21fa3e8ff.png). ![species_count](https://user-images.githubusercontent.com/20099589/101072466-14678200-356c-11eb-9c36-8c0eda8c3c36.png). # Plotting with GeoData.jl. I think reading data with JLD2 and plotting it can be cumbersome (and makes the examples more complicated than they should be in my opinion). I think once GeoData.jl is a bit more mature I think we should encourage users to use it as it simplifies data analysis and plotting greatly. For example, plotting w and b looks something like (could still be improved of course, contourf might be better). ```julia; anim = @animate for n in 1:Nt; @info ""Plotting idealized diurnal cycle frame $n/$Nt..."". w_plot = plot(w[Ti=n, xC=32], color=:balance, clims=(-0.02, 0.0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1244
https://github.com/CliMA/Oceananigans.jl/pull/1244:313,Modifiability,extend,extended,313,"This PR adds a new example called ""Microbial rock paper scissors"" in which an idealized diurnal cycle is simulated with an agent-based model of marine microbes as Lagrangian particles playing rock paper scissors. This example is loosely based off of https://github.com/ali-ramadhan/lagrangian-microbes and can be extended to to study competition between marine microbes in an idealized setting. The purposes of this example are to show users how to:; 1. use Lagrangian particle tracking.; 2. define their own custom particle types.; 3. implement interacting particle pairs using KD trees.; 4. write fields and particles to NetCDF.; 5. easily read, analyze, and plot data from NetCDF using GeoData.jl. This example has aided me in figuring out which abstractions are needed for particle tracking in #1091 and are helping me figure out which plotting recipes would be good to implement as part of https://github.com/rafaqz/GeoData.jl/pull/106. This PR in a work-in-progress and depends on #1091. I still need to make it Literate. The example also produces a neat animation of particles being advected (too big to include as a gif) and I'm hoping to expand the data analysis a bit. ![image](https://user-images.githubusercontent.com/20099589/101072675-614b5880-356c-11eb-8537-44e21fa3e8ff.png). ![species_count](https://user-images.githubusercontent.com/20099589/101072466-14678200-356c-11eb-9c36-8c0eda8c3c36.png). # Plotting with GeoData.jl. I think reading data with JLD2 and plotting it can be cumbersome (and makes the examples more complicated than they should be in my opinion). I think once GeoData.jl is a bit more mature I think we should encourage users to use it as it simplifies data analysis and plotting greatly. For example, plotting w and b looks something like (could still be improved of course, contourf might be better). ```julia; anim = @animate for n in 1:Nt; @info ""Plotting idealized diurnal cycle frame $n/$Nt..."". w_plot = plot(w[Ti=n, xC=32], color=:balance, clims=(-0.02, 0.0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1244
https://github.com/CliMA/Oceananigans.jl/pull/1244:1678,Usability,simpl,simplifies,1678,"e microbes in an idealized setting. The purposes of this example are to show users how to:; 1. use Lagrangian particle tracking.; 2. define their own custom particle types.; 3. implement interacting particle pairs using KD trees.; 4. write fields and particles to NetCDF.; 5. easily read, analyze, and plot data from NetCDF using GeoData.jl. This example has aided me in figuring out which abstractions are needed for particle tracking in #1091 and are helping me figure out which plotting recipes would be good to implement as part of https://github.com/rafaqz/GeoData.jl/pull/106. This PR in a work-in-progress and depends on #1091. I still need to make it Literate. The example also produces a neat animation of particles being advected (too big to include as a gif) and I'm hoping to expand the data analysis a bit. ![image](https://user-images.githubusercontent.com/20099589/101072675-614b5880-356c-11eb-8537-44e21fa3e8ff.png). ![species_count](https://user-images.githubusercontent.com/20099589/101072466-14678200-356c-11eb-9c36-8c0eda8c3c36.png). # Plotting with GeoData.jl. I think reading data with JLD2 and plotting it can be cumbersome (and makes the examples more complicated than they should be in my opinion). I think once GeoData.jl is a bit more mature I think we should encourage users to use it as it simplifies data analysis and plotting greatly. For example, plotting w and b looks something like (could still be improved of course, contourf might be better). ```julia; anim = @animate for n in 1:Nt; @info ""Plotting idealized diurnal cycle frame $n/$Nt..."". w_plot = plot(w[Ti=n, xC=32], color=:balance, clims=(-0.02, 0.02), aspect_ratio=:auto,; title=""Idealized diurnal cycle: $(prettytime(times[n]))""). b_plot = plot(b[Ti=n, xC=32], color=:thermal, clims=(-5e-4, 4e-4), aspect_ratio=:auto, title=""""). plot(w_plot, b_plot, layout=(2, 1), size=(1600, 900)); end; ```. ![image](https://user-images.githubusercontent.com/20099589/101071345-79ba7380-356a-11eb-9670-463298f7de47.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1244
https://github.com/CliMA/Oceananigans.jl/issues/1245:1582,Integrability,depend,depends,1582,"There are a few applications that require building fields before `IncompressibleModel`, in order to form `AbstractOperations` and `ComputedFields` that need be computed during a model time step (eg PR #1091). I think this use case will only become more and more important in the future. Currently this functionality is possible but plagued by a huge useability issue: the default `grid` has a halo size of 1, while most applications benefit from higher-order advection schemes. To hide the need to specify halo region sizes from users, we currently ""inflate"" halos inside the constructor for `IncompressibleModel`:. https://github.com/CliMA/Oceananigans.jl/blob/5ddace160c2b8c4469d49f6b35c1c748879a0c17/src/Models/IncompressibleModels/incompressible_model.jl#L111-L112. This means that users who want to build fields before `IncompressibleModel` do, in fact, have to know the halo size they need to specify for their chosen advection scheme. This isn't well-documented right now... Somehow, we have to figure out how to smooth this whole process out. One huge help will simply be to choose a default advection scheme that is useful for science: either `UpwindBiasedFifthOrder` or `WENO5`, and to set the default halo size for the grid to 5. Having these default will mitigate the problem greatly I think. But we also probably need utilities (or documentation at the very least) that explains this issue and how to choose the halo size if one needed to build the grid outside the model. Or, perhaps there are even better solutions to this issue. Basically the point is that the grid depends ""circularly"" on aspects of `IncompressibleModel`, which becomes an issue when things like `VelocityFields` (which also depend on the grid) need to be constructed prior to `IncompressibleModel`. We don't want users to have to replicate the `IncompressibleModel` constructor in their scripts...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1245
https://github.com/CliMA/Oceananigans.jl/issues/1245:1709,Integrability,depend,depend,1709,"There are a few applications that require building fields before `IncompressibleModel`, in order to form `AbstractOperations` and `ComputedFields` that need be computed during a model time step (eg PR #1091). I think this use case will only become more and more important in the future. Currently this functionality is possible but plagued by a huge useability issue: the default `grid` has a halo size of 1, while most applications benefit from higher-order advection schemes. To hide the need to specify halo region sizes from users, we currently ""inflate"" halos inside the constructor for `IncompressibleModel`:. https://github.com/CliMA/Oceananigans.jl/blob/5ddace160c2b8c4469d49f6b35c1c748879a0c17/src/Models/IncompressibleModels/incompressible_model.jl#L111-L112. This means that users who want to build fields before `IncompressibleModel` do, in fact, have to know the halo size they need to specify for their chosen advection scheme. This isn't well-documented right now... Somehow, we have to figure out how to smooth this whole process out. One huge help will simply be to choose a default advection scheme that is useful for science: either `UpwindBiasedFifthOrder` or `WENO5`, and to set the default halo size for the grid to 5. Having these default will mitigate the problem greatly I think. But we also probably need utilities (or documentation at the very least) that explains this issue and how to choose the halo size if one needed to build the grid outside the model. Or, perhaps there are even better solutions to this issue. Basically the point is that the grid depends ""circularly"" on aspects of `IncompressibleModel`, which becomes an issue when things like `VelocityFields` (which also depend on the grid) need to be constructed prior to `IncompressibleModel`. We don't want users to have to replicate the `IncompressibleModel` constructor in their scripts...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1245
https://github.com/CliMA/Oceananigans.jl/issues/1245:1070,Usability,simpl,simply,1070,"There are a few applications that require building fields before `IncompressibleModel`, in order to form `AbstractOperations` and `ComputedFields` that need be computed during a model time step (eg PR #1091). I think this use case will only become more and more important in the future. Currently this functionality is possible but plagued by a huge useability issue: the default `grid` has a halo size of 1, while most applications benefit from higher-order advection schemes. To hide the need to specify halo region sizes from users, we currently ""inflate"" halos inside the constructor for `IncompressibleModel`:. https://github.com/CliMA/Oceananigans.jl/blob/5ddace160c2b8c4469d49f6b35c1c748879a0c17/src/Models/IncompressibleModels/incompressible_model.jl#L111-L112. This means that users who want to build fields before `IncompressibleModel` do, in fact, have to know the halo size they need to specify for their chosen advection scheme. This isn't well-documented right now... Somehow, we have to figure out how to smooth this whole process out. One huge help will simply be to choose a default advection scheme that is useful for science: either `UpwindBiasedFifthOrder` or `WENO5`, and to set the default halo size for the grid to 5. Having these default will mitigate the problem greatly I think. But we also probably need utilities (or documentation at the very least) that explains this issue and how to choose the halo size if one needed to build the grid outside the model. Or, perhaps there are even better solutions to this issue. Basically the point is that the grid depends ""circularly"" on aspects of `IncompressibleModel`, which becomes an issue when things like `VelocityFields` (which also depend on the grid) need to be constructed prior to `IncompressibleModel`. We don't want users to have to replicate the `IncompressibleModel` constructor in their scripts...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1245
https://github.com/CliMA/Oceananigans.jl/issues/1246:143,Usability,clear,clear,143,"In a perfect world one would be able to use `AbstractOperations` for all output needs. But alas, there is #1241. The discussion on #1234 makes clear that this will continue to be a serious issue. There may also be output that cannot be expressed as an abstract operation. One work around for advanced users (which may be nice to have anyways) is to design an abstraction for `KernelComputedField`s that are computed based on a user-supplied kernel. I think usage could be something like (using [`ViscousDissipation`](https://github.com/CliMA/LESbrary.jl/blob/master/src/TurbulenceStatistics/viscous_dissipation.jl) as an example). ```julia; model = IncompressibleModel(...). @kernel function compute_viscous_dissipation!(ϵ, grid, clock, νₑ, u, v, w); i, j, k = @index(Global, NTuple). Σˣˣ = ∂xᶜᵃᵃ(i, j, k, grid, u); Σʸʸ = ∂yᵃᶜᵃ(i, j, k, grid, v); Σᶻᶻ = ∂zᵃᵃᶜ(i, j, k, grid, w). Σˣʸ = (ℑxyᶜᶜᵃ(i, j, k, grid, ∂yᵃᶠᵃ, u) + ℑxyᶜᶜᵃ(i, j, k, grid, ∂xᶠᵃᵃ, v)) / 2; Σˣᶻ = (ℑxzᶜᵃᶜ(i, j, k, grid, ∂zᵃᵃᶠ, u) + ℑxzᶜᵃᶜ(i, j, k, grid, ∂xᶠᵃᵃ, w)) / 2; Σʸᶻ = (ℑyzᵃᶜᶜ(i, j, k, grid, ∂zᵃᵃᶠ, v) + ℑyzᵃᶜᶜ(i, j, k, grid, ∂yᵃᶠᵃ, w)) / 2. @inbounds ϵ[i, j, k] = νₑ[i, j, k] * 2 * (Σˣˣ^2 + Σʸʸ^2 + Σᶻᶻ^2 + Σˣʸ^2 + Σˣᶻ^2 + Σʸᶻ^2); end. νₑ = model.diffusivities.νₑ; u, v, w = model.velocities. viscous_dissipation = KernelComputedField(Cell, Cell, Cell, model, compute_viscous_dissipation;; field_dependencies=(νₑ, u, v, w)); ```. In this example `viscous_dissipation` is then a bonafide field with a fully-fledged `compute!` function that can be used in output, time-averaging, in an `AveragedField`, etc. Users will need to write a kernel with `KernelAbstractions` language (which we'll have to document and provide examples for), but they won't have to write all the other boilerplate that goes into defining the struct and writing a `compute!` function (see again [`ViscousDissipation`](https://github.com/CliMA/LESbrary.jl/blob/master/src/TurbulenceStatistics/viscous_dissipation.jl) to get an idea of what this boiler plat",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1246
https://github.com/CliMA/Oceananigans.jl/issues/1247:222,Availability,failure,failures,222,Seems that examples are NaNing out while building documentation since PR #1198 was merged even though everything was fine for the latest Buildkite build on that PR: https://buildkite.com/clima/oceananigans/builds/649. Two failures on the same commit so it's a consistent issue:; https://buildkite.com/clima/oceananigans/builds/824; https://buildkite.com/clima/oceananigans/builds/830. I was able to reproduce locally as well. Thankfully this is just master as PR #1198 was not part of v0.45.0. Not sure how that happened but if this issue can't be fixed soon we should revert #1198.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1247
https://github.com/CliMA/Oceananigans.jl/issues/1249:25,Availability,checkpoint,checkpointing,25,"In some scripts manually checkpointing, e.g. at the end, is useful so having a `checkpoint(simulation)` function would be nice.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1249
https://github.com/CliMA/Oceananigans.jl/issues/1249:80,Availability,checkpoint,checkpoint,80,"In some scripts manually checkpointing, e.g. at the end, is useful so having a `checkpoint(simulation)` function would be nice.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1249
https://github.com/CliMA/Oceananigans.jl/issues/1250:211,Usability,feedback,feedback,211,Right now the callback/progress function is only called for the first time when `iteration = iteration_interval` but I think we actually want to run the progress function at iteration 0 as it helps provide more feedback to the user at a time of heavy compilation. This would help with #1013 and having output at iteration 0 tells the user that the simulation is starting to time step. Sometimes when the terminal is blank for a while I'm not sure if Julia is still compiling or if I accidentally created a huge CPU model that's taking forever to take each time step.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1250
https://github.com/CliMA/Oceananigans.jl/issues/1254:69,Integrability,depend,depends,69,"This is because the right-hand-side of the pressure Poisson equation depends on 1/Δt so Δt=0 leads to an `Inf` source term:. https://github.com/CliMA/Oceananigans.jl/blob/c3b688f9ef125faeac3aa9d7fd57f0dd2d392380/src/Solvers/solve_for_pressure.jl#L41. This wasn't an issue before since we never `time_step!(model, 0)` but now that the time step is aligned with output writing and simulation stop times, it's possible to end up calling `time_step!(model, 0)`:. https://github.com/CliMA/Oceananigans.jl/blob/c3b688f9ef125faeac3aa9d7fd57f0dd2d392380/src/Simulations/run.jl#L159-L161. Not sure of the best solution to this but one possible solution is if calling `time_step!(model, 0)` causes it to return early without doing anything. I added the ""high priority"" label to this issue since it can cause the output to contain `NaN` at the last time step, very undesirable for users.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1254
https://github.com/CliMA/Oceananigans.jl/pull/1257:20,Testability,test,tests,20,Shallow water model tests are failing on master because `model.velocities.u` does not exist for `ShallowWaterModel`. This PR fixes this by checking for NaNs in the model's first field.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1257
https://github.com/CliMA/Oceananigans.jl/pull/1259:40,Testability,test,tests,40,Resolves #1027; Resolves #1252. ~~Needs tests.~~,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1259
https://github.com/CliMA/Oceananigans.jl/pull/1260:17,Testability,test,tests,17,Need to add some tests before merging though. cc @tomchor,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1260
https://github.com/CliMA/Oceananigans.jl/issues/1262:419,Testability,test,tests,419,"Not sure if the bug label is appropriate here but `ShallowWaterModel` is instantiated with uh = vh = h = 0 and the tendencies have 1/h terms in them so time stepping this ""empty"" shallow water model leads to blow up. This is generally fine: if you time-step a nonsensical model it should blow up. The issue is that we add a NaN checker by default (which will still be there in #1138) so the shallow water time stepping tests keep triggering the NaN checker and failing. Should we just disable NaN checking for these tests by removing the NaN checker via `delete!(simulation.diagnostics, :nan_checker)`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1262
https://github.com/CliMA/Oceananigans.jl/issues/1262:516,Testability,test,tests,516,"Not sure if the bug label is appropriate here but `ShallowWaterModel` is instantiated with uh = vh = h = 0 and the tendencies have 1/h terms in them so time stepping this ""empty"" shallow water model leads to blow up. This is generally fine: if you time-step a nonsensical model it should blow up. The issue is that we add a NaN checker by default (which will still be there in #1138) so the shallow water time stepping tests keep triggering the NaN checker and failing. Should we just disable NaN checking for these tests by removing the NaN checker via `delete!(simulation.diagnostics, :nan_checker)`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1262
https://github.com/CliMA/Oceananigans.jl/issues/1263:30,Testability,test,tests,30,"Right now Buildkite only runs tests on the PR branch (pushes). Might be worth looking into whether Buildkite can also run pull request tests, i.e. merge the branch into master then run the tests. This would help catch issues like #1262.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1263
https://github.com/CliMA/Oceananigans.jl/issues/1263:135,Testability,test,tests,135,"Right now Buildkite only runs tests on the PR branch (pushes). Might be worth looking into whether Buildkite can also run pull request tests, i.e. merge the branch into master then run the tests. This would help catch issues like #1262.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1263
https://github.com/CliMA/Oceananigans.jl/issues/1263:189,Testability,test,tests,189,"Right now Buildkite only runs tests on the PR branch (pushes). Might be worth looking into whether Buildkite can also run pull request tests, i.e. merge the branch into master then run the tests. This would help catch issues like #1262.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1263
https://github.com/CliMA/Oceananigans.jl/issues/1265:409,Usability,simpl,simply,409,"At the moment, `derivative_operators.jl` defines second order center differencing, which is great. For ShallowWaterModel, I am splitting up the advection terms and the pressure. For advection I plan to use WENO5 and would similarly like a 4th order center differencing scheme for pressure. . The stencil for 4th order derivatives is `[-2, 16, -16, 2]/16`. . Based on that, I think a 4th oder derivative could simply be . ```@inline ∂xᶠᵃᵃ(i, j, k, grid, f::F, args...) where F<:Function = ( -2 f(i+1, j, k, grid, args...) + 16 f(i, j, k, grid, args...) - 16 f(i-1, j, k, grid, args...) + 2 f(i-2, j, k, grid, args...)) / (12 Δx(i, j, k, grid))```. My initial ideal was to add a sub or superscript 4 somewhere to denote the fact that this was 4th order. @ali mentioned that maybe we might want to dispatch based on the order. What do people think is the best way moving forward?. I don't think I would ever go higher than 4th since that makes for a much bigger stencil but if people wanted to, this could be done I suppose.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265
https://github.com/CliMA/Oceananigans.jl/pull/1270:66,Testability,test,test,66,Collaboration with @francispoulin. Todo:. - [x] Add time-stepping test with `advection=nothing` in `IncompressibleModel`; - [x] Add time-stepping test with `advection=nothing` in `ShallowWaterModel`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1270
https://github.com/CliMA/Oceananigans.jl/pull/1270:146,Testability,test,test,146,Collaboration with @francispoulin. Todo:. - [x] Add time-stepping test with `advection=nothing` in `IncompressibleModel`; - [x] Add time-stepping test with `advection=nothing` in `ShallowWaterModel`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1270
https://github.com/CliMA/Oceananigans.jl/issues/1271:350,Availability,ERROR,ERROR,350,"I just tried running `validation/periodic_advection.jl` and see that it can't find WENO, which is I think because we removed the N-th order WENO code. Is it better to change it to WENO5 for the moment, since that's what we have?. ```; julia> include(""periodic_advection.jl""); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: UndefVarError: WENO not defined; Stacktrace:; [1] top-level scope at /home/fpoulin/software/Oceananigans.jl/validation/periodic_advection/periodic_advection.jl:55; [2] include(::String) at ./client.jl:457; [3] top-level scope at REPL[1]:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/periodic_advection/periodic_advection.jl:55; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1271
https://github.com/CliMA/Oceananigans.jl/issues/1271:357,Performance,Load,LoadError,357,"I just tried running `validation/periodic_advection.jl` and see that it can't find WENO, which is I think because we removed the N-th order WENO code. Is it better to change it to WENO5 for the moment, since that's what we have?. ```; julia> include(""periodic_advection.jl""); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: UndefVarError: WENO not defined; Stacktrace:; [1] top-level scope at /home/fpoulin/software/Oceananigans.jl/validation/periodic_advection/periodic_advection.jl:55; [2] include(::String) at ./client.jl:457; [3] top-level scope at REPL[1]:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/periodic_advection/periodic_advection.jl:55; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1271
https://github.com/CliMA/Oceananigans.jl/issues/1271:22,Security,validat,validation,22,"I just tried running `validation/periodic_advection.jl` and see that it can't find WENO, which is I think because we removed the N-th order WENO code. Is it better to change it to WENO5 for the moment, since that's what we have?. ```; julia> include(""periodic_advection.jl""); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: UndefVarError: WENO not defined; Stacktrace:; [1] top-level scope at /home/fpoulin/software/Oceananigans.jl/validation/periodic_advection/periodic_advection.jl:55; [2] include(::String) at ./client.jl:457; [3] top-level scope at REPL[1]:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/periodic_advection/periodic_advection.jl:55; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1271
https://github.com/CliMA/Oceananigans.jl/issues/1271:476,Security,validat,validation,476,"I just tried running `validation/periodic_advection.jl` and see that it can't find WENO, which is I think because we removed the N-th order WENO code. Is it better to change it to WENO5 for the moment, since that's what we have?. ```; julia> include(""periodic_advection.jl""); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: UndefVarError: WENO not defined; Stacktrace:; [1] top-level scope at /home/fpoulin/software/Oceananigans.jl/validation/periodic_advection/periodic_advection.jl:55; [2] include(::String) at ./client.jl:457; [3] top-level scope at REPL[1]:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/periodic_advection/periodic_advection.jl:55; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1271
https://github.com/CliMA/Oceananigans.jl/issues/1271:673,Security,validat,validation,673,"I just tried running `validation/periodic_advection.jl` and see that it can't find WENO, which is I think because we removed the N-th order WENO code. Is it better to change it to WENO5 for the moment, since that's what we have?. ```; julia> include(""periodic_advection.jl""); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: UndefVarError: WENO not defined; Stacktrace:; [1] top-level scope at /home/fpoulin/software/Oceananigans.jl/validation/periodic_advection/periodic_advection.jl:55; [2] include(::String) at ./client.jl:457; [3] top-level scope at REPL[1]:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/periodic_advection/periodic_advection.jl:55; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1271
https://github.com/CliMA/Oceananigans.jl/issues/1272:275,Availability,failure,failures,275,"This set of tests also fails at least in part because of the lack of high order WENO as in #1271 , but the plots seem to use PyPlot and I ended up just getting a bunch of blank plots. I presume we wanted to update the plotting to use something else?. But I think some of the failures are that the orders do not match the theory close enough. ```; Test Summary: | Pass Fail Total; tmp | 86 9 95; ERROR: LoadError: Some tests did not pass: 86 passed, 9 failed, 0 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_advection_schemes.jl:69; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272
https://github.com/CliMA/Oceananigans.jl/issues/1272:395,Availability,ERROR,ERROR,395,"This set of tests also fails at least in part because of the lack of high order WENO as in #1271 , but the plots seem to use PyPlot and I ended up just getting a bunch of blank plots. I presume we wanted to update the plotting to use something else?. But I think some of the failures are that the orders do not match the theory close enough. ```; Test Summary: | Pass Fail Total; tmp | 86 9 95; ERROR: LoadError: Some tests did not pass: 86 passed, 9 failed, 0 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_advection_schemes.jl:69; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272
https://github.com/CliMA/Oceananigans.jl/issues/1272:461,Availability,error,errored,461,"This set of tests also fails at least in part because of the lack of high order WENO as in #1271 , but the plots seem to use PyPlot and I ended up just getting a bunch of blank plots. I presume we wanted to update the plotting to use something else?. But I think some of the failures are that the orders do not match the theory close enough. ```; Test Summary: | Pass Fail Total; tmp | 86 9 95; ERROR: LoadError: Some tests did not pass: 86 passed, 9 failed, 0 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_advection_schemes.jl:69; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272
https://github.com/CliMA/Oceananigans.jl/issues/1272:207,Deployability,update,update,207,"This set of tests also fails at least in part because of the lack of high order WENO as in #1271 , but the plots seem to use PyPlot and I ended up just getting a bunch of blank plots. I presume we wanted to update the plotting to use something else?. But I think some of the failures are that the orders do not match the theory close enough. ```; Test Summary: | Pass Fail Total; tmp | 86 9 95; ERROR: LoadError: Some tests did not pass: 86 passed, 9 failed, 0 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_advection_schemes.jl:69; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272
https://github.com/CliMA/Oceananigans.jl/issues/1272:402,Performance,Load,LoadError,402,"This set of tests also fails at least in part because of the lack of high order WENO as in #1271 , but the plots seem to use PyPlot and I ended up just getting a bunch of blank plots. I presume we wanted to update the plotting to use something else?. But I think some of the failures are that the orders do not match the theory close enough. ```; Test Summary: | Pass Fail Total; tmp | 86 9 95; ERROR: LoadError: Some tests did not pass: 86 passed, 9 failed, 0 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_advection_schemes.jl:69; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272
https://github.com/CliMA/Oceananigans.jl/issues/1272:546,Security,validat,validation,546,"This set of tests also fails at least in part because of the lack of high order WENO as in #1271 , but the plots seem to use PyPlot and I ended up just getting a bunch of blank plots. I presume we wanted to update the plotting to use something else?. But I think some of the failures are that the orders do not match the theory close enough. ```; Test Summary: | Pass Fail Total; tmp | 86 9 95; ERROR: LoadError: Some tests did not pass: 86 passed, 9 failed, 0 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_advection_schemes.jl:69; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272
https://github.com/CliMA/Oceananigans.jl/issues/1272:12,Testability,test,tests,12,"This set of tests also fails at least in part because of the lack of high order WENO as in #1271 , but the plots seem to use PyPlot and I ended up just getting a bunch of blank plots. I presume we wanted to update the plotting to use something else?. But I think some of the failures are that the orders do not match the theory close enough. ```; Test Summary: | Pass Fail Total; tmp | 86 9 95; ERROR: LoadError: Some tests did not pass: 86 passed, 9 failed, 0 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_advection_schemes.jl:69; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272
https://github.com/CliMA/Oceananigans.jl/issues/1272:347,Testability,Test,Test,347,"This set of tests also fails at least in part because of the lack of high order WENO as in #1271 , but the plots seem to use PyPlot and I ended up just getting a bunch of blank plots. I presume we wanted to update the plotting to use something else?. But I think some of the failures are that the orders do not match the theory close enough. ```; Test Summary: | Pass Fail Total; tmp | 86 9 95; ERROR: LoadError: Some tests did not pass: 86 passed, 9 failed, 0 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_advection_schemes.jl:69; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272
https://github.com/CliMA/Oceananigans.jl/issues/1272:418,Testability,test,tests,418,"This set of tests also fails at least in part because of the lack of high order WENO as in #1271 , but the plots seem to use PyPlot and I ended up just getting a bunch of blank plots. I presume we wanted to update the plotting to use something else?. But I think some of the failures are that the orders do not match the theory close enough. ```; Test Summary: | Pass Fail Total; tmp | 86 9 95; ERROR: LoadError: Some tests did not pass: 86 passed, 9 failed, 0 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_advection_schemes.jl:69; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272
https://github.com/CliMA/Oceananigans.jl/issues/1273:147,Availability,ERROR,ERROR,147,"This validation script also fails because it can't find CenteredSecondOrder. ```; julia> include(""one_dimensional_cosine_advection_diffusion.jl""); ERROR: LoadError: UndefVarError: CenteredSecondOrder not defined; Stacktrace:; [1] #1 at ./none:0 [inlined]; [2] iterate at ./generator.jl:47 [inlined]; [3] collect(::Base.Generator{Array{Int64,1},var""#1#2""{Float64,Int64,Int64,Float64}}) at ./array.jl:686; [4] run_convergence_test(::Float64, ::Int64, ::Array{Int64,1}) at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_cosine_advection_diffusion.jl:28; [5] top-level scope at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_cosine_advection_diffusion.jl:38; [6] include(::String) at ./client.jl:457; [7] top-level scope at REPL[1]:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_cosine_advection_diffusion.jl:38; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1273
https://github.com/CliMA/Oceananigans.jl/issues/1273:154,Performance,Load,LoadError,154,"This validation script also fails because it can't find CenteredSecondOrder. ```; julia> include(""one_dimensional_cosine_advection_diffusion.jl""); ERROR: LoadError: UndefVarError: CenteredSecondOrder not defined; Stacktrace:; [1] #1 at ./none:0 [inlined]; [2] iterate at ./generator.jl:47 [inlined]; [3] collect(::Base.Generator{Array{Int64,1},var""#1#2""{Float64,Int64,Int64,Float64}}) at ./array.jl:686; [4] run_convergence_test(::Float64, ::Int64, ::Array{Int64,1}) at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_cosine_advection_diffusion.jl:28; [5] top-level scope at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_cosine_advection_diffusion.jl:38; [6] include(::String) at ./client.jl:457; [7] top-level scope at REPL[1]:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_cosine_advection_diffusion.jl:38; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1273
https://github.com/CliMA/Oceananigans.jl/issues/1273:5,Security,validat,validation,5,"This validation script also fails because it can't find CenteredSecondOrder. ```; julia> include(""one_dimensional_cosine_advection_diffusion.jl""); ERROR: LoadError: UndefVarError: CenteredSecondOrder not defined; Stacktrace:; [1] #1 at ./none:0 [inlined]; [2] iterate at ./generator.jl:47 [inlined]; [3] collect(::Base.Generator{Array{Int64,1},var""#1#2""{Float64,Int64,Int64,Float64}}) at ./array.jl:686; [4] run_convergence_test(::Float64, ::Int64, ::Array{Int64,1}) at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_cosine_advection_diffusion.jl:28; [5] top-level scope at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_cosine_advection_diffusion.jl:38; [6] include(::String) at ./client.jl:457; [7] top-level scope at REPL[1]:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_cosine_advection_diffusion.jl:38; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1273
https://github.com/CliMA/Oceananigans.jl/issues/1273:509,Security,validat,validation,509,"This validation script also fails because it can't find CenteredSecondOrder. ```; julia> include(""one_dimensional_cosine_advection_diffusion.jl""); ERROR: LoadError: UndefVarError: CenteredSecondOrder not defined; Stacktrace:; [1] #1 at ./none:0 [inlined]; [2] iterate at ./generator.jl:47 [inlined]; [3] collect(::Base.Generator{Array{Int64,1},var""#1#2""{Float64,Int64,Int64,Float64}}) at ./array.jl:686; [4] run_convergence_test(::Float64, ::Int64, ::Array{Int64,1}) at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_cosine_advection_diffusion.jl:28; [5] top-level scope at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_cosine_advection_diffusion.jl:38; [6] include(::String) at ./client.jl:457; [7] top-level scope at REPL[1]:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_cosine_advection_diffusion.jl:38; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1273
https://github.com/CliMA/Oceananigans.jl/issues/1273:650,Security,validat,validation,650,"This validation script also fails because it can't find CenteredSecondOrder. ```; julia> include(""one_dimensional_cosine_advection_diffusion.jl""); ERROR: LoadError: UndefVarError: CenteredSecondOrder not defined; Stacktrace:; [1] #1 at ./none:0 [inlined]; [2] iterate at ./generator.jl:47 [inlined]; [3] collect(::Base.Generator{Array{Int64,1},var""#1#2""{Float64,Int64,Int64,Float64}}) at ./array.jl:686; [4] run_convergence_test(::Float64, ::Int64, ::Array{Int64,1}) at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_cosine_advection_diffusion.jl:28; [5] top-level scope at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_cosine_advection_diffusion.jl:38; [6] include(::String) at ./client.jl:457; [7] top-level scope at REPL[1]:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_cosine_advection_diffusion.jl:38; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1273
https://github.com/CliMA/Oceananigans.jl/issues/1273:870,Security,validat,validation,870,"This validation script also fails because it can't find CenteredSecondOrder. ```; julia> include(""one_dimensional_cosine_advection_diffusion.jl""); ERROR: LoadError: UndefVarError: CenteredSecondOrder not defined; Stacktrace:; [1] #1 at ./none:0 [inlined]; [2] iterate at ./generator.jl:47 [inlined]; [3] collect(::Base.Generator{Array{Int64,1},var""#1#2""{Float64,Int64,Int64,Float64}}) at ./array.jl:686; [4] run_convergence_test(::Float64, ::Int64, ::Array{Int64,1}) at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_cosine_advection_diffusion.jl:28; [5] top-level scope at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_cosine_advection_diffusion.jl:38; [6] include(::String) at ./client.jl:457; [7] top-level scope at REPL[1]:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/convergence_tests/one_dimensional_cosine_advection_diffusion.jl:38; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1273
https://github.com/CliMA/Oceananigans.jl/issues/1274:723,Energy Efficiency,schedul,schedule,723,"Basically whenever I set a writer with `AveragedTimeInterval` where `interval` is the same as `window`, I get the following warnings:. ```; ┌ Warning: Returning a WindowedTimeAverage before the collection period is complete.; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Mt2Rj/src/OutputWriters/windowed_time_average.jl:202; ┌ Warning: Returning a WindowedTimeAverage before the collection period is complete.; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Mt2Rj/src/OutputWriters/windowed_time_average.jl:202; ```. The call I'm using is something like that:. ```julia; simulation.output_writers[:averages] =; NetCDFOutputWriter(model, outputs,; filepath = @sprintf(""avg.%s.nc"", simname),; schedule = AveragedTimeInterval(2seconds; window=2seconds, stride=1),; ); ```. Note that if I change the schedule line to . ```julia; schedule = AveragedTimeInterval(2seconds; window=1.9seconds, stride=1),; ```. The warning gets suppressed.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1274
https://github.com/CliMA/Oceananigans.jl/issues/1274:828,Energy Efficiency,schedul,schedule,828,"Basically whenever I set a writer with `AveragedTimeInterval` where `interval` is the same as `window`, I get the following warnings:. ```; ┌ Warning: Returning a WindowedTimeAverage before the collection period is complete.; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Mt2Rj/src/OutputWriters/windowed_time_average.jl:202; ┌ Warning: Returning a WindowedTimeAverage before the collection period is complete.; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Mt2Rj/src/OutputWriters/windowed_time_average.jl:202; ```. The call I'm using is something like that:. ```julia; simulation.output_writers[:averages] =; NetCDFOutputWriter(model, outputs,; filepath = @sprintf(""avg.%s.nc"", simname),; schedule = AveragedTimeInterval(2seconds; window=2seconds, stride=1),; ); ```. Note that if I change the schedule line to . ```julia; schedule = AveragedTimeInterval(2seconds; window=1.9seconds, stride=1),; ```. The warning gets suppressed.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1274
https://github.com/CliMA/Oceananigans.jl/issues/1274:857,Energy Efficiency,schedul,schedule,857,"Basically whenever I set a writer with `AveragedTimeInterval` where `interval` is the same as `window`, I get the following warnings:. ```; ┌ Warning: Returning a WindowedTimeAverage before the collection period is complete.; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Mt2Rj/src/OutputWriters/windowed_time_average.jl:202; ┌ Warning: Returning a WindowedTimeAverage before the collection period is complete.; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Mt2Rj/src/OutputWriters/windowed_time_average.jl:202; ```. The call I'm using is something like that:. ```julia; simulation.output_writers[:averages] =; NetCDFOutputWriter(model, outputs,; filepath = @sprintf(""avg.%s.nc"", simname),; schedule = AveragedTimeInterval(2seconds; window=2seconds, stride=1),; ); ```. Note that if I change the schedule line to . ```julia; schedule = AveragedTimeInterval(2seconds; window=1.9seconds, stride=1),; ```. The warning gets suppressed.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1274
https://github.com/CliMA/Oceananigans.jl/pull/1276:14,Testability,test,tested,14,This has been tested using the advection schemes but should be easy enough to generalize to other tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276
https://github.com/CliMA/Oceananigans.jl/pull/1276:98,Testability,test,tests,98,This has been tested using the advection schemes but should be easy enough to generalize to other tests.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276
https://github.com/CliMA/Oceananigans.jl/issues/1278:824,Testability,test,testing,824,"`IsotropicDiffusivity` currently uses a viscosity and thermal diffusivity appropriate for water at 20 degrees Celsius and 35 psu:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/TurbulenceClosures/turbulence_closure_implementations/isotropic_diffusivity.jl#L11-L28. When I put this in I originally thought it was positive because it provided a reference. It's also cute because its ""oceanic"". But as time has gone on I now fear its actually surprising and also not very useful, since it's not actually a common to use Oceananigans for direct numerical simulations of miniscule boxes with molecular transport coefficients. Instead, `IsotropicDiffusivity` is useful for 1) idealized problems, education, examples and 2) as a simple turbulence closure when setting up a simulation / testing ideas, possibly prior to implementing a more complicated closure. This ""ocean-realistic"" default is inconvenient for either case. So, I propose changing the default for both the viscosity and diffusivity to 0. cc @tomchor @xiaozhour",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1278
https://github.com/CliMA/Oceananigans.jl/issues/1278:767,Usability,simpl,simple,767,"`IsotropicDiffusivity` currently uses a viscosity and thermal diffusivity appropriate for water at 20 degrees Celsius and 35 psu:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/TurbulenceClosures/turbulence_closure_implementations/isotropic_diffusivity.jl#L11-L28. When I put this in I originally thought it was positive because it provided a reference. It's also cute because its ""oceanic"". But as time has gone on I now fear its actually surprising and also not very useful, since it's not actually a common to use Oceananigans for direct numerical simulations of miniscule boxes with molecular transport coefficients. Instead, `IsotropicDiffusivity` is useful for 1) idealized problems, education, examples and 2) as a simple turbulence closure when setting up a simulation / testing ideas, possibly prior to implementing a more complicated closure. This ""ocean-realistic"" default is inconvenient for either case. So, I propose changing the default for both the viscosity and diffusivity to 0. cc @tomchor @xiaozhour",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1278
https://github.com/CliMA/Oceananigans.jl/issues/1279:679,Availability,down,downside,679,"The docs have an incorrect description of the `AnisotropicBiharmonicDiffusivity`: . https://clima.github.io/OceananigansDocumentation/stable/physics/turbulence_closures/#Constant-anisotropic-biharmonic-diffusivity. since the docs claim we use a horizontal biharmonic operator (dx^2 + dy^2)^2 + dz^2, despite that in our implementation:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_biharmonic_diffusivity.jl#L64-L68. we actually use dx^4 + dy^4 + dz^4. Our implementation is not truly biharmonic, but is instead might be described as ""fourth-order hyperdiffusion"". A downside of the form we use is that the amount of dissipation it provides depends on the orientation of a feature (""diagonal"" gradients are dissipated less than purely horizontal or vertical gradients). An upside is that we can ensure zero fluxes on solid boundaries more easily. We could solve this by having separate implementation of the true horizontal biharmonic operator for `AnisotropicBiharmonicDiffusivity` (still useful for horizontally-periodic problems), as well as a `FourthOrderHyperDiffusivity` that uses our current implementation. It also might make sense to have `IsotropicBiharmonicDiffusivity` since we can do triply periodic.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1279
https://github.com/CliMA/Oceananigans.jl/issues/1279:753,Integrability,depend,depends,753,"The docs have an incorrect description of the `AnisotropicBiharmonicDiffusivity`: . https://clima.github.io/OceananigansDocumentation/stable/physics/turbulence_closures/#Constant-anisotropic-biharmonic-diffusivity. since the docs claim we use a horizontal biharmonic operator (dx^2 + dy^2)^2 + dz^2, despite that in our implementation:. https://github.com/CliMA/Oceananigans.jl/blob/81db22f4a26396142e8cd5b5a4c50c75790c1d50/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_biharmonic_diffusivity.jl#L64-L68. we actually use dx^4 + dy^4 + dz^4. Our implementation is not truly biharmonic, but is instead might be described as ""fourth-order hyperdiffusion"". A downside of the form we use is that the amount of dissipation it provides depends on the orientation of a feature (""diagonal"" gradients are dissipated less than purely horizontal or vertical gradients). An upside is that we can ensure zero fluxes on solid boundaries more easily. We could solve this by having separate implementation of the true horizontal biharmonic operator for `AnisotropicBiharmonicDiffusivity` (still useful for horizontally-periodic problems), as well as a `FourthOrderHyperDiffusivity` that uses our current implementation. It also might make sense to have `IsotropicBiharmonicDiffusivity` since we can do triply periodic.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1279
https://github.com/CliMA/Oceananigans.jl/issues/1280:29,Availability,checkpoint,checkpoint,29,"When attempting to run after checkpoint, it seems to think that the last iteration it wrote to output writers was time=0, so it tries to take an enormous negative timestep so that it can write before the next time it was supposed to. Obviously this causes an error, in this case it gave a ""illegal memory access"" in a CUDA array",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280
https://github.com/CliMA/Oceananigans.jl/issues/1280:259,Availability,error,error,259,"When attempting to run after checkpoint, it seems to think that the last iteration it wrote to output writers was time=0, so it tries to take an enormous negative timestep so that it can write before the next time it was supposed to. Obviously this causes an error, in this case it gave a ""illegal memory access"" in a CUDA array",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280
https://github.com/CliMA/Oceananigans.jl/issues/1280:305,Security,access,access,305,"When attempting to run after checkpoint, it seems to think that the last iteration it wrote to output writers was time=0, so it tries to take an enormous negative timestep so that it can write before the next time it was supposed to. Obviously this causes an error, in this case it gave a ""illegal memory access"" in a CUDA array",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1280
https://github.com/CliMA/Oceananigans.jl/issues/1281:223,Availability,error,errors,223,"I'm trying to follow the [tutorial here](https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/) using vscode (connected via remote-ssh to ubuntu machine). However, I consistently get errors below (and `@animate` step doesn't finish): ; ```; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281
https://github.com/CliMA/Oceananigans.jl/issues/1281:651,Availability,Avail,Available,651,"I'm trying to follow the [tutorial here](https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/) using vscode (connected via remote-ssh to ubuntu machine). However, I consistently get errors below (and `@animate` step doesn't finish): ; ```; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281
https://github.com/CliMA/Oceananigans.jl/issues/1281:1246,Availability,Avail,Available,1246,"I'm trying to follow the [tutorial here](https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/) using vscode (connected via remote-ssh to ubuntu machine). However, I consistently get errors below (and `@animate` step doesn't finish): ; ```; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281
https://github.com/CliMA/Oceananigans.jl/issues/1281:1841,Availability,Avail,Available,1841,"I'm trying to follow the [tutorial here](https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/) using vscode (connected via remote-ssh to ubuntu machine). However, I consistently get errors below (and `@animate` step doesn't finish): ; ```; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281
https://github.com/CliMA/Oceananigans.jl/issues/1281:359,Integrability,rout,routine,359,"I'm trying to follow the [tutorial here](https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/) using vscode (connected via remote-ssh to ubuntu machine). However, I consistently get errors below (and `@animate` step doesn't finish): ; ```; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281
https://github.com/CliMA/Oceananigans.jl/issues/1281:859,Integrability,rout,routine,859,"I'm trying to follow the [tutorial here](https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/) using vscode (connected via remote-ssh to ubuntu machine). However, I consistently get errors below (and `@animate` step doesn't finish): ; ```; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281
https://github.com/CliMA/Oceananigans.jl/issues/1281:954,Integrability,rout,routine,954,"I'm trying to follow the [tutorial here](https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/) using vscode (connected via remote-ssh to ubuntu machine). However, I consistently get errors below (and `@animate` step doesn't finish): ; ```; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281
https://github.com/CliMA/Oceananigans.jl/issues/1281:1454,Integrability,rout,routine,1454,"I'm trying to follow the [tutorial here](https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/) using vscode (connected via remote-ssh to ubuntu machine). However, I consistently get errors below (and `@animate` step doesn't finish): ; ```; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281
https://github.com/CliMA/Oceananigans.jl/issues/1281:1549,Integrability,rout,routine,1549,"I'm trying to follow the [tutorial here](https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/) using vscode (connected via remote-ssh to ubuntu machine). However, I consistently get errors below (and `@animate` step doesn't finish): ; ```; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281
https://github.com/CliMA/Oceananigans.jl/issues/1281:430,Modifiability,plugin,plugin,430,"I'm trying to follow the [tutorial here](https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/) using vscode (connected via remote-ssh to ubuntu machine). However, I consistently get errors below (and `@animate` step doesn't finish): ; ```; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281
https://github.com/CliMA/Oceananigans.jl/issues/1281:469,Modifiability,plugin,plugin,469,"I'm trying to follow the [tutorial here](https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/) using vscode (connected via remote-ssh to ubuntu machine). However, I consistently get errors below (and `@animate` step doesn't finish): ; ```; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281
https://github.com/CliMA/Oceananigans.jl/issues/1281:571,Modifiability,plugin,plugin,571,"I'm trying to follow the [tutorial here](https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/) using vscode (connected via remote-ssh to ubuntu machine). However, I consistently get errors below (and `@animate` step doesn't finish): ; ```; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281
https://github.com/CliMA/Oceananigans.jl/issues/1281:670,Modifiability,plugin,plugins,670,"I'm trying to follow the [tutorial here](https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/) using vscode (connected via remote-ssh to ubuntu machine). However, I consistently get errors below (and `@animate` step doesn't finish): ; ```; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281
https://github.com/CliMA/Oceananigans.jl/issues/1281:1025,Modifiability,plugin,plugin,1025,"I'm trying to follow the [tutorial here](https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/) using vscode (connected via remote-ssh to ubuntu machine). However, I consistently get errors below (and `@animate` step doesn't finish): ; ```; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281
https://github.com/CliMA/Oceananigans.jl/issues/1281:1064,Modifiability,plugin,plugin,1064,"I'm trying to follow the [tutorial here](https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/) using vscode (connected via remote-ssh to ubuntu machine). However, I consistently get errors below (and `@animate` step doesn't finish): ; ```; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281
https://github.com/CliMA/Oceananigans.jl/issues/1281:1166,Modifiability,plugin,plugin,1166,"I'm trying to follow the [tutorial here](https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/) using vscode (connected via remote-ssh to ubuntu machine). However, I consistently get errors below (and `@animate` step doesn't finish): ; ```; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281
https://github.com/CliMA/Oceananigans.jl/issues/1281:1265,Modifiability,plugin,plugins,1265,"I'm trying to follow the [tutorial here](https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/) using vscode (connected via remote-ssh to ubuntu machine). However, I consistently get errors below (and `@animate` step doesn't finish): ; ```; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281
https://github.com/CliMA/Oceananigans.jl/issues/1281:1620,Modifiability,plugin,plugin,1620,"I'm trying to follow the [tutorial here](https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/) using vscode (connected via remote-ssh to ubuntu machine). However, I consistently get errors below (and `@animate` step doesn't finish): ; ```; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281
https://github.com/CliMA/Oceananigans.jl/issues/1281:1659,Modifiability,plugin,plugin,1659,"I'm trying to follow the [tutorial here](https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/) using vscode (connected via remote-ssh to ubuntu machine). However, I consistently get errors below (and `@animate` step doesn't finish): ; ```; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281
https://github.com/CliMA/Oceananigans.jl/issues/1281:1761,Modifiability,plugin,plugin,1761,"I'm trying to follow the [tutorial here](https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/) using vscode (connected via remote-ssh to ubuntu machine). However, I consistently get errors below (and `@animate` step doesn't finish): ; ```; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281
https://github.com/CliMA/Oceananigans.jl/issues/1281:1860,Modifiability,plugin,plugins,1860,"I'm trying to follow the [tutorial here](https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/) using vscode (connected via remote-ssh to ubuntu machine). However, I consistently get errors below (and `@animate` step doesn't finish): ; ```; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281
https://github.com/CliMA/Oceananigans.jl/issues/1281:448,Performance,load,load,448,"I'm trying to follow the [tutorial here](https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/) using vscode (connected via remote-ssh to ubuntu machine). However, I consistently get errors below (and `@animate` step doesn't finish): ; ```; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281
https://github.com/CliMA/Oceananigans.jl/issues/1281:1043,Performance,load,load,1043,"I'm trying to follow the [tutorial here](https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/) using vscode (connected via remote-ssh to ubuntu machine). However, I consistently get errors below (and `@animate` step doesn't finish): ; ```; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281
https://github.com/CliMA/Oceananigans.jl/issues/1281:1638,Performance,load,load,1638,"I'm trying to follow the [tutorial here](https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/) using vscode (connected via remote-ssh to ubuntu machine). However, I consistently get errors below (and `@animate` step doesn't finish): ; ```; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281
https://github.com/CliMA/Oceananigans.jl/issues/1281:741,Safety,Abort,Aborted,741,"I'm trying to follow the [tutorial here](https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/) using vscode (connected via remote-ssh to ubuntu machine). However, I consistently get errors below (and `@animate` step doesn't finish): ; ```; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281
https://github.com/CliMA/Oceananigans.jl/issues/1281:1336,Safety,Abort,Aborted,1336,"I'm trying to follow the [tutorial here](https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/) using vscode (connected via remote-ssh to ubuntu machine). However, I consistently get errors below (and `@animate` step doesn't finish): ; ```; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281
https://github.com/CliMA/Oceananigans.jl/issues/1285:113,Availability,ERROR,ERROR,113,Flux.jl is a pretty popular package. It seems Oceananigans conflicts with it.; If I do `using Flux` I get:; ```; ERROR: importing Flux into Main conflicts with an existing identifier; ```; Is there any way to import both?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1285
https://github.com/CliMA/Oceananigans.jl/pull/1287:52,Energy Efficiency,Adapt,Adapt,52,"This pull request changes the compat entry for the `Adapt` package from `^2` to `^2, 3.0`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287
https://github.com/CliMA/Oceananigans.jl/pull/1287:52,Modifiability,Adapt,Adapt,52,"This pull request changes the compat entry for the `Adapt` package from `^2` to `^2, 3.0`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287
https://github.com/CliMA/Oceananigans.jl/pull/1287:160,Testability,test,tested,160,"This pull request changes the compat entry for the `Adapt` package from `^2` to `^2, 3.0`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287
https://github.com/CliMA/Oceananigans.jl/pull/1287:265,Testability,test,tests,265,"This pull request changes the compat entry for the `Adapt` package from `^2` to `^2, 3.0`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287
https://github.com/CliMA/Oceananigans.jl/issues/1288:15,Energy Efficiency,schedul,schedule,15,"For; ```julia; schedule = AveragedTimeInterval(a, window=b); ```; It must be the case that a > b. If a = b or a < b the end result will produce NaNs.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1288
https://github.com/CliMA/Oceananigans.jl/issues/1289:1070,Energy Efficiency,meter,meters,1070,"s; using Oceananigans.Utils. using Oceananigans.Grids: nodes; using Oceananigans.Diagnostics: FieldMaximum; using Oceananigans.OutputWriters: JLD2OutputWriter, FieldSlicer, TimeInterval. grid = RegularCartesianGrid(size=(256, 256, 64), extent=(4, 4, 0.1)). buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(α=2e-4, β=0)). H=0.1 #dimension in vertical direction; W=4 #dimension in south-north direction; L=4 #dimension in east-west direction; Ra=1e9 #rayleigh number; Ro=0.24 #Horizontal Rossby number; v=2e-6 #diffusive viscocity; k=1e-6 #diffusivity ; l=W/2 #center of gaussian field; m=L/2 #center of gausian field. Bo=0.72e-4 #maximum surface flux. fo=0.5 #coriolis parameter. beta=3.75e-3. #Surface forcing; heat_flux(x,y,t) = Bo*exp(-0.5*((x-l)^2+(y-m)^2)). dTdz = 0 # K m⁻¹. T_bcs = TracerBoundaryConditions(grid,; top = BoundaryCondition(Flux, heat_flux),; bottom = BoundaryCondition(Gradient, dTdz)). #velocity boundary condition; u₁₀ = 1.0e-1 # m s⁻¹, average wind velocity 10 meters above the ocean; cᴰ = 2.5e-3 # dimensionless drag coefficient; ρₐ = 1.225 # kg m⁻³, average density of air at sea-level; ρₒ = 1026 # kg m⁻³, average density at the surface of the world ocean; Qᵘ = - ρₐ / ρₒ * cᴰ * u₁₀ * abs(u₁₀) # m² s⁻². u_bcs = UVelocityBoundaryConditions(grid, top = BoundaryCondition(Flux, Qᵘ), bottom=ValueBoundaryCondition(0.0)); v_bcs = VVelocityBoundaryConditions(grid, top = BoundaryCondition(Flux, Qᵘ), bottom=ValueBoundaryCondition(0.0)); w_bcs = WVelocityBoundaryConditions(grid, top = ValueBoundaryCondition(0.0), bottom=ValueBoundaryCondition(0.0)). #Incompressible model initiation ; model = IncompressibleModel(architecture = CPU(),; timestepper = :RungeKutta3,; grid = grid,; coriolis = BetaPlane(f₀=fo, β=beta),; buoyancy = buoyancy,; closure = IsotropicDiffusivity(ν=v, κ=k),; boundary_conditions = (u=u_bcs, v=v_bcs, w=w_bcs, T=T_bcs)). # Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise. # Te",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1289
https://github.com/CliMA/Oceananigans.jl/issues/1289:3310,Energy Efficiency,schedul,schedule,3310,"lux, Qᵘ), bottom=ValueBoundaryCondition(0.0)); v_bcs = VVelocityBoundaryConditions(grid, top = BoundaryCondition(Flux, Qᵘ), bottom=ValueBoundaryCondition(0.0)); w_bcs = WVelocityBoundaryConditions(grid, top = ValueBoundaryCondition(0.0), bottom=ValueBoundaryCondition(0.0)). #Incompressible model initiation ; model = IncompressibleModel(architecture = CPU(),; timestepper = :RungeKutta3,; grid = grid,; coriolis = BetaPlane(f₀=fo, β=beta),; buoyancy = buoyancy,; closure = IsotropicDiffusivity(ν=v, κ=k),; boundary_conditions = (u=u_bcs, v=v_bcs, w=w_bcs, T=T_bcs)). # Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise. # Temperature initial condition: a stable density gradient with random noise superposed.; Tᵢ(x, y, z) = 20 + dTdz * z + dTdz * model.grid.Lz * 1e-6 * Ξ(z). # Velocity initial condition: random noise scaled by the friction velocity.; uᵢ(x, y, z) = sqrt(abs(Qᵘ)) * 1e-4 * Ξ(z). # `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, v=uᵢ, w=uᵢ, T=Tᵢ). wizard = TimeStepWizard(cfl=0.3, Δt=0.10, max_change=1.1, max_Δt=0.1minute). wmax = FieldMaximum(abs, model.velocities.w); umax = FieldMaximum(abs, model.velocities.u); vmax = FieldMaximum(abs, model.velocities.v). start_time = time_ns() # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, umax = %.1e ms⁻¹, vmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), wmax(sim.model),umax(sim.model), vmax(sim.model),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model, Δt=wizard, stop_time=10minutes, iteration_interval=10,; progress=progress_message). simulation.output_writers[:fields] =; JLD2OutputWriter(model, merge(model.velocities, model.tracers),; prefix = ""open_ocean_convection2"",; schedule = TimeInterval(0.2minute),; force = true). run!(simulation); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1289
https://github.com/CliMA/Oceananigans.jl/issues/1289:2738,Integrability,message,message,2738,"lux, Qᵘ), bottom=ValueBoundaryCondition(0.0)); v_bcs = VVelocityBoundaryConditions(grid, top = BoundaryCondition(Flux, Qᵘ), bottom=ValueBoundaryCondition(0.0)); w_bcs = WVelocityBoundaryConditions(grid, top = ValueBoundaryCondition(0.0), bottom=ValueBoundaryCondition(0.0)). #Incompressible model initiation ; model = IncompressibleModel(architecture = CPU(),; timestepper = :RungeKutta3,; grid = grid,; coriolis = BetaPlane(f₀=fo, β=beta),; buoyancy = buoyancy,; closure = IsotropicDiffusivity(ν=v, κ=k),; boundary_conditions = (u=u_bcs, v=v_bcs, w=w_bcs, T=T_bcs)). # Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise. # Temperature initial condition: a stable density gradient with random noise superposed.; Tᵢ(x, y, z) = 20 + dTdz * z + dTdz * model.grid.Lz * 1e-6 * Ξ(z). # Velocity initial condition: random noise scaled by the friction velocity.; uᵢ(x, y, z) = sqrt(abs(Qᵘ)) * 1e-4 * Ξ(z). # `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, v=uᵢ, w=uᵢ, T=Tᵢ). wizard = TimeStepWizard(cfl=0.3, Δt=0.10, max_change=1.1, max_Δt=0.1minute). wmax = FieldMaximum(abs, model.velocities.w); umax = FieldMaximum(abs, model.velocities.u); vmax = FieldMaximum(abs, model.velocities.v). start_time = time_ns() # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, umax = %.1e ms⁻¹, vmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), wmax(sim.model),umax(sim.model), vmax(sim.model),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model, Δt=wizard, stop_time=10minutes, iteration_interval=10,; progress=progress_message). simulation.output_writers[:fields] =; JLD2OutputWriter(model, merge(model.velocities, model.tracers),; prefix = ""open_ocean_convection2"",; schedule = TimeInterval(0.2minute),; force = true). run!(simulation); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1289
https://github.com/CliMA/Oceananigans.jl/issues/1290:1416,Integrability,depend,dependencies,1416,"ata :: A; grid :: G; u :: U; v :: V; b :: B; dUdz :: Uz_bg; dVdz :: Vz_bg; N2 :: N2_bg; end. """"""; RichardsonNumber(model). Returns an `AbstractField` representing the Richardson number of `model`. Calling `compute!(Rich::RichardsonNumber)` computes the Richardson number; associated with `model` and stores it in `Rich.data`.; """"""; function RichardsonNumber(model; data = nothing,; N²_bg = 0, dUdz_bg = 0, dVdz_bg = 0). if isnothing(data); data = new_data(model.architecture, model.grid, (Cell, Cell, Face)); end. u, v, w = model.velocities; b = model.tracers.b. return RichardsonNumber(data, model.grid, u, v, b, dUdz_bg, dVdz_bg, N²_bg); end. function compute!(Rich::RichardsonNumber). arch = architecture(Rich.data). workgroup, worksize = work_layout(Rich.grid, :xyz, location=(Cell, Cell, Face)). compute_kernel! = compute_richardson_number!(device(arch), workgroup, worksize). event = compute_kernel!(Rich.data, Rich.grid,; Rich.u, Rich.v, Rich.b,; Rich.dUdz, Rich.dVdz, Rich.N2; dependencies=Event(device(arch))). wait(device(arch), event). return nothing; end. @kernel function compute_richardson_number!(Ri, grid, u, v, b, Uz, Vz, N2); i, j, k = @index(Global, NTuple). #dBdz = ∂zᵃᵃᶠ(i, j, k, grid, b) + N2 # dbdz(c, c, f); #dUdz_tot = ℑxᶜᵃᵃ(i, j, k, grid, ∂zᵃᵃᶠ, u) + Uz # dudz(f, c, f) => dudz(c, c, f); #dVdz_tot = ℑyᵃᶜᵃ(i, j, k, grid, ∂zᵃᵃᶠ, v) + Vz # dvdz(c, f, f) => dvdz(c, c, f). #@inbounds Ri[i, j, k] = dBdz / (dUdz_tot^2 + dVdz_tot^2); @inbounds Ri[i, j, k] = N2 / (Uz^2 + Vz^2); end; ```. So, note that, as a test, I'm using using `N2`, `Uz` and `Vz` in the actual calculation at the end. These are all constants (background stratification and shear) and the value of Ri should be exactly `1` at end. However, this is what I'm getting (I'm showing a horizontal average of a time step):. ```python; <xarray.DataArray 'Ri' (zF: 17)>; array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0.]); Coordinates:; * zF (zF) float64 -100.0 -87.5 -75.0 -62.5 ... 62.5 75.0 ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1290
https://github.com/CliMA/Oceananigans.jl/issues/1290:1960,Testability,test,test,1960,"g = 0, dVdz_bg = 0). if isnothing(data); data = new_data(model.architecture, model.grid, (Cell, Cell, Face)); end. u, v, w = model.velocities; b = model.tracers.b. return RichardsonNumber(data, model.grid, u, v, b, dUdz_bg, dVdz_bg, N²_bg); end. function compute!(Rich::RichardsonNumber). arch = architecture(Rich.data). workgroup, worksize = work_layout(Rich.grid, :xyz, location=(Cell, Cell, Face)). compute_kernel! = compute_richardson_number!(device(arch), workgroup, worksize). event = compute_kernel!(Rich.data, Rich.grid,; Rich.u, Rich.v, Rich.b,; Rich.dUdz, Rich.dVdz, Rich.N2; dependencies=Event(device(arch))). wait(device(arch), event). return nothing; end. @kernel function compute_richardson_number!(Ri, grid, u, v, b, Uz, Vz, N2); i, j, k = @index(Global, NTuple). #dBdz = ∂zᵃᵃᶠ(i, j, k, grid, b) + N2 # dbdz(c, c, f); #dUdz_tot = ℑxᶜᵃᵃ(i, j, k, grid, ∂zᵃᵃᶠ, u) + Uz # dudz(f, c, f) => dudz(c, c, f); #dVdz_tot = ℑyᵃᶜᵃ(i, j, k, grid, ∂zᵃᵃᶠ, v) + Vz # dvdz(c, f, f) => dvdz(c, c, f). #@inbounds Ri[i, j, k] = dBdz / (dUdz_tot^2 + dVdz_tot^2); @inbounds Ri[i, j, k] = N2 / (Uz^2 + Vz^2); end; ```. So, note that, as a test, I'm using using `N2`, `Uz` and `Vz` in the actual calculation at the end. These are all constants (background stratification and shear) and the value of Ri should be exactly `1` at end. However, this is what I'm getting (I'm showing a horizontal average of a time step):. ```python; <xarray.DataArray 'Ri' (zF: 17)>; array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 0.]); Coordinates:; * zF (zF) float64 -100.0 -87.5 -75.0 -62.5 ... 62.5 75.0 87.5 100.0; xC float64 7.812; xF float64 0.0; time float64 600.0; ```. For those unfamiliar with xarray, the output is `1` everywhere (good!) except at the upper boundary, where for some reason it is zero (bad!). Since I'm only using constants to calculate this, it seems to me that, for some reason, the corresponding `k` isn't being calculated at all. . Any ideas of how I might fix this?. Thanks!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1290
https://github.com/CliMA/Oceananigans.jl/pull/1291:190,Testability,test,tests,190,"This PR (pair programmed with @francispoulin) allows users to select the `timestepper` and adds support for `forcing` functions as part of the `ShallowWaterModel`. We also added some simple tests. We also added a `shallow_water_model_forcing` function that should readily generalize to `IncompressibleModel` while being shorter, so we can consider using it to replace `model_forcing`. Resolves #1284",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1291
https://github.com/CliMA/Oceananigans.jl/pull/1291:183,Usability,simpl,simple,183,"This PR (pair programmed with @francispoulin) allows users to select the `timestepper` and adds support for `forcing` functions as part of the `ShallowWaterModel`. We also added some simple tests. We also added a `shallow_water_model_forcing` function that should readily generalize to `IncompressibleModel` while being shorter, so we can consider using it to replace `model_forcing`. Resolves #1284",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1291
https://github.com/CliMA/Oceananigans.jl/pull/1293:167,Testability,Test,Testing,167,Adds `KernelComputedField <: AbstractField` which is computed using a user-defined `@kernel` function via `KernelAbstractions.jl`. To do:. - [x] Implementation; - [x] Testing; - [x] Example / Docs; - [x] Test complex examples on GPUs. Closes #1246,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1293
https://github.com/CliMA/Oceananigans.jl/pull/1293:204,Testability,Test,Test,204,Adds `KernelComputedField <: AbstractField` which is computed using a user-defined `@kernel` function via `KernelAbstractions.jl`. To do:. - [x] Implementation; - [x] Testing; - [x] Example / Docs; - [x] Test complex examples on GPUs. Closes #1246,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1293
https://github.com/CliMA/Oceananigans.jl/pull/1295:187,Testability,test,tested,187,"This pull request changes the compat entry for the `KernelAbstractions` package from `^0.3, 0.4` to `^0.3, 0.4, 0.5`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1295
https://github.com/CliMA/Oceananigans.jl/pull/1295:292,Testability,test,tests,292,"This pull request changes the compat entry for the `KernelAbstractions` package from `^0.3, 0.4` to `^0.3, 0.4, 0.5`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1295
https://github.com/CliMA/Oceananigans.jl/pull/1296:39,Availability,down,downgraded,39,Updated CUDA.jl to v2.3.0 since it was downgraded in PR #1295 for some reason. Waiting for https://github.com/JuliaGPU/CUDA.jl/pull/626 and tagged release to update to Adapt v3.0.0 as well.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1296
https://github.com/CliMA/Oceananigans.jl/pull/1296:0,Deployability,Update,Updated,0,Updated CUDA.jl to v2.3.0 since it was downgraded in PR #1295 for some reason. Waiting for https://github.com/JuliaGPU/CUDA.jl/pull/626 and tagged release to update to Adapt v3.0.0 as well.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1296
https://github.com/CliMA/Oceananigans.jl/pull/1296:147,Deployability,release,release,147,Updated CUDA.jl to v2.3.0 since it was downgraded in PR #1295 for some reason. Waiting for https://github.com/JuliaGPU/CUDA.jl/pull/626 and tagged release to update to Adapt v3.0.0 as well.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1296
https://github.com/CliMA/Oceananigans.jl/pull/1296:158,Deployability,update,update,158,Updated CUDA.jl to v2.3.0 since it was downgraded in PR #1295 for some reason. Waiting for https://github.com/JuliaGPU/CUDA.jl/pull/626 and tagged release to update to Adapt v3.0.0 as well.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1296
https://github.com/CliMA/Oceananigans.jl/pull/1296:168,Energy Efficiency,Adapt,Adapt,168,Updated CUDA.jl to v2.3.0 since it was downgraded in PR #1295 for some reason. Waiting for https://github.com/JuliaGPU/CUDA.jl/pull/626 and tagged release to update to Adapt v3.0.0 as well.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1296
https://github.com/CliMA/Oceananigans.jl/pull/1296:168,Modifiability,Adapt,Adapt,168,Updated CUDA.jl to v2.3.0 since it was downgraded in PR #1295 for some reason. Waiting for https://github.com/JuliaGPU/CUDA.jl/pull/626 and tagged release to update to Adapt v3.0.0 as well.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1296
https://github.com/CliMA/Oceananigans.jl/issues/1297:33,Availability,Avail,Available,33,Do we want to be able to compute Available Potential Energy (APE) to get an idea as to the energtics of a flow?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297
https://github.com/CliMA/Oceananigans.jl/issues/1297:53,Energy Efficiency,Energy,Energy,53,Do we want to be able to compute Available Potential Energy (APE) to get an idea as to the energtics of a flow?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1297
https://github.com/CliMA/Oceananigans.jl/pull/1298:105,Energy Efficiency,Power,Powerful,105,I reminded myself that there is some motivation/explanation just before the beginning of the section **A Powerful algorithm**.; I added some more clarifications. @jklymak what do you think?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1298
https://github.com/CliMA/Oceananigans.jl/pull/1301:1777,Availability,avail,available,1777,"capability of our ""conditional computation"" framework wherein the ""re-calculation"" of expensive diagnostics and computations may be avoided if possible. Previously, expensive field recalculations were avoided *only* at the outermost level (if the field were used directly in output), which in hindsight doesn't seem very useful since we often average or otherwise reduce expensive calculations for output (if we were not reducing an expensive calculation, we could simply calculate it offline). Avoiding recalculation for field ""dependencies"" requires adding a third function for field computation: we now have `compute_at!(field, time)`, `conditional_compute!(field, time)`, and `compute!(field, time)`. `compute_at!(field, time)` is the outermost function called by `fetch_output`. It falls back to `compute!(field)`. Fields opt-in to conditional computation by overloading `compute_at!`; for example, `ComputeField` implements. ```julia; compute_at!(field::ComputedField{X, Y, Z, <:FieldStatus}, time) where {X, Y, Z} = conditional_compute!(field, time); ```. Thus `ComputedField`s that have a `field.status` which is not `Nothing` are _conditionally_ computed. But if `field.status === nothing`, the computed field is always recomputed. The function `conditional_compute!(field, time)` examines `field.status` to determine whether a field has already been computed at `time` or not. If the field has been computed, it does nothing. If the field has not been computed, then `compute!(field, time)` is called, and `field.status.time` is updated. Conditionally computed fields must define a function `compute!(field, time=nothing)` that takes an optional positional argument `time`. This ensures that both `compute!(field)` and `compute!(field, time)` are available. Finally, fields that depend on other fields should call `compute_at!(dependency, time)` on all field dependencies. I hope that makes sense. It sounds a bit convoluted so I'm not sure this is the simplest solution. Criticism welcome.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1301
https://github.com/CliMA/Oceananigans.jl/pull/1301:1559,Deployability,update,updated,1559,"capability of our ""conditional computation"" framework wherein the ""re-calculation"" of expensive diagnostics and computations may be avoided if possible. Previously, expensive field recalculations were avoided *only* at the outermost level (if the field were used directly in output), which in hindsight doesn't seem very useful since we often average or otherwise reduce expensive calculations for output (if we were not reducing an expensive calculation, we could simply calculate it offline). Avoiding recalculation for field ""dependencies"" requires adding a third function for field computation: we now have `compute_at!(field, time)`, `conditional_compute!(field, time)`, and `compute!(field, time)`. `compute_at!(field, time)` is the outermost function called by `fetch_output`. It falls back to `compute!(field)`. Fields opt-in to conditional computation by overloading `compute_at!`; for example, `ComputeField` implements. ```julia; compute_at!(field::ComputedField{X, Y, Z, <:FieldStatus}, time) where {X, Y, Z} = conditional_compute!(field, time); ```. Thus `ComputedField`s that have a `field.status` which is not `Nothing` are _conditionally_ computed. But if `field.status === nothing`, the computed field is always recomputed. The function `conditional_compute!(field, time)` examines `field.status` to determine whether a field has already been computed at `time` or not. If the field has been computed, it does nothing. If the field has not been computed, then `compute!(field, time)` is called, and `field.status.time` is updated. Conditionally computed fields must define a function `compute!(field, time=nothing)` that takes an optional positional argument `time`. This ensures that both `compute!(field)` and `compute!(field, time)` are available. Finally, fields that depend on other fields should call `compute_at!(dependency, time)` on all field dependencies. I hope that makes sense. It sounds a bit convoluted so I'm not sure this is the simplest solution. Criticism welcome.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1301
https://github.com/CliMA/Oceananigans.jl/pull/1301:384,Energy Efficiency,reduce,reduce,384,"This PR extends the capability of our ""conditional computation"" framework wherein the ""re-calculation"" of expensive diagnostics and computations may be avoided if possible. Previously, expensive field recalculations were avoided *only* at the outermost level (if the field were used directly in output), which in hindsight doesn't seem very useful since we often average or otherwise reduce expensive calculations for output (if we were not reducing an expensive calculation, we could simply calculate it offline). Avoiding recalculation for field ""dependencies"" requires adding a third function for field computation: we now have `compute_at!(field, time)`, `conditional_compute!(field, time)`, and `compute!(field, time)`. `compute_at!(field, time)` is the outermost function called by `fetch_output`. It falls back to `compute!(field)`. Fields opt-in to conditional computation by overloading `compute_at!`; for example, `ComputeField` implements. ```julia; compute_at!(field::ComputedField{X, Y, Z, <:FieldStatus}, time) where {X, Y, Z} = conditional_compute!(field, time); ```. Thus `ComputedField`s that have a `field.status` which is not `Nothing` are _conditionally_ computed. But if `field.status === nothing`, the computed field is always recomputed. The function `conditional_compute!(field, time)` examines `field.status` to determine whether a field has already been computed at `time` or not. If the field has been computed, it does nothing. If the field has not been computed, then `compute!(field, time)` is called, and `field.status.time` is updated. Conditionally computed fields must define a function `compute!(field, time=nothing)` that takes an optional positional argument `time`. This ensures that both `compute!(field)` and `compute!(field, time)` are available. Finally, fields that depend on other fields should call `compute_at!(dependency, time)` on all field dependencies. I hope that makes sense. It sounds a bit convoluted so I'm not sure this is the simplest solution.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1301
https://github.com/CliMA/Oceananigans.jl/pull/1301:549,Integrability,depend,dependencies,549,"This PR extends the capability of our ""conditional computation"" framework wherein the ""re-calculation"" of expensive diagnostics and computations may be avoided if possible. Previously, expensive field recalculations were avoided *only* at the outermost level (if the field were used directly in output), which in hindsight doesn't seem very useful since we often average or otherwise reduce expensive calculations for output (if we were not reducing an expensive calculation, we could simply calculate it offline). Avoiding recalculation for field ""dependencies"" requires adding a third function for field computation: we now have `compute_at!(field, time)`, `conditional_compute!(field, time)`, and `compute!(field, time)`. `compute_at!(field, time)` is the outermost function called by `fetch_output`. It falls back to `compute!(field)`. Fields opt-in to conditional computation by overloading `compute_at!`; for example, `ComputeField` implements. ```julia; compute_at!(field::ComputedField{X, Y, Z, <:FieldStatus}, time) where {X, Y, Z} = conditional_compute!(field, time); ```. Thus `ComputedField`s that have a `field.status` which is not `Nothing` are _conditionally_ computed. But if `field.status === nothing`, the computed field is always recomputed. The function `conditional_compute!(field, time)` examines `field.status` to determine whether a field has already been computed at `time` or not. If the field has been computed, it does nothing. If the field has not been computed, then `compute!(field, time)` is called, and `field.status.time` is updated. Conditionally computed fields must define a function `compute!(field, time=nothing)` that takes an optional positional argument `time`. This ensures that both `compute!(field)` and `compute!(field, time)` are available. Finally, fields that depend on other fields should call `compute_at!(dependency, time)` on all field dependencies. I hope that makes sense. It sounds a bit convoluted so I'm not sure this is the simplest solution.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1301
https://github.com/CliMA/Oceananigans.jl/pull/1301:1809,Integrability,depend,depend,1809,"capability of our ""conditional computation"" framework wherein the ""re-calculation"" of expensive diagnostics and computations may be avoided if possible. Previously, expensive field recalculations were avoided *only* at the outermost level (if the field were used directly in output), which in hindsight doesn't seem very useful since we often average or otherwise reduce expensive calculations for output (if we were not reducing an expensive calculation, we could simply calculate it offline). Avoiding recalculation for field ""dependencies"" requires adding a third function for field computation: we now have `compute_at!(field, time)`, `conditional_compute!(field, time)`, and `compute!(field, time)`. `compute_at!(field, time)` is the outermost function called by `fetch_output`. It falls back to `compute!(field)`. Fields opt-in to conditional computation by overloading `compute_at!`; for example, `ComputeField` implements. ```julia; compute_at!(field::ComputedField{X, Y, Z, <:FieldStatus}, time) where {X, Y, Z} = conditional_compute!(field, time); ```. Thus `ComputedField`s that have a `field.status` which is not `Nothing` are _conditionally_ computed. But if `field.status === nothing`, the computed field is always recomputed. The function `conditional_compute!(field, time)` examines `field.status` to determine whether a field has already been computed at `time` or not. If the field has been computed, it does nothing. If the field has not been computed, then `compute!(field, time)` is called, and `field.status.time` is updated. Conditionally computed fields must define a function `compute!(field, time=nothing)` that takes an optional positional argument `time`. This ensures that both `compute!(field)` and `compute!(field, time)` are available. Finally, fields that depend on other fields should call `compute_at!(dependency, time)` on all field dependencies. I hope that makes sense. It sounds a bit convoluted so I'm not sure this is the simplest solution. Criticism welcome.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1301
https://github.com/CliMA/Oceananigans.jl/pull/1301:1857,Integrability,depend,dependency,1857,"capability of our ""conditional computation"" framework wherein the ""re-calculation"" of expensive diagnostics and computations may be avoided if possible. Previously, expensive field recalculations were avoided *only* at the outermost level (if the field were used directly in output), which in hindsight doesn't seem very useful since we often average or otherwise reduce expensive calculations for output (if we were not reducing an expensive calculation, we could simply calculate it offline). Avoiding recalculation for field ""dependencies"" requires adding a third function for field computation: we now have `compute_at!(field, time)`, `conditional_compute!(field, time)`, and `compute!(field, time)`. `compute_at!(field, time)` is the outermost function called by `fetch_output`. It falls back to `compute!(field)`. Fields opt-in to conditional computation by overloading `compute_at!`; for example, `ComputeField` implements. ```julia; compute_at!(field::ComputedField{X, Y, Z, <:FieldStatus}, time) where {X, Y, Z} = conditional_compute!(field, time); ```. Thus `ComputedField`s that have a `field.status` which is not `Nothing` are _conditionally_ computed. But if `field.status === nothing`, the computed field is always recomputed. The function `conditional_compute!(field, time)` examines `field.status` to determine whether a field has already been computed at `time` or not. If the field has been computed, it does nothing. If the field has not been computed, then `compute!(field, time)` is called, and `field.status.time` is updated. Conditionally computed fields must define a function `compute!(field, time=nothing)` that takes an optional positional argument `time`. This ensures that both `compute!(field)` and `compute!(field, time)` are available. Finally, fields that depend on other fields should call `compute_at!(dependency, time)` on all field dependencies. I hope that makes sense. It sounds a bit convoluted so I'm not sure this is the simplest solution. Criticism welcome.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1301
https://github.com/CliMA/Oceananigans.jl/pull/1301:1889,Integrability,depend,dependencies,1889,"capability of our ""conditional computation"" framework wherein the ""re-calculation"" of expensive diagnostics and computations may be avoided if possible. Previously, expensive field recalculations were avoided *only* at the outermost level (if the field were used directly in output), which in hindsight doesn't seem very useful since we often average or otherwise reduce expensive calculations for output (if we were not reducing an expensive calculation, we could simply calculate it offline). Avoiding recalculation for field ""dependencies"" requires adding a third function for field computation: we now have `compute_at!(field, time)`, `conditional_compute!(field, time)`, and `compute!(field, time)`. `compute_at!(field, time)` is the outermost function called by `fetch_output`. It falls back to `compute!(field)`. Fields opt-in to conditional computation by overloading `compute_at!`; for example, `ComputeField` implements. ```julia; compute_at!(field::ComputedField{X, Y, Z, <:FieldStatus}, time) where {X, Y, Z} = conditional_compute!(field, time); ```. Thus `ComputedField`s that have a `field.status` which is not `Nothing` are _conditionally_ computed. But if `field.status === nothing`, the computed field is always recomputed. The function `conditional_compute!(field, time)` examines `field.status` to determine whether a field has already been computed at `time` or not. If the field has been computed, it does nothing. If the field has not been computed, then `compute!(field, time)` is called, and `field.status.time` is updated. Conditionally computed fields must define a function `compute!(field, time=nothing)` that takes an optional positional argument `time`. This ensures that both `compute!(field)` and `compute!(field, time)` are available. Finally, fields that depend on other fields should call `compute_at!(dependency, time)` on all field dependencies. I hope that makes sense. It sounds a bit convoluted so I'm not sure this is the simplest solution. Criticism welcome.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1301
https://github.com/CliMA/Oceananigans.jl/pull/1301:8,Modifiability,extend,extends,8,"This PR extends the capability of our ""conditional computation"" framework wherein the ""re-calculation"" of expensive diagnostics and computations may be avoided if possible. Previously, expensive field recalculations were avoided *only* at the outermost level (if the field were used directly in output), which in hindsight doesn't seem very useful since we often average or otherwise reduce expensive calculations for output (if we were not reducing an expensive calculation, we could simply calculate it offline). Avoiding recalculation for field ""dependencies"" requires adding a third function for field computation: we now have `compute_at!(field, time)`, `conditional_compute!(field, time)`, and `compute!(field, time)`. `compute_at!(field, time)` is the outermost function called by `fetch_output`. It falls back to `compute!(field)`. Fields opt-in to conditional computation by overloading `compute_at!`; for example, `ComputeField` implements. ```julia; compute_at!(field::ComputedField{X, Y, Z, <:FieldStatus}, time) where {X, Y, Z} = conditional_compute!(field, time); ```. Thus `ComputedField`s that have a `field.status` which is not `Nothing` are _conditionally_ computed. But if `field.status === nothing`, the computed field is always recomputed. The function `conditional_compute!(field, time)` examines `field.status` to determine whether a field has already been computed at `time` or not. If the field has been computed, it does nothing. If the field has not been computed, then `compute!(field, time)` is called, and `field.status.time` is updated. Conditionally computed fields must define a function `compute!(field, time=nothing)` that takes an optional positional argument `time`. This ensures that both `compute!(field)` and `compute!(field, time)` are available. Finally, fields that depend on other fields should call `compute_at!(dependency, time)` on all field dependencies. I hope that makes sense. It sounds a bit convoluted so I'm not sure this is the simplest solution.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1301
https://github.com/CliMA/Oceananigans.jl/pull/1301:152,Safety,avoid,avoided,152,"This PR extends the capability of our ""conditional computation"" framework wherein the ""re-calculation"" of expensive diagnostics and computations may be avoided if possible. Previously, expensive field recalculations were avoided *only* at the outermost level (if the field were used directly in output), which in hindsight doesn't seem very useful since we often average or otherwise reduce expensive calculations for output (if we were not reducing an expensive calculation, we could simply calculate it offline). Avoiding recalculation for field ""dependencies"" requires adding a third function for field computation: we now have `compute_at!(field, time)`, `conditional_compute!(field, time)`, and `compute!(field, time)`. `compute_at!(field, time)` is the outermost function called by `fetch_output`. It falls back to `compute!(field)`. Fields opt-in to conditional computation by overloading `compute_at!`; for example, `ComputeField` implements. ```julia; compute_at!(field::ComputedField{X, Y, Z, <:FieldStatus}, time) where {X, Y, Z} = conditional_compute!(field, time); ```. Thus `ComputedField`s that have a `field.status` which is not `Nothing` are _conditionally_ computed. But if `field.status === nothing`, the computed field is always recomputed. The function `conditional_compute!(field, time)` examines `field.status` to determine whether a field has already been computed at `time` or not. If the field has been computed, it does nothing. If the field has not been computed, then `compute!(field, time)` is called, and `field.status.time` is updated. Conditionally computed fields must define a function `compute!(field, time=nothing)` that takes an optional positional argument `time`. This ensures that both `compute!(field)` and `compute!(field, time)` are available. Finally, fields that depend on other fields should call `compute_at!(dependency, time)` on all field dependencies. I hope that makes sense. It sounds a bit convoluted so I'm not sure this is the simplest solution.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1301
https://github.com/CliMA/Oceananigans.jl/pull/1301:221,Safety,avoid,avoided,221,"This PR extends the capability of our ""conditional computation"" framework wherein the ""re-calculation"" of expensive diagnostics and computations may be avoided if possible. Previously, expensive field recalculations were avoided *only* at the outermost level (if the field were used directly in output), which in hindsight doesn't seem very useful since we often average or otherwise reduce expensive calculations for output (if we were not reducing an expensive calculation, we could simply calculate it offline). Avoiding recalculation for field ""dependencies"" requires adding a third function for field computation: we now have `compute_at!(field, time)`, `conditional_compute!(field, time)`, and `compute!(field, time)`. `compute_at!(field, time)` is the outermost function called by `fetch_output`. It falls back to `compute!(field)`. Fields opt-in to conditional computation by overloading `compute_at!`; for example, `ComputeField` implements. ```julia; compute_at!(field::ComputedField{X, Y, Z, <:FieldStatus}, time) where {X, Y, Z} = conditional_compute!(field, time); ```. Thus `ComputedField`s that have a `field.status` which is not `Nothing` are _conditionally_ computed. But if `field.status === nothing`, the computed field is always recomputed. The function `conditional_compute!(field, time)` examines `field.status` to determine whether a field has already been computed at `time` or not. If the field has been computed, it does nothing. If the field has not been computed, then `compute!(field, time)` is called, and `field.status.time` is updated. Conditionally computed fields must define a function `compute!(field, time=nothing)` that takes an optional positional argument `time`. This ensures that both `compute!(field)` and `compute!(field, time)` are available. Finally, fields that depend on other fields should call `compute_at!(dependency, time)` on all field dependencies. I hope that makes sense. It sounds a bit convoluted so I'm not sure this is the simplest solution.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1301
https://github.com/CliMA/Oceananigans.jl/pull/1301:515,Safety,Avoid,Avoiding,515,"This PR extends the capability of our ""conditional computation"" framework wherein the ""re-calculation"" of expensive diagnostics and computations may be avoided if possible. Previously, expensive field recalculations were avoided *only* at the outermost level (if the field were used directly in output), which in hindsight doesn't seem very useful since we often average or otherwise reduce expensive calculations for output (if we were not reducing an expensive calculation, we could simply calculate it offline). Avoiding recalculation for field ""dependencies"" requires adding a third function for field computation: we now have `compute_at!(field, time)`, `conditional_compute!(field, time)`, and `compute!(field, time)`. `compute_at!(field, time)` is the outermost function called by `fetch_output`. It falls back to `compute!(field)`. Fields opt-in to conditional computation by overloading `compute_at!`; for example, `ComputeField` implements. ```julia; compute_at!(field::ComputedField{X, Y, Z, <:FieldStatus}, time) where {X, Y, Z} = conditional_compute!(field, time); ```. Thus `ComputedField`s that have a `field.status` which is not `Nothing` are _conditionally_ computed. But if `field.status === nothing`, the computed field is always recomputed. The function `conditional_compute!(field, time)` examines `field.status` to determine whether a field has already been computed at `time` or not. If the field has been computed, it does nothing. If the field has not been computed, then `compute!(field, time)` is called, and `field.status.time` is updated. Conditionally computed fields must define a function `compute!(field, time=nothing)` that takes an optional positional argument `time`. This ensures that both `compute!(field)` and `compute!(field, time)` are available. Finally, fields that depend on other fields should call `compute_at!(dependency, time)` on all field dependencies. I hope that makes sense. It sounds a bit convoluted so I'm not sure this is the simplest solution.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1301
https://github.com/CliMA/Oceananigans.jl/pull/1301:485,Usability,simpl,simply,485,"This PR extends the capability of our ""conditional computation"" framework wherein the ""re-calculation"" of expensive diagnostics and computations may be avoided if possible. Previously, expensive field recalculations were avoided *only* at the outermost level (if the field were used directly in output), which in hindsight doesn't seem very useful since we often average or otherwise reduce expensive calculations for output (if we were not reducing an expensive calculation, we could simply calculate it offline). Avoiding recalculation for field ""dependencies"" requires adding a third function for field computation: we now have `compute_at!(field, time)`, `conditional_compute!(field, time)`, and `compute!(field, time)`. `compute_at!(field, time)` is the outermost function called by `fetch_output`. It falls back to `compute!(field)`. Fields opt-in to conditional computation by overloading `compute_at!`; for example, `ComputeField` implements. ```julia; compute_at!(field::ComputedField{X, Y, Z, <:FieldStatus}, time) where {X, Y, Z} = conditional_compute!(field, time); ```. Thus `ComputedField`s that have a `field.status` which is not `Nothing` are _conditionally_ computed. But if `field.status === nothing`, the computed field is always recomputed. The function `conditional_compute!(field, time)` examines `field.status` to determine whether a field has already been computed at `time` or not. If the field has been computed, it does nothing. If the field has not been computed, then `compute!(field, time)` is called, and `field.status.time` is updated. Conditionally computed fields must define a function `compute!(field, time=nothing)` that takes an optional positional argument `time`. This ensures that both `compute!(field)` and `compute!(field, time)` are available. Finally, fields that depend on other fields should call `compute_at!(dependency, time)` on all field dependencies. I hope that makes sense. It sounds a bit convoluted so I'm not sure this is the simplest solution.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1301
https://github.com/CliMA/Oceananigans.jl/pull/1301:1983,Usability,simpl,simplest,1983,"capability of our ""conditional computation"" framework wherein the ""re-calculation"" of expensive diagnostics and computations may be avoided if possible. Previously, expensive field recalculations were avoided *only* at the outermost level (if the field were used directly in output), which in hindsight doesn't seem very useful since we often average or otherwise reduce expensive calculations for output (if we were not reducing an expensive calculation, we could simply calculate it offline). Avoiding recalculation for field ""dependencies"" requires adding a third function for field computation: we now have `compute_at!(field, time)`, `conditional_compute!(field, time)`, and `compute!(field, time)`. `compute_at!(field, time)` is the outermost function called by `fetch_output`. It falls back to `compute!(field)`. Fields opt-in to conditional computation by overloading `compute_at!`; for example, `ComputeField` implements. ```julia; compute_at!(field::ComputedField{X, Y, Z, <:FieldStatus}, time) where {X, Y, Z} = conditional_compute!(field, time); ```. Thus `ComputedField`s that have a `field.status` which is not `Nothing` are _conditionally_ computed. But if `field.status === nothing`, the computed field is always recomputed. The function `conditional_compute!(field, time)` examines `field.status` to determine whether a field has already been computed at `time` or not. If the field has been computed, it does nothing. If the field has not been computed, then `compute!(field, time)` is called, and `field.status.time` is updated. Conditionally computed fields must define a function `compute!(field, time=nothing)` that takes an optional positional argument `time`. This ensures that both `compute!(field)` and `compute!(field, time)` are available. Finally, fields that depend on other fields should call `compute_at!(dependency, time)` on all field dependencies. I hope that makes sense. It sounds a bit convoluted so I'm not sure this is the simplest solution. Criticism welcome.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1301
https://github.com/CliMA/Oceananigans.jl/pull/1303:124,Availability,checkpoint,checkpointed,124,"This is a temporary fix for #1280 (time stepping a model with `pickup=true` -> it blows up) until schedules can be probably checkpointed. While this is a temporary fix, it has affected a number of people already (@qwert2266, @suyashbire1, @sandreza, and now @sam12396 in #1300) so would be good to merge this and tag a new release.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1303
https://github.com/CliMA/Oceananigans.jl/pull/1303:323,Deployability,release,release,323,"This is a temporary fix for #1280 (time stepping a model with `pickup=true` -> it blows up) until schedules can be probably checkpointed. While this is a temporary fix, it has affected a number of people already (@qwert2266, @suyashbire1, @sandreza, and now @sam12396 in #1300) so would be good to merge this and tag a new release.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1303
https://github.com/CliMA/Oceananigans.jl/pull/1303:98,Energy Efficiency,schedul,schedules,98,"This is a temporary fix for #1280 (time stepping a model with `pickup=true` -> it blows up) until schedules can be probably checkpointed. While this is a temporary fix, it has affected a number of people already (@qwert2266, @suyashbire1, @sandreza, and now @sam12396 in #1300) so would be good to merge this and tag a new release.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1303
https://github.com/CliMA/Oceananigans.jl/issues/1304:180,Usability,learn,learning,180,"In addition to studying problems in oceanography, I also investigate problems in solar physics. Basically, the same equations as for the ocean but with magnetohydrodynamics. After learning about Oceananigans, it would be very easy (and desirable for me) to add a model (sometime, not right away) that would solve the MHD Shallow Water Model. This is something that I can see my students could use and benefit from. However, this is not a pure ocean problem so it does not fit in terms of the physics. **Question:** How would people feel about having an MHD model as part of Oceananigans?. If people agree that it doesn't fit, then I could learn to create another repo that piggy backs on Oceananigans, and that would be something that only I would be responsble to maintain. Would this be an option for the Oceananigans group?. Any thoughts are welcome.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1304
https://github.com/CliMA/Oceananigans.jl/issues/1304:639,Usability,learn,learn,639,"In addition to studying problems in oceanography, I also investigate problems in solar physics. Basically, the same equations as for the ocean but with magnetohydrodynamics. After learning about Oceananigans, it would be very easy (and desirable for me) to add a model (sometime, not right away) that would solve the MHD Shallow Water Model. This is something that I can see my students could use and benefit from. However, this is not a pure ocean problem so it does not fit in terms of the physics. **Question:** How would people feel about having an MHD model as part of Oceananigans?. If people agree that it doesn't fit, then I could learn to create another repo that piggy backs on Oceananigans, and that would be something that only I would be responsble to maintain. Would this be an option for the Oceananigans group?. Any thoughts are welcome.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1304
https://github.com/CliMA/Oceananigans.jl/issues/1307:47,Safety,avoid,avoid,47,"I will look into this soon as I really want to avoid NaN's, as I'm getting today.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307
https://github.com/CliMA/Oceananigans.jl/issues/1308:871,Availability,ERROR,ERROR,871,"When creating a background field, I can add it to its respective perturbations to create a total field. However, this fails when writing to file. Here's a MWE:. ```julia; using Oceananigans; using Oceananigans.AbstractOperations: compute!; using Oceananigans.Utils; using Oceananigans.OutputWriters. grid = RegularCartesianGrid(size=(16, 1, 16), extent=(1, 1, 1)). U(x, y, z, t) = 0.2 * z. model = IncompressibleModel(grid = grid, background_fields = (u=U,)). U_tot = model.background_fields.velocities.u + model.velocities.u. simulation = Simulation(model, Δt=2,; iteration_interval=5,; stop_iteration=5,). outputs = (u = model.velocities.u, U_tot = U_tot,); simulation.output_writers[:simple_output] = NetCDFOutputWriter(model, outputs,; filepath = ""mwe.nc"",; schedule = TimeInterval(20minutes),; mode = ""c""); run!(simulation); ```. This fails in the last line with. > ERROR: LoadError: type BinaryOperation has no field data. Is this expected behavior? It would be very nice to be able to do this!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1308
https://github.com/CliMA/Oceananigans.jl/issues/1308:762,Energy Efficiency,schedul,schedule,762,"When creating a background field, I can add it to its respective perturbations to create a total field. However, this fails when writing to file. Here's a MWE:. ```julia; using Oceananigans; using Oceananigans.AbstractOperations: compute!; using Oceananigans.Utils; using Oceananigans.OutputWriters. grid = RegularCartesianGrid(size=(16, 1, 16), extent=(1, 1, 1)). U(x, y, z, t) = 0.2 * z. model = IncompressibleModel(grid = grid, background_fields = (u=U,)). U_tot = model.background_fields.velocities.u + model.velocities.u. simulation = Simulation(model, Δt=2,; iteration_interval=5,; stop_iteration=5,). outputs = (u = model.velocities.u, U_tot = U_tot,); simulation.output_writers[:simple_output] = NetCDFOutputWriter(model, outputs,; filepath = ""mwe.nc"",; schedule = TimeInterval(20minutes),; mode = ""c""); run!(simulation); ```. This fails in the last line with. > ERROR: LoadError: type BinaryOperation has no field data. Is this expected behavior? It would be very nice to be able to do this!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1308
https://github.com/CliMA/Oceananigans.jl/issues/1308:878,Performance,Load,LoadError,878,"When creating a background field, I can add it to its respective perturbations to create a total field. However, this fails when writing to file. Here's a MWE:. ```julia; using Oceananigans; using Oceananigans.AbstractOperations: compute!; using Oceananigans.Utils; using Oceananigans.OutputWriters. grid = RegularCartesianGrid(size=(16, 1, 16), extent=(1, 1, 1)). U(x, y, z, t) = 0.2 * z. model = IncompressibleModel(grid = grid, background_fields = (u=U,)). U_tot = model.background_fields.velocities.u + model.velocities.u. simulation = Simulation(model, Δt=2,; iteration_interval=5,; stop_iteration=5,). outputs = (u = model.velocities.u, U_tot = U_tot,); simulation.output_writers[:simple_output] = NetCDFOutputWriter(model, outputs,; filepath = ""mwe.nc"",; schedule = TimeInterval(20minutes),; mode = ""c""); run!(simulation); ```. This fails in the last line with. > ERROR: LoadError: type BinaryOperation has no field data. Is this expected behavior? It would be very nice to be able to do this!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1308
https://github.com/CliMA/Oceananigans.jl/issues/1310:515,Deployability,integrat,integrating,515,"Borrowing on previous code that a student and I wrote, I have created a julia code that will solve the linear stability problem for a Bickley Jet in the context fo the `ShallowWaterModel`. It doesn't actually use Oceananigans at all, yet, but produces the followin four figures. This is something that I plan to use to validate the growth rates in the nonlinear evolution of the Bickely jet in the `ShallowWaterModel`, but can easily be extended to other profiles and other models as well. Is there any interest in integrating this in Oceananigans?. **Velocity and free-surface height of the basic state:**. ![basic_state](https://user-images.githubusercontent.com/8239041/105401802-93844880-5bf4-11eb-8a7f-32878e09698c.png). **Growth rates of the two most unstable modes:**. ![growth_rates](https://user-images.githubusercontent.com/8239041/105401818-9717cf80-5bf4-11eb-9c12-79f755ce84ed.png). **Plots of the 1D spatial strucutre of the most unstable mode:**. ![modes_1D](https://user-images.githubusercontent.com/8239041/105401831-9bdc8380-5bf4-11eb-8226-c531129dc7ae.png). **Plots of the 2D spatial strucutre of the most unstable mode:**. ![modes_2d](https://user-images.githubusercontent.com/8239041/105401841-9da64700-5bf4-11eb-9cf6-c7efb9fce62e.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1310
https://github.com/CliMA/Oceananigans.jl/issues/1310:515,Integrability,integrat,integrating,515,"Borrowing on previous code that a student and I wrote, I have created a julia code that will solve the linear stability problem for a Bickley Jet in the context fo the `ShallowWaterModel`. It doesn't actually use Oceananigans at all, yet, but produces the followin four figures. This is something that I plan to use to validate the growth rates in the nonlinear evolution of the Bickely jet in the `ShallowWaterModel`, but can easily be extended to other profiles and other models as well. Is there any interest in integrating this in Oceananigans?. **Velocity and free-surface height of the basic state:**. ![basic_state](https://user-images.githubusercontent.com/8239041/105401802-93844880-5bf4-11eb-8a7f-32878e09698c.png). **Growth rates of the two most unstable modes:**. ![growth_rates](https://user-images.githubusercontent.com/8239041/105401818-9717cf80-5bf4-11eb-9c12-79f755ce84ed.png). **Plots of the 1D spatial strucutre of the most unstable mode:**. ![modes_1D](https://user-images.githubusercontent.com/8239041/105401831-9bdc8380-5bf4-11eb-8226-c531129dc7ae.png). **Plots of the 2D spatial strucutre of the most unstable mode:**. ![modes_2d](https://user-images.githubusercontent.com/8239041/105401841-9da64700-5bf4-11eb-9cf6-c7efb9fce62e.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1310
https://github.com/CliMA/Oceananigans.jl/issues/1310:437,Modifiability,extend,extended,437,"Borrowing on previous code that a student and I wrote, I have created a julia code that will solve the linear stability problem for a Bickley Jet in the context fo the `ShallowWaterModel`. It doesn't actually use Oceananigans at all, yet, but produces the followin four figures. This is something that I plan to use to validate the growth rates in the nonlinear evolution of the Bickely jet in the `ShallowWaterModel`, but can easily be extended to other profiles and other models as well. Is there any interest in integrating this in Oceananigans?. **Velocity and free-surface height of the basic state:**. ![basic_state](https://user-images.githubusercontent.com/8239041/105401802-93844880-5bf4-11eb-8a7f-32878e09698c.png). **Growth rates of the two most unstable modes:**. ![growth_rates](https://user-images.githubusercontent.com/8239041/105401818-9717cf80-5bf4-11eb-9c12-79f755ce84ed.png). **Plots of the 1D spatial strucutre of the most unstable mode:**. ![modes_1D](https://user-images.githubusercontent.com/8239041/105401831-9bdc8380-5bf4-11eb-8226-c531129dc7ae.png). **Plots of the 2D spatial strucutre of the most unstable mode:**. ![modes_2d](https://user-images.githubusercontent.com/8239041/105401841-9da64700-5bf4-11eb-9cf6-c7efb9fce62e.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1310
https://github.com/CliMA/Oceananigans.jl/issues/1310:319,Security,validat,validate,319,"Borrowing on previous code that a student and I wrote, I have created a julia code that will solve the linear stability problem for a Bickley Jet in the context fo the `ShallowWaterModel`. It doesn't actually use Oceananigans at all, yet, but produces the followin four figures. This is something that I plan to use to validate the growth rates in the nonlinear evolution of the Bickely jet in the `ShallowWaterModel`, but can easily be extended to other profiles and other models as well. Is there any interest in integrating this in Oceananigans?. **Velocity and free-surface height of the basic state:**. ![basic_state](https://user-images.githubusercontent.com/8239041/105401802-93844880-5bf4-11eb-8a7f-32878e09698c.png). **Growth rates of the two most unstable modes:**. ![growth_rates](https://user-images.githubusercontent.com/8239041/105401818-9717cf80-5bf4-11eb-9c12-79f755ce84ed.png). **Plots of the 1D spatial strucutre of the most unstable mode:**. ![modes_1D](https://user-images.githubusercontent.com/8239041/105401831-9bdc8380-5bf4-11eb-8226-c531129dc7ae.png). **Plots of the 2D spatial strucutre of the most unstable mode:**. ![modes_2d](https://user-images.githubusercontent.com/8239041/105401841-9da64700-5bf4-11eb-9cf6-c7efb9fce62e.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1310
https://github.com/CliMA/Oceananigans.jl/issues/1313:106,Energy Efficiency,schedul,schedule,106,"Right now the `NetCDFOutputWriter` saves some useful metadata (date, Julia version, Oceananigans version, schedule metadata) but this could be extended to saving model and simulation parameters (advection scheme, coriolis parameters, boundary condition parameters when possible, equation of state parameters, etc.). This would be generally useful and reduce the burden to do this in other packages, e.g. LESbrary.jl. This saving of metadata can easily be extended to work with `JLD2OutputWriter` as well.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1313
https://github.com/CliMA/Oceananigans.jl/issues/1313:351,Energy Efficiency,reduce,reduce,351,"Right now the `NetCDFOutputWriter` saves some useful metadata (date, Julia version, Oceananigans version, schedule metadata) but this could be extended to saving model and simulation parameters (advection scheme, coriolis parameters, boundary condition parameters when possible, equation of state parameters, etc.). This would be generally useful and reduce the burden to do this in other packages, e.g. LESbrary.jl. This saving of metadata can easily be extended to work with `JLD2OutputWriter` as well.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1313
https://github.com/CliMA/Oceananigans.jl/issues/1313:143,Modifiability,extend,extended,143,"Right now the `NetCDFOutputWriter` saves some useful metadata (date, Julia version, Oceananigans version, schedule metadata) but this could be extended to saving model and simulation parameters (advection scheme, coriolis parameters, boundary condition parameters when possible, equation of state parameters, etc.). This would be generally useful and reduce the burden to do this in other packages, e.g. LESbrary.jl. This saving of metadata can easily be extended to work with `JLD2OutputWriter` as well.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1313
https://github.com/CliMA/Oceananigans.jl/issues/1313:455,Modifiability,extend,extended,455,"Right now the `NetCDFOutputWriter` saves some useful metadata (date, Julia version, Oceananigans version, schedule metadata) but this could be extended to saving model and simulation parameters (advection scheme, coriolis parameters, boundary condition parameters when possible, equation of state parameters, etc.). This would be generally useful and reduce the burden to do this in other packages, e.g. LESbrary.jl. This saving of metadata can easily be extended to work with `JLD2OutputWriter` as well.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1313
https://github.com/CliMA/Oceananigans.jl/pull/1316:252,Safety,avoid,avoids,252,"This PR instead of executing, e.g.,; ```; using Pkg; pkg""add Oceananigans, JLD2, Plots""; ```; it just prints them out as markdown ""code"". This way users can have them in the docs to copy-paste but the Documentation build does not execute them and thus avoids random clutter in Docs like discussed in #1315. Closes #1315.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1316
https://github.com/CliMA/Oceananigans.jl/issues/1317:101,Availability,error,error,101,I am trying to run a case with GPU architecture on my school's HPC but I keep running into this same error (see gpu_error.log). This is my first time using the GPUs on the HPC so I am not sure if this is a user error or a software error. The error comes up during model instantiation.; [gpu_error.log](https://github.com/CliMA/Oceananigans.jl/files/5867606/gpu_error.log). Let me know if there is anything else you may need. The run script is also attached as a .txt. ; [model_gpu_waves.txt](https://github.com/CliMA/Oceananigans.jl/files/5867635/model_gpu_waves.txt),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317
https://github.com/CliMA/Oceananigans.jl/issues/1317:211,Availability,error,error,211,I am trying to run a case with GPU architecture on my school's HPC but I keep running into this same error (see gpu_error.log). This is my first time using the GPUs on the HPC so I am not sure if this is a user error or a software error. The error comes up during model instantiation.; [gpu_error.log](https://github.com/CliMA/Oceananigans.jl/files/5867606/gpu_error.log). Let me know if there is anything else you may need. The run script is also attached as a .txt. ; [model_gpu_waves.txt](https://github.com/CliMA/Oceananigans.jl/files/5867635/model_gpu_waves.txt),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317
https://github.com/CliMA/Oceananigans.jl/issues/1317:231,Availability,error,error,231,I am trying to run a case with GPU architecture on my school's HPC but I keep running into this same error (see gpu_error.log). This is my first time using the GPUs on the HPC so I am not sure if this is a user error or a software error. The error comes up during model instantiation.; [gpu_error.log](https://github.com/CliMA/Oceananigans.jl/files/5867606/gpu_error.log). Let me know if there is anything else you may need. The run script is also attached as a .txt. ; [model_gpu_waves.txt](https://github.com/CliMA/Oceananigans.jl/files/5867635/model_gpu_waves.txt),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317
https://github.com/CliMA/Oceananigans.jl/issues/1317:242,Availability,error,error,242,I am trying to run a case with GPU architecture on my school's HPC but I keep running into this same error (see gpu_error.log). This is my first time using the GPUs on the HPC so I am not sure if this is a user error or a software error. The error comes up during model instantiation.; [gpu_error.log](https://github.com/CliMA/Oceananigans.jl/files/5867606/gpu_error.log). Let me know if there is anything else you may need. The run script is also attached as a .txt. ; [model_gpu_waves.txt](https://github.com/CliMA/Oceananigans.jl/files/5867635/model_gpu_waves.txt),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317
https://github.com/CliMA/Oceananigans.jl/issues/1317:122,Testability,log,log,122,I am trying to run a case with GPU architecture on my school's HPC but I keep running into this same error (see gpu_error.log). This is my first time using the GPUs on the HPC so I am not sure if this is a user error or a software error. The error comes up during model instantiation.; [gpu_error.log](https://github.com/CliMA/Oceananigans.jl/files/5867606/gpu_error.log). Let me know if there is anything else you may need. The run script is also attached as a .txt. ; [model_gpu_waves.txt](https://github.com/CliMA/Oceananigans.jl/files/5867635/model_gpu_waves.txt),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317
https://github.com/CliMA/Oceananigans.jl/issues/1317:297,Testability,log,log,297,I am trying to run a case with GPU architecture on my school's HPC but I keep running into this same error (see gpu_error.log). This is my first time using the GPUs on the HPC so I am not sure if this is a user error or a software error. The error comes up during model instantiation.; [gpu_error.log](https://github.com/CliMA/Oceananigans.jl/files/5867606/gpu_error.log). Let me know if there is anything else you may need. The run script is also attached as a .txt. ; [model_gpu_waves.txt](https://github.com/CliMA/Oceananigans.jl/files/5867635/model_gpu_waves.txt),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317
https://github.com/CliMA/Oceananigans.jl/issues/1317:367,Testability,log,log,367,I am trying to run a case with GPU architecture on my school's HPC but I keep running into this same error (see gpu_error.log). This is my first time using the GPUs on the HPC so I am not sure if this is a user error or a software error. The error comes up during model instantiation.; [gpu_error.log](https://github.com/CliMA/Oceananigans.jl/files/5867606/gpu_error.log). Let me know if there is anything else you may need. The run script is also attached as a .txt. ; [model_gpu_waves.txt](https://github.com/CliMA/Oceananigans.jl/files/5867635/model_gpu_waves.txt),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317
https://github.com/CliMA/Oceananigans.jl/issues/1318:50,Availability,avail,available,50,We should document the advection schemes that are available.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318
https://github.com/CliMA/Oceananigans.jl/pull/1319:57,Testability,test,testing,57,Accidently merged PR #1091 with examples disabled (I was testing docs) and it made its way into v0.46.0 so the stable docs have no examples now. This PR revives the examples. I'll tag v0.46.1 so the examples show up in the stable docs again.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1319
https://github.com/CliMA/Oceananigans.jl/issues/1324:80,Availability,error,error,80,"cc @glwagner . When calculating PV from previously calculating fields, I get an error that comes from an interpolation I have to do. For example, this code, which I believe is the correct code, produces the wrong result:. ```julia; using Oceananigans.Operators: ℑxyzᶜᶜᶠ; @kernel function compute_pv_from_Ro_Ri!(PV, grid, Ri, Ro, N², f₀); i, j, k = @index(Global, NTuple). Ro_int = ℑxyzᶜᶜᶠ(i, j, k, grid, Ro). @inbounds PV[i, j, k] = N²[i, j, k]*f₀ * (1 + Ro_int - 1/Ri[i, j, k]); end. Ri_kern = KernelComputedField(Center, Center, Face, compute_richardson_number!, model;; field_dependencies=(u_tot, v, b_tot, 0, 0, 0)). Ro_kern = KernelComputedField(Face, Face, Center, compute_rossby_number!, model;; field_dependencies=(u_tot, v, 0, 0, f0)). PV_kern = KernelComputedField(Center, Center, Face, compute_pv_from_Ro_Ri!, model;; field_dependencies=(Ri_kern, Ro_kern, N2_inf, f0)); ```. In the above code, `f0`, `N2_inf` are constants and `u_tot` is an `AbstractOperation`. Ri and Ro get calculated correctly. However, when I change the PV calculation so as to not interpolate, I get the correct result:. ```julia; @kernel function compute_pv_from_Ro_Ri!(PV, grid, Ri, Ro, N², f₀); i, j, k = @index(Global, NTuple). @inbounds PV[i, j, k] = N²[i, j, k]*f₀ * (1 + Ro[i, j, k] - 1/Ri[i, j, k]); end; ```. The code above produces the right numerical result (although it's ""wrong"" because I'd need to interpolate). This feels weird because `Ro` is constant everywhere, so interpolating it shouldn't make any difference. Am I doing something wrong here? Also I'm attaching a [Minimum Working Example](https://pastebin.com/gH7CPNTA) just in case it's useful.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1324
https://github.com/CliMA/Oceananigans.jl/pull/1326:191,Availability,error,errors,191,"This is something that @glwagner helped me put together a while ago and I had not merged it yet. I created a new branch that does only this and tested it out. Where it ran before, I get some errors. 7 to be precise. It seems GPU related and wondered if anyone has any suggestions how I can fix these?. ```; Test Summary: | Pass Error Total; Oceananigans | 18 7 25; Shallow Water Models | 18 7 25; Model constructor errors | 2 2; (Periodic, Periodic, Bounded) model construction | 6 6; (Periodic, Bounded, Bounded) model construction | 6 6; (Bounded, Bounded, Bounded) model construction | No tests; Setting ShallowWaterModel fields | 4 4; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Periodic, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Bounded, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), Nothing] | 1 1; Time-stepping ShallowWaterModels [GPU(), FPlane{Float64}] | 1 1; Time-stepping ShallowWaterModels [GPU(), BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaE",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:328,Availability,Error,Error,328,"This is something that @glwagner helped me put together a while ago and I had not merged it yet. I created a new branch that does only this and tested it out. Where it ran before, I get some errors. 7 to be precise. It seems GPU related and wondered if anyone has any suggestions how I can fix these?. ```; Test Summary: | Pass Error Total; Oceananigans | 18 7 25; Shallow Water Models | 18 7 25; Model constructor errors | 2 2; (Periodic, Periodic, Bounded) model construction | 6 6; (Periodic, Bounded, Bounded) model construction | 6 6; (Bounded, Bounded, Bounded) model construction | No tests; Setting ShallowWaterModel fields | 4 4; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Periodic, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Bounded, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), Nothing] | 1 1; Time-stepping ShallowWaterModels [GPU(), FPlane{Float64}] | 1 1; Time-stepping ShallowWaterModels [GPU(), BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaE",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:415,Availability,error,errors,415,"This is something that @glwagner helped me put together a while ago and I had not merged it yet. I created a new branch that does only this and tested it out. Where it ran before, I get some errors. 7 to be precise. It seems GPU related and wondered if anyone has any suggestions how I can fix these?. ```; Test Summary: | Pass Error Total; Oceananigans | 18 7 25; Shallow Water Models | 18 7 25; Model constructor errors | 2 2; (Periodic, Periodic, Bounded) model construction | 6 6; (Periodic, Bounded, Bounded) model construction | 6 6; (Bounded, Bounded, Bounded) model construction | No tests; Setting ShallowWaterModel fields | 4 4; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Periodic, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Bounded, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), Nothing] | 1 1; Time-stepping ShallowWaterModels [GPU(), FPlane{Float64}] | 1 1; Time-stepping ShallowWaterModels [GPU(), BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaE",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:1209,Availability,ERROR,ERROR,1209,"This is something that @glwagner helped me put together a while ago and I had not merged it yet. I created a new branch that does only this and tested it out. Where it ran before, I get some errors. 7 to be precise. It seems GPU related and wondered if anyone has any suggestions how I can fix these?. ```; Test Summary: | Pass Error Total; Oceananigans | 18 7 25; Shallow Water Models | 18 7 25; Model constructor errors | 2 2; (Periodic, Periodic, Bounded) model construction | 6 6; (Periodic, Bounded, Bounded) model construction | 6 6; (Bounded, Bounded, Bounded) model construction | No tests; Setting ShallowWaterModel fields | 4 4; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Periodic, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Bounded, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), Nothing] | 1 1; Time-stepping ShallowWaterModels [GPU(), FPlane{Float64}] | 1 1; Time-stepping ShallowWaterModels [GPU(), BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaE",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:1275,Availability,error,errored,1275,"This is something that @glwagner helped me put together a while ago and I had not merged it yet. I created a new branch that does only this and tested it out. Where it ran before, I get some errors. 7 to be precise. It seems GPU related and wondered if anyone has any suggestions how I can fix these?. ```; Test Summary: | Pass Error Total; Oceananigans | 18 7 25; Shallow Water Models | 18 7 25; Model constructor errors | 2 2; (Periodic, Periodic, Bounded) model construction | 6 6; (Periodic, Bounded, Bounded) model construction | 6 6; (Bounded, Bounded, Bounded) model construction | No tests; Setting ShallowWaterModel fields | 4 4; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Periodic, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Bounded, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), Nothing] | 1 1; Time-stepping ShallowWaterModels [GPU(), FPlane{Float64}] | 1 1; Time-stepping ShallowWaterModels [GPU(), BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaE",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:1381,Availability,error,error,1381,"5; Model constructor errors | 2 2; (Periodic, Periodic, Bounded) model construction | 6 6; (Periodic, Bounded, Bounded) model construction | 6 6; (Bounded, Bounded, Bounded) model construction | No tests; Setting ShallowWaterModel fields | 4 4; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Periodic, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Bounded, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), Nothing] | 1 1; Time-stepping ShallowWaterModels [GPU(), FPlane{Float64}] | 1 1; Time-stepping ShallowWaterModels [GPU(), BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x00000",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:1475,Availability,error,error,1475,"ruction | 6 6; (Periodic, Bounded, Bounded) model construction | 6 6; (Bounded, Bounded, Bounded) model construction | No tests; Setting ShallowWaterModel fields | 4 4; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Periodic, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Bounded, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), Nothing] | 1 1; Time-stepping ShallowWaterModels [GPU(), FPlane{Float64}] | 1 1; Time-stepping ShallowWaterModels [GPU(), BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:1569,Availability,error,error,1569,"ed) model construction | No tests; Setting ShallowWaterModel fields | 4 4; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Periodic, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Bounded, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), Nothing] | 1 1; Time-stepping ShallowWaterModels [GPU(), FPlane{Float64}] | 1 1; Time-stepping ShallowWaterModels [GPU(), BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:1663,Availability,error,error,1663,"owWaterModels [GPU(), (Periodic, Periodic, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Periodic, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Bounded, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), Nothing] | 1 1; Time-stepping ShallowWaterModels [GPU(), FPlane{Float64}] | 1 1; Time-stepping ShallowWaterModels [GPU(), BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:1757,Availability,error,error,1757,"GPU(), (Periodic, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Bounded, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), Nothing] | 1 1; Time-stepping ShallowWaterModels [GPU(), FPlane{Float64}] | 1 1; Time-stepping ShallowWaterModels [GPU(), BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:1851,Availability,error,error,1851," Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), Nothing] | 1 1; Time-stepping ShallowWaterModels [GPU(), FPlane{Float64}] | 1 1; Time-stepping ShallowWaterModels [GPU(), BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:1945,Availability,error,error,1945,"ing ShallowWaterModels [GPU(), FPlane{Float64}] | 1 1; Time-stepping ShallowWaterModels [GPU(), BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:2039,Availability,error,error,2039,", BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:2133,Availability,error,error,2133," Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:2227,Availability,error,error,2227,"ror: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:2321,Availability,error,error,2321,"g at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:2415,Availability,error,error,2415,"UDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:2509,Availability,error,error,2509,"UDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:2603,Availability,error,error,2603,"UDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:2697,Availability,error,error,2697,"UDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:2791,Availability,error,error,2791,"UDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:2885,Availability,error,error,2885,"UDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:2979,Availability,error,error,2979,"UDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:3073,Availability,error,error,3073,"UDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:3167,Availability,error,error,3167,"UDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:3261,Availability,error,error,3261,"UDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:3355,Availability,error,error,3355,"UDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:3449,Availability,error,error,3449,"UDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cuda",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:3543,Availability,error,error,3543,"UDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Sta",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:3637,Availability,error,error,3637,"UDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:3731,Availability,error,error,3731,"UDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; [2] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:3825,Availability,error,error,3825,"UDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; [2] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/p",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:3919,Availability,error,error,3919,"UDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; [2] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; [3] test(::Pkg.Ty",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:4013,Availability,error,error,4013,"UDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; [2] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, test_fn::Nothing, julia_args::C",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:4107,Availability,error,error,4107,"UDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; [2] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, test_fn::Nothing, julia_args::Cmd, test_args::Cmd, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:4201,Availability,error,error,4201,"UDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; [2] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, test_fn::Nothing, julia_args::Cmd, test_args::Cmd, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:32",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:4295,Availability,error,error,4295,"UDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; [2] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, test_fn::Nothing, julia_args::Cmd, test_args::Cmd, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:327; [4] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /buildworker/worker/pack",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:4389,Availability,error,error,4389,"UDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; [2] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, test_fn::Nothing, julia_args::Cmd, test_args::Cmd, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:327; [4] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:314; [5] #test#61 at /buildworker",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:4483,Availability,ERROR,ERROR,4483,"; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; [2] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, test_fn::Nothing, julia_args::Cmd, test_args::Cmd, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:327; [4] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:314; [5] #test#61 at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:67 [inlined]; [6] test at /buildworker/worker/package_linux64/build/usr/share/julia/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:4511,Availability,error,errored,4511,"; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; [2] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, test_fn::Nothing, julia_args::Cmd, test_args::Cmd, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:327; [4] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:314; [5] #test#61 at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:67 [inlined]; [6] test at /buildworker/worker/package_linux64/build/usr/share/julia/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:1216,Performance,Load,LoadError,1216,"This is something that @glwagner helped me put together a while ago and I had not merged it yet. I created a new branch that does only this and tested it out. Where it ran before, I get some errors. 7 to be precise. It seems GPU related and wondered if anyone has any suggestions how I can fix these?. ```; Test Summary: | Pass Error Total; Oceananigans | 18 7 25; Shallow Water Models | 18 7 25; Model constructor errors | 2 2; (Periodic, Periodic, Bounded) model construction | 6 6; (Periodic, Bounded, Bounded) model construction | 6 6; (Bounded, Bounded, Bounded) model construction | No tests; Setting ShallowWaterModel fields | 4 4; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Periodic, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Bounded, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), Nothing] | 1 1; Time-stepping ShallowWaterModels [GPU(), FPlane{Float64}] | 1 1; Time-stepping ShallowWaterModels [GPU(), BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaE",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:144,Testability,test,tested,144,"This is something that @glwagner helped me put together a while ago and I had not merged it yet. I created a new branch that does only this and tested it out. Where it ran before, I get some errors. 7 to be precise. It seems GPU related and wondered if anyone has any suggestions how I can fix these?. ```; Test Summary: | Pass Error Total; Oceananigans | 18 7 25; Shallow Water Models | 18 7 25; Model constructor errors | 2 2; (Periodic, Periodic, Bounded) model construction | 6 6; (Periodic, Bounded, Bounded) model construction | 6 6; (Bounded, Bounded, Bounded) model construction | No tests; Setting ShallowWaterModel fields | 4 4; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Periodic, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Bounded, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), Nothing] | 1 1; Time-stepping ShallowWaterModels [GPU(), FPlane{Float64}] | 1 1; Time-stepping ShallowWaterModels [GPU(), BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaE",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:307,Testability,Test,Test,307,"This is something that @glwagner helped me put together a while ago and I had not merged it yet. I created a new branch that does only this and tested it out. Where it ran before, I get some errors. 7 to be precise. It seems GPU related and wondered if anyone has any suggestions how I can fix these?. ```; Test Summary: | Pass Error Total; Oceananigans | 18 7 25; Shallow Water Models | 18 7 25; Model constructor errors | 2 2; (Periodic, Periodic, Bounded) model construction | 6 6; (Periodic, Bounded, Bounded) model construction | 6 6; (Bounded, Bounded, Bounded) model construction | No tests; Setting ShallowWaterModel fields | 4 4; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Periodic, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Bounded, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), Nothing] | 1 1; Time-stepping ShallowWaterModels [GPU(), FPlane{Float64}] | 1 1; Time-stepping ShallowWaterModels [GPU(), BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaE",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:592,Testability,test,tests,592,"This is something that @glwagner helped me put together a while ago and I had not merged it yet. I created a new branch that does only this and tested it out. Where it ran before, I get some errors. 7 to be precise. It seems GPU related and wondered if anyone has any suggestions how I can fix these?. ```; Test Summary: | Pass Error Total; Oceananigans | 18 7 25; Shallow Water Models | 18 7 25; Model constructor errors | 2 2; (Periodic, Periodic, Bounded) model construction | 6 6; (Periodic, Bounded, Bounded) model construction | 6 6; (Bounded, Bounded, Bounded) model construction | No tests; Setting ShallowWaterModel fields | 4 4; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Periodic, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Bounded, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), Nothing] | 1 1; Time-stepping ShallowWaterModels [GPU(), FPlane{Float64}] | 1 1; Time-stepping ShallowWaterModels [GPU(), BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaE",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:1232,Testability,test,tests,1232,"This is something that @glwagner helped me put together a while ago and I had not merged it yet. I created a new branch that does only this and tested it out. Where it ran before, I get some errors. 7 to be precise. It seems GPU related and wondered if anyone has any suggestions how I can fix these?. ```; Test Summary: | Pass Error Total; Oceananigans | 18 7 25; Shallow Water Models | 18 7 25; Model constructor errors | 2 2; (Periodic, Periodic, Bounded) model construction | 6 6; (Periodic, Bounded, Bounded) model construction | 6 6; (Bounded, Bounded, Bounded) model construction | No tests; Setting ShallowWaterModel fields | 4 4; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Periodic, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Bounded, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), Nothing] | 1 1; Time-stepping ShallowWaterModels [GPU(), FPlane{Float64}] | 1 1; Time-stepping ShallowWaterModels [GPU(), BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaE",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:1360,Testability,test,test,1360,"Shallow Water Models | 18 7 25; Model constructor errors | 2 2; (Periodic, Periodic, Bounded) model construction | 6 6; (Periodic, Bounded, Bounded) model construction | 6 6; (Bounded, Bounded, Bounded) model construction | No tests; Setting ShallowWaterModel fields | 4 4; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Periodic, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), (Bounded, Bounded, Bounded)] | 1 1; Time-stepping ShallowWaterModels [GPU(), Nothing] | 1 1; Time-stepping ShallowWaterModels [GPU(), FPlane{Float64}] | 1 1; Time-stepping ShallowWaterModels [GPU(), BetaPlane{Float64}] | 1 1; Time-step Wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]] | 1 1; ERROR: LoadError: Some tests did not pass: 18 passed, 0 failed, 7 errored, 0 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:4526,Testability,test,testing,4526,"; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; [2] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, test_fn::Nothing, julia_args::Cmd, test_args::Cmd, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:327; [4] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:314; [5] #test#61 at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:67 [inlined]; [6] test at /buildworker/worker/package_linux64/build/usr/share/julia/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
