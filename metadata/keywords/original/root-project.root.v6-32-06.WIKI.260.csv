id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/root/html534/TSQLFile.html:48484,Modifiability,config,configuration,48484,"nt_t SysStat(Int_t , Long_t* , Long64_t* , Long_t* , Long_t* ); { return 0; }. Int_t SysSync(Int_t ); { return 0; }. const char* SQLSmallTextType() const; { return fOtherTypes[0]; }. Int_t SQLSmallTextTypeLimit() const; { return atoi(fOtherTypes[1]); }. const char* SQLBigTextType() const; { return fOtherTypes[2]; }. const char* SQLDatetimeType() const; { return fOtherTypes[3]; }. const char* SQLIdentifierQuote() const; { return fOtherTypes[4]; }. const char* SQLDirIdColumn() const; { return fOtherTypes[5]; }. const char* SQLKeyIdColumn() const; { return fOtherTypes[6]; }. const char* SQLObjectIdColumn() const; { return fOtherTypes[7]; }. const char* SQLRawIdColumn() const; { return fOtherTypes[8]; }. const char* SQLStrIdColumn() const; { return fOtherTypes[9]; }. const char* SQLNameSeparator() const; { return fOtherTypes[10]; }. const char* SQLValueQuote() const; { return fOtherTypes[11]; }. const char* SQLDefaultTableType() const; { return fOtherTypes[12]; }. Bool_t GetUseSuffixes() const; configuration of SQL. { return fUseSuffixes; }. Int_t GetArrayLimit() const; { return fArrayLimit; }. void SkipArrayLimit(); { SetArrayLimit(-1); }. const char* GetTablesType() const; { return fTablesType.Data(); }. Int_t GetUseTransactions() const; { return fUseTransactions; }. Int_t GetUseIndexes() const; { return fUseIndexes; }. Int_t GetQuerisCounter() const; { return fQuerisCounter; }. void DrawMap(const char* = ""*"", Option_t* = """"); {}. void FillBuffer(char*& ); {}. void Flush(); {}. Long64_t GetEND() const; { return 0; }. Int_t GetErrno() const; { return 0; }. void ResetErrno() const; {}. Int_t GetNfree() const; { return 0; }. Int_t GetNbytesInfo() const; {return 0; }. Int_t GetNbytesFree() const; {return 0; }. Long64_t GetSeekFree() const; {return 0; }. Long64_t GetSeekInfo() const; {return 0; }. Long64_t GetSize() const; { return 0; }. void MakeFree(Long64_t , Long64_t ); {}. void MakeProject(const char* , const char* = ""*"", Option_t* = ""new""); {}. void Map(); {}. void Pa",MatchSource.WIKI,root/html534/TSQLFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLFile.html
https://root.cern/root/html534/TSQLFile.html:18648,Performance,cache,cacheDir,18648,"cover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); Bool_tRollback(); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t, TFile::ERelativeTo = kBeg); voidSetArrayLimit(Int_t limit = 20); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bo",MatchSource.WIKI,root/html534/TSQLFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLFile.html
https://root.cern/root/html534/TSQLFile.html:18775,Performance,cache,cache,18775,"pen(Option_t* mode); virtual voidTDirectoryFile::ResetAfterMerge(TFileMergeInfo*); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); Bool_tRollback(); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t, TFile::ERelativeTo = kBeg); voidSetArrayLimit(Int_t limit = 20); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(B",MatchSource.WIKI,root/html534/TSQLFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLFile.html
https://root.cern/root/html534/TSQLFile.html:18894,Performance,cache,cache,18894,"tual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); Bool_tRollback(); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t, TFile::ERelativeTo = kBeg); voidSetArrayLimit(Int_t limit = 20); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = ",MatchSource.WIKI,root/html534/TSQLFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLFile.html
https://root.cern/root/html534/TSQLFile.html:28787,Performance,cache,cache,28787,,MatchSource.WIKI,root/html534/TSQLFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLFile.html
https://root.cern/root/html534/TSQLFile.html:28849,Performance,cache,cache,28849,,MatchSource.WIKI,root/html534/TSQLFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLFile.html
https://root.cern/root/html534/TSQLFile.html:28921,Performance,cache,cache,28921,,MatchSource.WIKI,root/html534/TSQLFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLFile.html
https://root.cern/root/html534/TSQLFile.html:30861,Performance,cache,cache,30861,"rue is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of objects in memory; ofstream*fLogFile! log file with SQL statements; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; Int_tfModifyCounter! indicates how many changes was done with database tables; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tTFile::fMustFlush!True if the file buffers must be flushed; Int_tTFile::fNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tTFile::fNbytesFreeNumber of bytes for free segments structure; Int_tTFile::fNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Bool_tTFile::fNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Long64_tTFile::fOffset!Seek offset cache; TList*TFile::fOpenPhases!Time info about open phases; TStringTFile::fOptionFile options; const char**fOtherTypes! pointer on list of other SQL types like TEXT or blob; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TObjArray*TFile::fProcessIDs!Array of pointers to TProcessIDs; Int_tfQuerisCounter! how many query was applied; Int_tTFile::fReadCallsNumber of read calls ( not counting the cache calls ); TStringTFile::fRealNameEffective real file name (not original url); TSQLServer*fSQL! interface to SQL database ; TList*fSQLClassInfos! list of SQL class infos; Int_tfSQLIOversion! version of SQL I/O which is stored in configurations; Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Int_tfS",MatchSource.WIKI,root/html534/TSQLFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLFile.html
https://root.cern/root/html534/TSQLFile.html:31272,Performance,cache,cache,31272,"ory; Bool_tTFile::fMustFlush!True if the file buffers must be flushed; Int_tTFile::fNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tTFile::fNbytesFreeNumber of bytes for free segments structure; Int_tTFile::fNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Bool_tTFile::fNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Long64_tTFile::fOffset!Seek offset cache; TList*TFile::fOpenPhases!Time info about open phases; TStringTFile::fOptionFile options; const char**fOtherTypes! pointer on list of other SQL types like TEXT or blob; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TObjArray*TFile::fProcessIDs!Array of pointers to TProcessIDs; Int_tfQuerisCounter! how many query was applied; Int_tTFile::fReadCallsNumber of read calls ( not counting the cache calls ); TStringTFile::fRealNameEffective real file name (not original url); TSQLServer*fSQL! interface to SQL database ; TList*fSQLClassInfos! list of SQL class infos; Int_tfSQLIOversion! version of SQL I/O which is stored in configurations; Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Int_tfStmtCounter! count numbers of active statements; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringfTablesType! type, used in CREATE TABLE statements; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!UR",MatchSource.WIKI,root/html534/TSQLFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLFile.html
https://root.cern/root/html534/TSQLFile.html:33289,Performance,cache,cache,33289,"::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringfTablesType! type, used in CREATE TABLE statements; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; Int_tfUseIndexes! use indexes for tables: 0 - off, 1 - only for basic tables, 2 + normal class tables, 3 - all tables; Bool_tfUseSuffixes! use suffixes in column names like fValue:Int_t or fObject:pointer; Int_tfUseTransactions! use transaction statements for writing data into the tables; TStringfUserName! user name, used to access objects from database; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*TFile::fgAsyncOpenRequestsList of handles for pending open requests; static Long64_tTFile::fgBytesReadNumber of bytes read by all TFile objects; static Long64_tTFile::fgBytesWriteNumber of bytes written by all TFile objects; static TStringTFile::fgCacheFileDirDirectory where to locally stage files; static Bool_tTFile::fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static Long64_tTFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tTFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size.",MatchSource.WIKI,root/html534/TSQLFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLFile.html
https://root.cern/root/html534/TSQLFile.html:33319,Performance,cache,cached,33319,"::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringfTablesType! type, used in CREATE TABLE statements; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; Int_tfUseIndexes! use indexes for tables: 0 - off, 1 - only for basic tables, 2 + normal class tables, 3 - all tables; Bool_tfUseSuffixes! use suffixes in column names like fValue:Int_t or fObject:pointer; Int_tfUseTransactions! use transaction statements for writing data into the tables; TStringfUserName! user name, used to access objects from database; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*TFile::fgAsyncOpenRequestsList of handles for pending open requests; static Long64_tTFile::fgBytesReadNumber of bytes read by all TFile objects; static Long64_tTFile::fgBytesWriteNumber of bytes written by all TFile objects; static TStringTFile::fgCacheFileDirDirectory where to locally stage files; static Bool_tTFile::fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static Long64_tTFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static Int_tTFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size.",MatchSource.WIKI,root/html534/TSQLFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLFile.html
https://root.cern/root/html534/TSQLFile.html:2124,Safety,avoid,avoid,2124,"able ""ObjectsTable"".; In this there are following columns:; ""key:id"" - key identifier to which belong object; ""obj:id"" - object identifier; ""Class"" - object class name; ""Version"" - object class version; Data in each ""ObjectsTable"" row uniqly identify, in which table; and which column object is stored. In normal situation all class data should be sorted columnwise.; Up to now following member are supported:; 1) Basic data types; Here is everything clear. Column SQL type will be as much as possible; close to the original type of value.; 2) Fixed array of basic data types; In this case n columns like fArr[0], fArr[1] and so on will be created.; If there is multidimensional array, names will be fArr2[1][2][1] and so on; 3) Parent class; In this case version of parent class is stored and; data of parent class will be stored with the same obj:id in corrspondent table.; There is a special case, when parent store nothing (this is for instance TQObject).; In that case just -1 is written to avoid any extra checks if table exist or not.; 4) Object as data member.; In that case object is saved in normal way to data base and column; will contain id of this object.; 5) Pointer on object; Same as before. In case if object was already stored, just its id; will be placed in the column. For NULL pointer 0 is used.; 6) TString; Now column with limited width like VARCAHR(255) in MySQL is used.; Later this will be improved to support maximum possible strings; 7) Anything else.; Data will be converted to raw format and saved in _streamer_ table.; Each row supplied with obj:id and row:id, where row:id indicates; data, corresponding to this particular data member, and column; will contain this raw:id. All conversion to SQL statements are done with help of TSQLStructure class.; This is special hierarchical structure wich internally is very similar; to XML structures. TBufferSQL2 creates these structures, when object; data is streamed by ROOT and only afterwards all SQL statements will be pr",MatchSource.WIKI,root/html534/TSQLFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLFile.html
https://root.cern/root/html534/TSQLFile.html:4365,Safety,detect,detects,4365,", column contain class version; *:object - other object, column contain object id; *:rawdata - raw data, column contains id of raw data from _streamer_ table; *:Int_t - column with integer value; Use TSQLFile::SetUseSuffixes(kFALSE) to disable suffixes usage. This and several other options can be changed only when; TSQLFile created with options ""CREATE"" or ""RECREATE"" and only before; first write operation. These options are:; SetUseSuffixes() - suffix usage in column names (default - on); SetArrayLimit() - defines maximum array size, which can; has column for each element (default 21); SetTablesType() - table type name in MySQL database (default ""InnoDB""); SetUseIndexes() - usage of indexes in database (default kIndexesBasic); Normally these functions should be called immidiately after TSQLFile constructor. When objects data written to database, by default START TRANSACTION/COMMIT; SQL commands are used before and after data storage. If TSQLFile detects; any problems, ROLLBACK command will be used to restore; previous state of data base. If transactions not supported by SQL server,; they can be disabled by SetUseTransactions(kTransactionsOff). Or user; can take responsibility to use transactions function to hime. By default only indexes for basic tables are created.; In most cases usage of indexes increase perfomance to data reading,; but it also can increase time of writing data to database.; There are several modes of index usage available in SetUseIndexes() method. There is MakeSelectQuery(TClass*) method, which; produces SELECT statement to get objects data of specified class.; Difference from simple statement like:; mysql> SELECT * FROM TH1I_ver1; that not only data for that class, but also data from parent classes; will be extracted from other tables and combined in single result table.; Such select query can be usufull for external access to objects data. Up to now MySQL 4.1 and Oracle 9i were tested.; Some extra work is required for other SQL databases.; Hop",MatchSource.WIKI,root/html534/TSQLFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLFile.html
https://root.cern/root/html534/TSQLFile.html:19839,Safety,timeout,timeout,19839," virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_t* option = "">""); static voidTFile::SetReadaheadSize(Int_t bufsize = 256000); virtual voidTFile::SetReadCalls(Int_t readcalls = 0); static voidTFile::SetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDirectoryFile::SetSeekDir(Long64_t v); voidSetTablesType(const char* table_type); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTDirectoryFile::SetTRefAction(TObject* ref, TObject* parent); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetUseIndexes(Int_t use_type = kIndexesBasic); voidSetUseSuffixes(Bool_t on = kTRUE); voidSetUseTransactions(Int_t mode = kTransactionsAuto); virtual voidTDirectoryFile::SetWritable(Bool_t writable = kTRUE); virtual voidShowMembers(TMemberInspector&); virtual voidTFile::ShowStreamerInfo(); static Bool_tTFile::ShrinkCacheFileDir(Long64_t shrinkSize, Long_t cleanupInteval = 0); virtual Int_tSizeof() const; voidSkipArrayLimit(); voidStartLogFile(const char* fname)MENU ; Bool_tStartT",MatchSource.WIKI,root/html534/TSQLFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLFile.html
https://root.cern/root/html534/TSQLFile.html:355,Security,access,access,355,". TSQLFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » SQL; » TSQLFile. class TSQLFile: public TFile. The main motivation for the TSQLFile development is to have; ""transparent"" access to SQL data base via standard TFile interface. The main approach that each class (but not each object) has one or two tables; with names like $(CLASSNAME)_ver$(VERSION) and $(CLASSNAME)_raw$(VERSION); For example: TAxis_ver8 or TList_raw5; Second kind of tables appears, when some of class members can not be converted to; normalized form or when class has custom streamer.; For instance, for TH1 class two tables are required: TH1_ver4 and TH1_raw4; Most of memebers are stored in TH1_ver4 table columnwise, and only memeber:. Double_t* fBuffer; //[fBufferSize]. can not be represented as column while size of array is not known apriory.; Therefore, fBuffer will be written as list of values in TH1_raw4 table. All objects, stored in the DB, will be registered in table ""ObjectsTable"".; In this there are following columns:; ""key:id"" - key identifier to which belong object; ""obj:id"" - object identifier; ""Class"" - object class name; ""Version"" - object class version; Data in each ""ObjectsTable"" row uniqly identify, in which table; and which column object is stored. In normal situation all class data should be sorted columnwise.; Up to now following member are supported:; 1) Basic data types; Here is everything clear. Column SQL type will be as much as possible; close to the original type of value.; 2) Fixed array of basic data types; In this case n columns like fArr[0], fArr[1] and so on will be created.; If there is multidimensional array, names will be fArr2[1][2][1] and so on; 3) Parent class; In this case version of parent class is stored and; data of parent class will be stored with the same obj:id in corrspondent table",MatchSource.WIKI,root/html534/TSQLFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLFile.html
https://root.cern/root/html534/TSQLFile.html:5276,Security,access,access,5276,"by default START TRANSACTION/COMMIT; SQL commands are used before and after data storage. If TSQLFile detects; any problems, ROLLBACK command will be used to restore; previous state of data base. If transactions not supported by SQL server,; they can be disabled by SetUseTransactions(kTransactionsOff). Or user; can take responsibility to use transactions function to hime. By default only indexes for basic tables are created.; In most cases usage of indexes increase perfomance to data reading,; but it also can increase time of writing data to database.; There are several modes of index usage available in SetUseIndexes() method. There is MakeSelectQuery(TClass*) method, which; produces SELECT statement to get objects data of specified class.; Difference from simple statement like:; mysql> SELECT * FROM TH1I_ver1; that not only data for that class, but also data from parent classes; will be extracted from other tables and combined in single result table.; Such select query can be usufull for external access to objects data. Up to now MySQL 4.1 and Oracle 9i were tested.; Some extra work is required for other SQL databases.; Hopefully, this should be straigthforward. Known problems and open questions.; 1) TTree is not supported by TSQLFile. There is independent development; of TTreeSQL class, which allows to store trees directly in SQL database; 2) TClonesArray is store objects in raw format,; which can not be accessed outside ROOT.; This will be changed later.; 3) TDirectory cannot work. Hopefully, will (changes in ROOT basic I/O is required); 4) Streamer infos are not written to file, therefore schema evolution; is not yet supported. All eforts are done to enable this feature in; the near future. Example how TSQLFile can be used:. example of a session saving data to a SQL data base. const char* dbname = ""mysql://host.domain:3306/dbname"";; const char* username = ""username"";; const char* userpass = ""userpass"";. // Clean data base and create primary tables; TSQLFile* f = ",MatchSource.WIKI,root/html534/TSQLFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLFile.html
https://root.cern/root/html534/TSQLFile.html:5693,Security,access,accessed,5693,"ns function to hime. By default only indexes for basic tables are created.; In most cases usage of indexes increase perfomance to data reading,; but it also can increase time of writing data to database.; There are several modes of index usage available in SetUseIndexes() method. There is MakeSelectQuery(TClass*) method, which; produces SELECT statement to get objects data of specified class.; Difference from simple statement like:; mysql> SELECT * FROM TH1I_ver1; that not only data for that class, but also data from parent classes; will be extracted from other tables and combined in single result table.; Such select query can be usufull for external access to objects data. Up to now MySQL 4.1 and Oracle 9i were tested.; Some extra work is required for other SQL databases.; Hopefully, this should be straigthforward. Known problems and open questions.; 1) TTree is not supported by TSQLFile. There is independent development; of TTreeSQL class, which allows to store trees directly in SQL database; 2) TClonesArray is store objects in raw format,; which can not be accessed outside ROOT.; This will be changed later.; 3) TDirectory cannot work. Hopefully, will (changes in ROOT basic I/O is required); 4) Streamer infos are not written to file, therefore schema evolution; is not yet supported. All eforts are done to enable this feature in; the near future. Example how TSQLFile can be used:. example of a session saving data to a SQL data base. const char* dbname = ""mysql://host.domain:3306/dbname"";; const char* username = ""username"";; const char* userpass = ""userpass"";. // Clean data base and create primary tables; TSQLFile* f = new TSQLFile(dbname, ""recreate"", username, userpass);; // Write with standard I/O functions; arr->Write(""arr"", TObject::kSingleKey);; h1->Write(""histo"");; // Close connection to DB; delete f;. example of a session read data from SQL data base. // Open database again in read-only mode; TSQLFile* f = new TSQLFile(dbname, ""open"", username, userpass);; //",MatchSource.WIKI,root/html534/TSQLFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLFile.html
https://root.cern/root/html534/TSQLFile.html:32613,Security,access,access,32613," on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Int_tfStmtCounter! count numbers of active statements; Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringfTablesType! type, used in CREATE TABLE statements; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; Int_tfUseIndexes! use indexes for tables: 0 - off, 1 - only for basic tables, 2 + normal class tables, 3 - all tables; Bool_tfUseSuffixes! use suffixes in column names like fValue:Int_t or fObject:pointer; Int_tfUseTransactions! use transaction statements for writing data into the tables; TStringfUserName! user name, used to access objects from database; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*TFile::fgAsyncOpenRequestsList of handles for pending open requests; static Long64_tTFile::fgBytesReadNumber of bytes read by all TFile objects; static Long64_tTFile::fgBytesWriteNumber of bytes written by all TFile objects; static TStringTFile::fgCacheFileDirDirectory where to locally stage files; static Bool_tTFile::fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static Long64_tTFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile",MatchSource.WIKI,root/html534/TSQLFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLFile.html
https://root.cern/root/html534/TSQLFile.html:34647,Security,access,access,34647,"0 corresponds to blocking i/o; static Int_tTFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSQLFile(); default TSQLFile constructor. TSQLFile(const char* dbname, Option_t* option = ""read"", const char* user = ""user"", const char* pass = ""pass""); Connects to SQL server with provided arguments.; If the constructor fails in any way IsZombie() will; return true. Use IsOpen() to check if the file is (still) open. If option = NEW or CREATE create a ROOT tables in database; if the tables already exists connection is; not opened.; = RECREATE create completely new tables. Any existing tables; will be deleted; = UPDATE open an existing database for writing.; If data base open by other TSQLFile instance for writing,; write access will be rejected; = BREAKLOCK Special case when lock was not correctly released; by TSQLFile instance. This may happen if program crashed when; TSQLFile was open with write access mode.; = READ or OPEN open an existing data base for reading. For more details see comments for TFile::TFile() constructor. For a moment TSQLFile does not support TTree objects and subdirectories. void StartLogFile(const char* fname); start logging of all SQL statements in specified file. void StopLogFile(); close logging file. Bool_t IsMySQL() const; checks, if MySQL database. Bool_t IsOracle() const; checks, if Oracle database. Bool_t IsODBC() const; checks, if ODBC driver used for database connection. void SetUseSuffixes(Bool_t on = kTRUE); enable/disable uasge of suffixes in columns names; can be changed before first object is saved into file. void SetArrayLimit(Int_t limit = 20); Defines maximum number of columns for array representation; If array size bigger than limit, array data will be converted to raw format; Thi",MatchSource.WIKI,root/html534/TSQLFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLFile.html
https://root.cern/root/html534/TSQLFile.html:34827,Security,access,access,34827,"eadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSQLFile(); default TSQLFile constructor. TSQLFile(const char* dbname, Option_t* option = ""read"", const char* user = ""user"", const char* pass = ""pass""); Connects to SQL server with provided arguments.; If the constructor fails in any way IsZombie() will; return true. Use IsOpen() to check if the file is (still) open. If option = NEW or CREATE create a ROOT tables in database; if the tables already exists connection is; not opened.; = RECREATE create completely new tables. Any existing tables; will be deleted; = UPDATE open an existing database for writing.; If data base open by other TSQLFile instance for writing,; write access will be rejected; = BREAKLOCK Special case when lock was not correctly released; by TSQLFile instance. This may happen if program crashed when; TSQLFile was open with write access mode.; = READ or OPEN open an existing data base for reading. For more details see comments for TFile::TFile() constructor. For a moment TSQLFile does not support TTree objects and subdirectories. void StartLogFile(const char* fname); start logging of all SQL statements in specified file. void StopLogFile(); close logging file. Bool_t IsMySQL() const; checks, if MySQL database. Bool_t IsOracle() const; checks, if Oracle database. Bool_t IsODBC() const; checks, if ODBC driver used for database connection. void SetUseSuffixes(Bool_t on = kTRUE); enable/disable uasge of suffixes in columns names; can be changed before first object is saved into file. void SetArrayLimit(Int_t limit = 20); Defines maximum number of columns for array representation; If array size bigger than limit, array data will be converted to raw format; This is usefull to prevent tables with very big number of columns; If limit==0, all arrays will be stored in raw format; If limit<0, ",MatchSource.WIKI,root/html534/TSQLFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLFile.html
https://root.cern/root/html534/TSQLFile.html:37993,Security,access,access,37993,"This can be usesfull, when big number of objects should be stored in; data base and commitment required only if all operations were successful.; In that case in the end of all operations method Commit() should be; called. If operation on user-level is looks like not successfull,; method Rollback() will return database data and TSQLFile instance to; previous state.; In MySQL not all tables types support transaction mode of operation.; See SetTablesType() method for details . Bool_t Commit(); Commit transaction, started by StartTransaction() call.; Only after that call data will be written and visible on database side. Bool_t Rollback(); Rollback all operations, done after StartTransaction() call.; Database should return to initial state. void SetUseIndexes(Int_t use_type = kIndexesBasic); Specify usage of indexes for data tables; kIndexesNone = 0 - no indexes are used; kIndexesBasic = 1 - indexes used only for keys list and; objects list tables (default); kIndexesClass = 2 - index also created for every normal class table; kIndexesAll = 3 - index created for every table, including _streamer_ tables; Indexes in general should increase speed of access to objects data,; but they required more operations and more disk space on server side. const char* GetDataBaseName() const; Return name of data base on the host; For Oracle always return 0. void Close(Option_t* option = """"); Close a SQL file; For more comments see TFile::Close() function. ~TSQLFile(); destructor of TSQLFile object. void operator=(const TSQLFile& ); make private to exclude copy operator. Bool_t IsOpen() const; return kTRUE if file is opened and can be accessed. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; See TFile::Open() for details. TKey* CreateKey(TDirectory* mother, const TObject* obj, const char* name, Int_t bufsize); create SQL key, which will store object in data base. TKey* CreateKey(TDirectory* mother, const void* obj, const TClass* cl, const char*",MatchSource.WIKI,root/html534/TSQLFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLFile.html
https://root.cern/root/html534/TSQLFile.html:38473,Security,access,accessed,38473,"atabase side. Bool_t Rollback(); Rollback all operations, done after StartTransaction() call.; Database should return to initial state. void SetUseIndexes(Int_t use_type = kIndexesBasic); Specify usage of indexes for data tables; kIndexesNone = 0 - no indexes are used; kIndexesBasic = 1 - indexes used only for keys list and; objects list tables (default); kIndexesClass = 2 - index also created for every normal class table; kIndexesAll = 3 - index created for every table, including _streamer_ tables; Indexes in general should increase speed of access to objects data,; but they required more operations and more disk space on server side. const char* GetDataBaseName() const; Return name of data base on the host; For Oracle always return 0. void Close(Option_t* option = """"); Close a SQL file; For more comments see TFile::Close() function. ~TSQLFile(); destructor of TSQLFile object. void operator=(const TSQLFile& ); make private to exclude copy operator. Bool_t IsOpen() const; return kTRUE if file is opened and can be accessed. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; See TFile::Open() for details. TKey* CreateKey(TDirectory* mother, const TObject* obj, const char* name, Int_t bufsize); create SQL key, which will store object in data base. TKey* CreateKey(TDirectory* mother, const void* obj, const TClass* cl, const char* name, Int_t bufsize); create SQL key, which will store object in data base. void WriteHeader(); Write file info like configurations, title, UUID and other. void WriteStreamerInfo(); Store all TVirtualStreamerInfo, used in file, in sql database. Bool_t WriteSpecialObject(Long64_t keyid, TObject* obj, const char* name, const char* title); write special kind of object like streamer infos or file itself; keys for that objects should exist in tables but not indicated in list of keys,; therefore users can not get them with TDirectoryFile::Get() method. TObject* ReadSpecialObject(Long64_t keyid, TObject* obj = ",MatchSource.WIKI,root/html534/TSQLFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLFile.html
https://root.cern/root/html534/TSQLFile.html:38544,Security,access,access,38544,"ase should return to initial state. void SetUseIndexes(Int_t use_type = kIndexesBasic); Specify usage of indexes for data tables; kIndexesNone = 0 - no indexes are used; kIndexesBasic = 1 - indexes used only for keys list and; objects list tables (default); kIndexesClass = 2 - index also created for every normal class table; kIndexesAll = 3 - index created for every table, including _streamer_ tables; Indexes in general should increase speed of access to objects data,; but they required more operations and more disk space on server side. const char* GetDataBaseName() const; Return name of data base on the host; For Oracle always return 0. void Close(Option_t* option = """"); Close a SQL file; For more comments see TFile::Close() function. ~TSQLFile(); destructor of TSQLFile object. void operator=(const TSQLFile& ); make private to exclude copy operator. Bool_t IsOpen() const; return kTRUE if file is opened and can be accessed. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; See TFile::Open() for details. TKey* CreateKey(TDirectory* mother, const TObject* obj, const char* name, Int_t bufsize); create SQL key, which will store object in data base. TKey* CreateKey(TDirectory* mother, const void* obj, const TClass* cl, const char* name, Int_t bufsize); create SQL key, which will store object in data base. void WriteHeader(); Write file info like configurations, title, UUID and other. void WriteStreamerInfo(); Store all TVirtualStreamerInfo, used in file, in sql database. Bool_t WriteSpecialObject(Long64_t keyid, TObject* obj, const char* name, const char* title); write special kind of object like streamer infos or file itself; keys for that objects should exist in tables but not indicated in list of keys,; therefore users can not get them with TDirectoryFile::Get() method. TObject* ReadSpecialObject(Long64_t keyid, TObject* obj = 0); Read data of special kind of objects. TList* GetStreamerInfoList(); Read back streamer infos fr",MatchSource.WIKI,root/html534/TSQLFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLFile.html
https://root.cern/root/html534/TSQLFile.html:41651,Security,access,access,41651,"TSQLFile for the same data base; will be connected. TString MakeSelectQuery(TClass* cl); Produce SELECT statement which can be used to get all data; of class cl in one SELECT statement; This statement also can be used to create VIEW by command like; mysql> CREATE VIEW TH1I_view AS $CLASSSELECT$; Where $CLASSSELECT$ argument should be produced by call; f->MakeSelectQuery(TH1I::Class());; VIEWs supported by latest MySQL 5 and Oracle. Bool_t ProduceClassSelectQuery(TVirtualStreamerInfo* info, TSQLClassInfo* sqlinfo, TString& columns, TString& tables, Int_t& tablecnt); used by MakeClassSelectQuery method to add columns from table of; class, specified by TVirtualStreamerInfo structure. Bool_t IsTablesExists(); Checks if main keys table is existing. Bool_t IsWriteAccess(); Checkis, if lock is free in configuration tables. void SetLocking(Int_t mode); Set locking mode for current database. Int_t GetLocking(); Return current locking mode for that file. Bool_t IsReadAccess(); dummy, in future should check about read access to database. TSQLResult* SQLQuery(const char* cmd, Int_t flag = 0, Bool_t* res = 0); submits query to SQL server; if flag==0, result is not interesting and will be deleted; if flag==1, return result of submitted query; if flag==2, results is may be necessary for long time; Oracle plugin do not support working with several TSQLResult; objects, therefore explicit deep copy will be produced; If ok!=0, it will contains kTRUE is Query was successfull, otherwise kFALSE. Bool_t SQLCanStatement(); Test if DB support statement and number of open statements is not exceeded. TSQLStatement* SQLStatement(const char* cmd, Int_t bufsize = 1000); Produces SQL statement for currently conected DB server. void SQLDeleteStatement(TSQLStatement* stmt); delete statement and decrease counter. Bool_t SQLApplyCommands(TObjArray* cmds); supplies set of commands to server; Commands is stored as array of TObjString. Bool_t SQLTestTable(const char* tablename); Test, if table of specif",MatchSource.WIKI,root/html534/TSQLFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLFile.html
https://root.cern/root/html534/TSQLFile.html:46337,Security,access,access,46337,"); Checks that objects table is exists; If not, table will be created; Returns maximum value for existing objects id. Bool_t SQLObjectInfo(Long64_t objid, TString& clname, Version_t& version); Read from objects table data for specified objectid. TObjArray* SQLObjectsInfo(Long64_t keyid); Produce array of TSQLObjectInfo objects for all objects, belong to that key; Array should be deleted by calling function afterwards. TSQLResult* GetNormalClassData(Long64_t objid, TSQLClassInfo* sqlinfo); Method return request result for specified objid from normal classtable. TSQLResult* GetNormalClassDataAll(Long64_t minobjid, Long64_t maxobjid, TSQLClassInfo* sqlinfo); return data for several objects from the range from normal class table. TSQLResult* GetBlobClassData(Long64_t objid, TSQLClassInfo* sqlinfo); Method return request results for specified objid from _streamer_ classtable. TSQLStatement* GetBlobClassDataStmt(Long64_t objid, TSQLClassInfo* sqlinfo); Method return request results for specified objid from _streamer_ classtable; Data returned in form of statement, where direct access to values are possible. Long64_t StoreObjectInTables(Long64_t keyid, const void* obj, const TClass* cl); Store object in database. Return stored object id or -1 if error. const char* SQLCompatibleType(Int_t typ) const; returns sql type name which is most closer to ROOT basic type; typ should be from TVirtualStreamerInfo:: constansts like TVirtualStreamerInfo::kInt. const char* SQLIntType() const; return SQL integer type. Long64_t DirCreateEntry(TDirectory* ); Create entry for directory in database. Int_t DirReadKeys(TDirectory* ); Read directory list of keys from database. void DirWriteKeys(TDirectory* ); Write directory keys list to database. void DirWriteHeader(TDirectory* ); Update dir header in the file. void Streamer(TBuffer& ); streamer for TSQLFile class; stores only data for TDirectory. Int_t SysOpen(const char* , Int_t , UInt_t ); Interface to basic system I/O routines, suppressed. { ",MatchSource.WIKI,root/html534/TSQLFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLFile.html
https://root.cern/root/html534/TSQLFile.html:5339,Testability,test,tested,5339," after data storage. If TSQLFile detects; any problems, ROLLBACK command will be used to restore; previous state of data base. If transactions not supported by SQL server,; they can be disabled by SetUseTransactions(kTransactionsOff). Or user; can take responsibility to use transactions function to hime. By default only indexes for basic tables are created.; In most cases usage of indexes increase perfomance to data reading,; but it also can increase time of writing data to database.; There are several modes of index usage available in SetUseIndexes() method. There is MakeSelectQuery(TClass*) method, which; produces SELECT statement to get objects data of specified class.; Difference from simple statement like:; mysql> SELECT * FROM TH1I_ver1; that not only data for that class, but also data from parent classes; will be extracted from other tables and combined in single result table.; Such select query can be usufull for external access to objects data. Up to now MySQL 4.1 and Oracle 9i were tested.; Some extra work is required for other SQL databases.; Hopefully, this should be straigthforward. Known problems and open questions.; 1) TTree is not supported by TSQLFile. There is independent development; of TTreeSQL class, which allows to store trees directly in SQL database; 2) TClonesArray is store objects in raw format,; which can not be accessed outside ROOT.; This will be changed later.; 3) TDirectory cannot work. Hopefully, will (changes in ROOT basic I/O is required); 4) Streamer infos are not written to file, therefore schema evolution; is not yet supported. All eforts are done to enable this feature in; the near future. Example how TSQLFile can be used:. example of a session saving data to a SQL data base. const char* dbname = ""mysql://host.domain:3306/dbname"";; const char* username = ""username"";; const char* userpass = ""userpass"";. // Clean data base and create primary tables; TSQLFile* f = new TSQLFile(dbname, ""recreate"", username, userpass);; // Write with",MatchSource.WIKI,root/html534/TSQLFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLFile.html
https://root.cern/root/html534/TSQLFile.html:30040,Testability,log,log,30040,"ssIndex!Index of TStreamerInfo classes written to this file; Int_tTFile::fCompressCompression level and algorithm; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; Int_tTFile::fDFile descriptor; TDatimeTDirectoryFile::fDatimeCDate and time when directory is created; TDatimeTDirectoryFile::fDatimeMDate and time of last modification; Long64_tTFile::fENDLast used byte in file; TFile*TDirectoryFile::fFilepointer to current file in memory; TList*TFile::fFreeFree segments linked list table; Bool_tfIdsTableExists! indicate if IdsTable exists; TList*TFile::fInfoCache!Cached list of the streamer infos in this file; Bool_tTFile::fInitDone!True if the file has been initialized; Bool_tTFile::fIsArchive!True if this is a pure archive file; Bool_tTFile::fIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of objects in memory; ofstream*fLogFile! log file with SQL statements; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; Int_tfModifyCounter! indicates how many changes was done with database tables; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tTFile::fMustFlush!True if the file buffers must be flushed; Int_tTFile::fNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tTFile::fNbytesFreeNumber of bytes for free segments structure; Int_tTFile::fNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Bool_tTFile::fNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Long64_tTFile::fOffset!Seek offset cache; TList*TFile::fOpenPhases!Time info about open phases; TStringTFile::fOptionFile options; const char**fOtherTypes! pointer on list of other SQL types like TEXT or blob; TStrin",MatchSource.WIKI,root/html534/TSQLFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLFile.html
https://root.cern/root/html534/TSQLFile.html:35075,Testability,log,logging,35075,"har* dbname, Option_t* option = ""read"", const char* user = ""user"", const char* pass = ""pass""); Connects to SQL server with provided arguments.; If the constructor fails in any way IsZombie() will; return true. Use IsOpen() to check if the file is (still) open. If option = NEW or CREATE create a ROOT tables in database; if the tables already exists connection is; not opened.; = RECREATE create completely new tables. Any existing tables; will be deleted; = UPDATE open an existing database for writing.; If data base open by other TSQLFile instance for writing,; write access will be rejected; = BREAKLOCK Special case when lock was not correctly released; by TSQLFile instance. This may happen if program crashed when; TSQLFile was open with write access mode.; = READ or OPEN open an existing data base for reading. For more details see comments for TFile::TFile() constructor. For a moment TSQLFile does not support TTree objects and subdirectories. void StartLogFile(const char* fname); start logging of all SQL statements in specified file. void StopLogFile(); close logging file. Bool_t IsMySQL() const; checks, if MySQL database. Bool_t IsOracle() const; checks, if Oracle database. Bool_t IsODBC() const; checks, if ODBC driver used for database connection. void SetUseSuffixes(Bool_t on = kTRUE); enable/disable uasge of suffixes in columns names; can be changed before first object is saved into file. void SetArrayLimit(Int_t limit = 20); Defines maximum number of columns for array representation; If array size bigger than limit, array data will be converted to raw format; This is usefull to prevent tables with very big number of columns; If limit==0, all arrays will be stored in raw format; If limit<0, all array values will be stored in column form; Default value is 21. void SetTablesType(const char* table_type); Defines tables type, which is used in CREATE TABLE statements; Now is only used for MySQL database, where following types are supported:; ""BDB"", ""HEAP"", ""ISAM"", ""Inno",MatchSource.WIKI,root/html534/TSQLFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLFile.html
https://root.cern/root/html534/TSQLFile.html:35150,Testability,log,logging,35150,"const char* pass = ""pass""); Connects to SQL server with provided arguments.; If the constructor fails in any way IsZombie() will; return true. Use IsOpen() to check if the file is (still) open. If option = NEW or CREATE create a ROOT tables in database; if the tables already exists connection is; not opened.; = RECREATE create completely new tables. Any existing tables; will be deleted; = UPDATE open an existing database for writing.; If data base open by other TSQLFile instance for writing,; write access will be rejected; = BREAKLOCK Special case when lock was not correctly released; by TSQLFile instance. This may happen if program crashed when; TSQLFile was open with write access mode.; = READ or OPEN open an existing data base for reading. For more details see comments for TFile::TFile() constructor. For a moment TSQLFile does not support TTree objects and subdirectories. void StartLogFile(const char* fname); start logging of all SQL statements in specified file. void StopLogFile(); close logging file. Bool_t IsMySQL() const; checks, if MySQL database. Bool_t IsOracle() const; checks, if Oracle database. Bool_t IsODBC() const; checks, if ODBC driver used for database connection. void SetUseSuffixes(Bool_t on = kTRUE); enable/disable uasge of suffixes in columns names; can be changed before first object is saved into file. void SetArrayLimit(Int_t limit = 20); Defines maximum number of columns for array representation; If array size bigger than limit, array data will be converted to raw format; This is usefull to prevent tables with very big number of columns; If limit==0, all arrays will be stored in raw format; If limit<0, all array values will be stored in column form; Default value is 21. void SetTablesType(const char* table_type); Defines tables type, which is used in CREATE TABLE statements; Now is only used for MySQL database, where following types are supported:; ""BDB"", ""HEAP"", ""ISAM"", ""InnoDB"", ""MERGE"", ""MRG_MYISAM"", ""MYISAM""; Default for TSQLFile is ""Inn",MatchSource.WIKI,root/html534/TSQLFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLFile.html
https://root.cern/root/html534/TSQLFile.html:44122,Testability,test,test,44122,"gth of identifiers. void DeleteKeyFromDB(Long64_t keyid); remove key with specified id from keys table; also removes all objects data, related to this table. TKeySQL* FindSQLKey(TDirectory* dir, Long64_t keyid); Search for TKeySQL object with specified keyid. Bool_t WriteKeyData(TKeySQL* key); add entry into keys table. Bool_t UpdateKeyData(TKeySQL* key); updates (overwrites) key data in KeysTable. Long64_t DefineNextKeyId(); Returns next possible key identifier. TSQLClassInfo* FindSQLClassInfo(const char* clname, Int_t version); return (if exists) TSQLClassInfo for specified class name and version. TSQLClassInfo* FindSQLClassInfo(const TClass* cl); return (if exists) TSQLClassInfo for specified class. TSQLClassInfo* RequestSQLClassInfo(const char* clname, Int_t version); search in database tables for specified class and return TSQLClassInfo object. TString DefineTableName(const char* clname, Int_t version, Bool_t rawtable); proposes table name for class. Bool_t HasTable(const char* name); test if table name exists. TSQLClassInfo* RequestSQLClassInfo(const TClass* cl); search in database tables for specified class and return TSQLClassInfo object. void ReadSQLClassInfos(); Read all class infos from IdsTable. void AddIdEntry(Long64_t tableid, Int_t subid, Int_t type, const char* name, const char* sqlname, const char* info); Add entry into IdsTable, where all tables names and columns names are listed. Bool_t CreateClassTable(TSQLClassInfo* sqlinfo, TObjArray* colinfos); Create normal class table if required. Bool_t CreateRawTable(TSQLClassInfo* sqlinfo); create the raw table. Bool_t VerifyLongStringTable(); Checks that table for big strings is exists; If not, will be created. TString CodeLongString(Long64_t objid, Int_t strid); produces id which will be placed in column instead of string itself. Int_t IsLongStringCode(Long64_t objid, const char* value); checks if this is long string code; returns 0, if not or string id. Bool_t GetLongString(Long64_t objid, Int_t strid,",MatchSource.WIKI,root/html534/TSQLFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLFile.html
https://root.cern/root/html534/TSQLFile.html:1579,Usability,clear,clear,1579,"ASSNAME)_raw$(VERSION); For example: TAxis_ver8 or TList_raw5; Second kind of tables appears, when some of class members can not be converted to; normalized form or when class has custom streamer.; For instance, for TH1 class two tables are required: TH1_ver4 and TH1_raw4; Most of memebers are stored in TH1_ver4 table columnwise, and only memeber:. Double_t* fBuffer; //[fBufferSize]. can not be represented as column while size of array is not known apriory.; Therefore, fBuffer will be written as list of values in TH1_raw4 table. All objects, stored in the DB, will be registered in table ""ObjectsTable"".; In this there are following columns:; ""key:id"" - key identifier to which belong object; ""obj:id"" - object identifier; ""Class"" - object class name; ""Version"" - object class version; Data in each ""ObjectsTable"" row uniqly identify, in which table; and which column object is stored. In normal situation all class data should be sorted columnwise.; Up to now following member are supported:; 1) Basic data types; Here is everything clear. Column SQL type will be as much as possible; close to the original type of value.; 2) Fixed array of basic data types; In this case n columns like fArr[0], fArr[1] and so on will be created.; If there is multidimensional array, names will be fArr2[1][2][1] and so on; 3) Parent class; In this case version of parent class is stored and; data of parent class will be stored with the same obj:id in corrspondent table.; There is a special case, when parent store nothing (this is for instance TQObject).; In that case just -1 is written to avoid any extra checks if table exist or not.; 4) Object as data member.; In that case object is saved in normal way to data base and column; will contain id of this object.; 5) Pointer on object; Same as before. In case if object was already stored, just its id; will be placed in the column. For NULL pointer 0 is used.; 6) TString; Now column with limited width like VARCAHR(255) in MySQL is used.; Later this wil",MatchSource.WIKI,root/html534/TSQLFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLFile.html
https://root.cern/root/html534/TSQLFile.html:5030,Usability,simpl,simple,5030,"fault kIndexesBasic); Normally these functions should be called immidiately after TSQLFile constructor. When objects data written to database, by default START TRANSACTION/COMMIT; SQL commands are used before and after data storage. If TSQLFile detects; any problems, ROLLBACK command will be used to restore; previous state of data base. If transactions not supported by SQL server,; they can be disabled by SetUseTransactions(kTransactionsOff). Or user; can take responsibility to use transactions function to hime. By default only indexes for basic tables are created.; In most cases usage of indexes increase perfomance to data reading,; but it also can increase time of writing data to database.; There are several modes of index usage available in SetUseIndexes() method. There is MakeSelectQuery(TClass*) method, which; produces SELECT statement to get objects data of specified class.; Difference from simple statement like:; mysql> SELECT * FROM TH1I_ver1; that not only data for that class, but also data from parent classes; will be extracted from other tables and combined in single result table.; Such select query can be usufull for external access to objects data. Up to now MySQL 4.1 and Oracle 9i were tested.; Some extra work is required for other SQL databases.; Hopefully, this should be straigthforward. Known problems and open questions.; 1) TTree is not supported by TSQLFile. There is independent development; of TTreeSQL class, which allows to store trees directly in SQL database; 2) TClonesArray is store objects in raw format,; which can not be accessed outside ROOT.; This will be changed later.; 3) TDirectory cannot work. Hopefully, will (changes in ROOT basic I/O is required); 4) Streamer infos are not written to file, therefore schema evolution; is not yet supported. All eforts are done to enable this feature in; the near future. Example how TSQLFile can be used:. example of a session saving data to a SQL data base. const char* dbname = ""mysql://host.domain:330",MatchSource.WIKI,root/html534/TSQLFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLFile.html
https://root.cern/root/html534/TSQLMonitoringWriter.html:1460,Availability,error,error,1460," char* user, const char* pass, const char* table); virtual~TSQLMonitoringWriter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObj",MatchSource.WIKI,root/html534/TSQLMonitoringWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLMonitoringWriter.html
https://root.cern/root/html534/TSQLMonitoringWriter.html:1544,Availability,error,error,1544,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(",MatchSource.WIKI,root/html534/TSQLMonitoringWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLMonitoringWriter.html
https://root.cern/root/html534/TSQLMonitoringWriter.html:6859,Deployability,toggle,toggle,6859,"(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidVerbose(Bool_t onoff); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TSQLMonitoringWriter(const TSQLMonitoringWriter&); TSQLMonitoringWriter&operator=(const TSQLMonitoringWriter&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TList*TVirtualMonitoringWriter::fTmpOpenPhasesTo store open phases when there is not yet an object. private:. TSQLServer*fDBSQL database where to write; Long64_tfMaxBulkSizeMax packet size for insertions; TStringfTableSQL table name; Bool_tfVerboseVerbosity toggle. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSQLMonitoringWriter(const TSQLMonitoringWriter& ). TSQLMonitoringWriter& operator=(const TSQLMonitoringWriter& ). TSQLMonitoringWriter(const char* serv, const char* user, const char* pass, const char* table). virtual ~TSQLMonitoringWriter(). Bool_t SendParameters(TList* values, const char* ). void Verbose(Bool_t onoff); { fVerbose = onoff; }. » Author: J.F. Grosse-Oetringhaus, G.Ganis » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TSQLMonitoringWriter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLMonitoringWriter.html
https://root.cern/root/html534/TSQLObjectData.html:1923,Availability,error,error,1923,"actMethod(const char* method) const; voidAddUnpack(const char* tname, const char* value); voidAddUnpackInt(const char* tname, Int_t value); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetBlobPrefixName() const; const char*GetBlobTypeName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TSQLClassInfo*GetInfo() const; const char*GetLocatedField() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Long64_tGetObjId() const; virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetValue() const; virtual Bool_tTObject::Handl",MatchSource.WIKI,root/html534/TSQLObjectData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLObjectData.html
https://root.cern/root/html534/TSQLObjectData.html:2007,Availability,error,error,2007,"lue); voidAddUnpackInt(const char* tname, Int_t value); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetBlobPrefixName() const; const char*GetBlobTypeName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TSQLClassInfo*GetInfo() const; const char*GetLocatedField() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Long64_tGetObjId() const; virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetValue() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::In",MatchSource.WIKI,root/html534/TSQLObjectData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLObjectData.html
https://root.cern/root/html534/TSQLObjectData.html:5409,Availability,error,errormsg,5409,"od) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject&TObject::operator=(const TObject& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); Bool_tPrepareForRawData(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTObject::SetUniqueID(UInt_t uid); voidShiftToNextValue(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); Bool_tVerifyDataType(const char* tname, Bool_t errormsg = kTRUE); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html534/TSQLObjectData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLObjectData.html
https://root.cern/root/html534/TSQLObjectData.html:7742,Availability,error,errormsg,7742," . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSQLObjectData(); default contrsuctor. TSQLObjectData(TSQLClassInfo* sqlinfo, Long64_t objid, TSQLResult* classdata, TSQLRow* classrow, TSQLResult* blobdata, TSQLStatement* blobstmt); normal contrsuctor,. ~TSQLObjectData(); destructor of TSQLObjectData object. Int_t GetNumClassFields(); return number of columns in class table result. const char* GetClassFieldName(Int_t n); get name of class table column. Bool_t LocateColumn(const char* colname, Bool_t isblob = kFALSE); locate column of that name in results. Bool_t ShiftBlobRow(); shift cursor to next blob value. Bool_t ExtractBlobValues(); extract from curent blob row value and names identifiers. void AddUnpack(const char* tname, const char* value); add emulated data; this used to place version or TObject raw data, read from normal tables. void AddUnpackInt(const char* tname, Int_t value); emulate integer value in raw data. void ShiftToNextValue(); shift to next column or next row in blob data. Bool_t VerifyDataType(const char* tname, Bool_t errormsg = kTRUE); checks if data type corresponds to that stored in raw table. Bool_t PrepareForRawData(); prepare to read data from raw table. Long64_t GetObjId() const; { return fObjId; }. TSQLObjectData(). TSQLClassInfo* GetInfo() const; { return fInfo; }. Bool_t IsBlobData() const; { return fCurrentBlob || (fUnpack!=0); }. const char* GetValue() const; { return fLocatedValue; }. const char* GetLocatedField() const; { return fLocatedField; }. const char* GetBlobPrefixName() const; { return fBlobPrefixName; }. const char* GetBlobTypeName() const; { return fBlobTypeName; }. » Author: Sergey Linev 20/11/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sql:$Id$ » Last generated: 2015-03-14 16:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TSQLObjectData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLObjectData.html
https://root.cern/root/html534/TSQLObjectDataPool.html:1737,Availability,error,error,1737,"ObjectDataPool(TSQLClassInfo* info, TSQLResult* data); virtual~TSQLObjectDataPool(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TSQLResult*GetClassData() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; TSQLRow*GetObjectRow(Long64_t objid); static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TSQLClassInfo*GetSqlInfo() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(cons",MatchSource.WIKI,root/html534/TSQLObjectDataPool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLObjectDataPool.html
https://root.cern/root/html534/TSQLObjectDataPool.html:1821,Availability,error,error,1821," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TSQLResult*GetClassData() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; TSQLRow*GetObjectRow(Long64_t objid); static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TSQLClassInfo*GetSqlInfo() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const",MatchSource.WIKI,root/html534/TSQLObjectDataPool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLObjectDataPool.html
https://root.cern/root/html534/TSQLObjectDataPool.html:514,Performance,optimiz,optimize,514,". TSQLObjectDataPool. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » SQL; » TSQLObjectDataPool. class TSQLObjectDataPool: public TObject. TSQLObjectDataPool contains list (pool) of data from single class table; for differents objects, all belonging to the same key.; This is typical situation when list of objects stored as single key.; To optimize reading of such data, one query is submitted and results of that; query kept in TSQLObjectDataPool object. Function Members (Methods); public:. TSQLObjectDataPool(); TSQLObjectDataPool(const TSQLObjectDataPool&); TSQLObjectDataPool(TSQLClassInfo* info, TSQLResult* data); virtual~TSQLObjectDataPool(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::F",MatchSource.WIKI,root/html534/TSQLObjectDataPool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLObjectDataPool.html
https://root.cern/root/html534/TSQLObjectInfo.html:1749,Availability,error,error,1749,"Long64_t objid, const char* classname, Version_t version); virtual~TSQLObjectInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; const char*GetObjClassName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Long64_tGetObjId() const; Version_tGetObjVersion() const; virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* met",MatchSource.WIKI,root/html534/TSQLObjectInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLObjectInfo.html
https://root.cern/root/html534/TSQLObjectInfo.html:1833,Availability,error,error,1833," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; const char*GetObjClassName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Long64_tGetObjId() const; Version_tGetObjVersion() const; virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* clas",MatchSource.WIKI,root/html534/TSQLObjectInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLObjectInfo.html
https://root.cern/root/html534/TSQLResult.html:599,Availability,avail,available,599,". TSQLResult. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TSQLResult. class TSQLResult: public TObject. TSQLResult. Abstract base class defining interface to a SQL query result.; Objects of this class are created by TSQLServer methods. Related classes are TSQLServer and TSQLRow. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSQLResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetD",MatchSource.WIKI,root/html534/TSQLResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLResult.html
https://root.cern/root/html534/TSQLResult.html:1609,Availability,error,error,1609," virtual~TSQLResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetD",MatchSource.WIKI,root/html534/TSQLResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLResult.html
https://root.cern/root/html534/TSQLResult.html:1693,Availability,error,error,1693,"ethod) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFieldCount(); virtual const char*GetFieldName(Int_t field); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tGetRowCount() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(",MatchSource.WIKI,root/html534/TSQLResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLResult.html
https://root.cern/root/html534/TSQLResult.html:330,Integrability,interface,interface,330,". TSQLResult. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TSQLResult. class TSQLResult: public TObject. TSQLResult. Abstract base class defining interface to a SQL query result.; Objects of this class are created by TSQLServer methods. Related classes are TSQLServer and TSQLRow. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSQLResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetD",MatchSource.WIKI,root/html534/TSQLResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLResult.html
https://root.cern/root/html534/TSQLRow.html:599,Availability,avail,available,599,". TSQLRow. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TSQLRow. class TSQLRow: public TObject. TSQLRow. Abstract base class defining interface to a row of a SQL query; result. Objects of this class are created by TSQLResult methods. Related classes are TSQLServer and TSQLResult. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSQLRow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDraw",MatchSource.WIKI,root/html534/TSQLRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLRow.html
https://root.cern/root/html534/TSQLRow.html:1606,Availability,error,error,1606," virtual~TSQLRow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDraw",MatchSource.WIKI,root/html534/TSQLRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLRow.html
https://root.cern/root/html534/TSQLRow.html:1690,Availability,error,error,1690,"ethod) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetField(Int_t field); virtual ULong_tGetFieldLength(Int_t field); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) c",MatchSource.WIKI,root/html534/TSQLRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLRow.html
https://root.cern/root/html534/TSQLRow.html:318,Integrability,interface,interface,318,". TSQLRow. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TSQLRow. class TSQLRow: public TObject. TSQLRow. Abstract base class defining interface to a row of a SQL query; result. Objects of this class are created by TSQLResult methods. Related classes are TSQLServer and TSQLResult. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSQLRow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDraw",MatchSource.WIKI,root/html534/TSQLRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLRow.html
https://root.cern/root/html534/TSQLServer.html:1167,Availability,avail,available,1167,"ss description; function members; data members; class charts. ROOT; » NET; » NET; » TSQLServer. class TSQLServer: public TObject. TSQLServer. Abstract base class defining interface to a SQL server. To open a connection to a server use the static method Connect().; The db argument of Connect() is of the form:; <dbms>://<host>[:<port>][/<database>], e.g.; mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main, ...; Depending on the <dbms> specified an appropriate plugin library; will be loaded which will provide the real interface.; For SQLite, the syntax is slightly different:; sqlite://<database>; The string 'database' is directly passed to sqlite3_open(_v2),; so e.g. a filename or "":memory:"" are possible values.; For SQLite versions >= 3.7.7, SQLITE_OPEN_URI is activated to also; allow URI-parameters if needed. Related classes are TSQLResult and TSQLRow. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSQLServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*Connect(const char* db, const char* uid, const char* pw); virtual voidTObject::Copy(TObject& object) const; virtual Int_tCreateDataBase(const char* dbname); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Int_tDropDataBas",MatchSource.WIKI,root/html534/TSQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLServer.html
https://root.cern/root/html534/TSQLServer.html:2460,Availability,error,error,2460,"t::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*Connect(const char* db, const char* uid, const char* pw); virtual voidTObject::Copy(TObject& object) const; virtual Int_tCreateDataBase(const char* dbname); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Int_tDropDataBase(const char* dbname); virtual voidTObject::Dump() constMENU ; virtual voidEnableErrorOutput(Bool_t on = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Bool_tExec(const char* sql); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSQLResult*GetColumns(const char* dbname, const char* table, const char* wild = 0); virtual TSQLResult*GetDataBases(const char* wild = 0); const char*GetDB() const; const char*GetDBMS() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetErrorCode() const; virtual const char*GetErrorMsg() const; static const char*GetFloatFormat(); const char*GetHost() const; virtual const char*TObject::GetIconName() const; virtual Int_tGetMaxIdentifierLength(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObjec",MatchSource.WIKI,root/html534/TSQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLServer.html
https://root.cern/root/html534/TSQLServer.html:2544,Availability,error,error,2544,"onst; virtual voidClose(Option_t* option = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*Connect(const char* db, const char* uid, const char* pw); virtual voidTObject::Copy(TObject& object) const; virtual Int_tCreateDataBase(const char* dbname); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Int_tDropDataBase(const char* dbname); virtual voidTObject::Dump() constMENU ; virtual voidEnableErrorOutput(Bool_t on = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Bool_tExec(const char* sql); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSQLResult*GetColumns(const char* dbname, const char* table, const char* wild = 0); virtual TSQLResult*GetDataBases(const char* wild = 0); const char*GetDB() const; const char*GetDBMS() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetErrorCode() const; virtual const char*GetErrorMsg() const; static const char*GetFloatFormat(); const char*GetHost() const; virtual const char*TObject::GetIconName() const; virtual Int_tGetMaxIdentifierLength(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetPort() cons",MatchSource.WIKI,root/html534/TSQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLServer.html
https://root.cern/root/html534/TSQLServer.html:7738,Availability,error,error,7738," msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidClearError(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidSetError(Int_t code, const char* msg, const char* method = 0). Data Members; public:. enum ESQLDataTypes { kSQL_NONE; kSQL_CHAR; kSQL_VARCHAR; kSQL_INTEGER; kSQL_FLOAT; kSQL_DOUBLE; kSQL_NUMERIC; kSQL_BINARY; kSQL_TIMESTAMP; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfDBcurrently selected DB; Int_tfErrorCodeerror code of last operation; TStringfErrorMsgerror message of last operation; Bool_tfErrorOutenable error output; TStringfHosthost to which we are connected; Int_tfPortport to which we are connected; TStringfTypetype of DBMS (MySQL, Oracle, SysBase, ...); static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSQLServer * Connect(const char* db, const char* uid, const char* pw); The db should be of the form: <dbms>://<host>[:<port>][/<database>],; e.g.: mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main,; pgsql://... or sapdb://...; The uid is the username and pw the password that should be used for; the connection. Depending on the <dbms> the shared library (plugin); for the selected system will be loaded. When the connection could not; be opened 0 is returned. Bool_t Exec(const char* sql); Execute sql query.; Usefull for commands like DROP TABLE or INSERT, where result set; is not interested. Return kTRUE if no error. Int_t GetE",MatchSource.WIKI,root/html534/TSQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLServer.html
https://root.cern/root/html534/TSQLServer.html:8722,Availability,error,error,8722," Bool_tfErrorOutenable error output; TStringfHosthost to which we are connected; Int_tfPortport to which we are connected; TStringfTypetype of DBMS (MySQL, Oracle, SysBase, ...); static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSQLServer * Connect(const char* db, const char* uid, const char* pw); The db should be of the form: <dbms>://<host>[:<port>][/<database>],; e.g.: mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main,; pgsql://... or sapdb://...; The uid is the username and pw the password that should be used for; the connection. Depending on the <dbms> the shared library (plugin); for the selected system will be loaded. When the connection could not; be opened 0 is returned. Bool_t Exec(const char* sql); Execute sql query.; Usefull for commands like DROP TABLE or INSERT, where result set; is not interested. Return kTRUE if no error. Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLServer provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLServer provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method is specified, displays error message. Bool_t StartTransaction(); submit ""START TRANSACTION"" query to database; return kTRUE, if successful. Bool_t Commit(); submit ""COMMIT"" query to database; return kTRUE, if successful. Bool_t Rollback(); submit ""ROLLBACK"" query to database; return kTRUE, if successful. TList* GetTablesList(const char* wild = 0); Return list of user tables; Parameter wild specifies wildcard for table names.; It either contains exact table name to verify that table is exists or; ",MatchSource.WIKI,root/html534/TSQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLServer.html
https://root.cern/root/html534/TSQLServer.html:8765,Availability,error,error,8765,"rt to which we are connected; TStringfTypetype of DBMS (MySQL, Oracle, SysBase, ...); static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSQLServer * Connect(const char* db, const char* uid, const char* pw); The db should be of the form: <dbms>://<host>[:<port>][/<database>],; e.g.: mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main,; pgsql://... or sapdb://...; The uid is the username and pw the password that should be used for; the connection. Depending on the <dbms> the shared library (plugin); for the selected system will be loaded. When the connection could not; be opened 0 is returned. Bool_t Exec(const char* sql); Execute sql query.; Usefull for commands like DROP TABLE or INSERT, where result set; is not interested. Return kTRUE if no error. Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLServer provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLServer provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method is specified, displays error message. Bool_t StartTransaction(); submit ""START TRANSACTION"" query to database; return kTRUE, if successful. Bool_t Commit(); submit ""COMMIT"" query to database; return kTRUE, if successful. Bool_t Rollback(); submit ""ROLLBACK"" query to database; return kTRUE, if successful. TList* GetTablesList(const char* wild = 0); Return list of user tables; Parameter wild specifies wildcard for table names.; It either contains exact table name to verify that table is exists or; wildcard with ""%"" (any number of symbols) and ""_"" (exactly one symbol).; Example of vaild wild",MatchSource.WIKI,root/html534/TSQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLServer.html
https://root.cern/root/html534/TSQLServer.html:8809,Availability,error,error,8809,"rt to which we are connected; TStringfTypetype of DBMS (MySQL, Oracle, SysBase, ...); static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSQLServer * Connect(const char* db, const char* uid, const char* pw); The db should be of the form: <dbms>://<host>[:<port>][/<database>],; e.g.: mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main,; pgsql://... or sapdb://...; The uid is the username and pw the password that should be used for; the connection. Depending on the <dbms> the shared library (plugin); for the selected system will be loaded. When the connection could not; be opened 0 is returned. Bool_t Exec(const char* sql); Execute sql query.; Usefull for commands like DROP TABLE or INSERT, where result set; is not interested. Return kTRUE if no error. Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLServer provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLServer provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method is specified, displays error message. Bool_t StartTransaction(); submit ""START TRANSACTION"" query to database; return kTRUE, if successful. Bool_t Commit(); submit ""COMMIT"" query to database; return kTRUE, if successful. Bool_t Rollback(); submit ""ROLLBACK"" query to database; return kTRUE, if successful. TList* GetTablesList(const char* wild = 0); Return list of user tables; Parameter wild specifies wildcard for table names.; It either contains exact table name to verify that table is exists or; wildcard with ""%"" (any number of symbols) and ""_"" (exactly one symbol).; Example of vaild wild",MatchSource.WIKI,root/html534/TSQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLServer.html
https://root.cern/root/html534/TSQLServer.html:8876,Availability,error,error,8876,"rt to which we are connected; TStringfTypetype of DBMS (MySQL, Oracle, SysBase, ...); static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSQLServer * Connect(const char* db, const char* uid, const char* pw); The db should be of the form: <dbms>://<host>[:<port>][/<database>],; e.g.: mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main,; pgsql://... or sapdb://...; The uid is the username and pw the password that should be used for; the connection. Depending on the <dbms> the shared library (plugin); for the selected system will be loaded. When the connection could not; be opened 0 is returned. Bool_t Exec(const char* sql); Execute sql query.; Usefull for commands like DROP TABLE or INSERT, where result set; is not interested. Return kTRUE if no error. Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLServer provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLServer provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method is specified, displays error message. Bool_t StartTransaction(); submit ""START TRANSACTION"" query to database; return kTRUE, if successful. Bool_t Commit(); submit ""COMMIT"" query to database; return kTRUE, if successful. Bool_t Rollback(); submit ""ROLLBACK"" query to database; return kTRUE, if successful. TList* GetTablesList(const char* wild = 0); Return list of user tables; Parameter wild specifies wildcard for table names.; It either contains exact table name to verify that table is exists or; wildcard with ""%"" (any number of symbols) and ""_"" (exactly one symbol).; Example of vaild wild",MatchSource.WIKI,root/html534/TSQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLServer.html
https://root.cern/root/html534/TSQLServer.html:8931,Availability,error,error,8931,"or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSQLServer * Connect(const char* db, const char* uid, const char* pw); The db should be of the form: <dbms>://<host>[:<port>][/<database>],; e.g.: mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main,; pgsql://... or sapdb://...; The uid is the username and pw the password that should be used for; the connection. Depending on the <dbms> the shared library (plugin); for the selected system will be loaded. When the connection could not; be opened 0 is returned. Bool_t Exec(const char* sql); Execute sql query.; Usefull for commands like DROP TABLE or INSERT, where result set; is not interested. Return kTRUE if no error. Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLServer provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLServer provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method is specified, displays error message. Bool_t StartTransaction(); submit ""START TRANSACTION"" query to database; return kTRUE, if successful. Bool_t Commit(); submit ""COMMIT"" query to database; return kTRUE, if successful. Bool_t Rollback(); submit ""ROLLBACK"" query to database; return kTRUE, if successful. TList* GetTablesList(const char* wild = 0); Return list of user tables; Parameter wild specifies wildcard for table names.; It either contains exact table name to verify that table is exists or; wildcard with ""%"" (any number of symbols) and ""_"" (exactly one symbol).; Example of vaild wildcards: ""%"", ""%name"",""___user__"".; If wild=="""", list of all available tables will be produced.; List contain just tables names in the TObjString.; List must be deleted ",MatchSource.WIKI,root/html534/TSQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLServer.html
https://root.cern/root/html534/TSQLServer.html:8970,Availability,error,errors,8970,"or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSQLServer * Connect(const char* db, const char* uid, const char* pw); The db should be of the form: <dbms>://<host>[:<port>][/<database>],; e.g.: mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main,; pgsql://... or sapdb://...; The uid is the username and pw the password that should be used for; the connection. Depending on the <dbms> the shared library (plugin); for the selected system will be loaded. When the connection could not; be opened 0 is returned. Bool_t Exec(const char* sql); Execute sql query.; Usefull for commands like DROP TABLE or INSERT, where result set; is not interested. Return kTRUE if no error. Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLServer provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLServer provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method is specified, displays error message. Bool_t StartTransaction(); submit ""START TRANSACTION"" query to database; return kTRUE, if successful. Bool_t Commit(); submit ""COMMIT"" query to database; return kTRUE, if successful. Bool_t Rollback(); submit ""ROLLBACK"" query to database; return kTRUE, if successful. TList* GetTablesList(const char* wild = 0); Return list of user tables; Parameter wild specifies wildcard for table names.; It either contains exact table name to verify that table is exists or; wildcard with ""%"" (any number of symbols) and ""_"" (exactly one symbol).; Example of vaild wildcards: ""%"", ""%name"",""___user__"".; If wild=="""", list of all available tables will be produced.; List contain just tables names in the TObjString.; List must be deleted ",MatchSource.WIKI,root/html534/TSQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLServer.html
https://root.cern/root/html534/TSQLServer.html:9048,Availability,error,error,9048,"or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSQLServer * Connect(const char* db, const char* uid, const char* pw); The db should be of the form: <dbms>://<host>[:<port>][/<database>],; e.g.: mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main,; pgsql://... or sapdb://...; The uid is the username and pw the password that should be used for; the connection. Depending on the <dbms> the shared library (plugin); for the selected system will be loaded. When the connection could not; be opened 0 is returned. Bool_t Exec(const char* sql); Execute sql query.; Usefull for commands like DROP TABLE or INSERT, where result set; is not interested. Return kTRUE if no error. Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLServer provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLServer provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method is specified, displays error message. Bool_t StartTransaction(); submit ""START TRANSACTION"" query to database; return kTRUE, if successful. Bool_t Commit(); submit ""COMMIT"" query to database; return kTRUE, if successful. Bool_t Rollback(); submit ""ROLLBACK"" query to database; return kTRUE, if successful. TList* GetTablesList(const char* wild = 0); Return list of user tables; Parameter wild specifies wildcard for table names.; It either contains exact table name to verify that table is exists or; wildcard with ""%"" (any number of symbols) and ""_"" (exactly one symbol).; Example of vaild wildcards: ""%"", ""%name"",""___user__"".; If wild=="""", list of all available tables will be produced.; List contain just tables names in the TObjString.; List must be deleted ",MatchSource.WIKI,root/html534/TSQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLServer.html
https://root.cern/root/html534/TSQLServer.html:9089,Availability,error,error,9089,"ocumentation; TSQLServer * Connect(const char* db, const char* uid, const char* pw); The db should be of the form: <dbms>://<host>[:<port>][/<database>],; e.g.: mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main,; pgsql://... or sapdb://...; The uid is the username and pw the password that should be used for; the connection. Depending on the <dbms> the shared library (plugin); for the selected system will be loaded. When the connection could not; be opened 0 is returned. Bool_t Exec(const char* sql); Execute sql query.; Usefull for commands like DROP TABLE or INSERT, where result set; is not interested. Return kTRUE if no error. Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLServer provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLServer provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method is specified, displays error message. Bool_t StartTransaction(); submit ""START TRANSACTION"" query to database; return kTRUE, if successful. Bool_t Commit(); submit ""COMMIT"" query to database; return kTRUE, if successful. Bool_t Rollback(); submit ""ROLLBACK"" query to database; return kTRUE, if successful. TList* GetTablesList(const char* wild = 0); Return list of user tables; Parameter wild specifies wildcard for table names.; It either contains exact table name to verify that table is exists or; wildcard with ""%"" (any number of symbols) and ""_"" (exactly one symbol).; Example of vaild wildcards: ""%"", ""%name"",""___user__"".; If wild=="""", list of all available tables will be produced.; List contain just tables names in the TObjString.; List must be deleted by the user.; Example code of method usage:. TList* lst = serv->GetTablesList();; TIter next(lst);; TObject",MatchSource.WIKI,root/html534/TSQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLServer.html
https://root.cern/root/html534/TSQLServer.html:9190,Availability,error,error,9190,"ould be of the form: <dbms>://<host>[:<port>][/<database>],; e.g.: mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main,; pgsql://... or sapdb://...; The uid is the username and pw the password that should be used for; the connection. Depending on the <dbms> the shared library (plugin); for the selected system will be loaded. When the connection could not; be opened 0 is returned. Bool_t Exec(const char* sql); Execute sql query.; Usefull for commands like DROP TABLE or INSERT, where result set; is not interested. Return kTRUE if no error. Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLServer provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLServer provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method is specified, displays error message. Bool_t StartTransaction(); submit ""START TRANSACTION"" query to database; return kTRUE, if successful. Bool_t Commit(); submit ""COMMIT"" query to database; return kTRUE, if successful. Bool_t Rollback(); submit ""ROLLBACK"" query to database; return kTRUE, if successful. TList* GetTablesList(const char* wild = 0); Return list of user tables; Parameter wild specifies wildcard for table names.; It either contains exact table name to verify that table is exists or; wildcard with ""%"" (any number of symbols) and ""_"" (exactly one symbol).; Example of vaild wildcards: ""%"", ""%name"",""___user__"".; If wild=="""", list of all available tables will be produced.; List contain just tables names in the TObjString.; List must be deleted by the user.; Example code of method usage:. TList* lst = serv->GetTablesList();; TIter next(lst);; TObject* obj;; while (obj = next()); cout << ""Table: "" << obj->GetName() << endl;; delete lst;. Bool_",MatchSource.WIKI,root/html534/TSQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLServer.html
https://root.cern/root/html534/TSQLServer.html:9237,Availability,error,error,9237,"ould be of the form: <dbms>://<host>[:<port>][/<database>],; e.g.: mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main,; pgsql://... or sapdb://...; The uid is the username and pw the password that should be used for; the connection. Depending on the <dbms> the shared library (plugin); for the selected system will be loaded. When the connection could not; be opened 0 is returned. Bool_t Exec(const char* sql); Execute sql query.; Usefull for commands like DROP TABLE or INSERT, where result set; is not interested. Return kTRUE if no error. Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLServer provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLServer provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method is specified, displays error message. Bool_t StartTransaction(); submit ""START TRANSACTION"" query to database; return kTRUE, if successful. Bool_t Commit(); submit ""COMMIT"" query to database; return kTRUE, if successful. Bool_t Rollback(); submit ""ROLLBACK"" query to database; return kTRUE, if successful. TList* GetTablesList(const char* wild = 0); Return list of user tables; Parameter wild specifies wildcard for table names.; It either contains exact table name to verify that table is exists or; wildcard with ""%"" (any number of symbols) and ""_"" (exactly one symbol).; Example of vaild wildcards: ""%"", ""%name"",""___user__"".; If wild=="""", list of all available tables will be produced.; List contain just tables names in the TObjString.; List must be deleted by the user.; Example code of method usage:. TList* lst = serv->GetTablesList();; TIter next(lst);; TObject* obj;; while (obj = next()); cout << ""Table: "" << obj->GetName() << endl;; delete lst;. Bool_",MatchSource.WIKI,root/html534/TSQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLServer.html
https://root.cern/root/html534/TSQLServer.html:9868,Availability,avail,available,9868," own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLServer provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method is specified, displays error message. Bool_t StartTransaction(); submit ""START TRANSACTION"" query to database; return kTRUE, if successful. Bool_t Commit(); submit ""COMMIT"" query to database; return kTRUE, if successful. Bool_t Rollback(); submit ""ROLLBACK"" query to database; return kTRUE, if successful. TList* GetTablesList(const char* wild = 0); Return list of user tables; Parameter wild specifies wildcard for table names.; It either contains exact table name to verify that table is exists or; wildcard with ""%"" (any number of symbols) and ""_"" (exactly one symbol).; Example of vaild wildcards: ""%"", ""%name"",""___user__"".; If wild=="""", list of all available tables will be produced.; List contain just tables names in the TObjString.; List must be deleted by the user.; Example code of method usage:. TList* lst = serv->GetTablesList();; TIter next(lst);; TObject* obj;; while (obj = next()); cout << ""Table: "" << obj->GetName() << endl;; delete lst;. Bool_t HasTable(const char* tablename); Tests if table of that name exists in database; Return kTRUE, if table exists. TSQLTableInfo* GetTableInfo(const char* tablename); Producec TSQLTableInfo object, which contain info about; table itself and each table column; Object must be deleted by user. void SetFloatFormat(const char* fmt = ""%e""); set printf format for float/double members, default ""%e"". const char* GetFloatFormat(); return current printf format for float/double members, default ""%e"". virtual ~TSQLServer(); { }. void Close(Option_t* option = """"). TSQLResult * Query(const char* sql). Bool_t HasStatement() const; { return kFALSE; }. Int_t SelectDataBase(const char* dbname). TSQLResult ",MatchSource.WIKI,root/html534/TSQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLServer.html
https://root.cern/root/html534/TSQLServer.html:330,Integrability,interface,interface,330,". TSQLServer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TSQLServer. class TSQLServer: public TObject. TSQLServer. Abstract base class defining interface to a SQL server. To open a connection to a server use the static method Connect().; The db argument of Connect() is of the form:; <dbms>://<host>[:<port>][/<database>], e.g.; mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main, ...; Depending on the <dbms> specified an appropriate plugin library; will be loaded which will provide the real interface.; For SQLite, the syntax is slightly different:; sqlite://<database>; The string 'database' is directly passed to sqlite3_open(_v2),; so e.g. a filename or "":memory:"" are possible values.; For SQLite versions >= 3.7.7, SQLITE_OPEN_URI is activated to also; allow URI-parameters if needed. Related classes are TSQLResult and TSQLRow. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSQLServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*Connect(const char* db, const char* uid, const char* pw); virtual voidTObject::Copy(TObject& object) const; virtual Int_tCreateDataBase(const char* dbname); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Opti",MatchSource.WIKI,root/html534/TSQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLServer.html
https://root.cern/root/html534/TSQLServer.html:690,Integrability,interface,interface,690,". TSQLServer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TSQLServer. class TSQLServer: public TObject. TSQLServer. Abstract base class defining interface to a SQL server. To open a connection to a server use the static method Connect().; The db argument of Connect() is of the form:; <dbms>://<host>[:<port>][/<database>], e.g.; mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main, ...; Depending on the <dbms> specified an appropriate plugin library; will be loaded which will provide the real interface.; For SQLite, the syntax is slightly different:; sqlite://<database>; The string 'database' is directly passed to sqlite3_open(_v2),; so e.g. a filename or "":memory:"" are possible values.; For SQLite versions >= 3.7.7, SQLITE_OPEN_URI is activated to also; allow URI-parameters if needed. Related classes are TSQLResult and TSQLRow. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSQLServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*Connect(const char* db, const char* uid, const char* pw); virtual voidTObject::Copy(TObject& object) const; virtual Int_tCreateDataBase(const char* dbname); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Opti",MatchSource.WIKI,root/html534/TSQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLServer.html
https://root.cern/root/html534/TSQLServer.html:7689,Integrability,message,message,7689," msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidClearError(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidSetError(Int_t code, const char* msg, const char* method = 0). Data Members; public:. enum ESQLDataTypes { kSQL_NONE; kSQL_CHAR; kSQL_VARCHAR; kSQL_INTEGER; kSQL_FLOAT; kSQL_DOUBLE; kSQL_NUMERIC; kSQL_BINARY; kSQL_TIMESTAMP; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfDBcurrently selected DB; Int_tfErrorCodeerror code of last operation; TStringfErrorMsgerror message of last operation; Bool_tfErrorOutenable error output; TStringfHosthost to which we are connected; Int_tfPortport to which we are connected; TStringfTypetype of DBMS (MySQL, Oracle, SysBase, ...); static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSQLServer * Connect(const char* db, const char* uid, const char* pw); The db should be of the form: <dbms>://<host>[:<port>][/<database>],; e.g.: mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main,; pgsql://... or sapdb://...; The uid is the username and pw the password that should be used for; the connection. Depending on the <dbms> the shared library (plugin); for the selected system will be loaded. When the connection could not; be opened 0 is returned. Bool_t Exec(const char* sql); Execute sql query.; Usefull for commands like DROP TABLE or INSERT, where result set; is not interested. Return kTRUE if no error. Int_t GetE",MatchSource.WIKI,root/html534/TSQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLServer.html
https://root.cern/root/html534/TSQLServer.html:8937,Integrability,message,message,8937,"or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSQLServer * Connect(const char* db, const char* uid, const char* pw); The db should be of the form: <dbms>://<host>[:<port>][/<database>],; e.g.: mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main,; pgsql://... or sapdb://...; The uid is the username and pw the password that should be used for; the connection. Depending on the <dbms> the shared library (plugin); for the selected system will be loaded. When the connection could not; be opened 0 is returned. Bool_t Exec(const char* sql); Execute sql query.; Usefull for commands like DROP TABLE or INSERT, where result set; is not interested. Return kTRUE if no error. Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLServer provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLServer provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method is specified, displays error message. Bool_t StartTransaction(); submit ""START TRANSACTION"" query to database; return kTRUE, if successful. Bool_t Commit(); submit ""COMMIT"" query to database; return kTRUE, if successful. Bool_t Rollback(); submit ""ROLLBACK"" query to database; return kTRUE, if successful. TList* GetTablesList(const char* wild = 0); Return list of user tables; Parameter wild specifies wildcard for table names.; It either contains exact table name to verify that table is exists or; wildcard with ""%"" (any number of symbols) and ""_"" (exactly one symbol).; Example of vaild wildcards: ""%"", ""%name"",""___user__"".; If wild=="""", list of all available tables will be produced.; List contain just tables names in the TObjString.; List must be deleted ",MatchSource.WIKI,root/html534/TSQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLServer.html
https://root.cern/root/html534/TSQLServer.html:9054,Integrability,message,messages,9054,"or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSQLServer * Connect(const char* db, const char* uid, const char* pw); The db should be of the form: <dbms>://<host>[:<port>][/<database>],; e.g.: mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main,; pgsql://... or sapdb://...; The uid is the username and pw the password that should be used for; the connection. Depending on the <dbms> the shared library (plugin); for the selected system will be loaded. When the connection could not; be opened 0 is returned. Bool_t Exec(const char* sql); Execute sql query.; Usefull for commands like DROP TABLE or INSERT, where result set; is not interested. Return kTRUE if no error. Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLServer provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLServer provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method is specified, displays error message. Bool_t StartTransaction(); submit ""START TRANSACTION"" query to database; return kTRUE, if successful. Bool_t Commit(); submit ""COMMIT"" query to database; return kTRUE, if successful. Bool_t Rollback(); submit ""ROLLBACK"" query to database; return kTRUE, if successful. TList* GetTablesList(const char* wild = 0); Return list of user tables; Parameter wild specifies wildcard for table names.; It either contains exact table name to verify that table is exists or; wildcard with ""%"" (any number of symbols) and ""_"" (exactly one symbol).; Example of vaild wildcards: ""%"", ""%name"",""___user__"".; If wild=="""", list of all available tables will be produced.; List contain just tables names in the TObjString.; List must be deleted ",MatchSource.WIKI,root/html534/TSQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLServer.html
https://root.cern/root/html534/TSQLServer.html:9243,Integrability,message,message,9243,"ould be of the form: <dbms>://<host>[:<port>][/<database>],; e.g.: mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main,; pgsql://... or sapdb://...; The uid is the username and pw the password that should be used for; the connection. Depending on the <dbms> the shared library (plugin); for the selected system will be loaded. When the connection could not; be opened 0 is returned. Bool_t Exec(const char* sql); Execute sql query.; Usefull for commands like DROP TABLE or INSERT, where result set; is not interested. Return kTRUE if no error. Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLServer provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLServer provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method is specified, displays error message. Bool_t StartTransaction(); submit ""START TRANSACTION"" query to database; return kTRUE, if successful. Bool_t Commit(); submit ""COMMIT"" query to database; return kTRUE, if successful. Bool_t Rollback(); submit ""ROLLBACK"" query to database; return kTRUE, if successful. TList* GetTablesList(const char* wild = 0); Return list of user tables; Parameter wild specifies wildcard for table names.; It either contains exact table name to verify that table is exists or; wildcard with ""%"" (any number of symbols) and ""_"" (exactly one symbol).; Example of vaild wildcards: ""%"", ""%name"",""___user__"".; If wild=="""", list of all available tables will be produced.; List contain just tables names in the TObjString.; List must be deleted by the user.; Example code of method usage:. TList* lst = serv->GetTablesList();; TIter next(lst);; TObject* obj;; while (obj = next()); cout << ""Table: "" << obj->GetName() << endl;; delete lst;. Bool_",MatchSource.WIKI,root/html534/TSQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLServer.html
https://root.cern/root/html534/TSQLServer.html:631,Modifiability,plugin,plugin,631,". TSQLServer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TSQLServer. class TSQLServer: public TObject. TSQLServer. Abstract base class defining interface to a SQL server. To open a connection to a server use the static method Connect().; The db argument of Connect() is of the form:; <dbms>://<host>[:<port>][/<database>], e.g.; mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main, ...; Depending on the <dbms> specified an appropriate plugin library; will be loaded which will provide the real interface.; For SQLite, the syntax is slightly different:; sqlite://<database>; The string 'database' is directly passed to sqlite3_open(_v2),; so e.g. a filename or "":memory:"" are possible values.; For SQLite versions >= 3.7.7, SQLITE_OPEN_URI is activated to also; allow URI-parameters if needed. Related classes are TSQLResult and TSQLRow. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSQLServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*Connect(const char* db, const char* uid, const char* pw); virtual voidTObject::Copy(TObject& object) const; virtual Int_tCreateDataBase(const char* dbname); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Opti",MatchSource.WIKI,root/html534/TSQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLServer.html
https://root.cern/root/html534/TSQLServer.html:8463,Modifiability,plugin,plugin,8463,"; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfDBcurrently selected DB; Int_tfErrorCodeerror code of last operation; TStringfErrorMsgerror message of last operation; Bool_tfErrorOutenable error output; TStringfHosthost to which we are connected; Int_tfPortport to which we are connected; TStringfTypetype of DBMS (MySQL, Oracle, SysBase, ...); static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSQLServer * Connect(const char* db, const char* uid, const char* pw); The db should be of the form: <dbms>://<host>[:<port>][/<database>],; e.g.: mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main,; pgsql://... or sapdb://...; The uid is the username and pw the password that should be used for; the connection. Depending on the <dbms> the shared library (plugin); for the selected system will be loaded. When the connection could not; be opened 0 is returned. Bool_t Exec(const char* sql); Execute sql query.; Usefull for commands like DROP TABLE or INSERT, where result set; is not interested. Return kTRUE if no error. Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLServer provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLServer provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method is specified, displays error message. Bool_t StartTransaction(); submit ""START TRANSACTION"" query to database; return kTRUE, if successful. Bool_t Commit(); submit ""COMMIT"" query to database; return kTRUE, if successful. Bool_t Rollback(); submit ""ROL",MatchSource.WIKI,root/html534/TSQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLServer.html
https://root.cern/root/html534/TSQLServer.html:655,Performance,load,loaded,655,". TSQLServer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TSQLServer. class TSQLServer: public TObject. TSQLServer. Abstract base class defining interface to a SQL server. To open a connection to a server use the static method Connect().; The db argument of Connect() is of the form:; <dbms>://<host>[:<port>][/<database>], e.g.; mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main, ...; Depending on the <dbms> specified an appropriate plugin library; will be loaded which will provide the real interface.; For SQLite, the syntax is slightly different:; sqlite://<database>; The string 'database' is directly passed to sqlite3_open(_v2),; so e.g. a filename or "":memory:"" are possible values.; For SQLite versions >= 3.7.7, SQLITE_OPEN_URI is activated to also; allow URI-parameters if needed. Related classes are TSQLResult and TSQLRow. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSQLServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*Connect(const char* db, const char* uid, const char* pw); virtual voidTObject::Copy(TObject& object) const; virtual Int_tCreateDataBase(const char* dbname); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Opti",MatchSource.WIKI,root/html534/TSQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLServer.html
https://root.cern/root/html534/TSQLServer.html:8504,Performance,load,loaded,8504,"; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfDBcurrently selected DB; Int_tfErrorCodeerror code of last operation; TStringfErrorMsgerror message of last operation; Bool_tfErrorOutenable error output; TStringfHosthost to which we are connected; Int_tfPortport to which we are connected; TStringfTypetype of DBMS (MySQL, Oracle, SysBase, ...); static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSQLServer * Connect(const char* db, const char* uid, const char* pw); The db should be of the form: <dbms>://<host>[:<port>][/<database>],; e.g.: mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main,; pgsql://... or sapdb://...; The uid is the username and pw the password that should be used for; the connection. Depending on the <dbms> the shared library (plugin); for the selected system will be loaded. When the connection could not; be opened 0 is returned. Bool_t Exec(const char* sql); Execute sql query.; Usefull for commands like DROP TABLE or INSERT, where result set; is not interested. Return kTRUE if no error. Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLServer provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLServer provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method is specified, displays error message. Bool_t StartTransaction(); submit ""START TRANSACTION"" query to database; return kTRUE, if successful. Bool_t Commit(); submit ""COMMIT"" query to database; return kTRUE, if successful. Bool_t Rollback(); submit ""ROL",MatchSource.WIKI,root/html534/TSQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLServer.html
https://root.cern/root/html534/TSQLServer.html:8369,Security,password,password,8369,"p; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfDBcurrently selected DB; Int_tfErrorCodeerror code of last operation; TStringfErrorMsgerror message of last operation; Bool_tfErrorOutenable error output; TStringfHosthost to which we are connected; Int_tfPortport to which we are connected; TStringfTypetype of DBMS (MySQL, Oracle, SysBase, ...); static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSQLServer * Connect(const char* db, const char* uid, const char* pw); The db should be of the form: <dbms>://<host>[:<port>][/<database>],; e.g.: mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main,; pgsql://... or sapdb://...; The uid is the username and pw the password that should be used for; the connection. Depending on the <dbms> the shared library (plugin); for the selected system will be loaded. When the connection could not; be opened 0 is returned. Bool_t Exec(const char* sql); Execute sql query.; Usefull for commands like DROP TABLE or INSERT, where result set; is not interested. Return kTRUE if no error. Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLServer provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLServer provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method is specified, displays error message. Bool_t StartTransaction(); submit ""START TRANSACTION"" query to database; return kTRUE, if successful. Bool_t Commit(); subm",MatchSource.WIKI,root/html534/TSQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLServer.html
https://root.cern/root/html534/TSQLServer.html:543,Testability,test,test,543,". TSQLServer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TSQLServer. class TSQLServer: public TObject. TSQLServer. Abstract base class defining interface to a SQL server. To open a connection to a server use the static method Connect().; The db argument of Connect() is of the form:; <dbms>://<host>[:<port>][/<database>], e.g.; mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main, ...; Depending on the <dbms> specified an appropriate plugin library; will be loaded which will provide the real interface.; For SQLite, the syntax is slightly different:; sqlite://<database>; The string 'database' is directly passed to sqlite3_open(_v2),; so e.g. a filename or "":memory:"" are possible values.; For SQLite versions >= 3.7.7, SQLITE_OPEN_URI is activated to also; allow URI-parameters if needed. Related classes are TSQLResult and TSQLRow. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSQLServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*Connect(const char* db, const char* uid, const char* pw); virtual voidTObject::Copy(TObject& object) const; virtual Int_tCreateDataBase(const char* dbname); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Opti",MatchSource.WIKI,root/html534/TSQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLServer.html
https://root.cern/root/html534/TSQLServer.html:8271,Testability,test,test,8271,"kSQL_NUMERIC; kSQL_BINARY; kSQL_TIMESTAMP; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfDBcurrently selected DB; Int_tfErrorCodeerror code of last operation; TStringfErrorMsgerror message of last operation; Bool_tfErrorOutenable error output; TStringfHosthost to which we are connected; Int_tfPortport to which we are connected; TStringfTypetype of DBMS (MySQL, Oracle, SysBase, ...); static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSQLServer * Connect(const char* db, const char* uid, const char* pw); The db should be of the form: <dbms>://<host>[:<port>][/<database>],; e.g.: mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main,; pgsql://... or sapdb://...; The uid is the username and pw the password that should be used for; the connection. Depending on the <dbms> the shared library (plugin); for the selected system will be loaded. When the connection could not; be opened 0 is returned. Bool_t Exec(const char* sql); Execute sql query.; Usefull for commands like DROP TABLE or INSERT, where result set; is not interested. Return kTRUE if no error. Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLServer provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLServer provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method is specified, displays error message. Bool_t StartTransaction()",MatchSource.WIKI,root/html534/TSQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLServer.html
https://root.cern/root/html534/TSQLStatement.html:8782,Availability,avail,available,8782," "" << id2 << "" "" << name1 << "" "" << name2 << endl;; }; }. 4. Working with date/time parameters. The current implementation supports date, time, date&time and timestamp; data (all time intervals are not supported yet). To set or get date/time values,; the following methods should be used:; SetTime()/GetTime() - only time (hour:min:sec),; SetDate()/GetDate() - only date (year-month-day),; SetDatime()/GetDatime() - date and time; SetTimestamp()/GetTimestamp() - timestamp with seconds fraction; For some of these methods TDatime type can be used as parameter / return value.; Be aware that TDatime supports only dates after 1995-01-01.; There are also methods to get year, month, day, hour, minutes and seconds separately. Note that different SQL databases treat date/time types differently.; For instance, MySQL has all correspondent types (TIME, DATE, DATETIME and TIMESTAMP),; Oracle native driver supports only DATE (which is actually date and time) and TIMESTAMP; ODBC interface provides access for time, date and timestamps,; for PostgreSQL, TIMESTAMP is available and can be retrieved via all methods,; the implementation for SQLite interprets the column content as; a timestamp with second fraction.; Due to these differences, one should use correct methods to access such data.; For instance, in MySQL SQL type 'DATE' is only date (one should use GetDate() to; access such data), while in Oracle it is date and time. Therefore,; to get complete data from a 'DATE' column in Oracle, one should use the GetDatime() method. The only difference between timestamp and date/time is that timestamp has a fractional; seconds part. Be aware that the fractional part has different meanings; (actual value) in different SQL plugins.; For PostgreSQL, it is given back as microseconds, while for SQLite3,; milliseconds correspond to the fraction (similar to the DATETIME-functions; implemented in the SQLite3 language). 5. Binary data. Most modern data bases support just binary data, which is; typicall",MatchSource.WIKI,root/html534/TSQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLStatement.html
https://root.cern/root/html534/TSQLStatement.html:10441,Availability,avail,available,10441,"erent SQL plugins.; For PostgreSQL, it is given back as microseconds, while for SQLite3,; milliseconds correspond to the fraction (similar to the DATETIME-functions; implemented in the SQLite3 language). 5. Binary data. Most modern data bases support just binary data, which is; typically has SQL type name 'BLOB'. To access data in such; columns, GetBinary()/SetBinary() methods should be used.; The current implementation implies that the complete content of the; column must be retrieved at once. Therefore, very big data of; gigabytes size may cause a problem. In addition, for PostgresSQL, the methods GetLargeObject()/SetLargeObject(); are implemented with similar syntax. They retrieve a large object for the OID; given in the column of the statement. For non-PostgreSQL databases,; calling GetLargeObject()/SetLargeObject() is redirected to GetBinary()/SetBinary(). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSQLStatement(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidEnableErrorOutput(Bool_t on = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method,",MatchSource.WIKI,root/html534/TSQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLStatement.html
https://root.cern/root/html534/TSQLStatement.html:11462,Availability,error,error,11462,,MatchSource.WIKI,root/html534/TSQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLStatement.html
https://root.cern/root/html534/TSQLStatement.html:11546,Availability,error,error,11546,"onst; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidEnableErrorOutput(Bool_t on = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Bool_tGetBinary(Int_t, void*&, Long_t&); virtual Int_tGetBufferLength() const; virtual Bool_tGetDate(Int_t, Int_t&, Int_t&, Int_t&); TDatimeGetDatime(Int_t); virtual Bool_tGetDatime(Int_t, Int_t&, Int_t&, Int_t&, Int_t&, Int_t&, Int_t&); Int_tGetDay(Int_t); virtual Double_tGetDouble(Int_t); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetErrorCode() const; virtual const char*GetErrorMsg() const; virtual const char*GetFieldName(Int_t); Int_tGetHour(Int_t); virtual const char*TObject::GetIconName() const; virtual Int_tGetInt(Int_t); virtual Bool_tGetLargeObject(Int_t col, void*& mem, Long_t& size); virtual Long_tGetLong(Int_t); virtual Long64_tGetLong64(Int",MatchSource.WIKI,root/html534/TSQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLStatement.html
https://root.cern/root/html534/TSQLStatement.html:17673,Availability,error,error,17673,"(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidClearError(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidSetError(Int_t code, const char* msg, const char* method = 0). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfErrorCodeerror code of last operation; TStringfErrorMsgerror message of last operation; Bool_tfErrorOutenable error output . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLStatement provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLStatement provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method specified, displays error message. Bool_t SetDate(Int_t , const TDatime& ); set only date value for specified parameter from TDatime object. Bool_t SetTime(Int_t , const TDatime& ); set only time value for specified parameter from TDatime object. Bool_t SetDatime(Int_t , const TDatime& ); set date & time value for specified parameter from TDatime obj",MatchSource.WIKI,root/html534/TSQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLStatement.html
https://root.cern/root/html534/TSQLStatement.html:17815,Availability,error,error,17815,"* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidClearError(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidSetError(Int_t code, const char* msg, const char* method = 0). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfErrorCodeerror code of last operation; TStringfErrorMsgerror message of last operation; Bool_tfErrorOutenable error output . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLStatement provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLStatement provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method specified, displays error message. Bool_t SetDate(Int_t , const TDatime& ); set only date value for specified parameter from TDatime object. Bool_t SetTime(Int_t , const TDatime& ); set only time value for specified parameter from TDatime object. Bool_t SetDatime(Int_t , const TDatime& ); set date & time value for specified parameter from TDatime object. Bool_t SetTimestamp(Int_t , const TDatime& ); set timestamp value for specified parameter from TDatime object. TDatime GetDatime(Int_t ); return value of parameter in form of TDatime; Be aware, that TDatime does not allow",MatchSource.WIKI,root/html534/TSQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLStatement.html
https://root.cern/root/html534/TSQLStatement.html:17859,Availability,error,error,17859,"* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidClearError(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidSetError(Int_t code, const char* msg, const char* method = 0). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfErrorCodeerror code of last operation; TStringfErrorMsgerror message of last operation; Bool_tfErrorOutenable error output . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLStatement provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLStatement provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method specified, displays error message. Bool_t SetDate(Int_t , const TDatime& ); set only date value for specified parameter from TDatime object. Bool_t SetTime(Int_t , const TDatime& ); set only time value for specified parameter from TDatime object. Bool_t SetDatime(Int_t , const TDatime& ); set date & time value for specified parameter from TDatime object. Bool_t SetTimestamp(Int_t , const TDatime& ); set timestamp value for specified parameter from TDatime object. TDatime GetDatime(Int_t ); return value of parameter in form of TDatime; Be aware, that TDatime does not allow",MatchSource.WIKI,root/html534/TSQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLStatement.html
https://root.cern/root/html534/TSQLStatement.html:17929,Availability,error,error,17929,"* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidClearError(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidSetError(Int_t code, const char* msg, const char* method = 0). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfErrorCodeerror code of last operation; TStringfErrorMsgerror message of last operation; Bool_tfErrorOutenable error output . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLStatement provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLStatement provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method specified, displays error message. Bool_t SetDate(Int_t , const TDatime& ); set only date value for specified parameter from TDatime object. Bool_t SetTime(Int_t , const TDatime& ); set only time value for specified parameter from TDatime object. Bool_t SetDatime(Int_t , const TDatime& ); set date & time value for specified parameter from TDatime object. Bool_t SetTimestamp(Int_t , const TDatime& ); set timestamp value for specified parameter from TDatime object. TDatime GetDatime(Int_t ); return value of parameter in form of TDatime; Be aware, that TDatime does not allow",MatchSource.WIKI,root/html534/TSQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLStatement.html
https://root.cern/root/html534/TSQLStatement.html:17984,Availability,error,error,17984,"size = 0) const. protected:. voidClearError(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidSetError(Int_t code, const char* msg, const char* method = 0). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfErrorCodeerror code of last operation; TStringfErrorMsgerror message of last operation; Bool_tfErrorOutenable error output . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLStatement provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLStatement provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method specified, displays error message. Bool_t SetDate(Int_t , const TDatime& ); set only date value for specified parameter from TDatime object. Bool_t SetTime(Int_t , const TDatime& ); set only time value for specified parameter from TDatime object. Bool_t SetDatime(Int_t , const TDatime& ); set date & time value for specified parameter from TDatime object. Bool_t SetTimestamp(Int_t , const TDatime& ); set timestamp value for specified parameter from TDatime object. TDatime GetDatime(Int_t ); return value of parameter in form of TDatime; Be aware, that TDatime does not allow dates before 1995-01-01. Int_t GetYear(Int_t ); return year value for parameter (if applicable). Int_t GetMonth(Int_t ); return month value for parameter (if applicable). Int_t GetDa",MatchSource.WIKI,root/html534/TSQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLStatement.html
https://root.cern/root/html534/TSQLStatement.html:18023,Availability,error,errors,18023,"size = 0) const. protected:. voidClearError(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidSetError(Int_t code, const char* msg, const char* method = 0). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfErrorCodeerror code of last operation; TStringfErrorMsgerror message of last operation; Bool_tfErrorOutenable error output . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLStatement provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLStatement provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method specified, displays error message. Bool_t SetDate(Int_t , const TDatime& ); set only date value for specified parameter from TDatime object. Bool_t SetTime(Int_t , const TDatime& ); set only time value for specified parameter from TDatime object. Bool_t SetDatime(Int_t , const TDatime& ); set date & time value for specified parameter from TDatime object. Bool_t SetTimestamp(Int_t , const TDatime& ); set timestamp value for specified parameter from TDatime object. TDatime GetDatime(Int_t ); return value of parameter in form of TDatime; Be aware, that TDatime does not allow dates before 1995-01-01. Int_t GetYear(Int_t ); return year value for parameter (if applicable). Int_t GetMonth(Int_t ); return month value for parameter (if applicable). Int_t GetDa",MatchSource.WIKI,root/html534/TSQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLStatement.html
https://root.cern/root/html534/TSQLStatement.html:18104,Availability,error,error,18104,"size = 0) const. protected:. voidClearError(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidSetError(Int_t code, const char* msg, const char* method = 0). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfErrorCodeerror code of last operation; TStringfErrorMsgerror message of last operation; Bool_tfErrorOutenable error output . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLStatement provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLStatement provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method specified, displays error message. Bool_t SetDate(Int_t , const TDatime& ); set only date value for specified parameter from TDatime object. Bool_t SetTime(Int_t , const TDatime& ); set only time value for specified parameter from TDatime object. Bool_t SetDatime(Int_t , const TDatime& ); set date & time value for specified parameter from TDatime object. Bool_t SetTimestamp(Int_t , const TDatime& ); set timestamp value for specified parameter from TDatime object. TDatime GetDatime(Int_t ); return value of parameter in form of TDatime; Be aware, that TDatime does not allow dates before 1995-01-01. Int_t GetYear(Int_t ); return year value for parameter (if applicable). Int_t GetMonth(Int_t ); return month value for parameter (if applicable). Int_t GetDa",MatchSource.WIKI,root/html534/TSQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLStatement.html
https://root.cern/root/html534/TSQLStatement.html:18145,Availability,error,error,18145," const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidSetError(Int_t code, const char* msg, const char* method = 0). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfErrorCodeerror code of last operation; TStringfErrorMsgerror message of last operation; Bool_tfErrorOutenable error output . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLStatement provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLStatement provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method specified, displays error message. Bool_t SetDate(Int_t , const TDatime& ); set only date value for specified parameter from TDatime object. Bool_t SetTime(Int_t , const TDatime& ); set only time value for specified parameter from TDatime object. Bool_t SetDatime(Int_t , const TDatime& ); set date & time value for specified parameter from TDatime object. Bool_t SetTimestamp(Int_t , const TDatime& ); set timestamp value for specified parameter from TDatime object. TDatime GetDatime(Int_t ); return value of parameter in form of TDatime; Be aware, that TDatime does not allow dates before 1995-01-01. Int_t GetYear(Int_t ); return year value for parameter (if applicable). Int_t GetMonth(Int_t ); return month value for parameter (if applicable). Int_t GetDay(Int_t ); return day value for parameter (if applicable). Int_t GetHour(Int_t ); return hours value for par",MatchSource.WIKI,root/html534/TSQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLStatement.html
https://root.cern/root/html534/TSQLStatement.html:18246,Availability,error,error,18246,"t char* msg, const char* method = 0). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfErrorCodeerror code of last operation; TStringfErrorMsgerror message of last operation; Bool_tfErrorOutenable error output . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLStatement provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLStatement provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method specified, displays error message. Bool_t SetDate(Int_t , const TDatime& ); set only date value for specified parameter from TDatime object. Bool_t SetTime(Int_t , const TDatime& ); set only time value for specified parameter from TDatime object. Bool_t SetDatime(Int_t , const TDatime& ); set date & time value for specified parameter from TDatime object. Bool_t SetTimestamp(Int_t , const TDatime& ); set timestamp value for specified parameter from TDatime object. TDatime GetDatime(Int_t ); return value of parameter in form of TDatime; Be aware, that TDatime does not allow dates before 1995-01-01. Int_t GetYear(Int_t ); return year value for parameter (if applicable). Int_t GetMonth(Int_t ); return month value for parameter (if applicable). Int_t GetDay(Int_t ); return day value for parameter (if applicable). Int_t GetHour(Int_t ); return hours value for parameter (if applicable). Int_t GetMinute(Int_t ); return minutes value for parameter (if appl",MatchSource.WIKI,root/html534/TSQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLStatement.html
https://root.cern/root/html534/TSQLStatement.html:18290,Availability,error,error,18290,"t char* msg, const char* method = 0). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfErrorCodeerror code of last operation; TStringfErrorMsgerror message of last operation; Bool_tfErrorOutenable error output . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLStatement provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLStatement provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method specified, displays error message. Bool_t SetDate(Int_t , const TDatime& ); set only date value for specified parameter from TDatime object. Bool_t SetTime(Int_t , const TDatime& ); set only time value for specified parameter from TDatime object. Bool_t SetDatime(Int_t , const TDatime& ); set date & time value for specified parameter from TDatime object. Bool_t SetTimestamp(Int_t , const TDatime& ); set timestamp value for specified parameter from TDatime object. TDatime GetDatime(Int_t ); return value of parameter in form of TDatime; Be aware, that TDatime does not allow dates before 1995-01-01. Int_t GetYear(Int_t ); return year value for parameter (if applicable). Int_t GetMonth(Int_t ); return month value for parameter (if applicable). Int_t GetDay(Int_t ); return day value for parameter (if applicable). Int_t GetHour(Int_t ); return hours value for parameter (if applicable). Int_t GetMinute(Int_t ); return minutes value for parameter (if appl",MatchSource.WIKI,root/html534/TSQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLStatement.html
https://root.cern/root/html534/TSQLStatement.html:4099,Deployability,update,update,4099,"meter is set as integer via; SetInt(), all other rows should be specified as integer. At the end,; TSQLStatement::Process() should be called. Here a small example:. // first, create statement; TSQLStatement* stmt = serv->Statement(""INSERT INTO TESTTABLE (ID1, ID2, FFIELD, FVALUE) VALUES (?, ?, ?, ?)"", 100);. for (int n=0;n<357;n++); if (stmt->NextIteration()) {; stmt->SetInt(0, 123);; stmt->SetUInt(1, n+10);; stmt->SetString(2, Form(""name %d"",n), 200);; stmt->SetString(3, Form(""value %d"", n+10), 200);; }. stmt->Process();; delete stmt;. The second argument in the TSQLServer::Statement() method specifies the depth of; of buffers which are used to keep parameter values (100 in the example). It is not; a limitation of the number of rows which can be inserted with the statement.; When buffers are filled, they will be submitted to database and can be; reused again. This happens transparent to the user in the NextIteration(); method. Oracle and some ODBC drivers support buffering of parameter values and,; as a result, bulk insert (update) operation. MySQL (native driver and; MyODBC 3) does not support such a mode of operation, therefore adding; new rows will result in communication loop to database. Local databases (SQLite3) do not use any buffering at all in the TSQLStatement; implementation (but inside the library). They still profit from the; usage of prepared statements. When inserting many rows into a SQLite3 database,; consider using a transaction via the methods StartTransaction() and Commit(); of the TSQLServer, as autocommit is active by default and causes a sync to disk; after each single insert. One should also mention differences between Oracle and ODBC SQL syntax for; parameters. ODBC (and MySQL) use question marks to specify the position; where parameters should be inserted (as shown in the example). Oracle uses; :1, :2 and so on as marks to specify the position of parameter 0, 1, and so on.; Therefore, similar to the example, a query will look like:. TSQLSt",MatchSource.WIKI,root/html534/TSQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLStatement.html
https://root.cern/root/html534/TSQLStatement.html:6823,Energy Efficiency,allocate,allocate,6823,"ult().; Information about selected fields (columns); can be obtained with GetNumFields() and GetFieldName() methods.; To receive data for the next result row, NextResultRow() method should be called.; Value from each column can be retrieved with the GetInt(), GetDouble(),; GetString() and other methods. There are no strict limitations on which method should be used; to get column values. GetString() can be used as a generic method,; which should always return correct result, but also conversions between most; basic data types are supported. For instance, if a column contains integer; values, GetInt(), GetLong64(), GetDouble() and GetString() methods can be used.; If column has floating point format, GetDouble() and GetString() methods can; be used without loss of precision while GetInt() or GetLong64() will return; only the integer part of the value. One also can test whether; a value is NULL with the IsNull() method. The buffer length specified for a statement in the TSQLServer::Statement() call; will also be used to allocate buffers for column values. Usage of these; buffers is transparent for users and does not limit the number of rows; which can be accessed with one statement. Again, local databases do not work; with buffers inside TSQLStatement at all and ignore this value.; Example of select query:. stmt = serv->Statement(""SELECT * FROM TESTTABLE"", 100);; // process statement; if (stmt->Process()) {; // store result of statement in buffer; stmt->StoreResult();. // display info about selected field; cout << ""NumFields = "" << stmt->GetNumFields() << endl;; for (int n=0;n<stmt->GetNumFields();n++); cout << ""Field "" << n << "" = "" << stmt->GetFieldName(n) << endl;. // extract rows one after another; while (stmt->NextResultRow()) {; Double_t id1 = stmt->GetDouble(0);; UInt_t id2 = stmt->GetUInt(1);; const char* name1 = stmt->GetString(2);; const char* name2 = stmt->GetString(3);; cout << id1 << "" - "" << id2 << "" "" << name1 << "" "" << name2 << endl;; }; }. 4. Working ",MatchSource.WIKI,root/html534/TSQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLStatement.html
https://root.cern/root/html534/TSQLStatement.html:8695,Integrability,interface,interface,8695," "" << id2 << "" "" << name1 << "" "" << name2 << endl;; }; }. 4. Working with date/time parameters. The current implementation supports date, time, date&time and timestamp; data (all time intervals are not supported yet). To set or get date/time values,; the following methods should be used:; SetTime()/GetTime() - only time (hour:min:sec),; SetDate()/GetDate() - only date (year-month-day),; SetDatime()/GetDatime() - date and time; SetTimestamp()/GetTimestamp() - timestamp with seconds fraction; For some of these methods TDatime type can be used as parameter / return value.; Be aware that TDatime supports only dates after 1995-01-01.; There are also methods to get year, month, day, hour, minutes and seconds separately. Note that different SQL databases treat date/time types differently.; For instance, MySQL has all correspondent types (TIME, DATE, DATETIME and TIMESTAMP),; Oracle native driver supports only DATE (which is actually date and time) and TIMESTAMP; ODBC interface provides access for time, date and timestamps,; for PostgreSQL, TIMESTAMP is available and can be retrieved via all methods,; the implementation for SQLite interprets the column content as; a timestamp with second fraction.; Due to these differences, one should use correct methods to access such data.; For instance, in MySQL SQL type 'DATE' is only date (one should use GetDate() to; access such data), while in Oracle it is date and time. Therefore,; to get complete data from a 'DATE' column in Oracle, one should use the GetDatime() method. The only difference between timestamp and date/time is that timestamp has a fractional; seconds part. Be aware that the fractional part has different meanings; (actual value) in different SQL plugins.; For PostgreSQL, it is given back as microseconds, while for SQLite3,; milliseconds correspond to the fraction (similar to the DATETIME-functions; implemented in the SQLite3 language). 5. Binary data. Most modern data bases support just binary data, which is; typicall",MatchSource.WIKI,root/html534/TSQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLStatement.html
https://root.cern/root/html534/TSQLStatement.html:17624,Integrability,message,message,17624,"(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidClearError(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidSetError(Int_t code, const char* msg, const char* method = 0). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfErrorCodeerror code of last operation; TStringfErrorMsgerror message of last operation; Bool_tfErrorOutenable error output . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLStatement provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLStatement provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method specified, displays error message. Bool_t SetDate(Int_t , const TDatime& ); set only date value for specified parameter from TDatime object. Bool_t SetTime(Int_t , const TDatime& ); set only time value for specified parameter from TDatime object. Bool_t SetDatime(Int_t , const TDatime& ); set date & time value for specified parameter from TDatime obj",MatchSource.WIKI,root/html534/TSQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLStatement.html
https://root.cern/root/html534/TSQLStatement.html:17990,Integrability,message,message,17990,"size = 0) const. protected:. voidClearError(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidSetError(Int_t code, const char* msg, const char* method = 0). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfErrorCodeerror code of last operation; TStringfErrorMsgerror message of last operation; Bool_tfErrorOutenable error output . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLStatement provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLStatement provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method specified, displays error message. Bool_t SetDate(Int_t , const TDatime& ); set only date value for specified parameter from TDatime object. Bool_t SetTime(Int_t , const TDatime& ); set only time value for specified parameter from TDatime object. Bool_t SetDatime(Int_t , const TDatime& ); set date & time value for specified parameter from TDatime object. Bool_t SetTimestamp(Int_t , const TDatime& ); set timestamp value for specified parameter from TDatime object. TDatime GetDatime(Int_t ); return value of parameter in form of TDatime; Be aware, that TDatime does not allow dates before 1995-01-01. Int_t GetYear(Int_t ); return year value for parameter (if applicable). Int_t GetMonth(Int_t ); return month value for parameter (if applicable). Int_t GetDa",MatchSource.WIKI,root/html534/TSQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLStatement.html
https://root.cern/root/html534/TSQLStatement.html:18110,Integrability,message,messages,18110,"size = 0) const. protected:. voidClearError(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidSetError(Int_t code, const char* msg, const char* method = 0). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfErrorCodeerror code of last operation; TStringfErrorMsgerror message of last operation; Bool_tfErrorOutenable error output . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLStatement provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLStatement provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method specified, displays error message. Bool_t SetDate(Int_t , const TDatime& ); set only date value for specified parameter from TDatime object. Bool_t SetTime(Int_t , const TDatime& ); set only time value for specified parameter from TDatime object. Bool_t SetDatime(Int_t , const TDatime& ); set date & time value for specified parameter from TDatime object. Bool_t SetTimestamp(Int_t , const TDatime& ); set timestamp value for specified parameter from TDatime object. TDatime GetDatime(Int_t ); return value of parameter in form of TDatime; Be aware, that TDatime does not allow dates before 1995-01-01. Int_t GetYear(Int_t ); return year value for parameter (if applicable). Int_t GetMonth(Int_t ); return month value for parameter (if applicable). Int_t GetDa",MatchSource.WIKI,root/html534/TSQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLStatement.html
https://root.cern/root/html534/TSQLStatement.html:18296,Integrability,message,message,18296,"t char* msg, const char* method = 0). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfErrorCodeerror code of last operation; TStringfErrorMsgerror message of last operation; Bool_tfErrorOutenable error output . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLStatement provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLStatement provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method specified, displays error message. Bool_t SetDate(Int_t , const TDatime& ); set only date value for specified parameter from TDatime object. Bool_t SetTime(Int_t , const TDatime& ); set only time value for specified parameter from TDatime object. Bool_t SetDatime(Int_t , const TDatime& ); set date & time value for specified parameter from TDatime object. Bool_t SetTimestamp(Int_t , const TDatime& ); set timestamp value for specified parameter from TDatime object. TDatime GetDatime(Int_t ); return value of parameter in form of TDatime; Be aware, that TDatime does not allow dates before 1995-01-01. Int_t GetYear(Int_t ); return year value for parameter (if applicable). Int_t GetMonth(Int_t ); return month value for parameter (if applicable). Int_t GetDay(Int_t ); return day value for parameter (if applicable). Int_t GetHour(Int_t ); return hours value for parameter (if applicable). Int_t GetMinute(Int_t ); return minutes value for parameter (if appl",MatchSource.WIKI,root/html534/TSQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLStatement.html
https://root.cern/root/html534/TSQLStatement.html:9443,Modifiability,plugin,plugins,9443,"day, hour, minutes and seconds separately. Note that different SQL databases treat date/time types differently.; For instance, MySQL has all correspondent types (TIME, DATE, DATETIME and TIMESTAMP),; Oracle native driver supports only DATE (which is actually date and time) and TIMESTAMP; ODBC interface provides access for time, date and timestamps,; for PostgreSQL, TIMESTAMP is available and can be retrieved via all methods,; the implementation for SQLite interprets the column content as; a timestamp with second fraction.; Due to these differences, one should use correct methods to access such data.; For instance, in MySQL SQL type 'DATE' is only date (one should use GetDate() to; access such data), while in Oracle it is date and time. Therefore,; to get complete data from a 'DATE' column in Oracle, one should use the GetDatime() method. The only difference between timestamp and date/time is that timestamp has a fractional; seconds part. Be aware that the fractional part has different meanings; (actual value) in different SQL plugins.; For PostgreSQL, it is given back as microseconds, while for SQLite3,; milliseconds correspond to the fraction (similar to the DATETIME-functions; implemented in the SQLite3 language). 5. Binary data. Most modern data bases support just binary data, which is; typically has SQL type name 'BLOB'. To access data in such; columns, GetBinary()/SetBinary() methods should be used.; The current implementation implies that the complete content of the; column must be retrieved at once. Therefore, very big data of; gigabytes size may cause a problem. In addition, for PostgresSQL, the methods GetLargeObject()/SetLargeObject(); are implemented with similar syntax. They retrieve a large object for the OID; given in the column of the statement. For non-PostgreSQL databases,; calling GetLargeObject()/SetLargeObject() is redirected to GetBinary()/SetBinary(). Function Members (Methods);      This is an abstract class, constructors will not be documented",MatchSource.WIKI,root/html534/TSQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLStatement.html
https://root.cern/root/html534/TSQLStatement.html:780,Security,access,accessing,780,". TSQLStatement. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TSQLStatement. class TSQLStatement: public TObject. TSQLStatement. Abstract base class defining SQL statements, which can be submitted; in bulk to DB server. This is alternative to TSQLServer::Query() method, which allows only pure; text queries and pure text result in TSQLResult classes.; TSQLStatement is designed to support following features:; - usage of basic data types (like int or double) as parameters; in SQL statements; - bulk operation when inserting/updating/selecting data in database; - uasge of basic data types when accessing result set of executed query. 1. Creation of statement. To create an instance of the TSQLStatement class, the TSQLServer::Statement() method; should be used. Depending on the driver used for an ODBC connection,; the appropriate object instance will be created. For the moment there are; six different implementations of the TSQLStatement class: for MySQL,; Oracle, SAPDB, PostgreSQL, SQLite3 and ODBC. Hopefully, support of ODBC will allow usage of; statements for most existing RDBMS. // first, connect to the database; TSQLServer* serv = TSQLServer::Connect(""mysql://hostname.domain:3306/test"",; ""user"", ""pass"");; // check if connection is ok; if ((serv!=0) && serv->IsConnected()) {; // create instance of sql-statement; TSQLStatement* stmt = serv->Statement(""CREATE TABLE TESTTABLE (ID1 INT, ID2 INT, FFIELD VARCHAR(255), FVALUE VARCHAR(255))"";; // process statement; stmt->Process();; // destroy object; delete stmt;; }; delete serv;. 2. Insert data to data base. There is a special syntax of SQL queries which allows to use values; provided as parameters. For instance, to insert one row into the TESTTABLE created; with the previous example, one can simply execute a query like:. serv->Query(""INSERT INTO",MatchSource.WIKI,root/html534/TSQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLStatement.html
https://root.cern/root/html534/TSQLStatement.html:6960,Security,access,accessed,6960,"for the next result row, NextResultRow() method should be called.; Value from each column can be retrieved with the GetInt(), GetDouble(),; GetString() and other methods. There are no strict limitations on which method should be used; to get column values. GetString() can be used as a generic method,; which should always return correct result, but also conversions between most; basic data types are supported. For instance, if a column contains integer; values, GetInt(), GetLong64(), GetDouble() and GetString() methods can be used.; If column has floating point format, GetDouble() and GetString() methods can; be used without loss of precision while GetInt() or GetLong64() will return; only the integer part of the value. One also can test whether; a value is NULL with the IsNull() method. The buffer length specified for a statement in the TSQLServer::Statement() call; will also be used to allocate buffers for column values. Usage of these; buffers is transparent for users and does not limit the number of rows; which can be accessed with one statement. Again, local databases do not work; with buffers inside TSQLStatement at all and ignore this value.; Example of select query:. stmt = serv->Statement(""SELECT * FROM TESTTABLE"", 100);; // process statement; if (stmt->Process()) {; // store result of statement in buffer; stmt->StoreResult();. // display info about selected field; cout << ""NumFields = "" << stmt->GetNumFields() << endl;; for (int n=0;n<stmt->GetNumFields();n++); cout << ""Field "" << n << "" = "" << stmt->GetFieldName(n) << endl;. // extract rows one after another; while (stmt->NextResultRow()) {; Double_t id1 = stmt->GetDouble(0);; UInt_t id2 = stmt->GetUInt(1);; const char* name1 = stmt->GetString(2);; const char* name2 = stmt->GetString(3);; cout << id1 << "" - "" << id2 << "" "" << name1 << "" "" << name2 << endl;; }; }. 4. Working with date/time parameters. The current implementation supports date, time, date&time and timestamp; data (all time intervals are not s",MatchSource.WIKI,root/html534/TSQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLStatement.html
https://root.cern/root/html534/TSQLStatement.html:8714,Security,access,access,8714," "" << id2 << "" "" << name1 << "" "" << name2 << endl;; }; }. 4. Working with date/time parameters. The current implementation supports date, time, date&time and timestamp; data (all time intervals are not supported yet). To set or get date/time values,; the following methods should be used:; SetTime()/GetTime() - only time (hour:min:sec),; SetDate()/GetDate() - only date (year-month-day),; SetDatime()/GetDatime() - date and time; SetTimestamp()/GetTimestamp() - timestamp with seconds fraction; For some of these methods TDatime type can be used as parameter / return value.; Be aware that TDatime supports only dates after 1995-01-01.; There are also methods to get year, month, day, hour, minutes and seconds separately. Note that different SQL databases treat date/time types differently.; For instance, MySQL has all correspondent types (TIME, DATE, DATETIME and TIMESTAMP),; Oracle native driver supports only DATE (which is actually date and time) and TIMESTAMP; ODBC interface provides access for time, date and timestamps,; for PostgreSQL, TIMESTAMP is available and can be retrieved via all methods,; the implementation for SQLite interprets the column content as; a timestamp with second fraction.; Due to these differences, one should use correct methods to access such data.; For instance, in MySQL SQL type 'DATE' is only date (one should use GetDate() to; access such data), while in Oracle it is date and time. Therefore,; to get complete data from a 'DATE' column in Oracle, one should use the GetDatime() method. The only difference between timestamp and date/time is that timestamp has a fractional; seconds part. Be aware that the fractional part has different meanings; (actual value) in different SQL plugins.; For PostgreSQL, it is given back as microseconds, while for SQLite3,; milliseconds correspond to the fraction (similar to the DATETIME-functions; implemented in the SQLite3 language). 5. Binary data. Most modern data bases support just binary data, which is; typicall",MatchSource.WIKI,root/html534/TSQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLStatement.html
https://root.cern/root/html534/TSQLStatement.html:8990,Security,access,access,8990,"s,; the following methods should be used:; SetTime()/GetTime() - only time (hour:min:sec),; SetDate()/GetDate() - only date (year-month-day),; SetDatime()/GetDatime() - date and time; SetTimestamp()/GetTimestamp() - timestamp with seconds fraction; For some of these methods TDatime type can be used as parameter / return value.; Be aware that TDatime supports only dates after 1995-01-01.; There are also methods to get year, month, day, hour, minutes and seconds separately. Note that different SQL databases treat date/time types differently.; For instance, MySQL has all correspondent types (TIME, DATE, DATETIME and TIMESTAMP),; Oracle native driver supports only DATE (which is actually date and time) and TIMESTAMP; ODBC interface provides access for time, date and timestamps,; for PostgreSQL, TIMESTAMP is available and can be retrieved via all methods,; the implementation for SQLite interprets the column content as; a timestamp with second fraction.; Due to these differences, one should use correct methods to access such data.; For instance, in MySQL SQL type 'DATE' is only date (one should use GetDate() to; access such data), while in Oracle it is date and time. Therefore,; to get complete data from a 'DATE' column in Oracle, one should use the GetDatime() method. The only difference between timestamp and date/time is that timestamp has a fractional; seconds part. Be aware that the fractional part has different meanings; (actual value) in different SQL plugins.; For PostgreSQL, it is given back as microseconds, while for SQLite3,; milliseconds correspond to the fraction (similar to the DATETIME-functions; implemented in the SQLite3 language). 5. Binary data. Most modern data bases support just binary data, which is; typically has SQL type name 'BLOB'. To access data in such; columns, GetBinary()/SetBinary() methods should be used.; The current implementation implies that the complete content of the; column must be retrieved at once. Therefore, very big data of; gigaby",MatchSource.WIKI,root/html534/TSQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLStatement.html
https://root.cern/root/html534/TSQLStatement.html:9091,Security,access,access,9091,"() - only date (year-month-day),; SetDatime()/GetDatime() - date and time; SetTimestamp()/GetTimestamp() - timestamp with seconds fraction; For some of these methods TDatime type can be used as parameter / return value.; Be aware that TDatime supports only dates after 1995-01-01.; There are also methods to get year, month, day, hour, minutes and seconds separately. Note that different SQL databases treat date/time types differently.; For instance, MySQL has all correspondent types (TIME, DATE, DATETIME and TIMESTAMP),; Oracle native driver supports only DATE (which is actually date and time) and TIMESTAMP; ODBC interface provides access for time, date and timestamps,; for PostgreSQL, TIMESTAMP is available and can be retrieved via all methods,; the implementation for SQLite interprets the column content as; a timestamp with second fraction.; Due to these differences, one should use correct methods to access such data.; For instance, in MySQL SQL type 'DATE' is only date (one should use GetDate() to; access such data), while in Oracle it is date and time. Therefore,; to get complete data from a 'DATE' column in Oracle, one should use the GetDatime() method. The only difference between timestamp and date/time is that timestamp has a fractional; seconds part. Be aware that the fractional part has different meanings; (actual value) in different SQL plugins.; For PostgreSQL, it is given back as microseconds, while for SQLite3,; milliseconds correspond to the fraction (similar to the DATETIME-functions; implemented in the SQLite3 language). 5. Binary data. Most modern data bases support just binary data, which is; typically has SQL type name 'BLOB'. To access data in such; columns, GetBinary()/SetBinary() methods should be used.; The current implementation implies that the complete content of the; column must be retrieved at once. Therefore, very big data of; gigabytes size may cause a problem. In addition, for PostgresSQL, the methods GetLargeObject()/SetLargeObject(); ar",MatchSource.WIKI,root/html534/TSQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLStatement.html
https://root.cern/root/html534/TSQLStatement.html:9751,Security,access,access,9751,"able and can be retrieved via all methods,; the implementation for SQLite interprets the column content as; a timestamp with second fraction.; Due to these differences, one should use correct methods to access such data.; For instance, in MySQL SQL type 'DATE' is only date (one should use GetDate() to; access such data), while in Oracle it is date and time. Therefore,; to get complete data from a 'DATE' column in Oracle, one should use the GetDatime() method. The only difference between timestamp and date/time is that timestamp has a fractional; seconds part. Be aware that the fractional part has different meanings; (actual value) in different SQL plugins.; For PostgreSQL, it is given back as microseconds, while for SQLite3,; milliseconds correspond to the fraction (similar to the DATETIME-functions; implemented in the SQLite3 language). 5. Binary data. Most modern data bases support just binary data, which is; typically has SQL type name 'BLOB'. To access data in such; columns, GetBinary()/SetBinary() methods should be used.; The current implementation implies that the complete content of the; column must be retrieved at once. Therefore, very big data of; gigabytes size may cause a problem. In addition, for PostgresSQL, the methods GetLargeObject()/SetLargeObject(); are implemented with similar syntax. They retrieve a large object for the OID; given in the column of the statement. For non-PostgreSQL databases,; calling GetLargeObject()/SetLargeObject() is redirected to GetBinary()/SetBinary(). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSQLStatement(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObjec",MatchSource.WIKI,root/html534/TSQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLStatement.html
https://root.cern/root/html534/TSQLStatement.html:1380,Testability,test,test,1380,"nt is designed to support following features:; - usage of basic data types (like int or double) as parameters; in SQL statements; - bulk operation when inserting/updating/selecting data in database; - uasge of basic data types when accessing result set of executed query. 1. Creation of statement. To create an instance of the TSQLStatement class, the TSQLServer::Statement() method; should be used. Depending on the driver used for an ODBC connection,; the appropriate object instance will be created. For the moment there are; six different implementations of the TSQLStatement class: for MySQL,; Oracle, SAPDB, PostgreSQL, SQLite3 and ODBC. Hopefully, support of ODBC will allow usage of; statements for most existing RDBMS. // first, connect to the database; TSQLServer* serv = TSQLServer::Connect(""mysql://hostname.domain:3306/test"",; ""user"", ""pass"");; // check if connection is ok; if ((serv!=0) && serv->IsConnected()) {; // create instance of sql-statement; TSQLStatement* stmt = serv->Statement(""CREATE TABLE TESTTABLE (ID1 INT, ID2 INT, FFIELD VARCHAR(255), FVALUE VARCHAR(255))"";; // process statement; stmt->Process();; // destroy object; delete stmt;; }; delete serv;. 2. Insert data to data base. There is a special syntax of SQL queries which allows to use values; provided as parameters. For instance, to insert one row into the TESTTABLE created; with the previous example, one can simply execute a query like:. serv->Query(""INSERT INTO TESTTABLE VALUES (1, 2, \""name1\"", \""value1\"""");. However, when many (100-1000) rows should be inserted, each call of; TSQLServer::Query() method will cause communication loop with database; server, and the statement has to be evaluated each time instead of using a prepared statement.; As a result, insertion of data takes too much time. TSQLStatement provides a mechanism to insert many rows at once.; First of all, an appropriate statement should be created:. TSQLStatement* stmt = serv->Statement(""INSERT INTO TESTTABLE (ID1, ID2, FFIELD, FVAL",MatchSource.WIKI,root/html534/TSQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLStatement.html
https://root.cern/root/html534/TSQLStatement.html:6665,Testability,test,test,6665,"nd the result of statement; should be stored in internal buffers with the method TSQLStatement::StoreResult().; Information about selected fields (columns); can be obtained with GetNumFields() and GetFieldName() methods.; To receive data for the next result row, NextResultRow() method should be called.; Value from each column can be retrieved with the GetInt(), GetDouble(),; GetString() and other methods. There are no strict limitations on which method should be used; to get column values. GetString() can be used as a generic method,; which should always return correct result, but also conversions between most; basic data types are supported. For instance, if a column contains integer; values, GetInt(), GetLong64(), GetDouble() and GetString() methods can be used.; If column has floating point format, GetDouble() and GetString() methods can; be used without loss of precision while GetInt() or GetLong64() will return; only the integer part of the value. One also can test whether; a value is NULL with the IsNull() method. The buffer length specified for a statement in the TSQLServer::Statement() call; will also be used to allocate buffers for column values. Usage of these; buffers is transparent for users and does not limit the number of rows; which can be accessed with one statement. Again, local databases do not work; with buffers inside TSQLStatement at all and ignore this value.; Example of select query:. stmt = serv->Statement(""SELECT * FROM TESTTABLE"", 100);; // process statement; if (stmt->Process()) {; // store result of statement in buffer; stmt->StoreResult();. // display info about selected field; cout << ""NumFields = "" << stmt->GetNumFields() << endl;; for (int n=0;n<stmt->GetNumFields();n++); cout << ""Field "" << n << "" = "" << stmt->GetFieldName(n) << endl;. // extract rows one after another; while (stmt->NextResultRow()) {; Double_t id1 = stmt->GetDouble(0);; UInt_t id2 = stmt->GetUInt(1);; const char* name1 = stmt->GetString(2);; const char* name2 = stmt-",MatchSource.WIKI,root/html534/TSQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLStatement.html
https://root.cern/root/html534/TSQLStatement.html:1947,Usability,simpl,simply,1947,"tatement() method; should be used. Depending on the driver used for an ODBC connection,; the appropriate object instance will be created. For the moment there are; six different implementations of the TSQLStatement class: for MySQL,; Oracle, SAPDB, PostgreSQL, SQLite3 and ODBC. Hopefully, support of ODBC will allow usage of; statements for most existing RDBMS. // first, connect to the database; TSQLServer* serv = TSQLServer::Connect(""mysql://hostname.domain:3306/test"",; ""user"", ""pass"");; // check if connection is ok; if ((serv!=0) && serv->IsConnected()) {; // create instance of sql-statement; TSQLStatement* stmt = serv->Statement(""CREATE TABLE TESTTABLE (ID1 INT, ID2 INT, FFIELD VARCHAR(255), FVALUE VARCHAR(255))"";; // process statement; stmt->Process();; // destroy object; delete stmt;; }; delete serv;. 2. Insert data to data base. There is a special syntax of SQL queries which allows to use values; provided as parameters. For instance, to insert one row into the TESTTABLE created; with the previous example, one can simply execute a query like:. serv->Query(""INSERT INTO TESTTABLE VALUES (1, 2, \""name1\"", \""value1\"""");. However, when many (100-1000) rows should be inserted, each call of; TSQLServer::Query() method will cause communication loop with database; server, and the statement has to be evaluated each time instead of using a prepared statement.; As a result, insertion of data takes too much time. TSQLStatement provides a mechanism to insert many rows at once.; First of all, an appropriate statement should be created:. TSQLStatement* stmt = serv->Statement(""INSERT INTO TESTTABLE (ID1, ID2, FFIELD, FVALUE) VALUES (?, ?, ?, ?)"", 100);. Here question marks ""?"" indicate where statement parameters can be inserted.; To specify values of parameters, SetInt(), SetDouble(), SetString() and other; methods of the TSQLStatement class should be used. Before parameters values; can be specified, the NextIteration() method of statement class should be called.; For each new ro",MatchSource.WIKI,root/html534/TSQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLStatement.html
https://root.cern/root/html534/TSQLStructure.html:2309,Availability,error,error,2309,"t::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tConvertToTables(TSQLFile* f, Long64_t keyid, TObjArray* cmds); virtual voidTObject::Copy(TObject& object) const; static TStringDefineElementColumnName(TStreamerElement* elem, TSQLFile* f, Int_t indx = 0); static Int_tDefineElementColumnType(TStreamerElement* elem, TSQLFile* f); Long64_tDefineObjectId(Bool_t recursive = kTRUE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetArrayIndex() const; TSQLStructure*GetChild(Int_t n) const; Bool_tGetClassInfo(TClass*& cl, Version_t& version); TClass*GetCustomClass() const; Version_tGetCustomClassVersion() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TStreamerElement*GetElement() const; Int_tGetElementNumber() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; TClass*GetObjectClass() const; TSQLObjectData*GetObjectData(Bool_t search = false); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t",MatchSource.WIKI,root/html534/TSQLStructure.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLStructure.html
https://root.cern/root/html534/TSQLStructure.html:2393,Availability,error,error,2393,"bject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tConvertToTables(TSQLFile* f, Long64_t keyid, TObjArray* cmds); virtual voidTObject::Copy(TObject& object) const; static TStringDefineElementColumnName(TStreamerElement* elem, TSQLFile* f, Int_t indx = 0); static Int_tDefineElementColumnType(TStreamerElement* elem, TSQLFile* f); Long64_tDefineObjectId(Bool_t recursive = kTRUE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetArrayIndex() const; TSQLStructure*GetChild(Int_t n) const; Bool_tGetClassInfo(TClass*& cl, Version_t& version); TClass*GetCustomClass() const; Version_tGetCustomClassVersion() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TStreamerElement*GetElement() const; Int_tGetElementNumber() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; TClass*GetObjectClass() const; TSQLObjectData*GetObjectData(Bool_t search = false); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TSQLStructure*GetParent() const; Int_tGetRepeatCounter(",MatchSource.WIKI,root/html534/TSQLStructure.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLStructure.html
https://root.cern/root/html534/TSQLStructure.html:12987,Performance,perform,perform,12987," data. void AddObjectData(TSQLObjectData* objdata); add element with pointer to object data. TSQLObjectData* GetObjectData(Bool_t search = false); searchs for objects data. void Print(Option_t* option = """") const; print content of complete structure. void PrintLevel(Int_t level) const; print content of current structure. Bool_t IsNumericType(Int_t typ); defines if value is numeric and not requires quotes when writing. const char* GetSimpleTypeName(Int_t typ); provides name for basic types; used as suffix for column name or field suffix in raw table. Long64_t FindMaxObjectId(); define maximum reference id, used for objects. Bool_t ConvertToTables(TSQLFile* f, Long64_t keyid, TObjArray* cmds); Convert structure to sql statements; This function is called immidiately after TBufferSQL2 produces; this structure with object data; Should be only called for toplevel structure. void PerformConversion(TSqlRegistry* reg, TSqlRawBuffer* blobs, const char* topname, Bool_t useblob = kFALSE); perform conversion of structure to sql statements; first tries convert it to normal form; if fails, produces data for raw table. Bool_t StoreObject(TSqlRegistry* reg, Long64_t objid, TClass* cl, Bool_t registerobj = kTRUE); convert object data to sql statements; if normal (columnwise) representation is not possible,; complete object will be converted to raw format. Bool_t StoreObjectInNormalForm(TSqlRegistry* reg); this function verify object child elements and; calls transformation to class table. Bool_t StoreClassInNormalForm(TSqlRegistry* reg); produces data for complete class table; where not possible, raw data for some elements are created. TString MakeArrayIndex(TStreamerElement* elem, Int_t n); produce string with complete index like [1][2][0]. Bool_t StoreElementInNormalForm(TSqlRegistry* reg, TSQLTableData* columns); tries to store element data in column. Bool_t TryConvertObjectArray(TSqlRegistry* reg, TSqlRawBuffer* blobs); tries to write array of objects as lis of object refereneces",MatchSource.WIKI,root/html534/TSQLStructure.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLStructure.html
https://root.cern/root/html534/TSQLTableData.html:1868,Availability,error,error,1868,"; voidAddColumn(const char* name, Long64_t value); voidAddColumn(const char* name, const char* sqltype, const char* value, Bool_t numeric); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetColumn(Int_t n); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Int_tGetNumColumns(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual B",MatchSource.WIKI,root/html534/TSQLTableData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLTableData.html
https://root.cern/root/html534/TSQLTableData.html:1952,Availability,error,error,1952,"onst char* sqltype, const char* value, Bool_t numeric); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetColumn(Int_t n); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Int_tGetNumColumns(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::Inhe",MatchSource.WIKI,root/html534/TSQLTableData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLTableData.html
https://root.cern/root/html534/TSQLTableInfo.html:1661,Availability,error,error,1661,"onst char* create_time = 0, const char* update_time = 0); virtual~TSQLTableInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TSQLColumnInfo*FindColumn(const char* columnname); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TList*GetColumns() const; const char*GetCreateTime() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetEngine() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUpdateTime() const; virt",MatchSource.WIKI,root/html534/TSQLTableInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLTableInfo.html
https://root.cern/root/html534/TSQLTableInfo.html:1745,Availability,error,error,1745,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TSQLColumnInfo*FindColumn(const char* columnname); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TList*GetColumns() const; const char*GetCreateTime() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetEngine() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUpdateTime() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; ",MatchSource.WIKI,root/html534/TSQLTableInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLTableInfo.html
https://root.cern/root/html534/TSQLTableInfo.html:435,Deployability,update,update,435,". TSQLTableInfo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TSQLTableInfo. class TSQLTableInfo: public TNamed. TSQLTableInfo. Contains information about table and table columns.; For MySQL additional information like engine type,; creation and last update time is provided. Function Members (Methods); public:. TSQLTableInfo(); TSQLTableInfo(const TSQLTableInfo&); TSQLTableInfo(const char* tablename, TList* columns, const char* comment = ""SQL table"", const char* engine = 0, const char* create_time = 0, const char* update_time = 0); virtual~TSQLTableInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TSQLColumnInfo*FindColumn(const char* columnname); virt",MatchSource.WIKI,root/html534/TSQLTableInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLTableInfo.html
https://root.cern/root/html534/TSQLTableInfo.html:6131,Deployability,update,update,6131,"ject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*fColumns! list of TSQLColumnInfo objects, describing each table column; TStringfCreateTime! table creation time ; TStringfEngine! SQL tables engine name; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TStringfUpdateTime! table update time. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSQLTableInfo(); default constructor. TSQLTableInfo(const char* tablename, TList* columns, const char* comment = ""SQL table"", const char* engine = 0, const char* create_time = 0, const char* update_time = 0); normal constructor. ~TSQLTableInfo(); destructor. void Print(Option_t* option = """") const; Prints table and table columns info. TSQLColumnInfo* FindColumn(const char* columnname); Return column info object of given name. TSQLTableInfo(). TList* GetColumns() const; { return fColumns; }. const char* GetEngine() const; { return fEngine.Data(); }. const char* GetCreateTime() const; { return fCreateTime.Data(); }. const char* GetUpdateTime() const; { return fUpdateTime.Data(); }. » Author: Sergey Linev 31/05/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rad",MatchSource.WIKI,root/html534/TSQLTableInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSQLTableInfo.html
https://root.cern/root/html534/TSSLSocket.html:2070,Availability,error,error,2070,"* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; static TSocket*TSocket::CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0, Int_t* err = 0); static TSocket*TSocket::CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0, Int_t* err = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UInt_tTSocket::GetBytesRecv() const; UInt_tTSocket::GetBytesSent() const; static Int_tTSocket::GetClientProtocol(); Int_tTSocket::GetCompressionAlgorithm() const; Int_tTSocket::GetCompressionLevel() const; Int_tTSocket::GetCompressionSettings() const; virtual Int_tTSocket::GetDescriptor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tTSocket::GetErrorCode() const; virtual const char*TObject::GetIconName() const; TInetAddressTSocket::GetInetAddress() const; TTimeStampTSocket::GetLastUsage(); virtual TInetAddressTSocket::GetLocalInetAddre",MatchSource.WIKI,root/html534/TSSLSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSSLSocket.html
https://root.cern/root/html534/TSSLSocket.html:2154,Availability,error,error,2154,"al voidClose(Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; static TSocket*TSocket::CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0, Int_t* err = 0); static TSocket*TSocket::CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0, Int_t* err = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UInt_tTSocket::GetBytesRecv() const; UInt_tTSocket::GetBytesSent() const; static Int_tTSocket::GetClientProtocol(); Int_tTSocket::GetCompressionAlgorithm() const; Int_tTSocket::GetCompressionLevel() const; Int_tTSocket::GetCompressionSettings() const; virtual Int_tTSocket::GetDescriptor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tTSocket::GetErrorCode() const; virtual const char*TObject::GetIconName() const; TInetAddressTSocket::GetInetAddress() const; TTimeStampTSocket::GetLastUsage(); virtual TInetAddressTSocket::GetLocalInetAddress(); virtual Int_tTSocket::GetLocalPort(); virtual const char*TNamed::GetName() con",MatchSource.WIKI,root/html534/TSSLSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSSLSocket.html
https://root.cern/root/html534/TSSLSocket.html:4621,Availability,error,error,4621,":GetTcpWindowSize() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*TSocket::GetUrl() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTSocket::IsAuthenticated() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTSocket::IsValid() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidTSocket::NetError(const char* where, Int_t error); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tTSocket::Reconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRecv(TMessage*& mess); virtual Int_tRecv(Int_t& status, Int_t& kind); virtual Int_tRecv(char* mess, Int_t max); virtual Int_tRecv(char* mess",MatchSource.WIKI,root/html534/TSSLSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSSLSocket.html
https://root.cern/root/html534/TSSLSocket.html:11229,Deployability,configurat,configuration,11229,"gClientProtocolclient ""protocol"" version. private:. ssl_st*fSSL; ssl_ctx_st*fSSLCtx; static charfgSSLCAFile[2147483647]; static charfgSSLCAPath[2147483647]; static charfgSSLUCert[2147483647]; static charfgSSLUKey[2147483647]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void WrapWithSSL(void); Wraps the socket with OpenSSL. TSSLSocket(TInetAddress addr, const char* service, Int_t tcpwindowsize = -1). TSSLSocket(TInetAddress addr, Int_t port, Int_t tcpwindowsize = -1). TSSLSocket(const char* host, const char* service, Int_t tcpwindowsize = -1). TSSLSocket(const char* url, Int_t port, Int_t tcpwindowsize = -1). TSSLSocket(const char* sockpath). TSSLSocket(Int_t desc). TSSLSocket(Int_t desc, const char* sockpath). TSSLSocket(const TSSLSocket& s). ~TSSLSocket(); Close gracefully the connection, and free SSL structures. void Close(Option_t* option = """"); Close the SSL connection. void SetUpSSL(const char* cafile, const char* capath, const char* ucert, const char* ukey); Set up the static configuration variables. Int_t Recv(TMessage*& mess). Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Int_t Send(const TMessage& mess). Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. TSSLSocket(); {}. Int_t Recv(TMessage*& mess); The rest of the Send and Recv calls rely ultimately on these,; so it is enough to overload them. Int_t Send(const TMessage& mess). Int_t Send(Int_t kind); Issue with hidden method :(. { return TSocket::Send(kind); }. Int_t Send(Int_t status, Int_t kind); { return TSocket::Send(status, kind); }. Int_t Recv(Int_t& status, Int_t& kind); { return TSocket::Recv(status, kind); }. Int_t Recv(char* mess, Int_t max); { return TSocket::Recv(mess, max); }. » Author: Alejandro Alvarez 16/09/2011 » Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$I",MatchSource.WIKI,root/html534/TSSLSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSSLSocket.html
https://root.cern/root/html534/TSSLSocket.html:311,Integrability,wrap,wrapped,311,". TSSLSocket. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TSSLSocket. class TSSLSocket: public TSocket. TSSLSocket. A TSocket wrapped in by SSL. Function Members (Methods); public:. TSSLSocket(const char* sockpath); TSSLSocket(Int_t desc); TSSLSocket(const TSSLSocket& s); TSSLSocket(Int_t desc, const char* sockpath); TSSLSocket(TInetAddress addr, const char* service, Int_t tcpwindowsize = -1); TSSLSocket(TInetAddress addr, Int_t port, Int_t tcpwindowsize = -1); TSSLSocket(const char* host, const char* service, Int_t tcpwindowsize = -1); TSSLSocket(const char* url, Int_t port, Int_t tcpwindowsize = -1); virtual~TSSLSocket(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; static TSocket*TSocket::CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0, Int_t* err = 0); static TSocket*TSocket::CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0, Int_t* err = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual",MatchSource.WIKI,root/html534/TSSLSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSSLSocket.html
https://root.cern/root/html534/TSSLSocket.html:10208,Integrability,protocol,protocol,10208,"t { kRead; kWrite; };; enum TSocket::EServiceType { kSOCKD; kROOTD; kPROOFD; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TInetAddressTSocket::fAddressremote internet address and port #; TBitsTSocket::fBitsInfobits array to mark TStreamerInfo classes already sent; UInt_tTSocket::fBytesRecvtotal bytes received over this socket; UInt_tTSocket::fBytesSenttotal bytes sent using this socket; Int_tTSocket::fCompressCompression level and algorithm; TTimeStampTSocket::fLastUsageTime stamp of last usage; TVirtualMutex*TSocket::fLastUsageMtxProtect last usage setting / reading; TInetAddressTSocket::fLocalAddresslocal internet address and port #; TStringTNamed::fNameobject identifier; Int_tTSocket::fRemoteProtocolprotocol of remote daemon; TSecContext*TSocket::fSecContextafter a successful Authenticate call; TSocket::EServiceTypeTSocket::fServTyperemote service type; TStringTSocket::fServicename of service (matches remote port #); Int_tTSocket::fSocketsocket descriptor; Int_tTSocket::fTcpWindowSizeTCP window size (default 65535);; TStringTNamed::fTitleobject title; TList*TSocket::fUUIDslist of TProcessIDs already sent through the socket; TStringTSocket::fUrlneeds this for special authentication options; static ULong64_tTSocket::fgBytesRecvtotal bytes received by all socket objects; static ULong64_tTSocket::fgBytesSenttotal bytes sent by all socket objects; static Int_tTSocket::fgClientProtocolclient ""protocol"" version. private:. ssl_st*fSSL; ssl_ctx_st*fSSLCtx; static charfgSSLCAFile[2147483647]; static charfgSSLCAPath[2147483647]; static charfgSSLUCert[2147483647]; static charfgSSLUKey[2147483647]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void WrapWithSSL(void); Wraps the socket with OpenSSL. TSSLSocket(TIn",MatchSource.WIKI,root/html534/TSSLSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSSLSocket.html
https://root.cern/root/html534/TSSLSocket.html:11229,Modifiability,config,configuration,11229,"gClientProtocolclient ""protocol"" version. private:. ssl_st*fSSL; ssl_ctx_st*fSSLCtx; static charfgSSLCAFile[2147483647]; static charfgSSLCAPath[2147483647]; static charfgSSLUCert[2147483647]; static charfgSSLUKey[2147483647]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void WrapWithSSL(void); Wraps the socket with OpenSSL. TSSLSocket(TInetAddress addr, const char* service, Int_t tcpwindowsize = -1). TSSLSocket(TInetAddress addr, Int_t port, Int_t tcpwindowsize = -1). TSSLSocket(const char* host, const char* service, Int_t tcpwindowsize = -1). TSSLSocket(const char* url, Int_t port, Int_t tcpwindowsize = -1). TSSLSocket(const char* sockpath). TSSLSocket(Int_t desc). TSSLSocket(Int_t desc, const char* sockpath). TSSLSocket(const TSSLSocket& s). ~TSSLSocket(); Close gracefully the connection, and free SSL structures. void Close(Option_t* option = """"); Close the SSL connection. void SetUpSSL(const char* cafile, const char* capath, const char* ucert, const char* ukey); Set up the static configuration variables. Int_t Recv(TMessage*& mess). Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Int_t Send(const TMessage& mess). Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. TSSLSocket(); {}. Int_t Recv(TMessage*& mess); The rest of the Send and Recv calls rely ultimately on these,; so it is enough to overload them. Int_t Send(const TMessage& mess). Int_t Send(Int_t kind); Issue with hidden method :(. { return TSocket::Send(kind); }. Int_t Send(Int_t status, Int_t kind); { return TSocket::Send(status, kind); }. Int_t Recv(Int_t& status, Int_t& kind); { return TSocket::Recv(status, kind); }. Int_t Recv(char* mess, Int_t max); { return TSocket::Recv(mess, max); }. » Author: Alejandro Alvarez 16/09/2011 » Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$I",MatchSource.WIKI,root/html534/TSSLSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSSLSocket.html
https://root.cern/root/html534/TSSLSocket.html:11243,Modifiability,variab,variables,11243,"gClientProtocolclient ""protocol"" version. private:. ssl_st*fSSL; ssl_ctx_st*fSSLCtx; static charfgSSLCAFile[2147483647]; static charfgSSLCAPath[2147483647]; static charfgSSLUCert[2147483647]; static charfgSSLUKey[2147483647]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void WrapWithSSL(void); Wraps the socket with OpenSSL. TSSLSocket(TInetAddress addr, const char* service, Int_t tcpwindowsize = -1). TSSLSocket(TInetAddress addr, Int_t port, Int_t tcpwindowsize = -1). TSSLSocket(const char* host, const char* service, Int_t tcpwindowsize = -1). TSSLSocket(const char* url, Int_t port, Int_t tcpwindowsize = -1). TSSLSocket(const char* sockpath). TSSLSocket(Int_t desc). TSSLSocket(Int_t desc, const char* sockpath). TSSLSocket(const TSSLSocket& s). ~TSSLSocket(); Close gracefully the connection, and free SSL structures. void Close(Option_t* option = """"); Close the SSL connection. void SetUpSSL(const char* cafile, const char* capath, const char* ucert, const char* ukey); Set up the static configuration variables. Int_t Recv(TMessage*& mess). Int_t RecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Receive a raw buffer of specified length bytes. Int_t Send(const TMessage& mess). Int_t SendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); Send a raw buffer of specified length. TSSLSocket(); {}. Int_t Recv(TMessage*& mess); The rest of the Send and Recv calls rely ultimately on these,; so it is enough to overload them. Int_t Send(const TMessage& mess). Int_t Send(Int_t kind); Issue with hidden method :(. { return TSocket::Send(kind); }. Int_t Send(Int_t status, Int_t kind); { return TSocket::Send(status, kind); }. Int_t Recv(Int_t& status, Int_t& kind); { return TSocket::Recv(status, kind); }. Int_t Recv(char* mess, Int_t max); { return TSocket::Recv(mess, max); }. » Author: Alejandro Alvarez 16/09/2011 » Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$I",MatchSource.WIKI,root/html534/TSSLSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSSLSocket.html
https://root.cern/root/html534/TSSLSocket.html:5990,Safety,timeout,timeout,5990,"erator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tTSocket::Reconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRecv(TMessage*& mess); virtual Int_tRecv(Int_t& status, Int_t& kind); virtual Int_tRecv(char* mess, Int_t max); virtual Int_tRecv(char* mess, Int_t max, Int_t& kind); virtual Int_tRecvRaw(void* buffer, Int_t length, ESendRecvOptions opt = kDefault); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTSocket::Select(Int_t interest = kRead, Long_t timeout = -1); virtual Int_tSend(const TMessage& mess); virtual Int_tSend(Int_t kind); virtual Int_tSend(Int_t status, Int_t kind); virtual Int_tSend(const char* mess, Int_t kind = kMESS_STRING); virtual Int_tTSocket::SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); virtual Int_tSendRaw(const void* buffer, Int_t length, ESendRecvOptions opt = kDefault); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTSocket::SetCompressionAlgorithm(Int_t algorithm = 0); voidTSocket::SetCompressionLevel(Int_t level = 1); voidTSocket::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tTSocket::SetOption(ESockOptions opt, Int_t val); voidTSocket::SetRemoteProtocol(Int_t rproto); voidTSocke",MatchSource.WIKI,root/html534/TSSLSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSSLSocket.html
https://root.cern/root/html534/TSSLSocket.html:9983,Security,authenticat,authentication,9983,"t { kRead; kWrite; };; enum TSocket::EServiceType { kSOCKD; kROOTD; kPROOFD; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TInetAddressTSocket::fAddressremote internet address and port #; TBitsTSocket::fBitsInfobits array to mark TStreamerInfo classes already sent; UInt_tTSocket::fBytesRecvtotal bytes received over this socket; UInt_tTSocket::fBytesSenttotal bytes sent using this socket; Int_tTSocket::fCompressCompression level and algorithm; TTimeStampTSocket::fLastUsageTime stamp of last usage; TVirtualMutex*TSocket::fLastUsageMtxProtect last usage setting / reading; TInetAddressTSocket::fLocalAddresslocal internet address and port #; TStringTNamed::fNameobject identifier; Int_tTSocket::fRemoteProtocolprotocol of remote daemon; TSecContext*TSocket::fSecContextafter a successful Authenticate call; TSocket::EServiceTypeTSocket::fServTyperemote service type; TStringTSocket::fServicename of service (matches remote port #); Int_tTSocket::fSocketsocket descriptor; Int_tTSocket::fTcpWindowSizeTCP window size (default 65535);; TStringTNamed::fTitleobject title; TList*TSocket::fUUIDslist of TProcessIDs already sent through the socket; TStringTSocket::fUrlneeds this for special authentication options; static ULong64_tTSocket::fgBytesRecvtotal bytes received by all socket objects; static ULong64_tTSocket::fgBytesSenttotal bytes sent by all socket objects; static Int_tTSocket::fgClientProtocolclient ""protocol"" version. private:. ssl_st*fSSL; ssl_ctx_st*fSSLCtx; static charfgSSLCAFile[2147483647]; static charfgSSLCAPath[2147483647]; static charfgSSLUCert[2147483647]; static charfgSSLUKey[2147483647]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void WrapWithSSL(void); Wraps the socket with OpenSSL. TSSLSocket(TIn",MatchSource.WIKI,root/html534/TSSLSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSSLSocket.html
https://root.cern/root/html534/TStatistic.html:342,Availability,error,errors,342,". TStatistic. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » TStatistic. class TStatistic: public TObject. TStatistic. Statistical variable, defined by its mean, RMS and related errors.; Named, streamable, storable and mergeable. Function Members (Methods); public:. TStatistic(const char* name = """"); TStatistic(const TStatistic&); TStatistic(const char* name, Int_t n, const Double_t* val, const Double_t* w = 0); virtual~TStatistic(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Double_t val, Double_t w = 1.); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly()",MatchSource.WIKI,root/html534/TStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStatistic.html
https://root.cern/root/html534/TStatistic.html:1514,Availability,error,error,1514,"C header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » TStatistic. class TStatistic: public TObject. TStatistic. Statistical variable, defined by its mean, RMS and related errors.; Named, streamable, storable and mergeable. Function Members (Methods); public:. TStatistic(const char* name = """"); TStatistic(const TStatistic&); TStatistic(const char* name, Int_t n, const Double_t* val, const Double_t* w = 0); virtual~TStatistic(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Double_t val, Double_t w = 1.); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Double_tGetM2() const; Double_tGetMean() const; Double_tGe",MatchSource.WIKI,root/html534/TStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStatistic.html
https://root.cern/root/html534/TStatistic.html:1598,Availability,error,error,1598,"C header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » TStatistic. class TStatistic: public TObject. TStatistic. Statistical variable, defined by its mean, RMS and related errors.; Named, streamable, storable and mergeable. Function Members (Methods); public:. TStatistic(const char* name = """"); TStatistic(const TStatistic&); TStatistic(const char* name, Int_t n, const Double_t* val, const Double_t* w = 0); virtual~TStatistic(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Double_t val, Double_t w = 1.); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Double_tGetM2() const; Double_tGetMean() const; Double_tGe",MatchSource.WIKI,root/html534/TStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStatistic.html
https://root.cern/root/html534/TStatistic.html:295,Modifiability,variab,variable,295,". TStatistic. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » TStatistic. class TStatistic: public TObject. TStatistic. Statistical variable, defined by its mean, RMS and related errors.; Named, streamable, storable and mergeable. Function Members (Methods); public:. TStatistic(const char* name = """"); TStatistic(const TStatistic&); TStatistic(const char* name, Int_t n, const Double_t* val, const Double_t* w = 0); virtual~TStatistic(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Double_t val, Double_t w = 1.); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly()",MatchSource.WIKI,root/html534/TStatistic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStatistic.html
https://root.cern/root/html534/TStatsFeedback.html:3572,Availability,error,error,3572,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFeedback(TList* objs); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObje",MatchSource.WIKI,root/html534/TStatsFeedback.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStatsFeedback.html
https://root.cern/root/html534/TStatsFeedback.html:3656,Availability,error,error,3656,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFeedback(TList* objs); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tHash() const; virtu",MatchSource.WIKI,root/html534/TStatsFeedback.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStatsFeedback.html
https://root.cern/root/html534/TStatsFeedback.html:381,Usability,feedback,feedback,381,". TStatsFeedback. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TStatsFeedback. class TStatsFeedback: public TObject, public TQObject. TStatsFeedback. Utility class to display PROOF stats feedback histos during queries. Function Members (Methods); public:. TStatsFeedback(TProof* proof = 0); virtual~TStatsFeedback(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTQObject::Destroyed()SIGNAL ; Bool_tTQObject::Disconnect(const char* signal = 0, void* receiver = 0, const char* slot = 0); static Bool_tTQObject::Disconnect(TQObject* sender, const char* signal = 0, void* receiver = 0, const char* slot = 0); static Bool",MatchSource.WIKI,root/html534/TStatsFeedback.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStatsFeedback.html
https://root.cern/root/html534/TStatsFeedback.html:9027,Usability,feedback,feedback,9027,"name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TStringfNameIdentfier for this object; TProof*fProofhandle to PROOF session; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStatsFeedback(TProof* proof = 0); Constructor. ~TStatsFeedback(); Destructor. void Feedback(TList* objs); Display feedback. const char * GetName() const; { return fName.Data(); }. ULong_t Hash() const; { return fName.Hash(); }. » Author: G. Ganis May 2012 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-03-14 16:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TStatsFeedback.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStatsFeedback.html
https://root.cern/root/html534/TStatus.html:364,Availability,error,error,364,". TStatus. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TStatus. class TStatus: public TNamed. TStatus. This class holds the status of an ongoing operation and collects; error messages. It provides a Merge() operation allowing it to; be used in PROOF to monitor status in the slaves.; No messages indicates success. Function Members (Methods); public:. TStatus(); virtual~TStatus(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const char* mesg); voidAddInfo(const char* mesg); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() c",MatchSource.WIKI,root/html534/TStatus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStatus.html
https://root.cern/root/html534/TStatus.html:1549,Availability,error,error,1549,"us(); virtual~TStatus(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const char* mesg); voidAddInfo(const char* mesg); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetExitStatus() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Long_tGetResMemMax(Bool_t master = kFALSE) const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Long_tGetVirtMemMax(Bool_t master = kFALSE) const; virtual Bool_tTObject::HandleTimer(TTimer* timer);",MatchSource.WIKI,root/html534/TStatus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStatus.html
https://root.cern/root/html534/TStatus.html:1633,Availability,error,error,1633,"Add(const char* mesg); voidAddInfo(const char* mesg); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetExitStatus() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Long_tGetResMemMax(Bool_t master = kFALSE) const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Long_tGetVirtMemMax(Bool_t master = kFALSE) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, ",MatchSource.WIKI,root/html534/TStatus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStatus.html
https://root.cern/root/html534/TStatus.html:6205,Availability,error,error,6205,"al voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EProcStatus { kNotOk; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Int_tfExitStatusQuery exit status ((Int_t)TVirtualProofPlayer::EExitStatus or -1);; THashListfInfoMsgslist of info messages; TIterfIter!iterator in messages; TListfMsgslist of error messages; Long_tfResMaxMstMax resident memory used by the master; Long_tfResMemMaxMax resident memory used by the worker; Long_tfVirtMaxMstMax virtual memory used by the master; Long_tfVirtMemMaxMax virtual memory used by the worker. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStatus(); Default constructor. void Add(const char* mesg); Add an error message. void AddInfo(const char* mesg); Add an info message. Int_t Merge(TCollection* list); PROOF Merge() function. void Print(Option_t* option = """") const; Standard print function. void Reset(); Reset the iterator on the messages. const char * NextMesg(); Return the next message or 0. void SetMemValues(Long_t vmem = -1, Long_t rmem = -1, Bool_t master = kFALSE); Set max memory values. void Streamer(TBuffer& ); Stream an object of class TStatus. virtual ~TStatus(); { }. Bool_t IsOk() const; { return TestBit(kNotOk) ? kFALSE : kTRUE; }. Int_t GetExitStatus() const; { return fExitStatus; }. Long_t GetResMemMax(Bool_t ma",MatchSource.WIKI,root/html534/TStatus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStatus.html
https://root.cern/root/html534/TStatus.html:6603,Availability,error,error,6603,"const; voidTObject::MakeZombie(). Data Members; public:. enum EProcStatus { kNotOk; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Int_tfExitStatusQuery exit status ((Int_t)TVirtualProofPlayer::EExitStatus or -1);; THashListfInfoMsgslist of info messages; TIterfIter!iterator in messages; TListfMsgslist of error messages; Long_tfResMaxMstMax resident memory used by the master; Long_tfResMemMaxMax resident memory used by the worker; Long_tfVirtMaxMstMax virtual memory used by the master; Long_tfVirtMemMaxMax virtual memory used by the worker. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStatus(); Default constructor. void Add(const char* mesg); Add an error message. void AddInfo(const char* mesg); Add an info message. Int_t Merge(TCollection* list); PROOF Merge() function. void Print(Option_t* option = """") const; Standard print function. void Reset(); Reset the iterator on the messages. const char * NextMesg(); Return the next message or 0. void SetMemValues(Long_t vmem = -1, Long_t rmem = -1, Bool_t master = kFALSE); Set max memory values. void Streamer(TBuffer& ); Stream an object of class TStatus. virtual ~TStatus(); { }. Bool_t IsOk() const; { return TestBit(kNotOk) ? kFALSE : kTRUE; }. Int_t GetExitStatus() const; { return fExitStatus; }. Long_t GetResMemMax(Bool_t master = kFALSE) const; { return ((master) ? fResMaxMst : fResMemMax); }. Long_t GetVirtMemMax(Bool_t master = kFALSE) const; { return ((master) ? fVirtMaxMst : fVirtMemMax); }. void SetExitStatus(Int_t est); { fExitStatus = est; }. » Author: Maarten Ballintijn 12/03/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/pro",MatchSource.WIKI,root/html534/TStatus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStatus.html
https://root.cern/root/html534/TStatus.html:448,Energy Efficiency,monitor,monitor,448,". TStatus. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TStatus. class TStatus: public TNamed. TStatus. This class holds the status of an ongoing operation and collects; error messages. It provides a Merge() operation allowing it to; be used in PROOF to monitor status in the slaves.; No messages indicates success. Function Members (Methods); public:. TStatus(); virtual~TStatus(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const char* mesg); voidAddInfo(const char* mesg); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() c",MatchSource.WIKI,root/html534/TStatus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStatus.html
https://root.cern/root/html534/TStatus.html:370,Integrability,message,messages,370,". TStatus. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TStatus. class TStatus: public TNamed. TStatus. This class holds the status of an ongoing operation and collects; error messages. It provides a Merge() operation allowing it to; be used in PROOF to monitor status in the slaves.; No messages indicates success. Function Members (Methods); public:. TStatus(); virtual~TStatus(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const char* mesg); voidAddInfo(const char* mesg); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() c",MatchSource.WIKI,root/html534/TStatus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStatus.html
https://root.cern/root/html534/TStatus.html:482,Integrability,message,messages,482,". TStatus. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TStatus. class TStatus: public TNamed. TStatus. This class holds the status of an ongoing operation and collects; error messages. It provides a Merge() operation allowing it to; be used in PROOF to monitor status in the slaves.; No messages indicates success. Function Members (Methods); public:. TStatus(); virtual~TStatus(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const char* mesg); voidAddInfo(const char* mesg); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() c",MatchSource.WIKI,root/html534/TStatus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStatus.html
https://root.cern/root/html534/TStatus.html:6144,Integrability,message,messages,6144,"al voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EProcStatus { kNotOk; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Int_tfExitStatusQuery exit status ((Int_t)TVirtualProofPlayer::EExitStatus or -1);; THashListfInfoMsgslist of info messages; TIterfIter!iterator in messages; TListfMsgslist of error messages; Long_tfResMaxMstMax resident memory used by the master; Long_tfResMemMaxMax resident memory used by the worker; Long_tfVirtMaxMstMax virtual memory used by the master; Long_tfVirtMemMaxMax virtual memory used by the worker. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStatus(); Default constructor. void Add(const char* mesg); Add an error message. void AddInfo(const char* mesg); Add an info message. Int_t Merge(TCollection* list); PROOF Merge() function. void Print(Option_t* option = """") const; Standard print function. void Reset(); Reset the iterator on the messages. const char * NextMesg(); Return the next message or 0. void SetMemValues(Long_t vmem = -1, Long_t rmem = -1, Bool_t master = kFALSE); Set max memory values. void Streamer(TBuffer& ); Stream an object of class TStatus. virtual ~TStatus(); { }. Bool_t IsOk() const; { return TestBit(kNotOk) ? kFALSE : kTRUE; }. Int_t GetExitStatus() const; { return fExitStatus; }. Long_t GetResMemMax(Bool_t ma",MatchSource.WIKI,root/html534/TStatus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStatus.html
https://root.cern/root/html534/TStatus.html:6177,Integrability,message,messages,6177,"al voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EProcStatus { kNotOk; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Int_tfExitStatusQuery exit status ((Int_t)TVirtualProofPlayer::EExitStatus or -1);; THashListfInfoMsgslist of info messages; TIterfIter!iterator in messages; TListfMsgslist of error messages; Long_tfResMaxMstMax resident memory used by the master; Long_tfResMemMaxMax resident memory used by the worker; Long_tfVirtMaxMstMax virtual memory used by the master; Long_tfVirtMemMaxMax virtual memory used by the worker. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStatus(); Default constructor. void Add(const char* mesg); Add an error message. void AddInfo(const char* mesg); Add an info message. Int_t Merge(TCollection* list); PROOF Merge() function. void Print(Option_t* option = """") const; Standard print function. void Reset(); Reset the iterator on the messages. const char * NextMesg(); Return the next message or 0. void SetMemValues(Long_t vmem = -1, Long_t rmem = -1, Bool_t master = kFALSE); Set max memory values. void Streamer(TBuffer& ); Stream an object of class TStatus. virtual ~TStatus(); { }. Bool_t IsOk() const; { return TestBit(kNotOk) ? kFALSE : kTRUE; }. Int_t GetExitStatus() const; { return fExitStatus; }. Long_t GetResMemMax(Bool_t ma",MatchSource.WIKI,root/html534/TStatus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStatus.html
https://root.cern/root/html534/TStatus.html:6211,Integrability,message,messages,6211,"al voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EProcStatus { kNotOk; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Int_tfExitStatusQuery exit status ((Int_t)TVirtualProofPlayer::EExitStatus or -1);; THashListfInfoMsgslist of info messages; TIterfIter!iterator in messages; TListfMsgslist of error messages; Long_tfResMaxMstMax resident memory used by the master; Long_tfResMemMaxMax resident memory used by the worker; Long_tfVirtMaxMstMax virtual memory used by the master; Long_tfVirtMemMaxMax virtual memory used by the worker. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStatus(); Default constructor. void Add(const char* mesg); Add an error message. void AddInfo(const char* mesg); Add an info message. Int_t Merge(TCollection* list); PROOF Merge() function. void Print(Option_t* option = """") const; Standard print function. void Reset(); Reset the iterator on the messages. const char * NextMesg(); Return the next message or 0. void SetMemValues(Long_t vmem = -1, Long_t rmem = -1, Bool_t master = kFALSE); Set max memory values. void Streamer(TBuffer& ); Stream an object of class TStatus. virtual ~TStatus(); { }. Bool_t IsOk() const; { return TestBit(kNotOk) ? kFALSE : kTRUE; }. Int_t GetExitStatus() const; { return fExitStatus; }. Long_t GetResMemMax(Bool_t ma",MatchSource.WIKI,root/html534/TStatus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStatus.html
https://root.cern/root/html534/TStatus.html:6609,Integrability,message,message,6609,"const; voidTObject::MakeZombie(). Data Members; public:. enum EProcStatus { kNotOk; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Int_tfExitStatusQuery exit status ((Int_t)TVirtualProofPlayer::EExitStatus or -1);; THashListfInfoMsgslist of info messages; TIterfIter!iterator in messages; TListfMsgslist of error messages; Long_tfResMaxMstMax resident memory used by the master; Long_tfResMemMaxMax resident memory used by the worker; Long_tfVirtMaxMstMax virtual memory used by the master; Long_tfVirtMemMaxMax virtual memory used by the worker. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStatus(); Default constructor. void Add(const char* mesg); Add an error message. void AddInfo(const char* mesg); Add an info message. Int_t Merge(TCollection* list); PROOF Merge() function. void Print(Option_t* option = """") const; Standard print function. void Reset(); Reset the iterator on the messages. const char * NextMesg(); Return the next message or 0. void SetMemValues(Long_t vmem = -1, Long_t rmem = -1, Bool_t master = kFALSE); Set max memory values. void Streamer(TBuffer& ); Stream an object of class TStatus. virtual ~TStatus(); { }. Bool_t IsOk() const; { return TestBit(kNotOk) ? kFALSE : kTRUE; }. Int_t GetExitStatus() const; { return fExitStatus; }. Long_t GetResMemMax(Bool_t master = kFALSE) const; { return ((master) ? fResMaxMst : fResMemMax); }. Long_t GetVirtMemMax(Bool_t master = kFALSE) const; { return ((master) ? fVirtMaxMst : fVirtMemMax); }. void SetExitStatus(Int_t est); { fExitStatus = est; }. » Author: Maarten Ballintijn 12/03/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/pro",MatchSource.WIKI,root/html534/TStatus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStatus.html
https://root.cern/root/html534/TStatus.html:6662,Integrability,message,message,6662,"lic:. enum EProcStatus { kNotOk; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Int_tfExitStatusQuery exit status ((Int_t)TVirtualProofPlayer::EExitStatus or -1);; THashListfInfoMsgslist of info messages; TIterfIter!iterator in messages; TListfMsgslist of error messages; Long_tfResMaxMstMax resident memory used by the master; Long_tfResMemMaxMax resident memory used by the worker; Long_tfVirtMaxMstMax virtual memory used by the master; Long_tfVirtMemMaxMax virtual memory used by the worker. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStatus(); Default constructor. void Add(const char* mesg); Add an error message. void AddInfo(const char* mesg); Add an info message. Int_t Merge(TCollection* list); PROOF Merge() function. void Print(Option_t* option = """") const; Standard print function. void Reset(); Reset the iterator on the messages. const char * NextMesg(); Return the next message or 0. void SetMemValues(Long_t vmem = -1, Long_t rmem = -1, Bool_t master = kFALSE); Set max memory values. void Streamer(TBuffer& ); Stream an object of class TStatus. virtual ~TStatus(); { }. Bool_t IsOk() const; { return TestBit(kNotOk) ? kFALSE : kTRUE; }. Int_t GetExitStatus() const; { return fExitStatus; }. Long_t GetResMemMax(Bool_t master = kFALSE) const; { return ((master) ? fResMaxMst : fResMemMax); }. Long_t GetVirtMemMax(Bool_t master = kFALSE) const; { return ((master) ? fVirtMaxMst : fVirtMemMax); }. void SetExitStatus(Int_t est); { fExitStatus = est; }. » Author: Maarten Ballintijn 12/03/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-03-14 16:50; Th",MatchSource.WIKI,root/html534/TStatus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStatus.html
https://root.cern/root/html534/TStatus.html:6833,Integrability,message,messages,6833,"enu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Int_tfExitStatusQuery exit status ((Int_t)TVirtualProofPlayer::EExitStatus or -1);; THashListfInfoMsgslist of info messages; TIterfIter!iterator in messages; TListfMsgslist of error messages; Long_tfResMaxMstMax resident memory used by the master; Long_tfResMemMaxMax resident memory used by the worker; Long_tfVirtMaxMstMax virtual memory used by the master; Long_tfVirtMemMaxMax virtual memory used by the worker. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStatus(); Default constructor. void Add(const char* mesg); Add an error message. void AddInfo(const char* mesg); Add an info message. Int_t Merge(TCollection* list); PROOF Merge() function. void Print(Option_t* option = """") const; Standard print function. void Reset(); Reset the iterator on the messages. const char * NextMesg(); Return the next message or 0. void SetMemValues(Long_t vmem = -1, Long_t rmem = -1, Bool_t master = kFALSE); Set max memory values. void Streamer(TBuffer& ); Stream an object of class TStatus. virtual ~TStatus(); { }. Bool_t IsOk() const; { return TestBit(kNotOk) ? kFALSE : kTRUE; }. Int_t GetExitStatus() const; { return fExitStatus; }. Long_t GetResMemMax(Bool_t master = kFALSE) const; { return ((master) ? fResMaxMst : fResMemMax); }. Long_t GetVirtMemMax(Bool_t master = kFALSE) const; { return ((master) ? fVirtMaxMst : fVirtMemMax); }. void SetExitStatus(Int_t est); { fExitStatus = est; }. » Author: Maarten Ballintijn 12/03/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-03-14 16:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TStatus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStatus.html
https://root.cern/root/html534/TStatus.html:6884,Integrability,message,message,6884,"enu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Int_tfExitStatusQuery exit status ((Int_t)TVirtualProofPlayer::EExitStatus or -1);; THashListfInfoMsgslist of info messages; TIterfIter!iterator in messages; TListfMsgslist of error messages; Long_tfResMaxMstMax resident memory used by the master; Long_tfResMemMaxMax resident memory used by the worker; Long_tfVirtMaxMstMax virtual memory used by the master; Long_tfVirtMemMaxMax virtual memory used by the worker. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStatus(); Default constructor. void Add(const char* mesg); Add an error message. void AddInfo(const char* mesg); Add an info message. Int_t Merge(TCollection* list); PROOF Merge() function. void Print(Option_t* option = """") const; Standard print function. void Reset(); Reset the iterator on the messages. const char * NextMesg(); Return the next message or 0. void SetMemValues(Long_t vmem = -1, Long_t rmem = -1, Bool_t master = kFALSE); Set max memory values. void Streamer(TBuffer& ); Stream an object of class TStatus. virtual ~TStatus(); { }. Bool_t IsOk() const; { return TestBit(kNotOk) ? kFALSE : kTRUE; }. Int_t GetExitStatus() const; { return fExitStatus; }. Long_t GetResMemMax(Bool_t master = kFALSE) const; { return ((master) ? fResMaxMst : fResMemMax); }. Long_t GetVirtMemMax(Bool_t master = kFALSE) const; { return ((master) ? fVirtMaxMst : fVirtMemMax); }. void SetExitStatus(Int_t est); { fExitStatus = est; }. » Author: Maarten Ballintijn 12/03/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-03-14 16:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TStatus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStatus.html
https://root.cern/root/html534/TStdExceptionHandler.html:526,Availability,avail,available,526,". TStdExceptionHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TStdExceptionHandler. class TStdExceptionHandler: public TSysEvtHandler. TSysEvtHandler. Abstract base class for handling system events. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TStdExceptionHandler(); voidTObject::AbstractMethod(const char* method) const; voidTSysEvtHandler::Activate(); virtual voidTSysEvtHandler::Activated()SIGNAL ; virtual voidAdd(); virtual voidTSysEvtHandler::Added()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTObject::Copy(TObject& object) const; voidTSysEvtHandler::DeActivate(); virtual voidTSysEvtHandler::DeActivated()SIGNAL ; virtual voidTOb",MatchSource.WIKI,root/html534/TStdExceptionHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStdExceptionHandler.html
https://root.cern/root/html534/TStdExceptionHandler.html:3880,Availability,error,error,3880,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual TStdExceptionHandler::EStatusHandle(exception& exc); virtual Bool_tTObject::Handl",MatchSource.WIKI,root/html534/TStdExceptionHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStdExceptionHandler.html
https://root.cern/root/html534/TStdExceptionHandler.html:3964,Availability,error,error,3964,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual TStdExceptionHandler::EStatusHandle(exception& exc); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name",MatchSource.WIKI,root/html534/TStdExceptionHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStdExceptionHandler.html
https://root.cern/root/html534/TStopwatch.html:1463,Availability,error,error,1463,"Stopwatch&); ~TStopwatch(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidContinue(); virtual voidTObject::Copy(TObject& object) const; Int_tCounter() const; Double_tCpuTime(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html534/TStopwatch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStopwatch.html
https://root.cern/root/html534/TStopwatch.html:1547,Availability,error,error,1547,"irtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidContinue(); virtual voidTObject::Copy(TObject& object) const; Int_tCounter() const; Double_tCpuTime(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html534/TStopwatch.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStopwatch.html
https://root.cern/root/html534/TStorage.html:742,Deployability,toggle,toggle,742,". TStorage. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TStorage. class TStorage. TStorage. Storage manager. The storage manager works best in conjunction with; the custom ROOT new and delete operators defined in the file; NewDelete.cxx (libNew.so). Only when using the custom allocation; operators will memory usage statistics be gathered using the; TStorage EnterStat(), RemoveStat(), etc. functions.; Memory checking is by default enabled (when using libNew.so) and; usage statistics is gathered. Using the resource (in .rootrc):; Root.MemStat one can toggle statistics gathering on or off. More; specifically on can trap the allocation of a block of memory of a; certain size. This can be specified using the resource:; Root.MemStat.size, using the resource Root.MemStat.cnt one can; specify after how many allocations of this size the trap should; occur.; Set the compile option R__NOSTATS to de-activate all memory checking; and statistics gathering in the system. Function Members (Methods); public:. TStorage(); TStorage(const TStorage&); virtual~TStorage(); static voidAddToHeap(ULong_t begin, ULong_t end); static void*Alloc(size_t size); static TClass*Class(); static voidDealloc(void* ptr); static voidEnableStatistics(int size = -1, int ix = -1); static voidEnterStat(size_t size, void* p); static Bool_tFilledByObjectAlloc(UInt_t* member); static FreeHookFun_tGetFreeHook(); static void*GetFreeHookData(); static ULong_tGetHeapBegin(); static ULong_tGetHeapEnd(); static size_tGetMaxBlockSize(); static Bool_tHasCustomNewDelete(); virtual TClass*IsA() const; static Bool_tIsOnHeap(void* p); static void*ObjectAlloc(size_t size); static void*ObjectAlloc(size_t size, void* vp); static voidObjectDealloc(void* vp); static voidObjectDealloc(void* vp, void* ptr); TStorage&operator=(const TStorage&); sta",MatchSource.WIKI,root/html534/TStorage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStorage.html
https://root.cern/root/html534/TStorage.html:2868,Energy Efficiency,allocate,allocated,2868,"bjectAlloc(size_t size, void* vp); static voidObjectDealloc(void* vp); static voidObjectDealloc(void* vp, void* ptr); TStorage&operator=(const TStorage&); static voidPrintStatistics(); static void*ReAlloc(void* vp, size_t size); static void*ReAlloc(void* vp, size_t size, size_t oldsize); static char*ReAllocChar(char* vp, size_t size, size_t oldsize); static Int_t*ReAllocInt(Int_t* vp, size_t size, size_t oldsize); static voidRemoveStat(void* p); static voidSetCustomNewDelete(); static voidSetFreeHook(FreeHookFun_t func, void* data); static voidSetMaxBlockSize(size_t size); static voidSetReAllocHooks(ReAllocFun_t func1, ReAllocCFun_t func2); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; private:. static FreeHookFun_tfgFreeHookfunction called on free; static void*fgFreeHookDatadata used by this function; static Bool_tfgHasCustomNewDeletetrue if using ROOT's new/delete; static size_tfgMaxBlockSizelargest block allocated; static ReAllocCFun_tfgReAllocCHookcustom ReAlloc with length check; static ReAllocFun_tfgReAllocHookcustom ReAlloc; static const UInt_tkObjectAllocMemValue. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void EnterStat(size_t size, void* p); Register a memory allocation operation. If desired one can trap an; allocation of a certain size in case one tries to find a memory; leak of that particular size. This function is only called via; the ROOT custom new operators. void RemoveStat(void* p); Register a memory free operation. This function is only called via; the custom ROOT delete operator. void * Alloc(size_t size); Allocate a block of memory, that later can be resized using; TStorage::ReAlloc(). void Dealloc(void* ptr); De-allocate block of memory, that was allocated via TStorage::Alloc(). void * ReAlloc(void* vp, size_t size); Reallocate (i.e. resize) block of memory. Don't use if size is larger; than old",MatchSource.WIKI,root/html534/TStorage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStorage.html
https://root.cern/root/html534/TStorage.html:3657,Energy Efficiency,allocate,allocate,3657,"eeHookfunction called on free; static void*fgFreeHookDatadata used by this function; static Bool_tfgHasCustomNewDeletetrue if using ROOT's new/delete; static size_tfgMaxBlockSizelargest block allocated; static ReAllocCFun_tfgReAllocCHookcustom ReAlloc with length check; static ReAllocFun_tfgReAllocHookcustom ReAlloc; static const UInt_tkObjectAllocMemValue. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void EnterStat(size_t size, void* p); Register a memory allocation operation. If desired one can trap an; allocation of a certain size in case one tries to find a memory; leak of that particular size. This function is only called via; the ROOT custom new operators. void RemoveStat(void* p); Register a memory free operation. This function is only called via; the custom ROOT delete operator. void * Alloc(size_t size); Allocate a block of memory, that later can be resized using; TStorage::ReAlloc(). void Dealloc(void* ptr); De-allocate block of memory, that was allocated via TStorage::Alloc(). void * ReAlloc(void* vp, size_t size); Reallocate (i.e. resize) block of memory. Don't use if size is larger; than old size, use ReAlloc(void *, size_t, size_t) instead. void * ReAlloc(void* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) block of memory. Checks if current size is; equal to oldsize. If not memory was overwritten. char * ReAllocChar(char* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of chars. Size and oldsize are; in number of chars. Int_t * ReAllocInt(Int_t* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of integers. Size and oldsize are; number of integers (not number of bytes). void * ObjectAlloc(size_t size); Used to allocate a TObject on the heap (via TObject::operator new()).; Directly after this routine one can call (in the TObject ctor); TStorage::FilledByObjectAlloc() to find out if the just created object is on; the heap. void * ObjectAlloc(size_t size, void* vp);",MatchSource.WIKI,root/html534/TStorage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStorage.html
https://root.cern/root/html534/TStorage.html:3692,Energy Efficiency,allocate,allocated,3692,"eeHookfunction called on free; static void*fgFreeHookDatadata used by this function; static Bool_tfgHasCustomNewDeletetrue if using ROOT's new/delete; static size_tfgMaxBlockSizelargest block allocated; static ReAllocCFun_tfgReAllocCHookcustom ReAlloc with length check; static ReAllocFun_tfgReAllocHookcustom ReAlloc; static const UInt_tkObjectAllocMemValue. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void EnterStat(size_t size, void* p); Register a memory allocation operation. If desired one can trap an; allocation of a certain size in case one tries to find a memory; leak of that particular size. This function is only called via; the ROOT custom new operators. void RemoveStat(void* p); Register a memory free operation. This function is only called via; the custom ROOT delete operator. void * Alloc(size_t size); Allocate a block of memory, that later can be resized using; TStorage::ReAlloc(). void Dealloc(void* ptr); De-allocate block of memory, that was allocated via TStorage::Alloc(). void * ReAlloc(void* vp, size_t size); Reallocate (i.e. resize) block of memory. Don't use if size is larger; than old size, use ReAlloc(void *, size_t, size_t) instead. void * ReAlloc(void* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) block of memory. Checks if current size is; equal to oldsize. If not memory was overwritten. char * ReAllocChar(char* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of chars. Size and oldsize are; in number of chars. Int_t * ReAllocInt(Int_t* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of integers. Size and oldsize are; number of integers (not number of bytes). void * ObjectAlloc(size_t size); Used to allocate a TObject on the heap (via TObject::operator new()).; Directly after this routine one can call (in the TObject ctor); TStorage::FilledByObjectAlloc() to find out if the just created object is on; the heap. void * ObjectAlloc(size_t size, void* vp);",MatchSource.WIKI,root/html534/TStorage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStorage.html
https://root.cern/root/html534/TStorage.html:4419,Energy Efficiency,allocate,allocate,4419,"a memory free operation. This function is only called via; the custom ROOT delete operator. void * Alloc(size_t size); Allocate a block of memory, that later can be resized using; TStorage::ReAlloc(). void Dealloc(void* ptr); De-allocate block of memory, that was allocated via TStorage::Alloc(). void * ReAlloc(void* vp, size_t size); Reallocate (i.e. resize) block of memory. Don't use if size is larger; than old size, use ReAlloc(void *, size_t, size_t) instead. void * ReAlloc(void* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) block of memory. Checks if current size is; equal to oldsize. If not memory was overwritten. char * ReAllocChar(char* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of chars. Size and oldsize are; in number of chars. Int_t * ReAllocInt(Int_t* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of integers. Size and oldsize are; number of integers (not number of bytes). void * ObjectAlloc(size_t size); Used to allocate a TObject on the heap (via TObject::operator new()).; Directly after this routine one can call (in the TObject ctor); TStorage::FilledByObjectAlloc() to find out if the just created object is on; the heap. void * ObjectAlloc(size_t size, void* vp); Used to allocate a TObject on the heap (via TObject::operator new(size_t,void*)); in position vp. vp is already allocated (maybe on heap, maybe on; stack) so just return. void ObjectDealloc(void* vp); Used to deallocate a TObject on the heap (via TObject::operator delete()). void ObjectDealloc(void* vp, void* ptr); Used to deallocate a TObject on the heap (via TObject::operator delete(void*,void*)). void SetFreeHook(FreeHookFun_t func, void* data); Set a free handler. void SetReAllocHooks(ReAllocFun_t func1, ReAllocCFun_t func2); Set a custom ReAlloc handlers. This function is typically; called via a static object in the ROOT libNew.so shared library. void PrintStatistics(); Print memory usage statistics. void EnableStatistics(int size = -1, ",MatchSource.WIKI,root/html534/TStorage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStorage.html
https://root.cern/root/html534/TStorage.html:4685,Energy Efficiency,allocate,allocate,4685,"ia TStorage::Alloc(). void * ReAlloc(void* vp, size_t size); Reallocate (i.e. resize) block of memory. Don't use if size is larger; than old size, use ReAlloc(void *, size_t, size_t) instead. void * ReAlloc(void* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) block of memory. Checks if current size is; equal to oldsize. If not memory was overwritten. char * ReAllocChar(char* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of chars. Size and oldsize are; in number of chars. Int_t * ReAllocInt(Int_t* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of integers. Size and oldsize are; number of integers (not number of bytes). void * ObjectAlloc(size_t size); Used to allocate a TObject on the heap (via TObject::operator new()).; Directly after this routine one can call (in the TObject ctor); TStorage::FilledByObjectAlloc() to find out if the just created object is on; the heap. void * ObjectAlloc(size_t size, void* vp); Used to allocate a TObject on the heap (via TObject::operator new(size_t,void*)); in position vp. vp is already allocated (maybe on heap, maybe on; stack) so just return. void ObjectDealloc(void* vp); Used to deallocate a TObject on the heap (via TObject::operator delete()). void ObjectDealloc(void* vp, void* ptr); Used to deallocate a TObject on the heap (via TObject::operator delete(void*,void*)). void SetFreeHook(FreeHookFun_t func, void* data); Set a free handler. void SetReAllocHooks(ReAllocFun_t func1, ReAllocCFun_t func2); Set a custom ReAlloc handlers. This function is typically; called via a static object in the ROOT libNew.so shared library. void PrintStatistics(); Print memory usage statistics. void EnableStatistics(int size = -1, int ix = -1); Enable memory usage statistics gathering. Size is the size of the memory; block that should be trapped and ix is after how many such allocations; the trap should happen. ULong_t GetHeapBegin(). ULong_t GetHeapEnd(). void * GetFreeHookData(); return static free ",MatchSource.WIKI,root/html534/TStorage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStorage.html
https://root.cern/root/html534/TStorage.html:4789,Energy Efficiency,allocate,allocated,4789,"t use if size is larger; than old size, use ReAlloc(void *, size_t, size_t) instead. void * ReAlloc(void* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) block of memory. Checks if current size is; equal to oldsize. If not memory was overwritten. char * ReAllocChar(char* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of chars. Size and oldsize are; in number of chars. Int_t * ReAllocInt(Int_t* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of integers. Size and oldsize are; number of integers (not number of bytes). void * ObjectAlloc(size_t size); Used to allocate a TObject on the heap (via TObject::operator new()).; Directly after this routine one can call (in the TObject ctor); TStorage::FilledByObjectAlloc() to find out if the just created object is on; the heap. void * ObjectAlloc(size_t size, void* vp); Used to allocate a TObject on the heap (via TObject::operator new(size_t,void*)); in position vp. vp is already allocated (maybe on heap, maybe on; stack) so just return. void ObjectDealloc(void* vp); Used to deallocate a TObject on the heap (via TObject::operator delete()). void ObjectDealloc(void* vp, void* ptr); Used to deallocate a TObject on the heap (via TObject::operator delete(void*,void*)). void SetFreeHook(FreeHookFun_t func, void* data); Set a free handler. void SetReAllocHooks(ReAllocFun_t func1, ReAllocCFun_t func2); Set a custom ReAlloc handlers. This function is typically; called via a static object in the ROOT libNew.so shared library. void PrintStatistics(); Print memory usage statistics. void EnableStatistics(int size = -1, int ix = -1); Enable memory usage statistics gathering. Size is the size of the memory; block that should be trapped and ix is after how many such allocations; the trap should happen. ULong_t GetHeapBegin(). ULong_t GetHeapEnd(). void * GetFreeHookData(); return static free hook data. Bool_t HasCustomNewDelete(); return the has custom delete flag. void SetCustomNewDelete(); set t",MatchSource.WIKI,root/html534/TStorage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStorage.html
https://root.cern/root/html534/TStorage.html:4502,Integrability,rout,routine,4502,"a block of memory, that later can be resized using; TStorage::ReAlloc(). void Dealloc(void* ptr); De-allocate block of memory, that was allocated via TStorage::Alloc(). void * ReAlloc(void* vp, size_t size); Reallocate (i.e. resize) block of memory. Don't use if size is larger; than old size, use ReAlloc(void *, size_t, size_t) instead. void * ReAlloc(void* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) block of memory. Checks if current size is; equal to oldsize. If not memory was overwritten. char * ReAllocChar(char* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of chars. Size and oldsize are; in number of chars. Int_t * ReAllocInt(Int_t* vp, size_t size, size_t oldsize); Reallocate (i.e. resize) array of integers. Size and oldsize are; number of integers (not number of bytes). void * ObjectAlloc(size_t size); Used to allocate a TObject on the heap (via TObject::operator new()).; Directly after this routine one can call (in the TObject ctor); TStorage::FilledByObjectAlloc() to find out if the just created object is on; the heap. void * ObjectAlloc(size_t size, void* vp); Used to allocate a TObject on the heap (via TObject::operator new(size_t,void*)); in position vp. vp is already allocated (maybe on heap, maybe on; stack) so just return. void ObjectDealloc(void* vp); Used to deallocate a TObject on the heap (via TObject::operator delete()). void ObjectDealloc(void* vp, void* ptr); Used to deallocate a TObject on the heap (via TObject::operator delete(void*,void*)). void SetFreeHook(FreeHookFun_t func, void* data); Set a free handler. void SetReAllocHooks(ReAllocFun_t func1, ReAllocCFun_t func2); Set a custom ReAlloc handlers. This function is typically; called via a static object in the ROOT libNew.so shared library. void PrintStatistics(); Print memory usage statistics. void EnableStatistics(int size = -1, int ix = -1); Enable memory usage statistics gathering. Size is the size of the memory; block that should be trapped and ix is a",MatchSource.WIKI,root/html534/TStorage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStorage.html
https://root.cern/root/html534/TStreamerArtificial.html:1507,Availability,error,error,1507,"ame); ~TStreamerArtificial(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerElement::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; Int_tTStreamerElement::GetArrayLength() const; TClass*TStreamerElement::GetClass() const; virtual TClass*TStreamerElement::GetClassPointer() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTStreamerElement::GetExecID() const; Double_tTStreamerElement::GetFactor() const; virtual const char*TStreamerElement::GetFullName() const; virtual const char*TObject::GetIconName() const; virtual const char*TStreamerElement::GetInclude() const; Int_tTStreamerElement::GetMaxIndex(Int_t i) const; virtua",MatchSource.WIKI,root/html534/TStreamerArtificial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerArtificial.html
https://root.cern/root/html534/TStreamerArtificial.html:1591,Availability,error,error,1591," virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerElement::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; Int_tTStreamerElement::GetArrayLength() const; TClass*TStreamerElement::GetClass() const; virtual TClass*TStreamerElement::GetClassPointer() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTStreamerElement::GetExecID() const; Double_tTStreamerElement::GetFactor() const; virtual const char*TStreamerElement::GetFullName() const; virtual const char*TObject::GetIconName() const; virtual const char*TStreamerElement::GetInclude() const; Int_tTStreamerElement::GetMaxIndex(Int_t i) const; virtual ULong_tTStreamerElement::GetMethod() const; virtual const char*TNamed::GetName() c",MatchSource.WIKI,root/html534/TStreamerArtificial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerArtificial.html
https://root.cern/root/html534/TStreamerArtificial.html:8967,Modifiability,inherit,inherits,8967,"Lmultiset; kSTLbitset; };; enum TStreamerElement::[unnamed] { kHasRange; kCache; kRepeat; kRead; kWrite; kDoNotDelete; kWholeObject; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tTStreamerElement::fArrayDimnumber of array dimensions; Int_tTStreamerElement::fArrayLengthcumulative size of all array dims; TClass*TStreamerElement::fClassObject!pointer to class of object; Double_tTStreamerElement::fFactor!Conversion factor if a range is specified fFactor = (1<<nbits/(xmax-xmin); Int_tTStreamerElement::fMaxIndex[5]Maximum array index for array dimension ""dim""; TStringTNamed::fNameobject identifier; TClass*TStreamerElement::fNewClass!new element class when reading; Int_tTStreamerElement::fNewType!new element type when reading; Int_tTStreamerElement::fOffset!element offset in class; void*fReadFunc!; void*fReadRawFunc!; Int_tTStreamerElement::fSizesizeof element; TMemberStreamer*TStreamerElement::fStreamer!pointer to element Streamer; Int_tTStreamerElement::fTObjectOffset!base offset for TObject if the element inherits from it; TStringTNamed::fTitleobject title; Int_tTStreamerElement::fTypeelement type; TStringTStreamerElement::fTypeNameData type name of data member; Double_tTStreamerElement::fXmax!Maximum of data member if a range is specified [xmin,xmax,nbits]; Double_tTStreamerElement::fXmin!Minimum of data member if a range is specified [xmin,xmax,nbits]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStreamerElement& operator=(const TStreamerArtificial& ). TStreamerArtificial(const TStreamerArtificial& ). TStreamerArtificial(const char* name, const char* title, Int_t offset, Int_t dtype, const char* typeName); TStreamerArtificial() : fReadFunc(0),fReadRawFunc(0) {}. {}. void SetReadFunc(ROOT::TSchemaRul",MatchSource.WIKI,root/html534/TStreamerArtificial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerArtificial.html
https://root.cern/root/html534/TStreamerBase.html:1477,Availability,error,error,1477,"et); virtual~TStreamerBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerElement::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; Int_tTStreamerElement::GetArrayLength() const; UInt_tGetBaseCheckSum(); TVirtualStreamerInfo*GetBaseStreamerInfo() const; Int_tGetBaseVersion(); TClass*TStreamerElement::GetClass() const; virtual TClass*GetClassPointer() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetErrorMessage() const; virtual Int_tTStreamerElement::GetExecID() const; Double_tTStreamerElement::GetFactor() const; virtual const char*TStreamerElement::GetFullName() const; virtual const char*TObject::GetIconName() const",MatchSource.WIKI,root/html534/TStreamerBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerBase.html
https://root.cern/root/html534/TStreamerBase.html:1561,Availability,error,error,1561," virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerElement::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; Int_tTStreamerElement::GetArrayLength() const; UInt_tGetBaseCheckSum(); TVirtualStreamerInfo*GetBaseStreamerInfo() const; Int_tGetBaseVersion(); TClass*TStreamerElement::GetClass() const; virtual TClass*GetClassPointer() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetErrorMessage() const; virtual Int_tTStreamerElement::GetExecID() const; Double_tTStreamerElement::GetFactor() const; virtual const char*TStreamerElement::GetFullName() const; virtual const char*TObject::GetIconName() const; virtual const char*GetInclude() const; Int_tTStreamerElement::GetMaxIndex(Int_t i)",MatchSource.WIKI,root/html534/TStreamerBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerBase.html
https://root.cern/root/html534/TStreamerBase.html:8542,Integrability,message,message,8542,"oError(int level, const char* location, const char* fmt, va_list va) const; voidInitStreaming(); voidTObject::MakeZombie(). private:. TStreamerBase(const TStreamerBase&); TStreamerBase&operator=(const TStreamerBase&). Data Members; public:. enum TStreamerElement::ESTLtype { kSTL; kSTLstring; kSTLvector; kSTLlist; kSTLdeque; kSTLmap; kSTLmultimap; kSTLset; kSTLmultiset; kSTLbitset; };; enum TStreamerElement::[unnamed] { kHasRange; kCache; kRepeat; kRead; kWrite; kDoNotDelete; kWholeObject; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tTStreamerElement::fArrayDimnumber of array dimensions; Int_tTStreamerElement::fArrayLengthcumulative size of all array dims; UInt_t&fBaseCheckSum!checksum of the base class (used during memberwise streaming); TClass*fBaseClass!pointer to base class; Int_tfBaseVersionversion number of the base class (used during memberwise streaming); TClass*TStreamerElement::fClassObject!pointer to class of object; TStringfErrorMsg!Error message in case of checksum/version mismatch.; Double_tTStreamerElement::fFactor!Conversion factor if a range is specified fFactor = (1<<nbits/(xmax-xmin); Int_tTStreamerElement::fMaxIndex[5]Maximum array index for array dimension ""dim""; TStringTNamed::fNameobject identifier; TClass*fNewBaseClass!pointer to new base class if renamed; TClass*TStreamerElement::fNewClass!new element class when reading; Int_tTStreamerElement::fNewType!new element type when reading; Int_tTStreamerElement::fOffset!element offset in class; Int_tTStreamerElement::fSizesizeof element; TMemberStreamer*TStreamerElement::fStreamer!pointer to element Streamer; ClassStreamerFunc_tfStreamerFunc!Pointer to a wrapper around a custom streamer member function.; TVirtualStreamerInfo*fStreamerInfo!Pointer to the current StreamerInfo ",MatchSource.WIKI,root/html534/TStreamerBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerBase.html
https://root.cern/root/html534/TStreamerBase.html:9227,Integrability,wrap,wrapper,9227,"HasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tTStreamerElement::fArrayDimnumber of array dimensions; Int_tTStreamerElement::fArrayLengthcumulative size of all array dims; UInt_t&fBaseCheckSum!checksum of the base class (used during memberwise streaming); TClass*fBaseClass!pointer to base class; Int_tfBaseVersionversion number of the base class (used during memberwise streaming); TClass*TStreamerElement::fClassObject!pointer to class of object; TStringfErrorMsg!Error message in case of checksum/version mismatch.; Double_tTStreamerElement::fFactor!Conversion factor if a range is specified fFactor = (1<<nbits/(xmax-xmin); Int_tTStreamerElement::fMaxIndex[5]Maximum array index for array dimension ""dim""; TStringTNamed::fNameobject identifier; TClass*fNewBaseClass!pointer to new base class if renamed; TClass*TStreamerElement::fNewClass!new element class when reading; Int_tTStreamerElement::fNewType!new element type when reading; Int_tTStreamerElement::fOffset!element offset in class; Int_tTStreamerElement::fSizesizeof element; TMemberStreamer*TStreamerElement::fStreamer!pointer to element Streamer; ClassStreamerFunc_tfStreamerFunc!Pointer to a wrapper around a custom streamer member function.; TVirtualStreamerInfo*fStreamerInfo!Pointer to the current StreamerInfo for the baset class.; Int_tTStreamerElement::fTObjectOffset!base offset for TObject if the element inherits from it; TStringTNamed::fTitleobject title; Int_tTStreamerElement::fTypeelement type; TStringTStreamerElement::fTypeNameData type name of data member; Double_tTStreamerElement::fXmax!Maximum of data member if a range is specified [xmin,xmax,nbits]; Double_tTStreamerElement::fXmin!Minimum of data member if a range is specified [xmin,xmax,nbits]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStreamerBase(); Abuse TStreamerEleme",MatchSource.WIKI,root/html534/TStreamerBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerBase.html
https://root.cern/root/html534/TStreamerBase.html:9448,Modifiability,inherit,inherits,9448,".; Double_tTStreamerElement::fFactor!Conversion factor if a range is specified fFactor = (1<<nbits/(xmax-xmin); Int_tTStreamerElement::fMaxIndex[5]Maximum array index for array dimension ""dim""; TStringTNamed::fNameobject identifier; TClass*fNewBaseClass!pointer to new base class if renamed; TClass*TStreamerElement::fNewClass!new element class when reading; Int_tTStreamerElement::fNewType!new element type when reading; Int_tTStreamerElement::fOffset!element offset in class; Int_tTStreamerElement::fSizesizeof element; TMemberStreamer*TStreamerElement::fStreamer!pointer to element Streamer; ClassStreamerFunc_tfStreamerFunc!Pointer to a wrapper around a custom streamer member function.; TVirtualStreamerInfo*fStreamerInfo!Pointer to the current StreamerInfo for the baset class.; Int_tTStreamerElement::fTObjectOffset!base offset for TObject if the element inherits from it; TStringTNamed::fTitleobject title; Int_tTStreamerElement::fTypeelement type; TStringTStreamerElement::fTypeNameData type name of data member; Double_tTStreamerElement::fXmax!Maximum of data member if a range is specified [xmin,xmax,nbits]; Double_tTStreamerElement::fXmin!Minimum of data member if a range is specified [xmin,xmax,nbits]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStreamerBase(); Abuse TStreamerElement data member that is not used by TStreamerBase; Default ctor. TStreamerBase(const char* name, const char* title, Int_t offset); Abuse TStreamerElement data member that is not used by TStreamerBase; Create a TStreamerBase object. ~TStreamerBase(); TStreamerBase dtor. TClass * GetClassPointer() const; Returns a pointer to the TClass of this element. Int_t GetSize() const; Returns size of baseclass in bytes. void Init(TObject* obj = 0); Setup the element. void InitStreaming(); Setup the fStreamerFunc and fStreamerinfo. Bool_t IsBase() const; Return kTRUE if the element represent a base class. const char * GetInclude() const; Return the proper incl",MatchSource.WIKI,root/html534/TStreamerBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerBase.html
https://root.cern/root/html534/TStreamerBase.html:8263,Security,checksum,checksum,8263,"oError(int level, const char* location, const char* fmt, va_list va) const; voidInitStreaming(); voidTObject::MakeZombie(). private:. TStreamerBase(const TStreamerBase&); TStreamerBase&operator=(const TStreamerBase&). Data Members; public:. enum TStreamerElement::ESTLtype { kSTL; kSTLstring; kSTLvector; kSTLlist; kSTLdeque; kSTLmap; kSTLmultimap; kSTLset; kSTLmultiset; kSTLbitset; };; enum TStreamerElement::[unnamed] { kHasRange; kCache; kRepeat; kRead; kWrite; kDoNotDelete; kWholeObject; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tTStreamerElement::fArrayDimnumber of array dimensions; Int_tTStreamerElement::fArrayLengthcumulative size of all array dims; UInt_t&fBaseCheckSum!checksum of the base class (used during memberwise streaming); TClass*fBaseClass!pointer to base class; Int_tfBaseVersionversion number of the base class (used during memberwise streaming); TClass*TStreamerElement::fClassObject!pointer to class of object; TStringfErrorMsg!Error message in case of checksum/version mismatch.; Double_tTStreamerElement::fFactor!Conversion factor if a range is specified fFactor = (1<<nbits/(xmax-xmin); Int_tTStreamerElement::fMaxIndex[5]Maximum array index for array dimension ""dim""; TStringTNamed::fNameobject identifier; TClass*fNewBaseClass!pointer to new base class if renamed; TClass*TStreamerElement::fNewClass!new element class when reading; Int_tTStreamerElement::fNewType!new element type when reading; Int_tTStreamerElement::fOffset!element offset in class; Int_tTStreamerElement::fSizesizeof element; TMemberStreamer*TStreamerElement::fStreamer!pointer to element Streamer; ClassStreamerFunc_tfStreamerFunc!Pointer to a wrapper around a custom streamer member function.; TVirtualStreamerInfo*fStreamerInfo!Pointer to the current StreamerInfo ",MatchSource.WIKI,root/html534/TStreamerBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerBase.html
https://root.cern/root/html534/TStreamerBase.html:8561,Security,checksum,checksum,8561,"oError(int level, const char* location, const char* fmt, va_list va) const; voidInitStreaming(); voidTObject::MakeZombie(). private:. TStreamerBase(const TStreamerBase&); TStreamerBase&operator=(const TStreamerBase&). Data Members; public:. enum TStreamerElement::ESTLtype { kSTL; kSTLstring; kSTLvector; kSTLlist; kSTLdeque; kSTLmap; kSTLmultimap; kSTLset; kSTLmultiset; kSTLbitset; };; enum TStreamerElement::[unnamed] { kHasRange; kCache; kRepeat; kRead; kWrite; kDoNotDelete; kWholeObject; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tTStreamerElement::fArrayDimnumber of array dimensions; Int_tTStreamerElement::fArrayLengthcumulative size of all array dims; UInt_t&fBaseCheckSum!checksum of the base class (used during memberwise streaming); TClass*fBaseClass!pointer to base class; Int_tfBaseVersionversion number of the base class (used during memberwise streaming); TClass*TStreamerElement::fClassObject!pointer to class of object; TStringfErrorMsg!Error message in case of checksum/version mismatch.; Double_tTStreamerElement::fFactor!Conversion factor if a range is specified fFactor = (1<<nbits/(xmax-xmin); Int_tTStreamerElement::fMaxIndex[5]Maximum array index for array dimension ""dim""; TStringTNamed::fNameobject identifier; TClass*fNewBaseClass!pointer to new base class if renamed; TClass*TStreamerElement::fNewClass!new element class when reading; Int_tTStreamerElement::fNewType!new element type when reading; Int_tTStreamerElement::fOffset!element offset in class; Int_tTStreamerElement::fSizesizeof element; TMemberStreamer*TStreamerElement::fStreamer!pointer to element Streamer; ClassStreamerFunc_tfStreamerFunc!Pointer to a wrapper around a custom streamer member function.; TVirtualStreamerInfo*fStreamerInfo!Pointer to the current StreamerInfo ",MatchSource.WIKI,root/html534/TStreamerBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerBase.html
https://root.cern/root/html534/TStreamerBasicPointer.html:1649,Availability,error,error,1649,"tual~TStreamerBasicPointer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerElement::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; Int_tTStreamerElement::GetArrayLength() const; TClass*TStreamerElement::GetClass() const; virtual TClass*TStreamerElement::GetClassPointer() const; const char*GetCountClass() const; const char*GetCountName() const; Int_tGetCountVersion() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTStreamerElement::GetExecID() const; Double_tTStreamerElement::GetFactor() const; virtual const char*TStreamerElement::GetFullName() const; virtual const char*TObject::GetIconName() const; virtual const cha",MatchSource.WIKI,root/html534/TStreamerBasicPointer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerBasicPointer.html
https://root.cern/root/html534/TStreamerBasicPointer.html:1733,Availability,error,error,1733," virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerElement::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; Int_tTStreamerElement::GetArrayLength() const; TClass*TStreamerElement::GetClass() const; virtual TClass*TStreamerElement::GetClassPointer() const; const char*GetCountClass() const; const char*GetCountName() const; Int_tGetCountVersion() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTStreamerElement::GetExecID() const; Double_tTStreamerElement::GetFactor() const; virtual const char*TStreamerElement::GetFullName() const; virtual const char*TObject::GetIconName() const; virtual const char*TStreamerElement::GetInclude() const; Int_tTStreamerElement::GetMaxIndex(Int_t i) ",MatchSource.WIKI,root/html534/TStreamerBasicPointer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerBasicPointer.html
https://root.cern/root/html534/TStreamerBasicPointer.html:9201,Modifiability,inherit,inherits,9201,"te; kDoNotDelete; kWholeObject; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tTStreamerElement::fArrayDimnumber of array dimensions; Int_tTStreamerElement::fArrayLengthcumulative size of all array dims; TClass*TStreamerElement::fClassObject!pointer to class of object; TStringfCountClassname of the class with the counter; TStringfCountNamename of data member holding the array count; Int_tfCountVersionversion number of the class with the counter; TStreamerBasicType*fCounter!pointer to basic type counter; Double_tTStreamerElement::fFactor!Conversion factor if a range is specified fFactor = (1<<nbits/(xmax-xmin); Int_tTStreamerElement::fMaxIndex[5]Maximum array index for array dimension ""dim""; TStringTNamed::fNameobject identifier; TClass*TStreamerElement::fNewClass!new element class when reading; Int_tTStreamerElement::fNewType!new element type when reading; Int_tTStreamerElement::fOffset!element offset in class; Int_tTStreamerElement::fSizesizeof element; TMemberStreamer*TStreamerElement::fStreamer!pointer to element Streamer; Int_tTStreamerElement::fTObjectOffset!base offset for TObject if the element inherits from it; TStringTNamed::fTitleobject title; Int_tTStreamerElement::fTypeelement type; TStringTStreamerElement::fTypeNameData type name of data member; Double_tTStreamerElement::fXmax!Maximum of data member if a range is specified [xmin,xmax,nbits]; Double_tTStreamerElement::fXmin!Minimum of data member if a range is specified [xmin,xmax,nbits]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStreamerBasicPointer(); Default ctor. TStreamerBasicPointer(const char* name, const char* title, Int_t offset, Int_t dtype, const char* countName, const char* countClass, Int_t version, const char* typeName)",MatchSource.WIKI,root/html534/TStreamerBasicPointer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerBasicPointer.html
https://root.cern/root/html534/TStreamerBasicType.html:1567,Availability,error,error,1567,"virtual~TStreamerBasicType(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerElement::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; Int_tTStreamerElement::GetArrayLength() const; TClass*TStreamerElement::GetClass() const; virtual TClass*TStreamerElement::GetClassPointer() const; Int_tGetCounter() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTStreamerElement::GetExecID() const; Double_tTStreamerElement::GetFactor() const; virtual const char*TStreamerElement::GetFullName() const; virtual const char*TObject::GetIconName() const; virtual const char*TStreamerElement::GetInclude() const; Int_tTStreamerElement::GetMaxInd",MatchSource.WIKI,root/html534/TStreamerBasicType.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerBasicType.html
https://root.cern/root/html534/TStreamerBasicType.html:1651,Availability,error,error,1651," virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerElement::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; Int_tTStreamerElement::GetArrayLength() const; TClass*TStreamerElement::GetClass() const; virtual TClass*TStreamerElement::GetClassPointer() const; Int_tGetCounter() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTStreamerElement::GetExecID() const; Double_tTStreamerElement::GetFactor() const; virtual const char*TStreamerElement::GetFullName() const; virtual const char*TObject::GetIconName() const; virtual const char*TStreamerElement::GetInclude() const; Int_tTStreamerElement::GetMaxIndex(Int_t i) const; virtual ULong_tGetMethod() const; virtual const char*TNamed::GetN",MatchSource.WIKI,root/html534/TStreamerBasicType.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerBasicType.html
https://root.cern/root/html534/TStreamerBasicType.html:8823,Modifiability,inherit,inherits,8823,"Lbitset; };; enum TStreamerElement::[unnamed] { kHasRange; kCache; kRepeat; kRead; kWrite; kDoNotDelete; kWholeObject; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tTStreamerElement::fArrayDimnumber of array dimensions; Int_tTStreamerElement::fArrayLengthcumulative size of all array dims; TClass*TStreamerElement::fClassObject!pointer to class of object; Int_tfCounter!value of data member when referenced by an array; Double_tTStreamerElement::fFactor!Conversion factor if a range is specified fFactor = (1<<nbits/(xmax-xmin); Int_tTStreamerElement::fMaxIndex[5]Maximum array index for array dimension ""dim""; TStringTNamed::fNameobject identifier; TClass*TStreamerElement::fNewClass!new element class when reading; Int_tTStreamerElement::fNewType!new element type when reading; Int_tTStreamerElement::fOffset!element offset in class; Int_tTStreamerElement::fSizesizeof element; TMemberStreamer*TStreamerElement::fStreamer!pointer to element Streamer; Int_tTStreamerElement::fTObjectOffset!base offset for TObject if the element inherits from it; TStringTNamed::fTitleobject title; Int_tTStreamerElement::fTypeelement type; TStringTStreamerElement::fTypeNameData type name of data member; Double_tTStreamerElement::fXmax!Maximum of data member if a range is specified [xmin,xmax,nbits]; Double_tTStreamerElement::fXmin!Minimum of data member if a range is specified [xmin,xmax,nbits]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStreamerBasicType(); Default ctor. TStreamerBasicType(const char* name, const char* title, Int_t offset, Int_t dtype, const char* typeName); Create a TStreamerBasicType object. ~TStreamerBasicType(); TStreamerBasicType dtor. ULong_t GetMethod() const; return address of counter. Int_t GetSize()",MatchSource.WIKI,root/html534/TStreamerBasicType.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerBasicType.html
https://root.cern/root/html534/TStreamerElement.html:1446,Availability,error,error,1446,"st char* typeName); virtual~TStreamerElement(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tCannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetArrayDim() const; Int_tGetArrayLength() const; TClass*GetClass() const; virtual TClass*GetClassPointer() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetExecID() const; Double_tGetFactor() const; virtual const char*GetFullName() const; virtual const char*TObject::GetIconName() const; virtual const char*GetInclude() const; Int_tGetMaxIndex(Int_t i) const; virtual ULong_tGetMethod() const; virtual const char*TNamed::GetName() const; TClass*GetNewClass() const; Int_tGetNewType() const; virtual char*TObject::GetObjectInfo(I",MatchSource.WIKI,root/html534/TStreamerElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerElement.html
https://root.cern/root/html534/TStreamerElement.html:1530,Availability,error,error,1530,"ar* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tCannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetArrayDim() const; Int_tGetArrayLength() const; TClass*GetClass() const; virtual TClass*GetClassPointer() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetExecID() const; Double_tGetFactor() const; virtual const char*GetFullName() const; virtual const char*TObject::GetIconName() const; virtual const char*GetInclude() const; Int_tGetMaxIndex(Int_t i) const; virtual ULong_tGetMethod() const; virtual const char*TNamed::GetName() const; TClass*GetNewClass() const; Int_tGetNewType() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tGetOffset() co",MatchSource.WIKI,root/html534/TStreamerElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerElement.html
https://root.cern/root/html534/TStreamerElement.html:7695,Modifiability,inherit,inherits,7695,"); TStreamerElement&operator=(const TStreamerElement&). Data Members; public:. enum ESTLtype { kSTL; kSTLstring; kSTLvector; kSTLlist; kSTLdeque; kSTLmap; kSTLmultimap; kSTLset; kSTLmultiset; kSTLbitset; };; enum { kHasRange; kCache; kRepeat; kRead; kWrite; kDoNotDelete; kWholeObject; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfArrayDimnumber of array dimensions; Int_tfArrayLengthcumulative size of all array dims; TClass*fClassObject!pointer to class of object; Double_tfFactor!Conversion factor if a range is specified fFactor = (1<<nbits/(xmax-xmin); Int_tfMaxIndex[5]Maximum array index for array dimension ""dim""; TStringTNamed::fNameobject identifier; TClass*fNewClass!new element class when reading; Int_tfNewType!new element type when reading; Int_tfOffset!element offset in class; Int_tfSizesizeof element; TMemberStreamer*fStreamer!pointer to element Streamer; Int_tfTObjectOffset!base offset for TObject if the element inherits from it; TStringTNamed::fTitleobject title; Int_tfTypeelement type; TStringfTypeNameData type name of data member; Double_tfXmax!Maximum of data member if a range is specified [xmin,xmax,nbits]; Double_tfXmin!Minimum of data member if a range is specified [xmin,xmax,nbits]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStreamerElement(); Default ctor. TStreamerElement(const char* name, const char* title, Int_t offset, Int_t dtype, const char* typeName); Create a TStreamerElement object. ~TStreamerElement(); TStreamerElement dtor. Bool_t CannotSplit() const; Returns true if the element cannot be split, false otherwise.; An element cannot be split if the corresponding class member has; the special characters ""||"" as the first characters in the; comment field. TClass * GetCl",MatchSource.WIKI,root/html534/TStreamerElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerElement.html
https://root.cern/root/html534/TStreamerElement.html:9011,Performance,cache,cached,9011,",nbits]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStreamerElement(); Default ctor. TStreamerElement(const char* name, const char* title, Int_t offset, Int_t dtype, const char* typeName); Create a TStreamerElement object. ~TStreamerElement(); TStreamerElement dtor. Bool_t CannotSplit() const; Returns true if the element cannot be split, false otherwise.; An element cannot be split if the corresponding class member has; the special characters ""||"" as the first characters in the; comment field. TClass * GetClassPointer() const; Returns a pointer to the TClass of this element. Int_t GetExecID() const; Returns the TExec id for the EXEC instruction in the comment field; of a TRef data member. const char * GetFullName() const; Return element name including dimensions, if any; Note that this function stores the name into a static array.; You should copy the result. void GetSequenceType(TString& type) const; Fill type with the string representation of sequence; information including 'cached','repeat','write' or; 'nodelete'. Int_t GetSize() const; Returns size of this element in bytes. TMemberStreamer * GetStreamer() const; Return the local streamer object. const char * GetTypeNameBasic() const; Return type name of this element; in case the type name is not a standard basic type, return; the basic type name known to CINT. void Init(TObject* obj = 0); Initliaze the element. Bool_t IsOldFormat(const char* newTypeName); The early 3.00/00 and 3.01/01 versions used to store; dm->GetTypeName instead of dm->GetFullTypename; if this case is detected, the element type name is modified. Bool_t IsBase() const; Return kTRUE if the element represent a base class. void ls(Option_t* option = """") const; Print the content of the element. void SetArrayDim(Int_t dim); Set number of array dimensions. void SetMaxIndex(Int_t dim, Int_t max); set maximum index for array with dimension dim. void SetStreamer(TMemberStreamer* streamer); set pointer to ",MatchSource.WIKI,root/html534/TStreamerElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerElement.html
https://root.cern/root/html534/TStreamerElement.html:9570,Safety,detect,detected,9570,"const; Returns a pointer to the TClass of this element. Int_t GetExecID() const; Returns the TExec id for the EXEC instruction in the comment field; of a TRef data member. const char * GetFullName() const; Return element name including dimensions, if any; Note that this function stores the name into a static array.; You should copy the result. void GetSequenceType(TString& type) const; Fill type with the string representation of sequence; information including 'cached','repeat','write' or; 'nodelete'. Int_t GetSize() const; Returns size of this element in bytes. TMemberStreamer * GetStreamer() const; Return the local streamer object. const char * GetTypeNameBasic() const; Return type name of this element; in case the type name is not a standard basic type, return; the basic type name known to CINT. void Init(TObject* obj = 0); Initliaze the element. Bool_t IsOldFormat(const char* newTypeName); The early 3.00/00 and 3.01/01 versions used to store; dm->GetTypeName instead of dm->GetFullTypename; if this case is detected, the element type name is modified. Bool_t IsBase() const; Return kTRUE if the element represent a base class. void ls(Option_t* option = """") const; Print the content of the element. void SetArrayDim(Int_t dim); Set number of array dimensions. void SetMaxIndex(Int_t dim, Int_t max); set maximum index for array with dimension dim. void SetStreamer(TMemberStreamer* streamer); set pointer to Streamer function for this element. void Streamer(TBuffer& ); Stream an object of class TStreamerElement. void Update(const TClass* oldClass, TClass* newClass); function called by the TClass constructor when replacing an emulated class; by the real class. TStreamerElement(const TStreamerElement& ). TStreamerElement& operator=(const TStreamerElement& ). Int_t GetArrayDim() const; {return fArrayDim;}. Int_t GetArrayLength() const; {return fArrayLength;}. TClass * GetClass() const; {return GetClassPointer();}. const char * GetInclude() const; {return """";}. Int_t GetMaxIn",MatchSource.WIKI,root/html534/TStreamerElement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerElement.html
https://root.cern/root/html534/TStreamerInfo.html:2578,Availability,error,error,2578,"ss*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t*); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Bool_tCompareContent(TClass* cl, TVirtualStreamerInfo* info, Bool_t warn, Bool_t complete, TFile* file); virtual voidCompile(); voidComputeSize(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE); virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static TVirtualStreamerInfo*TVirtualStreamerInfo::Factory(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TFile* file, Bool_t force = kFALSE); virtual TClassStreamer*GenEmulatedClassStreamer(const char* class_name, Bool_t silent); virtual TVirtualCollectionProxy*GenEmulatedProxy(const char* class_name, Bool_t silent); virtual Int_tGenerateHeaderFile(const char* dirname, const TList* subClasses = 0, const TList* extrainfos = 0); virtual TClassStreamer*GenExplicitClassStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl); virtual TVirtualCollectionProxy*GenExplicitProxy(const ROOT::TCollectionProxyIn",MatchSource.WIKI,root/html534/TStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html
https://root.cern/root/html534/TStreamerInfo.html:2662,Availability,error,error,2662,"t*); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Bool_tCompareContent(TClass* cl, TVirtualStreamerInfo* info, Bool_t warn, Bool_t complete, TFile* file); virtual voidCompile(); voidComputeSize(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE); virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static TVirtualStreamerInfo*TVirtualStreamerInfo::Factory(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TFile* file, Bool_t force = kFALSE); virtual TClassStreamer*GenEmulatedClassStreamer(const char* class_name, Bool_t silent); virtual TVirtualCollectionProxy*GenEmulatedProxy(const char* class_name, Bool_t silent); virtual Int_tGenerateHeaderFile(const char* dirname, const TList* subClasses = 0, const TList* extrainfos = 0); virtual TClassStreamer*GenExplicitClassStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl); virtual TVirtualCollectionProxy*GenExplicitProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl); virtual TClass*GetActualClass(const void* obj) const; virtual",MatchSource.WIKI,root/html534/TStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html
https://root.cern/root/html534/TStreamerInfo.html:17263,Availability,error,error,17263,"ave some rules; to do that. void BuildOld(); rebuild the TStreamerInfo structure. void Clear(Option_t* ); If opt cointains 'built', reset this StreamerInfo as if Build or BuildOld; was never called on it (usefull to force their re-running). void CallShowMembers(void* obj, TMemberInspector& insp) const; Emulated a call ShowMembers() on the obj of this class type, passing insp and parent. TObject * Clone(const char* newname = """") const; Make a clone of an object using the Streamer facility.; If newname is specified, this will be the name of the new object. Bool_t CompareContent(TClass* cl, TVirtualStreamerInfo* info, Bool_t warn, Bool_t complete, TFile* file); Return True if the current StreamerInfo in cl or info is equivalent to this TStreamerInfo.; 'Equivalent' means the same number of persistent data member which the same actual C++ type and; the same name.; if 'warn' is true, Warning message are printed to explicit the differences.; if 'complete' is false, stop at the first error, otherwise continue until all members have been checked. void ComputeSize(); Compute total size of all persistent elements of the class. void ForceWriteInfo(TFile* file, Bool_t force = kFALSE); -- Recursively mark streamer infos for writing to a file. Will force this TStreamerInfo to the file and also; all the dependencies. If argument force > 0 the loop on class dependencies is forced. This function is called when streaming a class that contains; a null pointer. In this case, the TStreamerInfo for the class; with the null pointer must be written to the file and also all; the TStreamerInfo of all the classes referenced by the class. --; We must be given a file to write to. TClass * GetActualClass(const void* obj) const; Assuming that obj points to (the part of) an object that is of the; type described by this streamerInfo, return the actual type of the; object (i.e. the type described by this streamerInfo is a base class; of the actual type of the object.; This routine should only be call",MatchSource.WIKI,root/html534/TStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html
https://root.cern/root/html534/TStreamerInfo.html:14219,Deployability,update,update,14219,"rue if the StreamerInfo has been compiled (i.e. fully built, ready to use for streaming).; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; static Bool_tTVirtualStreamerInfo::fgCanDeleteTrue if ReadBuffer can delete object; static TVirtualStreamerInfo*TVirtualStreamerInfo::fgInfoFactory; static Bool_tTVirtualStreamerInfo::fgOptimizeTrue if optimization on; static Bool_tTVirtualStreamerInfo::fgStreamMemberWiseTrue if the collections are to be stream ""member-wise"" (when possible). private:. UInt_tfCheckSumchecksum of original class; TClass*fClass!pointer to class; Int_tfClassVersionClass version identifier; TStreamerInfo::TCompInfo*fComp![fNslots with less than fElements->GetEntries()*1.5 used] Compiled info; TStreamerInfo::TCompInfo**fCompFull![fElements->GetEntries()]; TStreamerInfo::TCompInfo**fCompOpt![fNdata]; TObjArray*fElementsArray of TStreamerElements; ULong_tfLiveCount! Number of outstanding pointer to this StreamerInfo.; Int_tfNVirtualInfoLoc! Number of virtual info location to update.; Int_tfNdata!number of optimized elements; Int_tfNfulldata!number of elements; Int_tfNslots!total numbrer of slots in fComp.; Int_tfNumber!Unique identifier; Version_tfOldVersion! Version of the TStreamerInfo object read from the file; Int_tfOnFileClassVersion!Class version identifier as stored on file.; TStreamerInfoActions::TActionSequence*fReadMemberWise! List of read action resulting from the compilation for use in member wise streaming.; TStreamerInfoActions::TActionSequence*fReadMemberWiseVecPtr! List of read action resulting from the compilation for use in member wise streaming.; TStreamerInfoActions::TActionSequence*fReadObjectWise! List of read action resulting from the compilation.; Int_tfSize!size of the persistent class; ULong_t*fVirtualInfoLoc![fNVirtualInfoLoc] Location of the pointer to the TStreamerInfo inside the object (when emulated); TStreamerInfoActions::TActionSequence*fWriteMemberWise! List of write action resulting from the comp",MatchSource.WIKI,root/html534/TStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html
https://root.cern/root/html534/TStreamerInfo.html:22929,Energy Efficiency,allocate,allocate,22929,"amerElement object corresponding to the j-th; element of a compressed array in fElems. parameters description:; - i: the serial number in array fElem; - j: the element number in the array of consecutive types; In the above example the class TAttLine has 3 consecutive data members; of the same type ""short"". Compile makes one single array of 3 elements.; To access the TStreamerElement for the second element; of this array, one can call:; TStreamerElement *el = GetStreamerElementReal(0,1);; const char* membername = el->GetName();; This function is typically called from TBuffer, TXmlBuffer. void InsertArtificialElements(const TObjArray* rules); Insert new members as expressed in the array of TSchemaRule(s). void ls(Option_t* option = """") const; List the TStreamerElement list and also the precomputed tables; if option contains the string ""incOrig"", also prints the original; (non-optimized elements in the list of compiled elements. void* New(void* obj = 0); An emulated object is created at address obj, if obj is null we; allocate memory for the object. void* NewArray(Long_t nElements, void* ary = 0); An array of emulated objects is created at address ary, if ary is null,; we allocate memory for the array. void DestructorImpl(void* p, Bool_t dtorOnly); Internal part of the destructor.; Destruct each of the datamembers in the same order; as the implicit destructor would. void Destructor(void* p, Bool_t dtorOnly = kFALSE); Emulated destructor for this class.; An emulated object is destroyed at address p.; Destruct each of the datamembers in the same order; as the implicit destructor would. void DeleteArray(void* p, Bool_t dtorOnly = kFALSE); Destroy an array of emulated objects, with optional delete. void PrintValue(const char* name, char* pointer, Int_t i, Int_t len, Int_t lenmax = 1000) const; print value of element i in object at pointer; The function may be called in two ways:; -method1 len < 0; i is assumed to be the TStreamerElement number i in StreamerInfo; -method2 le",MatchSource.WIKI,root/html534/TStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html
https://root.cern/root/html534/TStreamerInfo.html:23086,Energy Efficiency,allocate,allocate,23086,"ray fElem; - j: the element number in the array of consecutive types; In the above example the class TAttLine has 3 consecutive data members; of the same type ""short"". Compile makes one single array of 3 elements.; To access the TStreamerElement for the second element; of this array, one can call:; TStreamerElement *el = GetStreamerElementReal(0,1);; const char* membername = el->GetName();; This function is typically called from TBuffer, TXmlBuffer. void InsertArtificialElements(const TObjArray* rules); Insert new members as expressed in the array of TSchemaRule(s). void ls(Option_t* option = """") const; List the TStreamerElement list and also the precomputed tables; if option contains the string ""incOrig"", also prints the original; (non-optimized elements in the list of compiled elements. void* New(void* obj = 0); An emulated object is created at address obj, if obj is null we; allocate memory for the object. void* NewArray(Long_t nElements, void* ary = 0); An array of emulated objects is created at address ary, if ary is null,; we allocate memory for the array. void DestructorImpl(void* p, Bool_t dtorOnly); Internal part of the destructor.; Destruct each of the datamembers in the same order; as the implicit destructor would. void Destructor(void* p, Bool_t dtorOnly = kFALSE); Emulated destructor for this class.; An emulated object is destroyed at address p.; Destruct each of the datamembers in the same order; as the implicit destructor would. void DeleteArray(void* p, Bool_t dtorOnly = kFALSE); Destroy an array of emulated objects, with optional delete. void PrintValue(const char* name, char* pointer, Int_t i, Int_t len, Int_t lenmax = 1000) const; print value of element i in object at pointer; The function may be called in two ways:; -method1 len < 0; i is assumed to be the TStreamerElement number i in StreamerInfo; -method2 len >= 0; i is the type; address of variable is directly pointer.; len is the number of elements to be printed starting at pointer. void Prin",MatchSource.WIKI,root/html534/TStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html
https://root.cern/root/html534/TStreamerInfo.html:17171,Integrability,message,message,17171,"t. Bool_t BuildFor(const TClass* cl). Check if we can build this for foreign class - do we have some rules; to do that. void BuildOld(); rebuild the TStreamerInfo structure. void Clear(Option_t* ); If opt cointains 'built', reset this StreamerInfo as if Build or BuildOld; was never called on it (usefull to force their re-running). void CallShowMembers(void* obj, TMemberInspector& insp) const; Emulated a call ShowMembers() on the obj of this class type, passing insp and parent. TObject * Clone(const char* newname = """") const; Make a clone of an object using the Streamer facility.; If newname is specified, this will be the name of the new object. Bool_t CompareContent(TClass* cl, TVirtualStreamerInfo* info, Bool_t warn, Bool_t complete, TFile* file); Return True if the current StreamerInfo in cl or info is equivalent to this TStreamerInfo.; 'Equivalent' means the same number of persistent data member which the same actual C++ type and; the same name.; if 'warn' is true, Warning message are printed to explicit the differences.; if 'complete' is false, stop at the first error, otherwise continue until all members have been checked. void ComputeSize(); Compute total size of all persistent elements of the class. void ForceWriteInfo(TFile* file, Bool_t force = kFALSE); -- Recursively mark streamer infos for writing to a file. Will force this TStreamerInfo to the file and also; all the dependencies. If argument force > 0 the loop on class dependencies is forced. This function is called when streaming a class that contains; a null pointer. In this case, the TStreamerInfo for the class; with the null pointer must be written to the file and also all; the TStreamerInfo of all the classes referenced by the class. --; We must be given a file to write to. TClass * GetActualClass(const void* obj) const; Assuming that obj points to (the part of) an object that is of the; type described by this streamerInfo, return the actual type of the; object (i.e. the type described by this stream",MatchSource.WIKI,root/html534/TStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html
https://root.cern/root/html534/TStreamerInfo.html:17581,Integrability,depend,dependencies,17581,"ctor& insp) const; Emulated a call ShowMembers() on the obj of this class type, passing insp and parent. TObject * Clone(const char* newname = """") const; Make a clone of an object using the Streamer facility.; If newname is specified, this will be the name of the new object. Bool_t CompareContent(TClass* cl, TVirtualStreamerInfo* info, Bool_t warn, Bool_t complete, TFile* file); Return True if the current StreamerInfo in cl or info is equivalent to this TStreamerInfo.; 'Equivalent' means the same number of persistent data member which the same actual C++ type and; the same name.; if 'warn' is true, Warning message are printed to explicit the differences.; if 'complete' is false, stop at the first error, otherwise continue until all members have been checked. void ComputeSize(); Compute total size of all persistent elements of the class. void ForceWriteInfo(TFile* file, Bool_t force = kFALSE); -- Recursively mark streamer infos for writing to a file. Will force this TStreamerInfo to the file and also; all the dependencies. If argument force > 0 the loop on class dependencies is forced. This function is called when streaming a class that contains; a null pointer. In this case, the TStreamerInfo for the class; with the null pointer must be written to the file and also all; the TStreamerInfo of all the classes referenced by the class. --; We must be given a file to write to. TClass * GetActualClass(const void* obj) const; Assuming that obj points to (the part of) an object that is of the; type described by this streamerInfo, return the actual type of the; object (i.e. the type described by this streamerInfo is a base class; of the actual type of the object.; This routine should only be called if the class decribed by this; StreamerInfo is 'emulated'. Bool_t MatchLegacyCheckSum(UInt_t checksum) const; Return true if the checksum passed as argument is one of the checksum; value produced by the older checksum calulcation algorithm. UInt_t GetCheckSum(TClass::ECheckSum code",MatchSource.WIKI,root/html534/TStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html
https://root.cern/root/html534/TStreamerInfo.html:17635,Integrability,depend,dependencies,17635,"lass type, passing insp and parent. TObject * Clone(const char* newname = """") const; Make a clone of an object using the Streamer facility.; If newname is specified, this will be the name of the new object. Bool_t CompareContent(TClass* cl, TVirtualStreamerInfo* info, Bool_t warn, Bool_t complete, TFile* file); Return True if the current StreamerInfo in cl or info is equivalent to this TStreamerInfo.; 'Equivalent' means the same number of persistent data member which the same actual C++ type and; the same name.; if 'warn' is true, Warning message are printed to explicit the differences.; if 'complete' is false, stop at the first error, otherwise continue until all members have been checked. void ComputeSize(); Compute total size of all persistent elements of the class. void ForceWriteInfo(TFile* file, Bool_t force = kFALSE); -- Recursively mark streamer infos for writing to a file. Will force this TStreamerInfo to the file and also; all the dependencies. If argument force > 0 the loop on class dependencies is forced. This function is called when streaming a class that contains; a null pointer. In this case, the TStreamerInfo for the class; with the null pointer must be written to the file and also all; the TStreamerInfo of all the classes referenced by the class. --; We must be given a file to write to. TClass * GetActualClass(const void* obj) const; Assuming that obj points to (the part of) an object that is of the; type described by this streamerInfo, return the actual type of the; object (i.e. the type described by this streamerInfo is a base class; of the actual type of the object.; This routine should only be called if the class decribed by this; StreamerInfo is 'emulated'. Bool_t MatchLegacyCheckSum(UInt_t checksum) const; Return true if the checksum passed as argument is one of the checksum; value produced by the older checksum calulcation algorithm. UInt_t GetCheckSum(TClass::ECheckSum code) const; Recalculate the checksum of this TStreamerInfo based on its ",MatchSource.WIKI,root/html534/TStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html
https://root.cern/root/html534/TStreamerInfo.html:18245,Integrability,rout,routine,18245,"nue until all members have been checked. void ComputeSize(); Compute total size of all persistent elements of the class. void ForceWriteInfo(TFile* file, Bool_t force = kFALSE); -- Recursively mark streamer infos for writing to a file. Will force this TStreamerInfo to the file and also; all the dependencies. If argument force > 0 the loop on class dependencies is forced. This function is called when streaming a class that contains; a null pointer. In this case, the TStreamerInfo for the class; with the null pointer must be written to the file and also all; the TStreamerInfo of all the classes referenced by the class. --; We must be given a file to write to. TClass * GetActualClass(const void* obj) const; Assuming that obj points to (the part of) an object that is of the; type described by this streamerInfo, return the actual type of the; object (i.e. the type described by this streamerInfo is a base class; of the actual type of the object.; This routine should only be called if the class decribed by this; StreamerInfo is 'emulated'. Bool_t MatchLegacyCheckSum(UInt_t checksum) const; Return true if the checksum passed as argument is one of the checksum; value produced by the older checksum calulcation algorithm. UInt_t GetCheckSum(TClass::ECheckSum code) const; Recalculate the checksum of this TStreamerInfo based on its code. The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The check sum is built from the names/types of base classes and; data members.; Original algorithm from Victor Perevovchikov (perev@bnl.gov). The valid range of code is determined by ECheckSum. kNoEnum: data members of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation. This is needed for backward compatibility. WARNING: this function must be kept in sync with TClas",MatchSource.WIKI,root/html534/TStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html
https://root.cern/root/html534/TStreamerInfo.html:20968,Integrability,rout,routine,20968," is called by TFile::MakeProject for each class in the file. Int_t GetDataMemberOffset(TDataMember* dm, TMemberStreamer*& streamer) const; Compute data member offset; return pointer to the Streamer function if one exists. Int_t GetOffset(const char* ) const; return the offset of the data member as indicated by this StreamerInfo. Int_t GetSize() const; return total size of all persistent elements of the class (with offsets). Int_t GetSizeElements() const; return total size of all persistent elements of the class; use GetSize if you want to get the real size in memory. TStreamerElement* GetStreamerElement(const char* datamember, Int_t& offset) const; Return the StreamerElement of ""datamember"" inside our; class or any of its base classes. The offset information; contained in the StreamerElement is related to its immediately; containing class, so we return in 'offset' the offset inside; our class. TStreamerElement* GetStreamerElementReal(Int_t i, Int_t j) const. This routine is obsolete and should not longer be used. TStreamerInfo holds two types of data structures; -TObjArray* fElements; containing the list of all TStreamerElement; objects for this class version.; -ULong_t* fElem; containing the preprocessed information; by TStreamerInfo::Compile In case consecutive data members; are of the same type, the Compile function declares the consecutive; elements as one single element in fElems. example with the class TAttLine; TClass::GetClass(""TAttLine"")->GetStreamerInfo()->ls(); produces;; StreamerInfo for class: TAttLine, version=1; short fLineColor offset= 4 type= 2 line color; short fLineStyle offset= 6 type= 2 line style; short fLineWidth offset= 8 type= 2 line width; i= 0, fLineColor type= 22, offset= 4, len=3, method=0; For I/O implementations (eg. XML) , one has to know the original name; of the data member. This function can be used to return a pointer; to the original TStreamerElement object corresponding to the j-th; element of a compressed array in fElems. param",MatchSource.WIKI,root/html534/TStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html
https://root.cern/root/html534/TStreamerInfo.html:29071,Integrability,interface,interface,29071," GetOnFileClassVersion() const; {return fOnFileClassVersion;}. Int_t GetType(Int_t id) const; {return fComp[id].fType;}. Double_t GetValue(char* pointer, Int_t i, Int_t j, Int_t len) const; { return GetTypedValue<Double_t>(pointer, i, j, len); }. Double_t GetValueClones(TClonesArray* clones, Int_t i, Int_t j, Int_t k, Int_t eoffset) const; { return GetTypedValueClones<Double_t>(clones, i, j, k, eoffset); }. Double_t GetValueSTL(TVirtualCollectionProxy* cont, Int_t i, Int_t j, Int_t k, Int_t eoffset) const; { return GetTypedValueSTL<Double_t>(cont, i, j, k, eoffset); }. Double_t GetValueSTLP(TVirtualCollectionProxy* cont, Int_t i, Int_t j, Int_t k, Int_t eoffset) const; { return GetTypedValueSTLP<Double_t>(cont, i, j, k, eoffset); }. TVirtualStreamerInfo * NewInfo(TClass* cl); {return new TStreamerInfo(cl);}. Int_t ReadBufferClones(TBuffer& b, TClonesArray* clones, Int_t nc, Int_t first, Int_t eoffset). Int_t ReadBufferSTL(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc, Int_t eoffset, Bool_t v7 = kTRUE). void SetCheckSum(UInt_t checksum); {fCheckSum = checksum;}. void SetClass(TClass* cl); {fClass = cl;}. void SetClassVersion(Int_t vers); {fClassVersion=vers;}. void SetOnFileClassVersion(Int_t vers); {fOnFileClassVersion=vers;}. Int_t WriteBuffer(TBuffer& b, char* pointer, Int_t first); Try to remove those functions from the public interface. Int_t WriteBufferClones(TBuffer& b, TClonesArray* clones, Int_t nc, Int_t first, Int_t eoffset). Int_t WriteBufferSTL(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc). Int_t WriteBufferSTLPtrs(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc, Int_t first, Int_t eoffset). TStreamerElement * GetCurrentElement(). » Author: Rene Brun 12/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-07-31 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html
https://root.cern/root/html534/TStreamerInfo.html:23933,Modifiability,variab,variable,23933,"ized elements in the list of compiled elements. void* New(void* obj = 0); An emulated object is created at address obj, if obj is null we; allocate memory for the object. void* NewArray(Long_t nElements, void* ary = 0); An array of emulated objects is created at address ary, if ary is null,; we allocate memory for the array. void DestructorImpl(void* p, Bool_t dtorOnly); Internal part of the destructor.; Destruct each of the datamembers in the same order; as the implicit destructor would. void Destructor(void* p, Bool_t dtorOnly = kFALSE); Emulated destructor for this class.; An emulated object is destroyed at address p.; Destruct each of the datamembers in the same order; as the implicit destructor would. void DeleteArray(void* p, Bool_t dtorOnly = kFALSE); Destroy an array of emulated objects, with optional delete. void PrintValue(const char* name, char* pointer, Int_t i, Int_t len, Int_t lenmax = 1000) const; print value of element i in object at pointer; The function may be called in two ways:; -method1 len < 0; i is assumed to be the TStreamerElement number i in StreamerInfo; -method2 len >= 0; i is the type; address of variable is directly pointer.; len is the number of elements to be printed starting at pointer. void PrintValueClones(const char* name, TClonesArray* clones, Int_t i, Int_t eoffset, Int_t lenmax = 1000) const; print value of element i in a TClonesArray. void PrintValueSTL(const char* name, TVirtualCollectionProxy* cont, Int_t i, Int_t eoffset, Int_t lenmax = 1000) const; print value of element i in a TClonesArray. void Streamer(TBuffer& ); Stream an object of class TStreamerInfo. void TagFile(TFile* fFile); Mark the classindex of the current file as using this TStreamerInfo; This function is deprecated and its functionality is now done by; the overloads of TBuffer::TagStreamerInfo. void PrintValueAux(char* ladd, Int_t atype, TStreamerElement* aElement, Int_t aleng, Int_t* count); print value of element in object at pointer, type atype, leng alen",MatchSource.WIKI,root/html534/TStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html
https://root.cern/root/html534/TStreamerInfo.html:24973,Modifiability,variab,variable,24973," len < 0; i is assumed to be the TStreamerElement number i in StreamerInfo; -method2 len >= 0; i is the type; address of variable is directly pointer.; len is the number of elements to be printed starting at pointer. void PrintValueClones(const char* name, TClonesArray* clones, Int_t i, Int_t eoffset, Int_t lenmax = 1000) const; print value of element i in a TClonesArray. void PrintValueSTL(const char* name, TVirtualCollectionProxy* cont, Int_t i, Int_t eoffset, Int_t lenmax = 1000) const; print value of element i in a TClonesArray. void Streamer(TBuffer& ); Stream an object of class TStreamerInfo. void TagFile(TFile* fFile); Mark the classindex of the current file as using this TStreamerInfo; This function is deprecated and its functionality is now done by; the overloads of TBuffer::TagStreamerInfo. void PrintValueAux(char* ladd, Int_t atype, TStreamerElement* aElement, Int_t aleng, Int_t* count); print value of element in object at pointer, type atype, leng aleng or *count; The function may be called in two ways:; -method1 len < 0; i is assumed to be the TStreamerElement number i in StreamerInfo; -method2 len >= 0; i is the type; address of variable is directly pointer.; len is the number of elements to be printed starting at pointer. void Update(const TClass* oldClass, TClass* newClass); function called by the TClass constructor when replacing an emulated class; by the real class. GenEmulatedProxy(const char* class_name, Bool_t silent); Generate emulated collection proxy for a given class. GenEmulatedClassStreamer(const char* class_name, Bool_t silent); Generate emulated class streamer for a given collection class. GenExplicitProxy(const ROOT::TCollectionProxyInfo& info, TClass* cl); Generate proxy from static functions. GenExplicitClassStreamer(const ROOT::TCollectionProxyInfo& info, TClass* cl); Generate class streamer from static functions. TStreamerInfo(const TStreamerInfo& ). TStreamerInfo& operator=(const TStreamerInfo& ). void AddReadAction(TStreamerInfoAct",MatchSource.WIKI,root/html534/TStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html
https://root.cern/root/html534/TStreamerInfo.html:13559,Performance,optimiz,optimization,13559,"Counter; kCharStar; kChar; kShort; kInt; kLong; kFloat; kDouble; kDouble32; kUChar; kUShort; kUInt; kULong; kBits; kLong64; kULong64; kBool; kFloat16; kObject; kAny; kObjectp; kObjectP; kTString; kTObject; kTNamed; kAnyp; kAnyP; kAnyPnoVT; kSTLp; kSkip; kSkipL; kSkipP; kConv; kConvL; kConvP; kSTL; kSTLstring; kStreamer; kStreamLoop; kCache; kArtificial; kCacheNew; kCacheDelete; kMissing; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTVirtualStreamerInfo::fIsCompiled! true if the StreamerInfo has been compiled (i.e. fully built, ready to use for streaming).; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; static Bool_tTVirtualStreamerInfo::fgCanDeleteTrue if ReadBuffer can delete object; static TVirtualStreamerInfo*TVirtualStreamerInfo::fgInfoFactory; static Bool_tTVirtualStreamerInfo::fgOptimizeTrue if optimization on; static Bool_tTVirtualStreamerInfo::fgStreamMemberWiseTrue if the collections are to be stream ""member-wise"" (when possible). private:. UInt_tfCheckSumchecksum of original class; TClass*fClass!pointer to class; Int_tfClassVersionClass version identifier; TStreamerInfo::TCompInfo*fComp![fNslots with less than fElements->GetEntries()*1.5 used] Compiled info; TStreamerInfo::TCompInfo**fCompFull![fElements->GetEntries()]; TStreamerInfo::TCompInfo**fCompOpt![fNdata]; TObjArray*fElementsArray of TStreamerElements; ULong_tfLiveCount! Number of outstanding pointer to this StreamerInfo.; Int_tfNVirtualInfoLoc! Number of virtual info location to update.; Int_tfNdata!number of optimized elements; Int_tfNfulldata!number of elements; Int_tfNslots!total numbrer of slots in fComp.; Int_tfNumber!Unique identifier; Version_tfOldVersion! Version of the TStreamerInfo object read from the file; Int_tfOnFileClassVersion!Cla",MatchSource.WIKI,root/html534/TStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html
https://root.cern/root/html534/TStreamerInfo.html:14250,Performance,optimiz,optimized,14250,"ngTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; static Bool_tTVirtualStreamerInfo::fgCanDeleteTrue if ReadBuffer can delete object; static TVirtualStreamerInfo*TVirtualStreamerInfo::fgInfoFactory; static Bool_tTVirtualStreamerInfo::fgOptimizeTrue if optimization on; static Bool_tTVirtualStreamerInfo::fgStreamMemberWiseTrue if the collections are to be stream ""member-wise"" (when possible). private:. UInt_tfCheckSumchecksum of original class; TClass*fClass!pointer to class; Int_tfClassVersionClass version identifier; TStreamerInfo::TCompInfo*fComp![fNslots with less than fElements->GetEntries()*1.5 used] Compiled info; TStreamerInfo::TCompInfo**fCompFull![fElements->GetEntries()]; TStreamerInfo::TCompInfo**fCompOpt![fNdata]; TObjArray*fElementsArray of TStreamerElements; ULong_tfLiveCount! Number of outstanding pointer to this StreamerInfo.; Int_tfNVirtualInfoLoc! Number of virtual info location to update.; Int_tfNdata!number of optimized elements; Int_tfNfulldata!number of elements; Int_tfNslots!total numbrer of slots in fComp.; Int_tfNumber!Unique identifier; Version_tfOldVersion! Version of the TStreamerInfo object read from the file; Int_tfOnFileClassVersion!Class version identifier as stored on file.; TStreamerInfoActions::TActionSequence*fReadMemberWise! List of read action resulting from the compilation for use in member wise streaming.; TStreamerInfoActions::TActionSequence*fReadMemberWiseVecPtr! List of read action resulting from the compilation for use in member wise streaming.; TStreamerInfoActions::TActionSequence*fReadObjectWise! List of read action resulting from the compilation.; Int_tfSize!size of the persistent class; ULong_t*fVirtualInfoLoc![fNVirtualInfoLoc] Location of the pointer to the TStreamerInfo inside the object (when emulated); TStreamerInfoActions::TActionSequence*fWriteMemberWise! List of write action resulting from the compilation for use in member wise streaming.; TStreamerInfoActions::TActionSequence*fWriteMemberWis",MatchSource.WIKI,root/html534/TStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html
https://root.cern/root/html534/TStreamerInfo.html:22785,Performance,optimiz,optimized,22785,"en=3, method=0; For I/O implementations (eg. XML) , one has to know the original name; of the data member. This function can be used to return a pointer; to the original TStreamerElement object corresponding to the j-th; element of a compressed array in fElems. parameters description:; - i: the serial number in array fElem; - j: the element number in the array of consecutive types; In the above example the class TAttLine has 3 consecutive data members; of the same type ""short"". Compile makes one single array of 3 elements.; To access the TStreamerElement for the second element; of this array, one can call:; TStreamerElement *el = GetStreamerElementReal(0,1);; const char* membername = el->GetName();; This function is typically called from TBuffer, TXmlBuffer. void InsertArtificialElements(const TObjArray* rules); Insert new members as expressed in the array of TSchemaRule(s). void ls(Option_t* option = """") const; List the TStreamerElement list and also the precomputed tables; if option contains the string ""incOrig"", also prints the original; (non-optimized elements in the list of compiled elements. void* New(void* obj = 0); An emulated object is created at address obj, if obj is null we; allocate memory for the object. void* NewArray(Long_t nElements, void* ary = 0); An array of emulated objects is created at address ary, if ary is null,; we allocate memory for the array. void DestructorImpl(void* p, Bool_t dtorOnly); Internal part of the destructor.; Destruct each of the datamembers in the same order; as the implicit destructor would. void Destructor(void* p, Bool_t dtorOnly = kFALSE); Emulated destructor for this class.; An emulated object is destroyed at address p.; Destruct each of the datamembers in the same order; as the implicit destructor would. void DeleteArray(void* p, Bool_t dtorOnly = kFALSE); Destroy an array of emulated objects, with optional delete. void PrintValue(const char* name, char* pointer, Int_t i, Int_t len, Int_t lenmax = 1000) const; print va",MatchSource.WIKI,root/html534/TStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html
https://root.cern/root/html534/TStreamerInfo.html:6828,Security,checksum,checksum,6828,"ionSequence*GetWriteMemberWiseActions(Bool_t forCollection); TStreamerInfoActions::TActionSequence*GetWriteObjectWiseActions(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tTVirtualStreamerInfo::IsBuilt() const; Bool_tTVirtualStreamerInfo::IsCompiled() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTVirtualStreamerInfo::IsOptimized() const; Int_tTVirtualStreamerInfo::IsRecovered() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidls(Option_t* option = """") const; Bool_tMatchLegacyCheckSum(UInt_t checksum) const; voidTObject::MayNotUse(const char* method) const; virtual void*New(void* obj = 0); virtual void*NewArray(Long_t nElements, void* ary = 0); virtual TVirtualStreamerInfo*NewInfo(TClass* cl); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); static voidTVirtualStreamerInfo::Optimize(Bool_t opt = kTRUE); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; voidPrintValue(const char* name, char* pointer, Int_t i, Int_t len, Int_",MatchSource.WIKI,root/html534/TStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html
https://root.cern/root/html534/TStreamerInfo.html:8757,Security,checksum,checksum,8757,"voidPrintValue(const char* name, char* pointer, Int_t i, Int_t len, Int_t lenmax = 1000) const; voidPrintValueClones(const char* name, TClonesArray* clones, Int_t i, Int_t eoffset, Int_t lenmax = 1000) const; voidPrintValueSTL(const char* name, TVirtualCollectionProxy* cont, Int_t i, Int_t eoffset, Int_t lenmax = 1000) const; virtual Int_tTObject::Read(const char* name); Int_tReadBufferClones(TBuffer& b, TClonesArray* clones, Int_t nc, Int_t first, Int_t eoffset); Int_tReadBufferSTL(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc, Int_t eoffset, Bool_t v7 = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidTVirtualStreamerInfo::SetCanDelete(Bool_t opt = kTRUE); virtual voidSetCheckSum(UInt_t checksum); virtual voidSetClass(TClass* cl); virtual voidSetClassVersion(Int_t vers); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidTVirtualStreamerInfo::SetFactory(TVirtualStreamerInfo* factory); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidSetOnFileClassVersion(Int_t vers); static Bool_tTVirtualStreamerInfo::SetStreamMemberWise(Bool_t enable = kTRUE); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidTagFile(TFile* fFile); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::Te",MatchSource.WIKI,root/html534/TStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html
https://root.cern/root/html534/TStreamerInfo.html:18368,Security,checksum,checksum,18368,"o(TFile* file, Bool_t force = kFALSE); -- Recursively mark streamer infos for writing to a file. Will force this TStreamerInfo to the file and also; all the dependencies. If argument force > 0 the loop on class dependencies is forced. This function is called when streaming a class that contains; a null pointer. In this case, the TStreamerInfo for the class; with the null pointer must be written to the file and also all; the TStreamerInfo of all the classes referenced by the class. --; We must be given a file to write to. TClass * GetActualClass(const void* obj) const; Assuming that obj points to (the part of) an object that is of the; type described by this streamerInfo, return the actual type of the; object (i.e. the type described by this streamerInfo is a base class; of the actual type of the object.; This routine should only be called if the class decribed by this; StreamerInfo is 'emulated'. Bool_t MatchLegacyCheckSum(UInt_t checksum) const; Return true if the checksum passed as argument is one of the checksum; value produced by the older checksum calulcation algorithm. UInt_t GetCheckSum(TClass::ECheckSum code) const; Recalculate the checksum of this TStreamerInfo based on its code. The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The check sum is built from the names/types of base classes and; data members.; Original algorithm from Victor Perevovchikov (perev@bnl.gov). The valid range of code is determined by ECheckSum. kNoEnum: data members of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation. This is needed for backward compatibility. WARNING: this function must be kept in sync with TClass::GetCheckSum.; They are both used to handle backward compatibility and should both return the same values.; TStreamerInfo uses the infor",MatchSource.WIKI,root/html534/TStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html
https://root.cern/root/html534/TStreamerInfo.html:18404,Security,checksum,checksum,18404,"o(TFile* file, Bool_t force = kFALSE); -- Recursively mark streamer infos for writing to a file. Will force this TStreamerInfo to the file and also; all the dependencies. If argument force > 0 the loop on class dependencies is forced. This function is called when streaming a class that contains; a null pointer. In this case, the TStreamerInfo for the class; with the null pointer must be written to the file and also all; the TStreamerInfo of all the classes referenced by the class. --; We must be given a file to write to. TClass * GetActualClass(const void* obj) const; Assuming that obj points to (the part of) an object that is of the; type described by this streamerInfo, return the actual type of the; object (i.e. the type described by this streamerInfo is a base class; of the actual type of the object.; This routine should only be called if the class decribed by this; StreamerInfo is 'emulated'. Bool_t MatchLegacyCheckSum(UInt_t checksum) const; Return true if the checksum passed as argument is one of the checksum; value produced by the older checksum calulcation algorithm. UInt_t GetCheckSum(TClass::ECheckSum code) const; Recalculate the checksum of this TStreamerInfo based on its code. The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The check sum is built from the names/types of base classes and; data members.; Original algorithm from Victor Perevovchikov (perev@bnl.gov). The valid range of code is determined by ECheckSum. kNoEnum: data members of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation. This is needed for backward compatibility. WARNING: this function must be kept in sync with TClass::GetCheckSum.; They are both used to handle backward compatibility and should both return the same values.; TStreamerInfo uses the infor",MatchSource.WIKI,root/html534/TStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html
https://root.cern/root/html534/TStreamerInfo.html:18446,Security,checksum,checksum,18446,"o(TFile* file, Bool_t force = kFALSE); -- Recursively mark streamer infos for writing to a file. Will force this TStreamerInfo to the file and also; all the dependencies. If argument force > 0 the loop on class dependencies is forced. This function is called when streaming a class that contains; a null pointer. In this case, the TStreamerInfo for the class; with the null pointer must be written to the file and also all; the TStreamerInfo of all the classes referenced by the class. --; We must be given a file to write to. TClass * GetActualClass(const void* obj) const; Assuming that obj points to (the part of) an object that is of the; type described by this streamerInfo, return the actual type of the; object (i.e. the type described by this streamerInfo is a base class; of the actual type of the object.; This routine should only be called if the class decribed by this; StreamerInfo is 'emulated'. Bool_t MatchLegacyCheckSum(UInt_t checksum) const; Return true if the checksum passed as argument is one of the checksum; value produced by the older checksum calulcation algorithm. UInt_t GetCheckSum(TClass::ECheckSum code) const; Recalculate the checksum of this TStreamerInfo based on its code. The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The check sum is built from the names/types of base classes and; data members.; Original algorithm from Victor Perevovchikov (perev@bnl.gov). The valid range of code is determined by ECheckSum. kNoEnum: data members of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation. This is needed for backward compatibility. WARNING: this function must be kept in sync with TClass::GetCheckSum.; They are both used to handle backward compatibility and should both return the same values.; TStreamerInfo uses the infor",MatchSource.WIKI,root/html534/TStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html
https://root.cern/root/html534/TStreamerInfo.html:18484,Security,checksum,checksum,18484,"o(TFile* file, Bool_t force = kFALSE); -- Recursively mark streamer infos for writing to a file. Will force this TStreamerInfo to the file and also; all the dependencies. If argument force > 0 the loop on class dependencies is forced. This function is called when streaming a class that contains; a null pointer. In this case, the TStreamerInfo for the class; with the null pointer must be written to the file and also all; the TStreamerInfo of all the classes referenced by the class. --; We must be given a file to write to. TClass * GetActualClass(const void* obj) const; Assuming that obj points to (the part of) an object that is of the; type described by this streamerInfo, return the actual type of the; object (i.e. the type described by this streamerInfo is a base class; of the actual type of the object.; This routine should only be called if the class decribed by this; StreamerInfo is 'emulated'. Bool_t MatchLegacyCheckSum(UInt_t checksum) const; Return true if the checksum passed as argument is one of the checksum; value produced by the older checksum calulcation algorithm. UInt_t GetCheckSum(TClass::ECheckSum code) const; Recalculate the checksum of this TStreamerInfo based on its code. The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The check sum is built from the names/types of base classes and; data members.; Original algorithm from Victor Perevovchikov (perev@bnl.gov). The valid range of code is determined by ECheckSum. kNoEnum: data members of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation. This is needed for backward compatibility. WARNING: this function must be kept in sync with TClass::GetCheckSum.; They are both used to handle backward compatibility and should both return the same values.; TStreamerInfo uses the infor",MatchSource.WIKI,root/html534/TStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html
https://root.cern/root/html534/TStreamerInfo.html:18582,Security,checksum,checksum,18582,"all the dependencies. If argument force > 0 the loop on class dependencies is forced. This function is called when streaming a class that contains; a null pointer. In this case, the TStreamerInfo for the class; with the null pointer must be written to the file and also all; the TStreamerInfo of all the classes referenced by the class. --; We must be given a file to write to. TClass * GetActualClass(const void* obj) const; Assuming that obj points to (the part of) an object that is of the; type described by this streamerInfo, return the actual type of the; object (i.e. the type described by this streamerInfo is a base class; of the actual type of the object.; This routine should only be called if the class decribed by this; StreamerInfo is 'emulated'. Bool_t MatchLegacyCheckSum(UInt_t checksum) const; Return true if the checksum passed as argument is one of the checksum; value produced by the older checksum calulcation algorithm. UInt_t GetCheckSum(TClass::ECheckSum code) const; Recalculate the checksum of this TStreamerInfo based on its code. The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The check sum is built from the names/types of base classes and; data members.; Original algorithm from Victor Perevovchikov (perev@bnl.gov). The valid range of code is determined by ECheckSum. kNoEnum: data members of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation. This is needed for backward compatibility. WARNING: this function must be kept in sync with TClass::GetCheckSum.; They are both used to handle backward compatibility and should both return the same values.; TStreamerInfo uses the information in TStreamerElement while TClass uses the information; from TClass::GetListOfBases and TClass::GetListOfDataMembers. void GenerateDeclaration(",MatchSource.WIKI,root/html534/TStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html
https://root.cern/root/html534/TStreamerInfo.html:18995,Security,checksum,checksum,18995," part of) an object that is of the; type described by this streamerInfo, return the actual type of the; object (i.e. the type described by this streamerInfo is a base class; of the actual type of the object.; This routine should only be called if the class decribed by this; StreamerInfo is 'emulated'. Bool_t MatchLegacyCheckSum(UInt_t checksum) const; Return true if the checksum passed as argument is one of the checksum; value produced by the older checksum calulcation algorithm. UInt_t GetCheckSum(TClass::ECheckSum code) const; Recalculate the checksum of this TStreamerInfo based on its code. The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The check sum is built from the names/types of base classes and; data members.; Original algorithm from Victor Perevovchikov (perev@bnl.gov). The valid range of code is determined by ECheckSum. kNoEnum: data members of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation. This is needed for backward compatibility. WARNING: this function must be kept in sync with TClass::GetCheckSum.; They are both used to handle backward compatibility and should both return the same values.; TStreamerInfo uses the information in TStreamerElement while TClass uses the information; from TClass::GetListOfBases and TClass::GetListOfDataMembers. void GenerateDeclaration(FILE* fp, FILE* sfp, const TList* subClasses, Bool_t top = kTRUE); Write the Declaration of class. UInt_t GenerateIncludes(FILE* fp, char* inclist, const TList* extrainfos); Add to the header file, the #include need for this class. Int_t GenerateHeaderFile(const char* dirname, const TList* subClasses = 0, const TList* extrainfos = 0); Generate header file for the class described by this TStreamerInfo; the function is called by TFile::MakeProject for each ",MatchSource.WIKI,root/html534/TStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html
https://root.cern/root/html534/TStreamerInfo.html:19026,Security,checksum,checksum,19026," part of) an object that is of the; type described by this streamerInfo, return the actual type of the; object (i.e. the type described by this streamerInfo is a base class; of the actual type of the object.; This routine should only be called if the class decribed by this; StreamerInfo is 'emulated'. Bool_t MatchLegacyCheckSum(UInt_t checksum) const; Return true if the checksum passed as argument is one of the checksum; value produced by the older checksum calulcation algorithm. UInt_t GetCheckSum(TClass::ECheckSum code) const; Recalculate the checksum of this TStreamerInfo based on its code. The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The check sum is built from the names/types of base classes and; data members.; Original algorithm from Victor Perevovchikov (perev@bnl.gov). The valid range of code is determined by ECheckSum. kNoEnum: data members of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation. This is needed for backward compatibility. WARNING: this function must be kept in sync with TClass::GetCheckSum.; They are both used to handle backward compatibility and should both return the same values.; TStreamerInfo uses the information in TStreamerElement while TClass uses the information; from TClass::GetListOfBases and TClass::GetListOfDataMembers. void GenerateDeclaration(FILE* fp, FILE* sfp, const TList* subClasses, Bool_t top = kTRUE); Write the Declaration of class. UInt_t GenerateIncludes(FILE* fp, char* inclist, const TList* extrainfos); Add to the header file, the #include need for this class. Int_t GenerateHeaderFile(const char* dirname, const TList* subClasses = 0, const TList* extrainfos = 0); Generate header file for the class described by this TStreamerInfo; the function is called by TFile::MakeProject for each ",MatchSource.WIKI,root/html534/TStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html
https://root.cern/root/html534/TStreamerInfo.html:22256,Security,access,access,22256,"e single element in fElems. example with the class TAttLine; TClass::GetClass(""TAttLine"")->GetStreamerInfo()->ls(); produces;; StreamerInfo for class: TAttLine, version=1; short fLineColor offset= 4 type= 2 line color; short fLineStyle offset= 6 type= 2 line style; short fLineWidth offset= 8 type= 2 line width; i= 0, fLineColor type= 22, offset= 4, len=3, method=0; For I/O implementations (eg. XML) , one has to know the original name; of the data member. This function can be used to return a pointer; to the original TStreamerElement object corresponding to the j-th; element of a compressed array in fElems. parameters description:; - i: the serial number in array fElem; - j: the element number in the array of consecutive types; In the above example the class TAttLine has 3 consecutive data members; of the same type ""short"". Compile makes one single array of 3 elements.; To access the TStreamerElement for the second element; of this array, one can call:; TStreamerElement *el = GetStreamerElementReal(0,1);; const char* membername = el->GetName();; This function is typically called from TBuffer, TXmlBuffer. void InsertArtificialElements(const TObjArray* rules); Insert new members as expressed in the array of TSchemaRule(s). void ls(Option_t* option = """") const; List the TStreamerElement list and also the precomputed tables; if option contains the string ""incOrig"", also prints the original; (non-optimized elements in the list of compiled elements. void* New(void* obj = 0); An emulated object is created at address obj, if obj is null we; allocate memory for the object. void* NewArray(Long_t nElements, void* ary = 0); An array of emulated objects is created at address ary, if ary is null,; we allocate memory for the array. void DestructorImpl(void* p, Bool_t dtorOnly); Internal part of the destructor.; Destruct each of the datamembers in the same order; as the implicit destructor would. void Destructor(void* p, Bool_t dtorOnly = kFALSE); Emulated destructor for this class.",MatchSource.WIKI,root/html534/TStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html
https://root.cern/root/html534/TStreamerInfo.html:28761,Security,checksum,checksum,28761," GetOnFileClassVersion() const; {return fOnFileClassVersion;}. Int_t GetType(Int_t id) const; {return fComp[id].fType;}. Double_t GetValue(char* pointer, Int_t i, Int_t j, Int_t len) const; { return GetTypedValue<Double_t>(pointer, i, j, len); }. Double_t GetValueClones(TClonesArray* clones, Int_t i, Int_t j, Int_t k, Int_t eoffset) const; { return GetTypedValueClones<Double_t>(clones, i, j, k, eoffset); }. Double_t GetValueSTL(TVirtualCollectionProxy* cont, Int_t i, Int_t j, Int_t k, Int_t eoffset) const; { return GetTypedValueSTL<Double_t>(cont, i, j, k, eoffset); }. Double_t GetValueSTLP(TVirtualCollectionProxy* cont, Int_t i, Int_t j, Int_t k, Int_t eoffset) const; { return GetTypedValueSTLP<Double_t>(cont, i, j, k, eoffset); }. TVirtualStreamerInfo * NewInfo(TClass* cl); {return new TStreamerInfo(cl);}. Int_t ReadBufferClones(TBuffer& b, TClonesArray* clones, Int_t nc, Int_t first, Int_t eoffset). Int_t ReadBufferSTL(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc, Int_t eoffset, Bool_t v7 = kTRUE). void SetCheckSum(UInt_t checksum); {fCheckSum = checksum;}. void SetClass(TClass* cl); {fClass = cl;}. void SetClassVersion(Int_t vers); {fClassVersion=vers;}. void SetOnFileClassVersion(Int_t vers); {fOnFileClassVersion=vers;}. Int_t WriteBuffer(TBuffer& b, char* pointer, Int_t first); Try to remove those functions from the public interface. Int_t WriteBufferClones(TBuffer& b, TClonesArray* clones, Int_t nc, Int_t first, Int_t eoffset). Int_t WriteBufferSTL(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc). Int_t WriteBufferSTLPtrs(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc, Int_t first, Int_t eoffset). TStreamerElement * GetCurrentElement(). » Author: Rene Brun 12/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-07-31 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html
https://root.cern/root/html534/TStreamerInfo.html:28785,Security,checksum,checksum,28785," GetOnFileClassVersion() const; {return fOnFileClassVersion;}. Int_t GetType(Int_t id) const; {return fComp[id].fType;}. Double_t GetValue(char* pointer, Int_t i, Int_t j, Int_t len) const; { return GetTypedValue<Double_t>(pointer, i, j, len); }. Double_t GetValueClones(TClonesArray* clones, Int_t i, Int_t j, Int_t k, Int_t eoffset) const; { return GetTypedValueClones<Double_t>(clones, i, j, k, eoffset); }. Double_t GetValueSTL(TVirtualCollectionProxy* cont, Int_t i, Int_t j, Int_t k, Int_t eoffset) const; { return GetTypedValueSTL<Double_t>(cont, i, j, k, eoffset); }. Double_t GetValueSTLP(TVirtualCollectionProxy* cont, Int_t i, Int_t j, Int_t k, Int_t eoffset) const; { return GetTypedValueSTLP<Double_t>(cont, i, j, k, eoffset); }. TVirtualStreamerInfo * NewInfo(TClass* cl); {return new TStreamerInfo(cl);}. Int_t ReadBufferClones(TBuffer& b, TClonesArray* clones, Int_t nc, Int_t first, Int_t eoffset). Int_t ReadBufferSTL(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc, Int_t eoffset, Bool_t v7 = kTRUE). void SetCheckSum(UInt_t checksum); {fCheckSum = checksum;}. void SetClass(TClass* cl); {fClass = cl;}. void SetClassVersion(Int_t vers); {fClassVersion=vers;}. void SetOnFileClassVersion(Int_t vers); {fOnFileClassVersion=vers;}. Int_t WriteBuffer(TBuffer& b, char* pointer, Int_t first); Try to remove those functions from the public interface. Int_t WriteBufferClones(TBuffer& b, TClonesArray* clones, Int_t nc, Int_t first, Int_t eoffset). Int_t WriteBufferSTL(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc). Int_t WriteBufferSTLPtrs(TBuffer& b, TVirtualCollectionProxy* cont, Int_t nc, Int_t first, Int_t eoffset). TStreamerElement * GetCurrentElement(). » Author: Rene Brun 12/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-07-31 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TStreamerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html
https://root.cern/root/html534/TStreamerInfoActions__TActionSequence.html:1847,Availability,error,error,1847,"tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; TStreamerInfoActions::TActionSequence*CreateCopy(); static TStreamerInfoActions::TActionSequence*CreateReadMemberWiseActions(TVirtualStreamerInfo* info, TVirtualCollectionProxy& proxy); TStreamerInfoActions::TActionSequence*CreateSubSequence(const vector<Int_t>& element_ids, size_t offset); static TStreamerInfoActions::TActionSequence*CreateWriteMemberWiseActions(TVirtualStreamerInfo* info, TVirtualCollectionProxy& proxy); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html534/TStreamerInfoActions__TActionSequence.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfoActions__TActionSequence.html
https://root.cern/root/html534/TStreamerInfoActions__TActionSequence.html:1931,Availability,error,error,1931,"ct) const; TStreamerInfoActions::TActionSequence*CreateCopy(); static TStreamerInfoActions::TActionSequence*CreateReadMemberWiseActions(TVirtualStreamerInfo* info, TVirtualCollectionProxy& proxy); TStreamerInfoActions::TActionSequence*CreateSubSequence(const vector<Int_t>& element_ids, size_t offset); static TStreamerInfoActions::TActionSequence*CreateWriteMemberWiseActions(TVirtualStreamerInfo* info, TVirtualCollectionProxy& proxy); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html534/TStreamerInfoActions__TActionSequence.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfoActions__TActionSequence.html
https://root.cern/root/html534/TStreamerInfoActions__TActionSequence.html:6081,Modifiability,config,configures,6081,"ata); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TStreamerInfoActions::TActionSequenceTActionSequence(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TStreamerInfoActions::ActionContainer_tfActions; TStreamerInfoActions::TLoopConfiguration*fLoopConfigIf this is a bundle of memberwise streaming action, this configures the looping; TVirtualStreamerInfo*fStreamerInfoStreamerInfo used to derive these actions. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void AddToOffset(Int_t delta). void Print(). TConfiguredAction & operator=(const TStreamerInfoActions::TActionSequence& ); WARNING: Technically this is a move assignment!. TActionSequence(); {}. TActionSequence(TVirtualStreamerInfo* info, UInt_t maxdata); { fActions.reserve(maxdata); }. ~TActionSequence(). void AddAction( action_t action, TConfiguration *conf ). TActionSequence * CreateCopy(). TActionSequence * CreateReadMemberWiseActions(TVirtualStreamerInfo* info, TVirtualCollectionProxy& proxy). TActionSequence * CreateWriteMemberWiseActions(TVirtualStreamerInfo* info, TVirtualCollectionProxy& proxy). TActionSequence * CreateSubSequence(const vector<Int_t>& element_ids, size_t offset). » Author: Philippe Canal 05/2010 » Copyright (C) 1995-2004, Rene Brun and Fons Ra",MatchSource.WIKI,root/html534/TStreamerInfoActions__TActionSequence.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfoActions__TActionSequence.html
https://root.cern/root/html534/TStreamerInfoActions__TConfiguredAction.html:1328,Availability,error,error,1328," virtual~TConfiguredAction(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::Get",MatchSource.WIKI,root/html534/TStreamerInfoActions__TConfiguredAction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfoActions__TConfiguredAction.html
https://root.cern/root/html534/TStreamerInfoActions__TConfiguredAction.html:1412,Availability,error,error,1412," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html534/TStreamerInfoActions__TConfiguredAction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfoActions__TConfiguredAction.html
https://root.cern/root/html534/TStreamerInfoActions__TConfiguredAction.html:6816,Deployability,configurat,configuration,6816,"; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TStreamerInfoActions::TStreamerInfoAction_tfAction; TStreamerInfoActions::TConfiguration*fConfiguration; TStreamerInfoActions::TStreamerInfoLoopAction_tfLoopAction; TStreamerInfoActions::TStreamerInfoVecPtrLoopAction_tfVecPtrLoopAction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void PrintDebug(TBuffer& buffer, void* object) const. TConfiguredAction(); assignment operator must be the default because the 'copy' constructor is actually a move constructor and must be used. {}. TConfiguredAction(const TStreamerInfoActions::TConfiguredAction& rval); WARNING: Technically this is a move constructor ... TConfiguredAction & operator=(const TStreamerInfoActions::TConfiguredAction& rval); WARNING: Technically this is a move assignment!. TConfiguredAction(TStreamerInfoActions::TStreamerInfoLoopAction_t action, TStreamerInfoActions::TConfiguration* conf); Usual constructor. ~TConfiguredAction(); Usual destructor.; Idea: the configuration ownership might be moved to a single list so that; we can shared them between the optimized and non-optimized list of actions. Int_t operator()(TBuffer& buffer, void* object) const. Int_t operator()(TBuffer& buffer, void* start_collection, const void* end_collection) const. Int_t operator()(TBuffer& buffer, void* start_collection, const void* end_collection, const TStreamerInfoActions::TLoopConfiguration* loopconf) const. » Author: Philippe Canal 05/2010 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TStreamerInfoActions__TConfiguredAction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfoActions__TConfiguredAction.html
https://root.cern/root/html534/TStreamerInfoActions__TConfiguredAction.html:6816,Modifiability,config,configuration,6816,"; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TStreamerInfoActions::TStreamerInfoAction_tfAction; TStreamerInfoActions::TConfiguration*fConfiguration; TStreamerInfoActions::TStreamerInfoLoopAction_tfLoopAction; TStreamerInfoActions::TStreamerInfoVecPtrLoopAction_tfVecPtrLoopAction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void PrintDebug(TBuffer& buffer, void* object) const. TConfiguredAction(); assignment operator must be the default because the 'copy' constructor is actually a move constructor and must be used. {}. TConfiguredAction(const TStreamerInfoActions::TConfiguredAction& rval); WARNING: Technically this is a move constructor ... TConfiguredAction & operator=(const TStreamerInfoActions::TConfiguredAction& rval); WARNING: Technically this is a move assignment!. TConfiguredAction(TStreamerInfoActions::TStreamerInfoLoopAction_t action, TStreamerInfoActions::TConfiguration* conf); Usual constructor. ~TConfiguredAction(); Usual destructor.; Idea: the configuration ownership might be moved to a single list so that; we can shared them between the optimized and non-optimized list of actions. Int_t operator()(TBuffer& buffer, void* object) const. Int_t operator()(TBuffer& buffer, void* start_collection, const void* end_collection) const. Int_t operator()(TBuffer& buffer, void* start_collection, const void* end_collection, const TStreamerInfoActions::TLoopConfiguration* loopconf) const. » Author: Philippe Canal 05/2010 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TStreamerInfoActions__TConfiguredAction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfoActions__TConfiguredAction.html
https://root.cern/root/html534/TStreamerInfoActions__TConfiguredAction.html:6912,Performance,optimiz,optimized,6912,"; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TStreamerInfoActions::TStreamerInfoAction_tfAction; TStreamerInfoActions::TConfiguration*fConfiguration; TStreamerInfoActions::TStreamerInfoLoopAction_tfLoopAction; TStreamerInfoActions::TStreamerInfoVecPtrLoopAction_tfVecPtrLoopAction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void PrintDebug(TBuffer& buffer, void* object) const. TConfiguredAction(); assignment operator must be the default because the 'copy' constructor is actually a move constructor and must be used. {}. TConfiguredAction(const TStreamerInfoActions::TConfiguredAction& rval); WARNING: Technically this is a move constructor ... TConfiguredAction & operator=(const TStreamerInfoActions::TConfiguredAction& rval); WARNING: Technically this is a move assignment!. TConfiguredAction(TStreamerInfoActions::TStreamerInfoLoopAction_t action, TStreamerInfoActions::TConfiguration* conf); Usual constructor. ~TConfiguredAction(); Usual destructor.; Idea: the configuration ownership might be moved to a single list so that; we can shared them between the optimized and non-optimized list of actions. Int_t operator()(TBuffer& buffer, void* object) const. Int_t operator()(TBuffer& buffer, void* start_collection, const void* end_collection) const. Int_t operator()(TBuffer& buffer, void* start_collection, const void* end_collection, const TStreamerInfoActions::TLoopConfiguration* loopconf) const. » Author: Philippe Canal 05/2010 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TStreamerInfoActions__TConfiguredAction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfoActions__TConfiguredAction.html
https://root.cern/root/html534/TStreamerInfoActions__TConfiguredAction.html:6930,Performance,optimiz,optimized,6930,"; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TStreamerInfoActions::TStreamerInfoAction_tfAction; TStreamerInfoActions::TConfiguration*fConfiguration; TStreamerInfoActions::TStreamerInfoLoopAction_tfLoopAction; TStreamerInfoActions::TStreamerInfoVecPtrLoopAction_tfVecPtrLoopAction. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void PrintDebug(TBuffer& buffer, void* object) const. TConfiguredAction(); assignment operator must be the default because the 'copy' constructor is actually a move constructor and must be used. {}. TConfiguredAction(const TStreamerInfoActions::TConfiguredAction& rval); WARNING: Technically this is a move constructor ... TConfiguredAction & operator=(const TStreamerInfoActions::TConfiguredAction& rval); WARNING: Technically this is a move assignment!. TConfiguredAction(TStreamerInfoActions::TStreamerInfoLoopAction_t action, TStreamerInfoActions::TConfiguration* conf); Usual constructor. ~TConfiguredAction(); Usual destructor.; Idea: the configuration ownership might be moved to a single list so that; we can shared them between the optimized and non-optimized list of actions. Int_t operator()(TBuffer& buffer, void* object) const. Int_t operator()(TBuffer& buffer, void* start_collection, const void* end_collection) const. Int_t operator()(TBuffer& buffer, void* start_collection, const void* end_collection, const TStreamerInfoActions::TLoopConfiguration* loopconf) const. » Author: Philippe Canal 05/2010 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id$ » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TStreamerInfoActions__TConfiguredAction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerInfoActions__TConfiguredAction.html
https://root.cern/root/html534/TStreamerLoop.html:1656,Availability,error,error,1656,"me); virtual~TStreamerLoop(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerElement::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; Int_tTStreamerElement::GetArrayLength() const; TClass*TStreamerElement::GetClass() const; virtual TClass*TStreamerElement::GetClassPointer() const; const char*GetCountClass() const; const char*GetCountName() const; Int_tGetCountVersion() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTStreamerElement::GetExecID() const; Double_tTStreamerElement::GetFactor() const; virtual const char*TStreamerElement::GetFullName() const; virtual const char*TObject::GetIconName() const; virtual const cha",MatchSource.WIKI,root/html534/TStreamerLoop.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerLoop.html
https://root.cern/root/html534/TStreamerLoop.html:1740,Availability,error,error,1740," virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerElement::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; Int_tTStreamerElement::GetArrayLength() const; TClass*TStreamerElement::GetClass() const; virtual TClass*TStreamerElement::GetClassPointer() const; const char*GetCountClass() const; const char*GetCountName() const; Int_tGetCountVersion() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTStreamerElement::GetExecID() const; Double_tTStreamerElement::GetFactor() const; virtual const char*TStreamerElement::GetFullName() const; virtual const char*TObject::GetIconName() const; virtual const char*GetInclude() const; Int_tTStreamerElement::GetMaxIndex(Int_t i) const; virtual ULo",MatchSource.WIKI,root/html534/TStreamerLoop.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerLoop.html
https://root.cern/root/html534/TStreamerLoop.html:9176,Modifiability,inherit,inherits,9176,"te; kDoNotDelete; kWholeObject; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tTStreamerElement::fArrayDimnumber of array dimensions; Int_tTStreamerElement::fArrayLengthcumulative size of all array dims; TClass*TStreamerElement::fClassObject!pointer to class of object; TStringfCountClassname of the class with the counter; TStringfCountNamename of data member holding the array count; Int_tfCountVersionversion number of the class with the counter; TStreamerBasicType*fCounter!pointer to basic type counter; Double_tTStreamerElement::fFactor!Conversion factor if a range is specified fFactor = (1<<nbits/(xmax-xmin); Int_tTStreamerElement::fMaxIndex[5]Maximum array index for array dimension ""dim""; TStringTNamed::fNameobject identifier; TClass*TStreamerElement::fNewClass!new element class when reading; Int_tTStreamerElement::fNewType!new element type when reading; Int_tTStreamerElement::fOffset!element offset in class; Int_tTStreamerElement::fSizesizeof element; TMemberStreamer*TStreamerElement::fStreamer!pointer to element Streamer; Int_tTStreamerElement::fTObjectOffset!base offset for TObject if the element inherits from it; TStringTNamed::fTitleobject title; Int_tTStreamerElement::fTypeelement type; TStringTStreamerElement::fTypeNameData type name of data member; Double_tTStreamerElement::fXmax!Maximum of data member if a range is specified [xmin,xmax,nbits]; Double_tTStreamerElement::fXmin!Minimum of data member if a range is specified [xmin,xmax,nbits]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStreamerLoop(); Default ctor. TStreamerLoop(const char* name, const char* title, Int_t offset, const char* countName, const char* countClass, Int_t version, const char* typeName); Create a TStreamerLoop obje",MatchSource.WIKI,root/html534/TStreamerLoop.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerLoop.html
https://root.cern/root/html534/TStreamerObject.html:1547,Availability,error,error,1547,"); virtual~TStreamerObject(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerElement::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; Int_tTStreamerElement::GetArrayLength() const; TClass*TStreamerElement::GetClass() const; virtual TClass*TStreamerElement::GetClassPointer() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTStreamerElement::GetExecID() const; Double_tTStreamerElement::GetFactor() const; virtual const char*TStreamerElement::GetFullName() const; virtual const char*TObject::GetIconName() const; virtual const char*GetInclude() const; Int_tTStreamerElement::GetMaxIndex(Int_t i) const; virtual ULong_tTStreamer",MatchSource.WIKI,root/html534/TStreamerObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerObject.html
https://root.cern/root/html534/TStreamerObject.html:1631,Availability,error,error,1631," virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerElement::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; Int_tTStreamerElement::GetArrayLength() const; TClass*TStreamerElement::GetClass() const; virtual TClass*TStreamerElement::GetClassPointer() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTStreamerElement::GetExecID() const; Double_tTStreamerElement::GetFactor() const; virtual const char*TStreamerElement::GetFullName() const; virtual const char*TObject::GetIconName() const; virtual const char*GetInclude() const; Int_tTStreamerElement::GetMaxIndex(Int_t i) const; virtual ULong_tTStreamerElement::GetMethod() const; virtual const char*TNamed::GetName() const; TClass*TStre",MatchSource.WIKI,root/html534/TStreamerObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerObject.html
https://root.cern/root/html534/TStreamerObject.html:384,Modifiability,inherit,inherits,384,". TStreamerObject. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TStreamerObject. class TStreamerObject: public TStreamerElement. TStreamerObject implements streaming of embedded objects whose type; inherits from TObject. Function Members (Methods); public:. TStreamerObject(); TStreamerObject(const char* name, const char* title, Int_t offset, const char* typeName); virtual~TStreamerObject(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerElement::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; I",MatchSource.WIKI,root/html534/TStreamerObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerObject.html
https://root.cern/root/html534/TStreamerObject.html:8684,Modifiability,inherit,inherits,8684,"imap; kSTLset; kSTLmultiset; kSTLbitset; };; enum TStreamerElement::[unnamed] { kHasRange; kCache; kRepeat; kRead; kWrite; kDoNotDelete; kWholeObject; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tTStreamerElement::fArrayDimnumber of array dimensions; Int_tTStreamerElement::fArrayLengthcumulative size of all array dims; TClass*TStreamerElement::fClassObject!pointer to class of object; Double_tTStreamerElement::fFactor!Conversion factor if a range is specified fFactor = (1<<nbits/(xmax-xmin); Int_tTStreamerElement::fMaxIndex[5]Maximum array index for array dimension ""dim""; TStringTNamed::fNameobject identifier; TClass*TStreamerElement::fNewClass!new element class when reading; Int_tTStreamerElement::fNewType!new element type when reading; Int_tTStreamerElement::fOffset!element offset in class; Int_tTStreamerElement::fSizesizeof element; TMemberStreamer*TStreamerElement::fStreamer!pointer to element Streamer; Int_tTStreamerElement::fTObjectOffset!base offset for TObject if the element inherits from it; TStringTNamed::fTitleobject title; Int_tTStreamerElement::fTypeelement type; TStringTStreamerElement::fTypeNameData type name of data member; Double_tTStreamerElement::fXmax!Maximum of data member if a range is specified [xmin,xmax,nbits]; Double_tTStreamerElement::fXmin!Minimum of data member if a range is specified [xmin,xmax,nbits]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStreamerObject(); Default ctor. TStreamerObject(const char* name, const char* title, Int_t offset, const char* typeName); Create a TStreamerObject object. ~TStreamerObject(); TStreamerObject dtor. void Init(TObject* obj = 0); Setup the element. const char * GetInclude() const; Return the proper include for this element. Int_",MatchSource.WIKI,root/html534/TStreamerObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerObject.html
https://root.cern/root/html534/TStreamerObjectAny.html:1561,Availability,error,error,1561,"virtual~TStreamerObjectAny(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerElement::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; Int_tTStreamerElement::GetArrayLength() const; TClass*TStreamerElement::GetClass() const; virtual TClass*TStreamerElement::GetClassPointer() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTStreamerElement::GetExecID() const; Double_tTStreamerElement::GetFactor() const; virtual const char*TStreamerElement::GetFullName() const; virtual const char*TObject::GetIconName() const; virtual const char*GetInclude() const; Int_tTStreamerElement::GetMaxIndex(Int_t i) const; virtual ULong_tTStreamer",MatchSource.WIKI,root/html534/TStreamerObjectAny.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerObjectAny.html
https://root.cern/root/html534/TStreamerObjectAny.html:1645,Availability,error,error,1645," virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerElement::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; Int_tTStreamerElement::GetArrayLength() const; TClass*TStreamerElement::GetClass() const; virtual TClass*TStreamerElement::GetClassPointer() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTStreamerElement::GetExecID() const; Double_tTStreamerElement::GetFactor() const; virtual const char*TStreamerElement::GetFullName() const; virtual const char*TObject::GetIconName() const; virtual const char*GetInclude() const; Int_tTStreamerElement::GetMaxIndex(Int_t i) const; virtual ULong_tTStreamerElement::GetMethod() const; virtual const char*TNamed::GetName() const; TClass*TStre",MatchSource.WIKI,root/html534/TStreamerObjectAny.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerObjectAny.html
https://root.cern/root/html534/TStreamerObjectAny.html:387,Modifiability,inherit,inheriting,387,". TStreamerObjectAny. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TStreamerObjectAny. class TStreamerObjectAny: public TStreamerElement. TStreamerObjectAny implement streaming of embedded object not; inheriting from TObject. Function Members (Methods); public:. TStreamerObjectAny(); TStreamerObjectAny(const char* name, const char* title, Int_t offset, const char* typeName); virtual~TStreamerObjectAny(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerElement::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArray",MatchSource.WIKI,root/html534/TStreamerObjectAny.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerObjectAny.html
https://root.cern/root/html534/TStreamerObjectAny.html:8710,Modifiability,inherit,inherits,8710,"imap; kSTLset; kSTLmultiset; kSTLbitset; };; enum TStreamerElement::[unnamed] { kHasRange; kCache; kRepeat; kRead; kWrite; kDoNotDelete; kWholeObject; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tTStreamerElement::fArrayDimnumber of array dimensions; Int_tTStreamerElement::fArrayLengthcumulative size of all array dims; TClass*TStreamerElement::fClassObject!pointer to class of object; Double_tTStreamerElement::fFactor!Conversion factor if a range is specified fFactor = (1<<nbits/(xmax-xmin); Int_tTStreamerElement::fMaxIndex[5]Maximum array index for array dimension ""dim""; TStringTNamed::fNameobject identifier; TClass*TStreamerElement::fNewClass!new element class when reading; Int_tTStreamerElement::fNewType!new element type when reading; Int_tTStreamerElement::fOffset!element offset in class; Int_tTStreamerElement::fSizesizeof element; TMemberStreamer*TStreamerElement::fStreamer!pointer to element Streamer; Int_tTStreamerElement::fTObjectOffset!base offset for TObject if the element inherits from it; TStringTNamed::fTitleobject title; Int_tTStreamerElement::fTypeelement type; TStringTStreamerElement::fTypeNameData type name of data member; Double_tTStreamerElement::fXmax!Maximum of data member if a range is specified [xmin,xmax,nbits]; Double_tTStreamerElement::fXmin!Minimum of data member if a range is specified [xmin,xmax,nbits]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStreamerObjectAny(); Default ctor. TStreamerObjectAny(const char* name, const char* title, Int_t offset, const char* typeName); Create a TStreamerObjectAny object. ~TStreamerObjectAny(); TStreamerObjectAny dtor. void Init(TObject* obj = 0); Setup the element. const char * GetInclude() const; Return the proper include for thi",MatchSource.WIKI,root/html534/TStreamerObjectAny.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerObjectAny.html
https://root.cern/root/html534/TStreamerObjectAnyPointer.html:1613,Availability,error,error,1613,"~TStreamerObjectAnyPointer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerElement::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; Int_tTStreamerElement::GetArrayLength() const; TClass*TStreamerElement::GetClass() const; virtual TClass*TStreamerElement::GetClassPointer() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTStreamerElement::GetExecID() const; Double_tTStreamerElement::GetFactor() const; virtual const char*TStreamerElement::GetFullName() const; virtual const char*TObject::GetIconName() const; virtual const char*GetInclude() const; Int_tTStreamerElement::GetMaxIndex(Int_t i) const; virtual ULong_tTStreamer",MatchSource.WIKI,root/html534/TStreamerObjectAnyPointer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerObjectAnyPointer.html
https://root.cern/root/html534/TStreamerObjectAnyPointer.html:1697,Availability,error,error,1697," virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerElement::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; Int_tTStreamerElement::GetArrayLength() const; TClass*TStreamerElement::GetClass() const; virtual TClass*TStreamerElement::GetClassPointer() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTStreamerElement::GetExecID() const; Double_tTStreamerElement::GetFactor() const; virtual const char*TStreamerElement::GetFullName() const; virtual const char*TObject::GetIconName() const; virtual const char*GetInclude() const; Int_tTStreamerElement::GetMaxIndex(Int_t i) const; virtual ULong_tTStreamerElement::GetMethod() const; virtual const char*TNamed::GetName() const; TClass*TStre",MatchSource.WIKI,root/html534/TStreamerObjectAnyPointer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerObjectAnyPointer.html
https://root.cern/root/html534/TStreamerObjectAnyPointer.html:418,Modifiability,inherit,inheriting,418,". TStreamerObjectAnyPointer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TStreamerObjectAnyPointer. class TStreamerObjectAnyPointer: public TStreamerElement. TStreamerObjectPointerAny implements streaming of pointer to object; not inheriting from TObject. Function Members (Methods); public:. TStreamerObjectAnyPointer(); TStreamerObjectAnyPointer(const char* name, const char* title, Int_t offset, const char* typeName); virtual~TStreamerObjectAnyPointer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerElement::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const ",MatchSource.WIKI,root/html534/TStreamerObjectAnyPointer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerObjectAnyPointer.html
https://root.cern/root/html534/TStreamerObjectAnyPointer.html:8754,Modifiability,inherit,inherits,8754,"imap; kSTLset; kSTLmultiset; kSTLbitset; };; enum TStreamerElement::[unnamed] { kHasRange; kCache; kRepeat; kRead; kWrite; kDoNotDelete; kWholeObject; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tTStreamerElement::fArrayDimnumber of array dimensions; Int_tTStreamerElement::fArrayLengthcumulative size of all array dims; TClass*TStreamerElement::fClassObject!pointer to class of object; Double_tTStreamerElement::fFactor!Conversion factor if a range is specified fFactor = (1<<nbits/(xmax-xmin); Int_tTStreamerElement::fMaxIndex[5]Maximum array index for array dimension ""dim""; TStringTNamed::fNameobject identifier; TClass*TStreamerElement::fNewClass!new element class when reading; Int_tTStreamerElement::fNewType!new element type when reading; Int_tTStreamerElement::fOffset!element offset in class; Int_tTStreamerElement::fSizesizeof element; TMemberStreamer*TStreamerElement::fStreamer!pointer to element Streamer; Int_tTStreamerElement::fTObjectOffset!base offset for TObject if the element inherits from it; TStringTNamed::fTitleobject title; Int_tTStreamerElement::fTypeelement type; TStringTStreamerElement::fTypeNameData type name of data member; Double_tTStreamerElement::fXmax!Maximum of data member if a range is specified [xmin,xmax,nbits]; Double_tTStreamerElement::fXmin!Minimum of data member if a range is specified [xmin,xmax,nbits]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStreamerObjectAnyPointer(); Default ctor. TStreamerObjectAnyPointer(const char* name, const char* title, Int_t offset, const char* typeName); Create a TStreamerObjectAnyPointer object. ~TStreamerObjectAnyPointer(); TStreamerObjectAnyPointer dtor. void Init(TObject* obj = 0); Setup the element. const char * GetInclude() const",MatchSource.WIKI,root/html534/TStreamerObjectAnyPointer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerObjectAnyPointer.html
https://root.cern/root/html534/TStreamerObjectPointer.html:1588,Availability,error,error,1588,"ual~TStreamerObjectPointer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerElement::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; Int_tTStreamerElement::GetArrayLength() const; TClass*TStreamerElement::GetClass() const; virtual TClass*TStreamerElement::GetClassPointer() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTStreamerElement::GetExecID() const; Double_tTStreamerElement::GetFactor() const; virtual const char*TStreamerElement::GetFullName() const; virtual const char*TObject::GetIconName() const; virtual const char*GetInclude() const; Int_tTStreamerElement::GetMaxIndex(Int_t i) const; virtual ULong_tTStreamer",MatchSource.WIKI,root/html534/TStreamerObjectPointer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerObjectPointer.html
https://root.cern/root/html534/TStreamerObjectPointer.html:1672,Availability,error,error,1672," virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerElement::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; Int_tTStreamerElement::GetArrayLength() const; TClass*TStreamerElement::GetClass() const; virtual TClass*TStreamerElement::GetClassPointer() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTStreamerElement::GetExecID() const; Double_tTStreamerElement::GetFactor() const; virtual const char*TStreamerElement::GetFullName() const; virtual const char*TObject::GetIconName() const; virtual const char*GetInclude() const; Int_tTStreamerElement::GetMaxIndex(Int_t i) const; virtual ULong_tTStreamerElement::GetMethod() const; virtual const char*TNamed::GetName() const; TClass*TStre",MatchSource.WIKI,root/html534/TStreamerObjectPointer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerObjectPointer.html
https://root.cern/root/html534/TStreamerObjectPointer.html:402,Modifiability,inherit,inheriting,402,". TStreamerObjectPointer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TStreamerObjectPointer. class TStreamerObjectPointer: public TStreamerElement. TStreamerObjectPointer implements streaming of pointer to object; inheriting from TObject. Function Members (Methods); public:. TStreamerObjectPointer(); TStreamerObjectPointer(const char* name, const char* title, Int_t offset, const char* typeName); virtual~TStreamerObjectPointer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerElement::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_",MatchSource.WIKI,root/html534/TStreamerObjectPointer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerObjectPointer.html
https://root.cern/root/html534/TStreamerObjectPointer.html:8717,Modifiability,inherit,inherits,8717,"imap; kSTLset; kSTLmultiset; kSTLbitset; };; enum TStreamerElement::[unnamed] { kHasRange; kCache; kRepeat; kRead; kWrite; kDoNotDelete; kWholeObject; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tTStreamerElement::fArrayDimnumber of array dimensions; Int_tTStreamerElement::fArrayLengthcumulative size of all array dims; TClass*TStreamerElement::fClassObject!pointer to class of object; Double_tTStreamerElement::fFactor!Conversion factor if a range is specified fFactor = (1<<nbits/(xmax-xmin); Int_tTStreamerElement::fMaxIndex[5]Maximum array index for array dimension ""dim""; TStringTNamed::fNameobject identifier; TClass*TStreamerElement::fNewClass!new element class when reading; Int_tTStreamerElement::fNewType!new element type when reading; Int_tTStreamerElement::fOffset!element offset in class; Int_tTStreamerElement::fSizesizeof element; TMemberStreamer*TStreamerElement::fStreamer!pointer to element Streamer; Int_tTStreamerElement::fTObjectOffset!base offset for TObject if the element inherits from it; TStringTNamed::fTitleobject title; Int_tTStreamerElement::fTypeelement type; TStringTStreamerElement::fTypeNameData type name of data member; Double_tTStreamerElement::fXmax!Maximum of data member if a range is specified [xmin,xmax,nbits]; Double_tTStreamerElement::fXmin!Minimum of data member if a range is specified [xmin,xmax,nbits]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStreamerObjectPointer(); Default ctor. TStreamerObjectPointer(const char* name, const char* title, Int_t offset, const char* typeName); Create a TStreamerObjectPointer object. ~TStreamerObjectPointer(); TStreamerObjectPointer dtor. void Init(TObject* obj = 0); Setup the element. const char * GetInclude() const; Return the pr",MatchSource.WIKI,root/html534/TStreamerObjectPointer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerObjectPointer.html
https://root.cern/root/html534/TStreamerSTL.html:1653,Availability,error,error,1653,"oxy, Bool_t dmPointer); virtual~TStreamerSTL(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tCannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; Int_tTStreamerElement::GetArrayLength() const; TClass*TStreamerElement::GetClass() const; virtual TClass*TStreamerElement::GetClassPointer() const; Int_tGetCtype() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTStreamerElement::GetExecID() const; Double_tTStreamerElement::GetFactor() const; virtual const char*TStreamerElement::GetFullName() const; virtual const char*TObject::GetIconName() const; virtual const char*GetInclude() const; Int_tTStreamerElement::GetMaxIndex(Int_t i) const; v",MatchSource.WIKI,root/html534/TStreamerSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerSTL.html
https://root.cern/root/html534/TStreamerSTL.html:1737,Availability,error,error,1737,"ar* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tCannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; Int_tTStreamerElement::GetArrayLength() const; TClass*TStreamerElement::GetClass() const; virtual TClass*TStreamerElement::GetClassPointer() const; Int_tGetCtype() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTStreamerElement::GetExecID() const; Double_tTStreamerElement::GetFactor() const; virtual const char*TStreamerElement::GetFullName() const; virtual const char*TObject::GetIconName() const; virtual const char*GetInclude() const; Int_tTStreamerElement::GetMaxIndex(Int_t i) const; virtual ULong_tTStreamerElement::GetMethod() const; virtual const char*TNamed::GetNam",MatchSource.WIKI,root/html534/TStreamerSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerSTL.html
https://root.cern/root/html534/TStreamerSTL.html:8904,Modifiability,inherit,inherits,8904,"Lbitset; };; enum TStreamerElement::[unnamed] { kHasRange; kCache; kRepeat; kRead; kWrite; kDoNotDelete; kWholeObject; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tTStreamerElement::fArrayDimnumber of array dimensions; Int_tTStreamerElement::fArrayLengthcumulative size of all array dims; TClass*TStreamerElement::fClassObject!pointer to class of object; Int_tfCtypeSTL contained type; Double_tTStreamerElement::fFactor!Conversion factor if a range is specified fFactor = (1<<nbits/(xmax-xmin); Int_tTStreamerElement::fMaxIndex[5]Maximum array index for array dimension ""dim""; TStringTNamed::fNameobject identifier; TClass*TStreamerElement::fNewClass!new element class when reading; Int_tTStreamerElement::fNewType!new element type when reading; Int_tTStreamerElement::fOffset!element offset in class; Int_tfSTLtypetype of STL vector; Int_tTStreamerElement::fSizesizeof element; TMemberStreamer*TStreamerElement::fStreamer!pointer to element Streamer; Int_tTStreamerElement::fTObjectOffset!base offset for TObject if the element inherits from it; TStringTNamed::fTitleobject title; Int_tTStreamerElement::fTypeelement type; TStringTStreamerElement::fTypeNameData type name of data member; Double_tTStreamerElement::fXmax!Maximum of data member if a range is specified [xmin,xmax,nbits]; Double_tTStreamerElement::fXmin!Minimum of data member if a range is specified [xmin,xmax,nbits]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStreamerSTL(); Default ctor. TStreamerSTL(const char* name, const char* title, Int_t offset, const char* typeName, const TVirtualCollectionProxy& proxy, Bool_t dmPointer); Create a TStreamerSTL object. TStreamerSTL(const char* name, const char* title, Int_t offset, const char* typeName, const ",MatchSource.WIKI,root/html534/TStreamerSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerSTL.html
https://root.cern/root/html534/TStreamerSTL.html:9817,Modifiability,variab,variable,9817,"reamer!pointer to element Streamer; Int_tTStreamerElement::fTObjectOffset!base offset for TObject if the element inherits from it; TStringTNamed::fTitleobject title; Int_tTStreamerElement::fTypeelement type; TStringTStreamerElement::fTypeNameData type name of data member; Double_tTStreamerElement::fXmax!Maximum of data member if a range is specified [xmin,xmax,nbits]; Double_tTStreamerElement::fXmin!Minimum of data member if a range is specified [xmin,xmax,nbits]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStreamerSTL(); Default ctor. TStreamerSTL(const char* name, const char* title, Int_t offset, const char* typeName, const TVirtualCollectionProxy& proxy, Bool_t dmPointer); Create a TStreamerSTL object. TStreamerSTL(const char* name, const char* title, Int_t offset, const char* typeName, const char* trueType, Bool_t dmPointer); Create a TStreamerSTL object. ~TStreamerSTL(); TStreamerSTL dtor. Bool_t CannotSplit() const; We can not split STL's which are inside a variable size array.; At least for now. Bool_t IsaPointer() const; Return true if the data member is a pointer. Bool_t IsBase() const; Return kTRUE if the element represent a base class. Int_t GetSize() const; Returns size of STL container in bytes. void ls(Option_t* option = """") const; Print the content of the element. const char * GetInclude() const; Return the proper include for this element. void SetStreamer(TMemberStreamer* streamer); Set pointer to Streamer function for this element; NOTE: we do not take ownership. void Streamer(TBuffer& ); Stream an object of class TStreamerSTL. TStreamerElement& operator=(const TStreamerSTL& ). TStreamerSTL(const TStreamerSTL& ). Int_t GetSTLtype() const; {return fSTLtype;}. Int_t GetCtype() const; {return fCtype;}. void SetSTLtype(Int_t t); {fSTLtype = t;}. void SetCtype(Int_t t); {fCtype = t;}. » Author: Rene Brun 12/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: e0",MatchSource.WIKI,root/html534/TStreamerSTL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerSTL.html
https://root.cern/root/html534/TStreamerSTLstring.html:1536,Availability,error,error,1536,"r); virtual~TStreamerSTLstring(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerSTL::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; Int_tTStreamerElement::GetArrayLength() const; TClass*TStreamerElement::GetClass() const; virtual TClass*TStreamerElement::GetClassPointer() const; Int_tTStreamerSTL::GetCtype() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTStreamerElement::GetExecID() const; Double_tTStreamerElement::GetFactor() const; virtual const char*TStreamerElement::GetFullName() const; virtual const char*TObject::GetIconName() const; virtual const char*GetInclude() const; Int_tTStreamerElement::GetMaxIndex(Int",MatchSource.WIKI,root/html534/TStreamerSTLstring.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerSTLstring.html
https://root.cern/root/html534/TStreamerSTLstring.html:1620,Availability,error,error,1620,"nst; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerSTL::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; Int_tTStreamerElement::GetArrayLength() const; TClass*TStreamerElement::GetClass() const; virtual TClass*TStreamerElement::GetClassPointer() const; Int_tTStreamerSTL::GetCtype() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTStreamerElement::GetExecID() const; Double_tTStreamerElement::GetFactor() const; virtual const char*TStreamerElement::GetFullName() const; virtual const char*TObject::GetIconName() const; virtual const char*GetInclude() const; Int_tTStreamerElement::GetMaxIndex(Int_t i) const; virtual ULong_tTStreamerElement::GetMethod() const; virtual const char*",MatchSource.WIKI,root/html534/TStreamerSTLstring.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerSTLstring.html
https://root.cern/root/html534/TStreamerSTLstring.html:8931,Modifiability,inherit,inherits,8931,"num TStreamerElement::[unnamed] { kHasRange; kCache; kRepeat; kRead; kWrite; kDoNotDelete; kWholeObject; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tTStreamerElement::fArrayDimnumber of array dimensions; Int_tTStreamerElement::fArrayLengthcumulative size of all array dims; TClass*TStreamerElement::fClassObject!pointer to class of object; Int_tTStreamerSTL::fCtypeSTL contained type; Double_tTStreamerElement::fFactor!Conversion factor if a range is specified fFactor = (1<<nbits/(xmax-xmin); Int_tTStreamerElement::fMaxIndex[5]Maximum array index for array dimension ""dim""; TStringTNamed::fNameobject identifier; TClass*TStreamerElement::fNewClass!new element class when reading; Int_tTStreamerElement::fNewType!new element type when reading; Int_tTStreamerElement::fOffset!element offset in class; Int_tTStreamerSTL::fSTLtypetype of STL vector; Int_tTStreamerElement::fSizesizeof element; TMemberStreamer*TStreamerElement::fStreamer!pointer to element Streamer; Int_tTStreamerElement::fTObjectOffset!base offset for TObject if the element inherits from it; TStringTNamed::fTitleobject title; Int_tTStreamerElement::fTypeelement type; TStringTStreamerElement::fTypeNameData type name of data member; Double_tTStreamerElement::fXmax!Maximum of data member if a range is specified [xmin,xmax,nbits]; Double_tTStreamerElement::fXmin!Minimum of data member if a range is specified [xmin,xmax,nbits]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStreamerSTLstring(); Default ctor. TStreamerSTLstring(const char* name, const char* title, Int_t offset, const char* typeName, Bool_t dmPointer); Create a TStreamerSTLstring object. ~TStreamerSTLstring(); TStreamerSTLstring dtor. const char * GetInclude() const; Return the proper",MatchSource.WIKI,root/html534/TStreamerSTLstring.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerSTLstring.html
https://root.cern/root/html534/TStreamerString.html:1481,Availability,error,error,1481,"); virtual~TStreamerString(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerElement::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; Int_tTStreamerElement::GetArrayLength() const; TClass*TStreamerElement::GetClass() const; virtual TClass*TStreamerElement::GetClassPointer() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTStreamerElement::GetExecID() const; Double_tTStreamerElement::GetFactor() const; virtual const char*TStreamerElement::GetFullName() const; virtual const char*TObject::GetIconName() const; virtual const char*GetInclude() const; Int_tTStreamerElement::GetMaxIndex(Int_t i) const; virtual ULong_tTStreamer",MatchSource.WIKI,root/html534/TStreamerString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerString.html
https://root.cern/root/html534/TStreamerString.html:1565,Availability,error,error,1565," virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerElement::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; Int_tTStreamerElement::GetArrayLength() const; TClass*TStreamerElement::GetClass() const; virtual TClass*TStreamerElement::GetClassPointer() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTStreamerElement::GetExecID() const; Double_tTStreamerElement::GetFactor() const; virtual const char*TStreamerElement::GetFullName() const; virtual const char*TObject::GetIconName() const; virtual const char*GetInclude() const; Int_tTStreamerElement::GetMaxIndex(Int_t i) const; virtual ULong_tTStreamerElement::GetMethod() const; virtual const char*TNamed::GetName() const; TClass*TStre",MatchSource.WIKI,root/html534/TStreamerString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerString.html
https://root.cern/root/html534/TStreamerString.html:8636,Modifiability,inherit,inherits,8636,"imap; kSTLset; kSTLmultiset; kSTLbitset; };; enum TStreamerElement::[unnamed] { kHasRange; kCache; kRepeat; kRead; kWrite; kDoNotDelete; kWholeObject; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tTStreamerElement::fArrayDimnumber of array dimensions; Int_tTStreamerElement::fArrayLengthcumulative size of all array dims; TClass*TStreamerElement::fClassObject!pointer to class of object; Double_tTStreamerElement::fFactor!Conversion factor if a range is specified fFactor = (1<<nbits/(xmax-xmin); Int_tTStreamerElement::fMaxIndex[5]Maximum array index for array dimension ""dim""; TStringTNamed::fNameobject identifier; TClass*TStreamerElement::fNewClass!new element class when reading; Int_tTStreamerElement::fNewType!new element type when reading; Int_tTStreamerElement::fOffset!element offset in class; Int_tTStreamerElement::fSizesizeof element; TMemberStreamer*TStreamerElement::fStreamer!pointer to element Streamer; Int_tTStreamerElement::fTObjectOffset!base offset for TObject if the element inherits from it; TStringTNamed::fTitleobject title; Int_tTStreamerElement::fTypeelement type; TStringTStreamerElement::fTypeNameData type name of data member; Double_tTStreamerElement::fXmax!Maximum of data member if a range is specified [xmin,xmax,nbits]; Double_tTStreamerElement::fXmin!Minimum of data member if a range is specified [xmin,xmax,nbits]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStreamerString(); Default ctor. TStreamerString(const char* name, const char* title, Int_t offset); Create a TStreamerString object. ~TStreamerString(); TStreamerString dtor. const char * GetInclude() const; Return the proper include for this element. Int_t GetSize() const; Returns size of anyclass in bytes. void Streamer(TB",MatchSource.WIKI,root/html534/TStreamerString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStreamerString.html
https://root.cern/root/html534/TString.html:18347,Availability,error,error,18347,"st; Return integer value of string.; Valid strings include only digits and whitespace (see IsDigit()),; i.e. ""123456"", ""123 456"" and ""1 2 3 4 56"" are all valid; integer strings whose Atoi() value is 123456. Long64_t Atoll() const; Return long long value of string.; Valid strings include only digits and whitespace (see IsDigit()),; i.e. ""123456"", ""123 456"" and ""1 2 3 4 56"" are all valid; integer strings whose Atoll() value is 123456. Double_t Atof() const; Return floating-point value contained in string.; Examples of valid strings are:; 64320; 64 320; 6 4 3 2 0; 6.4320 6,4320; 6.43e20 6.43E20 6,43e20; 6.43e-20 6.43E-20 6,43e-20. TString Itoa(Int_t value, Int_t base); Converts an Int_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; Usage: the following statement produce the same output, namely ""1111""; cout << TString::Itoa(15,2) ;; cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; In case of error returns the ""!"" string. TString UItoa(UInt_t value, Int_t base); Converts a UInt_t (twice the range of an Int_t) to a TString with respect; to the base specified (2-36). Thus it is an enhanced version of sprintf; (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString LLtoa(Long64_t value, Int_t base); Converts a Long64_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString ULLtoa(ULong64_t value, Int_t base); Converts a ULong64_t (twice the range of an Long64_t) to a TString with; respect to the base specified (2-36). Thus it is an enhanced version of; sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; I",MatchSource.WIKI,root/html534/TString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TString.html
https://root.cern/root/html534/TString.html:18655,Availability,error,error,18655," value is 123456. Double_t Atof() const; Return floating-point value contained in string.; Examples of valid strings are:; 64320; 64 320; 6 4 3 2 0; 6.4320 6,4320; 6.43e20 6.43E20 6,43e20; 6.43e-20 6.43E-20 6,43e-20. TString Itoa(Int_t value, Int_t base); Converts an Int_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; Usage: the following statement produce the same output, namely ""1111""; cout << TString::Itoa(15,2) ;; cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; In case of error returns the ""!"" string. TString UItoa(UInt_t value, Int_t base); Converts a UInt_t (twice the range of an Int_t) to a TString with respect; to the base specified (2-36). Thus it is an enhanced version of sprintf; (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString LLtoa(Long64_t value, Int_t base); Converts a Long64_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString ULLtoa(ULong64_t value, Int_t base); Converts a ULong64_t (twice the range of an Long64_t) to a TString with; respect to the base specified (2-36). Thus it is an enhanced version of; sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString BaseConvert(const TString& s_in, Int_t base_in, Int_t base_out); Converts string from base base_in to base base_out. Supported bases; are 2-36. At most 64 bit data can be converted. Bool_t EndsWith(const char* pat, TString::ECaseCompare cmp = kExact) const; Return true if string ends with the specified string. TObjArray * Tokenize(const TString& delim) const; This fun",MatchSource.WIKI,root/html534/TString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TString.html
https://root.cern/root/html534/TString.html:18937,Availability,error,error,18937,"ring with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; Usage: the following statement produce the same output, namely ""1111""; cout << TString::Itoa(15,2) ;; cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; In case of error returns the ""!"" string. TString UItoa(UInt_t value, Int_t base); Converts a UInt_t (twice the range of an Int_t) to a TString with respect; to the base specified (2-36). Thus it is an enhanced version of sprintf; (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString LLtoa(Long64_t value, Int_t base); Converts a Long64_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString ULLtoa(ULong64_t value, Int_t base); Converts a ULong64_t (twice the range of an Long64_t) to a TString with; respect to the base specified (2-36). Thus it is an enhanced version of; sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString BaseConvert(const TString& s_in, Int_t base_in, Int_t base_out); Converts string from base base_in to base base_out. Supported bases; are 2-36. At most 64 bit data can be converted. Bool_t EndsWith(const char* pat, TString::ECaseCompare cmp = kExact) const; Return true if string ends with the specified string. TObjArray * Tokenize(const TString& delim) const; This function is used to isolate sequential tokens in a TString.; These tokens are separated in the string by at least one of the; characters in delim. The returned array contains the tokens; as TObjString's. The returned array is the owner of the objects,; and must be deleted by the user.",MatchSource.WIKI,root/html534/TString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TString.html
https://root.cern/root/html534/TString.html:19255,Availability,error,error,19255,"o handle hex; cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; In case of error returns the ""!"" string. TString UItoa(UInt_t value, Int_t base); Converts a UInt_t (twice the range of an Int_t) to a TString with respect; to the base specified (2-36). Thus it is an enhanced version of sprintf; (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString LLtoa(Long64_t value, Int_t base); Converts a Long64_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString ULLtoa(ULong64_t value, Int_t base); Converts a ULong64_t (twice the range of an Long64_t) to a TString with; respect to the base specified (2-36). Thus it is an enhanced version of; sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString BaseConvert(const TString& s_in, Int_t base_in, Int_t base_out); Converts string from base base_in to base base_out. Supported bases; are 2-36. At most 64 bit data can be converted. Bool_t EndsWith(const char* pat, TString::ECaseCompare cmp = kExact) const; Return true if string ends with the specified string. TObjArray * Tokenize(const TString& delim) const; This function is used to isolate sequential tokens in a TString.; These tokens are separated in the string by at least one of the; characters in delim. The returned array contains the tokens; as TObjString's. The returned array is the owner of the objects,; and must be deleted by the user. void FormImp(const char* fmt, va_list ap); Formats a string using a printf style format descriptor.; Existing string contents will be overwritten. void Form(const char *va_(fmt), ...); Formats a string using a printf style format descriptor.; Existing string contents will be overwritten. TString Format(const char *v",MatchSource.WIKI,root/html534/TString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TString.html
https://root.cern/root/html534/TString.html:18037,Energy Efficiency,adapt,adapted,18037,"pressed in the base; specified (range=2-36), i.e. {0,1} for base 2, {0-9,a-f,A-F} for base 16,; {0-9,a-z,A-Z} for base 36. Returns false in case string length is 0 or; string contains other characters. Int_t Atoi() const; Return integer value of string.; Valid strings include only digits and whitespace (see IsDigit()),; i.e. ""123456"", ""123 456"" and ""1 2 3 4 56"" are all valid; integer strings whose Atoi() value is 123456. Long64_t Atoll() const; Return long long value of string.; Valid strings include only digits and whitespace (see IsDigit()),; i.e. ""123456"", ""123 456"" and ""1 2 3 4 56"" are all valid; integer strings whose Atoll() value is 123456. Double_t Atof() const; Return floating-point value contained in string.; Examples of valid strings are:; 64320; 64 320; 6 4 3 2 0; 6.4320 6,4320; 6.43e20 6.43E20 6,43e20; 6.43e-20 6.43E-20 6,43e-20. TString Itoa(Int_t value, Int_t base); Converts an Int_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; Usage: the following statement produce the same output, namely ""1111""; cout << TString::Itoa(15,2) ;; cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; In case of error returns the ""!"" string. TString UItoa(UInt_t value, Int_t base); Converts a UInt_t (twice the range of an Int_t) to a TString with respect; to the base specified (2-36). Thus it is an enhanced version of sprintf; (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString LLtoa(Long64_t value, Int_t base); Converts a Long64_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString ULLtoa(ULong64_t value, Int_t base); Converts a ULon",MatchSource.WIKI,root/html534/TString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TString.html
https://root.cern/root/html534/TString.html:18567,Energy Efficiency,adapt,adapted,18567,"ce (see IsDigit()),; i.e. ""123456"", ""123 456"" and ""1 2 3 4 56"" are all valid; integer strings whose Atoll() value is 123456. Double_t Atof() const; Return floating-point value contained in string.; Examples of valid strings are:; 64320; 64 320; 6 4 3 2 0; 6.4320 6,4320; 6.43e20 6.43E20 6,43e20; 6.43e-20 6.43E-20 6,43e-20. TString Itoa(Int_t value, Int_t base); Converts an Int_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; Usage: the following statement produce the same output, namely ""1111""; cout << TString::Itoa(15,2) ;; cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; In case of error returns the ""!"" string. TString UItoa(UInt_t value, Int_t base); Converts a UInt_t (twice the range of an Int_t) to a TString with respect; to the base specified (2-36). Thus it is an enhanced version of sprintf; (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString LLtoa(Long64_t value, Int_t base); Converts a Long64_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString ULLtoa(ULong64_t value, Int_t base); Converts a ULong64_t (twice the range of an Long64_t) to a TString with; respect to the base specified (2-36). Thus it is an enhanced version of; sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString BaseConvert(const TString& s_in, Int_t base_in, Int_t base_out); Converts string from base base_in to base base_out. Supported bases; are 2-36. At most 64 bit data can be converted. Bool_t EndsWith(const char* pat, TString::ECaseCompare cmp = kExact) const; Return",MatchSource.WIKI,root/html534/TString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TString.html
https://root.cern/root/html534/TString.html:18848,Energy Efficiency,adapt,adapted,18848,"43E20 6,43e20; 6.43e-20 6.43E-20 6,43e-20. TString Itoa(Int_t value, Int_t base); Converts an Int_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; Usage: the following statement produce the same output, namely ""1111""; cout << TString::Itoa(15,2) ;; cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; In case of error returns the ""!"" string. TString UItoa(UInt_t value, Int_t base); Converts a UInt_t (twice the range of an Int_t) to a TString with respect; to the base specified (2-36). Thus it is an enhanced version of sprintf; (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString LLtoa(Long64_t value, Int_t base); Converts a Long64_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString ULLtoa(ULong64_t value, Int_t base); Converts a ULong64_t (twice the range of an Long64_t) to a TString with; respect to the base specified (2-36). Thus it is an enhanced version of; sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString BaseConvert(const TString& s_in, Int_t base_in, Int_t base_out); Converts string from base base_in to base base_out. Supported bases; are 2-36. At most 64 bit data can be converted. Bool_t EndsWith(const char* pat, TString::ECaseCompare cmp = kExact) const; Return true if string ends with the specified string. TObjArray * Tokenize(const TString& delim) const; This function is used to isolate sequential tokens in a TString.; These tokens are separated in the string by at least one of the; characters in delim. The returned array contains the",MatchSource.WIKI,root/html534/TString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TString.html
https://root.cern/root/html534/TString.html:19167,Energy Efficiency,adapt,adapted,19167,"e same output, namely ""1111""; cout << TString::Itoa(15,2) ;; cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; In case of error returns the ""!"" string. TString UItoa(UInt_t value, Int_t base); Converts a UInt_t (twice the range of an Int_t) to a TString with respect; to the base specified (2-36). Thus it is an enhanced version of sprintf; (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString LLtoa(Long64_t value, Int_t base); Converts a Long64_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString ULLtoa(ULong64_t value, Int_t base); Converts a ULong64_t (twice the range of an Long64_t) to a TString with; respect to the base specified (2-36). Thus it is an enhanced version of; sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString BaseConvert(const TString& s_in, Int_t base_in, Int_t base_out); Converts string from base base_in to base base_out. Supported bases; are 2-36. At most 64 bit data can be converted. Bool_t EndsWith(const char* pat, TString::ECaseCompare cmp = kExact) const; Return true if string ends with the specified string. TObjArray * Tokenize(const TString& delim) const; This function is used to isolate sequential tokens in a TString.; These tokens are separated in the string by at least one of the; characters in delim. The returned array contains the tokens; as TObjString's. The returned array is the owner of the objects,; and must be deleted by the user. void FormImp(const char* fmt, va_list ap); Formats a string using a printf style format descriptor.; Existing string contents will be overwritten. void Form(const char *va_(fmt), ...); Formats a string using a p",MatchSource.WIKI,root/html534/TString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TString.html
https://root.cern/root/html534/TString.html:11652,Integrability,depend,depending,11652,"bytes (treated as unsigned char values,; so that `\200' is greater than `\0', for example). Zero-length; strings are always identical. Int_t CountChar(Int_t c) const; Return number of times character c occurs in the string. TString Copy() const; Copy a string. Ssiz_t First(char c) const; Find first occurrence of a character c. Ssiz_t First(const char* cs) const; Find first occurrence of a character in cs. UInt_t HashCase() const; Return a case-sensitive hash value (endian independent). UInt_t HashFoldCase() const; Return a case-insensitive hash value (endian independent). UInt_t Hash(TString::ECaseCompare cmp = kExact) const; Return hash value. UInt_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string. (static function); For string: i = TString::Hash(string,nstring);; For int: i = TString::Hash(&intword,sizeof(int));; For pointer: i = TString::Hash(&pointer,sizeof(void*));. This employs two different hash functions, depending on ntxt:; ntxt == sizeof(void*): a simple bitwise xor to get fast pointer hashes; else: MurmurHash3_x64_128 http://code.google.com/p/smhasher. Ssiz_t Index(const char* pat, Ssiz_t patlen, Ssiz_t i, TString::ECaseCompare cmp) const; Search for a string in the TString. Plen is the length of pattern,; startIndex is the index from which to start and cmp selects the type; of case-comparison. Ssiz_t Last(char c) const; Find last occurrence of a character c. TString MD5() const; Return the MD5 digest for this string, in a string representation. Bool_t MaybeRegexp() const; Returns true if string contains one of the regexp characters ""^$.[]*+?"". Bool_t MaybeWildcard() const; Returns true if string contains one of the wildcard characters ""[]*?"". TString& Prepend(char c, Ssiz_t rep = 1); Prepend character c rep times to string. TString & Replace(Ssiz_t pos, Ssiz_t n, const char* s, Ssiz_t ns); Remove at most n1 characters from self beginning at pos,; and replace them with the first n2 characters of cs. TString& ReplaceAll(const ",MatchSource.WIKI,root/html534/TString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TString.html
https://root.cern/root/html534/TString.html:26907,Integrability,interface,interface,26907,"ngSize(Ssiz_t s); { fRep.fLong.fSize = s; }. Ssiz_t GetLongSize() const; { return fRep.fLong.fSize; }. void SetSize(Ssiz_t s); { IsLong() ? SetLongSize(s) : SetShortSize(s); }. void SetLongCap(Ssiz_t s); { fRep.fLong.fCap = kLongMask | s; }. Ssiz_t GetLongCap() const; { return fRep.fLong.fCap & ~kLongMask; }. void SetLongPointer(char* p); { fRep.fLong.fData = p; }. char * GetLongPointer(); { return fRep.fLong.fData; }. const char * GetLongPointer() const; { return fRep.fLong.fData; }. char * GetShortPointer(); { return fRep.fShort.fData; }. const char * GetShortPointer() const; { return fRep.fShort.fData; }. char * GetPointer(); { return IsLong() ? GetLongPointer() : GetShortPointer(); }. const char * GetPointer() const; { return IsLong() ? GetLongPointer() : GetShortPointer(); }. Ssiz_t MaxSize(); { return kMaxInt - 1; }. void UnLink() const; { if (IsLong()) delete [] fRep.fLong.fData; }. void Zero(). TString * ReadString(TBuffer& b, const TClass* clReq). Bool_t Gets(FILE* fp, Bool_t chop = kTRUE); C I/O interface. void Puts(FILE* fp). operator const char*() const; Type conversion. { return GetPointer(); }. char & operator()(Ssiz_t i). char operator()(Ssiz_t i) const. Ssiz_t Capacity() const; { return (IsLong() ? GetLongCap() : kMinCap) - 1; }. Ssiz_t Index(const char* s, Ssiz_t i = 0, TString::ECaseCompare cmp = kExact) const. Ssiz_t Index(const char* pat, Ssiz_t patlen, Ssiz_t i, TString::ECaseCompare cmp) const. Ssiz_t Index(const TRegexp& pat, Ssiz_t i = 0) const. Ssiz_t Index(const TRegexp& pat, Ssiz_t* ext, Ssiz_t i = 0) const. Bool_t IsWhitespace() const; { return (Length() == CountChar(' ')); }. istream & ReadFile(istream& str). istream & ReadLine(istream& str, Bool_t skipWhite = kTRUE). istream & ReadToDelim(istream& str, char delim = '\n'). istream & ReadToken(istream& str). TObjArray * Tokenize(const TString& delim) const. » Author: Fons Rademakers 04/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last ",MatchSource.WIKI,root/html534/TString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TString.html
https://root.cern/root/html534/TString.html:18008,Modifiability,enhance,enhanced,18008,"pressed in the base; specified (range=2-36), i.e. {0,1} for base 2, {0-9,a-f,A-F} for base 16,; {0-9,a-z,A-Z} for base 36. Returns false in case string length is 0 or; string contains other characters. Int_t Atoi() const; Return integer value of string.; Valid strings include only digits and whitespace (see IsDigit()),; i.e. ""123456"", ""123 456"" and ""1 2 3 4 56"" are all valid; integer strings whose Atoi() value is 123456. Long64_t Atoll() const; Return long long value of string.; Valid strings include only digits and whitespace (see IsDigit()),; i.e. ""123456"", ""123 456"" and ""1 2 3 4 56"" are all valid; integer strings whose Atoll() value is 123456. Double_t Atof() const; Return floating-point value contained in string.; Examples of valid strings are:; 64320; 64 320; 6 4 3 2 0; 6.4320 6,4320; 6.43e20 6.43E20 6,43e20; 6.43e-20 6.43E-20 6,43e-20. TString Itoa(Int_t value, Int_t base); Converts an Int_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; Usage: the following statement produce the same output, namely ""1111""; cout << TString::Itoa(15,2) ;; cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; In case of error returns the ""!"" string. TString UItoa(UInt_t value, Int_t base); Converts a UInt_t (twice the range of an Int_t) to a TString with respect; to the base specified (2-36). Thus it is an enhanced version of sprintf; (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString LLtoa(Long64_t value, Int_t base); Converts a Long64_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString ULLtoa(ULong64_t value, Int_t base); Converts a ULon",MatchSource.WIKI,root/html534/TString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TString.html
https://root.cern/root/html534/TString.html:18037,Modifiability,adapt,adapted,18037,"pressed in the base; specified (range=2-36), i.e. {0,1} for base 2, {0-9,a-f,A-F} for base 16,; {0-9,a-z,A-Z} for base 36. Returns false in case string length is 0 or; string contains other characters. Int_t Atoi() const; Return integer value of string.; Valid strings include only digits and whitespace (see IsDigit()),; i.e. ""123456"", ""123 456"" and ""1 2 3 4 56"" are all valid; integer strings whose Atoi() value is 123456. Long64_t Atoll() const; Return long long value of string.; Valid strings include only digits and whitespace (see IsDigit()),; i.e. ""123456"", ""123 456"" and ""1 2 3 4 56"" are all valid; integer strings whose Atoll() value is 123456. Double_t Atof() const; Return floating-point value contained in string.; Examples of valid strings are:; 64320; 64 320; 6 4 3 2 0; 6.4320 6,4320; 6.43e20 6.43E20 6,43e20; 6.43e-20 6.43E-20 6,43e-20. TString Itoa(Int_t value, Int_t base); Converts an Int_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; Usage: the following statement produce the same output, namely ""1111""; cout << TString::Itoa(15,2) ;; cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; In case of error returns the ""!"" string. TString UItoa(UInt_t value, Int_t base); Converts a UInt_t (twice the range of an Int_t) to a TString with respect; to the base specified (2-36). Thus it is an enhanced version of sprintf; (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString LLtoa(Long64_t value, Int_t base); Converts a Long64_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString ULLtoa(ULong64_t value, Int_t base); Converts a ULon",MatchSource.WIKI,root/html534/TString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TString.html
https://root.cern/root/html534/TString.html:18537,Modifiability,enhance,enhanced,18537,"ce (see IsDigit()),; i.e. ""123456"", ""123 456"" and ""1 2 3 4 56"" are all valid; integer strings whose Atoll() value is 123456. Double_t Atof() const; Return floating-point value contained in string.; Examples of valid strings are:; 64320; 64 320; 6 4 3 2 0; 6.4320 6,4320; 6.43e20 6.43E20 6,43e20; 6.43e-20 6.43E-20 6,43e-20. TString Itoa(Int_t value, Int_t base); Converts an Int_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; Usage: the following statement produce the same output, namely ""1111""; cout << TString::Itoa(15,2) ;; cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; In case of error returns the ""!"" string. TString UItoa(UInt_t value, Int_t base); Converts a UInt_t (twice the range of an Int_t) to a TString with respect; to the base specified (2-36). Thus it is an enhanced version of sprintf; (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString LLtoa(Long64_t value, Int_t base); Converts a Long64_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString ULLtoa(ULong64_t value, Int_t base); Converts a ULong64_t (twice the range of an Long64_t) to a TString with; respect to the base specified (2-36). Thus it is an enhanced version of; sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString BaseConvert(const TString& s_in, Int_t base_in, Int_t base_out); Converts string from base base_in to base base_out. Supported bases; are 2-36. At most 64 bit data can be converted. Bool_t EndsWith(const char* pat, TString::ECaseCompare cmp = kExact) const; Return",MatchSource.WIKI,root/html534/TString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TString.html
https://root.cern/root/html534/TString.html:18567,Modifiability,adapt,adapted,18567,"ce (see IsDigit()),; i.e. ""123456"", ""123 456"" and ""1 2 3 4 56"" are all valid; integer strings whose Atoll() value is 123456. Double_t Atof() const; Return floating-point value contained in string.; Examples of valid strings are:; 64320; 64 320; 6 4 3 2 0; 6.4320 6,4320; 6.43e20 6.43E20 6,43e20; 6.43e-20 6.43E-20 6,43e-20. TString Itoa(Int_t value, Int_t base); Converts an Int_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; Usage: the following statement produce the same output, namely ""1111""; cout << TString::Itoa(15,2) ;; cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; In case of error returns the ""!"" string. TString UItoa(UInt_t value, Int_t base); Converts a UInt_t (twice the range of an Int_t) to a TString with respect; to the base specified (2-36). Thus it is an enhanced version of sprintf; (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString LLtoa(Long64_t value, Int_t base); Converts a Long64_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString ULLtoa(ULong64_t value, Int_t base); Converts a ULong64_t (twice the range of an Long64_t) to a TString with; respect to the base specified (2-36). Thus it is an enhanced version of; sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString BaseConvert(const TString& s_in, Int_t base_in, Int_t base_out); Converts string from base base_in to base base_out. Supported bases; are 2-36. At most 64 bit data can be converted. Bool_t EndsWith(const char* pat, TString::ECaseCompare cmp = kExact) const; Return",MatchSource.WIKI,root/html534/TString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TString.html
https://root.cern/root/html534/TString.html:18819,Modifiability,enhance,enhanced,18819,"43E20 6,43e20; 6.43e-20 6.43E-20 6,43e-20. TString Itoa(Int_t value, Int_t base); Converts an Int_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; Usage: the following statement produce the same output, namely ""1111""; cout << TString::Itoa(15,2) ;; cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; In case of error returns the ""!"" string. TString UItoa(UInt_t value, Int_t base); Converts a UInt_t (twice the range of an Int_t) to a TString with respect; to the base specified (2-36). Thus it is an enhanced version of sprintf; (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString LLtoa(Long64_t value, Int_t base); Converts a Long64_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString ULLtoa(ULong64_t value, Int_t base); Converts a ULong64_t (twice the range of an Long64_t) to a TString with; respect to the base specified (2-36). Thus it is an enhanced version of; sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString BaseConvert(const TString& s_in, Int_t base_in, Int_t base_out); Converts string from base base_in to base base_out. Supported bases; are 2-36. At most 64 bit data can be converted. Bool_t EndsWith(const char* pat, TString::ECaseCompare cmp = kExact) const; Return true if string ends with the specified string. TObjArray * Tokenize(const TString& delim) const; This function is used to isolate sequential tokens in a TString.; These tokens are separated in the string by at least one of the; characters in delim. The returned array contains the",MatchSource.WIKI,root/html534/TString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TString.html
https://root.cern/root/html534/TString.html:18848,Modifiability,adapt,adapted,18848,"43E20 6,43e20; 6.43e-20 6.43E-20 6,43e-20. TString Itoa(Int_t value, Int_t base); Converts an Int_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; Usage: the following statement produce the same output, namely ""1111""; cout << TString::Itoa(15,2) ;; cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; In case of error returns the ""!"" string. TString UItoa(UInt_t value, Int_t base); Converts a UInt_t (twice the range of an Int_t) to a TString with respect; to the base specified (2-36). Thus it is an enhanced version of sprintf; (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString LLtoa(Long64_t value, Int_t base); Converts a Long64_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString ULLtoa(ULong64_t value, Int_t base); Converts a ULong64_t (twice the range of an Long64_t) to a TString with; respect to the base specified (2-36). Thus it is an enhanced version of; sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString BaseConvert(const TString& s_in, Int_t base_in, Int_t base_out); Converts string from base base_in to base base_out. Supported bases; are 2-36. At most 64 bit data can be converted. Bool_t EndsWith(const char* pat, TString::ECaseCompare cmp = kExact) const; Return true if string ends with the specified string. TObjArray * Tokenize(const TString& delim) const; This function is used to isolate sequential tokens in a TString.; These tokens are separated in the string by at least one of the; characters in delim. The returned array contains the",MatchSource.WIKI,root/html534/TString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TString.html
https://root.cern/root/html534/TString.html:19137,Modifiability,enhance,enhanced,19137,"e same output, namely ""1111""; cout << TString::Itoa(15,2) ;; cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; In case of error returns the ""!"" string. TString UItoa(UInt_t value, Int_t base); Converts a UInt_t (twice the range of an Int_t) to a TString with respect; to the base specified (2-36). Thus it is an enhanced version of sprintf; (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString LLtoa(Long64_t value, Int_t base); Converts a Long64_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString ULLtoa(ULong64_t value, Int_t base); Converts a ULong64_t (twice the range of an Long64_t) to a TString with; respect to the base specified (2-36). Thus it is an enhanced version of; sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString BaseConvert(const TString& s_in, Int_t base_in, Int_t base_out); Converts string from base base_in to base base_out. Supported bases; are 2-36. At most 64 bit data can be converted. Bool_t EndsWith(const char* pat, TString::ECaseCompare cmp = kExact) const; Return true if string ends with the specified string. TObjArray * Tokenize(const TString& delim) const; This function is used to isolate sequential tokens in a TString.; These tokens are separated in the string by at least one of the; characters in delim. The returned array contains the tokens; as TObjString's. The returned array is the owner of the objects,; and must be deleted by the user. void FormImp(const char* fmt, va_list ap); Formats a string using a printf style format descriptor.; Existing string contents will be overwritten. void Form(const char *va_(fmt), ...); Formats a string using a p",MatchSource.WIKI,root/html534/TString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TString.html
https://root.cern/root/html534/TString.html:19167,Modifiability,adapt,adapted,19167,"e same output, namely ""1111""; cout << TString::Itoa(15,2) ;; cout << TString::Itoa(0xF,2) ; /// 0x prefix to handle hex; cout << TString::Itoa(017,2) ; /// 0 prefix to handle oct; In case of error returns the ""!"" string. TString UItoa(UInt_t value, Int_t base); Converts a UInt_t (twice the range of an Int_t) to a TString with respect; to the base specified (2-36). Thus it is an enhanced version of sprintf; (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString LLtoa(Long64_t value, Int_t base); Converts a Long64_t to a TString with respect to the base specified (2-36).; Thus it is an enhanced version of sprintf (adapted from versions 0.4 of; http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString ULLtoa(ULong64_t value, Int_t base); Converts a ULong64_t (twice the range of an Long64_t) to a TString with; respect to the base specified (2-36). Thus it is an enhanced version of; sprintf (adapted from versions 0.4 of http://www.jb.man.ac.uk/~slowe/cpp/itoa.html).; In case of error returns the ""!"" string. TString BaseConvert(const TString& s_in, Int_t base_in, Int_t base_out); Converts string from base base_in to base base_out. Supported bases; are 2-36. At most 64 bit data can be converted. Bool_t EndsWith(const char* pat, TString::ECaseCompare cmp = kExact) const; Return true if string ends with the specified string. TObjArray * Tokenize(const TString& delim) const; This function is used to isolate sequential tokens in a TString.; These tokens are separated in the string by at least one of the; characters in delim. The returned array contains the tokens; as TObjString's. The returned array is the owner of the objects,; and must be deleted by the user. void FormImp(const char* fmt, va_list ap); Formats a string using a printf style format descriptor.; Existing string contents will be overwritten. void Form(const char *va_(fmt), ...); Formats a string using a p",MatchSource.WIKI,root/html534/TString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TString.html
https://root.cern/root/html534/TString.html:25443,Safety,detect,detecting,25443,", s.Data(), TMath::Min(s.Length(), n2)); }. TString & ReplaceAll(const TString& s1, const TString& s2); { return ReplaceAll(s1.Data(), s1.Length(), s2.Data(), s2.Length()) ; }. TString & ReplaceAll(const TString& s1, const char* s2); { return ReplaceAll(s1.Data(), s1.Length(), s2, s2 ? strlen(s2) : 0); }. TString & ReplaceAll(const char* s1, const TString& s2); { return ReplaceAll(s1, s1 ? strlen(s1) : 0, s2.Data(), s2.Length()); }. TString & ReplaceAll(const char* s1, const char* s2); { return ReplaceAll(s1, s1 ? strlen(s1) : 0, s2, s2 ? strlen(s2) : 0); }. char & operator()(Ssiz_t i); { return GetPointer()[i]; }. char operator()(Ssiz_t i) const; { return GetPointer()[i]; }. char & operator[](Ssiz_t i); { AssertElement(i); return GetPointer()[i]; }. char operator[](Ssiz_t i) const; { AssertElement(i); return GetPointer()[i]; }. char & operator()(Ssiz_t i). char operator()(Ssiz_t i) const. const char * Data() const. Ssiz_t Length() const; { return fExtent; }. Bool_t IsNull() const; For detecting null substrings. { return fBegin == kNPOS; }. Ssiz_t Align(Ssiz_t s); { return (s + (kAlignment-1)) & ~(kAlignment-1); }. Ssiz_t Recommend(Ssiz_t s); { return (s < kMinCap ? kMinCap : Align(s+1)) - 1; }. Bool_t IsLong() const; { return Bool_t(fRep.fShort.fSize & kShortMask); }. void SetShortSize(Ssiz_t s); { fRep.fShort.fSize = (unsigned char)(s << 1); }. Ssiz_t GetShortSize() const; { return fRep.fShort.fSize >> 1; }. void SetLongSize(Ssiz_t s); { fRep.fLong.fSize = s; }. Ssiz_t GetLongSize() const; { return fRep.fLong.fSize; }. void SetSize(Ssiz_t s); { IsLong() ? SetLongSize(s) : SetShortSize(s); }. void SetLongCap(Ssiz_t s); { fRep.fLong.fCap = kLongMask | s; }. Ssiz_t GetLongCap() const; { return fRep.fLong.fCap & ~kLongMask; }. void SetLongPointer(char* p); { fRep.fLong.fData = p; }. char * GetLongPointer(); { return fRep.fLong.fData; }. const char * GetLongPointer() const; { return fRep.fLong.fData; }. char * GetShortPointer(); { return fRep.fShort.fData; }. const cha",MatchSource.WIKI,root/html534/TString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TString.html
https://root.cern/root/html534/TString.html:411,Security,access,accessed,411,". TString. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TString. class TString. TString. Basic string class. Cannot be stored in a TCollection... use TObjString instead. The underlying string is stored as a char* that can be accessed via; TString::Data().; TString provides Short String Optimization (SSO) so that short; strings (<15 on 64-bit and <11 on 32-bit) are contained in the; TString internal data structure without the need for mallocing the; required space. Substring operations are provided by the TSubString class, which; holds a reference to the original string and its data, along with; the offset and length of the substring. To retrieve the substring; as a TString, construct a TString from it, eg:; root [0] TString s(""hello world""); root [1] TString s2( s(0,5) ); root [2] s2; (class TString)""hello"". This class is also known as (typedefs to this class)vector<TString,allocator<TString> >::value_type. Function Members (Methods); public:. TString(); TString(Ssiz_t ic); TString(const TString& s); TString(const char* s); TString(const string& s); TString(char c); TString(const TSubString& sub); TString(const char* s, Ssiz_t n); TString(char c, Ssiz_t s); virtual~TString(); TString&Append(const char* cs); TString&Append(const TString& s); TString&Append(const char* cs, Ssiz_t n); TString&Append(const TString& s, Ssiz_t n); TString&Append(char c, Ssiz_t rep = 1); Double_tAtof() const; Int_tAtoi() const; Long64_tAtoll() const; static TStringBaseConvert(const TString& s_in, Int_t base_in, Int_t base_out); Bool_tBeginsWith(const char* s, TString::ECaseCompare cmp = kExact) const; Bool_tBeginsWith(const TString& pat, TString::ECaseCompare cmp = kExact) const; Ssiz_tCapacity() const; Ssiz_tCapacity(Ssiz_t n); TString&Chop(); static TClass*Class(); voidClear(); intCompareTo(const char* cs,",MatchSource.WIKI,root/html534/TString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TString.html
https://root.cern/root/html534/TString.html:11153,Security,hash,hash,11153,"Compare cmp = kExact) const; Compare a string to char *cs2. Returns returns zero if the two; strings are identical, otherwise returns the difference between; the first two differing bytes (treated as unsigned char values,; so that `\200' is greater than `\0', for example). Zero-length; strings are always identical. int CompareTo(const TString& st, TString::ECaseCompare cmp = kExact) const; Compare a string to another string. Returns returns zero if the two; strings are identical, otherwise returns the difference between; the first two differing bytes (treated as unsigned char values,; so that `\200' is greater than `\0', for example). Zero-length; strings are always identical. Int_t CountChar(Int_t c) const; Return number of times character c occurs in the string. TString Copy() const; Copy a string. Ssiz_t First(char c) const; Find first occurrence of a character c. Ssiz_t First(const char* cs) const; Find first occurrence of a character in cs. UInt_t HashCase() const; Return a case-sensitive hash value (endian independent). UInt_t HashFoldCase() const; Return a case-insensitive hash value (endian independent). UInt_t Hash(TString::ECaseCompare cmp = kExact) const; Return hash value. UInt_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string. (static function); For string: i = TString::Hash(string,nstring);; For int: i = TString::Hash(&intword,sizeof(int));; For pointer: i = TString::Hash(&pointer,sizeof(void*));. This employs two different hash functions, depending on ntxt:; ntxt == sizeof(void*): a simple bitwise xor to get fast pointer hashes; else: MurmurHash3_x64_128 http://code.google.com/p/smhasher. Ssiz_t Index(const char* pat, Ssiz_t patlen, Ssiz_t i, TString::ECaseCompare cmp) const; Search for a string in the TString. Plen is the length of pattern,; startIndex is the index from which to start and cmp selects the type; of case-comparison. Ssiz_t Last(char c) const; Find last occurrence of a character c. TString MD5() const; Retur",MatchSource.WIKI,root/html534/TString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TString.html
https://root.cern/root/html534/TString.html:11241,Security,hash,hash,11241,"he two; strings are identical, otherwise returns the difference between; the first two differing bytes (treated as unsigned char values,; so that `\200' is greater than `\0', for example). Zero-length; strings are always identical. int CompareTo(const TString& st, TString::ECaseCompare cmp = kExact) const; Compare a string to another string. Returns returns zero if the two; strings are identical, otherwise returns the difference between; the first two differing bytes (treated as unsigned char values,; so that `\200' is greater than `\0', for example). Zero-length; strings are always identical. Int_t CountChar(Int_t c) const; Return number of times character c occurs in the string. TString Copy() const; Copy a string. Ssiz_t First(char c) const; Find first occurrence of a character c. Ssiz_t First(const char* cs) const; Find first occurrence of a character in cs. UInt_t HashCase() const; Return a case-sensitive hash value (endian independent). UInt_t HashFoldCase() const; Return a case-insensitive hash value (endian independent). UInt_t Hash(TString::ECaseCompare cmp = kExact) const; Return hash value. UInt_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string. (static function); For string: i = TString::Hash(string,nstring);; For int: i = TString::Hash(&intword,sizeof(int));; For pointer: i = TString::Hash(&pointer,sizeof(void*));. This employs two different hash functions, depending on ntxt:; ntxt == sizeof(void*): a simple bitwise xor to get fast pointer hashes; else: MurmurHash3_x64_128 http://code.google.com/p/smhasher. Ssiz_t Index(const char* pat, Ssiz_t patlen, Ssiz_t i, TString::ECaseCompare cmp) const; Search for a string in the TString. Plen is the length of pattern,; startIndex is the index from which to start and cmp selects the type; of case-comparison. Ssiz_t Last(char c) const; Find last occurrence of a character c. TString MD5() const; Return the MD5 digest for this string, in a string representation. Bool_t MaybeRegexp() co",MatchSource.WIKI,root/html534/TString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TString.html
https://root.cern/root/html534/TString.html:11336,Security,hash,hash,11336,"t two differing bytes (treated as unsigned char values,; so that `\200' is greater than `\0', for example). Zero-length; strings are always identical. int CompareTo(const TString& st, TString::ECaseCompare cmp = kExact) const; Compare a string to another string. Returns returns zero if the two; strings are identical, otherwise returns the difference between; the first two differing bytes (treated as unsigned char values,; so that `\200' is greater than `\0', for example). Zero-length; strings are always identical. Int_t CountChar(Int_t c) const; Return number of times character c occurs in the string. TString Copy() const; Copy a string. Ssiz_t First(char c) const; Find first occurrence of a character c. Ssiz_t First(const char* cs) const; Find first occurrence of a character in cs. UInt_t HashCase() const; Return a case-sensitive hash value (endian independent). UInt_t HashFoldCase() const; Return a case-insensitive hash value (endian independent). UInt_t Hash(TString::ECaseCompare cmp = kExact) const; Return hash value. UInt_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string. (static function); For string: i = TString::Hash(string,nstring);; For int: i = TString::Hash(&intword,sizeof(int));; For pointer: i = TString::Hash(&pointer,sizeof(void*));. This employs two different hash functions, depending on ntxt:; ntxt == sizeof(void*): a simple bitwise xor to get fast pointer hashes; else: MurmurHash3_x64_128 http://code.google.com/p/smhasher. Ssiz_t Index(const char* pat, Ssiz_t patlen, Ssiz_t i, TString::ECaseCompare cmp) const; Search for a string in the TString. Plen is the length of pattern,; startIndex is the index from which to start and cmp selects the type; of case-comparison. Ssiz_t Last(char c) const; Find last occurrence of a character c. TString MD5() const; Return the MD5 digest for this string, in a string representation. Bool_t MaybeRegexp() const; Returns true if string contains one of the regexp characters ""^$.[]*+?"". Boo",MatchSource.WIKI,root/html534/TString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TString.html
https://root.cern/root/html534/TString.html:11401,Security,hash,hash,11401,"er than `\0', for example). Zero-length; strings are always identical. int CompareTo(const TString& st, TString::ECaseCompare cmp = kExact) const; Compare a string to another string. Returns returns zero if the two; strings are identical, otherwise returns the difference between; the first two differing bytes (treated as unsigned char values,; so that `\200' is greater than `\0', for example). Zero-length; strings are always identical. Int_t CountChar(Int_t c) const; Return number of times character c occurs in the string. TString Copy() const; Copy a string. Ssiz_t First(char c) const; Find first occurrence of a character c. Ssiz_t First(const char* cs) const; Find first occurrence of a character in cs. UInt_t HashCase() const; Return a case-sensitive hash value (endian independent). UInt_t HashFoldCase() const; Return a case-insensitive hash value (endian independent). UInt_t Hash(TString::ECaseCompare cmp = kExact) const; Return hash value. UInt_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string. (static function); For string: i = TString::Hash(string,nstring);; For int: i = TString::Hash(&intword,sizeof(int));; For pointer: i = TString::Hash(&pointer,sizeof(void*));. This employs two different hash functions, depending on ntxt:; ntxt == sizeof(void*): a simple bitwise xor to get fast pointer hashes; else: MurmurHash3_x64_128 http://code.google.com/p/smhasher. Ssiz_t Index(const char* pat, Ssiz_t patlen, Ssiz_t i, TString::ECaseCompare cmp) const; Search for a string in the TString. Plen is the length of pattern,; startIndex is the index from which to start and cmp selects the type; of case-comparison. Ssiz_t Last(char c) const; Find last occurrence of a character c. TString MD5() const; Return the MD5 digest for this string, in a string representation. Bool_t MaybeRegexp() const; Returns true if string contains one of the regexp characters ""^$.[]*+?"". Bool_t MaybeWildcard() const; Returns true if string contains one of the wildcard c",MatchSource.WIKI,root/html534/TString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TString.html
https://root.cern/root/html534/TString.html:11636,Security,hash,hash,11636,"bytes (treated as unsigned char values,; so that `\200' is greater than `\0', for example). Zero-length; strings are always identical. Int_t CountChar(Int_t c) const; Return number of times character c occurs in the string. TString Copy() const; Copy a string. Ssiz_t First(char c) const; Find first occurrence of a character c. Ssiz_t First(const char* cs) const; Find first occurrence of a character in cs. UInt_t HashCase() const; Return a case-sensitive hash value (endian independent). UInt_t HashFoldCase() const; Return a case-insensitive hash value (endian independent). UInt_t Hash(TString::ECaseCompare cmp = kExact) const; Return hash value. UInt_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string. (static function); For string: i = TString::Hash(string,nstring);; For int: i = TString::Hash(&intword,sizeof(int));; For pointer: i = TString::Hash(&pointer,sizeof(void*));. This employs two different hash functions, depending on ntxt:; ntxt == sizeof(void*): a simple bitwise xor to get fast pointer hashes; else: MurmurHash3_x64_128 http://code.google.com/p/smhasher. Ssiz_t Index(const char* pat, Ssiz_t patlen, Ssiz_t i, TString::ECaseCompare cmp) const; Search for a string in the TString. Plen is the length of pattern,; startIndex is the index from which to start and cmp selects the type; of case-comparison. Ssiz_t Last(char c) const; Find last occurrence of a character c. TString MD5() const; Return the MD5 digest for this string, in a string representation. Bool_t MaybeRegexp() const; Returns true if string contains one of the regexp characters ""^$.[]*+?"". Bool_t MaybeWildcard() const; Returns true if string contains one of the wildcard characters ""[]*?"". TString& Prepend(char c, Ssiz_t rep = 1); Prepend character c rep times to string. TString & Replace(Ssiz_t pos, Ssiz_t n, const char* s, Ssiz_t ns); Remove at most n1 characters from self beginning at pos,; and replace them with the first n2 characters of cs. TString& ReplaceAll(const ",MatchSource.WIKI,root/html534/TString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TString.html
https://root.cern/root/html534/TString.html:11736,Security,hash,hashes,11736,"bytes (treated as unsigned char values,; so that `\200' is greater than `\0', for example). Zero-length; strings are always identical. Int_t CountChar(Int_t c) const; Return number of times character c occurs in the string. TString Copy() const; Copy a string. Ssiz_t First(char c) const; Find first occurrence of a character c. Ssiz_t First(const char* cs) const; Find first occurrence of a character in cs. UInt_t HashCase() const; Return a case-sensitive hash value (endian independent). UInt_t HashFoldCase() const; Return a case-insensitive hash value (endian independent). UInt_t Hash(TString::ECaseCompare cmp = kExact) const; Return hash value. UInt_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string. (static function); For string: i = TString::Hash(string,nstring);; For int: i = TString::Hash(&intword,sizeof(int));; For pointer: i = TString::Hash(&pointer,sizeof(void*));. This employs two different hash functions, depending on ntxt:; ntxt == sizeof(void*): a simple bitwise xor to get fast pointer hashes; else: MurmurHash3_x64_128 http://code.google.com/p/smhasher. Ssiz_t Index(const char* pat, Ssiz_t patlen, Ssiz_t i, TString::ECaseCompare cmp) const; Search for a string in the TString. Plen is the length of pattern,; startIndex is the index from which to start and cmp selects the type; of case-comparison. Ssiz_t Last(char c) const; Find last occurrence of a character c. TString MD5() const; Return the MD5 digest for this string, in a string representation. Bool_t MaybeRegexp() const; Returns true if string contains one of the regexp characters ""^$.[]*+?"". Bool_t MaybeWildcard() const; Returns true if string contains one of the wildcard characters ""[]*?"". TString& Prepend(char c, Ssiz_t rep = 1); Prepend character c rep times to string. TString & Replace(Ssiz_t pos, Ssiz_t n, const char* s, Ssiz_t ns); Remove at most n1 characters from self beginning at pos,; and replace them with the first n2 characters of cs. TString& ReplaceAll(const ",MatchSource.WIKI,root/html534/TString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TString.html
https://root.cern/root/html534/TString.html:11697,Usability,simpl,simple,11697,"bytes (treated as unsigned char values,; so that `\200' is greater than `\0', for example). Zero-length; strings are always identical. Int_t CountChar(Int_t c) const; Return number of times character c occurs in the string. TString Copy() const; Copy a string. Ssiz_t First(char c) const; Find first occurrence of a character c. Ssiz_t First(const char* cs) const; Find first occurrence of a character in cs. UInt_t HashCase() const; Return a case-sensitive hash value (endian independent). UInt_t HashFoldCase() const; Return a case-insensitive hash value (endian independent). UInt_t Hash(TString::ECaseCompare cmp = kExact) const; Return hash value. UInt_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string. (static function); For string: i = TString::Hash(string,nstring);; For int: i = TString::Hash(&intword,sizeof(int));; For pointer: i = TString::Hash(&pointer,sizeof(void*));. This employs two different hash functions, depending on ntxt:; ntxt == sizeof(void*): a simple bitwise xor to get fast pointer hashes; else: MurmurHash3_x64_128 http://code.google.com/p/smhasher. Ssiz_t Index(const char* pat, Ssiz_t patlen, Ssiz_t i, TString::ECaseCompare cmp) const; Search for a string in the TString. Plen is the length of pattern,; startIndex is the index from which to start and cmp selects the type; of case-comparison. Ssiz_t Last(char c) const; Find last occurrence of a character c. TString MD5() const; Return the MD5 digest for this string, in a string representation. Bool_t MaybeRegexp() const; Returns true if string contains one of the regexp characters ""^$.[]*+?"". Bool_t MaybeWildcard() const; Returns true if string contains one of the wildcard characters ""[]*?"". TString& Prepend(char c, Ssiz_t rep = 1); Prepend character c rep times to string. TString & Replace(Ssiz_t pos, Ssiz_t n, const char* s, Ssiz_t ns); Remove at most n1 characters from self beginning at pos,; and replace them with the first n2 characters of cs. TString& ReplaceAll(const ",MatchSource.WIKI,root/html534/TString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TString.html
https://root.cern/root/html534/TStringToken.html:8932,Availability,avail,available,8932,"const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TSubStringTString::Strip(TString::EStripType s = kTrailing, char c = ' ') const; TSubStringTString::SubString(const char* pat, Ssiz_t start = 0, TString::ECaseCompare cmp = kExact) const; TObjArray*TString::Tokenize(const TString& delim) const; Bool_tTString::Tokenize(TString& tok, Ssiz_t& from, const char* delim = "" "") const; voidTString::ToLower(); voidTString::ToUpper(); static TStringTString::UItoa(UInt_t value, Int_t base); static TStringTString::ULLtoa(ULong64_t value, Int_t base); static voidTString::WriteString(TBuffer& b, const TString* a). protected:. static Ssiz_tTString::AdjustCapacity(Ssiz_t oldCap, Ssiz_t newCap); static Ssiz_tTString::Align(Ssiz_t s); voidTString::AssertElement(Ssiz_t nc) const; voidTString::Clobber(Ssiz_t nc); voidTString::InitChar(char c); static Ssiz_tTString::Recommend(Ssiz_t s). Data Members; public:. enum TString::[unnamed] { kAlignment; };; enum TString::EStripType { kLeading; kTrailing; kBoth; };; enum TString::ECaseCompare { kExact; kIgnoreCase; };. protected:. const TStringfFullStr; Int_tfPos; Bool_tfReturnVoid; TPRegexpfSplitRe. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStringToken(const TString& fullStr, const TString& splitRe, Bool_t retVoid = kFALSE); Constructor. Bool_t NextToken(); Get the next token, it is stored in this TString.; Returns true if new token is available, false otherwise. TStringToken(const TString& fullStr, const TString& splitRe, Bool_t retVoid = kFALSE). virtual ~TStringToken(); {}. Bool_t AtEnd() const; { return fPos >= fFullStr.Length(); }. » Author: Eddy Offermann 24/06/05 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TStringToken.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStringToken.html
https://root.cern/root/html534/TStructNode.html:1859,Availability,error,error,1859,"me, void* pointer, TStructNode* parent, ULong_t size, ENodeType type); virtual~TStructNode(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; ULong_tGetAllMembersCount() const; Float_tGetCenter() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tGetHeight() const; virtual const char*TObject::GetIconName() const; UInt_tGetLevel() const; UInt_tGetMaxLevel() const; UInt_tGetMaxObjects() const; TList*GetMembers() const; ULong_tGetMembersCount() const; Float_tGetMiddle() const; virtual const char*GetName() const; ENodeTypeGetNodeType() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TStructNode*GetParent() const; void*GetPoi",MatchSource.WIKI,root/html534/TStructNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStructNode.html
https://root.cern/root/html534/TStructNode.html:1943,Availability,error,error,1943,"ctNode(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; ULong_tGetAllMembersCount() const; Float_tGetCenter() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tGetHeight() const; virtual const char*TObject::GetIconName() const; UInt_tGetLevel() const; UInt_tGetMaxLevel() const; UInt_tGetMaxObjects() const; TList*GetMembers() const; ULong_tGetMembersCount() const; Float_tGetMiddle() const; virtual const char*GetName() const; ENodeTypeGetNodeType() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TStructNode*GetParent() const; void*GetPointer() const; ULong_tGetRelativeMembersCount() const; ULong_tGetRelativeSize() const",MatchSource.WIKI,root/html534/TStructNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStructNode.html
https://root.cern/root/html534/TStructNode.html:7485,Energy Efficiency,allocate,allocated,7485,"; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. ULong_tfAllMembersCountNumber of all members (class and its daughters); Bool_tfCollapsedCondition - true if node is collapsed (we don't see dauthers); Float_tfHeightHeight of outlining box; UInt_tfLevelLevel number; UInt_tfMaxLevelNumber of levels displayed when the node is top node on scene; UInt_tfMaxObjectsNumber of objects displayed when the node is top node on scene; TList*fMembersList of daughter nodes; ULong_tfMembersCountNumber of members in class; TStringfNameName of node; ENodeTypefNodeTypeType of node; TStructNode*fParentPointer to parent node, NULL if not exist; void*fPointerPointer to data (address of variable); ULong_tfSizeMemory allocated by class without pointers and list elements; ULong_tfTotalSizeTotal allocated memory; TStringfTypeNameName of type; Bool_tfVisibleCondition - true if node is visible; Float_tfWidthWidth of outlining box; Float_tfXX coordinate in 3D space; Float_tfYY coordinate in 3D space; static EScalingTypefgScalBy. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStructNode(TString name, TString typeName, void* pointer, TStructNode* parent, ULong_t size, ENodeType type); Constructs node with name ""name"" of class ""typeName"" and given parent ""parent"" which represents pointer ""pointer"".; Size of node is set to ""size"" and type is set to ""type"". ~TStructNode(); Destructs list of nodes. Int_t Compare(const TObject* obj) const; Overrided method. Compare to objects of TStructNode class. U",MatchSource.WIKI,root/html534/TStructNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStructNode.html
https://root.cern/root/html534/TStructNode.html:7563,Energy Efficiency,allocate,allocated,7563,"; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. ULong_tfAllMembersCountNumber of all members (class and its daughters); Bool_tfCollapsedCondition - true if node is collapsed (we don't see dauthers); Float_tfHeightHeight of outlining box; UInt_tfLevelLevel number; UInt_tfMaxLevelNumber of levels displayed when the node is top node on scene; UInt_tfMaxObjectsNumber of objects displayed when the node is top node on scene; TList*fMembersList of daughter nodes; ULong_tfMembersCountNumber of members in class; TStringfNameName of node; ENodeTypefNodeTypeType of node; TStructNode*fParentPointer to parent node, NULL if not exist; void*fPointerPointer to data (address of variable); ULong_tfSizeMemory allocated by class without pointers and list elements; ULong_tfTotalSizeTotal allocated memory; TStringfTypeNameName of type; Bool_tfVisibleCondition - true if node is visible; Float_tfWidthWidth of outlining box; Float_tfXX coordinate in 3D space; Float_tfYY coordinate in 3D space; static EScalingTypefgScalBy. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStructNode(TString name, TString typeName, void* pointer, TStructNode* parent, ULong_t size, ENodeType type); Constructs node with name ""name"" of class ""typeName"" and given parent ""parent"" which represents pointer ""pointer"".; Size of node is set to ""size"" and type is set to ""type"". ~TStructNode(); Destructs list of nodes. Int_t Compare(const TObject* obj) const; Overrided method. Compare to objects of TStructNode class. U",MatchSource.WIKI,root/html534/TStructNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStructNode.html
https://root.cern/root/html534/TStructNode.html:10183,Energy Efficiency,allocate,allocated,10183,"e. void* GetPointer() const; Returns main pointer. ULong_t GetRelativeMembersCount() const; Returns relative numbers of members. If node is collapsed, then method returns number of all members,; it's node and its daughters, otherwise it returns number of members of node. ULong_t GetRelativeSize() const; Returns relative size of node. If node is collapsed, then function returns size of node and dauthers,; otherwise returns size of node only. ULong_t GetRelativeVolume() const; Returns size or number of members. If ScaleBy is set to kMembers and node is collapsed, then it; returns all number of members. If node isn't collapsed it returns number of members.; If Scaleby is set to kSize and node is collapsed, then it returns total size of node and daughters,; else it returns size of node, otherwise it returns 0. Float_t GetRelativeVolumeRatio(); Returns ratio - relative volume to area taken by utlining box. ULong_t GetSize() const; Returns size of node. ULong_t GetTotalSize() const; Returns total size of allocated memory in bytes. TString GetTypeName() const; Returns name of class. ULong_t GetVolume() const; Returns size or number of members. If ScaleBy is set to kMembers it returns all number of members.; If Scaleby is set to kSize then it returns total size of node and daughters, otherwise it returns 0. Float_t GetVolumeRatio(); Returns ratio - volme of node to area taken by outlining box. Float_t GetWidth() const; Returns width of outlining box. Float_t GetX() const; Returns X coordinate. Float_t GetY() const; Returns Y coordinate. Bool_t IsCollapsed() const; Returns true if node is colllapsed. Bool_t IsSortable() const; Returns true, because we have overrided method Compare. bool IsVisible() const; Returns true if node is visible. void SetAllMembersCount(ULong_t count); Sets numbers of all members to ""number"". void SetCollapsed(Bool_t collapsed); Sets collapsing of node to ""collapse"". void SetHeight(Float_t h); Sets width of outlining box to ""w"". void SetMaxLevel(UInt_",MatchSource.WIKI,root/html534/TStructNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStructNode.html
https://root.cern/root/html534/TStructNode.html:11804,Energy Efficiency,allocate,allocated,11804,"meRatio(); Returns ratio - volme of node to area taken by outlining box. Float_t GetWidth() const; Returns width of outlining box. Float_t GetX() const; Returns X coordinate. Float_t GetY() const; Returns Y coordinate. Bool_t IsCollapsed() const; Returns true if node is colllapsed. Bool_t IsSortable() const; Returns true, because we have overrided method Compare. bool IsVisible() const; Returns true if node is visible. void SetAllMembersCount(ULong_t count); Sets numbers of all members to ""number"". void SetCollapsed(Bool_t collapsed); Sets collapsing of node to ""collapse"". void SetHeight(Float_t h); Sets width of outlining box to ""w"". void SetMaxLevel(UInt_t level); Sets maximum number of leves displayed when the node is top node on scene. void SetMaxObjects(UInt_t max); Sets maximum number of objects displayed when the node is top node on scene. void SetMembers(TList* list); Sets list of dauther nodes to ""list"". void SetMembersCount(ULong_t count); Sets number of members to ""number"". void SetNodeType(ENodeType type); Sets type of node to ""type"". void SetPointer(void* pointer); Sets main pointer to ""pointer"". void SetScaleBy(EScalingType type); Sets scaling by to ""type"". void SetSize(ULong_t size); Sets size of node to ""size"". void SetTotalSize(ULong_t size); Sets total size of allocated memory in bytes to value ""size"". void SetVisible(bool visible); Sets visibility of node to ""visible"". void SetWidth(Float_t w); Sets width of outlining box to ""w"". void SetX(Float_t x); Sets X coordinate to ""x"". void SetY(Float_t y); Sets Y coordinate to ""y"". TStructNode(TString name, TString typeName, void* pointer, TStructNode* parent, ULong_t size, ENodeType type). » Author: Tomasz Sosnicki 18/09/09 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last changed: root/gviz3d:$Id$ » Last generated: 2015-03-14 16:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TStructNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStructNode.html
https://root.cern/root/html534/TStructNode.html:7455,Modifiability,variab,variable,7455,"; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. ULong_tfAllMembersCountNumber of all members (class and its daughters); Bool_tfCollapsedCondition - true if node is collapsed (we don't see dauthers); Float_tfHeightHeight of outlining box; UInt_tfLevelLevel number; UInt_tfMaxLevelNumber of levels displayed when the node is top node on scene; UInt_tfMaxObjectsNumber of objects displayed when the node is top node on scene; TList*fMembersList of daughter nodes; ULong_tfMembersCountNumber of members in class; TStringfNameName of node; ENodeTypefNodeTypeType of node; TStructNode*fParentPointer to parent node, NULL if not exist; void*fPointerPointer to data (address of variable); ULong_tfSizeMemory allocated by class without pointers and list elements; ULong_tfTotalSizeTotal allocated memory; TStringfTypeNameName of type; Bool_tfVisibleCondition - true if node is visible; Float_tfWidthWidth of outlining box; Float_tfXX coordinate in 3D space; Float_tfYY coordinate in 3D space; static EScalingTypefgScalBy. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStructNode(TString name, TString typeName, void* pointer, TStructNode* parent, ULong_t size, ENodeType type); Constructs node with name ""name"" of class ""typeName"" and given parent ""parent"" which represents pointer ""pointer"".; Size of node is set to ""size"" and type is set to ""type"". ~TStructNode(); Destructs list of nodes. Int_t Compare(const TObject* obj) const; Overrided method. Compare to objects of TStructNode class. U",MatchSource.WIKI,root/html534/TStructNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStructNode.html
https://root.cern/root/html534/TStructNodeEditor.html:4831,Availability,error,error,4831,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TStructNodeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStructNodeEditor.html
https://root.cern/root/html534/TStructNodeEditor.html:4915,Availability,error,error,4915,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TStructNodeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStructNodeEditor.html
https://root.cern/root/html534/TStructNodeEditor.html:18134,Availability,mask,mask,18134,,MatchSource.WIKI,root/html534/TStructNodeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStructNodeEditor.html
https://root.cern/root/html534/TStructNodeEditor.html:17625,Deployability,update,update,17625,,MatchSource.WIKI,root/html534/TStructNodeEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStructNodeEditor.html
https://root.cern/root/html534/TStructNodeProperty.html:1500,Availability,error,error,1500,"lor); TStructNodeProperty(const char* name, Pixel_t pixel); virtual~TStructNodeProperty(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TColorGetColor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Pixel_tGetPixel() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* meth",MatchSource.WIKI,root/html534/TStructNodeProperty.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStructNodeProperty.html
https://root.cern/root/html534/TStructNodeProperty.html:1584,Availability,error,error,1584,"rty(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TColorGetColor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Pixel_tGetPixel() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* class",MatchSource.WIKI,root/html534/TStructNodeProperty.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStructNodeProperty.html
https://root.cern/root/html534/TStructViewer.html:2570,Availability,error,error,2570," TStructViewer(void* ptr = NULL, const char* clname = NULL); virtual~TStructViewer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virt",MatchSource.WIKI,root/html534/TStructViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStructViewer.html
https://root.cern/root/html534/TStructViewer.html:2654,Availability,error,error,2654,"Viewer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TCanvas*GetCanvas(); TColorGetColor(const char* typeName); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGMainFrame*GetFrame(); virtual const char*TObject::GetIconName() const; TExMapGetLevelMembersCount() const; TExMapGetLevelSize() const; Bool_tGetLinksVisibility() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; void*GetPointer() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidT",MatchSource.WIKI,root/html534/TStructViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStructViewer.html
https://root.cern/root/html534/TStructViewer.html:7887,Energy Efficiency,allocate,allocated,7887,"color nodes; TStructViewerGUI*fGUIPointer to GUI class; TObjArrayfLevelArrayArray with pointers to nodes on each level; TExMapfLevelMembersCountContains number of objects on each level; TExMapfLevelSizeContains total size in bytes of a level; void*fPointerMain pointer to represented object; TClass*fPointerClassTClass of a main pointer; TExMapfPointersMap of pointer to avoid circulation; TStructNode*fTopNodeMaster node for fPointer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStructViewer(void* ptr = NULL, const char* clname = NULL); Default constructor. An argument ""ptr"" is a main pointer of type ""clname"", which should be shown in the viewer. ~TStructViewer(); Destructor. Clean all object after closing the viewer. void AddNode(TStructNode* node, ULong_t size); Find list with nodes on specified level and add node to this list and increment list of sizes and list of members. void CountMembers(TClass* cl, TStructNode* parent, void* pointer); Count allocated memory, increase member counters, find child nodes. void Draw(Option_t* option = """"); Draw object if there is valid pointer. TCanvas* GetCanvas(); Returns canvas used to keep TGeoVolumes. TGMainFrame* GetFrame(); Returns pointer to main window. void* GetPointer() const; Return main pointer. TExMap GetLevelMembersCount() const; Returns TExMap with pairs <level number, number of objects>. TExMap GetLevelSize() const; Returns TExMap with pairs <level number, size of level in bytes>. Bool_t GetLinksVisibility() const; Get visibility of links between objects. void Prepare(); Create top node and find all member nodes. void Reset(); Deleting nodes, maps and array. void SetColor(TString name, Int_t color); Sets color for the class ""name"" to color ""color"". void SetLinksVisibility(Bool_t val); ISets links visibility. void SetPointer(void* ptr, const char* clname = NULL); Set main pointer of class ""clname"". TColor GetColor(const char* typeName); Returns color associated with type ",MatchSource.WIKI,root/html534/TStructViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStructViewer.html
https://root.cern/root/html534/TStructViewer.html:523,Modifiability,inherit,inherit,523,". TStructViewer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GVIZ3D; » TStructViewer. class TStructViewer: public TObject. TStructViewer viewer represents class, struct or other type as an object in 3D space.; At the top of the scene we can see objects which is our pointer. Under it we see; pointers and collection elements. Collection must inherit from TCollection; or be STL collecion. We can change the number of visible levels or objects on the scene with the GUI or; methods. The size of geometry objects is proportional to the memory taken by this object; or to the number of members inside this object. An easy way to find some class in the viewer is to change the color of the type.; We can connect for example a TF2 class with red color or connect all classes; inheriting from TF2 by adding plus to name. For example typename ""TF2+"" tells us; that all classes inheriting from TF2 will be red. Navigation in viewer is very simple like in usual GLViewer. When you put the mouse over; some object you can see some information about it (e.g. name, size, actual level).; When you double click this object, it becames top object on scene.; Undo and redo operation are supported. In this picture we can see TStructViewer with pointer to TList which contains; other collections and objects of various classes. Other screenshot presents opened TStructNodeEditor. Function Members (Methods); public:. TStructViewer(void* ptr = NULL, const char* clname = NULL); virtual~TStructViewer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virt",MatchSource.WIKI,root/html534/TStructViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStructViewer.html
https://root.cern/root/html534/TStructViewer.html:952,Modifiability,inherit,inheriting,952,". TStructViewer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GVIZ3D; » TStructViewer. class TStructViewer: public TObject. TStructViewer viewer represents class, struct or other type as an object in 3D space.; At the top of the scene we can see objects which is our pointer. Under it we see; pointers and collection elements. Collection must inherit from TCollection; or be STL collecion. We can change the number of visible levels or objects on the scene with the GUI or; methods. The size of geometry objects is proportional to the memory taken by this object; or to the number of members inside this object. An easy way to find some class in the viewer is to change the color of the type.; We can connect for example a TF2 class with red color or connect all classes; inheriting from TF2 by adding plus to name. For example typename ""TF2+"" tells us; that all classes inheriting from TF2 will be red. Navigation in viewer is very simple like in usual GLViewer. When you put the mouse over; some object you can see some information about it (e.g. name, size, actual level).; When you double click this object, it becames top object on scene.; Undo and redo operation are supported. In this picture we can see TStructViewer with pointer to TList which contains; other collections and objects of various classes. Other screenshot presents opened TStructNodeEditor. Function Members (Methods); public:. TStructViewer(void* ptr = NULL, const char* clname = NULL); virtual~TStructViewer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virt",MatchSource.WIKI,root/html534/TStructViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStructViewer.html
https://root.cern/root/html534/TStructViewer.html:1051,Modifiability,inherit,inheriting,1051,"epage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GVIZ3D; » TStructViewer. class TStructViewer: public TObject. TStructViewer viewer represents class, struct or other type as an object in 3D space.; At the top of the scene we can see objects which is our pointer. Under it we see; pointers and collection elements. Collection must inherit from TCollection; or be STL collecion. We can change the number of visible levels or objects on the scene with the GUI or; methods. The size of geometry objects is proportional to the memory taken by this object; or to the number of members inside this object. An easy way to find some class in the viewer is to change the color of the type.; We can connect for example a TF2 class with red color or connect all classes; inheriting from TF2 by adding plus to name. For example typename ""TF2+"" tells us; that all classes inheriting from TF2 will be red. Navigation in viewer is very simple like in usual GLViewer. When you put the mouse over; some object you can see some information about it (e.g. name, size, actual level).; When you double click this object, it becames top object on scene.; Undo and redo operation are supported. In this picture we can see TStructViewer with pointer to TList which contains; other collections and objects of various classes. Other screenshot presents opened TStructNodeEditor. Function Members (Methods); public:. TStructViewer(void* ptr = NULL, const char* clname = NULL); virtual~TStructViewer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObjec",MatchSource.WIKI,root/html534/TStructViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStructViewer.html
https://root.cern/root/html534/TStructViewer.html:7251,Safety,avoid,avoid,7251," const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. voidAddNode(TStructNode* node, ULong_t size); voidCountMembers(TClass* cl, TStructNode* parent, void* pointer); voidPrepare(); voidReset(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TListfColorsList with properties used to color nodes; TStructViewerGUI*fGUIPointer to GUI class; TObjArrayfLevelArrayArray with pointers to nodes on each level; TExMapfLevelMembersCountContains number of objects on each level; TExMapfLevelSizeContains total size in bytes of a level; void*fPointerMain pointer to represented object; TClass*fPointerClassTClass of a main pointer; TExMapfPointersMap of pointer to avoid circulation; TStructNode*fTopNodeMaster node for fPointer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStructViewer(void* ptr = NULL, const char* clname = NULL); Default constructor. An argument ""ptr"" is a main pointer of type ""clname"", which should be shown in the viewer. ~TStructViewer(); Destructor. Clean all object after closing the viewer. void AddNode(TStructNode* node, ULong_t size); Find list with nodes on specified level and add node to this list and increment list of sizes and list of members. void CountMembers(TClass* cl, TStructNode* parent, void* pointer); Count allocated memory, increase member counters, find child nodes. void Draw(Option_t* option = """"); Draw object if there is valid pointer. TCanvas* GetCanvas(); Returns canvas used to keep TGeoV",MatchSource.WIKI,root/html534/TStructViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStructViewer.html
https://root.cern/root/html534/TStructViewer.html:1113,Usability,simpl,simple,1113,"file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GVIZ3D; » TStructViewer. class TStructViewer: public TObject. TStructViewer viewer represents class, struct or other type as an object in 3D space.; At the top of the scene we can see objects which is our pointer. Under it we see; pointers and collection elements. Collection must inherit from TCollection; or be STL collecion. We can change the number of visible levels or objects on the scene with the GUI or; methods. The size of geometry objects is proportional to the memory taken by this object; or to the number of members inside this object. An easy way to find some class in the viewer is to change the color of the type.; We can connect for example a TF2 class with red color or connect all classes; inheriting from TF2 by adding plus to name. For example typename ""TF2+"" tells us; that all classes inheriting from TF2 will be red. Navigation in viewer is very simple like in usual GLViewer. When you put the mouse over; some object you can see some information about it (e.g. name, size, actual level).; When you double click this object, it becames top object on scene.; Undo and redo operation are supported. In this picture we can see TStructViewer with pointer to TList which contains; other collections and objects of various classes. Other screenshot presents opened TStructNodeEditor. Function Members (Methods); public:. TStructViewer(void* ptr = NULL, const char* clname = NULL); virtual~TStructViewer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual v",MatchSource.WIKI,root/html534/TStructViewer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStructViewer.html
https://root.cern/root/html534/TStructViewerGUI.html:4878,Availability,error,error,4878,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TCanvas*GetCanvas(); voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; Int_tGetColor(TStructNode* node); static Int_tTGWindow::GetCounter(); TStructNodeProperty*GetDefaultColor(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual",MatchSource.WIKI,root/html534/TStructViewerGUI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStructViewerGUI.html
https://root.cern/root/html534/TStructViewerGUI.html:4962,Availability,error,error,4962,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TCanvas*GetCanvas(); voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; Int_tGetColor(TStructNode* node); static Int_tTGWindow::GetCounter(); TStructNodeProperty*GetDefaultColor(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefault",MatchSource.WIKI,root/html534/TStructViewerGUI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStructViewerGUI.html
https://root.cern/root/html534/TStructViewerGUI.html:20076,Availability,mask,mask,20076,,MatchSource.WIKI,root/html534/TStructViewerGUI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStructViewerGUI.html
https://root.cern/root/html534/TStructViewerGUI.html:26253,Deployability,update,updates,26253,"given parent ""p"". Argument ""parent"" is a pointer to TStructViewer which contains this GUI.; This constructor build window with all controls, build map with colors, init OpenGL Viewer and create TGeoVolumes. ~TStructViewerGUI(); Destructor. void AutoRefreshButtonSlot(Bool_t on); Activated when user chage condition. void BoxHeightValueSetSlot(Long_t h); Emmited when user changes height of boxes. void CalculatePosistion(TStructNode* parent); Recursive method to calculating nodes posistion in 3D space. void CheckMaxObjects(TStructNode* parent); Check if all of nodes can be displayed on scene. Hides redendant nodes. void CloseWindow(); Delete window. void ColorSelectedSlot(Pixel_t pixel); Slot for default color selsect.; Sets default colot to ""pixel"". void Divide(TList* list, Float_t x1, Float_t x2, Float_t y1, Float_t y2); Divides rectangle where the outlining box is placed. void DoubleClickedSlot(); Activated when user double click on objects on 3D scene. Sets clicked node to top node; and updates scene with camers reset. void Draw(Option_t* option = """"); Check limits and draws nodes and links. void DrawLink(TStructNode* parent); Recursive method to draw links. void DrawNode(TStructNode* node); Creates and draws TGeoVolume from given ""node"". void DrawVolumes(TStructNode* visObj); Recursive method to draw GeoVolumes. TStructNodeProperty* FindNodeProperty(TStructNode* node); Returns pointer to property associated with node ""node"". If property is not found; then it returns default property. TCanvas* GetCanvas(); Returns canvas used to keep TGeoVolumes. Int_t GetColor(TStructNode* node); Returns color form fColors for given ""node"". TStructNodeProperty* GetDefaultColor(); Return default color for nodes. Bool_t GetLinksVisibility() const; Returns true if links are visible, otherwise return false. TStructNode* GetNodePtr() const; Returns top node pointer. void GLWidgetProcessedEventSlot(Event_t* event); Handle events. Sets fMouseX and fMouseY when user move a mouse over viewe",MatchSource.WIKI,root/html534/TStructViewerGUI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStructViewerGUI.html
https://root.cern/root/html534/TStructViewerGUI.html:27495,Deployability,update,updates,27495,"om given ""node"". void DrawVolumes(TStructNode* visObj); Recursive method to draw GeoVolumes. TStructNodeProperty* FindNodeProperty(TStructNode* node); Returns pointer to property associated with node ""node"". If property is not found; then it returns default property. TCanvas* GetCanvas(); Returns canvas used to keep TGeoVolumes. Int_t GetColor(TStructNode* node); Returns color form fColors for given ""node"". TStructNodeProperty* GetDefaultColor(); Return default color for nodes. Bool_t GetLinksVisibility() const; Returns true if links are visible, otherwise return false. TStructNode* GetNodePtr() const; Returns top node pointer. void GLWidgetProcessedEventSlot(Event_t* event); Handle events. Sets fMouseX and fMouseY when user move a mouse over viewer and hides ToolTip. void LevelDistValueSetSlot(Long_t dist); Emmited when user changes distance between levels. void MouseOverSlot(TGLPhysicalShape* shape); MouseOver slot. Activated when user out mouse over object on scene.; Sets ToolTip and updates labels. void RedoButtonSlot(); Activated when user click Redo button. Repeat last Undo action. void ResetButtonSlot(); Resets camera. void Scale(TStructNode* parent); Recursive method to scaling all modes on scene. We have to scale nodes to get real ratio between nodes.; Uses fMaxRatio. void SetNodePtr(TStructNode* val); Sets top node pointer and updates view. void SetLinksVisibility(Bool_t val); Sets links visibility to ""visible"". void SetPointerButtonSlot(); Sets pointer given in fPointerTestEntry to the main pointer. void ShowLinksToggled(Bool_t on); Changes links visibility and refresh view. void UnCheckMaxObjects(); Shows hidden nodes. void Update(Bool_t resetCamera = false); Updates view. Clear all the nodes, call draw function and update scene. Doesn't reset camera. void UpdateButtonSlot(); Update button slot. Updates scene. void UpdateLabels(TStructNode* node); Refresh information in labels when user put mouse over object. void UndoButtonSlot(); UndoButton Slot. Activ",MatchSource.WIKI,root/html534/TStructViewerGUI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStructViewerGUI.html
https://root.cern/root/html534/TStructViewerGUI.html:27852,Deployability,update,updates,27852,"_t GetColor(TStructNode* node); Returns color form fColors for given ""node"". TStructNodeProperty* GetDefaultColor(); Return default color for nodes. Bool_t GetLinksVisibility() const; Returns true if links are visible, otherwise return false. TStructNode* GetNodePtr() const; Returns top node pointer. void GLWidgetProcessedEventSlot(Event_t* event); Handle events. Sets fMouseX and fMouseY when user move a mouse over viewer and hides ToolTip. void LevelDistValueSetSlot(Long_t dist); Emmited when user changes distance between levels. void MouseOverSlot(TGLPhysicalShape* shape); MouseOver slot. Activated when user out mouse over object on scene.; Sets ToolTip and updates labels. void RedoButtonSlot(); Activated when user click Redo button. Repeat last Undo action. void ResetButtonSlot(); Resets camera. void Scale(TStructNode* parent); Recursive method to scaling all modes on scene. We have to scale nodes to get real ratio between nodes.; Uses fMaxRatio. void SetNodePtr(TStructNode* val); Sets top node pointer and updates view. void SetLinksVisibility(Bool_t val); Sets links visibility to ""visible"". void SetPointerButtonSlot(); Sets pointer given in fPointerTestEntry to the main pointer. void ShowLinksToggled(Bool_t on); Changes links visibility and refresh view. void UnCheckMaxObjects(); Shows hidden nodes. void Update(Bool_t resetCamera = false); Updates view. Clear all the nodes, call draw function and update scene. Doesn't reset camera. void UpdateButtonSlot(); Update button slot. Updates scene. void UpdateLabels(TStructNode* node); Refresh information in labels when user put mouse over object. void UndoButtonSlot(); UndoButton Slot. Activated when user press Undo button. Restore last top node pointer. void ScaleByChangedSlot(); Activated when user press radio button. » Author: Tomasz Sosnicki 18/09/09 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last changed: root/gviz3d:$Id$ » Last generated: 2015-03-14 16:50; This page has been automatically gener",MatchSource.WIKI,root/html534/TStructViewerGUI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStructViewerGUI.html
https://root.cern/root/html534/TStructViewerGUI.html:28251,Deployability,update,update,28251,"eturn default color for nodes. Bool_t GetLinksVisibility() const; Returns true if links are visible, otherwise return false. TStructNode* GetNodePtr() const; Returns top node pointer. void GLWidgetProcessedEventSlot(Event_t* event); Handle events. Sets fMouseX and fMouseY when user move a mouse over viewer and hides ToolTip. void LevelDistValueSetSlot(Long_t dist); Emmited when user changes distance between levels. void MouseOverSlot(TGLPhysicalShape* shape); MouseOver slot. Activated when user out mouse over object on scene.; Sets ToolTip and updates labels. void RedoButtonSlot(); Activated when user click Redo button. Repeat last Undo action. void ResetButtonSlot(); Resets camera. void Scale(TStructNode* parent); Recursive method to scaling all modes on scene. We have to scale nodes to get real ratio between nodes.; Uses fMaxRatio. void SetNodePtr(TStructNode* val); Sets top node pointer and updates view. void SetLinksVisibility(Bool_t val); Sets links visibility to ""visible"". void SetPointerButtonSlot(); Sets pointer given in fPointerTestEntry to the main pointer. void ShowLinksToggled(Bool_t on); Changes links visibility and refresh view. void UnCheckMaxObjects(); Shows hidden nodes. void Update(Bool_t resetCamera = false); Updates view. Clear all the nodes, call draw function and update scene. Doesn't reset camera. void UpdateButtonSlot(); Update button slot. Updates scene. void UpdateLabels(TStructNode* node); Refresh information in labels when user put mouse over object. void UndoButtonSlot(); UndoButton Slot. Activated when user press Undo button. Restore last top node pointer. void ScaleByChangedSlot(); Activated when user press radio button. » Author: Tomasz Sosnicki 18/09/09 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last changed: root/gviz3d:$Id$ » Last generated: 2015-03-14 16:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TStructViewerGUI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStructViewerGUI.html
https://root.cern/root/html534/TStructViewerGUI.html:390,Integrability,interface,interface,390,". TStructViewerGUI. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GVIZ3D; » TStructViewerGUI. class TStructViewerGUI: public TGMainFrame. TStructViewerGUI is main window of TStructViewer. It provides graphical; interface. In the window we can find panel with tabs and frame with; GLViewer. Tab ""Info"" serves information about node and is used to naviagate; backward and forward. Second tab ""Options"" is used to set few options; such as links visibility, scaling method or setting a pointer.; Last tab ""Editor"" is tab when the TStructNodeEditor is placed. Function Members (Methods); public:. TStructViewerGUI(TStructViewer* parent, TStructNode* nodePtr, TList* colors, const TGWindow* p = NULL, UInt_t w = 800, UInt_t h = 600); virtual~TStructViewerGUI(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; voidAutoRefreshButtonSlot(Bool_t on); virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); voidBoxHeightValueSetSlot(Long_t h); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*T",MatchSource.WIKI,root/html534/TStructViewerGUI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStructViewerGUI.html
https://root.cern/root/html534/TStyle.html:1912,Availability,error,error,1912,"dPad(Option_t* option = """"); Int_tAxisChoice(Option_t* axis) const; virtual voidBrowse(TBrowser* b); static voidBuildStyles(); virtual voidcd(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject& style) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TAttText*GetAttDate(); Color_tGetAxisColor(Option_t* axis = ""X"") const; Float_tGetBarOffset() const; Float_tGetBarWidth() const; Int_tGetCanvasBorderMode() const; Width_tGetCanvasBorderSize() const; Color_tGetCanvasColor() const; Int_tGetCanvasDefH() const; Int_tGetCanvasDefW() const; Int_tGetCanvasDefX() const; Int_tGetCanvasDefY() const; Bool_tGetCanvasPreferGL() const; Int_tGetColorModelPS() const; Int_tGetColorPalette(Int_t i) const; Float_tGetDateX() const; Float_tGetDateY() const; Int_tGetDrawBorder() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::Get",MatchSource.WIKI,root/html534/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyle.html
https://root.cern/root/html534/TStyle.html:1996,Availability,error,error,1996,"se(TBrowser* b); static voidBuildStyles(); virtual voidcd(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject& style) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TAttText*GetAttDate(); Color_tGetAxisColor(Option_t* axis = ""X"") const; Float_tGetBarOffset() const; Float_tGetBarWidth() const; Int_tGetCanvasBorderMode() const; Width_tGetCanvasBorderSize() const; Color_tGetCanvasColor() const; Int_tGetCanvasDefH() const; Int_tGetCanvasDefW() const; Int_tGetCanvasDefX() const; Int_tGetCanvasDefY() const; Bool_tGetCanvasPreferGL() const; Int_tGetColorModelPS() const; Int_tGetColorPalette(Int_t i) const; Float_tGetDateX() const; Float_tGetDateY() const; Int_tGetDrawBorder() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tGetEndErrorSize() const; Float_tGetErrorX() const; virtual Color_",MatchSource.WIKI,root/html534/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyle.html
https://root.cern/root/html534/TStyle.html:10550,Availability,error,errorx,10550,"Primitive(ostream& out, Option_t* = """"); voidSaveSource(const char* filename, Option_t* option = 0); virtual voidTAttText::SaveTextAttributes(ostream& out, const char* name, Int_t alidef = 12, Float_t angdef = 0, Int_t coldef = 1, Int_t fondef = 61, Float_t sizdef = 1); voidSetAxisColor(Color_t color = 1, Option_t* axis = ""X""); voidSetBarOffset(Float_t baroff = 0.5); voidSetBarWidth(Float_t barwidth = 0.5); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetCanvasBorderMode(Int_t mode = 1); voidSetCanvasBorderSize(Width_t size = 1); voidSetCanvasColor(Color_t color = 19); voidSetCanvasDefH(Int_t h = 500); voidSetCanvasDefW(Int_t w = 700); voidSetCanvasDefX(Int_t topx = 10); voidSetCanvasDefY(Int_t topy = 10); voidSetCanvasPreferGL(Bool_t prefer = kTRUE); voidSetColorModelPS(Int_t c = 0); voidSetDateX(Float_t x = 0.01); voidSetDateY(Float_t y = 0.01); voidSetDrawBorder(Int_t drawborder = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEndErrorSize(Float_t np = 2); voidSetErrorX(Float_t errorx = 0.5); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); voidSetFitFormat(const char* format = ""5.4g""); voidSetFrameBorderMode(Int_t mode = 1); voidSetFrameBorderSize(Width_t size = 1); voidSetFrameFillColor(Color_t color = 1); voidSetFrameFillStyle(Style_t styl = 0); voidSetFrameLineColor(Color_t color = 1); voidSetFrameLineStyle(Style_t styl = 0); voidSetFrameLineWidth(Width_t width = 1); voidSetFuncColor(Color_t color = 1); voidSetFuncStyle(Style_t style = 1); voidSetFuncWidth(Width_t width = 4); voidSetGridColor(Color_t color = 0); voidSetGridStyle(Style_t style = 3); voidSetGridWidth(Width_t width = 1); voidSetHatchesLineWidth(Int_t l); voidSetHatchesSpacing(Double_t h); voidSetHeaderPS(const char* hea",MatchSource.WIKI,root/html534/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyle.html
https://root.cern/root/html534/TStyle.html:18572,Availability,error,error,18572,,MatchSource.WIKI,root/html534/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyle.html
https://root.cern/root/html534/TStyle.html:18624,Availability,error,errors,18624,,MatchSource.WIKI,root/html534/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyle.html
https://root.cern/root/html534/TStyle.html:27737,Availability,error,error,27737,"r model. void SetHistMinimumZero(Bool_t zero = kTRUE); If the argument zero=kTRUE the minimum value for the Y axis of 1-d histograms; is set to 0 if the minimum bin content is greater than 0 and TH1::SetMinimum; has not been called.; Otherwise the minimum is based on the minimum bin content. void SetNdivisions(Int_t n = 510, Option_t* axis = ""X""); Set the number of divisions to draw an axis.; ndiv : Number of divisions. n = N1 + 100*N2 + 10000*N3; N1=number of primary divisions.; N2=number of secondary divisions.; N3=number of 3rd divisions.; e.g.:; nndi=0 --> no tick marks.; nndi=2 --> 2 divisions, one tick mark in the middle; of the axis.; axis specifies which axis (""x"",""y"",""z""), default = ""x""; if axis=""xyz"" set all 3 axes. void SetAxisColor(Color_t color = 1, Option_t* axis = ""X""); Set color to draw the axis line and tick marks.; axis specifies which axis (""x"",""y"",""z""), default = ""x""; if axis=""xyz"" set all 3 axes. void SetEndErrorSize(Float_t np = 2); Set the size (in pixels) of the small lines drawn at the; end of the error bars (TH1 or TGraphErrors).; The default value is 2 pixels.; Set np=0 to remove these lines. void SetHeaderPS(const char* header); Define a string to be inserted in the Postscript header; The string in header will be added to the Postscript file; immediatly following the %%Page line; For example, this string may contain special Postscript instructions like; 200 200 translate; the following header string will print the string ""my annotation"" at the; bottom left corner of the page (outside the user area); ""gsave 100 -100 t 0 r 0 0 m /Helvetica-Bold findfont 56 sf 0 0 m ( my annotation ) show gr""; This information is used in TPostScript::Initialize. void SetIsReading(Bool_t reading = kTRUE); Sets the fIsReading member to reading (default=kTRUE); fIsReading (used via gStyle->IsReading()) can be used in; the functions myclass::UseCurrentStyle to read from the current style; or write to the current style. void SetTitlePS(const char* pstitle); Define",MatchSource.WIKI,root/html534/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyle.html
https://root.cern/root/html534/TStyle.html:32773,Availability,error,errors,32773,"e controlled by:; gStyle->SetDateX(x); x in NDC; gStyle->SetDateY(y); y in NDC. The date text attributes can be changed with:; gStyle->GetAttDate()->SetTextFont(font=62);; gStyle->GetAttDate()->SetTextSize(size=0.025);; gStyle->GetAttDate()->SetTextAngle(angle=0);; gStyle->GetAttDate()->SetTextAlign(align=11);; gStyle->GetAttDate()->SetTextColor(color=1);. The current date attributes can be obtained via:; gStyle->GetAttDate()->GetTextxxxx();. When the date option is active, a text object is created when the pad; paint its list of primitives. The text object is named ""DATE"".; The DATE attributes can also be edited interactively (position; and attributes) via the normal context menu. void SetOptFit(Int_t fit = 1); The type of information about fit parameters printed in the histogram; statistics box can be selected via the parameter mode.; The parameter mode can be = pcev (default = 0111); p = 1; print Probability; c = 1; print Chisquare/Number of degress of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters; Example: gStyle->SetOptFit(1011);; print fit probability, parameter names/values and errors.; When ""v""=1 is specified, only the non-fixed parameters are shown.; When ""v""=2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent to; gStyle->SetOptFit(111). see also SetOptStat below. void SetOptStat(Int_t stat = 1); The type of information printed in the histogram statistics box; can be selected via the parameter mode.; The parameter mode can be = ksiourmen (default = 000001111); k = 1; kurtosis printed; k = 2; kurtosis and kurtosis error printed; s = 1; skewness printed; s = 2; skewness and skewness error printed; i = 1; integral of bins printed; i = 2; integral of bins with option ""width"" printed; o = 1; number of overflows printed; u = 1; number of underflows printed; r = 1; rms printed; r = 2; rms and rms error printed; m = 1; mean value printed; m = 2; mean and mean error values prin",MatchSource.WIKI,root/html534/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyle.html
https://root.cern/root/html534/TStyle.html:32928,Availability,error,errors,32928,"e controlled by:; gStyle->SetDateX(x); x in NDC; gStyle->SetDateY(y); y in NDC. The date text attributes can be changed with:; gStyle->GetAttDate()->SetTextFont(font=62);; gStyle->GetAttDate()->SetTextSize(size=0.025);; gStyle->GetAttDate()->SetTextAngle(angle=0);; gStyle->GetAttDate()->SetTextAlign(align=11);; gStyle->GetAttDate()->SetTextColor(color=1);. The current date attributes can be obtained via:; gStyle->GetAttDate()->GetTextxxxx();. When the date option is active, a text object is created when the pad; paint its list of primitives. The text object is named ""DATE"".; The DATE attributes can also be edited interactively (position; and attributes) via the normal context menu. void SetOptFit(Int_t fit = 1); The type of information about fit parameters printed in the histogram; statistics box can be selected via the parameter mode.; The parameter mode can be = pcev (default = 0111); p = 1; print Probability; c = 1; print Chisquare/Number of degress of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters; Example: gStyle->SetOptFit(1011);; print fit probability, parameter names/values and errors.; When ""v""=1 is specified, only the non-fixed parameters are shown.; When ""v""=2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent to; gStyle->SetOptFit(111). see also SetOptStat below. void SetOptStat(Int_t stat = 1); The type of information printed in the histogram statistics box; can be selected via the parameter mode.; The parameter mode can be = ksiourmen (default = 000001111); k = 1; kurtosis printed; k = 2; kurtosis and kurtosis error printed; s = 1; skewness printed; s = 2; skewness and skewness error printed; i = 1; integral of bins printed; i = 2; integral of bins with option ""width"" printed; o = 1; number of overflows printed; u = 1; number of underflows printed; r = 1; rms printed; r = 2; rms and rms error printed; m = 1; mean value printed; m = 2; mean and mean error values prin",MatchSource.WIKI,root/html534/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyle.html
https://root.cern/root/html534/TStyle.html:33420,Availability,error,error,33420,"mode.; The parameter mode can be = pcev (default = 0111); p = 1; print Probability; c = 1; print Chisquare/Number of degress of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters; Example: gStyle->SetOptFit(1011);; print fit probability, parameter names/values and errors.; When ""v""=1 is specified, only the non-fixed parameters are shown.; When ""v""=2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent to; gStyle->SetOptFit(111). see also SetOptStat below. void SetOptStat(Int_t stat = 1); The type of information printed in the histogram statistics box; can be selected via the parameter mode.; The parameter mode can be = ksiourmen (default = 000001111); k = 1; kurtosis printed; k = 2; kurtosis and kurtosis error printed; s = 1; skewness printed; s = 2; skewness and skewness error printed; i = 1; integral of bins printed; i = 2; integral of bins with option ""width"" printed; o = 1; number of overflows printed; u = 1; number of underflows printed; r = 1; rms printed; r = 2; rms and rms error printed; m = 1; mean value printed; m = 2; mean and mean error values printed; e = 1; number of entries printed; n = 1; name of histogram is printed; Example: gStyle->SetOptStat(11);; print only name of histogram and number of entries.; gStyle->SetOptStat(1101); displays the name of histogram, mean value and RMS.; WARNING: never call SetOptStat(000111); but SetOptStat(1111), 0001111 will; be taken as an octal number !!; WARNING: SetOptStat(1) is taken as SetOptStat(1111) (for back compatibility; with older versions. If you want to print only the name of the histogram; call SetOptStat(1000000001).; NOTE that in case of 2-D histograms, when selecting just underflow (10000); or overflow (100000), the stats box will show all combinations; of underflow/overflows and not just one single number!. void SetOptStat(Option_t* stat); The parameter mode can be any combination of kKsSiourRmMen; k : kurtosis printed;",MatchSource.WIKI,root/html534/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyle.html
https://root.cern/root/html534/TStyle.html:33489,Availability,error,error,33489,"mode.; The parameter mode can be = pcev (default = 0111); p = 1; print Probability; c = 1; print Chisquare/Number of degress of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters; Example: gStyle->SetOptFit(1011);; print fit probability, parameter names/values and errors.; When ""v""=1 is specified, only the non-fixed parameters are shown.; When ""v""=2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent to; gStyle->SetOptFit(111). see also SetOptStat below. void SetOptStat(Int_t stat = 1); The type of information printed in the histogram statistics box; can be selected via the parameter mode.; The parameter mode can be = ksiourmen (default = 000001111); k = 1; kurtosis printed; k = 2; kurtosis and kurtosis error printed; s = 1; skewness printed; s = 2; skewness and skewness error printed; i = 1; integral of bins printed; i = 2; integral of bins with option ""width"" printed; o = 1; number of overflows printed; u = 1; number of underflows printed; r = 1; rms printed; r = 2; rms and rms error printed; m = 1; mean value printed; m = 2; mean and mean error values printed; e = 1; number of entries printed; n = 1; name of histogram is printed; Example: gStyle->SetOptStat(11);; print only name of histogram and number of entries.; gStyle->SetOptStat(1101); displays the name of histogram, mean value and RMS.; WARNING: never call SetOptStat(000111); but SetOptStat(1111), 0001111 will; be taken as an octal number !!; WARNING: SetOptStat(1) is taken as SetOptStat(1111) (for back compatibility; with older versions. If you want to print only the name of the histogram; call SetOptStat(1000000001).; NOTE that in case of 2-D histograms, when selecting just underflow (10000); or overflow (100000), the stats box will show all combinations; of underflow/overflows and not just one single number!. void SetOptStat(Option_t* stat); The parameter mode can be any combination of kKsSiourRmMen; k : kurtosis printed;",MatchSource.WIKI,root/html534/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyle.html
https://root.cern/root/html534/TStyle.html:33702,Availability,error,error,33702,"mode.; The parameter mode can be = pcev (default = 0111); p = 1; print Probability; c = 1; print Chisquare/Number of degress of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters; Example: gStyle->SetOptFit(1011);; print fit probability, parameter names/values and errors.; When ""v""=1 is specified, only the non-fixed parameters are shown.; When ""v""=2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent to; gStyle->SetOptFit(111). see also SetOptStat below. void SetOptStat(Int_t stat = 1); The type of information printed in the histogram statistics box; can be selected via the parameter mode.; The parameter mode can be = ksiourmen (default = 000001111); k = 1; kurtosis printed; k = 2; kurtosis and kurtosis error printed; s = 1; skewness printed; s = 2; skewness and skewness error printed; i = 1; integral of bins printed; i = 2; integral of bins with option ""width"" printed; o = 1; number of overflows printed; u = 1; number of underflows printed; r = 1; rms printed; r = 2; rms and rms error printed; m = 1; mean value printed; m = 2; mean and mean error values printed; e = 1; number of entries printed; n = 1; name of histogram is printed; Example: gStyle->SetOptStat(11);; print only name of histogram and number of entries.; gStyle->SetOptStat(1101); displays the name of histogram, mean value and RMS.; WARNING: never call SetOptStat(000111); but SetOptStat(1111), 0001111 will; be taken as an octal number !!; WARNING: SetOptStat(1) is taken as SetOptStat(1111) (for back compatibility; with older versions. If you want to print only the name of the histogram; call SetOptStat(1000000001).; NOTE that in case of 2-D histograms, when selecting just underflow (10000); or overflow (100000), the stats box will show all combinations; of underflow/overflows and not just one single number!. void SetOptStat(Option_t* stat); The parameter mode can be any combination of kKsSiourRmMen; k : kurtosis printed;",MatchSource.WIKI,root/html534/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyle.html
https://root.cern/root/html534/TStyle.html:33765,Availability,error,error,33765,"mode.; The parameter mode can be = pcev (default = 0111); p = 1; print Probability; c = 1; print Chisquare/Number of degress of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters; Example: gStyle->SetOptFit(1011);; print fit probability, parameter names/values and errors.; When ""v""=1 is specified, only the non-fixed parameters are shown.; When ""v""=2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent to; gStyle->SetOptFit(111). see also SetOptStat below. void SetOptStat(Int_t stat = 1); The type of information printed in the histogram statistics box; can be selected via the parameter mode.; The parameter mode can be = ksiourmen (default = 000001111); k = 1; kurtosis printed; k = 2; kurtosis and kurtosis error printed; s = 1; skewness printed; s = 2; skewness and skewness error printed; i = 1; integral of bins printed; i = 2; integral of bins with option ""width"" printed; o = 1; number of overflows printed; u = 1; number of underflows printed; r = 1; rms printed; r = 2; rms and rms error printed; m = 1; mean value printed; m = 2; mean and mean error values printed; e = 1; number of entries printed; n = 1; name of histogram is printed; Example: gStyle->SetOptStat(11);; print only name of histogram and number of entries.; gStyle->SetOptStat(1101); displays the name of histogram, mean value and RMS.; WARNING: never call SetOptStat(000111); but SetOptStat(1111), 0001111 will; be taken as an octal number !!; WARNING: SetOptStat(1) is taken as SetOptStat(1111) (for back compatibility; with older versions. If you want to print only the name of the histogram; call SetOptStat(1000000001).; NOTE that in case of 2-D histograms, when selecting just underflow (10000); or overflow (100000), the stats box will show all combinations; of underflow/overflows and not just one single number!. void SetOptStat(Option_t* stat); The parameter mode can be any combination of kKsSiourRmMen; k : kurtosis printed;",MatchSource.WIKI,root/html534/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyle.html
https://root.cern/root/html534/TStyle.html:34650,Availability,error,error,34650," 1; name of histogram is printed; Example: gStyle->SetOptStat(11);; print only name of histogram and number of entries.; gStyle->SetOptStat(1101); displays the name of histogram, mean value and RMS.; WARNING: never call SetOptStat(000111); but SetOptStat(1111), 0001111 will; be taken as an octal number !!; WARNING: SetOptStat(1) is taken as SetOptStat(1111) (for back compatibility; with older versions. If you want to print only the name of the histogram; call SetOptStat(1000000001).; NOTE that in case of 2-D histograms, when selecting just underflow (10000); or overflow (100000), the stats box will show all combinations; of underflow/overflows and not just one single number!. void SetOptStat(Option_t* stat); The parameter mode can be any combination of kKsSiourRmMen; k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; I : integral of bins with option ""width"" printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed; Example: gStyle->SetOptStat(""ne"");; print only name of histogram and number of entries.; gStyle->SetOptStat(""n"") print only the name of the histogram; gStyle->SetOptStat(""nemr"") is the default. void SetPaperSize(TStyle::EPaperSize size); Set paper size for PostScript output. void SetPaperSize(Float_t xsize = 20, Float_t ysize = 26); Set paper size for PostScript output.; The paper size is specified in centimeters. Default is 20x26.; See also TPad::Print. void SetTickLength(Float_t length = 0.03, Option_t* axis = ""X""); Set the tick marks length for an axis.; axis specifies which axis (""x"",""y"",""z""), default = ""x""; if axis=""xyz"" set all 3 axes. void SetTitleColor(Color_t color = 1, Option_t* axis = ""X""); if axis ==""x"" set the X axis title color; if axis ==""y"" set ",MatchSource.WIKI,root/html534/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyle.html
https://root.cern/root/html534/TStyle.html:34713,Availability,error,error,34713," 1; name of histogram is printed; Example: gStyle->SetOptStat(11);; print only name of histogram and number of entries.; gStyle->SetOptStat(1101); displays the name of histogram, mean value and RMS.; WARNING: never call SetOptStat(000111); but SetOptStat(1111), 0001111 will; be taken as an octal number !!; WARNING: SetOptStat(1) is taken as SetOptStat(1111) (for back compatibility; with older versions. If you want to print only the name of the histogram; call SetOptStat(1000000001).; NOTE that in case of 2-D histograms, when selecting just underflow (10000); or overflow (100000), the stats box will show all combinations; of underflow/overflows and not just one single number!. void SetOptStat(Option_t* stat); The parameter mode can be any combination of kKsSiourRmMen; k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; I : integral of bins with option ""width"" printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed; Example: gStyle->SetOptStat(""ne"");; print only name of histogram and number of entries.; gStyle->SetOptStat(""n"") print only the name of the histogram; gStyle->SetOptStat(""nemr"") is the default. void SetPaperSize(TStyle::EPaperSize size); Set paper size for PostScript output. void SetPaperSize(Float_t xsize = 20, Float_t ysize = 26); Set paper size for PostScript output.; The paper size is specified in centimeters. Default is 20x26.; See also TPad::Print. void SetTickLength(Float_t length = 0.03, Option_t* axis = ""X""); Set the tick marks length for an axis.; axis specifies which axis (""x"",""y"",""z""), default = ""x""; if axis=""xyz"" set all 3 axes. void SetTitleColor(Color_t color = 1, Option_t* axis = ""X""); if axis ==""x"" set the X axis title color; if axis ==""y"" set ",MatchSource.WIKI,root/html534/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyle.html
https://root.cern/root/html534/TStyle.html:34908,Availability,error,error,34908," 1; name of histogram is printed; Example: gStyle->SetOptStat(11);; print only name of histogram and number of entries.; gStyle->SetOptStat(1101); displays the name of histogram, mean value and RMS.; WARNING: never call SetOptStat(000111); but SetOptStat(1111), 0001111 will; be taken as an octal number !!; WARNING: SetOptStat(1) is taken as SetOptStat(1111) (for back compatibility; with older versions. If you want to print only the name of the histogram; call SetOptStat(1000000001).; NOTE that in case of 2-D histograms, when selecting just underflow (10000); or overflow (100000), the stats box will show all combinations; of underflow/overflows and not just one single number!. void SetOptStat(Option_t* stat); The parameter mode can be any combination of kKsSiourRmMen; k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; I : integral of bins with option ""width"" printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed; Example: gStyle->SetOptStat(""ne"");; print only name of histogram and number of entries.; gStyle->SetOptStat(""n"") print only the name of the histogram; gStyle->SetOptStat(""nemr"") is the default. void SetPaperSize(TStyle::EPaperSize size); Set paper size for PostScript output. void SetPaperSize(Float_t xsize = 20, Float_t ysize = 26); Set paper size for PostScript output.; The paper size is specified in centimeters. Default is 20x26.; See also TPad::Print. void SetTickLength(Float_t length = 0.03, Option_t* axis = ""X""); Set the tick marks length for an axis.; axis specifies which axis (""x"",""y"",""z""), default = ""x""; if axis=""xyz"" set all 3 axes. void SetTitleColor(Color_t color = 1, Option_t* axis = ""X""); if axis ==""x"" set the X axis title color; if axis ==""y"" set ",MatchSource.WIKI,root/html534/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyle.html
https://root.cern/root/html534/TStyle.html:34967,Availability,error,error,34967," 1; name of histogram is printed; Example: gStyle->SetOptStat(11);; print only name of histogram and number of entries.; gStyle->SetOptStat(1101); displays the name of histogram, mean value and RMS.; WARNING: never call SetOptStat(000111); but SetOptStat(1111), 0001111 will; be taken as an octal number !!; WARNING: SetOptStat(1) is taken as SetOptStat(1111) (for back compatibility; with older versions. If you want to print only the name of the histogram; call SetOptStat(1000000001).; NOTE that in case of 2-D histograms, when selecting just underflow (10000); or overflow (100000), the stats box will show all combinations; of underflow/overflows and not just one single number!. void SetOptStat(Option_t* stat); The parameter mode can be any combination of kKsSiourRmMen; k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; I : integral of bins with option ""width"" printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed; Example: gStyle->SetOptStat(""ne"");; print only name of histogram and number of entries.; gStyle->SetOptStat(""n"") print only the name of the histogram; gStyle->SetOptStat(""nemr"") is the default. void SetPaperSize(TStyle::EPaperSize size); Set paper size for PostScript output. void SetPaperSize(Float_t xsize = 20, Float_t ysize = 26); Set paper size for PostScript output.; The paper size is specified in centimeters. Default is 20x26.; See also TPad::Print. void SetTickLength(Float_t length = 0.03, Option_t* axis = ""X""); Set the tick marks length for an axis.; axis specifies which axis (""x"",""y"",""z""), default = ""x""; if axis=""xyz"" set all 3 axes. void SetTitleColor(Color_t color = 1, Option_t* axis = ""X""); if axis ==""x"" set the X axis title color; if axis ==""y"" set ",MatchSource.WIKI,root/html534/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyle.html
https://root.cern/root/html534/TStyle.html:44851,Availability,error,errorx,44851,"ScalePS() const; {return fLineScalePS;}. Bool_t IsReading() const; {return fIsReading;}. void SetFitFormat(const char* format = ""5.4g""); {fFitFormat = format;}. void SetHatchesLineWidth(Int_t l); {fHatchesLineWidth = l;}. void SetHatchesSpacing(Double_t h); {fHatchesSpacing = TMath::Max(0.1,h);}. void SetLineScalePS(Float_t scale = 3); {fLineScalePS=scale;}. void SetLegoInnerR(Float_t rad = 0.5); {fLegoInnerR = rad;}. void SetScreenFactor(Float_t factor = 1); {fScreenFactor = factor;}. void SetOptFile(Int_t file = 1); {fOptFile = file;}. void SetOptLogx(Int_t logx = 1); {fOptLogx = logx;}. void SetOptLogy(Int_t logy = 1); {fOptLogy = logy;}. void SetOptLogz(Int_t logz = 1); {fOptLogz = logz;}. void SetOptTitle(Int_t tit = 1); {fOptTitle = tit;}. void SetBarOffset(Float_t baroff = 0.5); {fBarOffset = baroff;}. void SetBarWidth(Float_t barwidth = 0.5); {fBarWidth = barwidth;}. void SetDateX(Float_t x = 0.01); {fDateX = x;}. void SetDateY(Float_t y = 0.01); {fDateY = y;}. void SetErrorX(Float_t errorx = 0.5); {fErrorX = errorx;}. void SetCanvasPreferGL(Bool_t prefer = kTRUE); {fCanvasPreferGL=prefer;}. void SetDrawBorder(Int_t drawborder = 1); {fDrawBorder = drawborder;}. void SetCanvasColor(Color_t color = 19); {fCanvasColor = color;}. void SetCanvasBorderSize(Width_t size = 1); {fCanvasBorderSize = size;}. void SetCanvasBorderMode(Int_t mode = 1); {fCanvasBorderMode = mode;}. void SetCanvasDefH(Int_t h = 500); {fCanvasDefH = h;}. void SetCanvasDefW(Int_t w = 700); {fCanvasDefW = w;}. void SetCanvasDefX(Int_t topx = 10); {fCanvasDefX = topx;}. void SetCanvasDefY(Int_t topy = 10); {fCanvasDefY = topy;}. void SetLegendBorderSize(Width_t size = 4); {fLegendBorderSize = size;}. void SetLegendFillColor(Color_t color = 0); {fLegendFillColor = color;}. void SetLegendFont(Style_t font = 62); {fLegendFont = font;}. void SetPadColor(Color_t color = 19); {fPadColor = color;}. void SetPadBorderSize(Width_t size = 1); {fPadBorderSize = size;}. void SetPadBorderMode(Int_t mode = 1);",MatchSource.WIKI,root/html534/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyle.html
https://root.cern/root/html534/TStyle.html:44877,Availability,error,errorx,44877,"ScalePS;}. Bool_t IsReading() const; {return fIsReading;}. void SetFitFormat(const char* format = ""5.4g""); {fFitFormat = format;}. void SetHatchesLineWidth(Int_t l); {fHatchesLineWidth = l;}. void SetHatchesSpacing(Double_t h); {fHatchesSpacing = TMath::Max(0.1,h);}. void SetLineScalePS(Float_t scale = 3); {fLineScalePS=scale;}. void SetLegoInnerR(Float_t rad = 0.5); {fLegoInnerR = rad;}. void SetScreenFactor(Float_t factor = 1); {fScreenFactor = factor;}. void SetOptFile(Int_t file = 1); {fOptFile = file;}. void SetOptLogx(Int_t logx = 1); {fOptLogx = logx;}. void SetOptLogy(Int_t logy = 1); {fOptLogy = logy;}. void SetOptLogz(Int_t logz = 1); {fOptLogz = logz;}. void SetOptTitle(Int_t tit = 1); {fOptTitle = tit;}. void SetBarOffset(Float_t baroff = 0.5); {fBarOffset = baroff;}. void SetBarWidth(Float_t barwidth = 0.5); {fBarWidth = barwidth;}. void SetDateX(Float_t x = 0.01); {fDateX = x;}. void SetDateY(Float_t y = 0.01); {fDateY = y;}. void SetErrorX(Float_t errorx = 0.5); {fErrorX = errorx;}. void SetCanvasPreferGL(Bool_t prefer = kTRUE); {fCanvasPreferGL=prefer;}. void SetDrawBorder(Int_t drawborder = 1); {fDrawBorder = drawborder;}. void SetCanvasColor(Color_t color = 19); {fCanvasColor = color;}. void SetCanvasBorderSize(Width_t size = 1); {fCanvasBorderSize = size;}. void SetCanvasBorderMode(Int_t mode = 1); {fCanvasBorderMode = mode;}. void SetCanvasDefH(Int_t h = 500); {fCanvasDefH = h;}. void SetCanvasDefW(Int_t w = 700); {fCanvasDefW = w;}. void SetCanvasDefX(Int_t topx = 10); {fCanvasDefX = topx;}. void SetCanvasDefY(Int_t topy = 10); {fCanvasDefY = topy;}. void SetLegendBorderSize(Width_t size = 4); {fLegendBorderSize = size;}. void SetLegendFillColor(Color_t color = 0); {fLegendFillColor = color;}. void SetLegendFont(Style_t font = 62); {fLegendFont = font;}. void SetPadColor(Color_t color = 19); {fPadColor = color;}. void SetPadBorderSize(Width_t size = 1); {fPadBorderSize = size;}. void SetPadBorderMode(Int_t mode = 1); {fPadBorderMode = mode;}. vo",MatchSource.WIKI,root/html534/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyle.html
https://root.cern/root/html534/TStyle.html:29258,Performance,scalab,scalable,29258,"er of the page (outside the user area); ""gsave 100 -100 t 0 r 0 0 m /Helvetica-Bold findfont 56 sf 0 0 m ( my annotation ) show gr""; This information is used in TPostScript::Initialize. void SetIsReading(Bool_t reading = kTRUE); Sets the fIsReading member to reading (default=kTRUE); fIsReading (used via gStyle->IsReading()) can be used in; the functions myclass::UseCurrentStyle to read from the current style; or write to the current style. void SetTitlePS(const char* pstitle); Define a string to be used in the %%Title of the Postscript files.; If this string is not defined, ROOT will use the canvas title. void SetLabelColor(Color_t color = 1, Option_t* axis = ""X""); Set axis labels color.; axis specifies which axis (""x"",""y"",""z""), default = ""x""; if axis=""xyz"" set all 3 axes. void SetLabelFont(Style_t font = 62, Option_t* axis = ""X""); Set font number used to draw axis labels.; font : Text font code = 10*fontnumber + precision; Font numbers must be between 1 and 14; precision = 1 fast hardware fonts (steps in the size); precision = 2 scalable and rotatable hardware fonts; The default font number is 62.; axis specifies which axis (""x"",""y"",""z""), default = ""x""; if axis=""xyz"" set all 3 axes. void SetLabelOffset(Float_t offset = 0.005, Option_t* axis = ""X""); Set offset between axis and axis labels.; The offset is expressed as a percent of the pad height.; axis specifies which axis (""x"",""y"",""z""), default = ""x""; if axis=""xyz"" set all 3 axes. void SetLabelSize(Float_t size = 0.04, Option_t* axis = ""X""); Set size of axis labels. The size is expressed as a percent of the pad height.; axis specifies which axis (""x"",""y"",""z""), default = ""x""; if axis=""xyz"" set all 3 axes. void SetLineStyleString(Int_t i, const char* text); Set line style string using the PostScript convention.; A line is a suite of segments, each segment is described by the number of; pixels. The initial and alternating elements (second, fourth, and so on); are the dashes, and the others spaces between dashes. Defaul",MatchSource.WIKI,root/html534/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyle.html
https://root.cern/root/html534/TStyle.html:457,Security,access,accessed,457,". TStyle. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TStyle. class TStyle: public TNamed, public TAttLine, public TAttFill, public TAttMarker, public TAttText. TStyle objects may be created to define special styles.; By default ROOT creates a default style that can be accessed via; the gStyle pointer. This class includes functions to set some of the following object attributes.; - Canvas; - Pad; - Histogram axis; - Lines; - Fill areas; - Text; - Markers; - Functions; - Histogram Statistics and Titles. Function Members (Methods); public:. TStyle(); TStyle(const TStyle& style); TStyle(const char* name, const char* title); virtual~TStyle(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Int_tAxisChoice(Option_t* axis) const; virtual voidBrowse(TBrowser* b); static voidBuildStyles(); virtual voidcd(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject& style) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error",MatchSource.WIKI,root/html534/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyle.html
https://root.cern/root/html534/TStyle.html:13256,Testability,log,logx,13256,"e_t font = 62, Option_t* axis = ""X""); voidSetLabelOffset(Float_t offset = 0.005, Option_t* axis = ""X""); voidSetLabelSize(Float_t size = 0.04, Option_t* axis = ""X""); voidSetLegendBorderSize(Width_t size = 4); voidSetLegendFillColor(Color_t color = 0); voidSetLegendFont(Style_t font = 62); voidSetLegoInnerR(Float_t rad = 0.5); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); voidSetLineScalePS(Float_t scale = 3); virtual voidTAttLine::SetLineStyle(Style_t lstyle); voidSetLineStyleString(Int_t i, const char* text); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTAttMarker::SetMarkerAttributes()MENU ; virtual voidTAttMarker::SetMarkerColor(Color_t mcolor = 1); virtual voidTAttMarker::SetMarkerColorAlpha(Color_t mcolor, Float_t malpha); virtual voidTAttMarker::SetMarkerSize(Size_t msize = 1); virtual voidTAttMarker::SetMarkerStyle(Style_t mstyle = 1); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidSetNdivisions(Int_t n = 510, Option_t* axis = ""X""); voidSetNumberContours(Int_t number = 20); static voidTObject::SetObjectStat(Bool_t stat); voidSetOptDate(Int_t datefl = 1); voidSetOptFile(Int_t file = 1); voidSetOptFit(Int_t fit = 1); voidSetOptLogx(Int_t logx = 1); voidSetOptLogy(Int_t logy = 1); voidSetOptLogz(Int_t logz = 1); voidSetOptStat(Int_t stat = 1); voidSetOptStat(Option_t* stat); voidSetOptTitle(Int_t tit = 1); voidSetPadBorderMode(Int_t mode = 1); voidSetPadBorderSize(Width_t size = 1); voidSetPadBottomMargin(Float_t margin = 0.1); voidSetPadColor(Color_t color = 19); voidSetPadGridX(Bool_t gridx); voidSetPadGridY(Bool_t gridy); voidSetPadLeftMargin(Float_t margin = 0.1); voidSetPadRightMargin(Float_t margin = 0.1); voidSetPadTickX(Int_t tickx); voidSetPadTickY(Int_t ticky); voidSetPadTopMargin(Float_t margin = 0.1); voidSetPaintTextFormat(const",MatchSource.WIKI,root/html534/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyle.html
https://root.cern/root/html534/TStyle.html:13288,Testability,log,logy,13288,"e_t font = 62, Option_t* axis = ""X""); voidSetLabelOffset(Float_t offset = 0.005, Option_t* axis = ""X""); voidSetLabelSize(Float_t size = 0.04, Option_t* axis = ""X""); voidSetLegendBorderSize(Width_t size = 4); voidSetLegendFillColor(Color_t color = 0); voidSetLegendFont(Style_t font = 62); voidSetLegoInnerR(Float_t rad = 0.5); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); voidSetLineScalePS(Float_t scale = 3); virtual voidTAttLine::SetLineStyle(Style_t lstyle); voidSetLineStyleString(Int_t i, const char* text); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTAttMarker::SetMarkerAttributes()MENU ; virtual voidTAttMarker::SetMarkerColor(Color_t mcolor = 1); virtual voidTAttMarker::SetMarkerColorAlpha(Color_t mcolor, Float_t malpha); virtual voidTAttMarker::SetMarkerSize(Size_t msize = 1); virtual voidTAttMarker::SetMarkerStyle(Style_t mstyle = 1); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidSetNdivisions(Int_t n = 510, Option_t* axis = ""X""); voidSetNumberContours(Int_t number = 20); static voidTObject::SetObjectStat(Bool_t stat); voidSetOptDate(Int_t datefl = 1); voidSetOptFile(Int_t file = 1); voidSetOptFit(Int_t fit = 1); voidSetOptLogx(Int_t logx = 1); voidSetOptLogy(Int_t logy = 1); voidSetOptLogz(Int_t logz = 1); voidSetOptStat(Int_t stat = 1); voidSetOptStat(Option_t* stat); voidSetOptTitle(Int_t tit = 1); voidSetPadBorderMode(Int_t mode = 1); voidSetPadBorderSize(Width_t size = 1); voidSetPadBottomMargin(Float_t margin = 0.1); voidSetPadColor(Color_t color = 19); voidSetPadGridX(Bool_t gridx); voidSetPadGridY(Bool_t gridy); voidSetPadLeftMargin(Float_t margin = 0.1); voidSetPadRightMargin(Float_t margin = 0.1); voidSetPadTickX(Int_t tickx); voidSetPadTickY(Int_t ticky); voidSetPadTopMargin(Float_t margin = 0.1); voidSetPaintTextFormat(const",MatchSource.WIKI,root/html534/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyle.html
https://root.cern/root/html534/TStyle.html:13320,Testability,log,logz,13320,"e_t font = 62, Option_t* axis = ""X""); voidSetLabelOffset(Float_t offset = 0.005, Option_t* axis = ""X""); voidSetLabelSize(Float_t size = 0.04, Option_t* axis = ""X""); voidSetLegendBorderSize(Width_t size = 4); voidSetLegendFillColor(Color_t color = 0); voidSetLegendFont(Style_t font = 62); voidSetLegoInnerR(Float_t rad = 0.5); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); voidSetLineScalePS(Float_t scale = 3); virtual voidTAttLine::SetLineStyle(Style_t lstyle); voidSetLineStyleString(Int_t i, const char* text); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTAttMarker::SetMarkerAttributes()MENU ; virtual voidTAttMarker::SetMarkerColor(Color_t mcolor = 1); virtual voidTAttMarker::SetMarkerColorAlpha(Color_t mcolor, Float_t malpha); virtual voidTAttMarker::SetMarkerSize(Size_t msize = 1); virtual voidTAttMarker::SetMarkerStyle(Style_t mstyle = 1); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidSetNdivisions(Int_t n = 510, Option_t* axis = ""X""); voidSetNumberContours(Int_t number = 20); static voidTObject::SetObjectStat(Bool_t stat); voidSetOptDate(Int_t datefl = 1); voidSetOptFile(Int_t file = 1); voidSetOptFit(Int_t fit = 1); voidSetOptLogx(Int_t logx = 1); voidSetOptLogy(Int_t logy = 1); voidSetOptLogz(Int_t logz = 1); voidSetOptStat(Int_t stat = 1); voidSetOptStat(Option_t* stat); voidSetOptTitle(Int_t tit = 1); voidSetPadBorderMode(Int_t mode = 1); voidSetPadBorderSize(Width_t size = 1); voidSetPadBottomMargin(Float_t margin = 0.1); voidSetPadColor(Color_t color = 19); voidSetPadGridX(Bool_t gridx); voidSetPadGridY(Bool_t gridy); voidSetPadLeftMargin(Float_t margin = 0.1); voidSetPadRightMargin(Float_t margin = 0.1); voidSetPadTickX(Int_t tickx); voidSetPadTickY(Int_t ticky); voidSetPadTopMargin(Float_t margin = 0.1); voidSetPaintTextFormat(const",MatchSource.WIKI,root/html534/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyle.html
https://root.cern/root/html534/TStyle.html:20418,Testability,log,log,20418,"der; Color_tfHistFillColorhistogram fill color; Style_tfHistFillStylehistogram fill style; Color_tfHistLineColorhistogram line color; Style_tfHistLineStylehistogram line style; Width_tfHistLineWidthhistogram line width; Bool_tfHistMinimumZerotrue if default minimum is 0, false if minimum is automatic; Double_tfHistTopMarginmargin between histogram's top and pad's top; Bool_tfIsReading!Set to FALSE when userclass::UseCurrentStyle is called by the style manager; Width_tfLegendBorderSizelegend box border size; Color_tfLegendFillColorlegend fill color; Style_tfLegendFontlegend font style; Float_tfLegoInnerRInner radius for cylindrical legos; Float_tfLineScalePSLine scale factor when drawing lines on Postscript; TStringfLineStyle[30]String describing line style i (for postScript); Int_tfNumberContoursdefault number of contours for 2-d plots; Int_tfOptDate=1 if date option is selected; Int_tfOptFile=1 if option File is selected; Int_tfOptFit=1 if option Fit is selected; Int_tfOptLogx=1 if log scale in X; Int_tfOptLogy=1 if log scale in y; Int_tfOptLogz=1 if log scale in z; Int_tfOptStat=1 if option Stat is selected; Int_tfOptTitle=1 if option Title is selected; Int_tfPadBorderModepad border mode; Width_tfPadBorderSizepad border size; Float_tfPadBottomMarginpad bottom margin; Color_tfPadColorpad color; Bool_tfPadGridXtrue to get the grid along X; Bool_tfPadGridYtrue to get the grid along Y; Float_tfPadLeftMarginpad left margin; Float_tfPadRightMarginpad right margin; Int_tfPadTickX=1 to set special pad ticks along X; Int_tfPadTickY=1 to set special pad ticks along Y; Float_tfPadTopMarginpad top margin; TStringfPaintTextFormatPrinting format for TH2::PaintText; Float_tfPaperSizeXPostScript paper size along X; Float_tfPaperSizeYPostScript paper size along Y; Float_tfScreenFactorMultiplication factor for canvas size and position; Int_tfShowEditorShow pad editor; Int_tfShowEventStatusShow event status panel; Int_tfShowToolBarShow toolbar; Width_tfStatBorderSizeborder size of S",MatchSource.WIKI,root/html534/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyle.html
https://root.cern/root/html534/TStyle.html:20453,Testability,log,log,20453," fill color; Style_tfHistFillStylehistogram fill style; Color_tfHistLineColorhistogram line color; Style_tfHistLineStylehistogram line style; Width_tfHistLineWidthhistogram line width; Bool_tfHistMinimumZerotrue if default minimum is 0, false if minimum is automatic; Double_tfHistTopMarginmargin between histogram's top and pad's top; Bool_tfIsReading!Set to FALSE when userclass::UseCurrentStyle is called by the style manager; Width_tfLegendBorderSizelegend box border size; Color_tfLegendFillColorlegend fill color; Style_tfLegendFontlegend font style; Float_tfLegoInnerRInner radius for cylindrical legos; Float_tfLineScalePSLine scale factor when drawing lines on Postscript; TStringfLineStyle[30]String describing line style i (for postScript); Int_tfNumberContoursdefault number of contours for 2-d plots; Int_tfOptDate=1 if date option is selected; Int_tfOptFile=1 if option File is selected; Int_tfOptFit=1 if option Fit is selected; Int_tfOptLogx=1 if log scale in X; Int_tfOptLogy=1 if log scale in y; Int_tfOptLogz=1 if log scale in z; Int_tfOptStat=1 if option Stat is selected; Int_tfOptTitle=1 if option Title is selected; Int_tfPadBorderModepad border mode; Width_tfPadBorderSizepad border size; Float_tfPadBottomMarginpad bottom margin; Color_tfPadColorpad color; Bool_tfPadGridXtrue to get the grid along X; Bool_tfPadGridYtrue to get the grid along Y; Float_tfPadLeftMarginpad left margin; Float_tfPadRightMarginpad right margin; Int_tfPadTickX=1 to set special pad ticks along X; Int_tfPadTickY=1 to set special pad ticks along Y; Float_tfPadTopMarginpad top margin; TStringfPaintTextFormatPrinting format for TH2::PaintText; Float_tfPaperSizeXPostScript paper size along X; Float_tfPaperSizeYPostScript paper size along Y; Float_tfScreenFactorMultiplication factor for canvas size and position; Int_tfShowEditorShow pad editor; Int_tfShowEventStatusShow event status panel; Int_tfShowToolBarShow toolbar; Width_tfStatBorderSizeborder size of Stats PaveLabel; Color_tfStatColorst",MatchSource.WIKI,root/html534/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyle.html
https://root.cern/root/html534/TStyle.html:20488,Testability,log,log,20488,"istogram fill style; Color_tfHistLineColorhistogram line color; Style_tfHistLineStylehistogram line style; Width_tfHistLineWidthhistogram line width; Bool_tfHistMinimumZerotrue if default minimum is 0, false if minimum is automatic; Double_tfHistTopMarginmargin between histogram's top and pad's top; Bool_tfIsReading!Set to FALSE when userclass::UseCurrentStyle is called by the style manager; Width_tfLegendBorderSizelegend box border size; Color_tfLegendFillColorlegend fill color; Style_tfLegendFontlegend font style; Float_tfLegoInnerRInner radius for cylindrical legos; Float_tfLineScalePSLine scale factor when drawing lines on Postscript; TStringfLineStyle[30]String describing line style i (for postScript); Int_tfNumberContoursdefault number of contours for 2-d plots; Int_tfOptDate=1 if date option is selected; Int_tfOptFile=1 if option File is selected; Int_tfOptFit=1 if option Fit is selected; Int_tfOptLogx=1 if log scale in X; Int_tfOptLogy=1 if log scale in y; Int_tfOptLogz=1 if log scale in z; Int_tfOptStat=1 if option Stat is selected; Int_tfOptTitle=1 if option Title is selected; Int_tfPadBorderModepad border mode; Width_tfPadBorderSizepad border size; Float_tfPadBottomMarginpad bottom margin; Color_tfPadColorpad color; Bool_tfPadGridXtrue to get the grid along X; Bool_tfPadGridYtrue to get the grid along Y; Float_tfPadLeftMarginpad left margin; Float_tfPadRightMarginpad right margin; Int_tfPadTickX=1 to set special pad ticks along X; Int_tfPadTickY=1 to set special pad ticks along Y; Float_tfPadTopMarginpad top margin; TStringfPaintTextFormatPrinting format for TH2::PaintText; Float_tfPaperSizeXPostScript paper size along X; Float_tfPaperSizeYPostScript paper size along Y; Float_tfScreenFactorMultiplication factor for canvas size and position; Int_tfShowEditorShow pad editor; Int_tfShowEventStatusShow event status panel; Int_tfShowToolBarShow toolbar; Width_tfStatBorderSizeborder size of Stats PaveLabel; Color_tfStatColorstat fill area color; Style_tfStatFon",MatchSource.WIKI,root/html534/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyle.html
https://root.cern/root/html534/TStyle.html:44410,Testability,log,logx,44410,"leYOffset() const; {return GetTitleOffset(""Y"");}. Float_t GetTitleYSize() const; {return GetTitleSize(""Y"");}. Float_t GetTitleX() const; {return fTitleX;}. Float_t GetTitleY() const; {return fTitleY;}. Float_t GetTitleW() const; {return fTitleW;}. Float_t GetTitleH() const; {return fTitleH;}. const char * GetHeaderPS() const; {return fHeaderPS.Data();}. const char * GetTitlePS() const; {return fTitlePS.Data();}. Float_t GetLineScalePS() const; {return fLineScalePS;}. Bool_t IsReading() const; {return fIsReading;}. void SetFitFormat(const char* format = ""5.4g""); {fFitFormat = format;}. void SetHatchesLineWidth(Int_t l); {fHatchesLineWidth = l;}. void SetHatchesSpacing(Double_t h); {fHatchesSpacing = TMath::Max(0.1,h);}. void SetLineScalePS(Float_t scale = 3); {fLineScalePS=scale;}. void SetLegoInnerR(Float_t rad = 0.5); {fLegoInnerR = rad;}. void SetScreenFactor(Float_t factor = 1); {fScreenFactor = factor;}. void SetOptFile(Int_t file = 1); {fOptFile = file;}. void SetOptLogx(Int_t logx = 1); {fOptLogx = logx;}. void SetOptLogy(Int_t logy = 1); {fOptLogy = logy;}. void SetOptLogz(Int_t logz = 1); {fOptLogz = logz;}. void SetOptTitle(Int_t tit = 1); {fOptTitle = tit;}. void SetBarOffset(Float_t baroff = 0.5); {fBarOffset = baroff;}. void SetBarWidth(Float_t barwidth = 0.5); {fBarWidth = barwidth;}. void SetDateX(Float_t x = 0.01); {fDateX = x;}. void SetDateY(Float_t y = 0.01); {fDateY = y;}. void SetErrorX(Float_t errorx = 0.5); {fErrorX = errorx;}. void SetCanvasPreferGL(Bool_t prefer = kTRUE); {fCanvasPreferGL=prefer;}. void SetDrawBorder(Int_t drawborder = 1); {fDrawBorder = drawborder;}. void SetCanvasColor(Color_t color = 19); {fCanvasColor = color;}. void SetCanvasBorderSize(Width_t size = 1); {fCanvasBorderSize = size;}. void SetCanvasBorderMode(Int_t mode = 1); {fCanvasBorderMode = mode;}. void SetCanvasDefH(Int_t h = 500); {fCanvasDefH = h;}. void SetCanvasDefW(Int_t w = 700); {fCanvasDefW = w;}. void SetCanvasDefX(Int_t topx = 10); {fCanvasDefX = topx;}. vo",MatchSource.WIKI,root/html534/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyle.html
https://root.cern/root/html534/TStyle.html:44433,Testability,log,logx,44433,"leYOffset() const; {return GetTitleOffset(""Y"");}. Float_t GetTitleYSize() const; {return GetTitleSize(""Y"");}. Float_t GetTitleX() const; {return fTitleX;}. Float_t GetTitleY() const; {return fTitleY;}. Float_t GetTitleW() const; {return fTitleW;}. Float_t GetTitleH() const; {return fTitleH;}. const char * GetHeaderPS() const; {return fHeaderPS.Data();}. const char * GetTitlePS() const; {return fTitlePS.Data();}. Float_t GetLineScalePS() const; {return fLineScalePS;}. Bool_t IsReading() const; {return fIsReading;}. void SetFitFormat(const char* format = ""5.4g""); {fFitFormat = format;}. void SetHatchesLineWidth(Int_t l); {fHatchesLineWidth = l;}. void SetHatchesSpacing(Double_t h); {fHatchesSpacing = TMath::Max(0.1,h);}. void SetLineScalePS(Float_t scale = 3); {fLineScalePS=scale;}. void SetLegoInnerR(Float_t rad = 0.5); {fLegoInnerR = rad;}. void SetScreenFactor(Float_t factor = 1); {fScreenFactor = factor;}. void SetOptFile(Int_t file = 1); {fOptFile = file;}. void SetOptLogx(Int_t logx = 1); {fOptLogx = logx;}. void SetOptLogy(Int_t logy = 1); {fOptLogy = logy;}. void SetOptLogz(Int_t logz = 1); {fOptLogz = logz;}. void SetOptTitle(Int_t tit = 1); {fOptTitle = tit;}. void SetBarOffset(Float_t baroff = 0.5); {fBarOffset = baroff;}. void SetBarWidth(Float_t barwidth = 0.5); {fBarWidth = barwidth;}. void SetDateX(Float_t x = 0.01); {fDateX = x;}. void SetDateY(Float_t y = 0.01); {fDateY = y;}. void SetErrorX(Float_t errorx = 0.5); {fErrorX = errorx;}. void SetCanvasPreferGL(Bool_t prefer = kTRUE); {fCanvasPreferGL=prefer;}. void SetDrawBorder(Int_t drawborder = 1); {fDrawBorder = drawborder;}. void SetCanvasColor(Color_t color = 19); {fCanvasColor = color;}. void SetCanvasBorderSize(Width_t size = 1); {fCanvasBorderSize = size;}. void SetCanvasBorderMode(Int_t mode = 1); {fCanvasBorderMode = mode;}. void SetCanvasDefH(Int_t h = 500); {fCanvasDefH = h;}. void SetCanvasDefW(Int_t w = 700); {fCanvasDefW = w;}. void SetCanvasDefX(Int_t topx = 10); {fCanvasDefX = topx;}. vo",MatchSource.WIKI,root/html534/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyle.html
https://root.cern/root/html534/TStyle.html:44463,Testability,log,logy,44463,"at_t GetTitleYSize() const; {return GetTitleSize(""Y"");}. Float_t GetTitleX() const; {return fTitleX;}. Float_t GetTitleY() const; {return fTitleY;}. Float_t GetTitleW() const; {return fTitleW;}. Float_t GetTitleH() const; {return fTitleH;}. const char * GetHeaderPS() const; {return fHeaderPS.Data();}. const char * GetTitlePS() const; {return fTitlePS.Data();}. Float_t GetLineScalePS() const; {return fLineScalePS;}. Bool_t IsReading() const; {return fIsReading;}. void SetFitFormat(const char* format = ""5.4g""); {fFitFormat = format;}. void SetHatchesLineWidth(Int_t l); {fHatchesLineWidth = l;}. void SetHatchesSpacing(Double_t h); {fHatchesSpacing = TMath::Max(0.1,h);}. void SetLineScalePS(Float_t scale = 3); {fLineScalePS=scale;}. void SetLegoInnerR(Float_t rad = 0.5); {fLegoInnerR = rad;}. void SetScreenFactor(Float_t factor = 1); {fScreenFactor = factor;}. void SetOptFile(Int_t file = 1); {fOptFile = file;}. void SetOptLogx(Int_t logx = 1); {fOptLogx = logx;}. void SetOptLogy(Int_t logy = 1); {fOptLogy = logy;}. void SetOptLogz(Int_t logz = 1); {fOptLogz = logz;}. void SetOptTitle(Int_t tit = 1); {fOptTitle = tit;}. void SetBarOffset(Float_t baroff = 0.5); {fBarOffset = baroff;}. void SetBarWidth(Float_t barwidth = 0.5); {fBarWidth = barwidth;}. void SetDateX(Float_t x = 0.01); {fDateX = x;}. void SetDateY(Float_t y = 0.01); {fDateY = y;}. void SetErrorX(Float_t errorx = 0.5); {fErrorX = errorx;}. void SetCanvasPreferGL(Bool_t prefer = kTRUE); {fCanvasPreferGL=prefer;}. void SetDrawBorder(Int_t drawborder = 1); {fDrawBorder = drawborder;}. void SetCanvasColor(Color_t color = 19); {fCanvasColor = color;}. void SetCanvasBorderSize(Width_t size = 1); {fCanvasBorderSize = size;}. void SetCanvasBorderMode(Int_t mode = 1); {fCanvasBorderMode = mode;}. void SetCanvasDefH(Int_t h = 500); {fCanvasDefH = h;}. void SetCanvasDefW(Int_t w = 700); {fCanvasDefW = w;}. void SetCanvasDefX(Int_t topx = 10); {fCanvasDefX = topx;}. void SetCanvasDefY(Int_t topy = 10); {fCanvasDefY = top",MatchSource.WIKI,root/html534/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyle.html
https://root.cern/root/html534/TStyle.html:44486,Testability,log,logy,44486,"at_t GetTitleYSize() const; {return GetTitleSize(""Y"");}. Float_t GetTitleX() const; {return fTitleX;}. Float_t GetTitleY() const; {return fTitleY;}. Float_t GetTitleW() const; {return fTitleW;}. Float_t GetTitleH() const; {return fTitleH;}. const char * GetHeaderPS() const; {return fHeaderPS.Data();}. const char * GetTitlePS() const; {return fTitlePS.Data();}. Float_t GetLineScalePS() const; {return fLineScalePS;}. Bool_t IsReading() const; {return fIsReading;}. void SetFitFormat(const char* format = ""5.4g""); {fFitFormat = format;}. void SetHatchesLineWidth(Int_t l); {fHatchesLineWidth = l;}. void SetHatchesSpacing(Double_t h); {fHatchesSpacing = TMath::Max(0.1,h);}. void SetLineScalePS(Float_t scale = 3); {fLineScalePS=scale;}. void SetLegoInnerR(Float_t rad = 0.5); {fLegoInnerR = rad;}. void SetScreenFactor(Float_t factor = 1); {fScreenFactor = factor;}. void SetOptFile(Int_t file = 1); {fOptFile = file;}. void SetOptLogx(Int_t logx = 1); {fOptLogx = logx;}. void SetOptLogy(Int_t logy = 1); {fOptLogy = logy;}. void SetOptLogz(Int_t logz = 1); {fOptLogz = logz;}. void SetOptTitle(Int_t tit = 1); {fOptTitle = tit;}. void SetBarOffset(Float_t baroff = 0.5); {fBarOffset = baroff;}. void SetBarWidth(Float_t barwidth = 0.5); {fBarWidth = barwidth;}. void SetDateX(Float_t x = 0.01); {fDateX = x;}. void SetDateY(Float_t y = 0.01); {fDateY = y;}. void SetErrorX(Float_t errorx = 0.5); {fErrorX = errorx;}. void SetCanvasPreferGL(Bool_t prefer = kTRUE); {fCanvasPreferGL=prefer;}. void SetDrawBorder(Int_t drawborder = 1); {fDrawBorder = drawborder;}. void SetCanvasColor(Color_t color = 19); {fCanvasColor = color;}. void SetCanvasBorderSize(Width_t size = 1); {fCanvasBorderSize = size;}. void SetCanvasBorderMode(Int_t mode = 1); {fCanvasBorderMode = mode;}. void SetCanvasDefH(Int_t h = 500); {fCanvasDefH = h;}. void SetCanvasDefW(Int_t w = 700); {fCanvasDefW = w;}. void SetCanvasDefX(Int_t topx = 10); {fCanvasDefX = topx;}. void SetCanvasDefY(Int_t topy = 10); {fCanvasDefY = top",MatchSource.WIKI,root/html534/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyle.html
https://root.cern/root/html534/TStyle.html:44516,Testability,log,logz,44516,";}. Float_t GetTitleX() const; {return fTitleX;}. Float_t GetTitleY() const; {return fTitleY;}. Float_t GetTitleW() const; {return fTitleW;}. Float_t GetTitleH() const; {return fTitleH;}. const char * GetHeaderPS() const; {return fHeaderPS.Data();}. const char * GetTitlePS() const; {return fTitlePS.Data();}. Float_t GetLineScalePS() const; {return fLineScalePS;}. Bool_t IsReading() const; {return fIsReading;}. void SetFitFormat(const char* format = ""5.4g""); {fFitFormat = format;}. void SetHatchesLineWidth(Int_t l); {fHatchesLineWidth = l;}. void SetHatchesSpacing(Double_t h); {fHatchesSpacing = TMath::Max(0.1,h);}. void SetLineScalePS(Float_t scale = 3); {fLineScalePS=scale;}. void SetLegoInnerR(Float_t rad = 0.5); {fLegoInnerR = rad;}. void SetScreenFactor(Float_t factor = 1); {fScreenFactor = factor;}. void SetOptFile(Int_t file = 1); {fOptFile = file;}. void SetOptLogx(Int_t logx = 1); {fOptLogx = logx;}. void SetOptLogy(Int_t logy = 1); {fOptLogy = logy;}. void SetOptLogz(Int_t logz = 1); {fOptLogz = logz;}. void SetOptTitle(Int_t tit = 1); {fOptTitle = tit;}. void SetBarOffset(Float_t baroff = 0.5); {fBarOffset = baroff;}. void SetBarWidth(Float_t barwidth = 0.5); {fBarWidth = barwidth;}. void SetDateX(Float_t x = 0.01); {fDateX = x;}. void SetDateY(Float_t y = 0.01); {fDateY = y;}. void SetErrorX(Float_t errorx = 0.5); {fErrorX = errorx;}. void SetCanvasPreferGL(Bool_t prefer = kTRUE); {fCanvasPreferGL=prefer;}. void SetDrawBorder(Int_t drawborder = 1); {fDrawBorder = drawborder;}. void SetCanvasColor(Color_t color = 19); {fCanvasColor = color;}. void SetCanvasBorderSize(Width_t size = 1); {fCanvasBorderSize = size;}. void SetCanvasBorderMode(Int_t mode = 1); {fCanvasBorderMode = mode;}. void SetCanvasDefH(Int_t h = 500); {fCanvasDefH = h;}. void SetCanvasDefW(Int_t w = 700); {fCanvasDefW = w;}. void SetCanvasDefX(Int_t topx = 10); {fCanvasDefX = topx;}. void SetCanvasDefY(Int_t topy = 10); {fCanvasDefY = topy;}. void SetLegendBorderSize(Width_t size = 4); {fLe",MatchSource.WIKI,root/html534/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyle.html
https://root.cern/root/html534/TStyle.html:44539,Testability,log,logz,44539,";}. Float_t GetTitleX() const; {return fTitleX;}. Float_t GetTitleY() const; {return fTitleY;}. Float_t GetTitleW() const; {return fTitleW;}. Float_t GetTitleH() const; {return fTitleH;}. const char * GetHeaderPS() const; {return fHeaderPS.Data();}. const char * GetTitlePS() const; {return fTitlePS.Data();}. Float_t GetLineScalePS() const; {return fLineScalePS;}. Bool_t IsReading() const; {return fIsReading;}. void SetFitFormat(const char* format = ""5.4g""); {fFitFormat = format;}. void SetHatchesLineWidth(Int_t l); {fHatchesLineWidth = l;}. void SetHatchesSpacing(Double_t h); {fHatchesSpacing = TMath::Max(0.1,h);}. void SetLineScalePS(Float_t scale = 3); {fLineScalePS=scale;}. void SetLegoInnerR(Float_t rad = 0.5); {fLegoInnerR = rad;}. void SetScreenFactor(Float_t factor = 1); {fScreenFactor = factor;}. void SetOptFile(Int_t file = 1); {fOptFile = file;}. void SetOptLogx(Int_t logx = 1); {fOptLogx = logx;}. void SetOptLogy(Int_t logy = 1); {fOptLogy = logy;}. void SetOptLogz(Int_t logz = 1); {fOptLogz = logz;}. void SetOptTitle(Int_t tit = 1); {fOptTitle = tit;}. void SetBarOffset(Float_t baroff = 0.5); {fBarOffset = baroff;}. void SetBarWidth(Float_t barwidth = 0.5); {fBarWidth = barwidth;}. void SetDateX(Float_t x = 0.01); {fDateX = x;}. void SetDateY(Float_t y = 0.01); {fDateY = y;}. void SetErrorX(Float_t errorx = 0.5); {fErrorX = errorx;}. void SetCanvasPreferGL(Bool_t prefer = kTRUE); {fCanvasPreferGL=prefer;}. void SetDrawBorder(Int_t drawborder = 1); {fDrawBorder = drawborder;}. void SetCanvasColor(Color_t color = 19); {fCanvasColor = color;}. void SetCanvasBorderSize(Width_t size = 1); {fCanvasBorderSize = size;}. void SetCanvasBorderMode(Int_t mode = 1); {fCanvasBorderMode = mode;}. void SetCanvasDefH(Int_t h = 500); {fCanvasDefH = h;}. void SetCanvasDefW(Int_t w = 700); {fCanvasDefW = w;}. void SetCanvasDefX(Int_t topx = 10); {fCanvasDefX = topx;}. void SetCanvasDefY(Int_t topy = 10); {fCanvasDefY = topy;}. void SetLegendBorderSize(Width_t size = 4); {fLe",MatchSource.WIKI,root/html534/TStyle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyle.html
https://root.cern/root/html534/TStyleDialog.html:4626,Availability,error,error,4626,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html534/TStyleDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleDialog.html
https://root.cern/root/html534/TStyleDialog.html:4710,Availability,error,error,4710,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html534/TStyleDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleDialog.html
https://root.cern/root/html534/TStyleDialog.html:19004,Availability,mask,mask,19004,,MatchSource.WIKI,root/html534/TStyleDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleDialog.html
https://root.cern/root/html534/TStyleDialog.html:23402,Integrability,message,message,23402,"GFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fCancelcancel button; TVirtualPad*fCurPadcurrent pad from which to import; TStyle*fCurStylestyle to copy or to rename; Int_tfMode1=new, 2=rename, 3=import; TGTextEntry*fNameTStyle name text entry; TGLabel*fNameLabelname label; TGTextButton*fOKsave button; TStyleManager*fStyleManagerparent style manager; TGTextEntry*fTitleTStyle title text entry; TGLabel*fTitleLabeltitle label; TList*fTrashListFrameto avoid memory leak; TList*fTrashListLayoutto avoid memory leak; TGLabel*fWarnLabellabel for warnings. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStyleDialog(TStyleManager* sm, TStyle* cur, Int_t mode, TVirtualPad* currentPad = 0); Constructor. Create the dialog window and draw it centered over the; main window 'mf'. A pointer to the style to copy or rename is given; by 'cur' and the parameter 'mode' specify the mode:; 1 = copy | 2 = rename | 3 = import from canvas. ~TStyleDialog(); Destructor. void DoCancel(); Slot called when the Cancel button is clicked. Close the window; without saving submitted changes. void DoCloseWindow(); Slot called when the window is closed via the window manager.; Close the window without saving submitted changes. void DoOK(); Slot called when the OK button is clicked. Rename or create the style; before closing the window. void DoUpdate(); Slot called every time the name is changed. Provide some protection; to avoid letting the user use an empty name or an already used one.; A warning message can be shown and the OK button disabled. » Author: Denis Favre-Miville 08/09/05 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id: TStyleDialog.h,v 1.0 2005/09/08 » Last generated: 2015-03-14 16:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TStyleDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleDialog.html
https://root.cern/root/html534/TStyleDialog.html:22327,Safety,avoid,avoid,22327,"me::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fCancelcancel button; TVirtualPad*fCurPadcurrent pad from which to import; TStyle*fCurStylestyle to copy or to rename; Int_tfMode1=new, 2=rename, 3=import; TGTextEntry*fNameTStyle name text entry; TGLabel*fNameLabelname label; TGTextButton*fOKsave button; TStyleManager*fStyleManagerparent style manager; TGTextEntry*fTitleTStyle title text entry; TGLabel*fTitleLabeltitle label; TList*fTrashListFrameto avoid memory leak; TList*fTrashListLayoutto avoid memory leak; TGLabel*fWarnLabellabel for warnings. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStyleDialog(TStyleManager* sm, TStyle* cur, Int_t mode, TVirtualPad* currentPad = 0); Constructor. Create the dialog window and draw it centered over the; main window 'mf'. A pointer to the style to copy or rename is given; by 'cur' and the parameter 'mode' specify the mode:; 1 = copy | 2 = rename | 3 = import from canvas. ~TStyleDialog(); Destructor. void DoCancel(); Slot called when the Cancel button is clicked. Close the window; without saving submitted changes. void DoCloseWindow(); Slot called when the window is closed via the window manager.; Close the window without saving submitted changes. void DoOK(); Slot called when the OK butto",MatchSource.WIKI,root/html534/TStyleDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleDialog.html
https://root.cern/root/html534/TStyleDialog.html:22371,Safety,avoid,avoid,22371,"me::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fCancelcancel button; TVirtualPad*fCurPadcurrent pad from which to import; TStyle*fCurStylestyle to copy or to rename; Int_tfMode1=new, 2=rename, 3=import; TGTextEntry*fNameTStyle name text entry; TGLabel*fNameLabelname label; TGTextButton*fOKsave button; TStyleManager*fStyleManagerparent style manager; TGTextEntry*fTitleTStyle title text entry; TGLabel*fTitleLabeltitle label; TList*fTrashListFrameto avoid memory leak; TList*fTrashListLayoutto avoid memory leak; TGLabel*fWarnLabellabel for warnings. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStyleDialog(TStyleManager* sm, TStyle* cur, Int_t mode, TVirtualPad* currentPad = 0); Constructor. Create the dialog window and draw it centered over the; main window 'mf'. A pointer to the style to copy or rename is given; by 'cur' and the parameter 'mode' specify the mode:; 1 = copy | 2 = rename | 3 = import from canvas. ~TStyleDialog(); Destructor. void DoCancel(); Slot called when the Cancel button is clicked. Close the window; without saving submitted changes. void DoCloseWindow(); Slot called when the window is closed via the window manager.; Close the window without saving submitted changes. void DoOK(); Slot called when the OK butto",MatchSource.WIKI,root/html534/TStyleDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleDialog.html
https://root.cern/root/html534/TStyleDialog.html:23326,Safety,avoid,avoid,23326,"GFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fCancelcancel button; TVirtualPad*fCurPadcurrent pad from which to import; TStyle*fCurStylestyle to copy or to rename; Int_tfMode1=new, 2=rename, 3=import; TGTextEntry*fNameTStyle name text entry; TGLabel*fNameLabelname label; TGTextButton*fOKsave button; TStyleManager*fStyleManagerparent style manager; TGTextEntry*fTitleTStyle title text entry; TGLabel*fTitleLabeltitle label; TList*fTrashListFrameto avoid memory leak; TList*fTrashListLayoutto avoid memory leak; TGLabel*fWarnLabellabel for warnings. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStyleDialog(TStyleManager* sm, TStyle* cur, Int_t mode, TVirtualPad* currentPad = 0); Constructor. Create the dialog window and draw it centered over the; main window 'mf'. A pointer to the style to copy or rename is given; by 'cur' and the parameter 'mode' specify the mode:; 1 = copy | 2 = rename | 3 = import from canvas. ~TStyleDialog(); Destructor. void DoCancel(); Slot called when the Cancel button is clicked. Close the window; without saving submitted changes. void DoCloseWindow(); Slot called when the window is closed via the window manager.; Close the window without saving submitted changes. void DoOK(); Slot called when the OK button is clicked. Rename or create the style; before closing the window. void DoUpdate(); Slot called every time the name is changed. Provide some protection; to avoid letting the user use an empty name or an already used one.; A warning message can be shown and the OK button disabled. » Author: Denis Favre-Miville 08/09/05 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id: TStyleDialog.h,v 1.0 2005/09/08 » Last generated: 2015-03-14 16:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TStyleDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleDialog.html
https://root.cern/root/html534/TStyleManager.html:856,Availability,avail,available,856,". TStyleManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TStyleManager. class TStyleManager: public TGMainFrame. TStyleManager. This class provides a Graphical User Interface to manage styles; in ROOT. It allows the user to edit styles, import / export; them to macros, apply a style on the selected object or on; all canvases, change gStyle. Activate the style manager by selecting Edit menu / Style...; in the canvas window. The Style Manager interface is composed of two parts:; - the top level interface that manages a list of styles;; - the style editor, which deals with the current style settings. /*. */. The combo box 'Available Styles' contains the list of available; styles for the current ROOT session and shows the currently; selected one. The field on the right shows the setting of the gStyle.; You can set the global variable gStyle to the selected style by; clicking on the button in the middle.; The group frame 'Apply on' displays information for the currently; selected canvas and object in the ROOT session. This selection might; be changed by clicking on another object with the middle mouse; button. You have a choice to apply a style on the selected object or; on all available canvases.; WARNING: You cannot undo the changes after applying the style! If; you are not sure of that action, it may be better to see a preview; of what you are going to apply.; If the check button 'Preview' is selected, a preview of the selected; canvas according to the selected style will be shown. The selection; of the next check button 'Run Time Preview' will apply updates of; the preview any time a value of the selected style is changed. For; drawings that take a time it is better to disable this option. Create a new style:; A new style can be created via the Style menu/New... or the toolbar.; A c",MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:1381,Availability,avail,available,1381,"nterface to manage styles; in ROOT. It allows the user to edit styles, import / export; them to macros, apply a style on the selected object or on; all canvases, change gStyle. Activate the style manager by selecting Edit menu / Style...; in the canvas window. The Style Manager interface is composed of two parts:; - the top level interface that manages a list of styles;; - the style editor, which deals with the current style settings. /*. */. The combo box 'Available Styles' contains the list of available; styles for the current ROOT session and shows the currently; selected one. The field on the right shows the setting of the gStyle.; You can set the global variable gStyle to the selected style by; clicking on the button in the middle.; The group frame 'Apply on' displays information for the currently; selected canvas and object in the ROOT session. This selection might; be changed by clicking on another object with the middle mouse; button. You have a choice to apply a style on the selected object or; on all available canvases.; WARNING: You cannot undo the changes after applying the style! If; you are not sure of that action, it may be better to see a preview; of what you are going to apply.; If the check button 'Preview' is selected, a preview of the selected; canvas according to the selected style will be shown. The selection; of the next check button 'Run Time Preview' will apply updates of; the preview any time a value of the selected style is changed. For; drawings that take a time it is better to disable this option. Create a new style:; A new style can be created via the Style menu/New... or the toolbar.; A clone of the selected style will be used as a base of the new; style. All its values can be modified via the style editor later.; The dialog that appears will ask for the name and description of the; new style. Import a style (from a macro):; A style macro can be imported at any time. The new imported style in; the ROOT session will become the selected o",MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:3273,Availability,avail,available,3273,"ed at any time. The new imported style in; the ROOT session will become the selected one. Import a style (from a canvas):; You can do that selecting the Style menu/Import from.../Canvas or; the corresponding Tool bar button. A new style will be created in the; ROOT session and will become the selected one. This style is a clone; of the gStyle with modified values as they are set in the currently; selected canvas. You can import a style from any canvas and apply it; later on some objects. Export a style (in a C++ macro file):; To store a style longer than for the current ROOT session you can; save it in a C++ macro file. This can be done via the menu or the; tool bar button. There is a naming convention for the style macros:; the name must be 'Style_*.C', where * can be replaced by anything; you want. Delete a style:; The selected style can be deleted from the list when you use the; Style menu/Delete or the corresponding tool bar button. The selected; style is removed from the list of all available styles for the; current ROOT session. WARRNING: it will be lost if you didn't saved; it in a C++ macro file before its deletion. Also, you cannot delete; the selected style if it is set to gStyle. A message 'Can not delete; gStyle' will be displayed on the CINT prompt. /*. */. Editor's buttons:; Open / close the style editor:; The button 'Edit >>' opens the style editor and its label changes to; 'Close <<'. For all details of what can be changed and how please see; the provided Help. Reset a style (to a previously saved state):; When the editor is opened, the 'Reset' button allows you to reset; the values of the selected style for editing. Doing that you cancel; all changes made since the last time you saved that style in a macro.; If the selected style is one of the five ROOT styles (Plain, Bold,; Video, Pub or Default), it will be recreated. Update the preview:; The button 'Update Preview' is available when a preview is shown and; the run time option is not selected. Thi",MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:4191,Availability,avail,available,4191,"g tool bar button. The selected; style is removed from the list of all available styles for the; current ROOT session. WARRNING: it will be lost if you didn't saved; it in a C++ macro file before its deletion. Also, you cannot delete; the selected style if it is set to gStyle. A message 'Can not delete; gStyle' will be displayed on the CINT prompt. /*. */. Editor's buttons:; Open / close the style editor:; The button 'Edit >>' opens the style editor and its label changes to; 'Close <<'. For all details of what can be changed and how please see; the provided Help. Reset a style (to a previously saved state):; When the editor is opened, the 'Reset' button allows you to reset; the values of the selected style for editing. Doing that you cancel; all changes made since the last time you saved that style in a macro.; If the selected style is one of the five ROOT styles (Plain, Bold,; Video, Pub or Default), it will be recreated. Update the preview:; The button 'Update Preview' is available when a preview is shown and; the run time option is not selected. This button allows you to; refresh the preview any time you want to see how the style you edit; looks like. Help button:; Provides a help of the currently selected tab. Function Members (Methods); public:. TStyleManager(const TGWindow*); virtual~TStyleManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); voidBuildList(TStyle* style = 0); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voi",MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:8799,Availability,error,error,8799,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:8883,Availability,error,error,8883,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:31298,Availability,mask,mask,31298,,MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:36533,Availability,error,error,36533,n; TGFileInfo*fCurMacrocurrent macro; TObject*fCurObjcurrent object; TGLabel*fCurObjLabellabel 'Object:'; TGTextEntry*fCurObjTextEntrylabel showing current object's name; TVirtualPad*fCurPadcurrent pad; TGLabel*fCurPadLabellabel 'Canvas:'; TGTextEntry*fCurPadTextEntrylabel showing current pad's name; TStyle*fCurSelStylecurrent selected style; TGLabel*fCurStylabellabel 'gStyle is set to:'; TGTextEntry*fCurStylelabel showing gStyle's name; Int_tfCurTabAxisNumcurrent opened axis tab number; Int_tfCurTabNumcurrent opened tab number; TGNumberEntry*fDateXcanvas date abscissa number entry; TGNumberEntry*fDateYcanvas date ordinate number entry; TGCheckButton*fDrawBorderfunction border show/hide check box; TGHorizontalFrame*fEditionButtonFrameeditor's buttons; TGVerticalFrame*fEditionFrameeditor; TGTextButton*fEditionHelphelp button; TGTextButton*fEditionResetreset button; TGTab*fEditionTabeditor's tabs; TGTextButton*fEditionUpdatePreviewupdate preview button; TGNumberEntry*fEndErrorSizeend error size number entry; TGNumberEntry*fErrorXerror along abscissa number entry; TGColorSelect*fFillColorgeneral fill color selection widget; TGedPatternSelect*fFillStylegeneral fill pattern selection widget; TGTextEntry*fFitFormatfit format text entry; TGLabel*fFitFormatLabellabel 'fit format'; TGButtonGroup*fFrameBorderModeframe border mode button group; TGLineWidthComboBox*fFrameBorderSizeframe border size combo box; TGColorSelect*fFrameFillColorframe fill color selection widget; TGedPatternSelect*fFrameFillStyleframe fill pattern selection widget; TGColorSelect*fFrameLineColorframe line color selection widget; TGLineStyleComboBox*fFrameLineStyleframe line style combo box; TGLineWidthComboBox*fFrameLineWidthframe line width combo box; TGColorSelect*fFuncColorfunction color selection widget; TGLineStyleComboBox*fFuncStylefunction line style combo box; TGLineWidthComboBox*fFuncWidthfunction width number entry; TGColorSelect*fGridColorpad grid line color selection widget; TGLineStyleCombo,MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:39232,Availability,avail,available,39232,Tab*fHistosTabhistos' tabs; TGHorizontal3DLine*fHorizontal3DLinea line under the tool bar; TGPopupMenu*fImportCascadeCascaded menu 'Import'; Bool_tfLastChoice=kTRUE if the user choose OK in the last TStyleDialog; TGLayoutHints*fLayoutExpandXoften used layout; TGLayoutHints*fLayoutExpandXCenterYMarginoften used layout; TGLayoutHints*fLayoutExpandXMarginoften used layout; TGLayoutHints*fLayoutExpandXYoften used layout; TGLayoutHints*fLayoutExpandXYMarginoften used layout; TGLineWidthComboBox*fLegendBorderSizelegend border size combo box; TGLabel*fLegendBorderSizeLabellabel 'Legend's'; TGNumberEntry*fLegoInnerRhistograms lego inner radius number entry; TGColorSelect*fLineColorgeneral line color selection widget; TGNumberEntry*fLineScalePSps/pdf line scale number entry; TGLineStyleComboBox*fLineStylegeneral line style combo box; TGTextButton*fLineStyleEditgeneral line style editor open button; TGLineWidthComboBox*fLineWidthgeneral line width combo box; TGComboBox*fListComboBoxlist of available styles; TGLabel*fListLabellabel 'Available Styles:'; TGPictureButton*fMakeDefaultselected style becom gStyle; const TGPicture*fMakeDefaultPicbutton picture; TGColorSelect*fMarkerColorgeneral marker color selection widget; TGComboBox*fMarkerSizegeneral marker size combo box; TGedMarkerSelect*fMarkerStylegeneral marker style entry; TGMenuBar*fMenuBarthe main window menu bar; TGPopupMenu*fMenuHelpthe 'Help' popup menu; TGPopupMenu*fMenuStylethe 'Style' popup menu; Bool_tfMoreAndNotLess=kTRUE when editor is open; TGTextButton*fMoreLessopen/close the editor; TGNumberEntry*fNumberContourshistograms number of contours number entry; TGCheckButton*fOptDateBoolcanvas date show/hide check box; TGComboBox*fOptDateFormatcanvas date format text entry; TGCheckButton*fOptFitChifit Chi show/hide check box; TGCheckButton*fOptFitErrorsfit errors check box; TGCheckButton*fOptFitProbabilityfit probability show/hide check box; TGCheckButton*fOptFitValuesfit values show/hide check box; TGCheckButton*fOp,MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:40074,Availability,error,errors,40074,extButton*fLineStyleEditgeneral line style editor open button; TGLineWidthComboBox*fLineWidthgeneral line width combo box; TGComboBox*fListComboBoxlist of available styles; TGLabel*fListLabellabel 'Available Styles:'; TGPictureButton*fMakeDefaultselected style becom gStyle; const TGPicture*fMakeDefaultPicbutton picture; TGColorSelect*fMarkerColorgeneral marker color selection widget; TGComboBox*fMarkerSizegeneral marker size combo box; TGedMarkerSelect*fMarkerStylegeneral marker style entry; TGMenuBar*fMenuBarthe main window menu bar; TGPopupMenu*fMenuHelpthe 'Help' popup menu; TGPopupMenu*fMenuStylethe 'Style' popup menu; Bool_tfMoreAndNotLess=kTRUE when editor is open; TGTextButton*fMoreLessopen/close the editor; TGNumberEntry*fNumberContourshistograms number of contours number entry; TGCheckButton*fOptDateBoolcanvas date show/hide check box; TGComboBox*fOptDateFormatcanvas date format text entry; TGCheckButton*fOptFitChifit Chi show/hide check box; TGCheckButton*fOptFitErrorsfit errors check box; TGCheckButton*fOptFitProbabilityfit probability show/hide check box; TGCheckButton*fOptFitValuesfit values show/hide check box; TGCheckButton*fOptLogxX axis logarithmic scale check box; TGCheckButton*fOptLogyY axis logarithmic scale check box; TGCheckButton*fOptLogzZ axis logarithmic scale check box; TGCheckButton*fOptStatEntriesstats entries show/hide check box; TGCheckButton*fOptStatErrorsstats errors check box; TGCheckButton*fOptStatIntegralstats integral show/hide check box; TGCheckButton*fOptStatKurtosisstats kurtosis show/hide check box; TGCheckButton*fOptStatMeanstats mean show/hide check box; TGCheckButton*fOptStatNamestats name show/hide check box; TGCheckButton*fOptStatOverflowstats overflow show/hide check box; TGCheckButton*fOptStatRMSstats RMS show/hide check box; TGCheckButton*fOptStatSkewnessstats Skewness show/hide check box; TGCheckButton*fOptStatUnderflowstats underflow show/hide check box; TGCheckButton*fOptTitletitle show/hide check box; TGButtonGroup*,MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:40492,Availability,error,errors,40492,arker size combo box; TGedMarkerSelect*fMarkerStylegeneral marker style entry; TGMenuBar*fMenuBarthe main window menu bar; TGPopupMenu*fMenuHelpthe 'Help' popup menu; TGPopupMenu*fMenuStylethe 'Style' popup menu; Bool_tfMoreAndNotLess=kTRUE when editor is open; TGTextButton*fMoreLessopen/close the editor; TGNumberEntry*fNumberContourshistograms number of contours number entry; TGCheckButton*fOptDateBoolcanvas date show/hide check box; TGComboBox*fOptDateFormatcanvas date format text entry; TGCheckButton*fOptFitChifit Chi show/hide check box; TGCheckButton*fOptFitErrorsfit errors check box; TGCheckButton*fOptFitProbabilityfit probability show/hide check box; TGCheckButton*fOptFitValuesfit values show/hide check box; TGCheckButton*fOptLogxX axis logarithmic scale check box; TGCheckButton*fOptLogyY axis logarithmic scale check box; TGCheckButton*fOptLogzZ axis logarithmic scale check box; TGCheckButton*fOptStatEntriesstats entries show/hide check box; TGCheckButton*fOptStatErrorsstats errors check box; TGCheckButton*fOptStatIntegralstats integral show/hide check box; TGCheckButton*fOptStatKurtosisstats kurtosis show/hide check box; TGCheckButton*fOptStatMeanstats mean show/hide check box; TGCheckButton*fOptStatNamestats name show/hide check box; TGCheckButton*fOptStatOverflowstats overflow show/hide check box; TGCheckButton*fOptStatRMSstats RMS show/hide check box; TGCheckButton*fOptStatSkewnessstats Skewness show/hide check box; TGCheckButton*fOptStatUnderflowstats underflow show/hide check box; TGCheckButton*fOptTitletitle show/hide check box; TGButtonGroup*fPadBorderModepad border mode button group; TGLineWidthComboBox*fPadBorderSizepad border size combo box; TGNumberEntry*fPadBottomMarginpad bottom margin number entry; TGColorSelect*fPadColorpad fill color selection widget; TGCheckButton*fPadGridXpad grid along X show/hide check box; TGCheckButton*fPadGridYpad grid along Y show/hide check box; TGNumberEntry*fPadLeftMarginpad left margin number entry; TGNumberEntry*f,MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:50250,Availability,avail,available,50250,"r or the tool bar. void DoDelete(); Delete the current selected style from the ROOT session.; Called via the menu or the tool bar. void DoRename(); Rename the current selected style. Called via the menu bar. void DoExport(); Save the current selected style in a C++ macro file. Called via the menu; or the tool bar. void DoExit(); Close the style manager. Called via the menu bar. void DoHelp(Int_t i); Open an help window. Called via the menu bar or the tool bar. void DoImportCanvas(); Create a new style (a copy of gStyle) and import the properties of the; current canvas inside. void CreateMacro(); Create a TGFileInfo concerning a macro, if it doesn't exist already. void AddToolbar(TGCompositeFrame* p); Add the tool bar to the frame 'p'. void AddTopLevelInterface(TGCompositeFrame* cf); Add the top level interface to the frame 'cf'. This part of the; interface will provide all enable functionalities, excluding the; edition of styles. void BuildList(TStyle* style = 0); Build the list of styles which will appear in the available styles; combo box. The new style to select is mentioned. If no style has; been specified, the last entry of the list is selected. void UpdateStatusBar(); Update the content of the status bar: show the name of the current; selected style, its title and the macro from which it has been imported. void UpdateEditor(Int_t tabNum); Update the values of every widget entry in the editor. The new values; are loaded from the current selected style. void ConnectAll(); Connect every entry in the top level interface to the slot. void DisconnectAll(); Disconnect every entry in the top level interface of the slot. void ConnectEditor(Int_t tabNum); Connect every widget entry of the editor to its specific slot. void DisconnectEditor(Int_t tabNum); Disconnect every widget entry of the editor from its slot. Must be; called before UpdateEditor() to avoid recursive calls. void DoEditor(); Called each time something is changed in the style editor. Thanks to; this metho",MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:59905,Availability,avail,available,59905,"TGCompositeFrame* f, Int_t id); Add a text align combo box to the frame f. TGButtonGroup * AddBorderModeEntry(TGCompositeFrame* f, Int_t id1, Int_t id2, Int_t id3); Add a border mode button group to the frame f. TGComboBox * AddDateFormatEntry(TGCompositeFrame* f, Int_t id); Add a date format combo box to the frame f. TGCheckButton * AddCheckButton(TGCompositeFrame* f, const char* s, Int_t id, Int_t e1 = 0, Int_t e2 = 2); Add a check button to the frame f. TGTextEntry * AddTextEntry(TGCompositeFrame* f, const char* s, Int_t id); Add a text entry to the frame f. A caption can be added. TGComboBox * AddPaperSizeEntry(TGCompositeFrame* f, Int_t id); Add a prefered paper size combo box to the frame f. void DoMenu(Int_t menuID); Slot called when an item of the menu is selected. void DoImportMacro(Bool_t create); Slot called to import a style from a C++ macro file. If create=kTRUE,; a new style is created. Otherwise, the current style is reseted. void DoListSelect(); Slot called when the user select an item in the available styles' list.; Update the preview, the editor, the status bar. The current selected; style is changed. void DoRealTime(Bool_t b); Slot called when the user click on the run time update check button.; If b=kTRUE, the user asks for a real time preview. void DoPreview(Bool_t b); Slot called when the user click on the preview check button. If b=kTRUE,; the user asks for a preview, otherwise he wants to close it. void DoPreviewClosed(); Slot called to close the preview, via the preview check button, or; when the preview window is closed via the window manager. void DoMakeDefault(); Slot called to make the current selected style (in the ComboBox); become gStyle. void DoApplyOnSelect(Int_t i); Slot called to choose on which object(s) the 'Apply' button will; have an effect. void DoApplyOn(); Slot called when the user clicks on the 'Apply' button. Apply the; current selected style to the specified object(s). void DoMoreLess(); Slot called when the user try to s",MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:68196,Availability,error,error,68196, fill style is modified by the user. void ModFrameLineColor(); Slot called whenever the frame line color is modified by the user. void ModFrameLineWidth(); Slot called whenever the frame line width is modified by the user. void ModFrameLineStyle(); Slot called whenever the frame line style is modified by the user. void ModPaletteEdit(); Slot called whenever the palette editor is opened by the user. void ModFrameBorderMode(); Slot called whenever the frame border mode is modified by the user. void ModFrameBorderSize(); Slot called whenever the frame border size is modified by the user. void ModFuncColor(); Slot called whenever the function line color is modified by the user. void ModFuncWidth(); Slot called whenever the function line width is modified by the user. void ModFuncStyle(); Slot called whenever the function line style is modified by the user. void ModDrawBorder(); Slot called whenever the draw border boolean is modified by the user. void ModEndErrorSize(); Slot called whenever the end error size is modified by the user. void ModErrorX(); Slot called whenever the error along X is modified by the user. void ModTimeOffset(); Slot called whenever the time offset is modified by the user. void ModStripDecimals(); Slot called whenever the strip decimal boolean is modified by the user. void ModApplyOnXYZ(); Slot called whenever the apply on XYZ button is clicked. The settings of; the current selected axis pad are applyed on all axis.; NB: The logarithmic scale option isn't modified by this method. void ModXTitleSize(); Slot called whenever the X axis title size is modified by the user. void ModXTitleSizeInPixels(Bool_t b); Slot called whenever the X axis title size mode is modified by the user. void ModXTitleColor(); Slot called whenever the X axis title color is modified by the user. void ModXTitleOffset(); Slot called whenever the X axis title offset is modified by the user. void ModXTitleFont(); Slot called whenever the X axis title font is modified by the user.,MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:68275,Availability,error,error,68275,e frame line color is modified by the user. void ModFrameLineWidth(); Slot called whenever the frame line width is modified by the user. void ModFrameLineStyle(); Slot called whenever the frame line style is modified by the user. void ModPaletteEdit(); Slot called whenever the palette editor is opened by the user. void ModFrameBorderMode(); Slot called whenever the frame border mode is modified by the user. void ModFrameBorderSize(); Slot called whenever the frame border size is modified by the user. void ModFuncColor(); Slot called whenever the function line color is modified by the user. void ModFuncWidth(); Slot called whenever the function line width is modified by the user. void ModFuncStyle(); Slot called whenever the function line style is modified by the user. void ModDrawBorder(); Slot called whenever the draw border boolean is modified by the user. void ModEndErrorSize(); Slot called whenever the end error size is modified by the user. void ModErrorX(); Slot called whenever the error along X is modified by the user. void ModTimeOffset(); Slot called whenever the time offset is modified by the user. void ModStripDecimals(); Slot called whenever the strip decimal boolean is modified by the user. void ModApplyOnXYZ(); Slot called whenever the apply on XYZ button is clicked. The settings of; the current selected axis pad are applyed on all axis.; NB: The logarithmic scale option isn't modified by this method. void ModXTitleSize(); Slot called whenever the X axis title size is modified by the user. void ModXTitleSizeInPixels(Bool_t b); Slot called whenever the X axis title size mode is modified by the user. void ModXTitleColor(); Slot called whenever the X axis title color is modified by the user. void ModXTitleOffset(); Slot called whenever the X axis title offset is modified by the user. void ModXTitleFont(); Slot called whenever the X axis title font is modified by the user. void ModXLabelSize(); Slot called whenever the X axis label size is modified by the ,MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:1764,Deployability,update,updates,1764," the current style settings. /*. */. The combo box 'Available Styles' contains the list of available; styles for the current ROOT session and shows the currently; selected one. The field on the right shows the setting of the gStyle.; You can set the global variable gStyle to the selected style by; clicking on the button in the middle.; The group frame 'Apply on' displays information for the currently; selected canvas and object in the ROOT session. This selection might; be changed by clicking on another object with the middle mouse; button. You have a choice to apply a style on the selected object or; on all available canvases.; WARNING: You cannot undo the changes after applying the style! If; you are not sure of that action, it may be better to see a preview; of what you are going to apply.; If the check button 'Preview' is selected, a preview of the selected; canvas according to the selected style will be shown. The selection; of the next check button 'Run Time Preview' will apply updates of; the preview any time a value of the selected style is changed. For; drawings that take a time it is better to disable this option. Create a new style:; A new style can be created via the Style menu/New... or the toolbar.; A clone of the selected style will be used as a base of the new; style. All its values can be modified via the style editor later.; The dialog that appears will ask for the name and description of the; new style. Import a style (from a macro):; A style macro can be imported at any time. The new imported style in; the ROOT session will become the selected one. Import a style (from a canvas):; You can do that selecting the Style menu/Import from.../Canvas or; the corresponding Tool bar button. A new style will be created in the; ROOT session and will become the selected one. This style is a clone; of the gStyle with modified values as they are set in the currently; selected canvas. You can import a style from any canvas and apply it; later on some objects. Exp",MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:60093,Deployability,update,update,60093,"utton group to the frame f. TGComboBox * AddDateFormatEntry(TGCompositeFrame* f, Int_t id); Add a date format combo box to the frame f. TGCheckButton * AddCheckButton(TGCompositeFrame* f, const char* s, Int_t id, Int_t e1 = 0, Int_t e2 = 2); Add a check button to the frame f. TGTextEntry * AddTextEntry(TGCompositeFrame* f, const char* s, Int_t id); Add a text entry to the frame f. A caption can be added. TGComboBox * AddPaperSizeEntry(TGCompositeFrame* f, Int_t id); Add a prefered paper size combo box to the frame f. void DoMenu(Int_t menuID); Slot called when an item of the menu is selected. void DoImportMacro(Bool_t create); Slot called to import a style from a C++ macro file. If create=kTRUE,; a new style is created. Otherwise, the current style is reseted. void DoListSelect(); Slot called when the user select an item in the available styles' list.; Update the preview, the editor, the status bar. The current selected; style is changed. void DoRealTime(Bool_t b); Slot called when the user click on the run time update check button.; If b=kTRUE, the user asks for a real time preview. void DoPreview(Bool_t b); Slot called when the user click on the preview check button. If b=kTRUE,; the user asks for a preview, otherwise he wants to close it. void DoPreviewClosed(); Slot called to close the preview, via the preview check button, or; when the preview window is closed via the window manager. void DoMakeDefault(); Slot called to make the current selected style (in the ComboBox); become gStyle. void DoApplyOnSelect(Int_t i); Slot called to choose on which object(s) the 'Apply' button will; have an effect. void DoApplyOn(); Slot called when the user clicks on the 'Apply' button. Apply the; current selected style to the specified object(s). void DoMoreLess(); Slot called when the user try to show or hide the editor part of the; style manager. void DoEditionUpdatePreview(); Slot called when the user clicks on the 'Update preview' button. void DoChangeTab(Int_t i); Slot call",MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:634,Integrability,interface,interface,634,". TStyleManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TStyleManager. class TStyleManager: public TGMainFrame. TStyleManager. This class provides a Graphical User Interface to manage styles; in ROOT. It allows the user to edit styles, import / export; them to macros, apply a style on the selected object or on; all canvases, change gStyle. Activate the style manager by selecting Edit menu / Style...; in the canvas window. The Style Manager interface is composed of two parts:; - the top level interface that manages a list of styles;; - the style editor, which deals with the current style settings. /*. */. The combo box 'Available Styles' contains the list of available; styles for the current ROOT session and shows the currently; selected one. The field on the right shows the setting of the gStyle.; You can set the global variable gStyle to the selected style by; clicking on the button in the middle.; The group frame 'Apply on' displays information for the currently; selected canvas and object in the ROOT session. This selection might; be changed by clicking on another object with the middle mouse; button. You have a choice to apply a style on the selected object or; on all available canvases.; WARNING: You cannot undo the changes after applying the style! If; you are not sure of that action, it may be better to see a preview; of what you are going to apply.; If the check button 'Preview' is selected, a preview of the selected; canvas according to the selected style will be shown. The selection; of the next check button 'Run Time Preview' will apply updates of; the preview any time a value of the selected style is changed. For; drawings that take a time it is better to disable this option. Create a new style:; A new style can be created via the Style menu/New... or the toolbar.; A c",MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:687,Integrability,interface,interface,687,". TStyleManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TStyleManager. class TStyleManager: public TGMainFrame. TStyleManager. This class provides a Graphical User Interface to manage styles; in ROOT. It allows the user to edit styles, import / export; them to macros, apply a style on the selected object or on; all canvases, change gStyle. Activate the style manager by selecting Edit menu / Style...; in the canvas window. The Style Manager interface is composed of two parts:; - the top level interface that manages a list of styles;; - the style editor, which deals with the current style settings. /*. */. The combo box 'Available Styles' contains the list of available; styles for the current ROOT session and shows the currently; selected one. The field on the right shows the setting of the gStyle.; You can set the global variable gStyle to the selected style by; clicking on the button in the middle.; The group frame 'Apply on' displays information for the currently; selected canvas and object in the ROOT session. This selection might; be changed by clicking on another object with the middle mouse; button. You have a choice to apply a style on the selected object or; on all available canvases.; WARNING: You cannot undo the changes after applying the style! If; you are not sure of that action, it may be better to see a preview; of what you are going to apply.; If the check button 'Preview' is selected, a preview of the selected; canvas according to the selected style will be shown. The selection; of the next check button 'Run Time Preview' will apply updates of; the preview any time a value of the selected style is changed. For; drawings that take a time it is better to disable this option. Create a new style:; A new style can be created via the Style menu/New... or the toolbar.; A c",MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:3482,Integrability,message,message,3482,"created in the; ROOT session and will become the selected one. This style is a clone; of the gStyle with modified values as they are set in the currently; selected canvas. You can import a style from any canvas and apply it; later on some objects. Export a style (in a C++ macro file):; To store a style longer than for the current ROOT session you can; save it in a C++ macro file. This can be done via the menu or the; tool bar button. There is a naming convention for the style macros:; the name must be 'Style_*.C', where * can be replaced by anything; you want. Delete a style:; The selected style can be deleted from the list when you use the; Style menu/Delete or the corresponding tool bar button. The selected; style is removed from the list of all available styles for the; current ROOT session. WARRNING: it will be lost if you didn't saved; it in a C++ macro file before its deletion. Also, you cannot delete; the selected style if it is set to gStyle. A message 'Can not delete; gStyle' will be displayed on the CINT prompt. /*. */. Editor's buttons:; Open / close the style editor:; The button 'Edit >>' opens the style editor and its label changes to; 'Close <<'. For all details of what can be changed and how please see; the provided Help. Reset a style (to a previously saved state):; When the editor is opened, the 'Reset' button allows you to reset; the values of the selected style for editing. Doing that you cancel; all changes made since the last time you saved that style in a macro.; If the selected style is one of the five ROOT styles (Plain, Bold,; Video, Pub or Default), it will be recreated. Update the preview:; The button 'Update Preview' is available when a preview is shown and; the run time option is not selected. This button allows you to; refresh the preview any time you want to see how the style you edit; looks like. Help button:; Provides a help of the currently selected tab. Function Members (Methods); public:. TStyleManager(const TGWindow*); virtual~TSt",MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:48816,Integrability,interface,interface,48816,lsZ axis label size check box; TGNumberEntry*fZNdivMainZ axis primary division number entry; TGNumberEntry*fZNdivSubZ axis secondary division number entry; TGNumberEntry*fZNdivSubSubZ axis tertiary division number entry; TGCheckButton*fZNdivisionsOptimizeZ axis division optimization check box; TGNumberEntry*fZTickLengthZ axis tick length number entry; TGColorSelect*fZTitleColorZ axis title color selection widget; TGFontTypeComboBox*fZTitleFontZ axis title font combo box; TGNumberEntry*fZTitleOffsetZ axis title offset number entry; TGNumberEntry*fZTitleSizeZ axis title size number entry; TGCheckButton*fZTitleSizeInPixelsZ axis title size check box; static TStyleManager*fgStyleManagersingleton style manager. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStyleManager(const TGWindow* ); Constructor. Create the main window of the style manager. ~TStyleManager(); Destructor. TStyleManager *& GetSM(); static: return style manager. void Init(); Set up the interface. Called by the ctor or by the 'Show' method. void Hide(); Called to hide the style manager. void Show(); Called to show the style manager. Static method. void Terminate(); Called to delete the style manager. Called when the ROOT session is; closed via a canvas' menu. void AddMenus(TGCompositeFrame* p); Add the menu bar to the frame 'p'. void DoNew(); Create a new style. Called via the menu bar or the tool bar. void DoDelete(); Delete the current selected style from the ROOT session.; Called via the menu or the tool bar. void DoRename(); Rename the current selected style. Called via the menu bar. void DoExport(); Save the current selected style in a C++ macro file. Called via the menu; or the tool bar. void DoExit(); Close the style manager. Called via the menu bar. void DoHelp(Int_t i); Open an help window. Called via the menu bar or the tool bar. void DoImportCanvas(); Create a new style (a copy of gStyle) and import the properties of the; current canvas inside. void ,MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:50033,Integrability,interface,interface,50033,"e the style manager. Called when the ROOT session is; closed via a canvas' menu. void AddMenus(TGCompositeFrame* p); Add the menu bar to the frame 'p'. void DoNew(); Create a new style. Called via the menu bar or the tool bar. void DoDelete(); Delete the current selected style from the ROOT session.; Called via the menu or the tool bar. void DoRename(); Rename the current selected style. Called via the menu bar. void DoExport(); Save the current selected style in a C++ macro file. Called via the menu; or the tool bar. void DoExit(); Close the style manager. Called via the menu bar. void DoHelp(Int_t i); Open an help window. Called via the menu bar or the tool bar. void DoImportCanvas(); Create a new style (a copy of gStyle) and import the properties of the; current canvas inside. void CreateMacro(); Create a TGFileInfo concerning a macro, if it doesn't exist already. void AddToolbar(TGCompositeFrame* p); Add the tool bar to the frame 'p'. void AddTopLevelInterface(TGCompositeFrame* cf); Add the top level interface to the frame 'cf'. This part of the; interface will provide all enable functionalities, excluding the; edition of styles. void BuildList(TStyle* style = 0); Build the list of styles which will appear in the available styles; combo box. The new style to select is mentioned. If no style has; been specified, the last entry of the list is selected. void UpdateStatusBar(); Update the content of the status bar: show the name of the current; selected style, its title and the macro from which it has been imported. void UpdateEditor(Int_t tabNum); Update the values of every widget entry in the editor. The new values; are loaded from the current selected style. void ConnectAll(); Connect every entry in the top level interface to the slot. void DisconnectAll(); Disconnect every entry in the top level interface of the slot. void ConnectEditor(Int_t tabNum); Connect every widget entry of the editor to its specific slot. void DisconnectEditor(Int_t tabNum); Disconnect e",MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:50080,Integrability,interface,interface,50080,"mpositeFrame* p); Add the menu bar to the frame 'p'. void DoNew(); Create a new style. Called via the menu bar or the tool bar. void DoDelete(); Delete the current selected style from the ROOT session.; Called via the menu or the tool bar. void DoRename(); Rename the current selected style. Called via the menu bar. void DoExport(); Save the current selected style in a C++ macro file. Called via the menu; or the tool bar. void DoExit(); Close the style manager. Called via the menu bar. void DoHelp(Int_t i); Open an help window. Called via the menu bar or the tool bar. void DoImportCanvas(); Create a new style (a copy of gStyle) and import the properties of the; current canvas inside. void CreateMacro(); Create a TGFileInfo concerning a macro, if it doesn't exist already. void AddToolbar(TGCompositeFrame* p); Add the tool bar to the frame 'p'. void AddTopLevelInterface(TGCompositeFrame* cf); Add the top level interface to the frame 'cf'. This part of the; interface will provide all enable functionalities, excluding the; edition of styles. void BuildList(TStyle* style = 0); Build the list of styles which will appear in the available styles; combo box. The new style to select is mentioned. If no style has; been specified, the last entry of the list is selected. void UpdateStatusBar(); Update the content of the status bar: show the name of the current; selected style, its title and the macro from which it has been imported. void UpdateEditor(Int_t tabNum); Update the values of every widget entry in the editor. The new values; are loaded from the current selected style. void ConnectAll(); Connect every entry in the top level interface to the slot. void DisconnectAll(); Disconnect every entry in the top level interface of the slot. void ConnectEditor(Int_t tabNum); Connect every widget entry of the editor to its specific slot. void DisconnectEditor(Int_t tabNum); Disconnect every widget entry of the editor from its slot. Must be; called before UpdateEditor() to avoid recurs",MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:50759,Integrability,interface,interface,50759,"tyle) and import the properties of the; current canvas inside. void CreateMacro(); Create a TGFileInfo concerning a macro, if it doesn't exist already. void AddToolbar(TGCompositeFrame* p); Add the tool bar to the frame 'p'. void AddTopLevelInterface(TGCompositeFrame* cf); Add the top level interface to the frame 'cf'. This part of the; interface will provide all enable functionalities, excluding the; edition of styles. void BuildList(TStyle* style = 0); Build the list of styles which will appear in the available styles; combo box. The new style to select is mentioned. If no style has; been specified, the last entry of the list is selected. void UpdateStatusBar(); Update the content of the status bar: show the name of the current; selected style, its title and the macro from which it has been imported. void UpdateEditor(Int_t tabNum); Update the values of every widget entry in the editor. The new values; are loaded from the current selected style. void ConnectAll(); Connect every entry in the top level interface to the slot. void DisconnectAll(); Disconnect every entry in the top level interface of the slot. void ConnectEditor(Int_t tabNum); Connect every widget entry of the editor to its specific slot. void DisconnectEditor(Int_t tabNum); Disconnect every widget entry of the editor from its slot. Must be; called before UpdateEditor() to avoid recursive calls. void DoEditor(); Called each time something is changed in the style editor. Thanks to; this method, we can know if the style differs from the original style. void AddEdition(TGCompositeFrame* p); Add the editor to the frame 'p'. It contains the tabs allowing the user; to modify every data member of the current TStyle object. void CreateTabGeneral(TGCompositeFrame* tab); Add the tab 'General' to the editor. void AddGeneralFill(TGCompositeFrame* f); Add the 'Fill' group frame to the 'General' tab. void AddGeneralLine(TGCompositeFrame* f); Add the 'Line' group frame to the 'General' tab. void AddGeneralText(TGComp",MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:50844,Integrability,interface,interface,50844," Create a TGFileInfo concerning a macro, if it doesn't exist already. void AddToolbar(TGCompositeFrame* p); Add the tool bar to the frame 'p'. void AddTopLevelInterface(TGCompositeFrame* cf); Add the top level interface to the frame 'cf'. This part of the; interface will provide all enable functionalities, excluding the; edition of styles. void BuildList(TStyle* style = 0); Build the list of styles which will appear in the available styles; combo box. The new style to select is mentioned. If no style has; been specified, the last entry of the list is selected. void UpdateStatusBar(); Update the content of the status bar: show the name of the current; selected style, its title and the macro from which it has been imported. void UpdateEditor(Int_t tabNum); Update the values of every widget entry in the editor. The new values; are loaded from the current selected style. void ConnectAll(); Connect every entry in the top level interface to the slot. void DisconnectAll(); Disconnect every entry in the top level interface of the slot. void ConnectEditor(Int_t tabNum); Connect every widget entry of the editor to its specific slot. void DisconnectEditor(Int_t tabNum); Disconnect every widget entry of the editor from its slot. Must be; called before UpdateEditor() to avoid recursive calls. void DoEditor(); Called each time something is changed in the style editor. Thanks to; this method, we can know if the style differs from the original style. void AddEdition(TGCompositeFrame* p); Add the editor to the frame 'p'. It contains the tabs allowing the user; to modify every data member of the current TStyle object. void CreateTabGeneral(TGCompositeFrame* tab); Add the tab 'General' to the editor. void AddGeneralFill(TGCompositeFrame* f); Add the 'Fill' group frame to the 'General' tab. void AddGeneralLine(TGCompositeFrame* f); Add the 'Line' group frame to the 'General' tab. void AddGeneralText(TGCompositeFrame* f); Add the 'Text' group frame to the 'General' tab. void AddGeneralMa",MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:1022,Modifiability,variab,variable,1022,"ss Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TStyleManager. class TStyleManager: public TGMainFrame. TStyleManager. This class provides a Graphical User Interface to manage styles; in ROOT. It allows the user to edit styles, import / export; them to macros, apply a style on the selected object or on; all canvases, change gStyle. Activate the style manager by selecting Edit menu / Style...; in the canvas window. The Style Manager interface is composed of two parts:; - the top level interface that manages a list of styles;; - the style editor, which deals with the current style settings. /*. */. The combo box 'Available Styles' contains the list of available; styles for the current ROOT session and shows the currently; selected one. The field on the right shows the setting of the gStyle.; You can set the global variable gStyle to the selected style by; clicking on the button in the middle.; The group frame 'Apply on' displays information for the currently; selected canvas and object in the ROOT session. This selection might; be changed by clicking on another object with the middle mouse; button. You have a choice to apply a style on the selected object or; on all available canvases.; WARNING: You cannot undo the changes after applying the style! If; you are not sure of that action, it may be better to see a preview; of what you are going to apply.; If the check button 'Preview' is selected, a preview of the selected; canvas according to the selected style will be shown. The selection; of the next check button 'Run Time Preview' will apply updates of; the preview any time a value of the selected style is changed. For; drawings that take a time it is better to disable this option. Create a new style:; A new style can be created via the Style menu/New... or the toolbar.; A clone of the selected style will be used as a bas",MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:46113,Performance,optimiz,optimization,46113,BarImportCanvasPictool bar 'Import from canvas' picture; TGPictureButton*fToolBarImportMacrotool bar 'Import from macro' button; const TGPicture*fToolBarImportMacroPictool bar 'Import from macro' picture; TGPictureButton*fToolBarNewtool bar 'New' button; const TGPicture*fToolBarNewPictool bar 'New' picture; TList*fTrashListFrameto avoid memory leak; TList*fTrashListLayoutto avoid memory leak; TGColorSelect*fXAxisColorX axis color selection widget; TGColorSelect*fXLabelColorX axis label color selection widget; TGFontTypeComboBox*fXLabelFontX axis label font combo box; TGNumberEntry*fXLabelOffsetX axis label offset number entry; TGNumberEntry*fXLabelSizeX axis label size number entry; TGCheckButton*fXLabelSizeInPixelsX axis label size check box; TGNumberEntry*fXNdivMainX axis primary division number entry; TGNumberEntry*fXNdivSubX axis secondary division number entry; TGNumberEntry*fXNdivSubSubX axis tertiary division number entry; TGCheckButton*fXNdivisionsOptimizeX axis division optimization check box; TGNumberEntry*fXTickLengthX axis tick length number entry; TGColorSelect*fXTitleColorX axis title color selection widget; TGFontTypeComboBox*fXTitleFontX axis title font combo box; TGNumberEntry*fXTitleOffsetX axis title offset number entry; TGNumberEntry*fXTitleSizeX axis title size number entry; TGCheckButton*fXTitleSizeInPixelsX axis title size check box; TGColorSelect*fYAxisColorY axis color selection widget; TGColorSelect*fYLabelColorY axis label color selection widget; TGFontTypeComboBox*fYLabelFontY axis label font combo box; TGNumberEntry*fYLabelOffsetY axis label offset number entry; TGNumberEntry*fYLabelSizeY axis label size number entry; TGCheckButton*fYLabelSizeInPixelsY axis label size check box; TGNumberEntry*fYNdivMainY axis primary division number entry; TGNumberEntry*fYNdivSubY axis secondary division number entry; TGNumberEntry*fYNdivSubSubY axis tertiary division number entry; TGCheckButton*fYNdivisionsOptimizeY axis division optimization check box; ,MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:47096,Performance,optimiz,optimization,47096,s division optimization check box; TGNumberEntry*fXTickLengthX axis tick length number entry; TGColorSelect*fXTitleColorX axis title color selection widget; TGFontTypeComboBox*fXTitleFontX axis title font combo box; TGNumberEntry*fXTitleOffsetX axis title offset number entry; TGNumberEntry*fXTitleSizeX axis title size number entry; TGCheckButton*fXTitleSizeInPixelsX axis title size check box; TGColorSelect*fYAxisColorY axis color selection widget; TGColorSelect*fYLabelColorY axis label color selection widget; TGFontTypeComboBox*fYLabelFontY axis label font combo box; TGNumberEntry*fYLabelOffsetY axis label offset number entry; TGNumberEntry*fYLabelSizeY axis label size number entry; TGCheckButton*fYLabelSizeInPixelsY axis label size check box; TGNumberEntry*fYNdivMainY axis primary division number entry; TGNumberEntry*fYNdivSubY axis secondary division number entry; TGNumberEntry*fYNdivSubSubY axis tertiary division number entry; TGCheckButton*fYNdivisionsOptimizeY axis division optimization check box; TGNumberEntry*fYTickLengthY axis tick length number entry; TGColorSelect*fYTitleColorY axis title color selection widget; TGFontTypeComboBox*fYTitleFontY axis title font combo box; TGNumberEntry*fYTitleOffsetY axis title offset number entry; TGNumberEntry*fYTitleSizeY axis title size number entry; TGCheckButton*fYTitleSizeInPixelsY axis title size check box; TGColorSelect*fZAxisColorZ axis color selection widget; TGColorSelect*fZLabelColorZ axis label color selection widget; TGFontTypeComboBox*fZLabelFontZ axis label font combo box; TGNumberEntry*fZLabelOffsetZ axis label offset number entry; TGNumberEntry*fZLabelSizeZ axis label size number entry; TGCheckButton*fZLabelSizeInPixelsZ axis label size check box; TGNumberEntry*fZNdivMainZ axis primary division number entry; TGNumberEntry*fZNdivSubZ axis secondary division number entry; TGNumberEntry*fZNdivSubSubZ axis tertiary division number entry; TGCheckButton*fZNdivisionsOptimizeZ axis division optimization check box; ,MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:48079,Performance,optimiz,optimization,48079,rY axis color selection widget; TGColorSelect*fYLabelColorY axis label color selection widget; TGFontTypeComboBox*fYLabelFontY axis label font combo box; TGNumberEntry*fYLabelOffsetY axis label offset number entry; TGNumberEntry*fYLabelSizeY axis label size number entry; TGCheckButton*fYLabelSizeInPixelsY axis label size check box; TGNumberEntry*fYNdivMainY axis primary division number entry; TGNumberEntry*fYNdivSubY axis secondary division number entry; TGNumberEntry*fYNdivSubSubY axis tertiary division number entry; TGCheckButton*fYNdivisionsOptimizeY axis division optimization check box; TGNumberEntry*fYTickLengthY axis tick length number entry; TGColorSelect*fYTitleColorY axis title color selection widget; TGFontTypeComboBox*fYTitleFontY axis title font combo box; TGNumberEntry*fYTitleOffsetY axis title offset number entry; TGNumberEntry*fYTitleSizeY axis title size number entry; TGCheckButton*fYTitleSizeInPixelsY axis title size check box; TGColorSelect*fZAxisColorZ axis color selection widget; TGColorSelect*fZLabelColorZ axis label color selection widget; TGFontTypeComboBox*fZLabelFontZ axis label font combo box; TGNumberEntry*fZLabelOffsetZ axis label offset number entry; TGNumberEntry*fZLabelSizeZ axis label size number entry; TGCheckButton*fZLabelSizeInPixelsZ axis label size check box; TGNumberEntry*fZNdivMainZ axis primary division number entry; TGNumberEntry*fZNdivSubZ axis secondary division number entry; TGNumberEntry*fZNdivSubSubZ axis tertiary division number entry; TGCheckButton*fZNdivisionsOptimizeZ axis division optimization check box; TGNumberEntry*fZTickLengthZ axis tick length number entry; TGColorSelect*fZTitleColorZ axis title color selection widget; TGFontTypeComboBox*fZTitleFontZ axis title font combo box; TGNumberEntry*fZTitleOffsetZ axis title offset number entry; TGNumberEntry*fZTitleSizeZ axis title size number entry; TGCheckButton*fZTitleSizeInPixelsZ axis title size check box; static TStyleManager*fgStyleManagersingleton style manager.,MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:50663,Performance,load,loaded,50663,"the tool bar. void DoImportCanvas(); Create a new style (a copy of gStyle) and import the properties of the; current canvas inside. void CreateMacro(); Create a TGFileInfo concerning a macro, if it doesn't exist already. void AddToolbar(TGCompositeFrame* p); Add the tool bar to the frame 'p'. void AddTopLevelInterface(TGCompositeFrame* cf); Add the top level interface to the frame 'cf'. This part of the; interface will provide all enable functionalities, excluding the; edition of styles. void BuildList(TStyle* style = 0); Build the list of styles which will appear in the available styles; combo box. The new style to select is mentioned. If no style has; been specified, the last entry of the list is selected. void UpdateStatusBar(); Update the content of the status bar: show the name of the current; selected style, its title and the macro from which it has been imported. void UpdateEditor(Int_t tabNum); Update the values of every widget entry in the editor. The new values; are loaded from the current selected style. void ConnectAll(); Connect every entry in the top level interface to the slot. void DisconnectAll(); Disconnect every entry in the top level interface of the slot. void ConnectEditor(Int_t tabNum); Connect every widget entry of the editor to its specific slot. void DisconnectEditor(Int_t tabNum); Disconnect every widget entry of the editor from its slot. Must be; called before UpdateEditor() to avoid recursive calls. void DoEditor(); Called each time something is changed in the style editor. Thanks to; this method, we can know if the style differs from the original style. void AddEdition(TGCompositeFrame* p); Add the editor to the frame 'p'. It contains the tabs allowing the user; to modify every data member of the current TStyle object. void CreateTabGeneral(TGCompositeFrame* tab); Add the tab 'General' to the editor. void AddGeneralFill(TGCompositeFrame* f); Add the 'Fill' group frame to the 'General' tab. void AddGeneralLine(TGCompositeFrame* f); Add t",MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:45452,Safety,avoid,avoid,45452,fTitleTextColortitle text color selection widget; TGNumberEntry*fTitleWtitle width number entry; TGNumberEntry*fTitleXtitle abscissa number entry; TGNumberEntry*fTitleYtitle ordinate number entry; TGToolBar*fToolBarthe tool bar; TGPictureButton*fToolBarDeletetool bar 'Delete' button; const TGPicture*fToolBarDeletePictool bar 'Delete' picture; TGPictureButton*fToolBarExporttool bar 'Export' button; const TGPicture*fToolBarExportPictool bar 'Export' picture; TGPictureButton*fToolBarHelptool bar 'Help' button; const TGPicture*fToolBarHelpPictool bar 'Help' picture; TGPictureButton*fToolBarImportCanvastool bar 'Import from canvas' button; const TGPicture*fToolBarImportCanvasPictool bar 'Import from canvas' picture; TGPictureButton*fToolBarImportMacrotool bar 'Import from macro' button; const TGPicture*fToolBarImportMacroPictool bar 'Import from macro' picture; TGPictureButton*fToolBarNewtool bar 'New' button; const TGPicture*fToolBarNewPictool bar 'New' picture; TList*fTrashListFrameto avoid memory leak; TList*fTrashListLayoutto avoid memory leak; TGColorSelect*fXAxisColorX axis color selection widget; TGColorSelect*fXLabelColorX axis label color selection widget; TGFontTypeComboBox*fXLabelFontX axis label font combo box; TGNumberEntry*fXLabelOffsetX axis label offset number entry; TGNumberEntry*fXLabelSizeX axis label size number entry; TGCheckButton*fXLabelSizeInPixelsX axis label size check box; TGNumberEntry*fXNdivMainX axis primary division number entry; TGNumberEntry*fXNdivSubX axis secondary division number entry; TGNumberEntry*fXNdivSubSubX axis tertiary division number entry; TGCheckButton*fXNdivisionsOptimizeX axis division optimization check box; TGNumberEntry*fXTickLengthX axis tick length number entry; TGColorSelect*fXTitleColorX axis title color selection widget; TGFontTypeComboBox*fXTitleFontX axis title font combo box; TGNumberEntry*fXTitleOffsetX axis title offset number entry; TGNumberEntry*fXTitleSizeX axis title size number entry; TGCheckButton*fXTit,MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:45496,Safety,avoid,avoid,45496,dget; TGNumberEntry*fTitleWtitle width number entry; TGNumberEntry*fTitleXtitle abscissa number entry; TGNumberEntry*fTitleYtitle ordinate number entry; TGToolBar*fToolBarthe tool bar; TGPictureButton*fToolBarDeletetool bar 'Delete' button; const TGPicture*fToolBarDeletePictool bar 'Delete' picture; TGPictureButton*fToolBarExporttool bar 'Export' button; const TGPicture*fToolBarExportPictool bar 'Export' picture; TGPictureButton*fToolBarHelptool bar 'Help' button; const TGPicture*fToolBarHelpPictool bar 'Help' picture; TGPictureButton*fToolBarImportCanvastool bar 'Import from canvas' button; const TGPicture*fToolBarImportCanvasPictool bar 'Import from canvas' picture; TGPictureButton*fToolBarImportMacrotool bar 'Import from macro' button; const TGPicture*fToolBarImportMacroPictool bar 'Import from macro' picture; TGPictureButton*fToolBarNewtool bar 'New' button; const TGPicture*fToolBarNewPictool bar 'New' picture; TList*fTrashListFrameto avoid memory leak; TList*fTrashListLayoutto avoid memory leak; TGColorSelect*fXAxisColorX axis color selection widget; TGColorSelect*fXLabelColorX axis label color selection widget; TGFontTypeComboBox*fXLabelFontX axis label font combo box; TGNumberEntry*fXLabelOffsetX axis label offset number entry; TGNumberEntry*fXLabelSizeX axis label size number entry; TGCheckButton*fXLabelSizeInPixelsX axis label size check box; TGNumberEntry*fXNdivMainX axis primary division number entry; TGNumberEntry*fXNdivSubX axis secondary division number entry; TGNumberEntry*fXNdivSubSubX axis tertiary division number entry; TGCheckButton*fXNdivisionsOptimizeX axis division optimization check box; TGNumberEntry*fXTickLengthX axis tick length number entry; TGColorSelect*fXTitleColorX axis title color selection widget; TGFontTypeComboBox*fXTitleFontX axis title font combo box; TGNumberEntry*fXTitleOffsetX axis title offset number entry; TGNumberEntry*fXTitleSizeX axis title size number entry; TGCheckButton*fXTitleSizeInPixelsX axis title size check box; T,MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:51101,Safety,avoid,avoid,51101,"ill provide all enable functionalities, excluding the; edition of styles. void BuildList(TStyle* style = 0); Build the list of styles which will appear in the available styles; combo box. The new style to select is mentioned. If no style has; been specified, the last entry of the list is selected. void UpdateStatusBar(); Update the content of the status bar: show the name of the current; selected style, its title and the macro from which it has been imported. void UpdateEditor(Int_t tabNum); Update the values of every widget entry in the editor. The new values; are loaded from the current selected style. void ConnectAll(); Connect every entry in the top level interface to the slot. void DisconnectAll(); Disconnect every entry in the top level interface of the slot. void ConnectEditor(Int_t tabNum); Connect every widget entry of the editor to its specific slot. void DisconnectEditor(Int_t tabNum); Disconnect every widget entry of the editor from its slot. Must be; called before UpdateEditor() to avoid recursive calls. void DoEditor(); Called each time something is changed in the style editor. Thanks to; this method, we can know if the style differs from the original style. void AddEdition(TGCompositeFrame* p); Add the editor to the frame 'p'. It contains the tabs allowing the user; to modify every data member of the current TStyle object. void CreateTabGeneral(TGCompositeFrame* tab); Add the tab 'General' to the editor. void AddGeneralFill(TGCompositeFrame* f); Add the 'Fill' group frame to the 'General' tab. void AddGeneralLine(TGCompositeFrame* f); Add the 'Line' group frame to the 'General' tab. void AddGeneralText(TGCompositeFrame* f); Add the 'Text' group frame to the 'General' tab. void AddGeneralMarker(TGCompositeFrame* f); Add the 'Marker' group frame to the 'General' tab. void CreateTabCanvas(TGCompositeFrame* tab); Add the tab 'Canvas' to the editor. void AddCanvasFill(TGCompositeFrame* f); Add the 'Fill' group frame to the 'Canvas' tab. void AddCanvasGeome",MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:40249,Testability,log,logarithmic,40249,el*fListLabellabel 'Available Styles:'; TGPictureButton*fMakeDefaultselected style becom gStyle; const TGPicture*fMakeDefaultPicbutton picture; TGColorSelect*fMarkerColorgeneral marker color selection widget; TGComboBox*fMarkerSizegeneral marker size combo box; TGedMarkerSelect*fMarkerStylegeneral marker style entry; TGMenuBar*fMenuBarthe main window menu bar; TGPopupMenu*fMenuHelpthe 'Help' popup menu; TGPopupMenu*fMenuStylethe 'Style' popup menu; Bool_tfMoreAndNotLess=kTRUE when editor is open; TGTextButton*fMoreLessopen/close the editor; TGNumberEntry*fNumberContourshistograms number of contours number entry; TGCheckButton*fOptDateBoolcanvas date show/hide check box; TGComboBox*fOptDateFormatcanvas date format text entry; TGCheckButton*fOptFitChifit Chi show/hide check box; TGCheckButton*fOptFitErrorsfit errors check box; TGCheckButton*fOptFitProbabilityfit probability show/hide check box; TGCheckButton*fOptFitValuesfit values show/hide check box; TGCheckButton*fOptLogxX axis logarithmic scale check box; TGCheckButton*fOptLogyY axis logarithmic scale check box; TGCheckButton*fOptLogzZ axis logarithmic scale check box; TGCheckButton*fOptStatEntriesstats entries show/hide check box; TGCheckButton*fOptStatErrorsstats errors check box; TGCheckButton*fOptStatIntegralstats integral show/hide check box; TGCheckButton*fOptStatKurtosisstats kurtosis show/hide check box; TGCheckButton*fOptStatMeanstats mean show/hide check box; TGCheckButton*fOptStatNamestats name show/hide check box; TGCheckButton*fOptStatOverflowstats overflow show/hide check box; TGCheckButton*fOptStatRMSstats RMS show/hide check box; TGCheckButton*fOptStatSkewnessstats Skewness show/hide check box; TGCheckButton*fOptStatUnderflowstats underflow show/hide check box; TGCheckButton*fOptTitletitle show/hide check box; TGButtonGroup*fPadBorderModepad border mode button group; TGLineWidthComboBox*fPadBorderSizepad border size combo box; TGNumberEntry*fPadBottomMarginpad bottom margin number entry; TGColorSel,MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:40307,Testability,log,logarithmic,40307,akeDefaultselected style becom gStyle; const TGPicture*fMakeDefaultPicbutton picture; TGColorSelect*fMarkerColorgeneral marker color selection widget; TGComboBox*fMarkerSizegeneral marker size combo box; TGedMarkerSelect*fMarkerStylegeneral marker style entry; TGMenuBar*fMenuBarthe main window menu bar; TGPopupMenu*fMenuHelpthe 'Help' popup menu; TGPopupMenu*fMenuStylethe 'Style' popup menu; Bool_tfMoreAndNotLess=kTRUE when editor is open; TGTextButton*fMoreLessopen/close the editor; TGNumberEntry*fNumberContourshistograms number of contours number entry; TGCheckButton*fOptDateBoolcanvas date show/hide check box; TGComboBox*fOptDateFormatcanvas date format text entry; TGCheckButton*fOptFitChifit Chi show/hide check box; TGCheckButton*fOptFitErrorsfit errors check box; TGCheckButton*fOptFitProbabilityfit probability show/hide check box; TGCheckButton*fOptFitValuesfit values show/hide check box; TGCheckButton*fOptLogxX axis logarithmic scale check box; TGCheckButton*fOptLogyY axis logarithmic scale check box; TGCheckButton*fOptLogzZ axis logarithmic scale check box; TGCheckButton*fOptStatEntriesstats entries show/hide check box; TGCheckButton*fOptStatErrorsstats errors check box; TGCheckButton*fOptStatIntegralstats integral show/hide check box; TGCheckButton*fOptStatKurtosisstats kurtosis show/hide check box; TGCheckButton*fOptStatMeanstats mean show/hide check box; TGCheckButton*fOptStatNamestats name show/hide check box; TGCheckButton*fOptStatOverflowstats overflow show/hide check box; TGCheckButton*fOptStatRMSstats RMS show/hide check box; TGCheckButton*fOptStatSkewnessstats Skewness show/hide check box; TGCheckButton*fOptStatUnderflowstats underflow show/hide check box; TGCheckButton*fOptTitletitle show/hide check box; TGButtonGroup*fPadBorderModepad border mode button group; TGLineWidthComboBox*fPadBorderSizepad border size combo box; TGNumberEntry*fPadBottomMarginpad bottom margin number entry; TGColorSelect*fPadColorpad fill color selection widget; TGCheckButto,MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:40365,Testability,log,logarithmic,40365,keDefaultPicbutton picture; TGColorSelect*fMarkerColorgeneral marker color selection widget; TGComboBox*fMarkerSizegeneral marker size combo box; TGedMarkerSelect*fMarkerStylegeneral marker style entry; TGMenuBar*fMenuBarthe main window menu bar; TGPopupMenu*fMenuHelpthe 'Help' popup menu; TGPopupMenu*fMenuStylethe 'Style' popup menu; Bool_tfMoreAndNotLess=kTRUE when editor is open; TGTextButton*fMoreLessopen/close the editor; TGNumberEntry*fNumberContourshistograms number of contours number entry; TGCheckButton*fOptDateBoolcanvas date show/hide check box; TGComboBox*fOptDateFormatcanvas date format text entry; TGCheckButton*fOptFitChifit Chi show/hide check box; TGCheckButton*fOptFitErrorsfit errors check box; TGCheckButton*fOptFitProbabilityfit probability show/hide check box; TGCheckButton*fOptFitValuesfit values show/hide check box; TGCheckButton*fOptLogxX axis logarithmic scale check box; TGCheckButton*fOptLogyY axis logarithmic scale check box; TGCheckButton*fOptLogzZ axis logarithmic scale check box; TGCheckButton*fOptStatEntriesstats entries show/hide check box; TGCheckButton*fOptStatErrorsstats errors check box; TGCheckButton*fOptStatIntegralstats integral show/hide check box; TGCheckButton*fOptStatKurtosisstats kurtosis show/hide check box; TGCheckButton*fOptStatMeanstats mean show/hide check box; TGCheckButton*fOptStatNamestats name show/hide check box; TGCheckButton*fOptStatOverflowstats overflow show/hide check box; TGCheckButton*fOptStatRMSstats RMS show/hide check box; TGCheckButton*fOptStatSkewnessstats Skewness show/hide check box; TGCheckButton*fOptStatUnderflowstats underflow show/hide check box; TGCheckButton*fOptTitletitle show/hide check box; TGButtonGroup*fPadBorderModepad border mode button group; TGLineWidthComboBox*fPadBorderSizepad border size combo box; TGNumberEntry*fPadBottomMarginpad bottom margin number entry; TGColorSelect*fPadColorpad fill color selection widget; TGCheckButton*fPadGridXpad grid along X show/hide check box; TGCheckBu,MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:68655,Testability,log,logarithmic,68655,user. void ModFrameBorderSize(); Slot called whenever the frame border size is modified by the user. void ModFuncColor(); Slot called whenever the function line color is modified by the user. void ModFuncWidth(); Slot called whenever the function line width is modified by the user. void ModFuncStyle(); Slot called whenever the function line style is modified by the user. void ModDrawBorder(); Slot called whenever the draw border boolean is modified by the user. void ModEndErrorSize(); Slot called whenever the end error size is modified by the user. void ModErrorX(); Slot called whenever the error along X is modified by the user. void ModTimeOffset(); Slot called whenever the time offset is modified by the user. void ModStripDecimals(); Slot called whenever the strip decimal boolean is modified by the user. void ModApplyOnXYZ(); Slot called whenever the apply on XYZ button is clicked. The settings of; the current selected axis pad are applyed on all axis.; NB: The logarithmic scale option isn't modified by this method. void ModXTitleSize(); Slot called whenever the X axis title size is modified by the user. void ModXTitleSizeInPixels(Bool_t b); Slot called whenever the X axis title size mode is modified by the user. void ModXTitleColor(); Slot called whenever the X axis title color is modified by the user. void ModXTitleOffset(); Slot called whenever the X axis title offset is modified by the user. void ModXTitleFont(); Slot called whenever the X axis title font is modified by the user. void ModXLabelSize(); Slot called whenever the X axis label size is modified by the user. void ModXLabelSizeInPixels(Bool_t b); Slot called whenever the X axis label size mode is modified by the user. void ModXLabelColor(); Slot called whenever the X axis label color is modified by the user. void ModXLabelOffset(); Slot called whenever the X axis label offset is modified by the user. void ModXLabelFont(); Slot called whenever the X axis label font is modified by the user. void ModXAxis,MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:69893,Testability,log,log,69893,s modified by the user. void ModXTitleColor(); Slot called whenever the X axis title color is modified by the user. void ModXTitleOffset(); Slot called whenever the X axis title offset is modified by the user. void ModXTitleFont(); Slot called whenever the X axis title font is modified by the user. void ModXLabelSize(); Slot called whenever the X axis label size is modified by the user. void ModXLabelSizeInPixels(Bool_t b); Slot called whenever the X axis label size mode is modified by the user. void ModXLabelColor(); Slot called whenever the X axis label color is modified by the user. void ModXLabelOffset(); Slot called whenever the X axis label offset is modified by the user. void ModXLabelFont(); Slot called whenever the X axis label font is modified by the user. void ModXAxisColor(); Slot called whenever the X axis color is modified by the user. void ModXTickLength(); Slot called whenever the X axis tick length is modified by the user. void ModOptLogx(); Slot called whenever the X axis log scale boolean is modified; by the user. void ModXNdivisions(); Slot called whenever the X axis Number of divisions is modified; by the user. void ModYTitleSize(); Slot called whenever the Y axis title size is modified by the user. void ModYTitleSizeInPixels(Bool_t b); Slot called whenever the Y axis title size mode is modified by the user. void ModYTitleColor(); Slot called whenever the Y axis title color is modified by the user. void ModYTitleOffset(); Slot called whenever the Y axis title offset is modified by the user. void ModYTitleFont(); Slot called whenever the Y axis title font is modified by the user. void ModYLabelSize(); Slot called whenever the Y axis label size is modified by the user. void ModYLabelSizeInPixels(Bool_t b); Slot called whenever the Y axis label size mode is modified by the user. void ModYLabelColor(); Slot called whenever the Y axis label color is modified by the user. void ModYLabelOffset(); Slot called whenever the Y axis label offset is modified ,MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:71220,Testability,log,log,71220,s modified by the user. void ModYTitleColor(); Slot called whenever the Y axis title color is modified by the user. void ModYTitleOffset(); Slot called whenever the Y axis title offset is modified by the user. void ModYTitleFont(); Slot called whenever the Y axis title font is modified by the user. void ModYLabelSize(); Slot called whenever the Y axis label size is modified by the user. void ModYLabelSizeInPixels(Bool_t b); Slot called whenever the Y axis label size mode is modified by the user. void ModYLabelColor(); Slot called whenever the Y axis label color is modified by the user. void ModYLabelOffset(); Slot called whenever the Y axis label offset is modified by the user. void ModYLabelFont(); Slot called whenever the Y axis label font is modified by the user. void ModYAxisColor(); Slot called whenever the Y axis color is modified by the user. void ModYTickLength(); Slot called whenever the Y axis tick length is modified by the user. void ModOptLogy(); Slot called whenever the Y axis log scale boolean is modified by the user. void ModYNdivisions(); Slot called whenever the Y axis Number of divisions is modified; by the user. void ModZTitleSize(); Slot called whenever the Z axis title size is modified by the user. void ModZTitleSizeInPixels(Bool_t b); Slot called whenever the Z axis title size mode is modified by the user. void ModZTitleColor(); Slot called whenever the Z axis title color is modified by the user. void ModZTitleOffset(); Slot called whenever the Z axis title offset is modified by the user. void ModZTitleFont(); Slot called whenever the Z axis title font is modified by the user. void ModZLabelSize(); Slot called whenever the Z axis label size is modified by the user. void ModZLabelSizeInPixels(Bool_t b); Slot called whenever the Z axis Label size mode is modified by the user. void ModZLabelColor(); Slot called whenever the Z axis label color is modified by the user. void ModZLabelOffset(); Slot called whenever the Z axis label offset is modified ,MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:72546,Testability,log,log,72546,s modified by the user. void ModZTitleColor(); Slot called whenever the Z axis title color is modified by the user. void ModZTitleOffset(); Slot called whenever the Z axis title offset is modified by the user. void ModZTitleFont(); Slot called whenever the Z axis title font is modified by the user. void ModZLabelSize(); Slot called whenever the Z axis label size is modified by the user. void ModZLabelSizeInPixels(Bool_t b); Slot called whenever the Z axis Label size mode is modified by the user. void ModZLabelColor(); Slot called whenever the Z axis label color is modified by the user. void ModZLabelOffset(); Slot called whenever the Z axis label offset is modified by the user. void ModZLabelFont(); Slot called whenever the Z axis label font is modified by the user. void ModZAxisColor(); Slot called whenever the Z axis color is modified by the user. void ModZTickLength(); Slot called whenever the Z axis tick length is modified by the user. void ModOptLogz(); Slot called whenever the Z axis log scale boolean is modified by the user. void ModZNdivisions(); Slot called whenever the Z axis Number of divisions is modified; by the user. void ModOptTitle(); Slot called whenever the OptTitle boolean is modified by the user. void ModTitleFillColor(); Slot called whenever the title fill color is modified by the user. void ModTitleStyle(); Slot called whenever the title fill style is modified by the user. void ModTitleTextColor(); Slot called whenever the title text color is modified by the user. void ModTitleFontSize(); Slot called whenever the text size is modified by the user. void ModTitleFontSizeInPixels(Bool_t b); Slot called whenever the text size mode is modified by the user. void ModTitleFont(); Slot called whenever the title text font is modified by the user. void ModTitleAlign(); Slot called whenever the title text align is modified by the user. void ModTitleBorderSize(); Slot called whenever the title border size is modified by the user. void ModLegendBorderSize();,MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStyleManager.html:1422,Usability,undo,undo,1422,"cted object or on; all canvases, change gStyle. Activate the style manager by selecting Edit menu / Style...; in the canvas window. The Style Manager interface is composed of two parts:; - the top level interface that manages a list of styles;; - the style editor, which deals with the current style settings. /*. */. The combo box 'Available Styles' contains the list of available; styles for the current ROOT session and shows the currently; selected one. The field on the right shows the setting of the gStyle.; You can set the global variable gStyle to the selected style by; clicking on the button in the middle.; The group frame 'Apply on' displays information for the currently; selected canvas and object in the ROOT session. This selection might; be changed by clicking on another object with the middle mouse; button. You have a choice to apply a style on the selected object or; on all available canvases.; WARNING: You cannot undo the changes after applying the style! If; you are not sure of that action, it may be better to see a preview; of what you are going to apply.; If the check button 'Preview' is selected, a preview of the selected; canvas according to the selected style will be shown. The selection; of the next check button 'Run Time Preview' will apply updates of; the preview any time a value of the selected style is changed. For; drawings that take a time it is better to disable this option. Create a new style:; A new style can be created via the Style menu/New... or the toolbar.; A clone of the selected style will be used as a base of the new; style. All its values can be modified via the style editor later.; The dialog that appears will ask for the name and description of the; new style. Import a style (from a macro):; A style macro can be imported at any time. The new imported style in; the ROOT session will become the selected one. Import a style (from a canvas):; You can do that selecting the Style menu/Import from.../Canvas or; the corresponding Tool b",MatchSource.WIKI,root/html534/TStyleManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStyleManager.html
https://root.cern/root/html534/TStylePreview.html:4576,Availability,error,error,4576,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html534/TStylePreview.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStylePreview.html
https://root.cern/root/html534/TStylePreview.html:4660,Availability,error,error,4660,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UIn",MatchSource.WIKI,root/html534/TStylePreview.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStylePreview.html
https://root.cern/root/html534/TStylePreview.html:19044,Availability,mask,mask,19044,,MatchSource.WIKI,root/html534/TStylePreview.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStylePreview.html
https://root.cern/root/html534/TStylePreview.html:22060,Safety,avoid,avoid,22060,"dowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TRootEmbeddedCanvas*fEcancanvas for preview; TVirtualPad*fPadoriginal pad previewed; TList*fTrashListLayoutto avoid memory leak. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStylePreview(const TGWindow* p, TStyle* style, TVirtualPad* currentPad); Constructor. Create a new window and draw a clone of; currentPad->GetCanvas() in it, using the style 'style'.; Thanks to that method, one can have a preview of any; style with any object. ~TStylePreview(); Destructor. void Update(TStyle* style, TVirtualPad* pad); Update the preview with possibly another style and; another object than previously. void MapTheWindow(); Initialize the layout algorithm. TCanvas * GetMainCanvas(); Return pointer to the selected canvas. » Author: Denis Favre-Miville 08/09/05 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id: TStylePreview.h,v 1.0 2005/09/08 » Last generated: 2015-03-14 16:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ",MatchSource.WIKI,root/html534/TStylePreview.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TStylePreview.html
https://root.cern/root/html534/TSubString.html:2560,Safety,detect,detecting,2560," Data Members; private:. Ssiz_tfBeginIndex of starting character; Ssiz_tfExtentLength of TSubString; TString&fStrReferenced string. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const char * Data() const; Return a pointer to the beginning of the substring. Note that the; terminating null is in the same place as for the original; TString, so this method is not appropriate for converting the; TSubString to a string. To do that, construct a TString from the; TSubString. For example:. root [0] TString s(""hello world""); root [1] TSubString sub=s(0, 5); root [2] sub.Data(); (const char* 0x857c8b8)""hello world""; root [3] TString substr(sub); root [4] substr; (class TString)""hello"". char operator[](Ssiz_t i) const; Access to elements of sub-string with bounds checking. { AssertElement(i); return fStr.GetPointer()[fBegin+i]; }. char operator()(Ssiz_t i) const; { return fStr.GetPointer()[fBegin+i]; }. TSubString & operator=(const TSubString& s); { fStr = s.fStr; fBegin = s.fBegin; fExtent = s.fExtent; return *this; }. TSubString(const TString& s, Ssiz_t start, Ssiz_t len); NB: the only constructor is private. void SubStringError(Ssiz_t , Ssiz_t , Ssiz_t ) const. void AssertElement(Ssiz_t i) const. TSubString(const TSubString& s); { }. TSubString & operator=(const char* s). TSubString & operator=(const TString& s). char & operator()(Ssiz_t i). char & operator[](Ssiz_t i). Ssiz_t Length() const; { return fExtent; }. Ssiz_t Start() const; { return fBegin; }. void ToLower(). void ToUpper(). Bool_t IsNull() const; For detecting null substrings. { return fBegin == kNPOS; }. int operator!() const; { return fBegin == kNPOS; }. » Author: Fons Rademakers 04/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TSubString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSubString.html
https://root.cern/root/html534/TSVDUnfold.html:1126,Availability,error,errors,1126,". TSVDUnfold. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TSVDUnfold. class TSVDUnfold: public TObject. SVD Approach to Data Unfolding. Reference: Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307]. TSVDUnfold implements the singular value decomposition based unfolding method (see reference). Currently, the unfolding of one-dimensional histograms is supported, with the same number of bins for the measured and the unfolded spectrum.; ; The unfolding procedure is based on singular value decomposition of the response matrix. The regularisation of the unfolding is implemented via a discrete minimum-curvature condition.; ; Monte Carlo inputs:; ; xini: true underlying spectrum (TH1D, n bins); bini: reconstructed spectrum (TH1D, n bins); Adet: response matrix (TH2D, nxn bins); ; Consider the unfolding of a measured spectrum bdat with covariance matrix Bcov (if not passed explicitly, a diagonal covariance will be built given the errors of bdat). The corresponding spectrum in the Monte Carlo is given by bini, with the true underlying spectrum given by xini. The detector response is described by Adet, with Adet filled with events (not probabilities) with the true observable on the y-axis and the reconstructed observable on the x-axis.; ; The measured distribution can be unfolded for any combination of resolution, efficiency and acceptance effects, provided an appropriate definition of xini and Adet. The unfolding can be performed by; . TSVDUnfold *tsvdunf = new TSVDUnfold( bdat, Bcov, bini, xini, Adet );; TH1D* unfresult = tsvdunf->Unfold( kreg );; . where kreg determines the regularisation of the unfolding. In general, overregularisation (too small kreg) will bias the unfolded spectrum towards the Monte Carlo input, while underregularisation (too large kreg) will lead to large fluctuation",MatchSource.WIKI,root/html534/TSVDUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSVDUnfold.html
https://root.cern/root/html534/TSVDUnfold.html:4288,Availability,error,error,4288,"l~TSVDUnfold(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Double_tComputeChiSquared(const TH1D& truspec, const TH1D& unfspec); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TH2D*GetAdetCovMatrix(Int_t ntoys, Int_t seed = 1); TH2D*GetBCov() const; TH1D*GetD() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetKReg() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TH1D*GetSV() const; virtual const char*TObject::GetTitle() const; TH2D*GetUnfoldCovMatrix(const TH2D* cov, Int_t ntoys, Int_t seed = 1); virtual UInt_tTObject::GetUniqueID() const; TH2D*GetXinv() con",MatchSource.WIKI,root/html534/TSVDUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSVDUnfold.html
https://root.cern/root/html534/TSVDUnfold.html:4372,Availability,error,error,4372,"Object::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Double_tComputeChiSquared(const TH1D& truspec, const TH1D& unfspec); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TH2D*GetAdetCovMatrix(Int_t ntoys, Int_t seed = 1); TH2D*GetBCov() const; TH1D*GetD() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetKReg() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TH1D*GetSV() const; virtual const char*TObject::GetTitle() const; TH2D*GetUnfoldCovMatrix(const TH2D* cov, Int_t ntoys, Int_t seed = 1); virtual UInt_tTObject::GetUniqueID() const; TH2D*GetXinv() const; TH2D*GetXtau() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual",MatchSource.WIKI,root/html534/TSVDUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSVDUnfold.html
https://root.cern/root/html534/TSVDUnfold.html:10909,Availability,error,error,10909,"umentation; TSVDUnfold(const TH1D* bdat, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Alternative constructor; User provides data and MC test spectra, as well as detector response matrix, diagonal covariance matrix of measured spectrum built from the uncertainties on measured spectrum. TSVDUnfold(const TH1D* bdat, TH2D* Bcov, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Default constructor; Initialisation of TSVDUnfold; User provides data and MC test spectra, as well as detector response matrix and the covariance matrix of the measured distribution. TSVDUnfold(const TSVDUnfold& other); Copy constructor. ~TSVDUnfold(); Destructor. TH1D* Unfold(Int_t kreg); Perform the unfolding with regularisation parameter kreg. TH2D* GetUnfoldCovMatrix(const TH2D* cov, Int_t ntoys, Int_t seed = 1); Determine for given input error matrix covariance matrix of unfolded; spectrum from toy simulation given the passed covariance matrix on measured spectrum; ""cov"" - covariance matrix on the measured spectrum, to be propagated; ""ntoys"" - number of pseudo experiments used for the propagation; ""seed"" - seed for pseudo experiments; Note that this covariance matrix will contain effects of forced normalisation if spectrum is normalised to unit area. TH2D* GetAdetCovMatrix(Int_t ntoys, Int_t seed = 1); Determine covariance matrix of unfolded spectrum from finite statistics in; response matrix using pseudo experiments; ""ntoys"" - number of pseudo experiments used for the propagation; ""seed"" - seed for pseudo experiments. TH1D* GetD() const; Returns d vector (for choosing appropriate regularisation). TH1D* GetSV() const; Returns singular values vector. TH2D* GetXtau() const; Returns the computed regularized covariance matrix corresponding to total uncertainties on measured spectrum as passed in the constructor.; Note that this covariance matrix will not contain the effects of forced normalization if spectrum is normalized to unit area. TH2D* GetXinv() const; Returns the computed ",MatchSource.WIKI,root/html534/TSVDUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSVDUnfold.html
https://root.cern/root/html534/TSVDUnfold.html:12298,Availability,error,errors,12298,"d normalisation if spectrum is normalised to unit area. TH2D* GetAdetCovMatrix(Int_t ntoys, Int_t seed = 1); Determine covariance matrix of unfolded spectrum from finite statistics in; response matrix using pseudo experiments; ""ntoys"" - number of pseudo experiments used for the propagation; ""seed"" - seed for pseudo experiments. TH1D* GetD() const; Returns d vector (for choosing appropriate regularisation). TH1D* GetSV() const; Returns singular values vector. TH2D* GetXtau() const; Returns the computed regularized covariance matrix corresponding to total uncertainties on measured spectrum as passed in the constructor.; Note that this covariance matrix will not contain the effects of forced normalization if spectrum is normalized to unit area. TH2D* GetXinv() const; Returns the computed inverse of the covariance matrix. TH2D* GetBCov() const; Returns the covariance matrix. void H2V(const TH1D* histo, TVectorD& vec); Fill 1D histogram into vector. void H2Verr(const TH1D* histo, TVectorD& vec); Fill 1D histogram errors into vector. void V2H(const TVectorD& vec, TH1D& histo); Fill vector into 1D histogram. void H2M(const TH2D* histo, TMatrixD& mat); Fill 2D histogram into matrix. void M2H(const TMatrixD& mat, TH2D& histo); Fill 2D histogram into matrix. TVectorD VecDiv(const TVectorD& vec1, const TVectorD& vec2, Int_t zero = 0); Divide entries of two vectors. TMatrixD MatDivVec(const TMatrixD& mat, const TVectorD& vec, Int_t zero = 0); Divide matrix entries by vector. TVectorD CompProd(const TVectorD& vec1, const TVectorD& vec2); Multiply entries of two vectors. Double_t GetCurvature(const TVectorD& vec, const TMatrixD& curv); Compute curvature of vector. void FillCurvatureMatrix(TMatrixD& tCurv, TMatrixD& tC) const. void InitHistos(). void RegularisedSymMatInvert(TMatrixDSym& mat, Double_t eps = 1e-3); naive regularised inversion cuts off small elements. Double_t ComputeChiSquared(const TH1D& truspec, const TH1D& unfspec); Helper routine to compute chi-squared between di",MatchSource.WIKI,root/html534/TSVDUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSVDUnfold.html
https://root.cern/root/html534/TSVDUnfold.html:13234,Integrability,rout,routine,13234,"his covariance matrix will not contain the effects of forced normalization if spectrum is normalized to unit area. TH2D* GetXinv() const; Returns the computed inverse of the covariance matrix. TH2D* GetBCov() const; Returns the covariance matrix. void H2V(const TH1D* histo, TVectorD& vec); Fill 1D histogram into vector. void H2Verr(const TH1D* histo, TVectorD& vec); Fill 1D histogram errors into vector. void V2H(const TVectorD& vec, TH1D& histo); Fill vector into 1D histogram. void H2M(const TH2D* histo, TMatrixD& mat); Fill 2D histogram into matrix. void M2H(const TMatrixD& mat, TH2D& histo); Fill 2D histogram into matrix. TVectorD VecDiv(const TVectorD& vec1, const TVectorD& vec2, Int_t zero = 0); Divide entries of two vectors. TMatrixD MatDivVec(const TMatrixD& mat, const TVectorD& vec, Int_t zero = 0); Divide matrix entries by vector. TVectorD CompProd(const TVectorD& vec1, const TVectorD& vec2); Multiply entries of two vectors. Double_t GetCurvature(const TVectorD& vec, const TMatrixD& curv); Compute curvature of vector. void FillCurvatureMatrix(TMatrixD& tCurv, TMatrixD& tC) const. void InitHistos(). void RegularisedSymMatInvert(TMatrixDSym& mat, Double_t eps = 1e-3); naive regularised inversion cuts off small elements. Double_t ComputeChiSquared(const TH1D& truspec, const TH1D& unfspec); Helper routine to compute chi-squared between distributions using the computed inverse of the covariance matrix for the unfolded spectrum as given in paper. void SetNormalize(Bool_t normalize); Set option to normalize unfolded spectrum to unit area; ""normalize"" - switch. { fNormalize = normalize; }. Int_t GetKReg() const; Regularisation parameter. { return fKReg; }. » Author: Kerstin Tackmann, Andreas Hoecker, Heiko Lacker » Copyright (c) 2010: *; » Last changed: Sat Mar 14 16:49:20 2015 » Last generated: 2015-03-14 16:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TSVDUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSVDUnfold.html
https://root.cern/root/html534/TSVDUnfold.html:1625,Performance,perform,performed,1625,"trum.; ; The unfolding procedure is based on singular value decomposition of the response matrix. The regularisation of the unfolding is implemented via a discrete minimum-curvature condition.; ; Monte Carlo inputs:; ; xini: true underlying spectrum (TH1D, n bins); bini: reconstructed spectrum (TH1D, n bins); Adet: response matrix (TH2D, nxn bins); ; Consider the unfolding of a measured spectrum bdat with covariance matrix Bcov (if not passed explicitly, a diagonal covariance will be built given the errors of bdat). The corresponding spectrum in the Monte Carlo is given by bini, with the true underlying spectrum given by xini. The detector response is described by Adet, with Adet filled with events (not probabilities) with the true observable on the y-axis and the reconstructed observable on the x-axis.; ; The measured distribution can be unfolded for any combination of resolution, efficiency and acceptance effects, provided an appropriate definition of xini and Adet. The unfolding can be performed by; . TSVDUnfold *tsvdunf = new TSVDUnfold( bdat, Bcov, bini, xini, Adet );; TH1D* unfresult = tsvdunf->Unfold( kreg );; . where kreg determines the regularisation of the unfolding. In general, overregularisation (too small kreg) will bias the unfolded spectrum towards the Monte Carlo input, while underregularisation (too large kreg) will lead to large fluctuations in the unfolded spectrum. The optimal regularisation can be determined following guidelines in Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307] using the distribution of the |d_i|<\tt> that can be obtained by tsvdunf->GetD() and/or using pseudo-experiments.; ; Covariance matrices on the measured spectrum (for either the total uncertainties or individual sources of uncertainties) can be propagated to covariance matrices using the GetUnfoldCovMatrix method, which uses pseudo experiments for the propagation. In addition, GetAdetCovMatrix allows for the propagation of the statistical uncertainties on the respo",MatchSource.WIKI,root/html534/TSVDUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSVDUnfold.html
https://root.cern/root/html534/TSVDUnfold.html:1260,Safety,detect,detector,1260,"um. Meth. A372, 469 (1996) [hep-ph/9509307]. TSVDUnfold implements the singular value decomposition based unfolding method (see reference). Currently, the unfolding of one-dimensional histograms is supported, with the same number of bins for the measured and the unfolded spectrum.; ; The unfolding procedure is based on singular value decomposition of the response matrix. The regularisation of the unfolding is implemented via a discrete minimum-curvature condition.; ; Monte Carlo inputs:; ; xini: true underlying spectrum (TH1D, n bins); bini: reconstructed spectrum (TH1D, n bins); Adet: response matrix (TH2D, nxn bins); ; Consider the unfolding of a measured spectrum bdat with covariance matrix Bcov (if not passed explicitly, a diagonal covariance will be built given the errors of bdat). The corresponding spectrum in the Monte Carlo is given by bini, with the true underlying spectrum given by xini. The detector response is described by Adet, with Adet filled with events (not probabilities) with the true observable on the y-axis and the reconstructed observable on the x-axis.; ; The measured distribution can be unfolded for any combination of resolution, efficiency and acceptance effects, provided an appropriate definition of xini and Adet. The unfolding can be performed by; . TSVDUnfold *tsvdunf = new TSVDUnfold( bdat, Bcov, bini, xini, Adet );; TH1D* unfresult = tsvdunf->Unfold( kreg );; . where kreg determines the regularisation of the unfolding. In general, overregularisation (too small kreg) will bias the unfolded spectrum towards the Monte Carlo input, while underregularisation (too large kreg) will lead to large fluctuations in the unfolded spectrum. The optimal regularisation can be determined following guidelines in Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307] using the distribution of the |d_i|<\tt> that can be obtained by tsvdunf->GetD() and/or using pseudo-experiments.; ; Covariance matrices on the measured spectrum (for either the total uncertai",MatchSource.WIKI,root/html534/TSVDUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSVDUnfold.html
https://root.cern/root/html534/TSVDUnfold.html:9820,Safety,detect,detector,9820,"DivVec(const TMatrixD& mat, const TVectorD& vec, Int_t zero = 0); static voidRegularisedSymMatInvert(TMatrixDSym& mat, Double_t eps = 1e-3); static voidV2H(const TVectorD& vec, TH1D& histo); static TVectorDVecDiv(const TVectorD& vec1, const TVectorD& vec2, Int_t zero = 0). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. const TH2D*fAdetDetector response matrix; TH2D*fBcovcovariance matrix of measured distribution (data); const TH1D*fBdatmeasured distribution (data); const TH1D*fBinireconstructed distribution (MC); TH1D*fDHist! Distribution of d (for checking regularization); Int_tfDdim! Derivative for curvature matrix; Int_tfKReg! Regularisation parameter; Bool_tfMatToyMode! Internal switch for evaluation of statistical uncertainties from response matrix; Int_tfNdim! Truth and reconstructed dimensions; Bool_tfNormalize! Normalize unfolded spectrum to 1; TH1D*fSVHist! Distribution of singular values; Bool_tfToyMode! Internal switch for covariance matrix propagation; TH1D*fToyhisto! Toy MC histogram; TH2D*fToymat! Toy MC detector response matrix; const TH1D*fXinitruth distribution (MC); TH2D*fXinv! Computed inverse of covariance matrix; TH2D*fXtau! Computed regularized covariance matrix. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSVDUnfold(const TH1D* bdat, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Alternative constructor; User provides data and MC test spectra, as well as detector response matrix, diagonal covariance matrix of measured spectrum built from the uncertainties on measured spectrum. TSVDUnfold(const TH1D* bdat, TH2D* Bcov, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Default constructor; Initialisation of TSVDUnfold; User provides data and MC test spec",MatchSource.WIKI,root/html534/TSVDUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSVDUnfold.html
https://root.cern/root/html534/TSVDUnfold.html:10241,Safety,detect,detector,10241,"const TH1D*fBdatmeasured distribution (data); const TH1D*fBinireconstructed distribution (MC); TH1D*fDHist! Distribution of d (for checking regularization); Int_tfDdim! Derivative for curvature matrix; Int_tfKReg! Regularisation parameter; Bool_tfMatToyMode! Internal switch for evaluation of statistical uncertainties from response matrix; Int_tfNdim! Truth and reconstructed dimensions; Bool_tfNormalize! Normalize unfolded spectrum to 1; TH1D*fSVHist! Distribution of singular values; Bool_tfToyMode! Internal switch for covariance matrix propagation; TH1D*fToyhisto! Toy MC histogram; TH2D*fToymat! Toy MC detector response matrix; const TH1D*fXinitruth distribution (MC); TH2D*fXinv! Computed inverse of covariance matrix; TH2D*fXtau! Computed regularized covariance matrix. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSVDUnfold(const TH1D* bdat, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Alternative constructor; User provides data and MC test spectra, as well as detector response matrix, diagonal covariance matrix of measured spectrum built from the uncertainties on measured spectrum. TSVDUnfold(const TH1D* bdat, TH2D* Bcov, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Default constructor; Initialisation of TSVDUnfold; User provides data and MC test spectra, as well as detector response matrix and the covariance matrix of the measured distribution. TSVDUnfold(const TSVDUnfold& other); Copy constructor. ~TSVDUnfold(); Destructor. TH1D* Unfold(Int_t kreg); Perform the unfolding with regularisation parameter kreg. TH2D* GetUnfoldCovMatrix(const TH2D* cov, Int_t ntoys, Int_t seed = 1); Determine for given input error matrix covariance matrix of unfolded; spectrum from toy simulation given the passed covariance matrix on measured spectrum; ""cov"" - covariance matrix on the measured spectrum, to be propagated; ""ntoys"" - number of pseudo experiments used for the propagation; ""seed"" - seed for pseudo experiments;",MatchSource.WIKI,root/html534/TSVDUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSVDUnfold.html
https://root.cern/root/html534/TSVDUnfold.html:10564,Safety,detect,detector,10564,"tatistical uncertainties from response matrix; Int_tfNdim! Truth and reconstructed dimensions; Bool_tfNormalize! Normalize unfolded spectrum to 1; TH1D*fSVHist! Distribution of singular values; Bool_tfToyMode! Internal switch for covariance matrix propagation; TH1D*fToyhisto! Toy MC histogram; TH2D*fToymat! Toy MC detector response matrix; const TH1D*fXinitruth distribution (MC); TH2D*fXinv! Computed inverse of covariance matrix; TH2D*fXtau! Computed regularized covariance matrix. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSVDUnfold(const TH1D* bdat, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Alternative constructor; User provides data and MC test spectra, as well as detector response matrix, diagonal covariance matrix of measured spectrum built from the uncertainties on measured spectrum. TSVDUnfold(const TH1D* bdat, TH2D* Bcov, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Default constructor; Initialisation of TSVDUnfold; User provides data and MC test spectra, as well as detector response matrix and the covariance matrix of the measured distribution. TSVDUnfold(const TSVDUnfold& other); Copy constructor. ~TSVDUnfold(); Destructor. TH1D* Unfold(Int_t kreg); Perform the unfolding with regularisation parameter kreg. TH2D* GetUnfoldCovMatrix(const TH2D* cov, Int_t ntoys, Int_t seed = 1); Determine for given input error matrix covariance matrix of unfolded; spectrum from toy simulation given the passed covariance matrix on measured spectrum; ""cov"" - covariance matrix on the measured spectrum, to be propagated; ""ntoys"" - number of pseudo experiments used for the propagation; ""seed"" - seed for pseudo experiments; Note that this covariance matrix will contain effects of forced normalisation if spectrum is normalised to unit area. TH2D* GetAdetCovMatrix(Int_t ntoys, Int_t seed = 1); Determine covariance matrix of unfolded spectrum from finite statistics in; response matrix using pseudo experiments; ""nto",MatchSource.WIKI,root/html534/TSVDUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSVDUnfold.html
https://root.cern/root/html534/TSVDUnfold.html:10216,Testability,test,test,10216,"const TH1D*fBdatmeasured distribution (data); const TH1D*fBinireconstructed distribution (MC); TH1D*fDHist! Distribution of d (for checking regularization); Int_tfDdim! Derivative for curvature matrix; Int_tfKReg! Regularisation parameter; Bool_tfMatToyMode! Internal switch for evaluation of statistical uncertainties from response matrix; Int_tfNdim! Truth and reconstructed dimensions; Bool_tfNormalize! Normalize unfolded spectrum to 1; TH1D*fSVHist! Distribution of singular values; Bool_tfToyMode! Internal switch for covariance matrix propagation; TH1D*fToyhisto! Toy MC histogram; TH2D*fToymat! Toy MC detector response matrix; const TH1D*fXinitruth distribution (MC); TH2D*fXinv! Computed inverse of covariance matrix; TH2D*fXtau! Computed regularized covariance matrix. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSVDUnfold(const TH1D* bdat, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Alternative constructor; User provides data and MC test spectra, as well as detector response matrix, diagonal covariance matrix of measured spectrum built from the uncertainties on measured spectrum. TSVDUnfold(const TH1D* bdat, TH2D* Bcov, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Default constructor; Initialisation of TSVDUnfold; User provides data and MC test spectra, as well as detector response matrix and the covariance matrix of the measured distribution. TSVDUnfold(const TSVDUnfold& other); Copy constructor. ~TSVDUnfold(); Destructor. TH1D* Unfold(Int_t kreg); Perform the unfolding with regularisation parameter kreg. TH2D* GetUnfoldCovMatrix(const TH2D* cov, Int_t ntoys, Int_t seed = 1); Determine for given input error matrix covariance matrix of unfolded; spectrum from toy simulation given the passed covariance matrix on measured spectrum; ""cov"" - covariance matrix on the measured spectrum, to be propagated; ""ntoys"" - number of pseudo experiments used for the propagation; ""seed"" - seed for pseudo experiments;",MatchSource.WIKI,root/html534/TSVDUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSVDUnfold.html
https://root.cern/root/html534/TSVDUnfold.html:10539,Testability,test,test,10539,"tatistical uncertainties from response matrix; Int_tfNdim! Truth and reconstructed dimensions; Bool_tfNormalize! Normalize unfolded spectrum to 1; TH1D*fSVHist! Distribution of singular values; Bool_tfToyMode! Internal switch for covariance matrix propagation; TH1D*fToyhisto! Toy MC histogram; TH2D*fToymat! Toy MC detector response matrix; const TH1D*fXinitruth distribution (MC); TH2D*fXinv! Computed inverse of covariance matrix; TH2D*fXtau! Computed regularized covariance matrix. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSVDUnfold(const TH1D* bdat, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Alternative constructor; User provides data and MC test spectra, as well as detector response matrix, diagonal covariance matrix of measured spectrum built from the uncertainties on measured spectrum. TSVDUnfold(const TH1D* bdat, TH2D* Bcov, const TH1D* bini, const TH1D* xini, const TH2D* Adet); Default constructor; Initialisation of TSVDUnfold; User provides data and MC test spectra, as well as detector response matrix and the covariance matrix of the measured distribution. TSVDUnfold(const TSVDUnfold& other); Copy constructor. ~TSVDUnfold(); Destructor. TH1D* Unfold(Int_t kreg); Perform the unfolding with regularisation parameter kreg. TH2D* GetUnfoldCovMatrix(const TH2D* cov, Int_t ntoys, Int_t seed = 1); Determine for given input error matrix covariance matrix of unfolded; spectrum from toy simulation given the passed covariance matrix on measured spectrum; ""cov"" - covariance matrix on the measured spectrum, to be propagated; ""ntoys"" - number of pseudo experiments used for the propagation; ""seed"" - seed for pseudo experiments; Note that this covariance matrix will contain effects of forced normalisation if spectrum is normalised to unit area. TH2D* GetAdetCovMatrix(Int_t ntoys, Int_t seed = 1); Determine covariance matrix of unfolded spectrum from finite statistics in; response matrix using pseudo experiments; ""nto",MatchSource.WIKI,root/html534/TSVDUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSVDUnfold.html
https://root.cern/root/html534/TSVDUnfold.html:2084,Usability,guid,guidelines,2084,"ed explicitly, a diagonal covariance will be built given the errors of bdat). The corresponding spectrum in the Monte Carlo is given by bini, with the true underlying spectrum given by xini. The detector response is described by Adet, with Adet filled with events (not probabilities) with the true observable on the y-axis and the reconstructed observable on the x-axis.; ; The measured distribution can be unfolded for any combination of resolution, efficiency and acceptance effects, provided an appropriate definition of xini and Adet. The unfolding can be performed by; . TSVDUnfold *tsvdunf = new TSVDUnfold( bdat, Bcov, bini, xini, Adet );; TH1D* unfresult = tsvdunf->Unfold( kreg );; . where kreg determines the regularisation of the unfolding. In general, overregularisation (too small kreg) will bias the unfolded spectrum towards the Monte Carlo input, while underregularisation (too large kreg) will lead to large fluctuations in the unfolded spectrum. The optimal regularisation can be determined following guidelines in Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307] using the distribution of the |d_i|<\tt> that can be obtained by tsvdunf->GetD() and/or using pseudo-experiments.; ; Covariance matrices on the measured spectrum (for either the total uncertainties or individual sources of uncertainties) can be propagated to covariance matrices using the GetUnfoldCovMatrix method, which uses pseudo experiments for the propagation. In addition, GetAdetCovMatrix allows for the propagation of the statistical uncertainties on the response matrix using pseudo experiments. The covariance matrix corresponding to Bcov is also computed as described in Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307] and can be obtained from tsvdunf->GetXtau() and its (regularisation independent) inverse from tsvdunf->GetXinv(). The distribution of singular values can be retrieved using tsvdunf->GetSV().; ; See also the tutorial for a toy example.; ; . Function Members (Methods); public:",MatchSource.WIKI,root/html534/TSVDUnfold.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSVDUnfold.html
https://root.cern/root/html534/TSVG.html:3299,Availability,error,error,3299,"py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); voidDrawPolyLine(Int_t n, TPoints* xy); voidDrawPolyLineNDC(Int_t n, TPoints* uv); virtual voidDrawPolyMarker(Int_t n, Float_t* x, Float_t* y); virtual voidDrawPolyMarker(Int_t n, Double_t* x, Double_t* y); virtual voidDrawPS(Int_t n, Float_t* xw, Float_t* yw); virtual voidDrawPS(Int_t n, Double_t* xw, Double_t* yw); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObje",MatchSource.WIKI,root/html534/TSVG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSVG.html
https://root.cern/root/html534/TSVG.html:3383,Availability,error,error,3383,"istancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); voidDrawPolyLine(Int_t n, TPoints* xy); voidDrawPolyLineNDC(Int_t n, TPoints* uv); virtual voidDrawPolyMarker(Int_t n, Float_t* x, Float_t* y); virtual voidDrawPolyMarker(Int_t n, Double_t* x, Double_t* y); virtual voidDrawPS(Int_t n, Float_t* xw, Float_t* yw); virtual voidDrawPS(Int_t n, Double_t* xw, Double_t* yw); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Opt",MatchSource.WIKI,root/html534/TSVG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSVG.html
https://root.cern/root/html534/TSVG.html:15102,Energy Efficiency,power,power,15102,"y to point x,y.; If NN=0 the x,y are written in the SVG file; according to the current transformation.; If NN>0 the line is clipped as a line.; If NN<0 the line is clipped as a fill area. void DrawPolyMarker(Int_t n, Float_t* x, Float_t* y); Paint PolyMarker. void DrawPolyMarker(Int_t n, Double_t* x, Double_t* y); Paint PolyMarker. void DrawPS(Int_t n, Double_t* xw, Double_t* yw); This function defines a path with xw and yw and draw it according the; value of nn:. If nn>0 a line is drawn.; If nn<0 a closed polygon is drawn. void Initialize(); Initialize the SVG file. The main task of the function is to output the; SVG header file which consist in <title>, <desc> and <defs>. The; HeaderPS provided by the user program is written in the <defs> part. void MovePS(Double_t x, Double_t y); Move to a new position (ix, iy). The move is done in relative coordinates; which allows to have short numbers which decrease the size of the file.; This function use the full power of the SVG's paths by using the; horizontal and vertical move whenever it is possible. void NewPage(); Start the SVG page. This function initialize the pad conversion; coefficients and output the <svg> directive which is close later in the; the function Close. void Range(Float_t xrange, Float_t yrange); Set the range for the paper in centimetres. void SetFillColor(Color_t cindex = 1); Set color index for fill areas. void SetLineColor(Color_t cindex = 1); Set color index for lines. void SetLineStyle(Style_t linestyle = 1); Change the line style. linestyle = 2 dashed; = 3 dotted; = 4 dash-dotted; = else solid (1 in is used most of the time). void SetLineWidth(Width_t linewidth = 1); Set the lines width. void SetMarkerColor(Color_t cindex = 1); Set color index for markers. void SetColor(Int_t color = 1); Set color with its color index. void SetColor(Float_t r, Float_t g, Float_t b); Set color with its R G B components. r: % of red in [0,1]; g: % of green in [0,1]; b: % of blue in [0,1]. void SetTextColor(Color_t c",MatchSource.WIKI,root/html534/TSVG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSVG.html
https://root.cern/root/html534/TSVG.html:16068,Energy Efficiency,green,green,16068,"e.; This function use the full power of the SVG's paths by using the; horizontal and vertical move whenever it is possible. void NewPage(); Start the SVG page. This function initialize the pad conversion; coefficients and output the <svg> directive which is close later in the; the function Close. void Range(Float_t xrange, Float_t yrange); Set the range for the paper in centimetres. void SetFillColor(Color_t cindex = 1); Set color index for fill areas. void SetLineColor(Color_t cindex = 1); Set color index for lines. void SetLineStyle(Style_t linestyle = 1); Change the line style. linestyle = 2 dashed; = 3 dotted; = 4 dash-dotted; = else solid (1 in is used most of the time). void SetLineWidth(Width_t linewidth = 1); Set the lines width. void SetMarkerColor(Color_t cindex = 1); Set color index for markers. void SetColor(Int_t color = 1); Set color with its color index. void SetColor(Float_t r, Float_t g, Float_t b); Set color with its R G B components. r: % of red in [0,1]; g: % of green in [0,1]; b: % of blue in [0,1]. void SetTextColor(Color_t cindex = 1); Set color index for text. void Text(Double_t x, Double_t y, const char* string); Draw text. xx: x position of the text; yy: y position of the text; chars: text to be drawn. void TextNDC(Double_t u, Double_t v, const char* string); Write a string of characters in NDC. Double_t UtoSVG(Double_t u); Convert U from NDC coordinate to SVG. Double_t VtoSVG(Double_t v); Convert V from NDC coordinate to SVG. Double_t XtoSVG(Double_t x); Convert X from world coordinate to SVG. Double_t YtoSVG(Double_t y); Convert Y from world coordinate to SVG. void CellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); Begin the Cell Array painting. void CellArrayFill(Int_t r, Int_t g, Int_t b); Paint the Cell Array. void CellArrayEnd(); End the Cell Array painting. void DrawPS(Int_t n, Float_t* xw, Float_t* yw); Not needed in SVG case. Double_t CMtoSVG(Double_t u); {return 0.5 + 72*u/2.54;}. void SetLineScal",MatchSource.WIKI,root/html534/TSVG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSVG.html
https://root.cern/root/html534/TSVG.html:299,Integrability,interface,interface,299,". TSVG. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » POSTSCRIPT; » TSVG. class TSVG: public TVirtualPS. TSVG: Graphics interface to SVG; SVG; (Scalable Vector Graphics) is a language for describing two-dimensional; graphics in XML. SVG allows high quality vector graphics in; HTML pages. To print a ROOT canvas ""c1"" into an SVG file simply do:. c1->Print(""c1.svg"");. The result is the ASCII file c1.svg. It can be open direclty using a web browser or included in a html document; the following way:. <embed width=""95%"" height=""500"" src=""c1.svg"" />>. It is best viewed with Internet Explorer and you need the; Adobe SVG; Viewer. To zoom using the Adobe SVG Viewer, position the mouse over; the area you want to zoom and click the right button. To define the zoom area,; use Control+drag to mark the boundaries of the zoom area. To pan, use Alt+drag.; By clicking with the right mouse button on the SVG graphics you will get; a pop-up menu giving other ways to interact with the image. SVG files can be used directly in compressed mode to minimize the time; transfer over the network. Compressed SVG files should be created using; gzip on a normal ASCII SVG file and should then be renamed; using the file extension .svgz.; . Function Members (Methods); public:. TSVG(); TSVG(const char* filename, Int_t type = -113); virtual~TSVG(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const c",MatchSource.WIKI,root/html534/TSVG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSVG.html
https://root.cern/root/html534/TSVG.html:12670,Integrability,interface,interface,12670,"er::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTVirtualPS::fNByteNumber of bytes written in the file (PDF); TStringTNamed::fNameobject identifier; Bool_tTVirtualPS::fPrintedTrue when a page must be printed; Bool_tfRangeTrue when a range has been defined; Int_tTVirtualPS::fSizBufferBuffer size; ofstream*TVirtualPS::fStreamFile stream identifier; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title; Int_tfTypeWorkstation type used to know if the SVG is open; Float_tfXsizePage size along X; Float_tfYsizePage size along Y; Double_tfYsizeSVGPage's Y size in SVG units. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSVG(); Default SVG constructor. TSVG(const char* filename, Int_t type = -113); Initialize the SVG interface. fname : SVG file name; wtype : SVG workstation type. Not used in the SVG driver. But as TSVG; inherits from TVirtualPS it should be kept. Anyway it is not; necessary to specify this parameter at creation time because it; has a default value (which is ignore in the SVG case). void Open(const char* filename, Int_t type = -111); Open a SVG file. ~TSVG(); Default SVG destructor. void Close(Option_t* opt = """"); Close a SVG file. void On(); Activate an already open SVG file. void Off(); Deactivate an already open SVG file. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw a Box. void DrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); Draw a Frame around a box. mode = -1 the box looks as it is behind the screen; mode = 1 the box looks as it is in front of the screen; border is the border size in already pre-computed SVG units dark is the; color for the dark part of the fr",MatchSource.WIKI,root/html534/TSVG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSVG.html
https://root.cern/root/html534/TSVG.html:12775,Modifiability,inherit,inherits,12775,"mber of bytes written in the file (PDF); TStringTNamed::fNameobject identifier; Bool_tTVirtualPS::fPrintedTrue when a page must be printed; Bool_tfRangeTrue when a range has been defined; Int_tTVirtualPS::fSizBufferBuffer size; ofstream*TVirtualPS::fStreamFile stream identifier; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title; Int_tfTypeWorkstation type used to know if the SVG is open; Float_tfXsizePage size along X; Float_tfYsizePage size along Y; Double_tfYsizeSVGPage's Y size in SVG units. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSVG(); Default SVG constructor. TSVG(const char* filename, Int_t type = -113); Initialize the SVG interface. fname : SVG file name; wtype : SVG workstation type. Not used in the SVG driver. But as TSVG; inherits from TVirtualPS it should be kept. Anyway it is not; necessary to specify this parameter at creation time because it; has a default value (which is ignore in the SVG case). void Open(const char* filename, Int_t type = -111); Open a SVG file. ~TSVG(); Default SVG destructor. void Close(Option_t* opt = """"); Close a SVG file. void On(); Activate an already open SVG file. void Off(); Deactivate an already open SVG file. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw a Box. void DrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); Draw a Frame around a box. mode = -1 the box looks as it is behind the screen; mode = 1 the box looks as it is in front of the screen; border is the border size in already pre-computed SVG units dark is the; color for the dark part of the frame light is the color for the light; part of the frame. void DrawPolyLine(Int_t n, TPoints* xy); Draw a PolyLine. Draw a polyline through the point",MatchSource.WIKI,root/html534/TSVG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSVG.html
https://root.cern/root/html534/TSVG.html:513,Usability,simpl,simply,513,". TSVG. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » POSTSCRIPT; » TSVG. class TSVG: public TVirtualPS. TSVG: Graphics interface to SVG; SVG; (Scalable Vector Graphics) is a language for describing two-dimensional; graphics in XML. SVG allows high quality vector graphics in; HTML pages. To print a ROOT canvas ""c1"" into an SVG file simply do:. c1->Print(""c1.svg"");. The result is the ASCII file c1.svg. It can be open direclty using a web browser or included in a html document; the following way:. <embed width=""95%"" height=""500"" src=""c1.svg"" />>. It is best viewed with Internet Explorer and you need the; Adobe SVG; Viewer. To zoom using the Adobe SVG Viewer, position the mouse over; the area you want to zoom and click the right button. To define the zoom area,; use Control+drag to mark the boundaries of the zoom area. To pan, use Alt+drag.; By clicking with the right mouse button on the SVG graphics you will get; a pop-up menu giving other ways to interact with the image. SVG files can be used directly in compressed mode to minimize the time; transfer over the network. Compressed SVG files should be created using; gzip on a normal ASCII SVG file and should then be renamed; using the file extension .svgz.; . Function Members (Methods); public:. TSVG(); TSVG(const char* filename, Int_t type = -113); virtual~TSVG(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const c",MatchSource.WIKI,root/html534/TSVG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSVG.html
https://root.cern/root/html534/TSynapse.html:1539,Availability,error,error,1539,"(const TSynapse&); TSynapse(TNeuron*, TNeuron*, Double_t w = 1); virtual~TSynapse(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetDeDw() const; Double_tGetDEDw() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TNeuron*GetPost() const; TNeuron*GetPre() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetValue() const; Double_tGetWeight() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObjec",MatchSource.WIKI,root/html534/TSynapse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSynapse.html
https://root.cern/root/html534/TSynapse.html:1623,Availability,error,error,1623," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetDeDw() const; Double_tGetDEDw() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TNeuron*GetPost() const; TNeuron*GetPre() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetValue() const; Double_tGetWeight() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) c",MatchSource.WIKI,root/html534/TSynapse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSynapse.html
https://root.cern/root/html534/TSynapse.html:5612,Availability,error,error,5612,"f_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfDEDw! the derivative of the total error wrt the synapse weight; TNeuron*fpostthe neuron after the synapse; TNeuron*fprethe neuron before the synapse; Double_tfweightthe weight of the synapse. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSynapse(); Default constructor. TSynapse(TNeuron* , TNeuron* , Double_t w = 1); Constructor that connects two neurons. void SetPre(TNeuron* pre); Sets the pre-neuron. void SetPost(TNeuron* post); Sets the post-neuron. Double_t GetValue() const; Returns the value: weithted input. Double_t GetDeDw() const; Computes the derivative of the error wrt the synapse weight. void SetWeight(Double_t w); Sets the weight of the synapse.; This weight is the multiplying factor applied on the; output of a neuron in the linear combination given as input; of another neuron. void SetDEDw(Double_t in); Sets the derivative of the total error wrt the synapse weight. TSynapse(). virtual ~TSynapse(); {}. TNeuron* GetPre() const; { return fpre; }. TNeuron* GetPost() const; { return fpost; }. Double_t GetWeight() const; { ",MatchSource.WIKI,root/html534/TSynapse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSynapse.html
https://root.cern/root/html534/TSynapse.html:6199,Availability,error,error,6199,"_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfDEDw! the derivative of the total error wrt the synapse weight; TNeuron*fpostthe neuron after the synapse; TNeuron*fprethe neuron before the synapse; Double_tfweightthe weight of the synapse. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSynapse(); Default constructor. TSynapse(TNeuron* , TNeuron* , Double_t w = 1); Constructor that connects two neurons. void SetPre(TNeuron* pre); Sets the pre-neuron. void SetPost(TNeuron* post); Sets the post-neuron. Double_t GetValue() const; Returns the value: weithted input. Double_t GetDeDw() const; Computes the derivative of the error wrt the synapse weight. void SetWeight(Double_t w); Sets the weight of the synapse.; This weight is the multiplying factor applied on the; output of a neuron in the linear combination given as input; of another neuron. void SetDEDw(Double_t in); Sets the derivative of the total error wrt the synapse weight. TSynapse(). virtual ~TSynapse(); {}. TNeuron* GetPre() const; { return fpre; }. TNeuron* GetPost() const; { return fpost; }. Double_t GetWeight() const; { return fweight; }. Double_t GetDEDw() const; { return fDEDw; }. » Author: Christophe.Delaere@cern.ch 20/07/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/mlp:$Id$ » Last generated: 2015-03-14 16:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TSynapse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSynapse.html
https://root.cern/root/html534/TSynapse.html:6484,Availability,error,error,6484,"_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfDEDw! the derivative of the total error wrt the synapse weight; TNeuron*fpostthe neuron after the synapse; TNeuron*fprethe neuron before the synapse; Double_tfweightthe weight of the synapse. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSynapse(); Default constructor. TSynapse(TNeuron* , TNeuron* , Double_t w = 1); Constructor that connects two neurons. void SetPre(TNeuron* pre); Sets the pre-neuron. void SetPost(TNeuron* post); Sets the post-neuron. Double_t GetValue() const; Returns the value: weithted input. Double_t GetDeDw() const; Computes the derivative of the error wrt the synapse weight. void SetWeight(Double_t w); Sets the weight of the synapse.; This weight is the multiplying factor applied on the; output of a neuron in the linear combination given as input; of another neuron. void SetDEDw(Double_t in); Sets the derivative of the total error wrt the synapse weight. TSynapse(). virtual ~TSynapse(); {}. TNeuron* GetPre() const; { return fpre; }. TNeuron* GetPost() const; { return fpost; }. Double_t GetWeight() const; { return fweight; }. Double_t GetDEDw() const; { return fDEDw; }. » Author: Christophe.Delaere@cern.ch 20/07/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/mlp:$Id$ » Last generated: 2015-03-14 16:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TSynapse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSynapse.html
https://root.cern/root/html534/TSynapse.html:304,Usability,simpl,simple,304,". TSynapse. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MLP; » TSynapse. class TSynapse: public TObject. TSynapse. This is a simple weighted bidirectionnal connection between; two neurons.; A network is built connecting two neurons by a synapse.; In addition to the value, the synapse can return the DeDw. Function Members (Methods); public:. TSynapse(); TSynapse(const TSynapse&); TSynapse(TNeuron*, TNeuron*, Double_t w = 1); virtual~TSynapse(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetDeDw() const; Double_tGetDEDw() const; virtual Option_t*TObject::GetDrawOption() const; s",MatchSource.WIKI,root/html534/TSynapse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSynapse.html
https://root.cern/root/html534/TSysEvtHandler.html:518,Availability,avail,available,518,". TSysEvtHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TSysEvtHandler. class TSysEvtHandler: public TObject, public TQObject. TSysEvtHandler. Abstract base class for handling system events. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSysEvtHandler(); voidTObject::AbstractMethod(const char* method) const; voidActivate(); virtual voidActivated()SIGNAL ; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTObject::Copy(TObject& object) const; voidDeActivate(); virtual voidDeActivated()SIGNAL ; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTQObject::Destroyed()SIGNAL ; Bool_tTQOb",MatchSource.WIKI,root/html534/TSysEvtHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSysEvtHandler.html
https://root.cern/root/html534/TSysEvtHandler.html:3786,Availability,error,error,3786,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(",MatchSource.WIKI,root/html534/TSysEvtHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSysEvtHandler.html
https://root.cern/root/html534/TSysEvtHandler.html:3870,Availability,error,error,3870,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTObject::Hash() const; virtual voidTQ",MatchSource.WIKI,root/html534/TSysEvtHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSysEvtHandler.html
https://root.cern/root/html534/TSysEvtHandler.html:9470,Safety,avoid,avoid,9470,"). private:. virtual void*GetSender(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. Bool_tfIsActivekTRUE if handler is active, kFALSE if not active. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Activate(); Activate a system event handler. All handlers are by default; activated. Use this method to activate a de-activated handler. void DeActivate(); De-activate a system event handler. Use this method to temporarily; disable an event handler to avoid it from being recursively called.; Use DeActivate() / Activate() instead of Remove() / Add() for this; purpose, since the Add() will add the handler back to the end of; the list of handlers and cause it to be called again for the same,; already handled, event. void * GetSender(); { return this; }. virtual ~TSysEvtHandler(); { }. Bool_t IsActive() const; { return fIsActive; }. void Add(). void Remove(). Bool_t Notify(). void Activated(); { Emit(""Activated()""); }. void DeActivated(); { Emit(""DeActivated()""); }. void Notified(); { Emit(""Notified()""); }. void Added(); { Emit(""Added()""); }. void Removed(); { Emit(""Removed()""); }. » Author: Fons Rademakers 16/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TSysEvtHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSysEvtHandler.html
https://root.cern/root/html534/TSystem.html:3487,Availability,error,error,3487,"r* build_dir = """", UInt_t dirmode = 0); virtual char*ConcatFileName(const char* dir, const char* name); virtual voidTNamed::Copy(TObject& named) const; virtual intCopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual const char*DirName(const char* pathname); virtual voidDispatchOneEvent(Bool_t pendingOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual char*DynamicPathName(const char* lib, Bool_t quiet = kFALSE); virtual Func_tDynFindSymbol(const char* module, const char* entry); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tExec(const char* shellcmd); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExit(int code, Bool_t mode = kTRUE); virtual voidExitLoop(); virtual Bool_tExpandPathName(TString& path); virtual char*ExpandPathName(const char* path); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual const char*FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFreeDirectory(void* dirp); virtual TSystem::EAclicModeGetAclicMode() const; virtual Int_tGetAclicProperties() const; voidGetBeepDefaults(Int_t& freq, Int_t& duration) const; virtual const char*GetBuildArch() const; virtual const char*GetBuildCompiler() const; virtual const char*GetBuildCompilerVersion() const; virtual c",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:3571,Availability,error,error,3571," const char* name); virtual voidTNamed::Copy(TObject& named) const; virtual intCopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual const char*DirName(const char* pathname); virtual voidDispatchOneEvent(Bool_t pendingOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual char*DynamicPathName(const char* lib, Bool_t quiet = kFALSE); virtual Func_tDynFindSymbol(const char* module, const char* entry); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tExec(const char* shellcmd); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExit(int code, Bool_t mode = kTRUE); virtual voidExitLoop(); virtual Bool_tExpandPathName(TString& path); virtual char*ExpandPathName(const char* path); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual const char*FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFreeDirectory(void* dirp); virtual TSystem::EAclicModeGetAclicMode() const; virtual Int_tGetAclicProperties() const; voidGetBeepDefaults(Int_t& freq, Int_t& duration) const; virtual const char*GetBuildArch() const; virtual const char*GetBuildCompiler() const; virtual const char*GetBuildCompilerVersion() const; virtual const char*GetBuildDir() const; virtual const char*GetBuildNode() const; virtual intG",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:11765,Availability,mask,mask,11765,"oidRun(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tSelect(TList* active, Long_t timeout); virtual Int_tSelect(TFileHandler* fh, Long_t timeout); virtual intSendBuf(int sock, const void* buffer, int length); virtual intSendRaw(int sock, const void* buffer, int length, int flag); virtual voidSetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidSetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDynamicPath(const char* pathname); virtual voidSetenv(const char* name, const char* value); voidSetErrorStr(const char* errstr); virtual voidSetFlagsDebug(const char*); virtual voidSetFlagsOpt(const char*); virtual Int_tSetFPEMask(Int_t mask = kDefaultMask); virtual voidSetIncludePath(const char* includePath); virtual voidSetLinkdefSuffix(const char* suffix); virtual voidSetLinkedLibs(const char* linkedLibs); virtual voidSetMakeExe(const char* directives); virtual voidSetMakeSharedLib(const char* directives); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetObjExt(const char* objExt); virtual voidSetProgname(const char* name); virtual intSetSockOpt(int sock, int kind, int val); virtual voidSetSoExt(const char* soExt); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidShowOutput(RedirectHandle_t* h); virtual Int_tTNamed::Sizeof() const; virtual voidSleep(UInt_t milliSec); virtual TStringSplitAclicMode(const char* filename, TString& mode, TString& args, TString& io) const; virtua",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:13274,Availability,mask,mask,13274,"voidSetMakeExe(const char* directives); virtual voidSetMakeSharedLib(const char* directives); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetObjExt(const char* objExt); virtual voidSetProgname(const char* name); virtual intSetSockOpt(int sock, int kind, int val); virtual voidSetSoExt(const char* soExt); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidShowOutput(RedirectHandle_t* h); virtual Int_tTNamed::Sizeof() const; virtual voidSleep(UInt_t milliSec); virtual TStringSplitAclicMode(const char* filename, TString& mode, TString& args, TString& io) const; virtual voidStackTrace(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual intSymlink(const char* from, const char* to); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidSyslog(ELogLevel level, const char* mess); virtual const char*TempDirectory() const; virtual FILE*TempFileName(TString& base, const char* dir = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual intUmask(Int_t mask); virtual const char*UnixPathName(const char* unixpathname); virtual intUnlink(const char* name); virtual voidUnload(const char* module); virtual voidUnsetenv(const char* name); virtual voidTObject::UseCurrentStyle(); virtual intUtime(const char* file, Long_t modtime, Long_t actime); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual char*Which(const char* search, const char* file, EAccessMode mode = kFileExists); virtual const char*WorkingDirectory(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:16704,Availability,mask,mask,16704,"Collection*fFileHandlerList of file handlers; TStringfFlagsDebugFlags for debug compilation; TStringfFlagsOptFlags for optimized compilation; TSeqCollection*fHelpersList of helper classes for alternative file/directory access; TStringfHostnameHostname; Bool_tfInControlTrue if in eventloop; TStringfIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tfInsideNotifyUsed by DispatchTimers(); Int_tfLevelLevel of nested eventloops; TStringfLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringfLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringfListLibsList shared libraries, cache used by GetLibraries; TStringfListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringfMakeExeDirective used to build an executable; TStringfMakeSharedLibDirective used to build a shared library; Int_tfMaxrfdLargest fd in read mask; Int_tfMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tfNfdNumber of fd's in masks; TStringfObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*fOnExitListList of items to be cleaned-up on exit; TFdSet*fReadmask!Files that should be checked for read events; TFdSet*fReadready!Files with reads waiting; Int_tfSigcntNumber of pending signals; TSeqCollection*fSignalHandlerList of signal handlers; TFdSet*fSignals!Signals that were trapped; TStringfSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*fStdExceptionHandlerList of std::exception handlers; TSeqCollection*fTimersList of timers; TStringTNamed::fTitleobject title; TStringfWdpathWorking directory; TFdSet*fWritemask!Files that should be checked for write events; TFdSet*fWriteready!Files with writes waiting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSystem(const char* name = ""Generic"", const char* title = ""Ge",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:16742,Availability,mask,mask,16742,"Collection*fFileHandlerList of file handlers; TStringfFlagsDebugFlags for debug compilation; TStringfFlagsOptFlags for optimized compilation; TSeqCollection*fHelpersList of helper classes for alternative file/directory access; TStringfHostnameHostname; Bool_tfInControlTrue if in eventloop; TStringfIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tfInsideNotifyUsed by DispatchTimers(); Int_tfLevelLevel of nested eventloops; TStringfLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringfLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringfListLibsList shared libraries, cache used by GetLibraries; TStringfListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringfMakeExeDirective used to build an executable; TStringfMakeSharedLibDirective used to build a shared library; Int_tfMaxrfdLargest fd in read mask; Int_tfMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tfNfdNumber of fd's in masks; TStringfObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*fOnExitListList of items to be cleaned-up on exit; TFdSet*fReadmask!Files that should be checked for read events; TFdSet*fReadready!Files with reads waiting; Int_tfSigcntNumber of pending signals; TSeqCollection*fSignalHandlerList of signal handlers; TFdSet*fSignals!Signals that were trapped; TStringfSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*fStdExceptionHandlerList of std::exception handlers; TSeqCollection*fTimersList of timers; TStringTNamed::fTitleobject title; TStringfWdpathWorking directory; TFdSet*fWritemask!Files that should be checked for write events; TFdSet*fWriteready!Files with writes waiting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSystem(const char* name = ""Generic"", const char* title = ""Ge",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:16814,Availability,mask,masks,16814,"Collection*fFileHandlerList of file handlers; TStringfFlagsDebugFlags for debug compilation; TStringfFlagsOptFlags for optimized compilation; TSeqCollection*fHelpersList of helper classes for alternative file/directory access; TStringfHostnameHostname; Bool_tfInControlTrue if in eventloop; TStringfIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tfInsideNotifyUsed by DispatchTimers(); Int_tfLevelLevel of nested eventloops; TStringfLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringfLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringfListLibsList shared libraries, cache used by GetLibraries; TStringfListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringfMakeExeDirective used to build an executable; TStringfMakeSharedLibDirective used to build a shared library; Int_tfMaxrfdLargest fd in read mask; Int_tfMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tfNfdNumber of fd's in masks; TStringfObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*fOnExitListList of items to be cleaned-up on exit; TFdSet*fReadmask!Files that should be checked for read events; TFdSet*fReadready!Files with reads waiting; Int_tfSigcntNumber of pending signals; TSeqCollection*fSignalHandlerList of signal handlers; TFdSet*fSignals!Signals that were trapped; TStringfSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*fStdExceptionHandlerList of std::exception handlers; TSeqCollection*fTimersList of timers; TStringTNamed::fTitleobject title; TStringfWdpathWorking directory; TFdSet*fWritemask!Files that should be checked for write events; TFdSet*fWriteready!Files with writes waiting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSystem(const char* name = ""Generic"", const char* title = ""Ge",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:18076,Availability,error,error,18076,"_tfSigcntNumber of pending signals; TSeqCollection*fSignalHandlerList of signal handlers; TFdSet*fSignals!Signals that were trapped; TStringfSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*fStdExceptionHandlerList of std::exception handlers; TSeqCollection*fTimersList of timers; TStringTNamed::fTitleobject title; TStringfWdpathWorking directory; TFdSet*fWritemask!Files that should be checked for write events; TFdSet*fWriteready!Files with writes waiting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSystem(const char* name = ""Generic"", const char* title = ""Generic System""); Create a new OS interface. ~TSystem(); Delete the OS interface. Bool_t Init(); Initialize the OS interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. void SetErrorStr(const char* errstr); Set the system error string. This string will be used by GetError().; To be used in case one does not want or can use the system error; string (e.g. because error is generated by a third party POSIX like; library that does not use standard errno). const char * GetError(); Return system error string. Int_t GetErrno(); Static function returning system error number. void ResetErrno(); Static function resetting system error number. void RemoveOnExit(TObject* obj); Objects that should be deleted on exit of the OS interface. const char * HostName(); Return the system's host name. void NotifyApplicationCreated(); Hook to tell TSystem that the TApplication object has been created. void Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); Beep for duration milliseconds with a tone of freqency freq.; Defaults to printing the '\a' character to stdout.; If freq or duration is <0 respectively, use default value.; If setDefault is set, only set the frequency and duration as; ",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:18190,Availability,error,error,18190," that were trapped; TStringfSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*fStdExceptionHandlerList of std::exception handlers; TSeqCollection*fTimersList of timers; TStringTNamed::fTitleobject title; TStringfWdpathWorking directory; TFdSet*fWritemask!Files that should be checked for write events; TFdSet*fWriteready!Files with writes waiting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSystem(const char* name = ""Generic"", const char* title = ""Generic System""); Create a new OS interface. ~TSystem(); Delete the OS interface. Bool_t Init(); Initialize the OS interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. void SetErrorStr(const char* errstr); Set the system error string. This string will be used by GetError().; To be used in case one does not want or can use the system error; string (e.g. because error is generated by a third party POSIX like; library that does not use standard errno). const char * GetError(); Return system error string. Int_t GetErrno(); Static function returning system error number. void ResetErrno(); Static function resetting system error number. void RemoveOnExit(TObject* obj); Objects that should be deleted on exit of the OS interface. const char * HostName(); Return the system's host name. void NotifyApplicationCreated(); Hook to tell TSystem that the TApplication object has been created. void Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); Beep for duration milliseconds with a tone of freqency freq.; Defaults to printing the '\a' character to stdout.; If freq or duration is <0 respectively, use default value.; If setDefault is set, only set the frequency and duration as; new defaults, but don't beep.; If default freq or duration is <0, never beep (silence). void Run(); System event",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:18218,Availability,error,error,18218,"SeqCollection*fStdExceptionHandlerList of std::exception handlers; TSeqCollection*fTimersList of timers; TStringTNamed::fTitleobject title; TStringfWdpathWorking directory; TFdSet*fWritemask!Files that should be checked for write events; TFdSet*fWriteready!Files with writes waiting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSystem(const char* name = ""Generic"", const char* title = ""Generic System""); Create a new OS interface. ~TSystem(); Delete the OS interface. Bool_t Init(); Initialize the OS interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. void SetErrorStr(const char* errstr); Set the system error string. This string will be used by GetError().; To be used in case one does not want or can use the system error; string (e.g. because error is generated by a third party POSIX like; library that does not use standard errno). const char * GetError(); Return system error string. Int_t GetErrno(); Static function returning system error number. void ResetErrno(); Static function resetting system error number. void RemoveOnExit(TObject* obj); Objects that should be deleted on exit of the OS interface. const char * HostName(); Return the system's host name. void NotifyApplicationCreated(); Hook to tell TSystem that the TApplication object has been created. void Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); Beep for duration milliseconds with a tone of freqency freq.; Defaults to printing the '\a' character to stdout.; If freq or duration is <0 respectively, use default value.; If setDefault is set, only set the frequency and duration as; new defaults, but don't beep.; If default freq or duration is <0, never beep (silence). void Run(); System event loop. void ExitLoop(); Exit from event loop. void InnerLoop(); Inner event loop. Bool_t Pr",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:18348,Availability,error,error,18348,"ction*fTimersList of timers; TStringTNamed::fTitleobject title; TStringfWdpathWorking directory; TFdSet*fWritemask!Files that should be checked for write events; TFdSet*fWriteready!Files with writes waiting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSystem(const char* name = ""Generic"", const char* title = ""Generic System""); Create a new OS interface. ~TSystem(); Delete the OS interface. Bool_t Init(); Initialize the OS interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. void SetErrorStr(const char* errstr); Set the system error string. This string will be used by GetError().; To be used in case one does not want or can use the system error; string (e.g. because error is generated by a third party POSIX like; library that does not use standard errno). const char * GetError(); Return system error string. Int_t GetErrno(); Static function returning system error number. void ResetErrno(); Static function resetting system error number. void RemoveOnExit(TObject* obj); Objects that should be deleted on exit of the OS interface. const char * HostName(); Return the system's host name. void NotifyApplicationCreated(); Hook to tell TSystem that the TApplication object has been created. void Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); Beep for duration milliseconds with a tone of freqency freq.; Defaults to printing the '\a' character to stdout.; If freq or duration is <0 respectively, use default value.; If setDefault is set, only set the frequency and duration as; new defaults, but don't beep.; If default freq or duration is <0, never beep (silence). void Run(); System event loop. void ExitLoop(); Exit from event loop. void InnerLoop(); Inner event loop. Bool_t ProcessEvents(); Process pending events (GUI, timers, sockets). Returns the re",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:18413,Availability,error,error,18413,"tle; TStringfWdpathWorking directory; TFdSet*fWritemask!Files that should be checked for write events; TFdSet*fWriteready!Files with writes waiting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSystem(const char* name = ""Generic"", const char* title = ""Generic System""); Create a new OS interface. ~TSystem(); Delete the OS interface. Bool_t Init(); Initialize the OS interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. void SetErrorStr(const char* errstr); Set the system error string. This string will be used by GetError().; To be used in case one does not want or can use the system error; string (e.g. because error is generated by a third party POSIX like; library that does not use standard errno). const char * GetError(); Return system error string. Int_t GetErrno(); Static function returning system error number. void ResetErrno(); Static function resetting system error number. void RemoveOnExit(TObject* obj); Objects that should be deleted on exit of the OS interface. const char * HostName(); Return the system's host name. void NotifyApplicationCreated(); Hook to tell TSystem that the TApplication object has been created. void Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); Beep for duration milliseconds with a tone of freqency freq.; Defaults to printing the '\a' character to stdout.; If freq or duration is <0 respectively, use default value.; If setDefault is set, only set the frequency and duration as; new defaults, but don't beep.; If default freq or duration is <0, never beep (silence). void Run(); System event loop. void ExitLoop(); Exit from event loop. void InnerLoop(); Inner event loop. Bool_t ProcessEvents(); Process pending events (GUI, timers, sockets). Returns the result of; TROOT::IsInterrupted(). The interrupt flag (TROOT:",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:18479,Availability,error,error,18479," should be checked for write events; TFdSet*fWriteready!Files with writes waiting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSystem(const char* name = ""Generic"", const char* title = ""Generic System""); Create a new OS interface. ~TSystem(); Delete the OS interface. Bool_t Init(); Initialize the OS interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. void SetErrorStr(const char* errstr); Set the system error string. This string will be used by GetError().; To be used in case one does not want or can use the system error; string (e.g. because error is generated by a third party POSIX like; library that does not use standard errno). const char * GetError(); Return system error string. Int_t GetErrno(); Static function returning system error number. void ResetErrno(); Static function resetting system error number. void RemoveOnExit(TObject* obj); Objects that should be deleted on exit of the OS interface. const char * HostName(); Return the system's host name. void NotifyApplicationCreated(); Hook to tell TSystem that the TApplication object has been created. void Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); Beep for duration milliseconds with a tone of freqency freq.; Defaults to printing the '\a' character to stdout.; If freq or duration is <0 respectively, use default value.; If setDefault is set, only set the frequency and duration as; new defaults, but don't beep.; If default freq or duration is <0, never beep (silence). void Run(); System event loop. void ExitLoop(); Exit from event loop. void InnerLoop(); Inner event loop. Bool_t ProcessEvents(); Process pending events (GUI, timers, sockets). Returns the result of; TROOT::IsInterrupted(). The interrupt flag (TROOT::SetInterrupt()); can be set during the handling of the events. T",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:22239,Availability,mask,mask,22239," the default handler, else restore previous behaviour. void ResetSignals(); Reset signals handlers to previous behaviour. void IgnoreSignal(ESignals sig, Bool_t ignore = kTRUE); If ignore is true ignore the specified signal, else restore previous; behaviour. void IgnoreInterrupt(Bool_t ignore = kTRUE); If ignr is true ignore the interrupt signal, else restore previous; behaviour. Typically call ignore interrupt before writing to disk. void AddStdExceptionHandler(TStdExceptionHandler* eh); Add an exception handler to list of system exception handlers. Only adds; the handler if it is not already in the list of exception handlers. TStdExceptionHandler * RemoveStdExceptionHandler(TStdExceptionHandler* eh); Remove an exception handler from list of exception handlers. Returns; the handler or 0 if the handler was not in the list of exception handlers. Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* command, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. TString GetFromPipe(const char* command); Execute command and return output in TString. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. TSystem * FindHelper(const char* path, void* dirptr = 0); Create helper TSystem to handle file and directory operations that; might be special for remote file access, like via rfiod or rootd. Bool_t ConsistentWith(const char* path, void* dirptr = 0); Check consistency of this helper with the one required; by 'path' or 'dirptr'. int MakeDirectory(const char* name); Make a directory. Returns 0 in case of success and; -1 if the directory could not be created (either alread",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:25585,Availability,error,error,25585,"st be deleted by the caller. const char * DirName(const char* pathname); Return the directory name in pathname. DirName of /user/root is /user.; In case no dirname is specified ""."" is returned. const char * UnixPathName(const char* unixpathname); Convert from a Unix pathname to a local pathname. E.g. from /user/root to \user\root. char * ConcatFileName(const char* dir, const char* name); Concatenate a directory and a file name. User must delete returned string. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. const char * ExpandFileName(const char* fname); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. This is a protected function called; from the OS specific system classes, like TUnixSystem and TWinNTSystem.; Returns the expanded filename or 0 in case of error. Bool_t ExpandPathName(TString& path); Expand a pathname getting rid of special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. char * ExpandPathName(const char* path); Expand a pathname getting rid of special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. The user must delete returned string. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; The file name must not contain any special shell characters line ~ or $,; in those cases first call ExpandPathName().; Attention, bizarre convention of return value!!. Bool_t IsPathLocal(const char* path); Retur",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:26914,Availability,failure,failure,26914,"tting rid of special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. The user must delete returned string. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; The file name must not contain any special shell characters line ~ or $,; in those cases first call ExpandPathName().; Attention, bizarre convention of return value!!. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. int Link(const char* from, const char* to); Create a link from file1 to file2. int Symlink(const char* from, const char* to); Create a symbolic link from file1 to file2. int Unlink(const char* name); Unlink, i.e. remove, a file. int GetPathInfo(const char* path, Long_t* id, Long_t* size, Long_t* flags, Long_t* modtime); Get info about a file: id, size, flags, modification time.; Id is (statbuf.st_dev << 24) + statbuf.st_ino; Size is the file size; Flags is file type: 0 is regular file, bit 0 set executable,; bit 1 set directory, bit 2 set special file; (socket, fifo, pipe, etc.); Modtime is modification time.; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetPathInfo(const char* path, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Get info about a file: id, size, flags, modification time.; Id ",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:27001,Availability,error,error,27001,"tting rid of special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. The user must delete returned string. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; The file name must not contain any special shell characters line ~ or $,; in those cases first call ExpandPathName().; Attention, bizarre convention of return value!!. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. int Link(const char* from, const char* to); Create a link from file1 to file2. int Symlink(const char* from, const char* to); Create a symbolic link from file1 to file2. int Unlink(const char* name); Unlink, i.e. remove, a file. int GetPathInfo(const char* path, Long_t* id, Long_t* size, Long_t* flags, Long_t* modtime); Get info about a file: id, size, flags, modification time.; Id is (statbuf.st_dev << 24) + statbuf.st_ino; Size is the file size; Flags is file type: 0 is regular file, bit 0 set executable,; bit 1 set directory, bit 2 set special file; (socket, fifo, pipe, etc.); Modtime is modification time.; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetPathInfo(const char* path, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Get info about a file: id, size, flags, modification time.; Id ",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:29185,Availability,error,error,29185," function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: fs type, block size, number of blocks,; number of free blocks. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set the a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file in a search path. Return value points to TString for; compatibility with Which(const char *, const char *, EAccessMode).; Returns 0 in case file is not found. char * Which(const char* search, const char* file, EAccessMode mode = kFileExists); Find location of file in a search path. User must delete returned string.; Returns 0 in case file is not found. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effec",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:29286,Availability,error,error,29286,"path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: fs type, block size, number of blocks,; number of free blocks. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set the a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file in a search path. Return value points to TString for; compatibility with Which(const char *, const char *, EAccessMode).; Returns 0 in case file is not found. char * Which(const char* search, const char* file, EAccessMode mode = kFileExists); Find location of file in a search path. User must delete returned string.; Returns 0 in case file is not found. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(cons",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:29322,Availability,mask,mask,29322,"s returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: fs type, block size, number of blocks,; number of free blocks. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set the a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file in a search path. Return value points to TString for; compatibility with Which(const char *, const char *, EAccessMode).; Returns 0 in case file is not found. char * Which(const char* search, const char* file, EAccessMode mode = kFileExists); Find location of file in a search path. User must delete returned string.; Returns 0 in case file is not found. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group ",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:29364,Availability,mask,mask,29364,"s returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: fs type, block size, number of blocks,; number of free blocks. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set the a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file in a search path. Return value points to TString for; compatibility with Which(const char *, const char *, EAccessMode).; Returns 0 in case file is not found. char * Which(const char* search, const char* file, EAccessMode mode = kFileExists); Find location of file in a search path. User must delete returned string.; Returns 0 in case file is not found. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group ",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:29562,Availability,error,error,29562,", Long_t* blocks, Long_t* bfree); Get info about a file system: fs type, block size, number of blocks,; number of free blocks. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set the a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file in a search path. Return value points to TString for; compatibility with Which(const char *, const char *, EAccessMode).; Returns 0 in case file is not found. char * Which(const char* search, const char* file, EAccessMode mode = kFileExists); Find location of file in a search path. User must delete returned string.; Returns 0 in case file is not found. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective group id. The effective group id corresponds; to the set id bit on the file being executed. UserGroup_t * GetUserInfo(Int_t ui",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:30665,Availability,error,error,30665,"ion of file in a search path. Return value points to TString for; compatibility with Which(const char *, const char *, EAccessMode).; Returns 0 in case file is not found. char * Which(const char* search, const char* file, EAccessMode mode = kFileExists); Find location of file in a search path. User must delete returned string.; Returns 0 in case file is not found. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective group id. The effective group id corresponds; to the set id bit on the file being executed. UserGroup_t * GetUserInfo(Int_t uid); Returns all user info in the UserGroup_t structure. The returned; structure must be deleted by the user. In case of error 0 is returned. UserGroup_t * GetUserInfo(const char* user = 0); Returns all user info in the UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. void Unsetenv(const char* name); Unset environment variable. const char * Getenv(cons",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:30897,Availability,error,error,30897,"e mode = kFileExists); Find location of file in a search path. User must delete returned string.; Returns 0 in case file is not found. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective group id. The effective group id corresponds; to the set id bit on the file being executed. UserGroup_t * GetUserInfo(Int_t uid); Returns all user info in the UserGroup_t structure. The returned; structure must be deleted by the user. In case of error 0 is returned. UserGroup_t * GetUserInfo(const char* user = 0); Returns all user info in the UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. void Unsetenv(const char* name); Unset environment variable. const char * Getenv(const char* env); Get environment variable. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:31164,Availability,error,error,31164," the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective group id. The effective group id corresponds; to the set id bit on the file being executed. UserGroup_t * GetUserInfo(Int_t uid); Returns all user info in the UserGroup_t structure. The returned; structure must be deleted by the user. In case of error 0 is returned. UserGroup_t * GetUserInfo(const char* user = 0); Returns all user info in the UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. void Unsetenv(const char* name); Unset environment variable. const char * Getenv(const char* env); Get environment variable. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", Re",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:31487,Availability,error,error,31487,"ile being executed. UserGroup_t * GetUserInfo(Int_t uid); Returns all user info in the UserGroup_t structure. The returned; structure must be deleted by the user. In case of error 0 is returned. UserGroup_t * GetUserInfo(const char* user = 0); Returns all user info in the UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. void Unsetenv(const char* name); Unset environment variable. const char * Getenv(const char* env); Get environment variable. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; The implementations of this fu",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:32867,Availability,error,error,32867,"cility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; The implementations of this function save internally the current state into; a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. void ShowOutput(RedirectHandle_t* h); Display the content associated with the redirection described by the; opaque handle 'h'. void AddDynamicPath(const char* pathname); Add a new directory to the dynamic path. const char* GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* pathname); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded, -1 in case lib does not exist; or in case of error and -2 in case of version mismatch.; When entry is specified the loaded lib is; searched for this entry point (return -1 when entry does not exist,; 0 otherwise). When the system flag is kTRUE, the library is consisdered; a permanent systen library that should not be unloaded during the; course o",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:33548,Availability,error,error,33548,"ly the current state into; a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. void ShowOutput(RedirectHandle_t* h); Display the content associated with the redirection described by the; opaque handle 'h'. void AddDynamicPath(const char* pathname); Add a new directory to the dynamic path. const char* GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* pathname); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded, -1 in case lib does not exist; or in case of error and -2 in case of version mismatch.; When entry is specified the loaded lib is; searched for this entry point (return -1 when entry does not exist,; 0 otherwise). When the system flag is kTRUE, the library is consisdered; a permanent systen library that should not be unloaded during the; course of the session. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Need to return the equivalent of LD_LIBRARY_PATH. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:34513,Availability,error,error,34513,"e lib was already loaded, -1 in case lib does not exist; or in case of error and -2 in case of version mismatch.; When entry is specified the loaded lib is; searched for this entry point (return -1 when entry does not exist,; 0 otherwise). When the system flag is kTRUE, the library is consisdered; a permanent systen library that should not be unloaded during the; course of the session. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Need to return the equivalent of LD_LIBRARY_PATH. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last error message. const TString & GetLastErrorString() const; Return the thread local storage for the custom last error message. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:34624,Availability,error,error,34624,"smatch.; When entry is specified the loaded lib is; searched for this entry point (return -1 when entry does not exist,; 0 otherwise). When the system flag is kTRUE, the library is consisdered; a permanent systen library that should not be unloaded during the; course of the session. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Need to return the equivalent of LD_LIBRARY_PATH. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last error message. const TString & GetLastErrorString() const; Return the thread local storage for the custom last error message. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. TInetAddress GetPeerName(int sock); Get ",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:34799,Availability,error,error,34799,"d; a permanent systen library that should not be unloaded during the; course of the session. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Need to return the equivalent of LD_LIBRARY_PATH. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last error message. const TString & GetLastErrorString() const; Return the thread local storage for the custom last error message. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. int GetServiceByName(const char* service)",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:37337,Availability,error,error,37337,"e unix domain service. int AcceptConnection(int sock); Accept a connection. void CloseConnection(int sock, Bool_t force = kFALSE); Close socket connection. int RecvRaw(int sock, void* buffer, int length, int flag); Receive exactly length bytes into buffer. Use opt to receive out-of-band; data or to have a peek at what is in the buffer (see TSocket). int SendRaw(int sock, const void* buffer, int length, int flag); Send exactly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). int RecvBuf(int sock, void* buffer, int length); Receive a buffer headed by a length indicator. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. int SetSockOpt(int sock, int kind, int val); Set socket option. int GetSockOpt(int sock, int kind, int* val); Get socket option. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. int CompileMacro(const char* filename, Option_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); This method compiles and loads a shared library containing; the code from the file ""filename"". The return value is true (1) in case of success and false (0); in case of error. The possible options are:; k : keep the shared library after the session end.",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:37514,Availability,error,error,37514,", void* buffer, int length, int flag); Receive exactly length bytes into buffer. Use opt to receive out-of-band; data or to have a peek at what is in the buffer (see TSocket). int SendRaw(int sock, const void* buffer, int length, int flag); Send exactly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). int RecvBuf(int sock, void* buffer, int length); Receive a buffer headed by a length indicator. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. int SetSockOpt(int sock, int kind, int val); Set socket option. int GetSockOpt(int sock, int kind, int* val); Get socket option. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. int CompileMacro(const char* filename, Option_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); This method compiles and loads a shared library containing; the code from the file ""filename"". The return value is true (1) in case of success and false (0); in case of error. The possible options are:; k : keep the shared library after the session end.; f : force recompilation.; g : compile with debug symbol; O : optimized the code (ignore if 'g' is specified); c : compile only, do not attempt to load the library.; - : if bu",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:37765,Availability,error,error,37765,"ly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). int RecvBuf(int sock, void* buffer, int length); Receive a buffer headed by a length indicator. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. int SetSockOpt(int sock, int kind, int val); Set socket option. int GetSockOpt(int sock, int kind, int* val); Get socket option. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. int CompileMacro(const char* filename, Option_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); This method compiles and loads a shared library containing; the code from the file ""filename"". The return value is true (1) in case of success and false (0); in case of error. The possible options are:; k : keep the shared library after the session end.; f : force recompilation.; g : compile with debug symbol; O : optimized the code (ignore if 'g' is specified); c : compile only, do not attempt to load the library.; - : if buildir is set, use a flat structure (see buildir below). If library_specified is specified, CompileMacro generates the file; ""library_specified"".soext where soext is the shared library extension for; the current platform. If build_dir is specified, it ",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:37924,Availability,error,error,37924,"gth indicator. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. int SetSockOpt(int sock, int kind, int val); Set socket option. int GetSockOpt(int sock, int kind, int* val); Get socket option. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. int CompileMacro(const char* filename, Option_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); This method compiles and loads a shared library containing; the code from the file ""filename"". The return value is true (1) in case of success and false (0); in case of error. The possible options are:; k : keep the shared library after the session end.; f : force recompilation.; g : compile with debug symbol; O : optimized the code (ignore if 'g' is specified); c : compile only, do not attempt to load the library.; - : if buildir is set, use a flat structure (see buildir below). If library_specified is specified, CompileMacro generates the file; ""library_specified"".soext where soext is the shared library extension for; the current platform. If build_dir is specified, it is used as an alternative 'root' for the; generation of the shared library. The library is stored in a sub-directories; of 'build_dir' including the full pathn",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:38252,Availability,error,error,38252," system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. int CompileMacro(const char* filename, Option_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); This method compiles and loads a shared library containing; the code from the file ""filename"". The return value is true (1) in case of success and false (0); in case of error. The possible options are:; k : keep the shared library after the session end.; f : force recompilation.; g : compile with debug symbol; O : optimized the code (ignore if 'g' is specified); c : compile only, do not attempt to load the library.; - : if buildir is set, use a flat structure (see buildir below). If library_specified is specified, CompileMacro generates the file; ""library_specified"".soext where soext is the shared library extension for; the current platform. If build_dir is specified, it is used as an alternative 'root' for the; generation of the shared library. The library is stored in a sub-directories; of 'build_dir' including the full pathname of the script unless a flat; directory structure is requested ('-' option). With the '-' option the libraries; are created directly in the directory 'build_dir'; in particular this means that; 2 scripts with the same name in different source directory will over-write each; other's library.; ",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:41338,Availability,avail,available,41338,"ynopsis:. The purpose of this addition is to allow the user to use an external; compiler to create a shared library from its C++ macro (scripts).; Currently in order to execute a script, a user has to type at the root; prompt. .X myfunc.C(arg1,arg2). We allow him to type:. .X myfunc.C++(arg1,arg2); or; .X myfunc.C+(arg1,arg2). In which case an external compiler will be called to create a shared; library. This shared library will then be loaded and the function; myfunc will be called with the two arguments. With '++' the shared library; is always recompiled. With '+' the shared library is recompiled only; if it does not exist yet or the macro file is newer than the shared; library. Of course the + and ++ notation is supported in similar way for .x and .L. Through the function TSystem::SetMakeSharedLib(), the user will be able to; indicate, with shell commands, how to build a shared library (a good; default will be provided). The most common change, namely where to find; header files, will be available through the function; TSystem::SetIncludePath().; A good default will be provided so that a typical user session should be at; most:. root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; -I$HOME/mypackage/include"");; root[2] .x myfunc.C++(10,20);. The user may sometimes try to compile a script before it has loaded all the; needed shared libraries. In this case we want to be helpfull and output a; list of the unresolved symbols. So if the loading of the created shared; library fails, we will try to build a executable that contains the; script. The linker should then output a list of missing symbols. To support this we provide a TSystem::SetMakeExe() function, that sets the; directive telling how to create an executable. The loader will need; to be informed of all the libraries available. The information about; the libraries that has been loaded by .L and TSystem::Load() is accesible; to the script compiler. However, the information about; the libraries that have been sele",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:42135,Availability,avail,available,42135,"unction TSystem::SetMakeSharedLib(), the user will be able to; indicate, with shell commands, how to build a shared library (a good; default will be provided). The most common change, namely where to find; header files, will be available through the function; TSystem::SetIncludePath().; A good default will be provided so that a typical user session should be at; most:. root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; -I$HOME/mypackage/include"");; root[2] .x myfunc.C++(10,20);. The user may sometimes try to compile a script before it has loaded all the; needed shared libraries. In this case we want to be helpfull and output a; list of the unresolved symbols. So if the loading of the created shared; library fails, we will try to build a executable that contains the; script. The linker should then output a list of missing symbols. To support this we provide a TSystem::SetMakeExe() function, that sets the; directive telling how to create an executable. The loader will need; to be informed of all the libraries available. The information about; the libraries that has been loaded by .L and TSystem::Load() is accesible; to the script compiler. However, the information about; the libraries that have been selected at link time by the application; builder (like the root libraries for root.exe) are not available and need; to be explictly listed in fLinkedLibs (either by default or by a call to; TSystem::SetLinkedLibs()). To simplify customization we could also add to the .rootrc support for the; variables. Unix.*.Root.IncludePath: -I$ROOTSYS/include; WinNT.*.Root.IncludePath: -I%ROOTSYS%/include. Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib .... And also support for MakeSharedLibs() and MakeExe(). (the ... have to be replaced by the actual values and are here only to; shorten this comment). Int_t GetAclicProperties() const; Return the ACLiC properties field. See EAclicProperties for details; on the semantic of ea",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:42426,Availability,avail,available,42426,":. root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; -I$HOME/mypackage/include"");; root[2] .x myfunc.C++(10,20);. The user may sometimes try to compile a script before it has loaded all the; needed shared libraries. In this case we want to be helpfull and output a; list of the unresolved symbols. So if the loading of the created shared; library fails, we will try to build a executable that contains the; script. The linker should then output a list of missing symbols. To support this we provide a TSystem::SetMakeExe() function, that sets the; directive telling how to create an executable. The loader will need; to be informed of all the libraries available. The information about; the libraries that has been loaded by .L and TSystem::Load() is accesible; to the script compiler. However, the information about; the libraries that have been selected at link time by the application; builder (like the root libraries for root.exe) are not available and need; to be explictly listed in fLinkedLibs (either by default or by a call to; TSystem::SetLinkedLibs()). To simplify customization we could also add to the .rootrc support for the; variables. Unix.*.Root.IncludePath: -I$ROOTSYS/include; WinNT.*.Root.IncludePath: -I%ROOTSYS%/include. Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib .... And also support for MakeSharedLibs() and MakeExe(). (the ... have to be replaced by the actual values and are here only to; shorten this comment). Int_t GetAclicProperties() const; Return the ACLiC properties field. See EAclicProperties for details; on the semantic of each bit. const char * GetBuildArch() const; Return the build architecture. const char * GetBuildCompiler() const; Return the build compiler. const char * GetBuildCompilerVersion() const; Return the build compiler version. const char * GetBuildNode() const; Return the build node name. const char * GetBuildDir() const; Return the path of the build directory. const char ",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:329,Integrability,interface,interface,329,". TSystem. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TSystem. class TSystem: public TNamed. TSystem. Abstract base class defining a generic interface to the underlying; Operating System.; This is not an ABC in the strict sense of the (C++) word. For; every member function there is an implementation (often not more; than a call to AbstractMethod() which prints a warning saying; that the method should be overridden in a derived class), which; allows a simple partial implementation for new OS'es. Function Members (Methods); public:. TSystem(const char* name = ""Generic"", const char* title = ""Generic System""); virtual~TSystem(); virtual voidAbort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intAcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode = kFileExists); virtual voidAddDynamicPath(const char* pathname); virtual voidAddFileHandler(TFileHandler* fh); virtual voidAddIncludePath(const char* includePath); virtual voidAddLinkedLibs(const char* linkedLib); virtual voidAddSignalHandler(TSignalHandler* sh); virtual voidAddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidAddTimer(TTimer* t); virtual intAnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intAnnounceUdpService(int port, int backlog); virtual intAnnounceUnixService(int port, int backlog); virtual intAnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*BaseName(const char* pathname); voidBeep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tcd(const char* path); virtual Bool_tChangeDirectory(const char* path); virtual intChmod(const char* file, UInt_t mode); static TCla",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:9082,Integrability,protocol,protocol,9082,"llpath = 0); virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tIsPathLocal(const char* path); virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual intLink(const char* from, const char* to); virtual voidListLibraries(const char* regexp = """"); virtual voidListSymbols(const char* module, const char* re = """"); virtual intLoad(const char* module, const char* entry = """", Bool_t system = kFALSE); virtual voidTNamed::ls(Option_t* option = """") const; virtual intMakeDirectory(const char* name); voidTObject::MayNotUse(const char* method) const; virtual intmkdir(const char* name, Bool_t recursive = kFALSE); virtual Long_tNextTimeOut(Bool_t mode); virtual Bool_tTObject::Notify(); virtual voidNotifyApplicationCreated(); virtual TTimeNow(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual intOpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); virtual void*OpenDirectory(const char* name); virtual voidOpenlog(const char* name, Int_t options, ELogFacility facility); virtual FILE*OpenPipe(const char* command, const char* mode); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual const char*PrependPathName(const char* dir, TString& name); virtual voidTNamed::Print(Option_t* option = """") const; virtual Bool_tProcessEvents(); const char*pwd(); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual intRecvBuf(int sock, void* buffer, int length);",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:17726,Integrability,interface,interface,17726," Int_tfMaxrfdLargest fd in read mask; Int_tfMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tfNfdNumber of fd's in masks; TStringfObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*fOnExitListList of items to be cleaned-up on exit; TFdSet*fReadmask!Files that should be checked for read events; TFdSet*fReadready!Files with reads waiting; Int_tfSigcntNumber of pending signals; TSeqCollection*fSignalHandlerList of signal handlers; TFdSet*fSignals!Signals that were trapped; TStringfSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*fStdExceptionHandlerList of std::exception handlers; TSeqCollection*fTimersList of timers; TStringTNamed::fTitleobject title; TStringfWdpathWorking directory; TFdSet*fWritemask!Files that should be checked for write events; TFdSet*fWriteready!Files with writes waiting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSystem(const char* name = ""Generic"", const char* title = ""Generic System""); Create a new OS interface. ~TSystem(); Delete the OS interface. Bool_t Init(); Initialize the OS interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. void SetErrorStr(const char* errstr); Set the system error string. This string will be used by GetError().; To be used in case one does not want or can use the system error; string (e.g. because error is generated by a third party POSIX like; library that does not use standard errno). const char * GetError(); Return system error string. Int_t GetErrno(); Static function returning system error number. void ResetErrno(); Static function resetting system error number. void RemoveOnExit(TObject* obj); Objects that should be deleted on exit of the OS interface. const char * HostName(); Return the system's host name. void NotifyApplicationCreated(",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:17763,Integrability,interface,interface,17763,"gTNamed::fNameobject identifier; Int_tfNfdNumber of fd's in masks; TStringfObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*fOnExitListList of items to be cleaned-up on exit; TFdSet*fReadmask!Files that should be checked for read events; TFdSet*fReadready!Files with reads waiting; Int_tfSigcntNumber of pending signals; TSeqCollection*fSignalHandlerList of signal handlers; TFdSet*fSignals!Signals that were trapped; TStringfSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*fStdExceptionHandlerList of std::exception handlers; TSeqCollection*fTimersList of timers; TStringTNamed::fTitleobject title; TStringfWdpathWorking directory; TFdSet*fWritemask!Files that should be checked for write events; TFdSet*fWriteready!Files with writes waiting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSystem(const char* name = ""Generic"", const char* title = ""Generic System""); Create a new OS interface. ~TSystem(); Delete the OS interface. Bool_t Init(); Initialize the OS interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. void SetErrorStr(const char* errstr); Set the system error string. This string will be used by GetError().; To be used in case one does not want or can use the system error; string (e.g. because error is generated by a third party POSIX like; library that does not use standard errno). const char * GetError(); Return system error string. Int_t GetErrno(); Static function returning system error number. void ResetErrno(); Static function resetting system error number. void RemoveOnExit(TObject* obj); Objects that should be deleted on exit of the OS interface. const char * HostName(); Return the system's host name. void NotifyApplicationCreated(); Hook to tell TSystem that the TApplication object has been created. void Beep(In",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:17807,Integrability,interface,interface,17807,"dNumber of fd's in masks; TStringfObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*fOnExitListList of items to be cleaned-up on exit; TFdSet*fReadmask!Files that should be checked for read events; TFdSet*fReadready!Files with reads waiting; Int_tfSigcntNumber of pending signals; TSeqCollection*fSignalHandlerList of signal handlers; TFdSet*fSignals!Signals that were trapped; TStringfSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*fStdExceptionHandlerList of std::exception handlers; TSeqCollection*fTimersList of timers; TStringTNamed::fTitleobject title; TStringfWdpathWorking directory; TFdSet*fWritemask!Files that should be checked for write events; TFdSet*fWriteready!Files with writes waiting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSystem(const char* name = ""Generic"", const char* title = ""Generic System""); Create a new OS interface. ~TSystem(); Delete the OS interface. Bool_t Init(); Initialize the OS interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. void SetErrorStr(const char* errstr); Set the system error string. This string will be used by GetError().; To be used in case one does not want or can use the system error; string (e.g. because error is generated by a third party POSIX like; library that does not use standard errno). const char * GetError(); Return system error string. Int_t GetErrno(); Static function returning system error number. void ResetErrno(); Static function resetting system error number. void RemoveOnExit(TObject* obj); Objects that should be deleted on exit of the OS interface. const char * HostName(); Return the system's host name. void NotifyApplicationCreated(); Hook to tell TSystem that the TApplication object has been created. void Beep(Int_t freq = -1, Int_t duration = -1, Bool",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:18575,Integrability,interface,interface,18575,"ng. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSystem(const char* name = ""Generic"", const char* title = ""Generic System""); Create a new OS interface. ~TSystem(); Delete the OS interface. Bool_t Init(); Initialize the OS interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. void SetErrorStr(const char* errstr); Set the system error string. This string will be used by GetError().; To be used in case one does not want or can use the system error; string (e.g. because error is generated by a third party POSIX like; library that does not use standard errno). const char * GetError(); Return system error string. Int_t GetErrno(); Static function returning system error number. void ResetErrno(); Static function resetting system error number. void RemoveOnExit(TObject* obj); Objects that should be deleted on exit of the OS interface. const char * HostName(); Return the system's host name. void NotifyApplicationCreated(); Hook to tell TSystem that the TApplication object has been created. void Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); Beep for duration milliseconds with a tone of freqency freq.; Defaults to printing the '\a' character to stdout.; If freq or duration is <0 respectively, use default value.; If setDefault is set, only set the frequency and duration as; new defaults, but don't beep.; If default freq or duration is <0, never beep (silence). void Run(); System event loop. void ExitLoop(); Exit from event loop. void InnerLoop(); Inner event loop. Bool_t ProcessEvents(); Process pending events (GUI, timers, sockets). Returns the result of; TROOT::IsInterrupted(). The interrupt flag (TROOT::SetInterrupt()); can be set during the handling of the events. This mechanism allows; macros running in tight calculating loops to be interrupte",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:19561,Integrability,depend,depending,19561,"should be deleted on exit of the OS interface. const char * HostName(); Return the system's host name. void NotifyApplicationCreated(); Hook to tell TSystem that the TApplication object has been created. void Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); Beep for duration milliseconds with a tone of freqency freq.; Defaults to printing the '\a' character to stdout.; If freq or duration is <0 respectively, use default value.; If setDefault is set, only set the frequency and duration as; new defaults, but don't beep.; If default freq or duration is <0, never beep (silence). void Run(); System event loop. void ExitLoop(); Exit from event loop. void InnerLoop(); Inner event loop. Bool_t ProcessEvents(); Process pending events (GUI, timers, sockets). Returns the result of; TROOT::IsInterrupted(). The interrupt flag (TROOT::SetInterrupt()); can be set during the handling of the events. This mechanism allows; macros running in tight calculating loops to be interrupted by some; GUI event (depending on the interval with which this method is; called). For example hitting ctrl-c in a canvas will set the; interrupt flag. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milli seconds. Int_t Select(TList* active, Long_t timeout); Select on active file descriptors (called by TMonitor). Int_t Select(TFileHandler* fh, Long_t timeout); Select on active file descriptors (called by TMonitor). TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. void AddTimer(TTimer* t); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* t); Remove timer from list of system timers. Returns removed timer or 0; if timer was not active. Long_t NextTimeOut(Bool_t mode); Time when next timer of mode (synchronous=kTRUE or; asynchronous=kFALSE) will time-out (in ms). void AddSignalHandler(TSignalHandler* sh); Add a signal handler to list of system signal handlers. Only adds; the handle",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:32006,Integrability,message,message,32006,"ure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. void Unsetenv(const char* name); Unset environment variable. const char * Getenv(const char* env); Get environment variable. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; The implementations of this function save internally the current state into; a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. void ShowOutput(RedirectHandle_t* h); Display the content associated with the redirection described by the; opaque handle 'h'. void",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:34519,Integrability,message,message,34519,"e lib was already loaded, -1 in case lib does not exist; or in case of error and -2 in case of version mismatch.; When entry is specified the loaded lib is; searched for this entry point (return -1 when entry does not exist,; 0 otherwise). When the system flag is kTRUE, the library is consisdered; a permanent systen library that should not be unloaded during the; course of the session. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Need to return the equivalent of LD_LIBRARY_PATH. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last error message. const TString & GetLastErrorString() const; Return the thread local storage for the custom last error message. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:34630,Integrability,message,message,34630,"smatch.; When entry is specified the loaded lib is; searched for this entry point (return -1 when entry does not exist,; 0 otherwise). When the system flag is kTRUE, the library is consisdered; a permanent systen library that should not be unloaded during the; course of the session. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Need to return the equivalent of LD_LIBRARY_PATH. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last error message. const TString & GetLastErrorString() const; Return the thread local storage for the custom last error message. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. TInetAddress GetPeerName(int sock); Get ",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:35957,Integrability,protocol,protocol,35957," loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(int port); Get name of internet service. int OpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); Open a connection to another host. int AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); Announce TCP/IP service. int AnnounceUdpService(int port, int backlog); Announce UDP service. int AnnounceUnixService(int port, int backlog); Announce unix domain service. int AnnounceUnixService(const char* sockpath, int backlog); Announce unix domain service. int AcceptConnection(int sock); Accept a connection. void CloseConnection(int sock, Bool_t force = kFALSE); Close socket connection. int RecvRaw(int sock, void* buffer, int length, int flag); Receive exactly length bytes into buffer. Use opt to receive out-of-band; data or to have a peek at what is in the buffer (see TSocket). int SendRaw(int sock, const void* buffer, int length, int flag); Send exactly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). int RecvBuf(int sock, void* buffer, int length); Receive a buffer headed by a length indicator. int S",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:46856,Integrability,depend,depends,46856,"ate an executable. This creation is used as a means to output; a list of unresolved symbols, when loading a shared library has failed.; The required variable is $ExeName rather than $SharedLib, e.g.:; gSystem->SetMakeExe(; ""g++ -Wall -fPIC $IncludePath $SourceFiles; -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic"");. void SetMakeSharedLib(const char* directives); Directives should contain the description on how to compile and link a; shared lib. This description can be any valid shell command, including; the use of ';' to separate several instructions. However, shell specific; construct should be avoided. In particular this description can contain; environment variables, like $ROOTSYS (or %ROOTSYS% on windows). Five special variables will be expanded before execution:; Variable name Expands to; ------------- ----------; $SourceFiles Name of source files to be compiled; $SharedLib Name of the shared library being created; $LibName Name of shared library without extension; $BuildDir Directory where the files will be created; $IncludePath value of fIncludePath; $LinkedLibs value of fLinkedLibs; $DepLibs libraries on which this library depends on; $ObjectFiles Name of source files to be compiler with; their extension changed to .o or .obj; $Opt location of the optimization/debug options; set fFlagsDebug and fFlagsOpt. e.g.:; gSystem->SetMakeSharedLib(; ""KCC -n32 --strict $IncludePath -K0 \$Opt $SourceFile; --no_exceptions --signed_chars --display_error_number; --diag_suppress 68 -o $SharedLib"");. gSystem->setMakeSharedLib(; ""Cxx $IncludePath -c $SourceFile;; ld -L/usr/lib/cmplrs/cxx -rpath /usr/lib/cmplrs/cxx -expect_unresolved; \$Opt -shared /usr/lib/cmplrs/cc/crt0.o /usr/lib/cmplrs/cxx/_main.o; -o $SharedLib $ObjectFile -lcxxstd -lcxx -lexc -lots -lc"". gSystem->SetMakeSharedLib(; ""$HOME/mygcc/bin/g++ \$Opt -Wall -fPIC $IncludePath $SourceFile; -shared -o $SharedLib"");. gSystem->SetMakeSharedLib(; ""cl -DWIN32 -D_WIN32 -D_MT -D_DLL -MD /O2 /G5 /MD -DWIN",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:15277,Modifiability,config,configure,15277,"Libraries(); voidTObject::MakeZombie(); virtual voidSigAlarmInterruptsSyscalls(Bool_t); static const char*StripOffProto(const char* path, const char* proto). private:. TSystem(const TSystem&); TSystem&operator=(const TSystem&). Data Members; public:. enum EAclicMode { kDefault; kDebug; kOpt; };; enum EAclicProperties { kFlatBuildDir; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSystem::EAclicModefAclicModeWhether the compilation should be done debug or opt; Int_tfAclicPropertiesVarious boolean flag for change ACLiC's behavior.; Int_tfBeepDurationUsed by Beep(); Int_tfBeepFreqUsed by Beep(); TStringfBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringfBuildCompilerCompiler used to build this ROOT; TStringfBuildCompilerVersionCompiler version used to build this ROOT; TStringfBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringfBuildNodeDetailed information where ROOT was built; TSeqCollection*fCompiledList of shared libs from compiled macros to be deleted; Bool_tfDoneTrue if eventloop should be finished; TSeqCollection*fFileHandlerList of file handlers; TStringfFlagsDebugFlags for debug compilation; TStringfFlagsOptFlags for optimized compilation; TSeqCollection*fHelpersList of helper classes for alternative file/directory access; TStringfHostnameHostname; Bool_tfInControlTrue if in eventloop; TStringfIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tfInsideNotifyUsed by DispatchTimers(); Int_tfLevelLevel of nested eventloops; TStringfLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringfLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringfL",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:17978,Modifiability,variab,variable,17978,"at should be checked for read events; TFdSet*fReadready!Files with reads waiting; Int_tfSigcntNumber of pending signals; TSeqCollection*fSignalHandlerList of signal handlers; TFdSet*fSignals!Signals that were trapped; TStringfSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*fStdExceptionHandlerList of std::exception handlers; TSeqCollection*fTimersList of timers; TStringTNamed::fTitleobject title; TStringfWdpathWorking directory; TFdSet*fWritemask!Files that should be checked for write events; TFdSet*fWriteready!Files with writes waiting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSystem(const char* name = ""Generic"", const char* title = ""Generic System""); Create a new OS interface. ~TSystem(); Delete the OS interface. Bool_t Init(); Initialize the OS interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. void SetErrorStr(const char* errstr); Set the system error string. This string will be used by GetError().; To be used in case one does not want or can use the system error; string (e.g. because error is generated by a third party POSIX like; library that does not use standard errno). const char * GetError(); Return system error string. Int_t GetErrno(); Static function returning system error number. void ResetErrno(); Static function resetting system error number. void RemoveOnExit(TObject* obj); Objects that should be deleted on exit of the OS interface. const char * HostName(); Return the system's host name. void NotifyApplicationCreated(); Hook to tell TSystem that the TApplication object has been created. void Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); Beep for duration milliseconds with a tone of freqency freq.; Defaults to printing the '\a' character to stdout.; If freq or duration is <0 respectivel",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:25335,Modifiability,variab,variables,25335,"at can be found in the ROOT include; path or the current directory.; If 'name' contains any ACLiC style information (e.g. trailing +[+][g|O]),; it will be striped off 'name'.; If fullpath is != 0, the full path to the file is returned in *fullpath,; which must be deleted by the caller. const char * DirName(const char* pathname); Return the directory name in pathname. DirName of /user/root is /user.; In case no dirname is specified ""."" is returned. const char * UnixPathName(const char* unixpathname); Convert from a Unix pathname to a local pathname. E.g. from /user/root to \user\root. char * ConcatFileName(const char* dir, const char* name); Concatenate a directory and a file name. User must delete returned string. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. const char * ExpandFileName(const char* fname); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. This is a protected function called; from the OS specific system classes, like TUnixSystem and TWinNTSystem.; Returns the expanded filename or 0 in case of error. Bool_t ExpandPathName(TString& path); Expand a pathname getting rid of special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. char * ExpandPathName(const char* path); Expand a pathname getting rid of special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. The user must delete returned string. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can a",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:25785,Modifiability,variab,variables,25785,". const char * UnixPathName(const char* unixpathname); Convert from a Unix pathname to a local pathname. E.g. from /user/root to \user\root. char * ConcatFileName(const char* dir, const char* name); Concatenate a directory and a file name. User must delete returned string. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. const char * ExpandFileName(const char* fname); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. This is a protected function called; from the OS specific system classes, like TUnixSystem and TWinNTSystem.; Returns the expanded filename or 0 in case of error. Bool_t ExpandPathName(TString& path); Expand a pathname getting rid of special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. char * ExpandPathName(const char* path); Expand a pathname getting rid of special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. The user must delete returned string. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; The file name must not contain any special shell characters line ~ or $,; in those cases first call ExpandPathName().; Attention, bizarre convention of return value!!. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int CopyFile(const char* from, const char* to, Bool_t over",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:26075,Modifiability,variab,variables,26075,"pendPathName(const char* dir, TString& name); Concatenate a directory and a file name. const char * ExpandFileName(const char* fname); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. This is a protected function called; from the OS specific system classes, like TUnixSystem and TWinNTSystem.; Returns the expanded filename or 0 in case of error. Bool_t ExpandPathName(TString& path); Expand a pathname getting rid of special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. char * ExpandPathName(const char* path); Expand a pathname getting rid of special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. The user must delete returned string. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; The file name must not contain any special shell characters line ~ or $,; in those cases first call ExpandPathName().; Attention, bizarre convention of return value!!. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* fro",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:28722,Modifiability,config,configured,28722," of success and 1 if the file could; not be stat'ed. int GetPathInfo(const char* path, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); Get info about a file: id, size, flags, modification time.; Id is (statbuf.st_dev << 24) + statbuf.st_ino; Size is the file size; Flags is file type: 0 is regular file, bit 0 set executable,; bit 1 set directory, bit 2 set special file; (socket, fifo, pipe, etc.); Modtime is modification time.; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: fs type, block size, number of blocks,; number of free blocks. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set the a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file in a search path. Return value points to TString",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:31574,Modifiability,variab,variable,31574,"d); Returns all user info in the UserGroup_t structure. The returned; structure must be deleted by the user. In case of error 0 is returned. UserGroup_t * GetUserInfo(const char* user = 0); Returns all user info in the UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. void Unsetenv(const char* name); Unset environment variable. const char * Getenv(const char* env); Get environment variable. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; The implementations of this function save internally the current state into; a stati",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:31635,Modifiability,variab,variable,31635,"; structure must be deleted by the user. In case of error 0 is returned. UserGroup_t * GetUserInfo(const char* user = 0); Returns all user info in the UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. void Unsetenv(const char* name); Unset environment variable. const char * Getenv(const char* env); Get environment variable. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; The implementations of this function save internally the current state into; a static structure.; The call can be made reentrant by specifying the opaque",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:31699,Modifiability,variab,variable,31699,"returned. UserGroup_t * GetUserInfo(const char* user = 0); Returns all user info in the UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. void Unsetenv(const char* name); Unset environment variable. const char * Getenv(const char* env); Get environment variable. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; The implementations of this function save internally the current state into; a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant ",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:40098,Modifiability,variab,variables,40098,"hat; 2 scripts with the same name in different source directory will over-write each; other's library.; See also TSystem::SetBuildDir. If dirmode is not zero and we need to create the target directory, the; file mode bit will be change to 'dirmode' using chmod. If library_specified is not specified, CompileMacro generate a default name; for library by taking the name of the file ""filename"" but replacing the; dot before the extension by an underscore and by adding the shared; library extension for the current platform.; For example on most platform, hsimple.cxx will generate hsimple_cxx.so. It uses the directive fMakeSharedLibs to create a shared library.; If loading the shared library fails, it tries to output a list of missing; symbols by creating an executable (on some platforms like OSF, this does; not HAVE to be an executable) containing the script. It uses the; directive fMakeExe to do so.; For both directives, before passing them to TSystem::Exec, it expands the; variables $SourceFiles, $SharedLib, $LibName, $IncludePath, $LinkedLibs,; $DepLibs, $ExeName and $ObjectFiles. See SetMakeSharedLib() for more; information on those variables. This method is used to implement the following feature:. Synopsis:. The purpose of this addition is to allow the user to use an external; compiler to create a shared library from its C++ macro (scripts).; Currently in order to execute a script, a user has to type at the root; prompt. .X myfunc.C(arg1,arg2). We allow him to type:. .X myfunc.C++(arg1,arg2); or; .X myfunc.C+(arg1,arg2). In which case an external compiler will be called to create a shared; library. This shared library will then be loaded and the function; myfunc will be called with the two arguments. With '++' the shared library; is always recompiled. With '+' the shared library is recompiled only; if it does not exist yet or the macro file is newer than the shared; library. Of course the + and ++ notation is supported in similar way for .x and .L. Through the functi",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:40263,Modifiability,variab,variables,40263,"uildDir. If dirmode is not zero and we need to create the target directory, the; file mode bit will be change to 'dirmode' using chmod. If library_specified is not specified, CompileMacro generate a default name; for library by taking the name of the file ""filename"" but replacing the; dot before the extension by an underscore and by adding the shared; library extension for the current platform.; For example on most platform, hsimple.cxx will generate hsimple_cxx.so. It uses the directive fMakeSharedLibs to create a shared library.; If loading the shared library fails, it tries to output a list of missing; symbols by creating an executable (on some platforms like OSF, this does; not HAVE to be an executable) containing the script. It uses the; directive fMakeExe to do so.; For both directives, before passing them to TSystem::Exec, it expands the; variables $SourceFiles, $SharedLib, $LibName, $IncludePath, $LinkedLibs,; $DepLibs, $ExeName and $ObjectFiles. See SetMakeSharedLib() for more; information on those variables. This method is used to implement the following feature:. Synopsis:. The purpose of this addition is to allow the user to use an external; compiler to create a shared library from its C++ macro (scripts).; Currently in order to execute a script, a user has to type at the root; prompt. .X myfunc.C(arg1,arg2). We allow him to type:. .X myfunc.C++(arg1,arg2); or; .X myfunc.C+(arg1,arg2). In which case an external compiler will be called to create a shared; library. This shared library will then be loaded and the function; myfunc will be called with the two arguments. With '++' the shared library; is always recompiled. With '+' the shared library is recompiled only; if it does not exist yet or the macro file is newer than the shared; library. Of course the + and ++ notation is supported in similar way for .x and .L. Through the function TSystem::SetMakeSharedLib(), the user will be able to; indicate, with shell commands, how to build a shared library (a good",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:42623,Modifiability,variab,variables,42623,"es try to compile a script before it has loaded all the; needed shared libraries. In this case we want to be helpfull and output a; list of the unresolved symbols. So if the loading of the created shared; library fails, we will try to build a executable that contains the; script. The linker should then output a list of missing symbols. To support this we provide a TSystem::SetMakeExe() function, that sets the; directive telling how to create an executable. The loader will need; to be informed of all the libraries available. The information about; the libraries that has been loaded by .L and TSystem::Load() is accesible; to the script compiler. However, the information about; the libraries that have been selected at link time by the application; builder (like the root libraries for root.exe) are not available and need; to be explictly listed in fLinkedLibs (either by default or by a call to; TSystem::SetLinkedLibs()). To simplify customization we could also add to the .rootrc support for the; variables. Unix.*.Root.IncludePath: -I$ROOTSYS/include; WinNT.*.Root.IncludePath: -I%ROOTSYS%/include. Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib .... And also support for MakeSharedLibs() and MakeExe(). (the ... have to be replaced by the actual values and are here only to; shorten this comment). Int_t GetAclicProperties() const; Return the ACLiC properties field. See EAclicProperties for details; on the semantic of each bit. const char * GetBuildArch() const; Return the build architecture. const char * GetBuildCompiler() const; Return the build compiler. const char * GetBuildCompilerVersion() const; Return the build compiler version. const char * GetBuildNode() const; Return the build node name. const char * GetBuildDir() const; Return the path of the build directory. const char * GetFlagsDebug() const; Return the debug flags. const char * GetFlagsOpt() const; Return the optimization flags. const char * GetMakeSh",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:45837,Modifiability,variab,variable,45837," Note that in this; mode there is a risk than 2 script of the same in different source; directory will over-write each other. void SetFlagsDebug(const char* ); FlagsDebug should contain the options to pass to the C++ compiler; in order to compile the library in debug mode. void SetFlagsOpt(const char* ); FlagsOpt should contain the options to pass to the C++ compiler; in order to compile the library in optimized mode. void SetAclicMode(TSystem::EAclicMode mode); AclicMode indicates whether the library should be built in; debug mode or optimized. The values are:; TSystem::kDefault : compile the same as the current ROOT; TSystem::kDebug : compiled in debug mode; TSystem::kOpt : optimized the library. void SetMakeExe(const char* directives); Directives has the same syntax as the argument of SetMakeSharedLib but is; used to create an executable. This creation is used as a means to output; a list of unresolved symbols, when loading a shared library has failed.; The required variable is $ExeName rather than $SharedLib, e.g.:; gSystem->SetMakeExe(; ""g++ -Wall -fPIC $IncludePath $SourceFiles; -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic"");. void SetMakeSharedLib(const char* directives); Directives should contain the description on how to compile and link a; shared lib. This description can be any valid shell command, including; the use of ';' to separate several instructions. However, shell specific; construct should be avoided. In particular this description can contain; environment variables, like $ROOTSYS (or %ROOTSYS% on windows). Five special variables will be expanded before execution:; Variable name Expands to; ------------- ----------; $SourceFiles Name of source files to be compiled; $SharedLib Name of the shared library being created; $LibName Name of shared library without extension; $BuildDir Directory where the files will be created; $IncludePath value of fIncludePath; $LinkedLibs value of fLinkedLibs; $DepLibs libraries on which this libra",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:46375,Modifiability,variab,variables,46375,"ilt in; debug mode or optimized. The values are:; TSystem::kDefault : compile the same as the current ROOT; TSystem::kDebug : compiled in debug mode; TSystem::kOpt : optimized the library. void SetMakeExe(const char* directives); Directives has the same syntax as the argument of SetMakeSharedLib but is; used to create an executable. This creation is used as a means to output; a list of unresolved symbols, when loading a shared library has failed.; The required variable is $ExeName rather than $SharedLib, e.g.:; gSystem->SetMakeExe(; ""g++ -Wall -fPIC $IncludePath $SourceFiles; -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic"");. void SetMakeSharedLib(const char* directives); Directives should contain the description on how to compile and link a; shared lib. This description can be any valid shell command, including; the use of ';' to separate several instructions. However, shell specific; construct should be avoided. In particular this description can contain; environment variables, like $ROOTSYS (or %ROOTSYS% on windows). Five special variables will be expanded before execution:; Variable name Expands to; ------------- ----------; $SourceFiles Name of source files to be compiled; $SharedLib Name of the shared library being created; $LibName Name of shared library without extension; $BuildDir Directory where the files will be created; $IncludePath value of fIncludePath; $LinkedLibs value of fLinkedLibs; $DepLibs libraries on which this library depends on; $ObjectFiles Name of source files to be compiler with; their extension changed to .o or .obj; $Opt location of the optimization/debug options; set fFlagsDebug and fFlagsOpt. e.g.:; gSystem->SetMakeSharedLib(; ""KCC -n32 --strict $IncludePath -K0 \$Opt $SourceFile; --no_exceptions --signed_chars --display_error_number; --diag_suppress 68 -o $SharedLib"");. gSystem->setMakeSharedLib(; ""Cxx $IncludePath -c $SourceFile;; ld -L/usr/lib/cmplrs/cxx -rpath /usr/lib/cmplrs/cxx -expect_unresolved; \$Opt -shared",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:46440,Modifiability,variab,variables,46440,"ate an executable. This creation is used as a means to output; a list of unresolved symbols, when loading a shared library has failed.; The required variable is $ExeName rather than $SharedLib, e.g.:; gSystem->SetMakeExe(; ""g++ -Wall -fPIC $IncludePath $SourceFiles; -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic"");. void SetMakeSharedLib(const char* directives); Directives should contain the description on how to compile and link a; shared lib. This description can be any valid shell command, including; the use of ';' to separate several instructions. However, shell specific; construct should be avoided. In particular this description can contain; environment variables, like $ROOTSYS (or %ROOTSYS% on windows). Five special variables will be expanded before execution:; Variable name Expands to; ------------- ----------; $SourceFiles Name of source files to be compiled; $SharedLib Name of the shared library being created; $LibName Name of shared library without extension; $BuildDir Directory where the files will be created; $IncludePath value of fIncludePath; $LinkedLibs value of fLinkedLibs; $DepLibs libraries on which this library depends on; $ObjectFiles Name of source files to be compiler with; their extension changed to .o or .obj; $Opt location of the optimization/debug options; set fFlagsDebug and fFlagsOpt. e.g.:; gSystem->SetMakeSharedLib(; ""KCC -n32 --strict $IncludePath -K0 \$Opt $SourceFile; --no_exceptions --signed_chars --display_error_number; --diag_suppress 68 -o $SharedLib"");. gSystem->setMakeSharedLib(; ""Cxx $IncludePath -c $SourceFile;; ld -L/usr/lib/cmplrs/cxx -rpath /usr/lib/cmplrs/cxx -expect_unresolved; \$Opt -shared /usr/lib/cmplrs/cc/crt0.o /usr/lib/cmplrs/cxx/_main.o; -o $SharedLib $ObjectFile -lcxxstd -lcxx -lexc -lots -lc"". gSystem->SetMakeSharedLib(; ""$HOME/mygcc/bin/g++ \$Opt -Wall -fPIC $IncludePath $SourceFile; -shared -o $SharedLib"");. gSystem->SetMakeSharedLib(; ""cl -DWIN32 -D_WIN32 -D_MT -D_DLL -MD /O2 /G5 /MD -DWIN",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:48766,Modifiability,config,config,48766,"ncludePath $SourceFile; /link -PDB:NONE /NODEFAULTLIB /INCREMENTAL:NO /RELEASE /NOLOGO; $LinkedLibs -entry:_DllMainCRTStartup@12 -dll /out:$SharedLib""). void AddIncludePath(const char* includePath); Add includePath to the already set include path. void AddLinkedLibs(const char* linkedLib); Add linkedLib to already set linked libs. void SetIncludePath(const char* includePath); IncludePath should contain the list of compiler flags to indicate where; to find user defined header files. It is used to expand $IncludePath in; the directives given to SetMakeSharedLib() and SetMakeExe(), e.g.:; gSystem->SetInclude(""-I$ROOTSYS/include -Imydirectory/include"");; the default value of IncludePath on Unix is:; ""-I$ROOTSYS/include ""; and on Windows:; ""/I%ROOTSYS%/include "". void SetLinkedLibs(const char* linkedLibs); LinkedLibs should contain the library directory and list of libraries; needed to recreate the current executable. It is used to expand $LinkedLibs; in the directives given to SetMakeSharedLib() and SetMakeExe(); The default value on Unix is: root-config --glibs. void SetLinkdefSuffix(const char* suffix); The 'suffix' will be appended to the name of a script loaded by ACLiC; and used to locate any eventual additional linkdef information that; ACLiC should used to produce the dictionary.; So by default, when doing .L MyScript.cxx, ACLiC will look; for a file name MyScript_linkdef and having one of the .h (.hpp,; etc.) extensions. If such a file exist, it will be added to; the end of the linkdef file used to created the ACLiC dictionary.; This effectively enable the full customization of the creation; of the dictionary. It should be noted that the file is intended; as a linkdef 'fragment', so usually you would not list the; typical '#pragma link off ...."". void SetSoExt(const char* soExt); Set shared library extension, should be either .so, .sl, .a, .dll, etc. void SetObjExt(const char* objExt); Set object files extension, should be either .o, .obj, etc. TString SplitAclic",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:15813,Performance,optimiz,optimized,15813,"AclicModeWhether the compilation should be done debug or opt; Int_tfAclicPropertiesVarious boolean flag for change ACLiC's behavior.; Int_tfBeepDurationUsed by Beep(); Int_tfBeepFreqUsed by Beep(); TStringfBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringfBuildCompilerCompiler used to build this ROOT; TStringfBuildCompilerVersionCompiler version used to build this ROOT; TStringfBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringfBuildNodeDetailed information where ROOT was built; TSeqCollection*fCompiledList of shared libs from compiled macros to be deleted; Bool_tfDoneTrue if eventloop should be finished; TSeqCollection*fFileHandlerList of file handlers; TStringfFlagsDebugFlags for debug compilation; TStringfFlagsOptFlags for optimized compilation; TSeqCollection*fHelpersList of helper classes for alternative file/directory access; TStringfHostnameHostname; Bool_tfInControlTrue if in eventloop; TStringfIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tfInsideNotifyUsed by DispatchTimers(); Int_tfLevelLevel of nested eventloops; TStringfLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringfLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringfListLibsList shared libraries, cache used by GetLibraries; TStringfListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringfMakeExeDirective used to build an executable; TStringfMakeSharedLibDirective used to build a shared library; Int_tfMaxrfdLargest fd in read mask; Int_tfMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tfNfdNumber of fd's in masks; TStringfObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*fOnExitListList of items to be cleaned-up on exit; TFdSet*fReadmask!Files that should be checked for read events; TFdS",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:16418,Performance,cache,cache,16418,"AclicModeWhether the compilation should be done debug or opt; Int_tfAclicPropertiesVarious boolean flag for change ACLiC's behavior.; Int_tfBeepDurationUsed by Beep(); Int_tfBeepFreqUsed by Beep(); TStringfBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringfBuildCompilerCompiler used to build this ROOT; TStringfBuildCompilerVersionCompiler version used to build this ROOT; TStringfBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringfBuildNodeDetailed information where ROOT was built; TSeqCollection*fCompiledList of shared libs from compiled macros to be deleted; Bool_tfDoneTrue if eventloop should be finished; TSeqCollection*fFileHandlerList of file handlers; TStringfFlagsDebugFlags for debug compilation; TStringfFlagsOptFlags for optimized compilation; TSeqCollection*fHelpersList of helper classes for alternative file/directory access; TStringfHostnameHostname; Bool_tfInControlTrue if in eventloop; TStringfIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tfInsideNotifyUsed by DispatchTimers(); Int_tfLevelLevel of nested eventloops; TStringfLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringfLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringfListLibsList shared libraries, cache used by GetLibraries; TStringfListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringfMakeExeDirective used to build an executable; TStringfMakeSharedLibDirective used to build a shared library; Int_tfMaxrfdLargest fd in read mask; Int_tfMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tfNfdNumber of fd's in masks; TStringfObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*fOnExitListList of items to be cleaned-up on exit; TFdSet*fReadmask!Files that should be checked for read events; TFdS",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:33459,Performance,load,loading,33459,"ly the current state into; a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. void ShowOutput(RedirectHandle_t* h); Display the content associated with the redirection described by the; opaque handle 'h'. void AddDynamicPath(const char* pathname); Add a new directory to the dynamic path. const char* GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* pathname); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded, -1 in case lib does not exist; or in case of error and -2 in case of version mismatch.; When entry is specified the loaded lib is; searched for this entry point (return -1 when entry does not exist,; 0 otherwise). When the system flag is kTRUE, the library is consisdered; a permanent systen library that should not be unloaded during the; course of the session. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Need to return the equivalent of LD_LIBRARY_PATH. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:33495,Performance,load,loaded,33495,"ly the current state into; a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. void ShowOutput(RedirectHandle_t* h); Display the content associated with the redirection described by the; opaque handle 'h'. void AddDynamicPath(const char* pathname); Add a new directory to the dynamic path. const char* GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* pathname); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded, -1 in case lib does not exist; or in case of error and -2 in case of version mismatch.; When entry is specified the loaded lib is; searched for this entry point (return -1 when entry does not exist,; 0 otherwise). When the system flag is kTRUE, the library is consisdered; a permanent systen library that should not be unloaded during the; course of the session. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Need to return the equivalent of LD_LIBRARY_PATH. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:33619,Performance,load,loaded,33619,"illed with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. void ShowOutput(RedirectHandle_t* h); Display the content associated with the redirection described by the; opaque handle 'h'. void AddDynamicPath(const char* pathname); Add a new directory to the dynamic path. const char* GetDynamicPath(); Return the dynamic path (used to find shared libraries). void SetDynamicPath(const char* pathname); Set the dynamic path to a new value.; If the value of 'path' is zero, the dynamic path is reset to its; default value. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded, -1 in case lib does not exist; or in case of error and -2 in case of version mismatch.; When entry is specified the loaded lib is; searched for this entry point (return -1 when entry does not exist,; 0 otherwise). When the system flag is kTRUE, the library is consisdered; a permanent systen library that should not be unloaded during the; course of the session. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Need to return the equivalent of LD_LIBRARY_PATH. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last error message. const TString & GetLastErrorString() const; Return the thread local storage for the custom last error message. const char * G",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:34343,Performance,load,loaded,34343,"value. int Load(const char* module, const char* entry = """", Bool_t system = kFALSE); Load a shared library. Returns 0 on successful loading, 1 in; case lib was already loaded, -1 in case lib does not exist; or in case of error and -2 in case of version mismatch.; When entry is specified the loaded lib is; searched for this entry point (return -1 when entry does not exist,; 0 otherwise). When the system flag is kTRUE, the library is consisdered; a permanent systen library that should not be unloaded during the; course of the session. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Need to return the equivalent of LD_LIBRARY_PATH. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last error message. const TString & GetLastErrorString() const; Return the thread local storage for the custom last error message. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:34703,Performance,load,loaded,34703,"s not exist,; 0 otherwise). When the system flag is kTRUE, the library is consisdered; a permanent systen library that should not be unloaded during the; course of the session. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Need to return the equivalent of LD_LIBRARY_PATH. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last error message. const TString & GetLastErrorString() const; Return the thread local storage for the custom last error message. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. TInetAddress GetSockName(int sock); Get Internet ",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:34941,Performance,load,loaded,34941,"ame(const char* lib, Bool_t quiet = kFALSE); Need to return the equivalent of LD_LIBRARY_PATH. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last error message. const TString & GetLastErrorString() const; Return the thread local storage for the custom last error message. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(int port); Get name of internet service. int OpenConne",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:35171,Performance,load,loaded,35171,"ary. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last error message. const TString & GetLastErrorString() const; Return the thread local storage for the custom last error message. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(int port); Get name of internet service. int OpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); Open a connection to another host. int AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); Announce TCP/IP service. int AnnounceUdpService(int port, int backlog); Announce UDP service. i",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:35290,Performance,load,loaded,35290,"d ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last error message. const TString & GetLastErrorString() const; Return the thread local storage for the custom last error message. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. TInetAddress GetSockName(int sock); Get Internet Protocol (IP) address of host and port #. int GetServiceByName(const char* service); Get port # of internet service. char * GetServiceByPort(int port); Get name of internet service. int OpenConnection(const char* server, int port, int tcpwindowsize = -1, const char* protocol = ""tcp""); Open a connection to another host. int AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); Announce TCP/IP service. int AnnounceUdpService(int port, int backlog); Announce UDP service. int AnnounceUnixService(int port, int backlog); Announce unix domain service. int AnnounceUnixService(",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:37434,Performance,load,load,37434,"nnection(int sock, Bool_t force = kFALSE); Close socket connection. int RecvRaw(int sock, void* buffer, int length, int flag); Receive exactly length bytes into buffer. Use opt to receive out-of-band; data or to have a peek at what is in the buffer (see TSocket). int SendRaw(int sock, const void* buffer, int length, int flag); Send exactly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). int RecvBuf(int sock, void* buffer, int length); Receive a buffer headed by a length indicator. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. int SetSockOpt(int sock, int kind, int val); Set socket option. int GetSockOpt(int sock, int kind, int* val); Get socket option. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. int CompileMacro(const char* filename, Option_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); This method compiles and loads a shared library containing; the code from the file ""filename"". The return value is true (1) in case of success and false (0); in case of error. The possible options are:; k : keep the shared library after the session end.; f : force recompilation.; g : compile with debug symbol; O : optimized the code (ignor",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:37451,Performance,load,load,37451,"nnection(int sock, Bool_t force = kFALSE); Close socket connection. int RecvRaw(int sock, void* buffer, int length, int flag); Receive exactly length bytes into buffer. Use opt to receive out-of-band; data or to have a peek at what is in the buffer (see TSocket). int SendRaw(int sock, const void* buffer, int length, int flag); Send exactly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). int RecvBuf(int sock, void* buffer, int length); Receive a buffer headed by a length indicator. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. int SetSockOpt(int sock, int kind, int val); Set socket option. int GetSockOpt(int sock, int kind, int* val); Get socket option. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. int CompileMacro(const char* filename, Option_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); This method compiles and loads a shared library containing; the code from the file ""filename"". The return value is true (1) in case of success and false (0); in case of error. The possible options are:; k : keep the shared library after the session end.; f : force recompilation.; g : compile with debug symbol; O : optimized the code (ignor",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:37589,Performance,load,load,37589," buffer. Use opt to receive out-of-band; data or to have a peek at what is in the buffer (see TSocket). int SendRaw(int sock, const void* buffer, int length, int flag); Send exactly length bytes from buffer. Use opt to send out-of-band; data (see TSocket). int RecvBuf(int sock, void* buffer, int length); Receive a buffer headed by a length indicator. int SendBuf(int sock, const void* buffer, int length); Send a buffer headed by a length indicator. int SetSockOpt(int sock, int kind, int val); Set socket option. int GetSockOpt(int sock, int kind, int* val); Get socket option. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. int CompileMacro(const char* filename, Option_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); This method compiles and loads a shared library containing; the code from the file ""filename"". The return value is true (1) in case of success and false (0); in case of error. The possible options are:; k : keep the shared library after the session end.; f : force recompilation.; g : compile with debug symbol; O : optimized the code (ignore if 'g' is specified); c : compile only, do not attempt to load the library.; - : if buildir is set, use a flat structure (see buildir below). If library_spec",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:38108,Performance,load,loads,38108,"int kind, int val); Set socket option. int GetSockOpt(int sock, int kind, int* val); Get socket option. int GetSysInfo(SysInfo_t* info) const; Returns static system info, like OS type, CPU type, number of CPUs; RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 0 otherwise. int GetCpuInfo(CpuInfo_t* info, Int_t sampleTime = 1000) const; Returns cpu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. int CompileMacro(const char* filename, Option_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); This method compiles and loads a shared library containing; the code from the file ""filename"". The return value is true (1) in case of success and false (0); in case of error. The possible options are:; k : keep the shared library after the session end.; f : force recompilation.; g : compile with debug symbol; O : optimized the code (ignore if 'g' is specified); c : compile only, do not attempt to load the library.; - : if buildir is set, use a flat structure (see buildir below). If library_specified is specified, CompileMacro generates the file; ""library_specified"".soext where soext is the shared library extension for; the current platform. If build_dir is specified, it is used as an alternative 'root' for the; generation of the shared library. The library is stored in a sub-directories; of 'build_dir' including the full pathname of the script unless a flat; directory structure is requested ('-' option). With the '-' option the libraries; are created directly in",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:38399,Performance,optimiz,optimized,38399,"pu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. int CompileMacro(const char* filename, Option_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); This method compiles and loads a shared library containing; the code from the file ""filename"". The return value is true (1) in case of success and false (0); in case of error. The possible options are:; k : keep the shared library after the session end.; f : force recompilation.; g : compile with debug symbol; O : optimized the code (ignore if 'g' is specified); c : compile only, do not attempt to load the library.; - : if buildir is set, use a flat structure (see buildir below). If library_specified is specified, CompileMacro generates the file; ""library_specified"".soext where soext is the shared library extension for; the current platform. If build_dir is specified, it is used as an alternative 'root' for the; generation of the shared library. The library is stored in a sub-directories; of 'build_dir' including the full pathname of the script unless a flat; directory structure is requested ('-' option). With the '-' option the libraries; are created directly in the directory 'build_dir'; in particular this means that; 2 scripts with the same name in different source directory will over-write each; other's library.; See also TSystem::SetBuildDir. If dirmode is not zero and we need to create the target directory, the; file mode bit will be change to 'dirmode' using chmod. If library_specified is not specified, CompileMacro gene",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:38484,Performance,load,load,38484,"pu load average and load info into the CpuInfo_t structure.; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; interval over which the CPU load will be measured, in ms (default 1000). int GetMemInfo(MemInfo_t* info) const; Returns ram and swap memory usage info into the MemInfo_t structure.; Returns -1 in case of error, 0 otherwise. int GetProcInfo(ProcInfo_t* info) const; Returns cpu and memory used by this process into the ProcInfo_t structure.; Returns -1 in case of error, 0 otherwise. int CompileMacro(const char* filename, Option_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); This method compiles and loads a shared library containing; the code from the file ""filename"". The return value is true (1) in case of success and false (0); in case of error. The possible options are:; k : keep the shared library after the session end.; f : force recompilation.; g : compile with debug symbol; O : optimized the code (ignore if 'g' is specified); c : compile only, do not attempt to load the library.; - : if buildir is set, use a flat structure (see buildir below). If library_specified is specified, CompileMacro generates the file; ""library_specified"".soext where soext is the shared library extension for; the current platform. If build_dir is specified, it is used as an alternative 'root' for the; generation of the shared library. The library is stored in a sub-directories; of 'build_dir' including the full pathname of the script unless a flat; directory structure is requested ('-' option). With the '-' option the libraries; are created directly in the directory 'build_dir'; in particular this means that; 2 scripts with the same name in different source directory will over-write each; other's library.; See also TSystem::SetBuildDir. If dirmode is not zero and we need to create the target directory, the; file mode bit will be change to 'dirmode' using chmod. If library_specified is not specified, CompileMacro gene",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:39781,Performance,load,loading,39781,"ries; of 'build_dir' including the full pathname of the script unless a flat; directory structure is requested ('-' option). With the '-' option the libraries; are created directly in the directory 'build_dir'; in particular this means that; 2 scripts with the same name in different source directory will over-write each; other's library.; See also TSystem::SetBuildDir. If dirmode is not zero and we need to create the target directory, the; file mode bit will be change to 'dirmode' using chmod. If library_specified is not specified, CompileMacro generate a default name; for library by taking the name of the file ""filename"" but replacing the; dot before the extension by an underscore and by adding the shared; library extension for the current platform.; For example on most platform, hsimple.cxx will generate hsimple_cxx.so. It uses the directive fMakeSharedLibs to create a shared library.; If loading the shared library fails, it tries to output a list of missing; symbols by creating an executable (on some platforms like OSF, this does; not HAVE to be an executable) containing the script. It uses the; directive fMakeExe to do so.; For both directives, before passing them to TSystem::Exec, it expands the; variables $SourceFiles, $SharedLib, $LibName, $IncludePath, $LinkedLibs,; $DepLibs, $ExeName and $ObjectFiles. See SetMakeSharedLib() for more; information on those variables. This method is used to implement the following feature:. Synopsis:. The purpose of this addition is to allow the user to use an external; compiler to create a shared library from its C++ macro (scripts).; Currently in order to execute a script, a user has to type at the root; prompt. .X myfunc.C(arg1,arg2). We allow him to type:. .X myfunc.C++(arg1,arg2); or; .X myfunc.C+(arg1,arg2). In which case an external compiler will be called to create a shared; library. This shared library will then be loaded and the function; myfunc will be called with the two arguments. With '++' the shared library; is a",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:40773,Performance,load,loaded,40773,"e shared library fails, it tries to output a list of missing; symbols by creating an executable (on some platforms like OSF, this does; not HAVE to be an executable) containing the script. It uses the; directive fMakeExe to do so.; For both directives, before passing them to TSystem::Exec, it expands the; variables $SourceFiles, $SharedLib, $LibName, $IncludePath, $LinkedLibs,; $DepLibs, $ExeName and $ObjectFiles. See SetMakeSharedLib() for more; information on those variables. This method is used to implement the following feature:. Synopsis:. The purpose of this addition is to allow the user to use an external; compiler to create a shared library from its C++ macro (scripts).; Currently in order to execute a script, a user has to type at the root; prompt. .X myfunc.C(arg1,arg2). We allow him to type:. .X myfunc.C++(arg1,arg2); or; .X myfunc.C+(arg1,arg2). In which case an external compiler will be called to create a shared; library. This shared library will then be loaded and the function; myfunc will be called with the two arguments. With '++' the shared library; is always recompiled. With '+' the shared library is recompiled only; if it does not exist yet or the macro file is newer than the shared; library. Of course the + and ++ notation is supported in similar way for .x and .L. Through the function TSystem::SetMakeSharedLib(), the user will be able to; indicate, with shell commands, how to build a shared library (a good; default will be provided). The most common change, namely where to find; header files, will be available through the function; TSystem::SetIncludePath().; A good default will be provided so that a typical user session should be at; most:. root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; -I$HOME/mypackage/include"");; root[2] .x myfunc.C++(10,20);. The user may sometimes try to compile a script before it has loaded all the; needed shared libraries. In this case we want to be helpfull and output a; list of the unresolved symbols. So if the l",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:41657,Performance,load,loaded,41657,"C+(arg1,arg2). In which case an external compiler will be called to create a shared; library. This shared library will then be loaded and the function; myfunc will be called with the two arguments. With '++' the shared library; is always recompiled. With '+' the shared library is recompiled only; if it does not exist yet or the macro file is newer than the shared; library. Of course the + and ++ notation is supported in similar way for .x and .L. Through the function TSystem::SetMakeSharedLib(), the user will be able to; indicate, with shell commands, how to build a shared library (a good; default will be provided). The most common change, namely where to find; header files, will be available through the function; TSystem::SetIncludePath().; A good default will be provided so that a typical user session should be at; most:. root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; -I$HOME/mypackage/include"");; root[2] .x myfunc.C++(10,20);. The user may sometimes try to compile a script before it has loaded all the; needed shared libraries. In this case we want to be helpfull and output a; list of the unresolved symbols. So if the loading of the created shared; library fails, we will try to build a executable that contains the; script. The linker should then output a list of missing symbols. To support this we provide a TSystem::SetMakeExe() function, that sets the; directive telling how to create an executable. The loader will need; to be informed of all the libraries available. The information about; the libraries that has been loaded by .L and TSystem::Load() is accesible; to the script compiler. However, the information about; the libraries that have been selected at link time by the application; builder (like the root libraries for root.exe) are not available and need; to be explictly listed in fLinkedLibs (either by default or by a call to; TSystem::SetLinkedLibs()). To simplify customization we could also add to the .rootrc support for the; variables. Unix.*.Root.",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:41790,Performance,load,loading,41790,"ments. With '++' the shared library; is always recompiled. With '+' the shared library is recompiled only; if it does not exist yet or the macro file is newer than the shared; library. Of course the + and ++ notation is supported in similar way for .x and .L. Through the function TSystem::SetMakeSharedLib(), the user will be able to; indicate, with shell commands, how to build a shared library (a good; default will be provided). The most common change, namely where to find; header files, will be available through the function; TSystem::SetIncludePath().; A good default will be provided so that a typical user session should be at; most:. root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; -I$HOME/mypackage/include"");; root[2] .x myfunc.C++(10,20);. The user may sometimes try to compile a script before it has loaded all the; needed shared libraries. In this case we want to be helpfull and output a; list of the unresolved symbols. So if the loading of the created shared; library fails, we will try to build a executable that contains the; script. The linker should then output a list of missing symbols. To support this we provide a TSystem::SetMakeExe() function, that sets the; directive telling how to create an executable. The loader will need; to be informed of all the libraries available. The information about; the libraries that has been loaded by .L and TSystem::Load() is accesible; to the script compiler. However, the information about; the libraries that have been selected at link time by the application; builder (like the root libraries for root.exe) are not available and need; to be explictly listed in fLinkedLibs (either by default or by a call to; TSystem::SetLinkedLibs()). To simplify customization we could also add to the .rootrc support for the; variables. Unix.*.Root.IncludePath: -I$ROOTSYS/include; WinNT.*.Root.IncludePath: -I%ROOTSYS%/include. Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib ....",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:42081,Performance,load,loader,42081,"unction TSystem::SetMakeSharedLib(), the user will be able to; indicate, with shell commands, how to build a shared library (a good; default will be provided). The most common change, namely where to find; header files, will be available through the function; TSystem::SetIncludePath().; A good default will be provided so that a typical user session should be at; most:. root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; -I$HOME/mypackage/include"");; root[2] .x myfunc.C++(10,20);. The user may sometimes try to compile a script before it has loaded all the; needed shared libraries. In this case we want to be helpfull and output a; list of the unresolved symbols. So if the loading of the created shared; library fails, we will try to build a executable that contains the; script. The linker should then output a list of missing symbols. To support this we provide a TSystem::SetMakeExe() function, that sets the; directive telling how to create an executable. The loader will need; to be informed of all the libraries available. The information about; the libraries that has been loaded by .L and TSystem::Load() is accesible; to the script compiler. However, the information about; the libraries that have been selected at link time by the application; builder (like the root libraries for root.exe) are not available and need; to be explictly listed in fLinkedLibs (either by default or by a call to; TSystem::SetLinkedLibs()). To simplify customization we could also add to the .rootrc support for the; variables. Unix.*.Root.IncludePath: -I$ROOTSYS/include; WinNT.*.Root.IncludePath: -I%ROOTSYS%/include. Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib .... And also support for MakeSharedLibs() and MakeExe(). (the ... have to be replaced by the actual values and are here only to; shorten this comment). Int_t GetAclicProperties() const; Return the ACLiC properties field. See EAclicProperties for details; on the semantic of ea",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:42197,Performance,load,loaded,42197,"icate, with shell commands, how to build a shared library (a good; default will be provided). The most common change, namely where to find; header files, will be available through the function; TSystem::SetIncludePath().; A good default will be provided so that a typical user session should be at; most:. root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; -I$HOME/mypackage/include"");; root[2] .x myfunc.C++(10,20);. The user may sometimes try to compile a script before it has loaded all the; needed shared libraries. In this case we want to be helpfull and output a; list of the unresolved symbols. So if the loading of the created shared; library fails, we will try to build a executable that contains the; script. The linker should then output a list of missing symbols. To support this we provide a TSystem::SetMakeExe() function, that sets the; directive telling how to create an executable. The loader will need; to be informed of all the libraries available. The information about; the libraries that has been loaded by .L and TSystem::Load() is accesible; to the script compiler. However, the information about; the libraries that have been selected at link time by the application; builder (like the root libraries for root.exe) are not available and need; to be explictly listed in fLinkedLibs (either by default or by a call to; TSystem::SetLinkedLibs()). To simplify customization we could also add to the .rootrc support for the; variables. Unix.*.Root.IncludePath: -I$ROOTSYS/include; WinNT.*.Root.IncludePath: -I%ROOTSYS%/include. Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib .... And also support for MakeSharedLibs() and MakeExe(). (the ... have to be replaced by the actual values and are here only to; shorten this comment). Int_t GetAclicProperties() const; Return the ACLiC properties field. See EAclicProperties for details; on the semantic of each bit. const char * GetBuildArch() const; Return the build archit",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:43574,Performance,optimiz,optimization,43574,"ustomization we could also add to the .rootrc support for the; variables. Unix.*.Root.IncludePath: -I$ROOTSYS/include; WinNT.*.Root.IncludePath: -I%ROOTSYS%/include. Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib .... And also support for MakeSharedLibs() and MakeExe(). (the ... have to be replaced by the actual values and are here only to; shorten this comment). Int_t GetAclicProperties() const; Return the ACLiC properties field. See EAclicProperties for details; on the semantic of each bit. const char * GetBuildArch() const; Return the build architecture. const char * GetBuildCompiler() const; Return the build compiler. const char * GetBuildCompilerVersion() const; Return the build compiler version. const char * GetBuildNode() const; Return the build node name. const char * GetBuildDir() const; Return the path of the build directory. const char * GetFlagsDebug() const; Return the debug flags. const char * GetFlagsOpt() const; Return the optimization flags. const char * GetMakeSharedLib() const; Return the command line use to make a shared library.; See TSystem::CompileMacro for more details. const char * GetMakeExe() const; Return the command line use to make an executable.; See TSystem::CompileMacro for more details. const char * GetIncludePath(); Get the list of include path. const char * GetLinkedLibs() const; Return the list of library linked to this executable.; See TSystem::CompileMacro for more details. const char * GetLinkdefSuffix() const; Return the linkdef suffix chosen by the user for ACLiC.; See TSystem::CompileMacro for more details. const char * GetSoExt() const; Get the shared library extension. const char * GetObjExt() const; Get the object file extension. void SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); Set the location where ACLiC will create libraries and use as; a scratch area.; If isflast is flase, then the libraries are actually stored in; sub-directories of 'build_d",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:45259,Performance,optimiz,optimized,45259,"st char * GetSoExt() const; Get the shared library extension. const char * GetObjExt() const; Get the object file extension. void SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); Set the location where ACLiC will create libraries and use as; a scratch area.; If isflast is flase, then the libraries are actually stored in; sub-directories of 'build_dir' including the full pathname of the; script. If the script is location at /full/path/name/macro.C; the library will be located at 'build_dir+/full/path/name/macro_C.so'; If 'isflat' is true, then no subdirectory is created and the library; is created directly in the directory 'build_dir'. Note that in this; mode there is a risk than 2 script of the same in different source; directory will over-write each other. void SetFlagsDebug(const char* ); FlagsDebug should contain the options to pass to the C++ compiler; in order to compile the library in debug mode. void SetFlagsOpt(const char* ); FlagsOpt should contain the options to pass to the C++ compiler; in order to compile the library in optimized mode. void SetAclicMode(TSystem::EAclicMode mode); AclicMode indicates whether the library should be built in; debug mode or optimized. The values are:; TSystem::kDefault : compile the same as the current ROOT; TSystem::kDebug : compiled in debug mode; TSystem::kOpt : optimized the library. void SetMakeExe(const char* directives); Directives has the same syntax as the argument of SetMakeSharedLib but is; used to create an executable. This creation is used as a means to output; a list of unresolved symbols, when loading a shared library has failed.; The required variable is $ExeName rather than $SharedLib, e.g.:; gSystem->SetMakeExe(; ""g++ -Wall -fPIC $IncludePath $SourceFiles; -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic"");. void SetMakeSharedLib(const char* directives); Directives should contain the description on how to compile and link a; shared lib. This description can be any valid shell comm",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:45394,Performance,optimiz,optimized,45394,"ir(const char* build_dir, Bool_t isflat = kFALSE); Set the location where ACLiC will create libraries and use as; a scratch area.; If isflast is flase, then the libraries are actually stored in; sub-directories of 'build_dir' including the full pathname of the; script. If the script is location at /full/path/name/macro.C; the library will be located at 'build_dir+/full/path/name/macro_C.so'; If 'isflat' is true, then no subdirectory is created and the library; is created directly in the directory 'build_dir'. Note that in this; mode there is a risk than 2 script of the same in different source; directory will over-write each other. void SetFlagsDebug(const char* ); FlagsDebug should contain the options to pass to the C++ compiler; in order to compile the library in debug mode. void SetFlagsOpt(const char* ); FlagsOpt should contain the options to pass to the C++ compiler; in order to compile the library in optimized mode. void SetAclicMode(TSystem::EAclicMode mode); AclicMode indicates whether the library should be built in; debug mode or optimized. The values are:; TSystem::kDefault : compile the same as the current ROOT; TSystem::kDebug : compiled in debug mode; TSystem::kOpt : optimized the library. void SetMakeExe(const char* directives); Directives has the same syntax as the argument of SetMakeSharedLib but is; used to create an executable. This creation is used as a means to output; a list of unresolved symbols, when loading a shared library has failed.; The required variable is $ExeName rather than $SharedLib, e.g.:; gSystem->SetMakeExe(; ""g++ -Wall -fPIC $IncludePath $SourceFiles; -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic"");. void SetMakeSharedLib(const char* directives); Directives should contain the description on how to compile and link a; shared lib. This description can be any valid shell command, including; the use of ';' to separate several instructions. However, shell specific; construct should be avoided. In particular this d",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:45538,Performance,optimiz,optimized,45538,"s flase, then the libraries are actually stored in; sub-directories of 'build_dir' including the full pathname of the; script. If the script is location at /full/path/name/macro.C; the library will be located at 'build_dir+/full/path/name/macro_C.so'; If 'isflat' is true, then no subdirectory is created and the library; is created directly in the directory 'build_dir'. Note that in this; mode there is a risk than 2 script of the same in different source; directory will over-write each other. void SetFlagsDebug(const char* ); FlagsDebug should contain the options to pass to the C++ compiler; in order to compile the library in debug mode. void SetFlagsOpt(const char* ); FlagsOpt should contain the options to pass to the C++ compiler; in order to compile the library in optimized mode. void SetAclicMode(TSystem::EAclicMode mode); AclicMode indicates whether the library should be built in; debug mode or optimized. The values are:; TSystem::kDefault : compile the same as the current ROOT; TSystem::kDebug : compiled in debug mode; TSystem::kOpt : optimized the library. void SetMakeExe(const char* directives); Directives has the same syntax as the argument of SetMakeSharedLib but is; used to create an executable. This creation is used as a means to output; a list of unresolved symbols, when loading a shared library has failed.; The required variable is $ExeName rather than $SharedLib, e.g.:; gSystem->SetMakeExe(; ""g++ -Wall -fPIC $IncludePath $SourceFiles; -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic"");. void SetMakeSharedLib(const char* directives); Directives should contain the description on how to compile and link a; shared lib. This description can be any valid shell command, including; the use of ';' to separate several instructions. However, shell specific; construct should be avoided. In particular this description can contain; environment variables, like $ROOTSYS (or %ROOTSYS% on windows). Five special variables will be expanded before executio",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:45786,Performance,load,loading,45786,"ubdirectory is created and the library; is created directly in the directory 'build_dir'. Note that in this; mode there is a risk than 2 script of the same in different source; directory will over-write each other. void SetFlagsDebug(const char* ); FlagsDebug should contain the options to pass to the C++ compiler; in order to compile the library in debug mode. void SetFlagsOpt(const char* ); FlagsOpt should contain the options to pass to the C++ compiler; in order to compile the library in optimized mode. void SetAclicMode(TSystem::EAclicMode mode); AclicMode indicates whether the library should be built in; debug mode or optimized. The values are:; TSystem::kDefault : compile the same as the current ROOT; TSystem::kDebug : compiled in debug mode; TSystem::kOpt : optimized the library. void SetMakeExe(const char* directives); Directives has the same syntax as the argument of SetMakeSharedLib but is; used to create an executable. This creation is used as a means to output; a list of unresolved symbols, when loading a shared library has failed.; The required variable is $ExeName rather than $SharedLib, e.g.:; gSystem->SetMakeExe(; ""g++ -Wall -fPIC $IncludePath $SourceFiles; -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic"");. void SetMakeSharedLib(const char* directives); Directives should contain the description on how to compile and link a; shared lib. This description can be any valid shell command, including; the use of ';' to separate several instructions. However, shell specific; construct should be avoided. In particular this description can contain; environment variables, like $ROOTSYS (or %ROOTSYS% on windows). Five special variables will be expanded before execution:; Variable name Expands to; ------------- ----------; $SourceFiles Name of source files to be compiled; $SharedLib Name of the shared library being created; $LibName Name of shared library without extension; $BuildDir Directory where the files will be created; $IncludePath value ",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:46983,Performance,optimiz,optimization,46983,"11 -lm -ldl -rdynamic"");. void SetMakeSharedLib(const char* directives); Directives should contain the description on how to compile and link a; shared lib. This description can be any valid shell command, including; the use of ';' to separate several instructions. However, shell specific; construct should be avoided. In particular this description can contain; environment variables, like $ROOTSYS (or %ROOTSYS% on windows). Five special variables will be expanded before execution:; Variable name Expands to; ------------- ----------; $SourceFiles Name of source files to be compiled; $SharedLib Name of the shared library being created; $LibName Name of shared library without extension; $BuildDir Directory where the files will be created; $IncludePath value of fIncludePath; $LinkedLibs value of fLinkedLibs; $DepLibs libraries on which this library depends on; $ObjectFiles Name of source files to be compiler with; their extension changed to .o or .obj; $Opt location of the optimization/debug options; set fFlagsDebug and fFlagsOpt. e.g.:; gSystem->SetMakeSharedLib(; ""KCC -n32 --strict $IncludePath -K0 \$Opt $SourceFile; --no_exceptions --signed_chars --display_error_number; --diag_suppress 68 -o $SharedLib"");. gSystem->setMakeSharedLib(; ""Cxx $IncludePath -c $SourceFile;; ld -L/usr/lib/cmplrs/cxx -rpath /usr/lib/cmplrs/cxx -expect_unresolved; \$Opt -shared /usr/lib/cmplrs/cc/crt0.o /usr/lib/cmplrs/cxx/_main.o; -o $SharedLib $ObjectFile -lcxxstd -lcxx -lexc -lots -lc"". gSystem->SetMakeSharedLib(; ""$HOME/mygcc/bin/g++ \$Opt -Wall -fPIC $IncludePath $SourceFile; -shared -o $SharedLib"");. gSystem->SetMakeSharedLib(; ""cl -DWIN32 -D_WIN32 -D_MT -D_DLL -MD /O2 /G5 /MD -DWIN32; -D_WINDOWS $IncludePath $SourceFile; /link -PDB:NONE /NODEFAULTLIB /INCREMENTAL:NO /RELEASE /NOLOGO; $LinkedLibs -entry:_DllMainCRTStartup@12 -dll /out:$SharedLib""). void AddIncludePath(const char* includePath); Add includePath to the already set include path. void AddLinkedLibs(const char* linkedLib); Ad",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:48879,Performance,load,loaded,48879,"udePath); Add includePath to the already set include path. void AddLinkedLibs(const char* linkedLib); Add linkedLib to already set linked libs. void SetIncludePath(const char* includePath); IncludePath should contain the list of compiler flags to indicate where; to find user defined header files. It is used to expand $IncludePath in; the directives given to SetMakeSharedLib() and SetMakeExe(), e.g.:; gSystem->SetInclude(""-I$ROOTSYS/include -Imydirectory/include"");; the default value of IncludePath on Unix is:; ""-I$ROOTSYS/include ""; and on Windows:; ""/I%ROOTSYS%/include "". void SetLinkedLibs(const char* linkedLibs); LinkedLibs should contain the library directory and list of libraries; needed to recreate the current executable. It is used to expand $LinkedLibs; in the directives given to SetMakeSharedLib() and SetMakeExe(); The default value on Unix is: root-config --glibs. void SetLinkdefSuffix(const char* suffix); The 'suffix' will be appended to the name of a script loaded by ACLiC; and used to locate any eventual additional linkdef information that; ACLiC should used to produce the dictionary.; So by default, when doing .L MyScript.cxx, ACLiC will look; for a file name MyScript_linkdef and having one of the .h (.hpp,; etc.) extensions. If such a file exist, it will be added to; the end of the linkdef file used to created the ACLiC dictionary.; This effectively enable the full customization of the creation; of the dictionary. It should be noted that the file is intended; as a linkdef 'fragment', so usually you would not list the; typical '#pragma link off ...."". void SetSoExt(const char* soExt); Set shared library extension, should be either .so, .sl, .a, .dll, etc. void SetObjExt(const char* objExt); Set object files extension, should be either .o, .obj, etc. TString SplitAclicMode(const char* filename, TString& mode, TString& args, TString& io) const; This method split a filename of the form:; [path/]macro.C[+|++[g|O]][(args)].; It stores the ACliC mode [+|++[g",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:10982,Safety,timeout,timeout,10982,"l voidTObject::RecursiveRemove(TObject* obj); virtual intRecvBuf(int sock, void* buffer, int length); virtual intRecvRaw(int sock, void* buffer, int length, int flag); virtual Int_tRedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*RemoveFileHandler(TFileHandler* fh); voidRemoveOnExit(TObject* obj); virtual TSignalHandler*RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*RemoveTimer(TTimer* t); virtual intRename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidResetErrno(); virtual voidResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidResetSignals(); virtual voidResetTimer(TTimer*); virtual voidRun(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tSelect(TList* active, Long_t timeout); virtual Int_tSelect(TFileHandler* fh, Long_t timeout); virtual intSendBuf(int sock, const void* buffer, int length); virtual intSendRaw(int sock, const void* buffer, int length, int flag); virtual voidSetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidSetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDynamicPath(const char* pathname); virtual voidSetenv(const char* name, const char* value); voidSetErrorStr(const char* errstr); virtual voidSetFlagsDebug(const char*); virtual voidSetFlagsOpt(const char*); virtual Int_tSetFPEMask(Int_t mask = kDefaultMask); virtual voidSetIncludePath(const char* includePath); virtual voidSetLinkdefSuffix(const char* suffix); virtual voidSetLinkedLibs(const char* linkedLibs); virtual voidSetMakeExe(const char* directives",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:11037,Safety,timeout,timeout,11037,"ntRecvBuf(int sock, void* buffer, int length); virtual intRecvRaw(int sock, void* buffer, int length, int flag); virtual Int_tRedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); virtual TFileHandler*RemoveFileHandler(TFileHandler* fh); voidRemoveOnExit(TObject* obj); virtual TSignalHandler*RemoveSignalHandler(TSignalHandler* sh); virtual TStdExceptionHandler*RemoveStdExceptionHandler(TStdExceptionHandler* eh); virtual TTimer*RemoveTimer(TTimer* t); virtual intRename(const char* from, const char* to); voidTObject::ResetBit(UInt_t f); static voidResetErrno(); virtual voidResetSignal(ESignals sig, Bool_t reset = kTRUE); virtual voidResetSignals(); virtual voidResetTimer(TTimer*); virtual voidRun(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tSelect(TList* active, Long_t timeout); virtual Int_tSelect(TFileHandler* fh, Long_t timeout); virtual intSendBuf(int sock, const void* buffer, int length); virtual intSendRaw(int sock, const void* buffer, int length, int flag); virtual voidSetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidSetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDynamicPath(const char* pathname); virtual voidSetenv(const char* name, const char* value); voidSetErrorStr(const char* errstr); virtual voidSetFlagsDebug(const char*); virtual voidSetFlagsOpt(const char*); virtual Int_tSetFPEMask(Int_t mask = kDefaultMask); virtual voidSetIncludePath(const char* includePath); virtual voidSetLinkdefSuffix(const char* suffix); virtual voidSetLinkedLibs(const char* linkedLibs); virtual voidSetMakeExe(const char* directives); virtual voidSetMakeSharedLib(const char* directives)",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:19863,Safety,timeout,timeout,19863,"eq.; Defaults to printing the '\a' character to stdout.; If freq or duration is <0 respectively, use default value.; If setDefault is set, only set the frequency and duration as; new defaults, but don't beep.; If default freq or duration is <0, never beep (silence). void Run(); System event loop. void ExitLoop(); Exit from event loop. void InnerLoop(); Inner event loop. Bool_t ProcessEvents(); Process pending events (GUI, timers, sockets). Returns the result of; TROOT::IsInterrupted(). The interrupt flag (TROOT::SetInterrupt()); can be set during the handling of the events. This mechanism allows; macros running in tight calculating loops to be interrupted by some; GUI event (depending on the interval with which this method is; called). For example hitting ctrl-c in a canvas will set the; interrupt flag. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milli seconds. Int_t Select(TList* active, Long_t timeout); Select on active file descriptors (called by TMonitor). Int_t Select(TFileHandler* fh, Long_t timeout); Select on active file descriptors (called by TMonitor). TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. void AddTimer(TTimer* t); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* t); Remove timer from list of system timers. Returns removed timer or 0; if timer was not active. Long_t NextTimeOut(Bool_t mode); Time when next timer of mode (synchronous=kTRUE or; asynchronous=kFALSE) will time-out (in ms). void AddSignalHandler(TSignalHandler* sh); Add a signal handler to list of system signal handlers. Only adds; the handler if it is not already in the list of signal handlers. TSignalHandler * RemoveSignalHandler(TSignalHandler* sh); Remove a signal handler from list of signal handlers. Returns; the handler or 0 if the handler was not in the list of signal handlers. void AddFileHandler(TFileHandler* fh); Add a file handler to the list of system file handl",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:19967,Safety,timeout,timeout,19967,"fault value.; If setDefault is set, only set the frequency and duration as; new defaults, but don't beep.; If default freq or duration is <0, never beep (silence). void Run(); System event loop. void ExitLoop(); Exit from event loop. void InnerLoop(); Inner event loop. Bool_t ProcessEvents(); Process pending events (GUI, timers, sockets). Returns the result of; TROOT::IsInterrupted(). The interrupt flag (TROOT::SetInterrupt()); can be set during the handling of the events. This mechanism allows; macros running in tight calculating loops to be interrupted by some; GUI event (depending on the interval with which this method is; called). For example hitting ctrl-c in a canvas will set the; interrupt flag. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milli seconds. Int_t Select(TList* active, Long_t timeout); Select on active file descriptors (called by TMonitor). Int_t Select(TFileHandler* fh, Long_t timeout); Select on active file descriptors (called by TMonitor). TTime Now(); Get current time in milliseconds since 0:00 Jan 1 1995. void AddTimer(TTimer* t); Add timer to list of system timers. TTimer * RemoveTimer(TTimer* t); Remove timer from list of system timers. Returns removed timer or 0; if timer was not active. Long_t NextTimeOut(Bool_t mode); Time when next timer of mode (synchronous=kTRUE or; asynchronous=kFALSE) will time-out (in ms). void AddSignalHandler(TSignalHandler* sh); Add a signal handler to list of system signal handlers. Only adds; the handler if it is not already in the list of signal handlers. TSignalHandler * RemoveSignalHandler(TSignalHandler* sh); Remove a signal handler from list of signal handlers. Returns; the handler or 0 if the handler was not in the list of signal handlers. void AddFileHandler(TFileHandler* fh); Add a file handler to the list of system file handlers. Only adds; the handler if it is not already in the list of file handlers. TFileHandler * RemoveFi",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:26643,Safety,avoid,avoid,26643,"f special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. char * ExpandPathName(const char* path); Expand a pathname getting rid of special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. The user must delete returned string. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; The file name must not contain any special shell characters line ~ or $,; in those cases first call ExpandPathName().; Attention, bizarre convention of return value!!. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. int Link(const char* from, const char* to); Create a link from file1 to file2. int Symlink(const char* from, const char* to); Create a symbolic link from file1 to file2. int Unlink(const char* name); Unlink, i.e. remove, a file. int GetPathInfo(const char* path, Long_t* id, Long_t* size, Long_t* flags, Long_t* modtime); Get info about a file: id, size, flags, modification time.; Id is (statbuf.st_dev << 24) + statbuf.st_ino; Size is the file size; Flags is file type: 0 is regular file, bit 0 set executable,; bit 1 set directory, bit 2 set special file; (socket, fifo, pipe, ",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:29094,Safety,safe,safely,29094,"it 2 set special file; (socket, fifo, pipe, etc.); Modtime is modification time.; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: fs type, block size, number of blocks,; number of free blocks. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set the a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file in a search path. Return value points to TString for; compatibility with Which(const char *, const char *, EAccessMode).; Returns 0 in case file is not found. char * Which(const char* search, const char* file, EAccessMode mode = kFileExists); Find location of file in a search path. User must delete returned string.; Returns 0 in case file is not found. Int_t GetUid(const char* user = 0); Returns the user's ",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:29128,Safety,avoid,avoids,29128,"it 2 set special file; (socket, fifo, pipe, etc.); Modtime is modification time.; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: fs type, block size, number of blocks,; number of free blocks. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set the a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file in a search path. Return value points to TString for; compatibility with Which(const char *, const char *, EAccessMode).; Returns 0 in case file is not found. char * Which(const char* search, const char* file, EAccessMode mode = kFileExists); Find location of file in a search path. User must delete returned string.; Returns 0 in case file is not found. Int_t GetUid(const char* user = 0); Returns the user's ",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:44889,Safety,risk,risk,44889," path. const char * GetLinkedLibs() const; Return the list of library linked to this executable.; See TSystem::CompileMacro for more details. const char * GetLinkdefSuffix() const; Return the linkdef suffix chosen by the user for ACLiC.; See TSystem::CompileMacro for more details. const char * GetSoExt() const; Get the shared library extension. const char * GetObjExt() const; Get the object file extension. void SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); Set the location where ACLiC will create libraries and use as; a scratch area.; If isflast is flase, then the libraries are actually stored in; sub-directories of 'build_dir' including the full pathname of the; script. If the script is location at /full/path/name/macro.C; the library will be located at 'build_dir+/full/path/name/macro_C.so'; If 'isflat' is true, then no subdirectory is created and the library; is created directly in the directory 'build_dir'. Note that in this; mode there is a risk than 2 script of the same in different source; directory will over-write each other. void SetFlagsDebug(const char* ); FlagsDebug should contain the options to pass to the C++ compiler; in order to compile the library in debug mode. void SetFlagsOpt(const char* ); FlagsOpt should contain the options to pass to the C++ compiler; in order to compile the library in optimized mode. void SetAclicMode(TSystem::EAclicMode mode); AclicMode indicates whether the library should be built in; debug mode or optimized. The values are:; TSystem::kDefault : compile the same as the current ROOT; TSystem::kDebug : compiled in debug mode; TSystem::kOpt : optimized the library. void SetMakeExe(const char* directives); Directives has the same syntax as the argument of SetMakeSharedLib but is; used to create an executable. This creation is used as a means to output; a list of unresolved symbols, when loading a shared library has failed.; The required variable is $ExeName rather than $SharedLib, e.g.:; gSystem->SetMakeExe(; ""g++ ",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:46310,Safety,avoid,avoided,46310,"e(TSystem::EAclicMode mode); AclicMode indicates whether the library should be built in; debug mode or optimized. The values are:; TSystem::kDefault : compile the same as the current ROOT; TSystem::kDebug : compiled in debug mode; TSystem::kOpt : optimized the library. void SetMakeExe(const char* directives); Directives has the same syntax as the argument of SetMakeSharedLib but is; used to create an executable. This creation is used as a means to output; a list of unresolved symbols, when loading a shared library has failed.; The required variable is $ExeName rather than $SharedLib, e.g.:; gSystem->SetMakeExe(; ""g++ -Wall -fPIC $IncludePath $SourceFiles; -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic"");. void SetMakeSharedLib(const char* directives); Directives should contain the description on how to compile and link a; shared lib. This description can be any valid shell command, including; the use of ';' to separate several instructions. However, shell specific; construct should be avoided. In particular this description can contain; environment variables, like $ROOTSYS (or %ROOTSYS% on windows). Five special variables will be expanded before execution:; Variable name Expands to; ------------- ----------; $SourceFiles Name of source files to be compiled; $SharedLib Name of the shared library being created; $LibName Name of shared library without extension; $BuildDir Directory where the files will be created; $IncludePath value of fIncludePath; $LinkedLibs value of fLinkedLibs; $DepLibs libraries on which this library depends on; $ObjectFiles Name of source files to be compiler with; their extension changed to .o or .obj; $Opt location of the optimization/debug options; set fFlagsDebug and fFlagsOpt. e.g.:; gSystem->SetMakeSharedLib(; ""KCC -n32 --strict $IncludePath -K0 \$Opt $SourceFile; --no_exceptions --signed_chars --display_error_number; --diag_suppress 68 -o $SharedLib"");. gSystem->setMakeSharedLib(; ""Cxx $IncludePath -c $SourceFile;; ld -",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:15913,Security,access,access,15913,"AclicModeWhether the compilation should be done debug or opt; Int_tfAclicPropertiesVarious boolean flag for change ACLiC's behavior.; Int_tfBeepDurationUsed by Beep(); Int_tfBeepFreqUsed by Beep(); TStringfBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringfBuildCompilerCompiler used to build this ROOT; TStringfBuildCompilerVersionCompiler version used to build this ROOT; TStringfBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringfBuildNodeDetailed information where ROOT was built; TSeqCollection*fCompiledList of shared libs from compiled macros to be deleted; Bool_tfDoneTrue if eventloop should be finished; TSeqCollection*fFileHandlerList of file handlers; TStringfFlagsDebugFlags for debug compilation; TStringfFlagsOptFlags for optimized compilation; TSeqCollection*fHelpersList of helper classes for alternative file/directory access; TStringfHostnameHostname; Bool_tfInControlTrue if in eventloop; TStringfIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tfInsideNotifyUsed by DispatchTimers(); Int_tfLevelLevel of nested eventloops; TStringfLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringfLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringfListLibsList shared libraries, cache used by GetLibraries; TStringfListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringfMakeExeDirective used to build an executable; TStringfMakeSharedLibDirective used to build a shared library; Int_tfMaxrfdLargest fd in read mask; Int_tfMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tfNfdNumber of fd's in masks; TStringfObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*fOnExitListList of items to be cleaned-up on exit; TFdSet*fReadmask!Files that should be checked for read events; TFdS",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:22951,Security,access,access,22951,"tion handlers. TStdExceptionHandler * RemoveStdExceptionHandler(TStdExceptionHandler* eh); Remove an exception handler from list of exception handlers. Returns; the handler or 0 if the handler was not in the list of exception handlers. Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. int Exec(const char* shellcmd); Execute a command. FILE * OpenPipe(const char* command, const char* mode); Open a pipe. int ClosePipe(FILE* pipe); Close the pipe. TString GetFromPipe(const char* command); Execute command and return output in TString. int GetPid(); Get process id. void Exit(int code, Bool_t mode = kTRUE); Exit the application. void Abort(int code = 0); Abort the application. void StackTrace(); Print a stack trace. TSystem * FindHelper(const char* path, void* dirptr = 0); Create helper TSystem to handle file and directory operations that; might be special for remote file access, like via rfiod or rootd. Bool_t ConsistentWith(const char* path, void* dirptr = 0); Check consistency of this helper with the one required; by 'path' or 'dirptr'. int MakeDirectory(const char* name); Make a directory. Returns 0 in case of success and; -1 if the directory could not be created (either already exists or; illegal path name). void * OpenDirectory(const char* name); Open a directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Free a directory. const char * GetDirEntry(void* dirp); Get a directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. int mkdir(const char* name, Bool_t recursive = kFALSE); Make a file system directory. Returns 0 in case of success and; -1 if the directory cou",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:26305,Security,access,access,26305,"ility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. This is a protected function called; from the OS specific system classes, like TUnixSystem and TWinNTSystem.; Returns the expanded filename or 0 in case of error. Bool_t ExpandPathName(TString& path); Expand a pathname getting rid of special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. char * ExpandPathName(const char* path); Expand a pathname getting rid of special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. The user must delete returned string. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; The file name must not contain any special shell characters line ~ or $,; in those cases first call ExpandPathName().; Attention, bizarre convention of return value!!. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. int Link(const char* from, const char* to); Create a link from file1 to file2. int Symlink(const char* from, const char* to); Create a symbolic link from file1 to file2. int Unlink(const char* name)",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:26339,Security,access,access,26339,"ility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. This is a protected function called; from the OS specific system classes, like TUnixSystem and TWinNTSystem.; Returns the expanded filename or 0 in case of error. Bool_t ExpandPathName(TString& path); Expand a pathname getting rid of special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. char * ExpandPathName(const char* path); Expand a pathname getting rid of special shell characaters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. The user must delete returned string. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; The file name must not contain any special shell characters line ~ or $,; in those cases first call ExpandPathName().; Attention, bizarre convention of return value!!. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. int Link(const char* from, const char* to); Create a link from file1 to file2. int Symlink(const char* from, const char* to); Create a symbolic link from file1 to file2. int Unlink(const char* name)",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:28854,Security,secur,secure,28854,"gs, Long_t* modtime); Get info about a file: id, size, flags, modification time.; Id is (statbuf.st_dev << 24) + statbuf.st_ino; Size is the file size; Flags is file type: 0 is regular file, bit 0 set executable,; bit 1 set directory, bit 2 set special file; (socket, fifo, pipe, etc.); Modtime is modification time.; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: fs type, block size, number of blocks,; number of free blocks. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set the a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file in a search path. Return value points to TString for; compatibility with Which(const char *, const char *, EAccessMode).; Returns 0 in case file is not found. char * Which(co",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:29143,Security,secur,security,29143,"it 2 set special file; (socket, fifo, pipe, etc.); Modtime is modification time.; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: fs type, block size, number of blocks,; number of free blocks. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set the a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file in a search path. Return value points to TString for; compatibility with Which(const char *, const char *, EAccessMode).; Returns 0 in case file is not found. char * Which(const char* search, const char* file, EAccessMode mode = kFileExists); Find location of file in a search path. User must delete returned string.; Returns 0 in case file is not found. Int_t GetUid(const char* user = 0); Returns the user's ",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:29463,Security,access,access,29463,"rns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: fs type, block size, number of blocks,; number of free blocks. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set the a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file in a search path. Return value points to TString for; compatibility with Which(const char *, const char *, EAccessMode).; Returns 0 in case file is not found. char * Which(const char* search, const char* file, EAccessMode mode = kFileExists); Find location of file in a search path. User must delete returned string.; Returns 0 in case file is not found. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective grou",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:31805,Testability,log,log,31805,"e UserGroup_t structure. If user = 0, returns; current user's id info. The returned structure must be deleted by the; user. In case of error 0 is returned. UserGroup_t * GetGroupInfo(Int_t gid); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. void Unsetenv(const char* name); Unset environment variable. const char * Getenv(const char* env); Get environment variable. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; The implementations of this function save internally the current state into; a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subse",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:31978,Testability,log,logging,31978,"ure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. void Unsetenv(const char* name); Unset environment variable. const char * Getenv(const char* env); Get environment variable. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; The implementations of this function save internally the current state into; a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. void ShowOutput(RedirectHandle_t* h); Display the content associated with the redirection described by the; opaque handle 'h'. void",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:32042,Testability,log,log,32042,"ure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. void Unsetenv(const char* name); Unset environment variable. const char * Getenv(const char* env); Get environment variable. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; The implementations of this function save internally the current state into; a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. void ShowOutput(RedirectHandle_t* h); Display the content associated with the redirection described by the; opaque handle 'h'. void",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:32091,Testability,log,log,32091,"ll are:; fGid and fGroup; The returned structure must be deleted by the user. In case of; error 0 is returned. UserGroup_t * GetGroupInfo(const char* group = 0); Returns all group info in the UserGroup_t structure. The only active; fields in the UserGroup_t structure for this call are:; fGid and fGroup; If group = 0, returns current user's group. The returned structure; must be deleted by the user. In case of error 0 is returned. void Setenv(const char* name, const char* value); Set environment variable. void Unsetenv(const char* name); Unset environment variable. const char * Getenv(const char* env); Get environment variable. void Openlog(const char* name, Int_t options, ELogFacility facility); Open connection to system log daemon. For the use of the options and; facility see the Unix openlog man page. void Syslog(ELogLevel level, const char* mess); Send mess to syslog daemon. Level is the logging level and mess the; message that will be written on the log. void Closelog(); Close connection to system log daemon. Int_t RedirectOutput(const char* name, const char* mode = ""a"", RedirectHandle_t* h = 0); Redirect standard output (stdout, stderr) to the specified file.; If the file argument is 0 the output is set again to stderr, stdout.; The second argument specifies whether the output should be added to the; file (""a"", default) or the file be truncated before (""w"").; The implementations of this function save internally the current state into; a static structure.; The call can be made reentrant by specifying the opaque structure pointed; by 'h', which is filled with the relevant information. The handle 'h'; obtained on the first call must then be used in any subsequent call,; included ShowOutput, to display the redirected output.; Returns 0 on success, -1 in case of error. void ShowOutput(RedirectHandle_t* h); Display the content associated with the redirection described by the; opaque handle 'h'. void AddDynamicPath(const char* pathname); Add a new directory to the dyn",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:643,Usability,simpl,simple,643,". TSystem. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TSystem. class TSystem: public TNamed. TSystem. Abstract base class defining a generic interface to the underlying; Operating System.; This is not an ABC in the strict sense of the (C++) word. For; every member function there is an implementation (often not more; than a call to AbstractMethod() which prints a warning saying; that the method should be overridden in a derived class), which; allows a simple partial implementation for new OS'es. Function Members (Methods); public:. TSystem(const char* name = ""Generic"", const char* title = ""Generic System""); virtual~TSystem(); virtual voidAbort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intAcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode = kFileExists); virtual voidAddDynamicPath(const char* pathname); virtual voidAddFileHandler(TFileHandler* fh); virtual voidAddIncludePath(const char* includePath); virtual voidAddLinkedLibs(const char* linkedLib); virtual voidAddSignalHandler(TSignalHandler* sh); virtual voidAddStdExceptionHandler(TStdExceptionHandler* eh); virtual voidAddTimer(TTimer* t); virtual intAnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1); virtual intAnnounceUdpService(int port, int backlog); virtual intAnnounceUnixService(int port, int backlog); virtual intAnnounceUnixService(const char* sockpath, int backlog); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*BaseName(const char* pathname); voidBeep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); virtual voidTObject::Browse(TBrowser* b); Bool_tcd(const char* path); virtual Bool_tChangeDirectory(const char* path); virtual intChmod(const char* file, UInt_t mode); static TCla",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystem.html:42550,Usability,simpl,simplify,42550," .x myfunc.C++(10,20);. The user may sometimes try to compile a script before it has loaded all the; needed shared libraries. In this case we want to be helpfull and output a; list of the unresolved symbols. So if the loading of the created shared; library fails, we will try to build a executable that contains the; script. The linker should then output a list of missing symbols. To support this we provide a TSystem::SetMakeExe() function, that sets the; directive telling how to create an executable. The loader will need; to be informed of all the libraries available. The information about; the libraries that has been loaded by .L and TSystem::Load() is accesible; to the script compiler. However, the information about; the libraries that have been selected at link time by the application; builder (like the root libraries for root.exe) are not available and need; to be explictly listed in fLinkedLibs (either by default or by a call to; TSystem::SetLinkedLibs()). To simplify customization we could also add to the .rootrc support for the; variables. Unix.*.Root.IncludePath: -I$ROOTSYS/include; WinNT.*.Root.IncludePath: -I%ROOTSYS%/include. Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib .... And also support for MakeSharedLibs() and MakeExe(). (the ... have to be replaced by the actual values and are here only to; shorten this comment). Int_t GetAclicProperties() const; Return the ACLiC properties field. See EAclicProperties for details; on the semantic of each bit. const char * GetBuildArch() const; Return the build architecture. const char * GetBuildCompiler() const; Return the build compiler. const char * GetBuildCompilerVersion() const; Return the build compiler version. const char * GetBuildNode() const; Return the build node name. const char * GetBuildDir() const; Return the path of the build directory. const char * GetFlagsDebug() const; Return the debug flags. const char * GetFlagsOpt() const; Return the",MatchSource.WIKI,root/html534/TSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystem.html
https://root.cern/root/html534/TSystemDirectory.html:1513,Availability,error,error,1513,"emDirectory(); TSystemDirectory(const char* dirname, const char* path); virtual~TSystemDirectory(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(const char*); virtual voidCopy(TObject&) const; virtual voidDelete(); virtual voidDelete(Option_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawClass() const; virtual TObject*DrawClone(Option_t*) const; virtual voidTSystemFile::Dump() const; virtual voidEdit(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TSystemFile::GetIconName() const; virtual TList*GetListOfFiles() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, con",MatchSource.WIKI,root/html534/TSystemDirectory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystemDirectory.html
https://root.cern/root/html534/TSystemDirectory.html:1597,Availability,error,error,1597,"temDirectory(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(const char*); virtual voidCopy(TObject&) const; virtual voidDelete(); virtual voidDelete(Option_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawClass() const; virtual TObject*DrawClone(Option_t*) const; virtual voidTSystemFile::Dump() const; virtual voidEdit(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TSystemFile::GetIconName() const; virtual TList*GetListOfFiles() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) c",MatchSource.WIKI,root/html534/TSystemDirectory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystemDirectory.html
https://root.cern/root/html534/TSystemDirectory.html:6766,Availability,error,errors,6766,"kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TOrdCollection*fDirsInBrowser; TOrdCollection*fFilesInBrowser; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSystemDirectory(); Create a system directory object. TSystemDirectory(const char* dirname, const char* path); Create a system directory object. TSystemDirectory(const TSystemDirectory& ); copy constructor. TSystemDirectory& operator=(const TSystemDirectory& ); assignment operator. ~TSystemDirectory(); Delete system directory object. TList * GetListOfFiles() const; Returns a TList of TSystemFile objects representing the contents; of the directory. It's the responsibility of the user to delete; the list (the list owns the contained objects).; Returns 0 in case of errors. void SetDirectory(const char* name); Create a system directory object. Bool_t IsItDirectory(const char* name) const; Check if name is a directory. void Browse(TBrowser* b); Browse OS system directories. TSystemDirectory * FindDirObj(const char* name); Method that returns system directory object if it; exists in list, 0 otherwise. TSystemFile * FindFileObj(const char* name, const char* dir); Method that returns system file object if it exists in; list, 0 otherwise. Bool_t IsFolder() const; { return kTRUE; }. Bool_t IsDirectory(const char* = 0) const; { return kTRUE; }. void Edit(); { }. void Delete(); {}. void Copy(const char* ); {}. void Move(const char* ); {}. void DrawClass() const; dummy methods from TObject. { }. TObject * DrawClone(Option_t* ) const; { return 0; }. void SetDrawOption(Option_t* ); { }. void SetName(const char* name); { TSystemFile::SetName(name); }. void SetTitle(const char* title); { TSystemFile::SetTitle(title); }. void Delete(Option_t* ); { }. vo",MatchSource.WIKI,root/html534/TSystemDirectory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystemDirectory.html
https://root.cern/root/html534/TSystemFile.html:1478,Availability,error,error,1478," TSystemFile&); TSystemFile(const char* filename, const char* dirname); virtual~TSystemFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(const char* to)MENU ; virtual voidCopy(TObject&) const; virtual voidDelete()MENU ; virtual voidDelete(Option_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawClass() const; virtual TObject*DrawClone(Option_t*) const; virtual voidDump() const; virtual voidEdit()MENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::Inhe",MatchSource.WIKI,root/html534/TSystemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystemFile.html
https://root.cern/root/html534/TSystemFile.html:1562,Availability,error,error,1562,"temFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(const char* to)MENU ; virtual voidCopy(TObject&) const; virtual voidDelete()MENU ; virtual voidDelete(Option_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawClass() const; virtual TObject*DrawClone(Option_t*) const; virtual voidDump() const; virtual voidEdit()MENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TCl",MatchSource.WIKI,root/html534/TSystemFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TSystemFile.html
https://root.cern/root/html534/TTabCom.html:2659,Availability,error,error,2659,"complete a member of a global object). 7. the list of #pragma's is hardcoded; (ie not obtained from the interpreter at runtime); ==> user-defined #pragma's will not be recognized. 8. the system include directories are also hardcoded; because i don't know how to get them from the interpreter.; fons, maybe they should be #ifdef'd for the different sytems?. 9. the TabCom.FileIgnore resource is always applied, even if you; are not trying to complete a filename. 10. anything in quotes is assumed to be a filename; so (among other things) you can't complete a quoted class name:; eg, TClass class1( ""TDict[TAB] //; this won't work... looks for a file in pwd starting with TDict. 11. the prototypes tend to omit the word ""const"" a lot.; this is a problem with ROOT or CINT. 12. when listing ambiguous matches, only one column is used,; even if there are many completions. 13. anonymous objects are not currently identified; so, for example,. root> printf( TString([TAB. gives an error message instead of listing TString's constructors.; (this could be fixed). 14. the routine that adds the ""appendage"" isn't smart enough to know; if it's already there:. root> TCanvas::Update(); press [TAB] here ^; root> TCanvas::Update()(); (this could be fixed). 15. the appendage is only applied if there is exactly 1 match.; eg, this. root> G__at[TAB]; root> G__ateval. happens instead of this. root> G__at[TAB]; root> G__ateval(. because there are several overloaded versions of G__ateval().; (this could be fixed). Function Members (Methods); public:. TTabCom(); virtual~TTabCom(); static Char_tAllAgreeOnChar(int i, const TSeqCollection* pList, Int_t& nGoodStrings); static voidAppendListOfFilesInDirectory(const char* dirName, TSeqCollection* pList); static TClass*Class(); voidClearAll(); voidClearClasses(); voidClearCppDirectives(); voidClearEnvVars(); voidClearFiles(); voidClearGlobalFunctions(); voidClearGlobals(); voidClearPragmas(); voidClearSysIncFiles(); voidClearUsers(); static TStringDetermineCla",MatchSource.WIKI,root/html534/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTabCom.html
https://root.cern/root/html534/TTabCom.html:4398,Availability,error,errorLevel,4398," G__ateval. happens instead of this. root> G__at[TAB]; root> G__ateval(. because there are several overloaded versions of G__ateval().; (this could be fixed). Function Members (Methods); public:. TTabCom(); virtual~TTabCom(); static Char_tAllAgreeOnChar(int i, const TSeqCollection* pList, Int_t& nGoodStrings); static voidAppendListOfFilesInDirectory(const char* dirName, TSeqCollection* pList); static TClass*Class(); voidClearAll(); voidClearClasses(); voidClearCppDirectives(); voidClearEnvVars(); voidClearFiles(); voidClearGlobalFunctions(); voidClearGlobals(); voidClearPragmas(); voidClearSysIncFiles(); voidClearUsers(); static TStringDetermineClass(const char* varName); static Bool_tExcludedByFignore(TString s); const TSeqCollection*GetListOfClasses(); const TSeqCollection*GetListOfCppDirectives(); const TSeqCollection*GetListOfEnvVars(); const TSeqCollection*GetListOfFilesInPath(const char* path); const TSeqCollection*GetListOfGlobalFunctions(); const TSeqCollection*GetListOfGlobals(); const TSeqCollection*GetListOfPragmas(); const TSeqCollection*GetListOfSysIncFiles(); const TSeqCollection*GetListOfUsers(); static TStringGetSysIncludePath(); Int_tHook(char* buf, int* pLoc, ostream& out); virtual TClass*IsA() const; static Bool_tIsDirectory(const char* fileName); static TSeqCollection*NewListOfFilesInPath(const char* path); static voidNoMsg(Int_t errorLevel); static Bool_tPathIsSpecifiedInFileName(const TString& fileName); voidRehashAll(); voidRehashClasses(); voidRehashCppDirectives(); voidRehashEnvVars(); voidRehashFiles(); voidRehashGlobalFunctions(); voidRehashGlobals(); voidRehashPragmas(); voidRehashSysIncFiles(); voidRehashUsers(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TTabCom(const TTabCom&); Int_tComplete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char* appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); vo",MatchSource.WIKI,root/html534/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTabCom.html
https://root.cern/root/html534/TTabCom.html:9660,Availability,failure,failure,9660," * GetListOfPragmas(); Return the list of pragmas. const TSeqCollection * GetListOfSysIncFiles(); Return the list of system include files. const TSeqCollection * GetListOfUsers(); reads from ""/etc/passwd"". Char_t AllAgreeOnChar(int i, const TSeqCollection* pList, Int_t& nGoodStrings); [static utility function]. if all the strings in ""*pList"" have the same ith character,; that character is returned.; otherwise 0 is returned. any string ""s"" for which ""ExcludedByFignore(s)"" is true; will be ignored unless All the strings in ""*pList""; are ""ExcludedByFignore()"". in addition, the number of strings which were not; ""ExcludedByFignore()"" is returned in ""nGoodStrings"". void AppendListOfFilesInDirectory(const char* dirName, TSeqCollection* pList); [static utility function]. adds a TObjString to ""*pList""; for each entry found in the system directory ""dirName"". directories that do not exist are silently ignored. TString DetermineClass(const char* varName); [static utility function]. returns empty string on failure.; otherwise returns something like this: ""TROOT*"".; fails for non-class types (ie, int, char, etc).; fails for pointers to functions. Bool_t ExcludedByFignore(TString s); [static utility function]. returns true iff ""s"" ends with one of; the strings listed in the ""TabCom.FileIgnore"" resource. TString GetSysIncludePath(); [static utility function]. returns a colon-separated string of directories; that CINT will search when you call #include<...>. returns empty string on failure. Bool_t IsDirectory(const char* fileName); [static utility function]. calls TSystem::GetPathInfo() to see if ""fileName""; is a system directory. TSeqCollection * NewListOfFilesInPath(const char* path); [static utility function]. creates a list containing the full path name for each file; in the (colon separated) string ""path1"". memory is allocated with ""new"", so; whoever calls this function takes responsibility for deleting it. Bool_t PathIsSpecifiedInFileName(const TString& fileName); [static utili",MatchSource.WIKI,root/html534/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTabCom.html
https://root.cern/root/html534/TTabCom.html:10141,Availability,failure,failure,10141,"ue; will be ignored unless All the strings in ""*pList""; are ""ExcludedByFignore()"". in addition, the number of strings which were not; ""ExcludedByFignore()"" is returned in ""nGoodStrings"". void AppendListOfFilesInDirectory(const char* dirName, TSeqCollection* pList); [static utility function]. adds a TObjString to ""*pList""; for each entry found in the system directory ""dirName"". directories that do not exist are silently ignored. TString DetermineClass(const char* varName); [static utility function]. returns empty string on failure.; otherwise returns something like this: ""TROOT*"".; fails for non-class types (ie, int, char, etc).; fails for pointers to functions. Bool_t ExcludedByFignore(TString s); [static utility function]. returns true iff ""s"" ends with one of; the strings listed in the ""TabCom.FileIgnore"" resource. TString GetSysIncludePath(); [static utility function]. returns a colon-separated string of directories; that CINT will search when you call #include<...>. returns empty string on failure. Bool_t IsDirectory(const char* fileName); [static utility function]. calls TSystem::GetPathInfo() to see if ""fileName""; is a system directory. TSeqCollection * NewListOfFilesInPath(const char* path); [static utility function]. creates a list containing the full path name for each file; in the (colon separated) string ""path1"". memory is allocated with ""new"", so; whoever calls this function takes responsibility for deleting it. Bool_t PathIsSpecifiedInFileName(const TString& fileName); [static utility function]. true if ""fileName""; 1. is an absolute path (""/tmp/a""); 2. is a relative path (""../whatever"", ""./test""); 3. starts with user name (""~/mail""); 4. starts with an environment variable (""$ROOTSYS/bin""). void NoMsg(Int_t errorLevel); [static utility function]. calling ""NoMsg( errorLevel )"",; sets ""gErrorIgnoreLevel"" to ""errorLevel+1"" so that; all errors with ""level < errorLevel"" will be ignored. calling the function with a negative argument; (e.g., ""NoMsg( -1 )""); rese",MatchSource.WIKI,root/html534/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTabCom.html
https://root.cern/root/html534/TTabCom.html:10881,Availability,error,errorLevel,10881," with one of; the strings listed in the ""TabCom.FileIgnore"" resource. TString GetSysIncludePath(); [static utility function]. returns a colon-separated string of directories; that CINT will search when you call #include<...>. returns empty string on failure. Bool_t IsDirectory(const char* fileName); [static utility function]. calls TSystem::GetPathInfo() to see if ""fileName""; is a system directory. TSeqCollection * NewListOfFilesInPath(const char* path); [static utility function]. creates a list containing the full path name for each file; in the (colon separated) string ""path1"". memory is allocated with ""new"", so; whoever calls this function takes responsibility for deleting it. Bool_t PathIsSpecifiedInFileName(const TString& fileName); [static utility function]. true if ""fileName""; 1. is an absolute path (""/tmp/a""); 2. is a relative path (""../whatever"", ""./test""); 3. starts with user name (""~/mail""); 4. starts with an environment variable (""$ROOTSYS/bin""). void NoMsg(Int_t errorLevel); [static utility function]. calling ""NoMsg( errorLevel )"",; sets ""gErrorIgnoreLevel"" to ""errorLevel+1"" so that; all errors with ""level < errorLevel"" will be ignored. calling the function with a negative argument; (e.g., ""NoMsg( -1 )""); resets gErrorIgnoreLevel to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char* appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char* dest, const char* localName, const char* appendage = 0, const char* fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char* defaultPath) const; [private]. TString ExtendPath(const char* originalPath, TString newBase) const; [private]. Int_t Hook(char* buf, int* pLoc, ostream& out); [private]. void InitPatterns(); [private]. TClass * MakeClassFromClassName(const char* className) const; [private]; (does some specific error handling that makes the function unsuitable for general use.); re",MatchSource.WIKI,root/html534/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTabCom.html
https://root.cern/root/html534/TTabCom.html:10937,Availability,error,errorLevel,10937," [static utility function]. returns a colon-separated string of directories; that CINT will search when you call #include<...>. returns empty string on failure. Bool_t IsDirectory(const char* fileName); [static utility function]. calls TSystem::GetPathInfo() to see if ""fileName""; is a system directory. TSeqCollection * NewListOfFilesInPath(const char* path); [static utility function]. creates a list containing the full path name for each file; in the (colon separated) string ""path1"". memory is allocated with ""new"", so; whoever calls this function takes responsibility for deleting it. Bool_t PathIsSpecifiedInFileName(const TString& fileName); [static utility function]. true if ""fileName""; 1. is an absolute path (""/tmp/a""); 2. is a relative path (""../whatever"", ""./test""); 3. starts with user name (""~/mail""); 4. starts with an environment variable (""$ROOTSYS/bin""). void NoMsg(Int_t errorLevel); [static utility function]. calling ""NoMsg( errorLevel )"",; sets ""gErrorIgnoreLevel"" to ""errorLevel+1"" so that; all errors with ""level < errorLevel"" will be ignored. calling the function with a negative argument; (e.g., ""NoMsg( -1 )""); resets gErrorIgnoreLevel to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char* appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char* dest, const char* localName, const char* appendage = 0, const char* fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char* defaultPath) const; [private]. TString ExtendPath(const char* originalPath, TString newBase) const; [private]. Int_t Hook(char* buf, int* pLoc, ostream& out); [private]. void InitPatterns(); [private]. TClass * MakeClassFromClassName(const char* className) const; [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a class.; user must delete.; returns 0 in case of error. T",MatchSource.WIKI,root/html534/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTabCom.html
https://root.cern/root/html534/TTabCom.html:10982,Availability,error,errorLevel,10982," [static utility function]. returns a colon-separated string of directories; that CINT will search when you call #include<...>. returns empty string on failure. Bool_t IsDirectory(const char* fileName); [static utility function]. calls TSystem::GetPathInfo() to see if ""fileName""; is a system directory. TSeqCollection * NewListOfFilesInPath(const char* path); [static utility function]. creates a list containing the full path name for each file; in the (colon separated) string ""path1"". memory is allocated with ""new"", so; whoever calls this function takes responsibility for deleting it. Bool_t PathIsSpecifiedInFileName(const TString& fileName); [static utility function]. true if ""fileName""; 1. is an absolute path (""/tmp/a""); 2. is a relative path (""../whatever"", ""./test""); 3. starts with user name (""~/mail""); 4. starts with an environment variable (""$ROOTSYS/bin""). void NoMsg(Int_t errorLevel); [static utility function]. calling ""NoMsg( errorLevel )"",; sets ""gErrorIgnoreLevel"" to ""errorLevel+1"" so that; all errors with ""level < errorLevel"" will be ignored. calling the function with a negative argument; (e.g., ""NoMsg( -1 )""); resets gErrorIgnoreLevel to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char* appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char* dest, const char* localName, const char* appendage = 0, const char* fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char* defaultPath) const; [private]. TString ExtendPath(const char* originalPath, TString newBase) const; [private]. Int_t Hook(char* buf, int* pLoc, ostream& out); [private]. void InitPatterns(); [private]. TClass * MakeClassFromClassName(const char* className) const; [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a class.; user must delete.; returns 0 in case of error. T",MatchSource.WIKI,root/html534/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTabCom.html
https://root.cern/root/html534/TTabCom.html:11009,Availability,error,errors,11009," [static utility function]. returns a colon-separated string of directories; that CINT will search when you call #include<...>. returns empty string on failure. Bool_t IsDirectory(const char* fileName); [static utility function]. calls TSystem::GetPathInfo() to see if ""fileName""; is a system directory. TSeqCollection * NewListOfFilesInPath(const char* path); [static utility function]. creates a list containing the full path name for each file; in the (colon separated) string ""path1"". memory is allocated with ""new"", so; whoever calls this function takes responsibility for deleting it. Bool_t PathIsSpecifiedInFileName(const TString& fileName); [static utility function]. true if ""fileName""; 1. is an absolute path (""/tmp/a""); 2. is a relative path (""../whatever"", ""./test""); 3. starts with user name (""~/mail""); 4. starts with an environment variable (""$ROOTSYS/bin""). void NoMsg(Int_t errorLevel); [static utility function]. calling ""NoMsg( errorLevel )"",; sets ""gErrorIgnoreLevel"" to ""errorLevel+1"" so that; all errors with ""level < errorLevel"" will be ignored. calling the function with a negative argument; (e.g., ""NoMsg( -1 )""); resets gErrorIgnoreLevel to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char* appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char* dest, const char* localName, const char* appendage = 0, const char* fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char* defaultPath) const; [private]. TString ExtendPath(const char* originalPath, TString newBase) const; [private]. Int_t Hook(char* buf, int* pLoc, ostream& out); [private]. void InitPatterns(); [private]. TClass * MakeClassFromClassName(const char* className) const; [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a class.; user must delete.; returns 0 in case of error. T",MatchSource.WIKI,root/html534/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTabCom.html
https://root.cern/root/html534/TTabCom.html:11030,Availability,error,errorLevel,11030," [static utility function]. returns a colon-separated string of directories; that CINT will search when you call #include<...>. returns empty string on failure. Bool_t IsDirectory(const char* fileName); [static utility function]. calls TSystem::GetPathInfo() to see if ""fileName""; is a system directory. TSeqCollection * NewListOfFilesInPath(const char* path); [static utility function]. creates a list containing the full path name for each file; in the (colon separated) string ""path1"". memory is allocated with ""new"", so; whoever calls this function takes responsibility for deleting it. Bool_t PathIsSpecifiedInFileName(const TString& fileName); [static utility function]. true if ""fileName""; 1. is an absolute path (""/tmp/a""); 2. is a relative path (""../whatever"", ""./test""); 3. starts with user name (""~/mail""); 4. starts with an environment variable (""$ROOTSYS/bin""). void NoMsg(Int_t errorLevel); [static utility function]. calling ""NoMsg( errorLevel )"",; sets ""gErrorIgnoreLevel"" to ""errorLevel+1"" so that; all errors with ""level < errorLevel"" will be ignored. calling the function with a negative argument; (e.g., ""NoMsg( -1 )""); resets gErrorIgnoreLevel to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char* appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char* dest, const char* localName, const char* appendage = 0, const char* fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char* defaultPath) const; [private]. TString ExtendPath(const char* originalPath, TString newBase) const; [private]. Int_t Hook(char* buf, int* pLoc, ostream& out); [private]. void InitPatterns(); [private]. TClass * MakeClassFromClassName(const char* className) const; [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a class.; user must delete.; returns 0 in case of error. T",MatchSource.WIKI,root/html534/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTabCom.html
https://root.cern/root/html534/TTabCom.html:11821,Availability,error,error,11821,"4. starts with an environment variable (""$ROOTSYS/bin""). void NoMsg(Int_t errorLevel); [static utility function]. calling ""NoMsg( errorLevel )"",; sets ""gErrorIgnoreLevel"" to ""errorLevel+1"" so that; all errors with ""level < errorLevel"" will be ignored. calling the function with a negative argument; (e.g., ""NoMsg( -1 )""); resets gErrorIgnoreLevel to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char* appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char* dest, const char* localName, const char* appendage = 0, const char* fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char* defaultPath) const; [private]. TString ExtendPath(const char* originalPath, TString newBase) const; [private]. Int_t Hook(char* buf, int* pLoc, ostream& out); [private]. void InitPatterns(); [private]. TClass * MakeClassFromClassName(const char* className) const; [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a class.; user must delete.; returns 0 in case of error. TClass * TryMakeClassFromClassName(const char* className) const; Same as above but does not print the error message. TClass * MakeClassFromVarName(const char* varName, TTabCom::EContext_t& context, int iter = 0); [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a variable.; user must delete.; returns 0 in case of error.; if user has operator.() or operator->() backwards, will modify: context, *fpLoc and fBuf.; context sensitive behavior. void SetPattern(TTabCom::EContext_t handle, const char* regexp); [private]. int ParseReverse(const char* var_str, int start). Returns the place in the string where to put the \0, starting the search; from ""start"". TTabCom(). TTabCom& operator=(const TTabCom& ). EContext_t DetermineCon",MatchSource.WIKI,root/html534/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTabCom.html
https://root.cern/root/html534/TTabCom.html:11981,Availability,error,error,11981,"evel"" to ""errorLevel+1"" so that; all errors with ""level < errorLevel"" will be ignored. calling the function with a negative argument; (e.g., ""NoMsg( -1 )""); resets gErrorIgnoreLevel to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char* appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char* dest, const char* localName, const char* appendage = 0, const char* fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char* defaultPath) const; [private]. TString ExtendPath(const char* originalPath, TString newBase) const; [private]. Int_t Hook(char* buf, int* pLoc, ostream& out); [private]. void InitPatterns(); [private]. TClass * MakeClassFromClassName(const char* className) const; [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a class.; user must delete.; returns 0 in case of error. TClass * TryMakeClassFromClassName(const char* className) const; Same as above but does not print the error message. TClass * MakeClassFromVarName(const char* varName, TTabCom::EContext_t& context, int iter = 0); [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a variable.; user must delete.; returns 0 in case of error.; if user has operator.() or operator->() backwards, will modify: context, *fpLoc and fBuf.; context sensitive behavior. void SetPattern(TTabCom::EContext_t handle, const char* regexp); [private]. int ParseReverse(const char* var_str, int start). Returns the place in the string where to put the \0, starting the search; from ""start"". TTabCom(). TTabCom& operator=(const TTabCom& ). EContext_t DetermineContext() const. » Author: Christian Lacunza 27/04/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/rint:$Id$ » Last generated: 2015-",MatchSource.WIKI,root/html534/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTabCom.html
https://root.cern/root/html534/TTabCom.html:12090,Availability,error,error,12090,"l be ignored. calling the function with a negative argument; (e.g., ""NoMsg( -1 )""); resets gErrorIgnoreLevel to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char* appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char* dest, const char* localName, const char* appendage = 0, const char* fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char* defaultPath) const; [private]. TString ExtendPath(const char* originalPath, TString newBase) const; [private]. Int_t Hook(char* buf, int* pLoc, ostream& out); [private]. void InitPatterns(); [private]. TClass * MakeClassFromClassName(const char* className) const; [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a class.; user must delete.; returns 0 in case of error. TClass * TryMakeClassFromClassName(const char* className) const; Same as above but does not print the error message. TClass * MakeClassFromVarName(const char* varName, TTabCom::EContext_t& context, int iter = 0); [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a variable.; user must delete.; returns 0 in case of error.; if user has operator.() or operator->() backwards, will modify: context, *fpLoc and fBuf.; context sensitive behavior. void SetPattern(TTabCom::EContext_t handle, const char* regexp); [private]. int ParseReverse(const char* var_str, int start). Returns the place in the string where to put the \0, starting the search; from ""start"". TTabCom(). TTabCom& operator=(const TTabCom& ). EContext_t DetermineContext() const. » Author: Christian Lacunza 27/04/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/rint:$Id$ » Last generated: 2015-03-14 16:50; This page has been automatically generated. For comments or ",MatchSource.WIKI,root/html534/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTabCom.html
https://root.cern/root/html534/TTabCom.html:12232,Availability,error,error,12232,"rIgnoreLevel to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char* appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char* dest, const char* localName, const char* appendage = 0, const char* fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char* defaultPath) const; [private]. TString ExtendPath(const char* originalPath, TString newBase) const; [private]. Int_t Hook(char* buf, int* pLoc, ostream& out); [private]. void InitPatterns(); [private]. TClass * MakeClassFromClassName(const char* className) const; [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a class.; user must delete.; returns 0 in case of error. TClass * TryMakeClassFromClassName(const char* className) const; Same as above but does not print the error message. TClass * MakeClassFromVarName(const char* varName, TTabCom::EContext_t& context, int iter = 0); [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a variable.; user must delete.; returns 0 in case of error.; if user has operator.() or operator->() backwards, will modify: context, *fpLoc and fBuf.; context sensitive behavior. void SetPattern(TTabCom::EContext_t handle, const char* regexp); [private]. int ParseReverse(const char* var_str, int start). Returns the place in the string where to put the \0, starting the search; from ""start"". TTabCom(). TTabCom& operator=(const TTabCom& ). EContext_t DetermineContext() const. » Author: Christian Lacunza 27/04/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/rint:$Id$ » Last generated: 2015-03-14 16:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTabCom.html
https://root.cern/root/html534/TTabCom.html:12395,Availability,error,error,12395,"rIgnoreLevel to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char* appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char* dest, const char* localName, const char* appendage = 0, const char* fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char* defaultPath) const; [private]. TString ExtendPath(const char* originalPath, TString newBase) const; [private]. Int_t Hook(char* buf, int* pLoc, ostream& out); [private]. void InitPatterns(); [private]. TClass * MakeClassFromClassName(const char* className) const; [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a class.; user must delete.; returns 0 in case of error. TClass * TryMakeClassFromClassName(const char* className) const; Same as above but does not print the error message. TClass * MakeClassFromVarName(const char* varName, TTabCom::EContext_t& context, int iter = 0); [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a variable.; user must delete.; returns 0 in case of error.; if user has operator.() or operator->() backwards, will modify: context, *fpLoc and fBuf.; context sensitive behavior. void SetPattern(TTabCom::EContext_t handle, const char* regexp); [private]. int ParseReverse(const char* var_str, int start). Returns the place in the string where to put the \0, starting the search; from ""start"". TTabCom(). TTabCom& operator=(const TTabCom& ). EContext_t DetermineContext() const. » Author: Christian Lacunza 27/04/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/rint:$Id$ » Last generated: 2015-03-14 16:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTabCom.html
https://root.cern/root/html534/TTabCom.html:10488,Energy Efficiency,allocate,allocated,10488," do not exist are silently ignored. TString DetermineClass(const char* varName); [static utility function]. returns empty string on failure.; otherwise returns something like this: ""TROOT*"".; fails for non-class types (ie, int, char, etc).; fails for pointers to functions. Bool_t ExcludedByFignore(TString s); [static utility function]. returns true iff ""s"" ends with one of; the strings listed in the ""TabCom.FileIgnore"" resource. TString GetSysIncludePath(); [static utility function]. returns a colon-separated string of directories; that CINT will search when you call #include<...>. returns empty string on failure. Bool_t IsDirectory(const char* fileName); [static utility function]. calls TSystem::GetPathInfo() to see if ""fileName""; is a system directory. TSeqCollection * NewListOfFilesInPath(const char* path); [static utility function]. creates a list containing the full path name for each file; in the (colon separated) string ""path1"". memory is allocated with ""new"", so; whoever calls this function takes responsibility for deleting it. Bool_t PathIsSpecifiedInFileName(const TString& fileName); [static utility function]. true if ""fileName""; 1. is an absolute path (""/tmp/a""); 2. is a relative path (""../whatever"", ""./test""); 3. starts with user name (""~/mail""); 4. starts with an environment variable (""$ROOTSYS/bin""). void NoMsg(Int_t errorLevel); [static utility function]. calling ""NoMsg( errorLevel )"",; sets ""gErrorIgnoreLevel"" to ""errorLevel+1"" so that; all errors with ""level < errorLevel"" will be ignored. calling the function with a negative argument; (e.g., ""NoMsg( -1 )""); resets gErrorIgnoreLevel to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char* appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char* dest, const char* localName, const char* appendage = 0, const char* fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char* de",MatchSource.WIKI,root/html534/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTabCom.html
https://root.cern/root/html534/TTabCom.html:2665,Integrability,message,message,2665,"complete a member of a global object). 7. the list of #pragma's is hardcoded; (ie not obtained from the interpreter at runtime); ==> user-defined #pragma's will not be recognized. 8. the system include directories are also hardcoded; because i don't know how to get them from the interpreter.; fons, maybe they should be #ifdef'd for the different sytems?. 9. the TabCom.FileIgnore resource is always applied, even if you; are not trying to complete a filename. 10. anything in quotes is assumed to be a filename; so (among other things) you can't complete a quoted class name:; eg, TClass class1( ""TDict[TAB] //; this won't work... looks for a file in pwd starting with TDict. 11. the prototypes tend to omit the word ""const"" a lot.; this is a problem with ROOT or CINT. 12. when listing ambiguous matches, only one column is used,; even if there are many completions. 13. anonymous objects are not currently identified; so, for example,. root> printf( TString([TAB. gives an error message instead of listing TString's constructors.; (this could be fixed). 14. the routine that adds the ""appendage"" isn't smart enough to know; if it's already there:. root> TCanvas::Update(); press [TAB] here ^; root> TCanvas::Update()(); (this could be fixed). 15. the appendage is only applied if there is exactly 1 match.; eg, this. root> G__at[TAB]; root> G__ateval. happens instead of this. root> G__at[TAB]; root> G__ateval(. because there are several overloaded versions of G__ateval().; (this could be fixed). Function Members (Methods); public:. TTabCom(); virtual~TTabCom(); static Char_tAllAgreeOnChar(int i, const TSeqCollection* pList, Int_t& nGoodStrings); static voidAppendListOfFilesInDirectory(const char* dirName, TSeqCollection* pList); static TClass*Class(); voidClearAll(); voidClearClasses(); voidClearCppDirectives(); voidClearEnvVars(); voidClearFiles(); voidClearGlobalFunctions(); voidClearGlobals(); voidClearPragmas(); voidClearSysIncFiles(); voidClearUsers(); static TStringDetermineCla",MatchSource.WIKI,root/html534/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTabCom.html
https://root.cern/root/html534/TTabCom.html:2748,Integrability,rout,routine,2748,"terpreter at runtime); ==> user-defined #pragma's will not be recognized. 8. the system include directories are also hardcoded; because i don't know how to get them from the interpreter.; fons, maybe they should be #ifdef'd for the different sytems?. 9. the TabCom.FileIgnore resource is always applied, even if you; are not trying to complete a filename. 10. anything in quotes is assumed to be a filename; so (among other things) you can't complete a quoted class name:; eg, TClass class1( ""TDict[TAB] //; this won't work... looks for a file in pwd starting with TDict. 11. the prototypes tend to omit the word ""const"" a lot.; this is a problem with ROOT or CINT. 12. when listing ambiguous matches, only one column is used,; even if there are many completions. 13. anonymous objects are not currently identified; so, for example,. root> printf( TString([TAB. gives an error message instead of listing TString's constructors.; (this could be fixed). 14. the routine that adds the ""appendage"" isn't smart enough to know; if it's already there:. root> TCanvas::Update(); press [TAB] here ^; root> TCanvas::Update()(); (this could be fixed). 15. the appendage is only applied if there is exactly 1 match.; eg, this. root> G__at[TAB]; root> G__ateval. happens instead of this. root> G__at[TAB]; root> G__ateval(. because there are several overloaded versions of G__ateval().; (this could be fixed). Function Members (Methods); public:. TTabCom(); virtual~TTabCom(); static Char_tAllAgreeOnChar(int i, const TSeqCollection* pList, Int_t& nGoodStrings); static voidAppendListOfFilesInDirectory(const char* dirName, TSeqCollection* pList); static TClass*Class(); voidClearAll(); voidClearClasses(); voidClearCppDirectives(); voidClearEnvVars(); voidClearFiles(); voidClearGlobalFunctions(); voidClearGlobals(); voidClearPragmas(); voidClearSysIncFiles(); voidClearUsers(); static TStringDetermineClass(const char* varName); static Bool_tExcludedByFignore(TString s); const TSeqCollection*GetListOfClasses(",MatchSource.WIKI,root/html534/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTabCom.html
https://root.cern/root/html534/TTabCom.html:12096,Integrability,message,message,12096,"l be ignored. calling the function with a negative argument; (e.g., ""NoMsg( -1 )""); resets gErrorIgnoreLevel to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char* appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char* dest, const char* localName, const char* appendage = 0, const char* fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char* defaultPath) const; [private]. TString ExtendPath(const char* originalPath, TString newBase) const; [private]. Int_t Hook(char* buf, int* pLoc, ostream& out); [private]. void InitPatterns(); [private]. TClass * MakeClassFromClassName(const char* className) const; [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a class.; user must delete.; returns 0 in case of error. TClass * TryMakeClassFromClassName(const char* className) const; Same as above but does not print the error message. TClass * MakeClassFromVarName(const char* varName, TTabCom::EContext_t& context, int iter = 0); [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a variable.; user must delete.; returns 0 in case of error.; if user has operator.() or operator->() backwards, will modify: context, *fpLoc and fBuf.; context sensitive behavior. void SetPattern(TTabCom::EContext_t handle, const char* regexp); [private]. int ParseReverse(const char* var_str, int start). Returns the place in the string where to put the \0, starting the search; from ""start"". TTabCom(). TTabCom& operator=(const TTabCom& ). EContext_t DetermineContext() const. » Author: Christian Lacunza 27/04/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/rint:$Id$ » Last generated: 2015-03-14 16:50; This page has been automatically generated. For comments or ",MatchSource.WIKI,root/html534/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTabCom.html
https://root.cern/root/html534/TTabCom.html:404,Modifiability,variab,variable,404,". TTabCom. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » RINT; » TTabCom. class TTabCom. TTabCom. This class performs basic tab completion.; You should be able to hit [TAB] to complete a partially typed:. username; environment variable; preprocessor directive; pragma; filename (with a context-sensitive path); public member function or data member (including base classes); global variable, function, or class name. Also, something like. someObject->Func([TAB]; someObject.Func([TAB]; someClass::Func([TAB]; someClass var([TAB]; new someClass([TAB]. will print a list of prototypes for the indicated; method or constructor. Current limitations and bugs:. 1. you can only use one member access operator at a time.; eg, this will work: gROOT->GetListOfG[TAB]; but this will not: gROOT->GetListOfGlobals()->Conta[TAB]. 2. nothing is guaranteed to work on windows; (for one thing, /bin/env and /etc/passwd are hardcoded). 3. CINT shortcut #2 is deliberately not supported.; (using ""operator.()"" instead of ""operator->()""). 4. most identifiers (including C++ identifiers, usernames,; environment variables, etc); are restriceted to this character set: [_a-zA-Z0-9]; therefore, you won't be able to complete things like. operator new; operator+; etc. 5. ~whatever[TAB] always tries to complete a username.; use whitespace (~ whatever[TAB]) if you want to complete a global; identifier. 6. CINT shortcut #3 is not supported when trying to complete; the name of a global object. (it is supported when trying to; complete a member of a global object). 7. the list of #pragma's is hardcoded; (ie not obtained from the interpreter at runtime); ==> user-defined #pragma's will not be recognized. 8. the system include directories are also hardcoded; because i don't know how to get them from the interpreter.; fons, maybe they should b",MatchSource.WIKI,root/html534/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTabCom.html
https://root.cern/root/html534/TTabCom.html:559,Modifiability,variab,variable,559,". TTabCom. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » RINT; » TTabCom. class TTabCom. TTabCom. This class performs basic tab completion.; You should be able to hit [TAB] to complete a partially typed:. username; environment variable; preprocessor directive; pragma; filename (with a context-sensitive path); public member function or data member (including base classes); global variable, function, or class name. Also, something like. someObject->Func([TAB]; someObject.Func([TAB]; someClass::Func([TAB]; someClass var([TAB]; new someClass([TAB]. will print a list of prototypes for the indicated; method or constructor. Current limitations and bugs:. 1. you can only use one member access operator at a time.; eg, this will work: gROOT->GetListOfG[TAB]; but this will not: gROOT->GetListOfGlobals()->Conta[TAB]. 2. nothing is guaranteed to work on windows; (for one thing, /bin/env and /etc/passwd are hardcoded). 3. CINT shortcut #2 is deliberately not supported.; (using ""operator.()"" instead of ""operator->()""). 4. most identifiers (including C++ identifiers, usernames,; environment variables, etc); are restriceted to this character set: [_a-zA-Z0-9]; therefore, you won't be able to complete things like. operator new; operator+; etc. 5. ~whatever[TAB] always tries to complete a username.; use whitespace (~ whatever[TAB]) if you want to complete a global; identifier. 6. CINT shortcut #3 is not supported when trying to complete; the name of a global object. (it is supported when trying to; complete a member of a global object). 7. the list of #pragma's is hardcoded; (ie not obtained from the interpreter at runtime); ==> user-defined #pragma's will not be recognized. 8. the system include directories are also hardcoded; because i don't know how to get them from the interpreter.; fons, maybe they should b",MatchSource.WIKI,root/html534/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTabCom.html
https://root.cern/root/html534/TTabCom.html:1269,Modifiability,variab,variables,1269,"basic tab completion.; You should be able to hit [TAB] to complete a partially typed:. username; environment variable; preprocessor directive; pragma; filename (with a context-sensitive path); public member function or data member (including base classes); global variable, function, or class name. Also, something like. someObject->Func([TAB]; someObject.Func([TAB]; someClass::Func([TAB]; someClass var([TAB]; new someClass([TAB]. will print a list of prototypes for the indicated; method or constructor. Current limitations and bugs:. 1. you can only use one member access operator at a time.; eg, this will work: gROOT->GetListOfG[TAB]; but this will not: gROOT->GetListOfGlobals()->Conta[TAB]. 2. nothing is guaranteed to work on windows; (for one thing, /bin/env and /etc/passwd are hardcoded). 3. CINT shortcut #2 is deliberately not supported.; (using ""operator.()"" instead of ""operator->()""). 4. most identifiers (including C++ identifiers, usernames,; environment variables, etc); are restriceted to this character set: [_a-zA-Z0-9]; therefore, you won't be able to complete things like. operator new; operator+; etc. 5. ~whatever[TAB] always tries to complete a username.; use whitespace (~ whatever[TAB]) if you want to complete a global; identifier. 6. CINT shortcut #3 is not supported when trying to complete; the name of a global object. (it is supported when trying to; complete a member of a global object). 7. the list of #pragma's is hardcoded; (ie not obtained from the interpreter at runtime); ==> user-defined #pragma's will not be recognized. 8. the system include directories are also hardcoded; because i don't know how to get them from the interpreter.; fons, maybe they should be #ifdef'd for the different sytems?. 9. the TabCom.FileIgnore resource is always applied, even if you; are not trying to complete a filename. 10. anything in quotes is assumed to be a filename; so (among other things) you can't complete a quoted class name:; eg, TClass class1( ""TDict[TAB] //; ",MatchSource.WIKI,root/html534/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTabCom.html
https://root.cern/root/html534/TTabCom.html:7139,Modifiability,variab,variables,7139,IndirectMember; kCXX_Global; kCXX_GlobalProto; kNUM_PAT; };. private:. char*fBufinitialized by Hook(); Int_tfLastIterfrodo: iteration counter for recursive MakeClassFromVarName; unsigned shortfPat[25][1024]array of patterns; const char*fRegExp[25]corresponding regular expression plain text; Bool_tfVarIsPointerfrodo: pointer or not flag; TSeqCollection*fpClasses; TSeqCollection*fpDirectives; TSeqCollection*fpEnvVars; TSeqCollection*fpFiles; TSeqCollection*fpGlobalFuncs; TSeqCollection*fpGlobals; int*fpLocinitialized by Hook(); TSeqCollection*fpNamespacesContains the names of namespaces registered in CINT.; TSeqCollection*fpPragmas; TSeqCollection*fpSysIncFiles; TSeqCollection*fpUsers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTabCom(); Default constructor. ~TTabCom(); Destructor. void ClearClasses(); Clear classes and namespace collections. void ClearCppDirectives(); Forget all Cpp directives seen so far. void ClearEnvVars(); Forget all environment variables seen so far. void ClearFiles(); Close all files. void ClearGlobalFunctions(); Forget all global functions seen so far. void ClearGlobals(); Forget all global variables seen so far. void ClearPragmas(); Forget all pragmas seen so far. void ClearSysIncFiles(); Close system files. void ClearUsers(); Forget all user seen so far. void ClearAll(); clears all lists; except for user names and system include files. void RehashClasses(); Do the class rehash. void RehashCppDirectives(); Cpp rehashing. void RehashEnvVars(); Environemnt variables rehashing. void RehashFiles(); Close files. void RehashGlobalFunctions(); Reload global functions. void RehashGlobals(); Reload globals. void RehashPragmas(); Reload pragmas. void RehashSysIncFiles(); Reload system include files. void RehashUsers(); Reload users. void RehashAll(); clears and then rebuilds all lists; except for user names and system include files. const TSeqCollection * GetListOfClasses(); Return the list of classes. co,MatchSource.WIKI,root/html534/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTabCom.html
https://root.cern/root/html534/TTabCom.html:7307,Modifiability,variab,variables,7307,"rName; unsigned shortfPat[25][1024]array of patterns; const char*fRegExp[25]corresponding regular expression plain text; Bool_tfVarIsPointerfrodo: pointer or not flag; TSeqCollection*fpClasses; TSeqCollection*fpDirectives; TSeqCollection*fpEnvVars; TSeqCollection*fpFiles; TSeqCollection*fpGlobalFuncs; TSeqCollection*fpGlobals; int*fpLocinitialized by Hook(); TSeqCollection*fpNamespacesContains the names of namespaces registered in CINT.; TSeqCollection*fpPragmas; TSeqCollection*fpSysIncFiles; TSeqCollection*fpUsers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTabCom(); Default constructor. ~TTabCom(); Destructor. void ClearClasses(); Clear classes and namespace collections. void ClearCppDirectives(); Forget all Cpp directives seen so far. void ClearEnvVars(); Forget all environment variables seen so far. void ClearFiles(); Close all files. void ClearGlobalFunctions(); Forget all global functions seen so far. void ClearGlobals(); Forget all global variables seen so far. void ClearPragmas(); Forget all pragmas seen so far. void ClearSysIncFiles(); Close system files. void ClearUsers(); Forget all user seen so far. void ClearAll(); clears all lists; except for user names and system include files. void RehashClasses(); Do the class rehash. void RehashCppDirectives(); Cpp rehashing. void RehashEnvVars(); Environemnt variables rehashing. void RehashFiles(); Close files. void RehashGlobalFunctions(); Reload global functions. void RehashGlobals(); Reload globals. void RehashPragmas(); Reload pragmas. void RehashSysIncFiles(); Reload system include files. void RehashUsers(); Reload users. void RehashAll(); clears and then rebuilds all lists; except for user names and system include files. const TSeqCollection * GetListOfClasses(); Return the list of classes. const TSeqCollection * GetListOfCppDirectives(); Return the list of CPP directives. const TSeqCollection * GetListOfFilesInPath(const char* path); ""path"" should be initiali",MatchSource.WIKI,root/html534/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTabCom.html
https://root.cern/root/html534/TTabCom.html:7679,Modifiability,variab,variables,7679,"on*fpNamespacesContains the names of namespaces registered in CINT.; TSeqCollection*fpPragmas; TSeqCollection*fpSysIncFiles; TSeqCollection*fpUsers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTabCom(); Default constructor. ~TTabCom(); Destructor. void ClearClasses(); Clear classes and namespace collections. void ClearCppDirectives(); Forget all Cpp directives seen so far. void ClearEnvVars(); Forget all environment variables seen so far. void ClearFiles(); Close all files. void ClearGlobalFunctions(); Forget all global functions seen so far. void ClearGlobals(); Forget all global variables seen so far. void ClearPragmas(); Forget all pragmas seen so far. void ClearSysIncFiles(); Close system files. void ClearUsers(); Forget all user seen so far. void ClearAll(); clears all lists; except for user names and system include files. void RehashClasses(); Do the class rehash. void RehashCppDirectives(); Cpp rehashing. void RehashEnvVars(); Environemnt variables rehashing. void RehashFiles(); Close files. void RehashGlobalFunctions(); Reload global functions. void RehashGlobals(); Reload globals. void RehashPragmas(); Reload pragmas. void RehashSysIncFiles(); Reload system include files. void RehashUsers(); Reload users. void RehashAll(); clears and then rebuilds all lists; except for user names and system include files. const TSeqCollection * GetListOfClasses(); Return the list of classes. const TSeqCollection * GetListOfCppDirectives(); Return the list of CPP directives. const TSeqCollection * GetListOfFilesInPath(const char* path); ""path"" should be initialized with a colon separated list of; system directories. const TSeqCollection * GetListOfEnvVars(); Uses ""env"" (Unix) or ""set"" (Windows) to get list of environment variables. const TSeqCollection * GetListOfGlobals(); Return the list of globals. const TSeqCollection * GetListOfGlobalFunctions(); Return the list of global functions. const TSeqCollection * GetListOfPragmas()",MatchSource.WIKI,root/html534/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTabCom.html
https://root.cern/root/html534/TTabCom.html:8461,Modifiability,variab,variables,8461,"e system files. void ClearUsers(); Forget all user seen so far. void ClearAll(); clears all lists; except for user names and system include files. void RehashClasses(); Do the class rehash. void RehashCppDirectives(); Cpp rehashing. void RehashEnvVars(); Environemnt variables rehashing. void RehashFiles(); Close files. void RehashGlobalFunctions(); Reload global functions. void RehashGlobals(); Reload globals. void RehashPragmas(); Reload pragmas. void RehashSysIncFiles(); Reload system include files. void RehashUsers(); Reload users. void RehashAll(); clears and then rebuilds all lists; except for user names and system include files. const TSeqCollection * GetListOfClasses(); Return the list of classes. const TSeqCollection * GetListOfCppDirectives(); Return the list of CPP directives. const TSeqCollection * GetListOfFilesInPath(const char* path); ""path"" should be initialized with a colon separated list of; system directories. const TSeqCollection * GetListOfEnvVars(); Uses ""env"" (Unix) or ""set"" (Windows) to get list of environment variables. const TSeqCollection * GetListOfGlobals(); Return the list of globals. const TSeqCollection * GetListOfGlobalFunctions(); Return the list of global functions. const TSeqCollection * GetListOfPragmas(); Return the list of pragmas. const TSeqCollection * GetListOfSysIncFiles(); Return the list of system include files. const TSeqCollection * GetListOfUsers(); reads from ""/etc/passwd"". Char_t AllAgreeOnChar(int i, const TSeqCollection* pList, Int_t& nGoodStrings); [static utility function]. if all the strings in ""*pList"" have the same ith character,; that character is returned.; otherwise 0 is returned. any string ""s"" for which ""ExcludedByFignore(s)"" is true; will be ignored unless All the strings in ""*pList""; are ""ExcludedByFignore()"". in addition, the number of strings which were not; ""ExcludedByFignore()"" is returned in ""nGoodStrings"". void AppendListOfFilesInDirectory(const char* dirName, TSeqCollection* pList); [static utilit",MatchSource.WIKI,root/html534/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTabCom.html
https://root.cern/root/html534/TTabCom.html:10837,Modifiability,variab,variable,10837,"); [static utility function]. returns true iff ""s"" ends with one of; the strings listed in the ""TabCom.FileIgnore"" resource. TString GetSysIncludePath(); [static utility function]. returns a colon-separated string of directories; that CINT will search when you call #include<...>. returns empty string on failure. Bool_t IsDirectory(const char* fileName); [static utility function]. calls TSystem::GetPathInfo() to see if ""fileName""; is a system directory. TSeqCollection * NewListOfFilesInPath(const char* path); [static utility function]. creates a list containing the full path name for each file; in the (colon separated) string ""path1"". memory is allocated with ""new"", so; whoever calls this function takes responsibility for deleting it. Bool_t PathIsSpecifiedInFileName(const TString& fileName); [static utility function]. true if ""fileName""; 1. is an absolute path (""/tmp/a""); 2. is a relative path (""../whatever"", ""./test""); 3. starts with user name (""~/mail""); 4. starts with an environment variable (""$ROOTSYS/bin""). void NoMsg(Int_t errorLevel); [static utility function]. calling ""NoMsg( errorLevel )"",; sets ""gErrorIgnoreLevel"" to ""errorLevel+1"" so that; all errors with ""level < errorLevel"" will be ignored. calling the function with a negative argument; (e.g., ""NoMsg( -1 )""); resets gErrorIgnoreLevel to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char* appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char* dest, const char* localName, const char* appendage = 0, const char* fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char* defaultPath) const; [private]. TString ExtendPath(const char* originalPath, TString newBase) const; [private]. Int_t Hook(char* buf, int* pLoc, ostream& out); [private]. void InitPatterns(); [private]. TClass * MakeClassFromClassName(const char* className) const; [private]; (does some specific error handling ",MatchSource.WIKI,root/html534/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTabCom.html
https://root.cern/root/html534/TTabCom.html:12344,Modifiability,variab,variable,12344,"rIgnoreLevel to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char* appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char* dest, const char* localName, const char* appendage = 0, const char* fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char* defaultPath) const; [private]. TString ExtendPath(const char* originalPath, TString newBase) const; [private]. Int_t Hook(char* buf, int* pLoc, ostream& out); [private]. void InitPatterns(); [private]. TClass * MakeClassFromClassName(const char* className) const; [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a class.; user must delete.; returns 0 in case of error. TClass * TryMakeClassFromClassName(const char* className) const; Same as above but does not print the error message. TClass * MakeClassFromVarName(const char* varName, TTabCom::EContext_t& context, int iter = 0); [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a variable.; user must delete.; returns 0 in case of error.; if user has operator.() or operator->() backwards, will modify: context, *fpLoc and fBuf.; context sensitive behavior. void SetPattern(TTabCom::EContext_t handle, const char* regexp); [private]. int ParseReverse(const char* var_str, int start). Returns the place in the string where to put the \0, starting the search; from ""start"". TTabCom(). TTabCom& operator=(const TTabCom& ). EContext_t DetermineContext() const. » Author: Christian Lacunza 27/04/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/rint:$Id$ » Last generated: 2015-03-14 16:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTabCom.html
https://root.cern/root/html534/TTabCom.html:286,Performance,perform,performs,286,". TTabCom. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » RINT; » TTabCom. class TTabCom. TTabCom. This class performs basic tab completion.; You should be able to hit [TAB] to complete a partially typed:. username; environment variable; preprocessor directive; pragma; filename (with a context-sensitive path); public member function or data member (including base classes); global variable, function, or class name. Also, something like. someObject->Func([TAB]; someObject.Func([TAB]; someClass::Func([TAB]; someClass var([TAB]; new someClass([TAB]. will print a list of prototypes for the indicated; method or constructor. Current limitations and bugs:. 1. you can only use one member access operator at a time.; eg, this will work: gROOT->GetListOfG[TAB]; but this will not: gROOT->GetListOfGlobals()->Conta[TAB]. 2. nothing is guaranteed to work on windows; (for one thing, /bin/env and /etc/passwd are hardcoded). 3. CINT shortcut #2 is deliberately not supported.; (using ""operator.()"" instead of ""operator->()""). 4. most identifiers (including C++ identifiers, usernames,; environment variables, etc); are restriceted to this character set: [_a-zA-Z0-9]; therefore, you won't be able to complete things like. operator new; operator+; etc. 5. ~whatever[TAB] always tries to complete a username.; use whitespace (~ whatever[TAB]) if you want to complete a global; identifier. 6. CINT shortcut #3 is not supported when trying to complete; the name of a global object. (it is supported when trying to; complete a member of a global object). 7. the list of #pragma's is hardcoded; (ie not obtained from the interpreter at runtime); ==> user-defined #pragma's will not be recognized. 8. the system include directories are also hardcoded; because i don't know how to get them from the interpreter.; fons, maybe they should b",MatchSource.WIKI,root/html534/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTabCom.html
https://root.cern/root/html534/TTabCom.html:864,Security,access,access,864,". TTabCom. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » RINT; » TTabCom. class TTabCom. TTabCom. This class performs basic tab completion.; You should be able to hit [TAB] to complete a partially typed:. username; environment variable; preprocessor directive; pragma; filename (with a context-sensitive path); public member function or data member (including base classes); global variable, function, or class name. Also, something like. someObject->Func([TAB]; someObject.Func([TAB]; someClass::Func([TAB]; someClass var([TAB]; new someClass([TAB]. will print a list of prototypes for the indicated; method or constructor. Current limitations and bugs:. 1. you can only use one member access operator at a time.; eg, this will work: gROOT->GetListOfG[TAB]; but this will not: gROOT->GetListOfGlobals()->Conta[TAB]. 2. nothing is guaranteed to work on windows; (for one thing, /bin/env and /etc/passwd are hardcoded). 3. CINT shortcut #2 is deliberately not supported.; (using ""operator.()"" instead of ""operator->()""). 4. most identifiers (including C++ identifiers, usernames,; environment variables, etc); are restriceted to this character set: [_a-zA-Z0-9]; therefore, you won't be able to complete things like. operator new; operator+; etc. 5. ~whatever[TAB] always tries to complete a username.; use whitespace (~ whatever[TAB]) if you want to complete a global; identifier. 6. CINT shortcut #3 is not supported when trying to complete; the name of a global object. (it is supported when trying to; complete a member of a global object). 7. the list of #pragma's is hardcoded; (ie not obtained from the interpreter at runtime); ==> user-defined #pragma's will not be recognized. 8. the system include directories are also hardcoded; because i don't know how to get them from the interpreter.; fons, maybe they should b",MatchSource.WIKI,root/html534/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTabCom.html
https://root.cern/root/html534/TTabCom.html:10762,Testability,test,test,10762,".; fails for pointers to functions. Bool_t ExcludedByFignore(TString s); [static utility function]. returns true iff ""s"" ends with one of; the strings listed in the ""TabCom.FileIgnore"" resource. TString GetSysIncludePath(); [static utility function]. returns a colon-separated string of directories; that CINT will search when you call #include<...>. returns empty string on failure. Bool_t IsDirectory(const char* fileName); [static utility function]. calls TSystem::GetPathInfo() to see if ""fileName""; is a system directory. TSeqCollection * NewListOfFilesInPath(const char* path); [static utility function]. creates a list containing the full path name for each file; in the (colon separated) string ""path1"". memory is allocated with ""new"", so; whoever calls this function takes responsibility for deleting it. Bool_t PathIsSpecifiedInFileName(const TString& fileName); [static utility function]. true if ""fileName""; 1. is an absolute path (""/tmp/a""); 2. is a relative path (""../whatever"", ""./test""); 3. starts with user name (""~/mail""); 4. starts with an environment variable (""$ROOTSYS/bin""). void NoMsg(Int_t errorLevel); [static utility function]. calling ""NoMsg( errorLevel )"",; sets ""gErrorIgnoreLevel"" to ""errorLevel+1"" so that; all errors with ""level < errorLevel"" will be ignored. calling the function with a negative argument; (e.g., ""NoMsg( -1 )""); resets gErrorIgnoreLevel to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char* appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char* dest, const char* localName, const char* appendage = 0, const char* fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char* defaultPath) const; [private]. TString ExtendPath(const char* originalPath, TString newBase) const; [private]. Int_t Hook(char* buf, int* pLoc, ostream& out); [private]. void InitPatterns(); [private]. TClass * MakeClassFromClassName(const c",MatchSource.WIKI,root/html534/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTabCom.html
https://root.cern/root/html534/TTabCom.html:7493,Usability,clear,clears,7493,"ves; TSeqCollection*fpEnvVars; TSeqCollection*fpFiles; TSeqCollection*fpGlobalFuncs; TSeqCollection*fpGlobals; int*fpLocinitialized by Hook(); TSeqCollection*fpNamespacesContains the names of namespaces registered in CINT.; TSeqCollection*fpPragmas; TSeqCollection*fpSysIncFiles; TSeqCollection*fpUsers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTabCom(); Default constructor. ~TTabCom(); Destructor. void ClearClasses(); Clear classes and namespace collections. void ClearCppDirectives(); Forget all Cpp directives seen so far. void ClearEnvVars(); Forget all environment variables seen so far. void ClearFiles(); Close all files. void ClearGlobalFunctions(); Forget all global functions seen so far. void ClearGlobals(); Forget all global variables seen so far. void ClearPragmas(); Forget all pragmas seen so far. void ClearSysIncFiles(); Close system files. void ClearUsers(); Forget all user seen so far. void ClearAll(); clears all lists; except for user names and system include files. void RehashClasses(); Do the class rehash. void RehashCppDirectives(); Cpp rehashing. void RehashEnvVars(); Environemnt variables rehashing. void RehashFiles(); Close files. void RehashGlobalFunctions(); Reload global functions. void RehashGlobals(); Reload globals. void RehashPragmas(); Reload pragmas. void RehashSysIncFiles(); Reload system include files. void RehashUsers(); Reload users. void RehashAll(); clears and then rebuilds all lists; except for user names and system include files. const TSeqCollection * GetListOfClasses(); Return the list of classes. const TSeqCollection * GetListOfCppDirectives(); Return the list of CPP directives. const TSeqCollection * GetListOfFilesInPath(const char* path); ""path"" should be initialized with a colon separated list of; system directories. const TSeqCollection * GetListOfEnvVars(); Uses ""env"" (Unix) or ""set"" (Windows) to get list of environment variables. const TSeqCollection * GetListOfGlobals(); Re",MatchSource.WIKI,root/html534/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTabCom.html
https://root.cern/root/html534/TTabCom.html:7971,Usability,clear,clears,7971,"nd namespace collections. void ClearCppDirectives(); Forget all Cpp directives seen so far. void ClearEnvVars(); Forget all environment variables seen so far. void ClearFiles(); Close all files. void ClearGlobalFunctions(); Forget all global functions seen so far. void ClearGlobals(); Forget all global variables seen so far. void ClearPragmas(); Forget all pragmas seen so far. void ClearSysIncFiles(); Close system files. void ClearUsers(); Forget all user seen so far. void ClearAll(); clears all lists; except for user names and system include files. void RehashClasses(); Do the class rehash. void RehashCppDirectives(); Cpp rehashing. void RehashEnvVars(); Environemnt variables rehashing. void RehashFiles(); Close files. void RehashGlobalFunctions(); Reload global functions. void RehashGlobals(); Reload globals. void RehashPragmas(); Reload pragmas. void RehashSysIncFiles(); Reload system include files. void RehashUsers(); Reload users. void RehashAll(); clears and then rebuilds all lists; except for user names and system include files. const TSeqCollection * GetListOfClasses(); Return the list of classes. const TSeqCollection * GetListOfCppDirectives(); Return the list of CPP directives. const TSeqCollection * GetListOfFilesInPath(const char* path); ""path"" should be initialized with a colon separated list of; system directories. const TSeqCollection * GetListOfEnvVars(); Uses ""env"" (Unix) or ""set"" (Windows) to get list of environment variables. const TSeqCollection * GetListOfGlobals(); Return the list of globals. const TSeqCollection * GetListOfGlobalFunctions(); Return the list of global functions. const TSeqCollection * GetListOfPragmas(); Return the list of pragmas. const TSeqCollection * GetListOfSysIncFiles(); Return the list of system include files. const TSeqCollection * GetListOfUsers(); reads from ""/etc/passwd"". Char_t AllAgreeOnChar(int i, const TSeqCollection* pList, Int_t& nGoodStrings); [static utility function]. if all the strings in ""*pList"" have the",MatchSource.WIKI,root/html534/TTabCom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTabCom.html
https://root.cern/root/html534/TTable.html:6852,Availability,error,error,6852,"newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tCopyRows(const TTable* srcTable, Long_t srcRow = 0, Long_t dstRow = 0, Long_t nRows = 0, Bool_t expand = kFALSE); virtual voidCopySet(TTable& array); virtual voidDeleteRows(Long_t indx, UInt_t nRows = 1); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual TH1*Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual voidFit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; void*GetArray() const; virtua",MatchSource.WIKI,root/html534/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTable.html
https://root.cern/root/html534/TTable.html:6936,Availability,error,error,6936," voidTNamed::Copy(TObject& named) const; Int_tCopyRows(const TTable* srcTable, Long_t srcRow = 0, Long_t dstRow = 0, Long_t nRows = 0, Bool_t expand = kFALSE); virtual voidCopySet(TTable& array); virtual voidDeleteRows(Long_t indx, UInt_t nRows = 1); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual TH1*Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual voidFit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; void*GetArray() const; virtual TSeqCollection*TDataSet::GetCollection() const; virtual const Char_t*GetColumnComm",MatchSource.WIKI,root/html534/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTable.html
https://root.cern/root/html534/TTable.html:26305,Availability,down,down,26305," row index the ""row"" has occupied. row == 0 see method TTable::AddAt(const void *row, Int_t i). void AddAt(const void* c, Int_t i); Add one element (""row"") of structure at position ""i"".; Check for out of bounds. If the row == 0 the ""i"" cell is still occupied and; filled with the pattern ""ff"". void CopyStruct(Char_t* dest, const Char_t* src); Copy the C-structure src into the new location; the length of the strucutre is defined by this class descriptor. void CopySet(TTable& array); to be documented. const Char_t * GetColumnComment(Int_t columnIndex) const; Get a comment from the table descriptor. Long_t AppendRows(const void* row, UInt_t nRows); Append nRows row of the array ""row"" to the table; return; - the new table size (# of table rows); - 0 if the object doesn't own the internal array and can not expand it. Long_t InsertRows(const void* rows, Long_t indx, UInt_t nRows = 1); void InsertRows(cons void *row, Long_t indx, UInt_t nRows). Insert one or several rows into the table at ""indx"" position; The rest table stuff is shifted down. cons void - a pointer to the array of rows to be inserted; Long_t indx = The position these rows will be inserted to; Int_t nRows - the total number of rows to be inserted; = 1 ""by default; return:; The number of the rows has been shifted to accomodate; the new rows. void * ReAllocate(); Reallocate this table leaving only (used rows)+1 allocated; GetTableSize() = GetNRows() + 1; returns a pointer to the first row of the reallocated table; Note:; The table is reallocated if it is an owner of the internal array. void * ReAllocate(Int_t newsize); Reallocate this table leaving only <newsize> allocated; GetTableSize() = newsize;; returns a pointer to the first row of the reallocated table; Note:; The table is reallocated if it is an owner of the internal array. void ReAlloc(Int_t newsize); The table is reallocated if it is an owner of the internal array. Char_t * Create(); Allocate a space for the new table, if any; Sleep for a while if spa",MatchSource.WIKI,root/html534/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTable.html
https://root.cern/root/html534/TTable.html:27270,Availability,avail,available,27270,"rows into the table at ""indx"" position; The rest table stuff is shifted down. cons void - a pointer to the array of rows to be inserted; Long_t indx = The position these rows will be inserted to; Int_t nRows - the total number of rows to be inserted; = 1 ""by default; return:; The number of the rows has been shifted to accomodate; the new rows. void * ReAllocate(); Reallocate this table leaving only (used rows)+1 allocated; GetTableSize() = GetNRows() + 1; returns a pointer to the first row of the reallocated table; Note:; The table is reallocated if it is an owner of the internal array. void * ReAllocate(Int_t newsize); Reallocate this table leaving only <newsize> allocated; GetTableSize() = newsize;; returns a pointer to the first row of the reallocated table; Note:; The table is reallocated if it is an owner of the internal array. void ReAlloc(Int_t newsize); The table is reallocated if it is an owner of the internal array. Char_t * Create(); Allocate a space for the new table, if any; Sleep for a while if space is not available and try again. void Browse(TBrowser* b); Wrap each table coulumn with TColumnView object to browse. void Clear(Option_t* opt = """"); Deletes the internal array of this class; if this object does own its internal table. void Delete(Option_t* opt = """"). Delete the internal array and free the memory it occupied; if this object did own this array. Then perform TDataSet::Delete(opt). TClass * GetRowClass() const; to be documented. Long_t GetNRows() const; Returns the number of the used rows for the wrapped table. Long_t GetRowSize() const; Returns the size (in bytes) of one table row. Long_t GetTableSize() const; Returns the number of the allocated rows. void Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0); Fit a projected item(s) from a TTable*-; *-* =======================================. formula is a TF1 expression. See ",MatchSource.WIKI,root/html534/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTable.html
https://root.cern/root/html534/TTable.html:29174,Availability,error,error,29174,"(s) from a TTable*-; *-* =======================================. formula is a TF1 expression. See TTable::Draw for explanations of the other parameters. By default the temporary histogram created is called htemp.; If varexp contains >>hnew , the new histogram created is called hnew; and it is kept in the current directory.; Example:; table.Fit(pol4,""sqrt(x)>>hsqrt"",""y>0""); will fit sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. const Char_t * GetType() const; Returns the type of the wrapped C-structure kept as the TNamed title. Bool_t IsFolder() const; return Folder flag to be used by TBrowse object; The table is a folder if; - it has sub-dataset; or; - GetNRows > 0. Int_t NaN(). return the total number of the NaN for float/double cells of this table; Thanks Victor Perevoztchikov. TTable * New(const Char_t* name, const Char_t* type, void* array, UInt_t size); This static method creates a new TTable object if provided. Bool_t OutOfBoundsError(const char* where, Int_t i) const; Generate an out-of-bounds error. Always returns false. Char_t * Print(Char_t* buf, Int_t n) const; Create IDL table defintion (to be used for XDF I/O). const Char_t * PrintHeader() const; Print general table inforamtion. const Char_t * Print(Int_t row, Int_t rownumber = 10, const Char_t* colfirst = """", const Char_t* collast = """") const; const Char_t *TTable::Print(Int_t row, Int_t rownumber, const Char_t *colfirst, const Char_t *collast) const. Print the contents of internal table per COLUMN. row - the index of the first row to print (counting from ZERO); rownumber - the total number of rows to print out (=10 by default). (No use !) Char_t *colfirst, *collast - the names of the first/last; to print out (not implemented yet). Check bounds and adjust it. void PrintContents(Option_t* opt = """") const; to be documented. void Project(const char* hname, const char* varexp, const char* selection = """", Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); -*-*",MatchSource.WIKI,root/html534/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTable.html
https://root.cern/root/html534/TTable.html:2293,Energy Efficiency,charge,charge,2293,"t start (cm). See also comments*; float phi0; /* azimuthal angle at start (deg) *; float z0; /* z-coord. at start (cm) *; float psi; /* azimuthal angle of pT vector (deg) *; float tanl; /* tan(dip) =pz/pt at start *; float invpt; /* 1/pt at start (GeV/c)^(-1) *; float curvature; /* Track curvature (1/cm) *; float covar[15]; /* full covariance matrix *; float chisq[2]; /* Chi-square per degree of freedom *; float x_first[3]; /* coord. of first measured point (cm) *; float x_last[3]; /* coord. of last measured point (cm) *; float length; /* from first to last point (cm) *; float impact; /* primary vertex (cm) *; unsigned long map[2]; /* extrap. info. (see preceding comments)*; int id; /* Primary key (see comments) *; int iflag; /* bitmask quality info. (see comments) *; int det_id; /* Detector id information *; int method; /* Track finding/fitting method, packed *; int pid; /* Geant particle ID for assumed mass *; int n_point; /* SVT, TPC, FTPC component #s are packed *; int n_max_point; /* SVT, TPC, FTPC component #s are packed *; int n_fit_point; /* SVT, TPC, FTPC component #s are packed *; int icharge; /* Particle charge in units of |e| *; int id_start_vertex; /* final fit and primary track candidates *; } DST_TRACK_ST;. class St_dst_track : public TTable; {; public:; ClassDefTable(St_dst_track,dst_track_st); ClassDef(St_dst_track,2) //C++ wrapper for <dst_track> StAF table; };; #endif. where the CPP macro defines several convinient methods for the; ""table"" class (see: $ROOTSYS/table/inc/Ttypes.h for details:. #define ClassDefTable(className,structName); protected:; static TTableDescriptor *fgColDescriptors;; virtual TTableDescriptor *GetDescriptorPointer() const { return fgColDescriptors;}; virtual void SetDescriptorPointer(TTableDescriptor *list) const { fgColDescriptors = list;}; public:; typedef structName* iterator;; className() : TTable(_QUOTE_(className),sizeof(structName)) {SetType(_QUOTE_(structName));}; className(const char *name) : TTable(name,sizeof(stru",MatchSource.WIKI,root/html534/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTable.html
https://root.cern/root/html534/TTable.html:26649,Energy Efficiency,allocate,allocated,26649,"ss descriptor. void CopySet(TTable& array); to be documented. const Char_t * GetColumnComment(Int_t columnIndex) const; Get a comment from the table descriptor. Long_t AppendRows(const void* row, UInt_t nRows); Append nRows row of the array ""row"" to the table; return; - the new table size (# of table rows); - 0 if the object doesn't own the internal array and can not expand it. Long_t InsertRows(const void* rows, Long_t indx, UInt_t nRows = 1); void InsertRows(cons void *row, Long_t indx, UInt_t nRows). Insert one or several rows into the table at ""indx"" position; The rest table stuff is shifted down. cons void - a pointer to the array of rows to be inserted; Long_t indx = The position these rows will be inserted to; Int_t nRows - the total number of rows to be inserted; = 1 ""by default; return:; The number of the rows has been shifted to accomodate; the new rows. void * ReAllocate(); Reallocate this table leaving only (used rows)+1 allocated; GetTableSize() = GetNRows() + 1; returns a pointer to the first row of the reallocated table; Note:; The table is reallocated if it is an owner of the internal array. void * ReAllocate(Int_t newsize); Reallocate this table leaving only <newsize> allocated; GetTableSize() = newsize;; returns a pointer to the first row of the reallocated table; Note:; The table is reallocated if it is an owner of the internal array. void ReAlloc(Int_t newsize); The table is reallocated if it is an owner of the internal array. Char_t * Create(); Allocate a space for the new table, if any; Sleep for a while if space is not available and try again. void Browse(TBrowser* b); Wrap each table coulumn with TColumnView object to browse. void Clear(Option_t* opt = """"); Deletes the internal array of this class; if this object does own its internal table. void Delete(Option_t* opt = """"). Delete the internal array and free the memory it occupied; if this object did own this array. Then perform TDataSet::Delete(opt). TClass * GetRowClass() const; to be docum",MatchSource.WIKI,root/html534/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTable.html
https://root.cern/root/html534/TTable.html:26906,Energy Efficiency,allocate,allocated,26906," the table; return; - the new table size (# of table rows); - 0 if the object doesn't own the internal array and can not expand it. Long_t InsertRows(const void* rows, Long_t indx, UInt_t nRows = 1); void InsertRows(cons void *row, Long_t indx, UInt_t nRows). Insert one or several rows into the table at ""indx"" position; The rest table stuff is shifted down. cons void - a pointer to the array of rows to be inserted; Long_t indx = The position these rows will be inserted to; Int_t nRows - the total number of rows to be inserted; = 1 ""by default; return:; The number of the rows has been shifted to accomodate; the new rows. void * ReAllocate(); Reallocate this table leaving only (used rows)+1 allocated; GetTableSize() = GetNRows() + 1; returns a pointer to the first row of the reallocated table; Note:; The table is reallocated if it is an owner of the internal array. void * ReAllocate(Int_t newsize); Reallocate this table leaving only <newsize> allocated; GetTableSize() = newsize;; returns a pointer to the first row of the reallocated table; Note:; The table is reallocated if it is an owner of the internal array. void ReAlloc(Int_t newsize); The table is reallocated if it is an owner of the internal array. Char_t * Create(); Allocate a space for the new table, if any; Sleep for a while if space is not available and try again. void Browse(TBrowser* b); Wrap each table coulumn with TColumnView object to browse. void Clear(Option_t* opt = """"); Deletes the internal array of this class; if this object does own its internal table. void Delete(Option_t* opt = """"). Delete the internal array and free the memory it occupied; if this object did own this array. Then perform TDataSet::Delete(opt). TClass * GetRowClass() const; to be documented. Long_t GetNRows() const; Returns the number of the used rows for the wrapped table. Long_t GetRowSize() const; Returns the size (in bytes) of one table row. Long_t GetTableSize() const; Returns the number of the allocated rows. void Fit(const ",MatchSource.WIKI,root/html534/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTable.html
https://root.cern/root/html534/TTable.html:27921,Energy Efficiency,allocate,allocated,27921,"size> allocated; GetTableSize() = newsize;; returns a pointer to the first row of the reallocated table; Note:; The table is reallocated if it is an owner of the internal array. void ReAlloc(Int_t newsize); The table is reallocated if it is an owner of the internal array. Char_t * Create(); Allocate a space for the new table, if any; Sleep for a while if space is not available and try again. void Browse(TBrowser* b); Wrap each table coulumn with TColumnView object to browse. void Clear(Option_t* opt = """"); Deletes the internal array of this class; if this object does own its internal table. void Delete(Option_t* opt = """"). Delete the internal array and free the memory it occupied; if this object did own this array. Then perform TDataSet::Delete(opt). TClass * GetRowClass() const; to be documented. Long_t GetNRows() const; Returns the number of the used rows for the wrapped table. Long_t GetRowSize() const; Returns the size (in bytes) of one table row. Long_t GetTableSize() const; Returns the number of the allocated rows. void Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0); Fit a projected item(s) from a TTable*-; *-* =======================================. formula is a TF1 expression. See TTable::Draw for explanations of the other parameters. By default the temporary histogram created is called htemp.; If varexp contains >>hnew , the new histogram created is called hnew; and it is kept in the current directory.; Example:; table.Fit(pol4,""sqrt(x)>>hsqrt"",""y>0""); will fit sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. const Char_t * GetType() const; Returns the type of the wrapped C-structure kept as the TNamed title. Bool_t IsFolder() const; return Folder flag to be used by TBrowse object; The table is a folder if; - it has sub-dataset; or; - GetNRows > 0. Int_t NaN(). return the total number of the NaN for float/double cel",MatchSource.WIKI,root/html534/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTable.html
https://root.cern/root/html534/TTable.html:30515,Energy Efficiency,allocate,allocated,30515,"nst; const Char_t *TTable::Print(Int_t row, Int_t rownumber, const Char_t *colfirst, const Char_t *collast) const. Print the contents of internal table per COLUMN. row - the index of the first row to print (counting from ZERO); rownumber - the total number of rows to print out (=10 by default). (No use !) Char_t *colfirst, *collast - the names of the first/last; to print out (not implemented yet). Check bounds and adjust it. void PrintContents(Option_t* opt = """") const; to be documented. void Project(const char* hname, const char* varexp, const char* selection = """", Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); -*-*Make a projection of a TTable using selections; *-* =============================================. Depending on the value of varexp (described in Draw) a 1-D,2-D,etc; projection of the TTable will be filled in histogram hname.; Note that the dimension of hname must match with the dimension of varexp. Int_t Purge(Option_t* opt = """"); Shrink the table to free the unused but still allocated rows. void SavePrimitive(ostream& out, Option_t* option = """"); Save a primitive as a C++ statement(s) on output stream ""out"". void Set(Int_t n); Set array size of TTable object to n longs. If n<0 leave array unchanged. void SetTablePointer(void* table); to be documented. void SetType(const char *const type); to be documented. Char_t * MakeExpression(const Char_t** expressions, Int_t nExpressions); Create CINT macro to evaluate the user-provided expresssion; Expression may contains:; - the table columen names; - 2 meta names: i$ - the current column index,; n$ - the total table size provided by TTable::GetNRows() method. return the name of temporary file with the current expressions. void Reset(Int_t c = 0); Fill the entire table with byte ""c"" ;; c=0 ""be default"". void ResetMap(Bool_t wipe = kTRUE); Clean all filled columns with the pointers to TTableMap; if any; wipe = kTRUE - delete all object the Map's point to; kFALSE - zero pointer, do not ",MatchSource.WIKI,root/html534/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTable.html
https://root.cern/root/html534/TTable.html:2523,Integrability,wrap,wrapper,2523," /* full covariance matrix *; float chisq[2]; /* Chi-square per degree of freedom *; float x_first[3]; /* coord. of first measured point (cm) *; float x_last[3]; /* coord. of last measured point (cm) *; float length; /* from first to last point (cm) *; float impact; /* primary vertex (cm) *; unsigned long map[2]; /* extrap. info. (see preceding comments)*; int id; /* Primary key (see comments) *; int iflag; /* bitmask quality info. (see comments) *; int det_id; /* Detector id information *; int method; /* Track finding/fitting method, packed *; int pid; /* Geant particle ID for assumed mass *; int n_point; /* SVT, TPC, FTPC component #s are packed *; int n_max_point; /* SVT, TPC, FTPC component #s are packed *; int n_fit_point; /* SVT, TPC, FTPC component #s are packed *; int icharge; /* Particle charge in units of |e| *; int id_start_vertex; /* final fit and primary track candidates *; } DST_TRACK_ST;. class St_dst_track : public TTable; {; public:; ClassDefTable(St_dst_track,dst_track_st); ClassDef(St_dst_track,2) //C++ wrapper for <dst_track> StAF table; };; #endif. where the CPP macro defines several convinient methods for the; ""table"" class (see: $ROOTSYS/table/inc/Ttypes.h for details:. #define ClassDefTable(className,structName); protected:; static TTableDescriptor *fgColDescriptors;; virtual TTableDescriptor *GetDescriptorPointer() const { return fgColDescriptors;}; virtual void SetDescriptorPointer(TTableDescriptor *list) const { fgColDescriptors = list;}; public:; typedef structName* iterator;; className() : TTable(_QUOTE_(className),sizeof(structName)) {SetType(_QUOTE_(structName));}; className(const char *name) : TTable(name,sizeof(structName)) {SetType(_QUOTE_(structName));}; className(Int_t n) : TTable(_QUOTE_(className),n,sizeof(structName)) {SetType(_QUOTE_(structName));}; className(const char *name,Int_t n) : TTable(name,n,sizeof(structName)) {SetType(_QUOTE_(structName));}; structName *GetTable(Int_t i=0) const { return ((structName *)GetArray())+i;",MatchSource.WIKI,root/html534/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTable.html
https://root.cern/root/html534/TTable.html:4304,Integrability,wrap,wrapped,4304,"e));}; className(const char *name,Int_t n) : TTable(name,n,sizeof(structName)) {SetType(_QUOTE_(structName));}; structName *GetTable(Int_t i=0) const { return ((structName *)GetArray())+i;}; structName &operator[](Int_t i){ assert(i>=0 && i < GetNRows()); return *GetTable(i); }; const structName &operator[](Int_t i) const { assert(i>=0 && i < GetNRows()); return *((const structName *)(GetTable(i))); }; structName *begin() const { return GetNRows()? GetTable(0):0;}; structName *end() const {Int_t i = GetNRows(); return i? GetTable(i):0;}. The class implementation file may 2 lines and look as follows:; (for the example above):. St_dst_track_Table.cxx:. #include ""St_dst_track_Table.h""; TableClassImpl(St_dst_track, dst_track_st). LinkDef.h. To provide ROOT I/O for this class TWO CINT dictonary entries; should be defined with your custom LinkDef.h file; 1. First entry (as usually) for the class derived from TTable; for example:; #pragma C++ class St_dst_track; 2. Second entry for the C-structure wrapped into the class.; Since C-structuire is not derived from TObject it must be; properly defined as ""foreign"" ROOT class; #pragma C++ class dst_track_st+;. meta-variables i$ and n$ introduced; where ""i$"" stands for the current row index; ""n$"" stands for the total number of rows; meta-variable can be used along the normal; table column names in the expressions (see for example; method TTable::Draw. Function Members (Methods); public:. TTable(const TTable& table); TTable(const char* name = 0, Int_t size = 0); TTable(const char* name, Int_t n, Int_t size); TTable(const char* name, Int_t n, Char_t* array, Int_t size); TTable(const char* name, const char* type, Int_t n, Char_t* array, Int_t size); virtual~TTable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDataSet::Add(TDataSet* dataset); virtual Int_tAddAt(const void* c); virtual voidAddAt(const void* c, Int_t i); virtual voidAddAt(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddAtAndExpand(TD",MatchSource.WIKI,root/html534/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTable.html
https://root.cern/root/html534/TTable.html:27778,Integrability,wrap,wrapped,27778,"le; Note:; The table is reallocated if it is an owner of the internal array. void * ReAllocate(Int_t newsize); Reallocate this table leaving only <newsize> allocated; GetTableSize() = newsize;; returns a pointer to the first row of the reallocated table; Note:; The table is reallocated if it is an owner of the internal array. void ReAlloc(Int_t newsize); The table is reallocated if it is an owner of the internal array. Char_t * Create(); Allocate a space for the new table, if any; Sleep for a while if space is not available and try again. void Browse(TBrowser* b); Wrap each table coulumn with TColumnView object to browse. void Clear(Option_t* opt = """"); Deletes the internal array of this class; if this object does own its internal table. void Delete(Option_t* opt = """"). Delete the internal array and free the memory it occupied; if this object did own this array. Then perform TDataSet::Delete(opt). TClass * GetRowClass() const; to be documented. Long_t GetNRows() const; Returns the number of the used rows for the wrapped table. Long_t GetRowSize() const; Returns the size (in bytes) of one table row. Long_t GetTableSize() const; Returns the number of the allocated rows. void Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0); Fit a projected item(s) from a TTable*-; *-* =======================================. formula is a TF1 expression. See TTable::Draw for explanations of the other parameters. By default the temporary histogram created is called htemp.; If varexp contains >>hnew , the new histogram created is called hnew; and it is kept in the current directory.; Example:; table.Fit(pol4,""sqrt(x)>>hsqrt"",""y>0""); will fit sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. const Char_t * GetType() const; Returns the type of the wrapped C-structure kept as the TNamed title. Bool_t IsFolder() const; return Folder flag to be used by T",MatchSource.WIKI,root/html534/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTable.html
https://root.cern/root/html534/TTable.html:28645,Integrability,wrap,wrapped,28645,"DataSet::Delete(opt). TClass * GetRowClass() const; to be documented. Long_t GetNRows() const; Returns the number of the used rows for the wrapped table. Long_t GetRowSize() const; Returns the size (in bytes) of one table row. Long_t GetTableSize() const; Returns the number of the allocated rows. void Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0); Fit a projected item(s) from a TTable*-; *-* =======================================. formula is a TF1 expression. See TTable::Draw for explanations of the other parameters. By default the temporary histogram created is called htemp.; If varexp contains >>hnew , the new histogram created is called hnew; and it is kept in the current directory.; Example:; table.Fit(pol4,""sqrt(x)>>hsqrt"",""y>0""); will fit sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. const Char_t * GetType() const; Returns the type of the wrapped C-structure kept as the TNamed title. Bool_t IsFolder() const; return Folder flag to be used by TBrowse object; The table is a folder if; - it has sub-dataset; or; - GetNRows > 0. Int_t NaN(). return the total number of the NaN for float/double cells of this table; Thanks Victor Perevoztchikov. TTable * New(const Char_t* name, const Char_t* type, void* array, UInt_t size); This static method creates a new TTable object if provided. Bool_t OutOfBoundsError(const char* where, Int_t i) const; Generate an out-of-bounds error. Always returns false. Char_t * Print(Char_t* buf, Int_t n) const; Create IDL table defintion (to be used for XDF I/O). const Char_t * PrintHeader() const; Print general table inforamtion. const Char_t * Print(Int_t row, Int_t rownumber = 10, const Char_t* colfirst = """", const Char_t* collast = """") const; const Char_t *TTable::Print(Int_t row, Int_t rownumber, const Char_t *colfirst, const Char_t *collast) const. Print the contents of internal table per C",MatchSource.WIKI,root/html534/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTable.html
https://root.cern/root/html534/TTable.html:4469,Modifiability,variab,variables,4469,"tructName &operator[](Int_t i) const { assert(i>=0 && i < GetNRows()); return *((const structName *)(GetTable(i))); }; structName *begin() const { return GetNRows()? GetTable(0):0;}; structName *end() const {Int_t i = GetNRows(); return i? GetTable(i):0;}. The class implementation file may 2 lines and look as follows:; (for the example above):. St_dst_track_Table.cxx:. #include ""St_dst_track_Table.h""; TableClassImpl(St_dst_track, dst_track_st). LinkDef.h. To provide ROOT I/O for this class TWO CINT dictonary entries; should be defined with your custom LinkDef.h file; 1. First entry (as usually) for the class derived from TTable; for example:; #pragma C++ class St_dst_track; 2. Second entry for the C-structure wrapped into the class.; Since C-structuire is not derived from TObject it must be; properly defined as ""foreign"" ROOT class; #pragma C++ class dst_track_st+;. meta-variables i$ and n$ introduced; where ""i$"" stands for the current row index; ""n$"" stands for the total number of rows; meta-variable can be used along the normal; table column names in the expressions (see for example; method TTable::Draw. Function Members (Methods); public:. TTable(const TTable& table); TTable(const char* name = 0, Int_t size = 0); TTable(const char* name, Int_t n, Int_t size); TTable(const char* name, Int_t n, Char_t* array, Int_t size); TTable(const char* name, const char* type, Int_t n, Char_t* array, Int_t size); virtual~TTable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDataSet::Add(TDataSet* dataset); virtual Int_tAddAt(const void* c); virtual voidAddAt(const void* c, Int_t i); virtual voidAddAt(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddAtAndExpand(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddFirst(TDataSet* dataset); virtual voidTDataSet::AddLast(TDataSet* dataset); virtual voidAdopt(Int_t n, void* array); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Long_tAppendRows(const void* row, UInt_t nRows); ",MatchSource.WIKI,root/html534/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTable.html
https://root.cern/root/html534/TTable.html:4593,Modifiability,variab,variable,4593,"tructName &operator[](Int_t i) const { assert(i>=0 && i < GetNRows()); return *((const structName *)(GetTable(i))); }; structName *begin() const { return GetNRows()? GetTable(0):0;}; structName *end() const {Int_t i = GetNRows(); return i? GetTable(i):0;}. The class implementation file may 2 lines and look as follows:; (for the example above):. St_dst_track_Table.cxx:. #include ""St_dst_track_Table.h""; TableClassImpl(St_dst_track, dst_track_st). LinkDef.h. To provide ROOT I/O for this class TWO CINT dictonary entries; should be defined with your custom LinkDef.h file; 1. First entry (as usually) for the class derived from TTable; for example:; #pragma C++ class St_dst_track; 2. Second entry for the C-structure wrapped into the class.; Since C-structuire is not derived from TObject it must be; properly defined as ""foreign"" ROOT class; #pragma C++ class dst_track_st+;. meta-variables i$ and n$ introduced; where ""i$"" stands for the current row index; ""n$"" stands for the total number of rows; meta-variable can be used along the normal; table column names in the expressions (see for example; method TTable::Draw. Function Members (Methods); public:. TTable(const TTable& table); TTable(const char* name = 0, Int_t size = 0); TTable(const char* name, Int_t n, Int_t size); TTable(const char* name, Int_t n, Char_t* array, Int_t size); TTable(const char* name, const char* type, Int_t n, Char_t* array, Int_t size); virtual~TTable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDataSet::Add(TDataSet* dataset); virtual Int_tAddAt(const void* c); virtual voidAddAt(const void* c, Int_t i); virtual voidAddAt(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddAtAndExpand(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddFirst(TDataSet* dataset); virtual voidTDataSet::AddLast(TDataSet* dataset); virtual voidAdopt(Int_t n, void* array); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Long_tAppendRows(const void* row, UInt_t nRows); ",MatchSource.WIKI,root/html534/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTable.html
https://root.cern/root/html534/TTable.html:20147,Modifiability,variab,variable,20147,"he rows been copied. void DeleteRows(Long_t indx, UInt_t nRows = 1); Delete one or several rows from the table. Int_t indx - index of the first row to be deleted; Int_t nRows - the total number of rows to be deleted; = 1 ""by default. TH1 * Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); *-*-*-*-*-*Draw expression varexp for specified entries; *-* ===========================================. This function accepts TCut objects as arguments.; Useful to use the string operator +; example:; table.Draw(""x"",cut1+cut2+cut3);. TCutG object with ""CUTG"" name can be created via the graphics editor. TH1 * Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); *-*-*-*-*-*Draw expression varexp for specified entries; *-* ===========================================. varexp is an expression of the general form e1:e2:e3; where e1,etc is a C++ expression referencing a combination of the TTable columns; One can use two extra meta variable ""i$"" and ""n$"" along with the table; column names.; i$ is to involve the current row number; n$ refers the total num,ber of rows of this table provided by TTable::GetNRows(). Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim dsitribution of y versus sqrt(x); = i$:sqrt(x) 2-Dim dsitribution of i versus sqrt(x[i]); = phep[0]:sqrt(phep[3]) 2-Dim dsitribution of phep[0] versus sqrt(phep[3]). Note that the variables e1, e2 or e3 may contain a boolean expression as well.; example, if e1= x*(y<0), the value histogrammed will be x if y<0; and will be 0 otherwise. selection is a C++ expression with a combination of the columns.; The value corresponding to the selection expression is used as a weight; to fill the histogram.; If the expression includes only boolean operations, the result; is 0 or 1. If the result is 0, the histogram is no",MatchSource.WIKI,root/html534/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTable.html
https://root.cern/root/html534/TTable.html:20660,Modifiability,variab,variables,20660," object with ""CUTG"" name can be created via the graphics editor. TH1 * Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); *-*-*-*-*-*Draw expression varexp for specified entries; *-* ===========================================. varexp is an expression of the general form e1:e2:e3; where e1,etc is a C++ expression referencing a combination of the TTable columns; One can use two extra meta variable ""i$"" and ""n$"" along with the table; column names.; i$ is to involve the current row number; n$ refers the total num,ber of rows of this table provided by TTable::GetNRows(). Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim dsitribution of y versus sqrt(x); = i$:sqrt(x) 2-Dim dsitribution of i versus sqrt(x[i]); = phep[0]:sqrt(phep[3]) 2-Dim dsitribution of phep[0] versus sqrt(phep[3]). Note that the variables e1, e2 or e3 may contain a boolean expression as well.; example, if e1= x*(y<0), the value histogrammed will be x if y<0; and will be 0 otherwise. selection is a C++ expression with a combination of the columns.; The value corresponding to the selection expression is used as a weight; to fill the histogram.; If the expression includes only boolean operations, the result; is 0 or 1. If the result is 0, the histogram is not filled.; In general, the expression may be of the form:. value*(boolean expression). if boolean expression is true, the histogram is filled with; a weight = value.; Examples:; selection1 = ""x<y && sqrt(z)>3.2 && 6 < i$ && i$ < n$""; selection2 = ""(x+y)*(sqrt(z)>3.2""; selection3 = ""signal*(log(signal)>1.2)""; selection1 returns a weigth = 0 or 1; selection2 returns a weight = x+y if sqrt(z)>3.2; returns a weight = 0 otherwise.; selection3 returns a weight = signal if log(signal)>1.2. option is the drawing option; see TH1::Draw for the list of all drawing options.; If option contains th",MatchSource.WIKI,root/html534/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTable.html
https://root.cern/root/html534/TTable.html:21989,Modifiability,variab,variable,21989," operations, the result; is 0 or 1. If the result is 0, the histogram is not filled.; In general, the expression may be of the form:. value*(boolean expression). if boolean expression is true, the histogram is filled with; a weight = value.; Examples:; selection1 = ""x<y && sqrt(z)>3.2 && 6 < i$ && i$ < n$""; selection2 = ""(x+y)*(sqrt(z)>3.2""; selection3 = ""signal*(log(signal)>1.2)""; selection1 returns a weigth = 0 or 1; selection2 returns a weight = x+y if sqrt(z)>3.2; returns a weight = 0 otherwise.; selection3 returns a weight = signal if log(signal)>1.2. option is the drawing option; see TH1::Draw for the list of all drawing options.; If option contains the string ""goff"", no graphics is generated. nentries is the number of entries to process (default is all); first is the first entry to process (default is 0). Saving the result of Draw to an histogram. By default the temporary histogram created is called htemp.; If varexp0 contains >>hnew (following the variable(s) name(s),; the new histogram created is called hnew and it is kept in the current; directory.; Example:; tree.Draw(""sqrt(x)>>hsqrt"",""y>0""); will draw sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. By default, the specified histogram is reset.; To continue to append data to an existing histogram, use ""+"" in front; of the histogram name;; table.Draw(""sqrt(x)>>+hsqrt"",""y>0""); will not reset hsqrt, but will continue filling. Making a Profile histogram. In case of a 2-Dim expression, one can generate a TProfile histogram; instead of a TH2F histogram by specyfying option=prof or option=profs.; The option=prof is automatically selected in case of y:x>>pf; where pf is an existing TProfile histogram. Saving the result of Draw to a TEventList. TTable::Draw can be used to fill a TEventList object (list of entry numbers); instead of histogramming one variable.; If varexp0 has the form >>elist , a TEventList object named ""elist""; is created in the current directory. elist will contain the list; ",MatchSource.WIKI,root/html534/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTable.html
https://root.cern/root/html534/TTable.html:22873,Modifiability,variab,variable,22873,"ess (default is 0). Saving the result of Draw to an histogram. By default the temporary histogram created is called htemp.; If varexp0 contains >>hnew (following the variable(s) name(s),; the new histogram created is called hnew and it is kept in the current; directory.; Example:; tree.Draw(""sqrt(x)>>hsqrt"",""y>0""); will draw sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. By default, the specified histogram is reset.; To continue to append data to an existing histogram, use ""+"" in front; of the histogram name;; table.Draw(""sqrt(x)>>+hsqrt"",""y>0""); will not reset hsqrt, but will continue filling. Making a Profile histogram. In case of a 2-Dim expression, one can generate a TProfile histogram; instead of a TH2F histogram by specyfying option=prof or option=profs.; The option=prof is automatically selected in case of y:x>>pf; where pf is an existing TProfile histogram. Saving the result of Draw to a TEventList. TTable::Draw can be used to fill a TEventList object (list of entry numbers); instead of histogramming one variable.; If varexp0 has the form >>elist , a TEventList object named ""elist""; is created in the current directory. elist will contain the list; of entry numbers satisfying the current selection.; Example:; tree.Draw("">>yplus"",""y>0""); will create a TEventList object named ""yplus"" in the current directory.; In an interactive session, one can type (after TTable::Draw); yplus.Print(""all""); to print the list of entry numbers in the list. By default, the specified entry list is reset.; To continue to append data to an existing list, use ""+"" in front; of the list name;; table.Draw("">>+yplus"",""y>0""); will not reset yplus, but will enter the selected entries at the end; of the existing list. Bool_t EntryLoop(const Char_t* exprFileName, Int_t& action, TObject* obj, Int_t nentries = 1000000000, Int_t firstentry = 0, Option_t* option = """"). EntryLoop creates a CINT bytecode to evaluate the given expressions for; all table rows in loop and fill the",MatchSource.WIKI,root/html534/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTable.html
https://root.cern/root/html534/TTable.html:27630,Performance,perform,perform,27630,"ows)+1 allocated; GetTableSize() = GetNRows() + 1; returns a pointer to the first row of the reallocated table; Note:; The table is reallocated if it is an owner of the internal array. void * ReAllocate(Int_t newsize); Reallocate this table leaving only <newsize> allocated; GetTableSize() = newsize;; returns a pointer to the first row of the reallocated table; Note:; The table is reallocated if it is an owner of the internal array. void ReAlloc(Int_t newsize); The table is reallocated if it is an owner of the internal array. Char_t * Create(); Allocate a space for the new table, if any; Sleep for a while if space is not available and try again. void Browse(TBrowser* b); Wrap each table coulumn with TColumnView object to browse. void Clear(Option_t* opt = """"); Deletes the internal array of this class; if this object does own its internal table. void Delete(Option_t* opt = """"). Delete the internal array and free the memory it occupied; if this object did own this array. Then perform TDataSet::Delete(opt). TClass * GetRowClass() const; to be documented. Long_t GetNRows() const; Returns the number of the used rows for the wrapped table. Long_t GetRowSize() const; Returns the size (in bytes) of one table row. Long_t GetTableSize() const; Returns the number of the allocated rows. void Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0); Fit a projected item(s) from a TTable*-; *-* =======================================. formula is a TF1 expression. See TTable::Draw for explanations of the other parameters. By default the temporary histogram created is called htemp.; If varexp contains >>hnew , the new histogram created is called hnew; and it is kept in the current directory.; Example:; table.Fit(pol4,""sqrt(x)>>hsqrt"",""y>0""); will fit sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. const Char_t * GetType() const; Returns the type of t",MatchSource.WIKI,root/html534/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTable.html
https://root.cern/root/html534/TTable.html:3522,Testability,assert,assert,3522,"int icharge; /* Particle charge in units of |e| *; int id_start_vertex; /* final fit and primary track candidates *; } DST_TRACK_ST;. class St_dst_track : public TTable; {; public:; ClassDefTable(St_dst_track,dst_track_st); ClassDef(St_dst_track,2) //C++ wrapper for <dst_track> StAF table; };; #endif. where the CPP macro defines several convinient methods for the; ""table"" class (see: $ROOTSYS/table/inc/Ttypes.h for details:. #define ClassDefTable(className,structName); protected:; static TTableDescriptor *fgColDescriptors;; virtual TTableDescriptor *GetDescriptorPointer() const { return fgColDescriptors;}; virtual void SetDescriptorPointer(TTableDescriptor *list) const { fgColDescriptors = list;}; public:; typedef structName* iterator;; className() : TTable(_QUOTE_(className),sizeof(structName)) {SetType(_QUOTE_(structName));}; className(const char *name) : TTable(name,sizeof(structName)) {SetType(_QUOTE_(structName));}; className(Int_t n) : TTable(_QUOTE_(className),n,sizeof(structName)) {SetType(_QUOTE_(structName));}; className(const char *name,Int_t n) : TTable(name,n,sizeof(structName)) {SetType(_QUOTE_(structName));}; structName *GetTable(Int_t i=0) const { return ((structName *)GetArray())+i;}; structName &operator[](Int_t i){ assert(i>=0 && i < GetNRows()); return *GetTable(i); }; const structName &operator[](Int_t i) const { assert(i>=0 && i < GetNRows()); return *((const structName *)(GetTable(i))); }; structName *begin() const { return GetNRows()? GetTable(0):0;}; structName *end() const {Int_t i = GetNRows(); return i? GetTable(i):0;}. The class implementation file may 2 lines and look as follows:; (for the example above):. St_dst_track_Table.cxx:. #include ""St_dst_track_Table.h""; TableClassImpl(St_dst_track, dst_track_st). LinkDef.h. To provide ROOT I/O for this class TWO CINT dictonary entries; should be defined with your custom LinkDef.h file; 1. First entry (as usually) for the class derived from TTable; for example:; #pragma C++ class St_dst_track; 2",MatchSource.WIKI,root/html534/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTable.html
https://root.cern/root/html534/TTable.html:3624,Testability,assert,assert,3624,"int icharge; /* Particle charge in units of |e| *; int id_start_vertex; /* final fit and primary track candidates *; } DST_TRACK_ST;. class St_dst_track : public TTable; {; public:; ClassDefTable(St_dst_track,dst_track_st); ClassDef(St_dst_track,2) //C++ wrapper for <dst_track> StAF table; };; #endif. where the CPP macro defines several convinient methods for the; ""table"" class (see: $ROOTSYS/table/inc/Ttypes.h for details:. #define ClassDefTable(className,structName); protected:; static TTableDescriptor *fgColDescriptors;; virtual TTableDescriptor *GetDescriptorPointer() const { return fgColDescriptors;}; virtual void SetDescriptorPointer(TTableDescriptor *list) const { fgColDescriptors = list;}; public:; typedef structName* iterator;; className() : TTable(_QUOTE_(className),sizeof(structName)) {SetType(_QUOTE_(structName));}; className(const char *name) : TTable(name,sizeof(structName)) {SetType(_QUOTE_(structName));}; className(Int_t n) : TTable(_QUOTE_(className),n,sizeof(structName)) {SetType(_QUOTE_(structName));}; className(const char *name,Int_t n) : TTable(name,n,sizeof(structName)) {SetType(_QUOTE_(structName));}; structName *GetTable(Int_t i=0) const { return ((structName *)GetArray())+i;}; structName &operator[](Int_t i){ assert(i>=0 && i < GetNRows()); return *GetTable(i); }; const structName &operator[](Int_t i) const { assert(i>=0 && i < GetNRows()); return *((const structName *)(GetTable(i))); }; structName *begin() const { return GetNRows()? GetTable(0):0;}; structName *end() const {Int_t i = GetNRows(); return i? GetTable(i):0;}. The class implementation file may 2 lines and look as follows:; (for the example above):. St_dst_track_Table.cxx:. #include ""St_dst_track_Table.h""; TableClassImpl(St_dst_track, dst_track_st). LinkDef.h. To provide ROOT I/O for this class TWO CINT dictonary entries; should be defined with your custom LinkDef.h file; 1. First entry (as usually) for the class derived from TTable; for example:; #pragma C++ class St_dst_track; 2",MatchSource.WIKI,root/html534/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTable.html
https://root.cern/root/html534/TTable.html:21385,Testability,log,log,21385,"distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim dsitribution of y versus sqrt(x); = i$:sqrt(x) 2-Dim dsitribution of i versus sqrt(x[i]); = phep[0]:sqrt(phep[3]) 2-Dim dsitribution of phep[0] versus sqrt(phep[3]). Note that the variables e1, e2 or e3 may contain a boolean expression as well.; example, if e1= x*(y<0), the value histogrammed will be x if y<0; and will be 0 otherwise. selection is a C++ expression with a combination of the columns.; The value corresponding to the selection expression is used as a weight; to fill the histogram.; If the expression includes only boolean operations, the result; is 0 or 1. If the result is 0, the histogram is not filled.; In general, the expression may be of the form:. value*(boolean expression). if boolean expression is true, the histogram is filled with; a weight = value.; Examples:; selection1 = ""x<y && sqrt(z)>3.2 && 6 < i$ && i$ < n$""; selection2 = ""(x+y)*(sqrt(z)>3.2""; selection3 = ""signal*(log(signal)>1.2)""; selection1 returns a weigth = 0 or 1; selection2 returns a weight = x+y if sqrt(z)>3.2; returns a weight = 0 otherwise.; selection3 returns a weight = signal if log(signal)>1.2. option is the drawing option; see TH1::Draw for the list of all drawing options.; If option contains the string ""goff"", no graphics is generated. nentries is the number of entries to process (default is all); first is the first entry to process (default is 0). Saving the result of Draw to an histogram. By default the temporary histogram created is called htemp.; If varexp0 contains >>hnew (following the variable(s) name(s),; the new histogram created is called hnew and it is kept in the current; directory.; Example:; tree.Draw(""sqrt(x)>>hsqrt"",""y>0""); will draw sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. By default, the specified histogram is reset.; To continue to append data to an existing histogram, use ""+"" in front; of the histogram name;; table.Draw(""sqrt(x",MatchSource.WIKI,root/html534/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTable.html
https://root.cern/root/html534/TTable.html:21565,Testability,log,log,21565,"versus sqrt(x[i]); = phep[0]:sqrt(phep[3]) 2-Dim dsitribution of phep[0] versus sqrt(phep[3]). Note that the variables e1, e2 or e3 may contain a boolean expression as well.; example, if e1= x*(y<0), the value histogrammed will be x if y<0; and will be 0 otherwise. selection is a C++ expression with a combination of the columns.; The value corresponding to the selection expression is used as a weight; to fill the histogram.; If the expression includes only boolean operations, the result; is 0 or 1. If the result is 0, the histogram is not filled.; In general, the expression may be of the form:. value*(boolean expression). if boolean expression is true, the histogram is filled with; a weight = value.; Examples:; selection1 = ""x<y && sqrt(z)>3.2 && 6 < i$ && i$ < n$""; selection2 = ""(x+y)*(sqrt(z)>3.2""; selection3 = ""signal*(log(signal)>1.2)""; selection1 returns a weigth = 0 or 1; selection2 returns a weight = x+y if sqrt(z)>3.2; returns a weight = 0 otherwise.; selection3 returns a weight = signal if log(signal)>1.2. option is the drawing option; see TH1::Draw for the list of all drawing options.; If option contains the string ""goff"", no graphics is generated. nentries is the number of entries to process (default is all); first is the first entry to process (default is 0). Saving the result of Draw to an histogram. By default the temporary histogram created is called htemp.; If varexp0 contains >>hnew (following the variable(s) name(s),; the new histogram created is called hnew and it is kept in the current; directory.; Example:; tree.Draw(""sqrt(x)>>hsqrt"",""y>0""); will draw sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. By default, the specified histogram is reset.; To continue to append data to an existing histogram, use ""+"" in front; of the histogram name;; table.Draw(""sqrt(x)>>+hsqrt"",""y>0""); will not reset hsqrt, but will continue filling. Making a Profile histogram. In case of a 2-Dim expression, one can generate a TProfile histogram; instea",MatchSource.WIKI,root/html534/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTable.html
https://root.cern/root/html534/TTable.html:20351,Usability,simpl,simplest,20351,"ied entries; *-* ===========================================. This function accepts TCut objects as arguments.; Useful to use the string operator +; example:; table.Draw(""x"",cut1+cut2+cut3);. TCutG object with ""CUTG"" name can be created via the graphics editor. TH1 * Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); *-*-*-*-*-*Draw expression varexp for specified entries; *-* ===========================================. varexp is an expression of the general form e1:e2:e3; where e1,etc is a C++ expression referencing a combination of the TTable columns; One can use two extra meta variable ""i$"" and ""n$"" along with the table; column names.; i$ is to involve the current row number; n$ refers the total num,ber of rows of this table provided by TTable::GetNRows(). Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim dsitribution of y versus sqrt(x); = i$:sqrt(x) 2-Dim dsitribution of i versus sqrt(x[i]); = phep[0]:sqrt(phep[3]) 2-Dim dsitribution of phep[0] versus sqrt(phep[3]). Note that the variables e1, e2 or e3 may contain a boolean expression as well.; example, if e1= x*(y<0), the value histogrammed will be x if y<0; and will be 0 otherwise. selection is a C++ expression with a combination of the columns.; The value corresponding to the selection expression is used as a weight; to fill the histogram.; If the expression includes only boolean operations, the result; is 0 or 1. If the result is 0, the histogram is not filled.; In general, the expression may be of the form:. value*(boolean expression). if boolean expression is true, the histogram is filled with; a weight = value.; Examples:; selection1 = ""x<y && sqrt(z)>3.2 && 6 < i$ && i$ < n$""; selection2 = ""(x+y)*(sqrt(z)>3.2""; selection3 = ""signal*(log(signal)>1.2)""; selection1 returns a weigth = 0 or 1; selection2 returns a weight = x+y if sqrt(z)>",MatchSource.WIKI,root/html534/TTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTable.html
https://root.cern/root/html534/TTable3Points.html:4253,Availability,error,error,4253,"z); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; static Int_tTPoints3DABC::DistancetoLine(Int_t px, Int_t py, Float_t x1, Float_t y1, Float_t x2, Float_t y2, Int_t lineWidth = 1); virtual Int_tTTablePoints::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tGetAnyPoint(Int_t idx, TTable3Points::EPointDirection xAxis) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetKey(Int_t); virtual Int_tTTablePoints::GetLastPosition() const; virtual Int_tGetN() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TTablePoints::GetOption() const; virtual Float_t*GetP() const; virtual void*TTablePoints::GetTable(); virtual const char*TObject::GetTitle() const; virt",MatchSource.WIKI,root/html534/TTable3Points.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTable3Points.html
https://root.cern/root/html534/TTable3Points.html:4337,Availability,error,error,4337,"se(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; static Int_tTPoints3DABC::DistancetoLine(Int_t px, Int_t py, Float_t x1, Float_t y1, Float_t x2, Float_t y2, Int_t lineWidth = 1); virtual Int_tTTablePoints::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tGetAnyPoint(Int_t idx, TTable3Points::EPointDirection xAxis) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetKey(Int_t); virtual Int_tTTablePoints::GetLastPosition() const; virtual Int_tGetN() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TTablePoints::GetOption() const; virtual Float_t*GetP() const; virtual void*TTablePoints::GetTable(); virtual const char*TObject::GetTitle() const; virtual Int_tGetTotalKeys(); virtual UInt_tTObject::GetUniqueID() const; virtual Float_t",MatchSource.WIKI,root/html534/TTable3Points.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTable3Points.html
https://root.cern/root/html534/TTableDescriptor.html:3168,Availability,error,error,3168,"w = 0, Long_t nRows = 0, Bool_t expand = kFALSE); virtual voidTTable::CopySet(TTable& array); TStringCreateLeafList() const; virtual voidTTable::DeleteRows(Long_t indx, UInt_t nRows = 1); UInt_tDimensions(Int_t column) const; Int_tDimensions(const Char_t* columnName = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTable::Draw(Option_t* opt); virtual TH1*TTable::Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*TTable::Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; tableDescriptor_st*end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual voidTTable::Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; void*TTable::GetArray",MatchSource.WIKI,root/html534/TTableDescriptor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTableDescriptor.html
https://root.cern/root/html534/TTableDescriptor.html:3252,Availability,error,error,3252,"& array); TStringCreateLeafList() const; virtual voidTTable::DeleteRows(Long_t indx, UInt_t nRows = 1); UInt_tDimensions(Int_t column) const; Int_tDimensions(const Char_t* columnName = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTable::Draw(Option_t* opt); virtual TH1*TTable::Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*TTable::Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; tableDescriptor_st*end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual voidTTable::Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; void*TTable::GetArray() const; virtual TSeqCollection*TDataSet::GetCollection() const; virtual const Char",MatchSource.WIKI,root/html534/TTableDescriptor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTableDescriptor.html
https://root.cern/root/html534/TTableDescriptor.html:18530,Testability,assert,assert,18530,"nst TTableDescriptor& dsc); {}. virtual ~TTableDescriptor(). Int_t AddAt(const void* c). void AddAt(const void* c, Int_t i). void AddAt(const tableDescriptor_st& element, const char* comment, Int_t indx). void AddAt(TDataSet* dataset, Int_t idx = 0). TString CreateLeafList() const. void LearnTable(const TTable* parentTable). void LearnTable(TClass* classPtr). Int_t ColumnByName(const Char_t* columnName = 0) const. UInt_t Offset(Int_t column) const. UInt_t ColumnSize(Int_t column) const. UInt_t TypeSize(Int_t column) const. UInt_t Dimensions(Int_t column) const. Int_t Sizeof() const. Int_t UpdateOffsets(const TTableDescriptor* newDesciptor). TTableDescriptor * MakeDescriptor(const char* structName). TDataSet * MakeCommentField(Bool_t createFlag = kTRUE). TTableDescriptor * GetDescriptorPointer() const. void SetDescriptorPointer(TTableDescriptor* list). TTableDescriptor(); {SetType(""tableDescriptor_st"");}. TTableDescriptor(const char* name); {SetType(""tableDescriptor_st"");}. TTableDescriptor(Int_t n); {SetType(""tableDescriptor_st"");}. TTableDescriptor(const char* name, Int_t n); {SetType(""tableDescriptor_st"");}. tableDescriptor_st * GetTable(Int_t i = 0) const; { return ((tableDescriptor_st *)GetArray())+i;}. tableDescriptor_st & operator[](Int_t i); { assert(i>=0 && i < GetNRows()); return *GetTable(i); }. const tableDescriptor_st & operator[](Int_t i) const; { assert(i>=0 && i < GetNRows()); return *((const tableDescriptor_st *)(GetTable(i))); }. tableDescriptor_st * begin() const; { return GetNRows()? GetTable(0):0;}. tableDescriptor_st * end() const; {Long_t i = GetNRows(); return i? GetTable(i):0;}. const char * TableDictionary(). » Author: Valery Fine 09/08/99 (E-mail: fine@bnl.gov) » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/table:$Id$ » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TTableDescriptor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTableDescriptor.html
https://root.cern/root/html534/TTableDescriptor.html:18642,Testability,assert,assert,18642,"nst TTableDescriptor& dsc); {}. virtual ~TTableDescriptor(). Int_t AddAt(const void* c). void AddAt(const void* c, Int_t i). void AddAt(const tableDescriptor_st& element, const char* comment, Int_t indx). void AddAt(TDataSet* dataset, Int_t idx = 0). TString CreateLeafList() const. void LearnTable(const TTable* parentTable). void LearnTable(TClass* classPtr). Int_t ColumnByName(const Char_t* columnName = 0) const. UInt_t Offset(Int_t column) const. UInt_t ColumnSize(Int_t column) const. UInt_t TypeSize(Int_t column) const. UInt_t Dimensions(Int_t column) const. Int_t Sizeof() const. Int_t UpdateOffsets(const TTableDescriptor* newDesciptor). TTableDescriptor * MakeDescriptor(const char* structName). TDataSet * MakeCommentField(Bool_t createFlag = kTRUE). TTableDescriptor * GetDescriptorPointer() const. void SetDescriptorPointer(TTableDescriptor* list). TTableDescriptor(); {SetType(""tableDescriptor_st"");}. TTableDescriptor(const char* name); {SetType(""tableDescriptor_st"");}. TTableDescriptor(Int_t n); {SetType(""tableDescriptor_st"");}. TTableDescriptor(const char* name, Int_t n); {SetType(""tableDescriptor_st"");}. tableDescriptor_st * GetTable(Int_t i = 0) const; { return ((tableDescriptor_st *)GetArray())+i;}. tableDescriptor_st & operator[](Int_t i); { assert(i>=0 && i < GetNRows()); return *GetTable(i); }. const tableDescriptor_st & operator[](Int_t i) const; { assert(i>=0 && i < GetNRows()); return *((const tableDescriptor_st *)(GetTable(i))); }. tableDescriptor_st * begin() const; { return GetNRows()? GetTable(0):0;}. tableDescriptor_st * end() const; {Long_t i = GetNRows(); return i? GetTable(i):0;}. const char * TableDictionary(). » Author: Valery Fine 09/08/99 (E-mail: fine@bnl.gov) » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/table:$Id$ » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TTableDescriptor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTableDescriptor.html
https://root.cern/root/html534/TTableIter.html:1777,Availability,error,error,1777,"ad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Int_tCountKey(Float_t& keyvalue); Int_tCountKey(Long_t& keyvalue); Int_tCountKey(Int_t& keyvalue); Int_tCountKey(Short_t& keyvalue); Int_tCountKey(Double_t& keyvalue); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Int_tGetNRows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(con",MatchSource.WIKI,root/html534/TTableIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTableIter.html
https://root.cern/root/html534/TTableIter.html:1861,Availability,error,error,1861,"lass(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Int_tCountKey(Float_t& keyvalue); Int_tCountKey(Long_t& keyvalue); Int_tCountKey(Int_t& keyvalue); Int_tCountKey(Short_t& keyvalue); Int_tCountKey(Double_t& keyvalue); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Int_tGetNRows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) con",MatchSource.WIKI,root/html534/TTableIter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTableIter.html
https://root.cern/root/html534/TTableMap.html:2497,Availability,error,error,2497,"thod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); TTable::iteratorBegin(); TTable::iteratorBegin() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; TTable::iteratorEnd(); TTable::iteratorEnd() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html534/TTableMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTableMap.html
https://root.cern/root/html534/TTableMap.html:2581,Availability,error,error,2581,"); TTable::iteratorBegin(); TTable::iteratorBegin() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; TTable::iteratorEnd(); TTable::iteratorEnd() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html534/TTableMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTableMap.html
https://root.cern/root/html534/TTablePoints.html:1098,Availability,avail,available,1098,"; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TTablePoints. class TTablePoints: public TPoints3DABC. Defines the TTable as an element of ""event"" geometry. +SEQ,TTablePoints.; +SEQ,T<your_table_name_here>. class T<your_table_name_here>_Points : public TTablePoints; {; public:; T<your_table_name_here>_Points(TTableSorter *sorter,const void *key,Option_t *opt):; TTablePoints(sorter,key,opt){}; virtual ~T<your_table_name_here>_Points(){} // default destructor; virtual Float_t GetX(Int_t indx) { return ((<your_table_name_here>_st *)fRows)[Indx(idx)]-> <x>;}; virtual Float_t GetY(Int_t indx) { return ((<your_table_name_here>_st *)fRows)[Indx(idx)]-> <y>;}; virtual Float_t GetZ(Int_t indx) { return ((<your_table_name_here>_st *)fRows)[Indx(idx)]-> <z>;}; };. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TTablePoints(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tTPoints3DABC::Add(Float_t x, Float_t y, Float_t z); virtual Int_tTPoints3DABC::AddLast(Float_t x, Float_t y, Float_t z); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; static Int_tTPoints3DABC::DistancetoLine(Int_t px, Int_t py, Float_t x1, Float_t y1, Float_t x2, Float_t y2, Int_t lineWidth = 1); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::Dr",MatchSource.WIKI,root/html534/TTablePoints.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTablePoints.html
https://root.cern/root/html534/TTablePoints.html:2324,Availability,error,error,2324,"_t y, Float_t z); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; static Int_tTPoints3DABC::DistancetoLine(Int_t px, Int_t py, Float_t x1, Float_t y1, Float_t x2, Float_t y2, Int_t lineWidth = 1); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetLastPosition() const; virtual Int_tTPoints3DABC::GetN() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*GetOption() const; virtual Float_t*TPoints3DABC::GetP() const; virtual void*GetTable(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Float_tGetX(Int_t idx) const; virtual const Float_t*TPoints3DABC::GetXYZ(Int_",MatchSource.WIKI,root/html534/TTablePoints.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTablePoints.html
https://root.cern/root/html534/TTablePoints.html:2408,Availability,error,error,2408,"dTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; static Int_tTPoints3DABC::DistancetoLine(Int_t px, Int_t py, Float_t x1, Float_t y1, Float_t x2, Float_t y2, Int_t lineWidth = 1); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetLastPosition() const; virtual Int_tTPoints3DABC::GetN() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*GetOption() const; virtual Float_t*TPoints3DABC::GetP() const; virtual void*GetTable(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Float_tGetX(Int_t idx) const; virtual const Float_t*TPoints3DABC::GetXYZ(Int_t idx); virtual Float_t*TPoints3DABC::GetXYZ(Float_t* xyz, Int_t idx, Int_t num = 1)",MatchSource.WIKI,root/html534/TTablePoints.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTablePoints.html
https://root.cern/root/html534/TTableSorter.html:4765,Availability,error,error,4765,"e) const; Int_tBinarySearch(Bool_t value) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCountKey(const void* key, Int_t firstIndx = 0, Bool_t bSearch = kTRUE, Int_t* firstRow = 0) const; virtual Int_tCountKeys() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual Int_tFindFirstKey(const void* key) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetColumnName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFirstRow() const; virtual const char*TObject::GetIconName() const; Int_tGetIndex(UInt_t sortedIndex) const; virtual const void*GetKeyAddress(Int_t indx); virtual Int_tGetLastFound() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNRows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOptio",MatchSource.WIKI,root/html534/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTableSorter.html
https://root.cern/root/html534/TTableSorter.html:4849,Availability,error,error,4849,"r* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCountKey(const void* key, Int_t firstIndx = 0, Bool_t bSearch = kTRUE, Int_t* firstRow = 0) const; virtual Int_tCountKeys() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual Int_tFindFirstKey(const void* key) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetColumnName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFirstRow() const; virtual const char*TObject::GetIconName() const; Int_tGetIndex(UInt_t sortedIndex) const; virtual const void*GetKeyAddress(Int_t indx); virtual Int_tGetLastFound() const; virtual const char*TNamed::GetName() const; virtual Int_tGetNRows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TTable*GetTable() const; virtual const char*GetTableName() const;",MatchSource.WIKI,root/html534/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTableSorter.html
https://root.cern/root/html534/TTableSorter.html:385,Integrability,interface,interface,385,". TTableSorter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TTableSorter. class TTableSorter: public TNamed. TTableSorter - Is an ""observer"" class to sort the TTable objects; The class provides an interface to the standard ""C/C++"". qsort and bsearch subroutines (for further information see your local C/C++ docs); ===== =======. - This class DOESN'T change / touch the ""host"" table itself; For any TTable object one can create as many different ""sorter""; as he/she finds useful for his/her code; - Any instance of this class is meaningful as long as the ""host"" object; ""TTable"" does exist and is not changed; - Any attempt to access this TTableSorter after the ""host"" object deleted; causes the program abnormal termination; - Any attempt to access this TTableSorter after the ""host"" object been changed; causes an unpredictable result; - Any instance (object) of this class is NOT deleted ""by automatic"" just; the ""host object ""TTable"" deleted. It is the responsibility of the user's code; keeping TTableSorter and the the ""host"" TTable objects consistent. ""To do"" list. 1. A separate method to provide lexicographical sort if the ""sorted"" column is a kind of array. Usage:; 1. Create an instance of the sorter for the selected column of your table. new TTableSorter(TTable &table, TString &colName,Int_t firstRow,Int_t numberRows). All sort actions are performed within TTableSorter ctor.; This means one needs no extra effort to SORT table. ""Sorter"" contains; the ""sorted index array"" as soon as you create the sorter. TTableSorter sorter(MyTable,""id"",20, 34);; - Creates a sorter for MyTable column ""id"" ordering; its 34 rows from 20 row with standard ""C"" qsort subroutine. 2. You may use this instance to search any ""id"" value with operator []; to get the table row index as follows:. Int_t id = 5;; Int_t i",MatchSource.WIKI,root/html534/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTableSorter.html
https://root.cern/root/html534/TTableSorter.html:1544,Performance,perform,performed,1544,"uch the ""host"" table itself; For any TTable object one can create as many different ""sorter""; as he/she finds useful for his/her code; - Any instance of this class is meaningful as long as the ""host"" object; ""TTable"" does exist and is not changed; - Any attempt to access this TTableSorter after the ""host"" object deleted; causes the program abnormal termination; - Any attempt to access this TTableSorter after the ""host"" object been changed; causes an unpredictable result; - Any instance (object) of this class is NOT deleted ""by automatic"" just; the ""host object ""TTable"" deleted. It is the responsibility of the user's code; keeping TTableSorter and the the ""host"" TTable objects consistent. ""To do"" list. 1. A separate method to provide lexicographical sort if the ""sorted"" column is a kind of array. Usage:; 1. Create an instance of the sorter for the selected column of your table. new TTableSorter(TTable &table, TString &colName,Int_t firstRow,Int_t numberRows). All sort actions are performed within TTableSorter ctor.; This means one needs no extra effort to SORT table. ""Sorter"" contains; the ""sorted index array"" as soon as you create the sorter. TTableSorter sorter(MyTable,""id"",20, 34);; - Creates a sorter for MyTable column ""id"" ordering; its 34 rows from 20 row with standard ""C"" qsort subroutine. 2. You may use this instance to search any ""id"" value with operator []; to get the table row index as follows:. Int_t id = 5;; Int_t index = sorter[id]; // Look for the row index with id = 5; // using the standard ""C"" ""bsearch"" binary search; // subroutine; Int_t index = sorter(id); // Look for the row index with id ""nearest"" to 5; // using the internal ""BinarySearch"" method. 3. Some useful methods of this class:. 3.1. CountKeys(); 3.2 CountKey(const void *key, Int_t firstIndx=0,Bool_t bSearch=kTRUE,Int_t *firstRow=0); 3.3. FindFirstKey(const void *key); 3.4. GetIndex(UInt_t sortedIndex). Function Members (Methods); public:. TTableSorter(); TTableSorter(const TTable& table, T",MatchSource.WIKI,root/html534/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTableSorter.html
https://root.cern/root/html534/TTableSorter.html:14867,Safety,safe,safe,14867,"ingle integer number allowed !; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const TTable& table, SEARCHMETHOD search, COMPAREMETHOD compare, Int_t firstRow = 0, Int_t numbeRows = 0). TTableSorter ctor sorts the input table according the function ""search"". - search - the function to compare the ""key"" and the table rows during sorting; typedef Int_t (*SEARCHMETHOD) (const void *, const void **);. - compare - the function to compare two table rows during searching; typedef Int_t (*COMPAREMETHOD)(const void **, const void **);. - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table; Note: This is a base class. If one fears it is not safe; ----- to allow ""void *"" one may potect the end-user code; providing a derived class with the appropriated type; of the parameters. TTableSorter(const TTable* table, SEARCHMETHOD search, COMPAREMETHOD compare, Int_t firstRow = 0, Int_t numbeRows = 0). TTableSorter ctor sorts the input table according the function ""search"". - search - the function to compare the ""key"" and the table rows during sorting; typedef Int_t (*SEARCHMETHOD) (const void *, const void **);. - compare - the function to compare two table rows during searching; typedef Int_t (*COMPAREMETHOD)(const void **, const void **);. - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table; Note: This is a base class. If one fears it is not safe; ----- to allow ""void *"" one may potect the end-user code; providing a derived class with the appropriated type; of the parameters. void BuildSorter(TString& colName, Int_t firstRow, Int_t numberRows",MatchSource.WIKI,root/html534/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTableSorter.html
https://root.cern/root/html534/TTableSorter.html:15719,Safety,safe,safe,15719,"from the ""firstRow"" by the end of table; Note: This is a base class. If one fears it is not safe; ----- to allow ""void *"" one may potect the end-user code; providing a derived class with the appropriated type; of the parameters. TTableSorter(const TTable* table, SEARCHMETHOD search, COMPAREMETHOD compare, Int_t firstRow = 0, Int_t numbeRows = 0). TTableSorter ctor sorts the input table according the function ""search"". - search - the function to compare the ""key"" and the table rows during sorting; typedef Int_t (*SEARCHMETHOD) (const void *, const void **);. - compare - the function to compare two table rows during searching; typedef Int_t (*COMPAREMETHOD)(const void **, const void **);. - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table; Note: This is a base class. If one fears it is not safe; ----- to allow ""void *"" one may potect the end-user code; providing a derived class with the appropriated type; of the parameters. void BuildSorter(TString& colName, Int_t firstRow, Int_t numberRows). BuildSorter backs TTableSorter ctor. - colName - may be followed by the square brackets with integer number inside,; if that columm is an array (for example ""phys[3]"").; NO expression inside of [], only a single integer number allowed !; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Float_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Double_",MatchSource.WIKI,root/html534/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTableSorter.html
https://root.cern/root/html534/TTableSorter.html:18459,Safety,avoid,avoid,18459,"able rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. void SetSimpleArray(Int_t arraySize, Int_t firstRow, Int_t numberRows); Set some common parameteres for the ""simple"" arrays. ~TTableSorter(); to be documented. Int_t BSearch(valuetype value). Int_t SelectSearch(valuetype value). Int_t BSearch(const void* value) const; to be documented. Int_t GetIndex(UInt_t sortedIndex) const; returns the original index of the row by its sorted index. Int_t CountKey(const void* key, Int_t firstIndx = 0, Bool_t bSearch = kTRUE, Int_t* firstRow = 0) const. CountKey counts the number of rows with the key value equal ""key"". key - it is a POINTER to the key value; fistIndx - the first index within sorted array to star search; = 0 by default; bSearch = kTRUE - binary search (by default) is used otherwise linear one. Int_t CountKeys() const. Counts the number of different key values. Bool_t FillIndexArray(). File the array of the pointers and check whether; the original table has been sorted to avoid an extra job. Return: kTRUE - the table has been sorted; kFALSE - otherwise. Int_t FindFirstKey(const void* key) const. Looks for the first index of the ""key""; within SORTED table AFTER sorting. Returns: = -1 if the ""key"" was not found. Note: This method has no sense for; ==== the float and double key. To get the index within the original; unsorted table the GetIndex() method; may be used like this:; GetIndex(FindFirstKey(key)). const char * GetTableName() const; to be documented. const char * GetTableTitle() const; to be documented. const char * GetTableType() const; to be documented. TTable * GetTable() const; to be documented. void SetSearchMethod(); Select search function at once. void QSort(); Call the standard C run-time library ""qsort"" function. void LearnTable(). LearnTable() allows the TTableSorter to learn the structure of the; tables used to fill the ntuple.; table - the name of the table; buildTree - if kTRUE, then add TBranches to t",MatchSource.WIKI,root/html534/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTableSorter.html
https://root.cern/root/html534/TTableSorter.html:815,Security,access,access,815,". TTableSorter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TTableSorter. class TTableSorter: public TNamed. TTableSorter - Is an ""observer"" class to sort the TTable objects; The class provides an interface to the standard ""C/C++"". qsort and bsearch subroutines (for further information see your local C/C++ docs); ===== =======. - This class DOESN'T change / touch the ""host"" table itself; For any TTable object one can create as many different ""sorter""; as he/she finds useful for his/her code; - Any instance of this class is meaningful as long as the ""host"" object; ""TTable"" does exist and is not changed; - Any attempt to access this TTableSorter after the ""host"" object deleted; causes the program abnormal termination; - Any attempt to access this TTableSorter after the ""host"" object been changed; causes an unpredictable result; - Any instance (object) of this class is NOT deleted ""by automatic"" just; the ""host object ""TTable"" deleted. It is the responsibility of the user's code; keeping TTableSorter and the the ""host"" TTable objects consistent. ""To do"" list. 1. A separate method to provide lexicographical sort if the ""sorted"" column is a kind of array. Usage:; 1. Create an instance of the sorter for the selected column of your table. new TTableSorter(TTable &table, TString &colName,Int_t firstRow,Int_t numberRows). All sort actions are performed within TTableSorter ctor.; This means one needs no extra effort to SORT table. ""Sorter"" contains; the ""sorted index array"" as soon as you create the sorter. TTableSorter sorter(MyTable,""id"",20, 34);; - Creates a sorter for MyTable column ""id"" ordering; its 34 rows from 20 row with standard ""C"" qsort subroutine. 2. You may use this instance to search any ""id"" value with operator []; to get the table row index as follows:. Int_t id = 5;; Int_t i",MatchSource.WIKI,root/html534/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTableSorter.html
https://root.cern/root/html534/TTableSorter.html:931,Security,access,access,931,". TTableSorter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TTableSorter. class TTableSorter: public TNamed. TTableSorter - Is an ""observer"" class to sort the TTable objects; The class provides an interface to the standard ""C/C++"". qsort and bsearch subroutines (for further information see your local C/C++ docs); ===== =======. - This class DOESN'T change / touch the ""host"" table itself; For any TTable object one can create as many different ""sorter""; as he/she finds useful for his/her code; - Any instance of this class is meaningful as long as the ""host"" object; ""TTable"" does exist and is not changed; - Any attempt to access this TTableSorter after the ""host"" object deleted; causes the program abnormal termination; - Any attempt to access this TTableSorter after the ""host"" object been changed; causes an unpredictable result; - Any instance (object) of this class is NOT deleted ""by automatic"" just; the ""host object ""TTable"" deleted. It is the responsibility of the user's code; keeping TTableSorter and the the ""host"" TTable objects consistent. ""To do"" list. 1. A separate method to provide lexicographical sort if the ""sorted"" column is a kind of array. Usage:; 1. Create an instance of the sorter for the selected column of your table. new TTableSorter(TTable &table, TString &colName,Int_t firstRow,Int_t numberRows). All sort actions are performed within TTableSorter ctor.; This means one needs no extra effort to SORT table. ""Sorter"" contains; the ""sorted index array"" as soon as you create the sorter. TTableSorter sorter(MyTable,""id"",20, 34);; - Creates a sorter for MyTable column ""id"" ordering; its 34 rows from 20 row with standard ""C"" qsort subroutine. 2. You may use this instance to search any ""id"" value with operator []; to get the table row index as follows:. Int_t id = 5;; Int_t i",MatchSource.WIKI,root/html534/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTableSorter.html
https://root.cern/root/html534/TTableSorter.html:2732,Usability,simpl,simpleArray,2732,,MatchSource.WIKI,root/html534/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTableSorter.html
https://root.cern/root/html534/TTableSorter.html:2834,Usability,simpl,simpleArray,2834,,MatchSource.WIKI,root/html534/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTableSorter.html
https://root.cern/root/html534/TTableSorter.html:2934,Usability,simpl,simpleArray,2934,,MatchSource.WIKI,root/html534/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTableSorter.html
https://root.cern/root/html534/TTableSorter.html:11921,Usability,simpl,simple,11921,"SelectSearch(Bool_t value) const; voidSetSearchMethod(); voidSetSimpleArray(Int_t arraySize, Int_t firstRow, Int_t numberRows). private:. TTableSorter(const TTableSorter&); TTableSorter&operator=(const TTableSorter&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfColDimensionsThe number of the dimensions for array (=-1 means it is a ""simple"" array); TStringfColName; Int_tfColOffset; Int_tfColSizeThe size of the selected column in bytes; TTable::EColumnTypefColTypedata type of the selected column; COMPAREMETHODfCompareMethodFunction to sort the original array; const char*fFirstParentRow! pointer to the internal array of TTable object;; Int_tfFirstRowfirst row of the table to be sorted; Int_t*fIndexArray""parsed"" indecis; Int_tfLastFoundThe index of the last found index within fSortIndex; TStringTNamed::fNameobject identifier; Int_tfNumberOfRowsnumber of rows of the table to be sorted; Long_tfParentRowSizeTo be filled from TTable::GetRowSize() method; const TTable*fParentTable!- the back pointer to the sorted table; SEARCHMETHODfSearchMethodFunction selected to search values; void**fSortIndexArray of pointers to columns of the sorted table; TStringTNamed::fTitleobject title; const Char_t*fsimpleArrayPointer to the ""simple"" array;. private:. TTableSorter::fValue. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTableSorter(); default ctor for RootCint dictionary. TTableSorter(const TTable& table, TString& colName, Int_t firstRow = 0, Int_t numbeRows = 0). TTableSorter ctor sorts the input table along its column defined with colName. - colName - may be followed by the square brackets with integer number inside,; if that columm is an array (for example ""phys[3]"").; NO expression inside ",MatchSource.WIKI,root/html534/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTableSorter.html
https://root.cern/root/html534/TTableSorter.html:12817,Usability,simpl,simple,12817,"SelectSearch(Bool_t value) const; voidSetSearchMethod(); voidSetSimpleArray(Int_t arraySize, Int_t firstRow, Int_t numberRows). private:. TTableSorter(const TTableSorter&); TTableSorter&operator=(const TTableSorter&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tfColDimensionsThe number of the dimensions for array (=-1 means it is a ""simple"" array); TStringfColName; Int_tfColOffset; Int_tfColSizeThe size of the selected column in bytes; TTable::EColumnTypefColTypedata type of the selected column; COMPAREMETHODfCompareMethodFunction to sort the original array; const char*fFirstParentRow! pointer to the internal array of TTable object;; Int_tfFirstRowfirst row of the table to be sorted; Int_t*fIndexArray""parsed"" indecis; Int_tfLastFoundThe index of the last found index within fSortIndex; TStringTNamed::fNameobject identifier; Int_tfNumberOfRowsnumber of rows of the table to be sorted; Long_tfParentRowSizeTo be filled from TTable::GetRowSize() method; const TTable*fParentTable!- the back pointer to the sorted table; SEARCHMETHODfSearchMethodFunction selected to search values; void**fSortIndexArray of pointers to columns of the sorted table; TStringTNamed::fTitleobject title; const Char_t*fsimpleArrayPointer to the ""simple"" array;. private:. TTableSorter::fValue. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTableSorter(); default ctor for RootCint dictionary. TTableSorter(const TTable& table, TString& colName, Int_t firstRow = 0, Int_t numbeRows = 0). TTableSorter ctor sorts the input table along its column defined with colName. - colName - may be followed by the square brackets with integer number inside,; if that columm is an array (for example ""phys[3]"").; NO expression inside ",MatchSource.WIKI,root/html534/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTableSorter.html
https://root.cern/root/html534/TTableSorter.html:16389,Usability,simpl,simpleArray,16389,"pedef Int_t (*COMPAREMETHOD)(const void **, const void **);. - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table; Note: This is a base class. If one fears it is not safe; ----- to allow ""void *"" one may potect the end-user code; providing a derived class with the appropriated type; of the parameters. void BuildSorter(TString& colName, Int_t firstRow, Int_t numberRows). BuildSorter backs TTableSorter ctor. - colName - may be followed by the square brackets with integer number inside,; if that columm is an array (for example ""phys[3]"").; NO expression inside of [], only a single integer number allowed !; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Float_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Double_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Long_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the sie of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the nu",MatchSource.WIKI,root/html534/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTableSorter.html
https://root.cern/root/html534/TTableSorter.html:16496,Usability,simpl,simpleArray,16496,"he first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table; Note: This is a base class. If one fears it is not safe; ----- to allow ""void *"" one may potect the end-user code; providing a derived class with the appropriated type; of the parameters. void BuildSorter(TString& colName, Int_t firstRow, Int_t numberRows). BuildSorter backs TTableSorter ctor. - colName - may be followed by the square brackets with integer number inside,; if that columm is an array (for example ""phys[3]"").; NO expression inside of [], only a single integer number allowed !; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Float_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Double_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Long_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the sie of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows fr",MatchSource.WIKI,root/html534/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTableSorter.html
https://root.cern/root/html534/TTableSorter.html:16778,Usability,simpl,simpleArray,16778,"ved class with the appropriated type; of the parameters. void BuildSorter(TString& colName, Int_t firstRow, Int_t numberRows). BuildSorter backs TTableSorter ctor. - colName - may be followed by the square brackets with integer number inside,; if that columm is an array (for example ""phys[3]"").; NO expression inside of [], only a single integer number allowed !; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Float_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Double_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Long_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the sie of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. void SetSimpleArray(Int_t arraySize, Int_t firstRow, Int_t numberRows); Set some common parameteres for the ""simple"" arrays. ~TTableSorter(); to be documented. Int_t BSearch(valuetype value). Int_t SelectSearch(valuetype value). Int_t BSearch(const void* value) const; to be ",MatchSource.WIKI,root/html534/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTableSorter.html
https://root.cern/root/html534/TTableSorter.html:16885,Usability,simpl,simpleArray,16885,"String& colName, Int_t firstRow, Int_t numberRows). BuildSorter backs TTableSorter ctor. - colName - may be followed by the square brackets with integer number inside,; if that columm is an array (for example ""phys[3]"").; NO expression inside of [], only a single integer number allowed !; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Float_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Double_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Long_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the sie of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. void SetSimpleArray(Int_t arraySize, Int_t firstRow, Int_t numberRows); Set some common parameteres for the ""simple"" arrays. ~TTableSorter(); to be documented. Int_t BSearch(valuetype value). Int_t SelectSearch(valuetype value). Int_t BSearch(const void* value) const; to be documented. Int_t GetIndex(UInt_t sortedIndex) const; returns the original ",MatchSource.WIKI,root/html534/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTableSorter.html
https://root.cern/root/html534/TTableSorter.html:17165,Usability,simpl,simpleArray,17165,"table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Float_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Double_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Long_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the sie of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. void SetSimpleArray(Int_t arraySize, Int_t firstRow, Int_t numberRows); Set some common parameteres for the ""simple"" arrays. ~TTableSorter(); to be documented. Int_t BSearch(valuetype value). Int_t SelectSearch(valuetype value). Int_t BSearch(const void* value) const; to be documented. Int_t GetIndex(UInt_t sortedIndex) const; returns the original index of the row by its sorted index. Int_t CountKey(const void* key, Int_t firstIndx = 0, Bool_t bSearch = kTRUE, Int_t* firstRow = 0) const. CountKey counts the number of rows with the key value equal ""key"". key - it is a POINTER to the key value; fistIndx - the first index within sorted array to star search; ",MatchSource.WIKI,root/html534/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTableSorter.html
https://root.cern/root/html534/TTableSorter.html:17272,Usability,simpl,simpleArray,17272,"able rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Float_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Double_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Long_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the sie of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. void SetSimpleArray(Int_t arraySize, Int_t firstRow, Int_t numberRows); Set some common parameteres for the ""simple"" arrays. ~TTableSorter(); to be documented. Int_t BSearch(valuetype value). Int_t SelectSearch(valuetype value). Int_t BSearch(const void* value) const; to be documented. Int_t GetIndex(UInt_t sortedIndex) const; returns the original index of the row by its sorted index. Int_t CountKey(const void* key, Int_t firstIndx = 0, Bool_t bSearch = kTRUE, Int_t* firstRow = 0) const. CountKey counts the number of rows with the key value equal ""key"". key - it is a POINTER to the key value; fistIndx - the first index within sorted array to star search; = 0 by default; bSearch = kTRUE - binary search (by default) is used other",MatchSource.WIKI,root/html534/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTableSorter.html
https://root.cern/root/html534/TTableSorter.html:17633,Usability,simpl,simple,17633,"to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Double_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Long_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the sie of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. void SetSimpleArray(Int_t arraySize, Int_t firstRow, Int_t numberRows); Set some common parameteres for the ""simple"" arrays. ~TTableSorter(); to be documented. Int_t BSearch(valuetype value). Int_t SelectSearch(valuetype value). Int_t BSearch(const void* value) const; to be documented. Int_t GetIndex(UInt_t sortedIndex) const; returns the original index of the row by its sorted index. Int_t CountKey(const void* key, Int_t firstIndx = 0, Bool_t bSearch = kTRUE, Int_t* firstRow = 0) const. CountKey counts the number of rows with the key value equal ""key"". key - it is a POINTER to the key value; fistIndx - the first index within sorted array to star search; = 0 by default; bSearch = kTRUE - binary search (by default) is used otherwise linear one. Int_t CountKeys() const. Counts the number of different key values. Bool_t FillIndexArray(). File the array of the pointers and check whether; the original table has been sorted to avoid an extra job. Return: kTRUE - the table has been sorted; kFALSE - otherwise. Int_t FindFirstKey(const void* key) const. L",MatchSource.WIKI,root/html534/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTableSorter.html
https://root.cern/root/html534/TTableSorter.html:19287,Usability,learn,learn,19287,"const. Counts the number of different key values. Bool_t FillIndexArray(). File the array of the pointers and check whether; the original table has been sorted to avoid an extra job. Return: kTRUE - the table has been sorted; kFALSE - otherwise. Int_t FindFirstKey(const void* key) const. Looks for the first index of the ""key""; within SORTED table AFTER sorting. Returns: = -1 if the ""key"" was not found. Note: This method has no sense for; ==== the float and double key. To get the index within the original; unsorted table the GetIndex() method; may be used like this:; GetIndex(FindFirstKey(key)). const char * GetTableName() const; to be documented. const char * GetTableTitle() const; to be documented. const char * GetTableType() const; to be documented. TTable * GetTable() const; to be documented. void SetSearchMethod(); Select search function at once. void QSort(); Call the standard C run-time library ""qsort"" function. void LearnTable(). LearnTable() allows the TTableSorter to learn the structure of the; tables used to fill the ntuple.; table - the name of the table; buildTree - if kTRUE, then add TBranches to the TTree for each table; column (default=kFALSE). const char * At(Int_t i) const; {return fFirstParentRow + i*fParentRowSize;}. Long_t GetRowSize(); { return fParentRowSize; }. Int_t operator[](Int_t value) const; { return BSearch(value); }. Int_t operator[](Long_t value) const; { return BSearch(value); }. Int_t operator[](Double_t value) const; { return BSearch(value); }. Int_t operator[](void* value) const; { return BSearch(value); }. Int_t operator()(Float_t value); { return BinarySearch(value); }. Int_t operator()(Int_t value); { return BinarySearch(value); }. Int_t operator()(Long_t value); { return BinarySearch(value); }. Int_t operator()(Double_t value); { return BinarySearch(value); }. TTableSorter(const TTableSorter& ). TTableSorter & operator=(const TTableSorter& ). int CompareFloat_t(const void** , const void** ). int CompareInt_t(const void** , con",MatchSource.WIKI,root/html534/TTableSorter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTableSorter.html
https://root.cern/root/html534/TTable__iterator.html:310,Integrability,wrap,wrapper,310,". TTable::iterator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TTable::iterator. class TTable::iterator. TTable. It is a base class to create a ""wrapper"" class; holding the plain C-structure array; (1 element of the structure per element). Function Members (Methods); public:. ~iterator(); TTable::iteratoriterator(); TTable::iteratoriterator(const TTable::iterator& iter); TTable::iteratoriterator(const TTable& table, TTable::iterator::vec_const_iterator& arowPtr); void*operator void*() const; Bool_toperator!=(const TTable::iterator& t) const; Long_toperator*() const; TTable::iteratoroperator+(Int_t idx); voidoperator++(); voidoperator++(int); voidoperator+=(Int_t idx); TTable::iteratoroperator-(Int_t idx); Int_toperator-(const TTable::iterator& it) const; voidoperator--(); voidoperator--(int); voidoperator-=(Int_t idx); TTable::iterator&operator=(const TTable::iterator& iter); Bool_toperator==(const TTable::iterator& t) const; void*rowPtr() const; const Long_t&RowSize() const; const TTable&Table() const. Data Members; private:. TTable::iterator::vec_iteratorfCurrentRow; Long_tfRowSize; const TTable*fThisTable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTable & operator=(const TTable::iterator& iter). iterator(); {;}. iterator(const TTable& table, TTable::iterator::vec_const_iterator& arowPtr); {;}. iterator(const TTable& table, TTable::iterator::vec_const_iterator& arowPtr); fCurrentRow(* const_cast<vector<Long_t>::iterator *>(&arowPtr) ) {;}. {;}. void operator++(); { ++fCurrentRow; }. void operator++(int ); { fCurrentRow++; }. void operator--(); { --fCurrentRow; }. void operator--(int ); { fCurrentRow--; }. iterator operator+(Int_t idx); { std::vector<Long_t>::iterator addition = fCurrentRow+idx; return iterator(*fThisTable,addition); }. iterator operator-",MatchSource.WIKI,root/html534/TTable__iterator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTable__iterator.html
https://root.cern/root/html534/TTask.html:4266,Availability,error,error,4266,"Method(const char* method) const; virtual voidAdd(TTask* task); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidCleanTasks(); virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidContinue()MENU ; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidExec(Option_t* option); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteTask(Option_t* option = ""0"")MENU ; virtual voidExecuteTasks(Option_t* option); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetBreakin() const; Int_tGetBreakout() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetListOfTasks() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; ",MatchSource.WIKI,root/html534/TTask.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTask.html
https://root.cern/root/html534/TTask.html:4350,Availability,error,error,4350,":AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidCleanTasks(); virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidContinue()MENU ; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidExec(Option_t* option); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteTask(Option_t* option = ""0"")MENU ; virtual voidExecuteTasks(Option_t* option); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetBreakin() const; Int_tGetBreakout() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetListOfTasks() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() con",MatchSource.WIKI,root/html534/TTask.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTask.html
https://root.cern/root/html534/TTask.html:1260,Usability,resume,resumed,1260,"T; » CORE; » BASE; » TTask. class TTask: public TNamed. TTask is a base class that can be used to build a complex tree of Tasks.; Each TTask derived class may contain other TTasks that can be executed; recursively, such that a complex program can be dynamically built and executed; by invoking the services of the top level Task or one of its subtasks. Use the TTask::Add function to add a subtask to an existing TTask.; To execute a TTask, one calls the ExecuteTask function. ExecuteTask will; call recursively:; - the TTask::Exec function of the derived class; - TTask::ExecuteTasks to execute for each task the list of its subtasks.; If the top level task (see example below) is added to the list of Root; browsable objects, the tree of tasks can be visualized by the Root browser.; The browser can be used to start a task, set break points at the beginning; of a task or when the task has completed. At a breakpoint, data structures; generated by the execution up this point may be inspected asyncronously; and then the execution can be resumed by selecting the ""Continue"" function; of a task. A Task may be active or inactive (controlled by TTask::SetActive).; When a task is not active, its sub tasks are not executed. A TTask tree may be made persistent, saving the status of all the tasks. The picture in the Root browser below has been generated by executing; the following script:. { //------------------script tasks.C---------------------------; TTask *aliroot = new TTask(""aliroot"",""ALICE reconstruction main task"");; TTask *geominit = new TTask(""geomInit"",""Initialize ALICE geometry"");; TTask *matinit = new TTask(""matInit"",""Initialize ALICE materials"");; TTask *physinit = new TTask(""physInit"",""Initialize Physics processes"");; TTask *tracker = new TTask(""tracker"",""Track reconstruction manager"");; TTask *tpcrec = new TTask(""tpcrec"",""TPC reconstruction"");; TTask *itsrec = new TTask(""itsrec"",""ITS reconstruction"");; TTask *muonrec = new TTask(""muonRec"",""Muon Reconstruction"");; TTask *",MatchSource.WIKI,root/html534/TTask.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTask.html
https://root.cern/root/html534/TTask.html:9977,Usability,clear,clear,9977," static TTask*fgBeginTaskpointer to task initiator; static TTask*fgBreakPointpointer to current break point. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTask(); Default constructor invoked when reading a TTask object from a file. TTask(const char* name, const char* title); Standard constructor. TTask& operator=(const TTask& tt); assignment operator (PLEASE DO NOT USE THIS IS WRONG). TTask(const TTask& task); Copy constructor. ~TTask(); Delete a task and its subtasks. void Abort(); Abort current tree of tasks.; After this call, the tree of tasks is ready to be executed again.; The application must take care of cleaning data structures created; by previous executions. void Browse(TBrowser* b); Browse the list of tasks.; It is recommended to add the top level task to the list of; ROOT browsables by:; gROOT->GetListOfBrowsables()->Add(myTopLevelTask). void CleanTasks(); Reset tasks state: breakpoints and execute flags; also invokes the Clear function of each task to clear all data; structures created by a previous execution of a task. void Clear(Option_t* option = """"); Recursively call the Clear function of this task and its subtasks.; The Clear function must be implemented for each derived class; to clear all data structures created by a previous execution of a task.; This function is automatically called by the CleanTasks function. void Continue(); Resume execution at the current break point. void Exec(Option_t* option); Dummy Execute.; This function must be redefined in the derived classes. void ExecuteTask(Option_t* option = ""0""); Execute main task and its subtasks.; When calling this function, the Exec function of the corresponding class; is invoked, then the list of its subtasks is executed calling recursively; all the subtasks, etc. The option parameter may be used to select different execution steps; within a task. This parameter is passed also to all the subtasks. void ExecuteTasks(Option_t* option); Execute all th",MatchSource.WIKI,root/html534/TTask.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTask.html
https://root.cern/root/html534/TTask.html:10216,Usability,clear,clear,10216," from a file. TTask(const char* name, const char* title); Standard constructor. TTask& operator=(const TTask& tt); assignment operator (PLEASE DO NOT USE THIS IS WRONG). TTask(const TTask& task); Copy constructor. ~TTask(); Delete a task and its subtasks. void Abort(); Abort current tree of tasks.; After this call, the tree of tasks is ready to be executed again.; The application must take care of cleaning data structures created; by previous executions. void Browse(TBrowser* b); Browse the list of tasks.; It is recommended to add the top level task to the list of; ROOT browsables by:; gROOT->GetListOfBrowsables()->Add(myTopLevelTask). void CleanTasks(); Reset tasks state: breakpoints and execute flags; also invokes the Clear function of each task to clear all data; structures created by a previous execution of a task. void Clear(Option_t* option = """"); Recursively call the Clear function of this task and its subtasks.; The Clear function must be implemented for each derived class; to clear all data structures created by a previous execution of a task.; This function is automatically called by the CleanTasks function. void Continue(); Resume execution at the current break point. void Exec(Option_t* option); Dummy Execute.; This function must be redefined in the derived classes. void ExecuteTask(Option_t* option = ""0""); Execute main task and its subtasks.; When calling this function, the Exec function of the corresponding class; is invoked, then the list of its subtasks is executed calling recursively; all the subtasks, etc. The option parameter may be used to select different execution steps; within a task. This parameter is passed also to all the subtasks. void ExecuteTasks(Option_t* option); Execute all the subtasks of a task. void ls(Option_t* option = ""*"") const; List the tree of tasks.; Indentation is used to identify the task tree. void Add(TTask* task); {fTasks->Add(task);}. Int_t GetBreakin() const; { return fBreakin; }. Int_t GetBreakout() const; { return f",MatchSource.WIKI,root/html534/TTask.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTask.html
https://root.cern/root/html534/TTeXDump.html:3430,Availability,error,error,3430,"py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); voidDrawPolyLine(Int_t n, TPoints* xy); voidDrawPolyLineNDC(Int_t n, TPoints* uv); virtual voidDrawPolyMarker(Int_t n, Float_t* x, Float_t* y); virtual voidDrawPolyMarker(Int_t n, Double_t* x, Double_t* y); virtual voidDrawPS(Int_t n, Float_t* xw, Float_t* yw); virtual voidDrawPS(Int_t n, Double_t* xw, Double_t* yw); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObje",MatchSource.WIKI,root/html534/TTeXDump.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTeXDump.html
https://root.cern/root/html534/TTeXDump.html:3514,Availability,error,error,3514,"istancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); voidDrawPolyLine(Int_t n, TPoints* xy); voidDrawPolyLineNDC(Int_t n, TPoints* uv); virtual voidDrawPolyMarker(Int_t n, Float_t* x, Float_t* y); virtual voidDrawPolyMarker(Int_t n, Double_t* x, Double_t* y); virtual voidDrawPS(Int_t n, Float_t* xw, Float_t* yw); virtual voidDrawPS(Int_t n, Double_t* xw, Double_t* yw); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Opt",MatchSource.WIKI,root/html534/TTeXDump.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTeXDump.html
https://root.cern/root/html534/TTeXDump.html:15758,Energy Efficiency,green,green,15758," yw); This function defines a path with xw and yw and draw it according the; value of nn:. If nn>0 a line is drawn.; If nn<0 a closed polygon is drawn. void NewPage(); Start the TeX page. This function starts the tikzpicture environment. void Range(Float_t xrange, Float_t yrange); Set the range for the paper in centimetres. void SetFillColor(Color_t cindex = 1); Set color index for fill areas. void SetLineColor(Color_t cindex = 1); Set color index for lines. void SetLineStyle(Style_t linestyle = 1); Change the line style. linestyle = 2 dashed; = 3 dotted; = 4 dash-dotted; = else solid (1 in is used most of the time). void SetLineWidth(Width_t linewidth = 1); Set the lines width. void SetMarkerSize(Size_t msize = 1); Set size for markers. void SetMarkerColor(Color_t cindex = 1); Set color index for markers. void SetColor(Int_t color = 1); Set color with its color index. void SetColor(Float_t r, Float_t g, Float_t b); Set color with its R G B components. r: % of red in [0,1]; g: % of green in [0,1]; b: % of blue in [0,1]. void SetTextColor(Color_t cindex = 1); Set color index for text. void Text(Double_t x, Double_t y, const char* string); Draw text. xx: x position of the text; yy: y position of the text; chars: text to be drawn. void TextNDC(Double_t u, Double_t v, const char* string); Write a string of characters in NDC. Float_t UtoTeX(Double_t u); Convert U from NDC coordinate to TeX. Float_t VtoTeX(Double_t v); Convert V from NDC coordinate to TeX. Float_t XtoTeX(Double_t x); Convert X from world coordinate to TeX. Float_t YtoTeX(Double_t y); Convert Y from world coordinate to TeX. void CellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); Begin the Cell Array painting. void CellArrayFill(Int_t r, Int_t g, Int_t b); Paint the Cell Array. void CellArrayEnd(); End the Cell Array painting. void DrawPS(Int_t n, Float_t* xw, Float_t* yw); Not needed in TeX case. void DefineMarkers(); add additional pgfplotmarks. Int_t CMtoTeX(Double_t u);",MatchSource.WIKI,root/html534/TTeXDump.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTeXDump.html
https://root.cern/root/html534/TTeXDump.html:315,Integrability,interface,interface,315,". TTeXDump. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » POSTSCRIPT; » TTeXDump. class TTeXDump: public TVirtualPS. TTeXDump: Graphics interface to TeX; This class allow to generate PGF/TikZ vector graphics output; which can be included in TeX and LaTeX documents. PGF is a TeX macro package for generating graphics. It is platform; and format-independent and works together with the most important TeX; backend drivers, including pdftex and dvips. It comes with a; user-friendly syntax layer called TikZ. To generate a such file it is enough to do:. gStyle->SetPaperSize(10.,10.);; hpx->Draw();; gPad->Print(""hpx.tex"");. Then, the generated file (hpx.tex) can be included in a; LaTeX document (simple.tex) in the following way:. \documentclass{article}; \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}; \title{A simple LaTeX example}; \date{July 2013}; \begin{document}; \maketitle; The following image as been generated using the TTeXDump class:; \par; \input{hpx.tex}; \end{document}. Note the three directives needed at the top of the LaTeX file:. \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}. Then including the picture in the document is done with the; \input<\tt> directive.; The command pdflatex simple.tex will generate the; corresponding pdf file simple.pdf.; . Function Members (Methods); public:. TTeXDump(); TTeXDump(const char* filename, Int_t type = -113); virtual~TTeXDump(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TO",MatchSource.WIKI,root/html534/TTeXDump.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTeXDump.html
https://root.cern/root/html534/TTeXDump.html:12912,Integrability,interface,interface,12912,"::fLineWidthline width; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTVirtualPS::fNByteNumber of bytes written in the file (PDF); TStringTNamed::fNameobject identifier; Bool_tTVirtualPS::fPrintedTrue when a page must be printed; Bool_tfRangeTrue when a range has been defined; Int_tTVirtualPS::fSizBufferBuffer size; ofstream*TVirtualPS::fStreamFile stream identifier; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title; Int_tfTypeWorkstation type used to know if the Tex is open; Float_tfXsizePage size along X; Float_tfYsizePage size along Y. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTeXDump(); Default TeX constructor. TTeXDump(const char* filename, Int_t type = -113); Initialize the TeX interface. fname : TeX file name; wtype : TeX workstation type. Not used in the TeX driver. But as TTeXDump; inherits from TVirtualPS it should be kept. Anyway it is not; necessary to specify this parameter at creation time because it; has a default value (which is ignore in the TeX case). void Open(const char* filename, Int_t type = -111); Open a TeX file. ~TTeXDump(); Default TeX destructor. void Close(Option_t* opt = """"); Close a TeX file. void On(); Activate an already open TeX file. void Off(); Deactivate an already open TeX file. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw a Box. void DrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); Draw a Frame around a box. mode = -1 the box looks as it is behind the screen; mode = 1 the box looks as it is in front of the screen; border is the border size in already pre-computed TeX units dark is the; color for the dark part",MatchSource.WIKI,root/html534/TTeXDump.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTeXDump.html
https://root.cern/root/html534/TTeXDump.html:13021,Modifiability,inherit,inherits,13021,"er style; Int_tTVirtualPS::fNByteNumber of bytes written in the file (PDF); TStringTNamed::fNameobject identifier; Bool_tTVirtualPS::fPrintedTrue when a page must be printed; Bool_tfRangeTrue when a range has been defined; Int_tTVirtualPS::fSizBufferBuffer size; ofstream*TVirtualPS::fStreamFile stream identifier; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title; Int_tfTypeWorkstation type used to know if the Tex is open; Float_tfXsizePage size along X; Float_tfYsizePage size along Y. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTeXDump(); Default TeX constructor. TTeXDump(const char* filename, Int_t type = -113); Initialize the TeX interface. fname : TeX file name; wtype : TeX workstation type. Not used in the TeX driver. But as TTeXDump; inherits from TVirtualPS it should be kept. Anyway it is not; necessary to specify this parameter at creation time because it; has a default value (which is ignore in the TeX case). void Open(const char* filename, Int_t type = -111); Open a TeX file. ~TTeXDump(); Default TeX destructor. void Close(Option_t* opt = """"); Close a TeX file. void On(); Activate an already open TeX file. void Off(); Deactivate an already open TeX file. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw a Box. void DrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); Draw a Frame around a box. mode = -1 the box looks as it is behind the screen; mode = 1 the box looks as it is in front of the screen; border is the border size in already pre-computed TeX units dark is the; color for the dark part of the frame light is the color for the light; part of the frame. void DrawPolyLine(Int_t n, TPoints* xy); Draw a PolyLine. Draw a polyline through the",MatchSource.WIKI,root/html534/TTeXDump.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTeXDump.html
https://root.cern/root/html534/TTeXDump.html:646,Usability,user-friendly,user-friendly,646,". TTeXDump. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » POSTSCRIPT; » TTeXDump. class TTeXDump: public TVirtualPS. TTeXDump: Graphics interface to TeX; This class allow to generate PGF/TikZ vector graphics output; which can be included in TeX and LaTeX documents. PGF is a TeX macro package for generating graphics. It is platform; and format-independent and works together with the most important TeX; backend drivers, including pdftex and dvips. It comes with a; user-friendly syntax layer called TikZ. To generate a such file it is enough to do:. gStyle->SetPaperSize(10.,10.);; hpx->Draw();; gPad->Print(""hpx.tex"");. Then, the generated file (hpx.tex) can be included in a; LaTeX document (simple.tex) in the following way:. \documentclass{article}; \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}; \title{A simple LaTeX example}; \date{July 2013}; \begin{document}; \maketitle; The following image as been generated using the TTeXDump class:; \par; \input{hpx.tex}; \end{document}. Note the three directives needed at the top of the LaTeX file:. \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}. Then including the picture in the document is done with the; \input<\tt> directive.; The command pdflatex simple.tex will generate the; corresponding pdf file simple.pdf.; . Function Members (Methods); public:. TTeXDump(); TTeXDump(const char* filename, Int_t type = -113); virtual~TTeXDump(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TO",MatchSource.WIKI,root/html534/TTeXDump.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTeXDump.html
https://root.cern/root/html534/TTeXDump.html:875,Usability,simpl,simple,875,". TTeXDump. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » POSTSCRIPT; » TTeXDump. class TTeXDump: public TVirtualPS. TTeXDump: Graphics interface to TeX; This class allow to generate PGF/TikZ vector graphics output; which can be included in TeX and LaTeX documents. PGF is a TeX macro package for generating graphics. It is platform; and format-independent and works together with the most important TeX; backend drivers, including pdftex and dvips. It comes with a; user-friendly syntax layer called TikZ. To generate a such file it is enough to do:. gStyle->SetPaperSize(10.,10.);; hpx->Draw();; gPad->Print(""hpx.tex"");. Then, the generated file (hpx.tex) can be included in a; LaTeX document (simple.tex) in the following way:. \documentclass{article}; \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}; \title{A simple LaTeX example}; \date{July 2013}; \begin{document}; \maketitle; The following image as been generated using the TTeXDump class:; \par; \input{hpx.tex}; \end{document}. Note the three directives needed at the top of the LaTeX file:. \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}. Then including the picture in the document is done with the; \input<\tt> directive.; The command pdflatex simple.tex will generate the; corresponding pdf file simple.pdf.; . Function Members (Methods); public:. TTeXDump(); TTeXDump(const char* filename, Int_t type = -113); virtual~TTeXDump(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TO",MatchSource.WIKI,root/html534/TTeXDump.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTeXDump.html
https://root.cern/root/html534/TTeXDump.html:1018,Usability,simpl,simple,1018," Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » POSTSCRIPT; » TTeXDump. class TTeXDump: public TVirtualPS. TTeXDump: Graphics interface to TeX; This class allow to generate PGF/TikZ vector graphics output; which can be included in TeX and LaTeX documents. PGF is a TeX macro package for generating graphics. It is platform; and format-independent and works together with the most important TeX; backend drivers, including pdftex and dvips. It comes with a; user-friendly syntax layer called TikZ. To generate a such file it is enough to do:. gStyle->SetPaperSize(10.,10.);; hpx->Draw();; gPad->Print(""hpx.tex"");. Then, the generated file (hpx.tex) can be included in a; LaTeX document (simple.tex) in the following way:. \documentclass{article}; \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}; \title{A simple LaTeX example}; \date{July 2013}; \begin{document}; \maketitle; The following image as been generated using the TTeXDump class:; \par; \input{hpx.tex}; \end{document}. Note the three directives needed at the top of the LaTeX file:. \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}. Then including the picture in the document is done with the; \input<\tt> directive.; The command pdflatex simple.tex will generate the; corresponding pdf file simple.pdf.; . Function Members (Methods); public:. TTeXDump(); TTeXDump(const char* filename, Int_t type = -113); virtual~TTeXDump(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidT",MatchSource.WIKI,root/html534/TTeXDump.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTeXDump.html
https://root.cern/root/html534/TTeXDump.html:1437,Usability,simpl,simple,1437,"aTeX documents. PGF is a TeX macro package for generating graphics. It is platform; and format-independent and works together with the most important TeX; backend drivers, including pdftex and dvips. It comes with a; user-friendly syntax layer called TikZ. To generate a such file it is enough to do:. gStyle->SetPaperSize(10.,10.);; hpx->Draw();; gPad->Print(""hpx.tex"");. Then, the generated file (hpx.tex) can be included in a; LaTeX document (simple.tex) in the following way:. \documentclass{article}; \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}; \title{A simple LaTeX example}; \date{July 2013}; \begin{document}; \maketitle; The following image as been generated using the TTeXDump class:; \par; \input{hpx.tex}; \end{document}. Note the three directives needed at the top of the LaTeX file:. \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}. Then including the picture in the document is done with the; \input<\tt> directive.; The command pdflatex simple.tex will generate the; corresponding pdf file simple.pdf.; . Function Members (Methods); public:. TTeXDump(); TTeXDump(const char* filename, Int_t type = -113); virtual~TTeXDump(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); Int_tCMtoTeX(Double_t u); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidDefineMarkers(); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, In",MatchSource.WIKI,root/html534/TTeXDump.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTeXDump.html
https://root.cern/root/html534/TTeXDump.html:1490,Usability,simpl,simple,1490,"e for generating graphics. It is platform; and format-independent and works together with the most important TeX; backend drivers, including pdftex and dvips. It comes with a; user-friendly syntax layer called TikZ. To generate a such file it is enough to do:. gStyle->SetPaperSize(10.,10.);; hpx->Draw();; gPad->Print(""hpx.tex"");. Then, the generated file (hpx.tex) can be included in a; LaTeX document (simple.tex) in the following way:. \documentclass{article}; \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}; \title{A simple LaTeX example}; \date{July 2013}; \begin{document}; \maketitle; The following image as been generated using the TTeXDump class:; \par; \input{hpx.tex}; \end{document}. Note the three directives needed at the top of the LaTeX file:. \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}. Then including the picture in the document is done with the; \input<\tt> directive.; The command pdflatex simple.tex will generate the; corresponding pdf file simple.pdf.; . Function Members (Methods); public:. TTeXDump(); TTeXDump(const char* filename, Int_t type = -113); virtual~TTeXDump(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); Int_tCMtoTeX(Double_t u); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidDefineMarkers(); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double",MatchSource.WIKI,root/html534/TTeXDump.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTeXDump.html
https://root.cern/root/html534/TText.html:1992,Availability,error,error,1992,"virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject& text) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TText*DrawText(Double_t x, Double_t y, const char* text); virtual TText*DrawText(Double_t x, Double_t y, const wchar_t* text); virtual TText*DrawTextNDC(Double_t x, Double_t y, const char* text); virtual TText*DrawTextNDC(Double_t x, Double_t y, const wchar_t* text); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tGetBBox(); virtual TPointGetBBoxCenter(); virtual voidGetBoundingBox(UInt_t& w, UInt_t& h, Bool_t angle = kFALSE); virtual voidGetControlBox(Int_t x, Int_t y, Double_t theta, Int_t* cBoxX, Int_t* cBoxY); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidGetTextAdvance(UInt_t& a, const char* text",MatchSource.WIKI,root/html534/TText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TText.html
https://root.cern/root/html534/TText.html:2076,Availability,error,error,2076,"ption = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject& text) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TText*DrawText(Double_t x, Double_t y, const char* text); virtual TText*DrawText(Double_t x, Double_t y, const wchar_t* text); virtual TText*DrawTextNDC(Double_t x, Double_t y, const char* text); virtual TText*DrawTextNDC(Double_t x, Double_t y, const wchar_t* text); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tGetBBox(); virtual TPointGetBBoxCenter(); virtual voidGetBoundingBox(UInt_t& w, UInt_t& h, Bool_t angle = kFALSE); virtual voidGetControlBox(Int_t x, Int_t y, Double_t theta, Int_t* cBoxX, Int_t* cBoxY); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidGetTextAdvance(UInt_t& a, const char* text, const Bool_t kern = kTRUE) const; virtual Short_tTAttText::GetTextAlign() const; v",MatchSource.WIKI,root/html534/TText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TText.html
https://root.cern/root/html534/TTextEditor.html:4497,Availability,error,error,4497,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html534/TTextEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTextEditor.html
https://root.cern/root/html534/TTextEditor.html:4581,Availability,error,error,4581,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*TGFrame::GetDNDData(Atom_t); virtual Int_tTGFrame::GetDragType() c",MatchSource.WIKI,root/html534/TTextEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTextEditor.html
https://root.cern/root/html534/TTextEditor.html:17403,Availability,mask,mask,17403,,MatchSource.WIKI,root/html534/TTextEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTextEditor.html
https://root.cern/root/html534/TTF.html:1610,Deployability,patch,patch,1610,". TTF. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TTF. class TTF. TTF. Interface to the freetype 2 library. Function Members (Methods); public:. TTF(); TTF(const TTF&); virtual~TTF(); static Short_tCharToUnicode(UInt_t code); static TClass*Class(); static voidCleanup(); static Int_tGetAscent(); static const FT_BBox&GetBox(); static TTGlyph*GetGlyphs(); static Bool_tGetHinting(); static Bool_tGetKerning(); static Int_tGetNumGlyphs(); static FT_Matrix*GetRotMatrix(); static Bool_tGetSmoothing(); static voidGetTextAdvance(UInt_t& a, char* text); static voidGetTextExtent(UInt_t& w, UInt_t& h, char* text); static voidGetTextExtent(UInt_t& w, UInt_t& h, wchar_t* text); static Int_tGetWidth(); static voidInit(); virtual TClass*IsA() const; static Bool_tIsInitialized(); static voidLayoutGlyphs(); TTF&operator=(const TTF&); static voidPrepareString(const char* string); static voidPrepareString(const wchar_t* string); static voidSetHinting(Bool_t state); static voidSetKerning(Bool_t state); static voidSetRotationMatrix(Float_t angle); static voidSetSmoothing(Bool_t state); static voidSetTextFont(Font_t fontnumber); static Int_tSetTextFont(const char* fontname, Int_t italic = 0); static voidSetTextSize(Float_t textsize); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); static voidVersion(Int_t& major, Int_t& minor, Int_t& patch). Data Members; public:. enum { kTTMaxFonts; kMaxGlyphs; };. protected:. static Int_tfgAscentstring ascent, used to compute Y alignment; static FT_BBoxfgCBoxstring control box; static void*fgCharMap[32]font character map; static Int_tfgCurFontIdxcurrent font index; static void*fgFace[32]font face; static Int_tfgFontCountnumber of fonts loaded; static char*fgFontName[32]font name; st",MatchSource.WIKI,root/html534/TTF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTF.html
https://root.cern/root/html534/TTF.html:5043,Deployability,patch,patch,5043,"ing(const wchar_t* string); Put the characters in ""string"" in the ""glyphs"" array. void SetHinting(Bool_t state); Set hinting flag. void SetKerning(Bool_t state); Set kerning flag. void SetRotationMatrix(Float_t angle); Set the rotation matrix used to rotate the font outlines. void SetSmoothing(Bool_t state); Set smoothing (anti-aliasing) flag. Int_t SetTextFont(const char* fontname, Int_t italic = 0); Set text font to specified name.; font : font name; italic : the fonts should be slanted. Used for symbol font. Set text font to specified name. This function returns 0 if; the specified font is found, 1 if not. void SetTextFont(Font_t fontnumber); Set specified font.; List of the currently supported fonts (screen and PostScript). Font ID X11 TTF; 1 : times-medium-i-normal timesi.ttf; 2 : times-bold-r-normal timesbd.ttf; 3 : times-bold-i-normal timesi.ttf; 4 : helvetica-medium-r-normal arial.ttf; 5 : helvetica-medium-o-normal ariali.ttf; 6 : helvetica-bold-r-normal arialbd.ttf; 7 : helvetica-bold-o-normal arialbi.ttf; 8 : courier-medium-r-normal cour.ttf; 9 : courier-medium-o-normal couri.ttf; 10 : courier-bold-r-normal courbd.ttf; 11 : courier-bold-o-normal courbi.ttf; 12 : symbol-medium-r-normal symbol.ttf; 13 : times-medium-r-normal times.ttf; 14 : wingding.ttf; 15 : symbol oblique is emulated from symbol.ttf. void SetTextSize(Float_t textsize); Set current text size. void Version(Int_t& major, Int_t& minor, Int_t& patch). Bool_t GetHinting(). Bool_t GetKerning(). Bool_t GetSmoothing(). Bool_t IsInitialized(). Int_t GetWidth(). Int_t GetAscent(). Int_t GetNumGlyphs(). FT_Matrix * GetRotMatrix(). const FT_BBox & GetBox(). TTGlyph * GetGlyphs(). TTF(); { }. » Author: Olivier Couet 01/10/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/graf:$Id$ » Last generated: 2015-03-14 16:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TTF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTF.html
https://root.cern/root/html534/TTF.html:2747,Integrability,interface,interface,2747,"o compute Y alignment; static FT_BBoxfgCBoxstring control box; static void*fgCharMap[32]font character map; static Int_tfgCurFontIdxcurrent font index; static void*fgFace[32]font face; static Int_tfgFontCountnumber of fonts loaded; static char*fgFontName[32]font name; static TTGlyphfgGlyphs[1024]glyphs; static Bool_tfgHintinguse hinting (true by default); static Bool_tfgInittrue if the Init has been called; static Bool_tfgKerninguse kerning (true by default); static void*fgLibraryFreeType font library; static Int_tfgNumGlyphsnumber of glyphs in the string; static FT_Matrix*fgRotMatrixrotation matrix; static Bool_tfgSmoothinguse anti-aliasing (true when >8 planes, false otherwise); static Int_tfgSymbItaFontIdxSymbol italic font index; static Int_tfgTBlankWtrailing blanks width; static Int_tfgWidthstring width, used to compute X alignment. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TTF(); Cleanup TTF environment. void Init(); Initialise the TrueType fonts interface. void Cleanup(); Cleanup. Is called by the gCleanupTTF destructor. Short_t CharToUnicode(UInt_t code); Map char to unicode. Returns 0 in case no mapping exists. void GetTextExtent(UInt_t& w, UInt_t& h, char* text); Get width (w) and height (h) when text is horizontal. void GetTextAdvance(UInt_t& a, char* text); Get advance (a) when text is horizontal. void GetTextExtent(UInt_t& w, UInt_t& h, wchar_t* text); Get width (w) and height (h) when text is horizontal. void LayoutGlyphs(); Compute the glyps positions, fgAscent and fgWidth (needed for alignment).; Perform the Glyphs transformation.; Compute the string control box.; If required take the ""kerning"" into account.; SetRotation and PrepareString should have been called before. void PrepareString(const char* string); Put the characters in ""string"" in the ""glyphs"" array. void PrepareString(const wchar_t* string); Put the characters in ""string"" in the ""glyphs"" array. void SetHinting(Bool_t state); Set hinting f",MatchSource.WIKI,root/html534/TTF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTF.html
https://root.cern/root/html534/TTF.html:1954,Performance,load,loaded,1954,"(Bool_t state); static voidSetKerning(Bool_t state); static voidSetRotationMatrix(Float_t angle); static voidSetSmoothing(Bool_t state); static voidSetTextFont(Font_t fontnumber); static Int_tSetTextFont(const char* fontname, Int_t italic = 0); static voidSetTextSize(Float_t textsize); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); static voidVersion(Int_t& major, Int_t& minor, Int_t& patch). Data Members; public:. enum { kTTMaxFonts; kMaxGlyphs; };. protected:. static Int_tfgAscentstring ascent, used to compute Y alignment; static FT_BBoxfgCBoxstring control box; static void*fgCharMap[32]font character map; static Int_tfgCurFontIdxcurrent font index; static void*fgFace[32]font face; static Int_tfgFontCountnumber of fonts loaded; static char*fgFontName[32]font name; static TTGlyphfgGlyphs[1024]glyphs; static Bool_tfgHintinguse hinting (true by default); static Bool_tfgInittrue if the Init has been called; static Bool_tfgKerninguse kerning (true by default); static void*fgLibraryFreeType font library; static Int_tfgNumGlyphsnumber of glyphs in the string; static FT_Matrix*fgRotMatrixrotation matrix; static Bool_tfgSmoothinguse anti-aliasing (true when >8 planes, false otherwise); static Int_tfgSymbItaFontIdxSymbol italic font index; static Int_tfgTBlankWtrailing blanks width; static Int_tfgWidthstring width, used to compute X alignment. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TTF(); Cleanup TTF environment. void Init(); Initialise the TrueType fonts interface. void Cleanup(); Cleanup. Is called by the gCleanupTTF destructor. Short_t CharToUnicode(UInt_t code); Map char to unicode. Returns 0 in case no mapping exists. void GetTextExtent(UInt_t& w, UInt_t& h, char* text); Get width (w) and height (h) when text is horizontal. void GetTextAdvance(UInt_t& a, char* text); Get advance (a) when text is horizontal. void GetTextExtent(UInt",MatchSource.WIKI,root/html534/TTF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTF.html
https://root.cern/root/html534/TThread.html:1885,Availability,error,error,1885,"pendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static Int_tCancelPoint(); static TClass*Class(); virtual const char*TObject::ClassName() const; static Int_tCleanUp(); static Int_tCleanUpPop(Int_t exe = 0); static Int_tCleanUpPush(void* free, void* arg = 0); virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(Option_t* option = """"); static Int_tDelete(TThread*& th); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Int_tExists(); static Int_tExit(void* ret = 0); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Long_tGetId() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TThread::EPriorityGetPriority() const; TThread::EStateGetState() const; static TThread*GetThread(Long_t id); static TThread*GetThread(const char* name); static Int_tGetTime(ULong_t* absSec, UL",MatchSource.WIKI,root/html534/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TThread.html
https://root.cern/root/html534/TThread.html:1969,Availability,error,error,1969,"_tCancelPoint(); static TClass*Class(); virtual const char*TObject::ClassName() const; static Int_tCleanUp(); static Int_tCleanUpPop(Int_t exe = 0); static Int_tCleanUpPush(void* free, void* arg = 0); virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(Option_t* option = """"); static Int_tDelete(TThread*& th); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Int_tExists(); static Int_tExit(void* ret = 0); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Long_tGetId() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TThread::EPriorityGetPriority() const; TThread::EStateGetState() const; static TThread*GetThread(Long_t id); static TThread*GetThread(const char* name); static Int_tGetTime(ULong_t* absSec, ULong_t* absNanoSec); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObje",MatchSource.WIKI,root/html534/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TThread.html
https://root.cern/root/html534/TThread.html:11538,Availability,error,error,11538,"thod to delete the specified thread.; Returns -1 in case the thread was running and has been killed. Returns; 0 in case the thread has been Delete and Cleaned up. The th pointer is; not valid anymore in that case. Int_t Exists(); Static method to check if threads exist.; Returns the number of running threads. void SetPriority(TThread::EPriority pri); Set thread priority. TThread * GetThread(Long_t id); Static method to find a thread by id. TThread * GetThread(const char* name); Static method to find a thread by name. TThread * Self(); Static method returning pointer to current thread. Long_t Join(void** ret = 0); Join this thread. Long_t Join(Long_t id, void** ret = 0); Static method to join a thread by id. Long_t SelfId(); Static method returning the id for the current thread. Int_t Run(void* arg = 0); Start the thread. This starts the static method TThread::Function(); which calls the user function specified in the TThread ctor with; the arg argument. Returns 0 on success, otherwise an error number will; be returned. Int_t Kill(); Kill this thread. Returns 0 on success, otherwise an error number will; be returned. Int_t Kill(Long_t id); Static method to kill the thread by id. Returns 0 on success, otherwise; an error number will be returned. Int_t Kill(const char* name); Static method to kill thread by name. Returns 0 on success, otherwise; an error number will be returned. Int_t SetCancelOff(); Static method to turn off thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelOn(); Static method to turn on thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelAsynchronous(); Static method to set the cancellation response type of the calling thread; to asynchronous, i.e. cancel as soon as the cancellation request; is received. Int_t SetCancelDeferred(); Static method to set the cancellation response type of the calling thread; to deferred, i.e. cancel only at next cancell",MatchSource.WIKI,root/html534/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TThread.html
https://root.cern/root/html534/TThread.html:11637,Availability,error,error,11637,". Returns; 0 in case the thread has been Delete and Cleaned up. The th pointer is; not valid anymore in that case. Int_t Exists(); Static method to check if threads exist.; Returns the number of running threads. void SetPriority(TThread::EPriority pri); Set thread priority. TThread * GetThread(Long_t id); Static method to find a thread by id. TThread * GetThread(const char* name); Static method to find a thread by name. TThread * Self(); Static method returning pointer to current thread. Long_t Join(void** ret = 0); Join this thread. Long_t Join(Long_t id, void** ret = 0); Static method to join a thread by id. Long_t SelfId(); Static method returning the id for the current thread. Int_t Run(void* arg = 0); Start the thread. This starts the static method TThread::Function(); which calls the user function specified in the TThread ctor with; the arg argument. Returns 0 on success, otherwise an error number will; be returned. Int_t Kill(); Kill this thread. Returns 0 on success, otherwise an error number will; be returned. Int_t Kill(Long_t id); Static method to kill the thread by id. Returns 0 on success, otherwise; an error number will be returned. Int_t Kill(const char* name); Static method to kill thread by name. Returns 0 on success, otherwise; an error number will be returned. Int_t SetCancelOff(); Static method to turn off thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelOn(); Static method to turn on thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelAsynchronous(); Static method to set the cancellation response type of the calling thread; to asynchronous, i.e. cancel as soon as the cancellation request; is received. Int_t SetCancelDeferred(); Static method to set the cancellation response type of the calling thread; to deferred, i.e. cancel only at next cancellation point.; Returns 0 on success, otherwise an error number will be returned. Int_t CancelPoint()",MatchSource.WIKI,root/html534/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TThread.html
https://root.cern/root/html534/TThread.html:11768,Availability,error,error,11768," Static method to check if threads exist.; Returns the number of running threads. void SetPriority(TThread::EPriority pri); Set thread priority. TThread * GetThread(Long_t id); Static method to find a thread by id. TThread * GetThread(const char* name); Static method to find a thread by name. TThread * Self(); Static method returning pointer to current thread. Long_t Join(void** ret = 0); Join this thread. Long_t Join(Long_t id, void** ret = 0); Static method to join a thread by id. Long_t SelfId(); Static method returning the id for the current thread. Int_t Run(void* arg = 0); Start the thread. This starts the static method TThread::Function(); which calls the user function specified in the TThread ctor with; the arg argument. Returns 0 on success, otherwise an error number will; be returned. Int_t Kill(); Kill this thread. Returns 0 on success, otherwise an error number will; be returned. Int_t Kill(Long_t id); Static method to kill the thread by id. Returns 0 on success, otherwise; an error number will be returned. Int_t Kill(const char* name); Static method to kill thread by name. Returns 0 on success, otherwise; an error number will be returned. Int_t SetCancelOff(); Static method to turn off thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelOn(); Static method to turn on thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelAsynchronous(); Static method to set the cancellation response type of the calling thread; to asynchronous, i.e. cancel as soon as the cancellation request; is received. Int_t SetCancelDeferred(); Static method to set the cancellation response type of the calling thread; to deferred, i.e. cancel only at next cancellation point.; Returns 0 on success, otherwise an error number will be returned. Int_t CancelPoint(); Static method to set a cancellation point. Returns 0 on success, otherwise; an error number will be returned. Int_t CleanUpPush(",MatchSource.WIKI,root/html534/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TThread.html
https://root.cern/root/html534/TThread.html:11903,Availability,error,error,11903,"priority. TThread * GetThread(Long_t id); Static method to find a thread by id. TThread * GetThread(const char* name); Static method to find a thread by name. TThread * Self(); Static method returning pointer to current thread. Long_t Join(void** ret = 0); Join this thread. Long_t Join(Long_t id, void** ret = 0); Static method to join a thread by id. Long_t SelfId(); Static method returning the id for the current thread. Int_t Run(void* arg = 0); Start the thread. This starts the static method TThread::Function(); which calls the user function specified in the TThread ctor with; the arg argument. Returns 0 on success, otherwise an error number will; be returned. Int_t Kill(); Kill this thread. Returns 0 on success, otherwise an error number will; be returned. Int_t Kill(Long_t id); Static method to kill the thread by id. Returns 0 on success, otherwise; an error number will be returned. Int_t Kill(const char* name); Static method to kill thread by name. Returns 0 on success, otherwise; an error number will be returned. Int_t SetCancelOff(); Static method to turn off thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelOn(); Static method to turn on thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelAsynchronous(); Static method to set the cancellation response type of the calling thread; to asynchronous, i.e. cancel as soon as the cancellation request; is received. Int_t SetCancelDeferred(); Static method to set the cancellation response type of the calling thread; to deferred, i.e. cancel only at next cancellation point.; Returns 0 on success, otherwise an error number will be returned. Int_t CancelPoint(); Static method to set a cancellation point. Returns 0 on success, otherwise; an error number will be returned. Int_t CleanUpPush(void* free, void* arg = 0); Static method which pushes thread cleanup method on stack.; Returns 0 in case of success and -1 in case of ",MatchSource.WIKI,root/html534/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TThread.html
https://root.cern/root/html534/TThread.html:12039,Availability,error,error,12039,"find a thread by name. TThread * Self(); Static method returning pointer to current thread. Long_t Join(void** ret = 0); Join this thread. Long_t Join(Long_t id, void** ret = 0); Static method to join a thread by id. Long_t SelfId(); Static method returning the id for the current thread. Int_t Run(void* arg = 0); Start the thread. This starts the static method TThread::Function(); which calls the user function specified in the TThread ctor with; the arg argument. Returns 0 on success, otherwise an error number will; be returned. Int_t Kill(); Kill this thread. Returns 0 on success, otherwise an error number will; be returned. Int_t Kill(Long_t id); Static method to kill the thread by id. Returns 0 on success, otherwise; an error number will be returned. Int_t Kill(const char* name); Static method to kill thread by name. Returns 0 on success, otherwise; an error number will be returned. Int_t SetCancelOff(); Static method to turn off thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelOn(); Static method to turn on thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelAsynchronous(); Static method to set the cancellation response type of the calling thread; to asynchronous, i.e. cancel as soon as the cancellation request; is received. Int_t SetCancelDeferred(); Static method to set the cancellation response type of the calling thread; to deferred, i.e. cancel only at next cancellation point.; Returns 0 on success, otherwise an error number will be returned. Int_t CancelPoint(); Static method to set a cancellation point. Returns 0 on success, otherwise; an error number will be returned. Int_t CleanUpPush(void* free, void* arg = 0); Static method which pushes thread cleanup method on stack.; Returns 0 in case of success and -1 in case of error. Int_t CleanUpPop(Int_t exe = 0); Static method which pops thread cleanup method off stack.; Returns 0 in case of success and -1 i",MatchSource.WIKI,root/html534/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TThread.html
https://root.cern/root/html534/TThread.html:12173,Availability,error,error,12173,"ead. Long_t Join(Long_t id, void** ret = 0); Static method to join a thread by id. Long_t SelfId(); Static method returning the id for the current thread. Int_t Run(void* arg = 0); Start the thread. This starts the static method TThread::Function(); which calls the user function specified in the TThread ctor with; the arg argument. Returns 0 on success, otherwise an error number will; be returned. Int_t Kill(); Kill this thread. Returns 0 on success, otherwise an error number will; be returned. Int_t Kill(Long_t id); Static method to kill the thread by id. Returns 0 on success, otherwise; an error number will be returned. Int_t Kill(const char* name); Static method to kill thread by name. Returns 0 on success, otherwise; an error number will be returned. Int_t SetCancelOff(); Static method to turn off thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelOn(); Static method to turn on thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelAsynchronous(); Static method to set the cancellation response type of the calling thread; to asynchronous, i.e. cancel as soon as the cancellation request; is received. Int_t SetCancelDeferred(); Static method to set the cancellation response type of the calling thread; to deferred, i.e. cancel only at next cancellation point.; Returns 0 on success, otherwise an error number will be returned. Int_t CancelPoint(); Static method to set a cancellation point. Returns 0 on success, otherwise; an error number will be returned. Int_t CleanUpPush(void* free, void* arg = 0); Static method which pushes thread cleanup method on stack.; Returns 0 in case of success and -1 in case of error. Int_t CleanUpPop(Int_t exe = 0); Static method which pops thread cleanup method off stack.; Returns 0 in case of success and -1 in case of error. Int_t CleanUp(); Static method to cleanup the calling thread. void AfterCancel(TThread* th); Static method which is c",MatchSource.WIKI,root/html534/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TThread.html
https://root.cern/root/html534/TThread.html:12585,Availability,error,error,12585,"); Kill this thread. Returns 0 on success, otherwise an error number will; be returned. Int_t Kill(Long_t id); Static method to kill the thread by id. Returns 0 on success, otherwise; an error number will be returned. Int_t Kill(const char* name); Static method to kill thread by name. Returns 0 on success, otherwise; an error number will be returned. Int_t SetCancelOff(); Static method to turn off thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelOn(); Static method to turn on thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelAsynchronous(); Static method to set the cancellation response type of the calling thread; to asynchronous, i.e. cancel as soon as the cancellation request; is received. Int_t SetCancelDeferred(); Static method to set the cancellation response type of the calling thread; to deferred, i.e. cancel only at next cancellation point.; Returns 0 on success, otherwise an error number will be returned. Int_t CancelPoint(); Static method to set a cancellation point. Returns 0 on success, otherwise; an error number will be returned. Int_t CleanUpPush(void* free, void* arg = 0); Static method which pushes thread cleanup method on stack.; Returns 0 in case of success and -1 in case of error. Int_t CleanUpPop(Int_t exe = 0); Static method which pops thread cleanup method off stack.; Returns 0 in case of success and -1 in case of error. Int_t CleanUp(); Static method to cleanup the calling thread. void AfterCancel(TThread* th); Static method which is called after the thread has been canceled. Int_t Exit(void* ret = 0); Static method which terminates the execution of the calling thread. Int_t Sleep(ULong_t secs, ULong_t nanos = 0); Static method to sleep the calling thread. Int_t GetTime(ULong_t* absSec, ULong_t* absNanoSec); Static method to get the current time. Returns; the number of seconds. Int_t Lock(); Static method to lock the main thread mutex. Int",MatchSource.WIKI,root/html534/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TThread.html
https://root.cern/root/html534/TThread.html:12716,Availability,error,error,12716,"l the thread by id. Returns 0 on success, otherwise; an error number will be returned. Int_t Kill(const char* name); Static method to kill thread by name. Returns 0 on success, otherwise; an error number will be returned. Int_t SetCancelOff(); Static method to turn off thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelOn(); Static method to turn on thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelAsynchronous(); Static method to set the cancellation response type of the calling thread; to asynchronous, i.e. cancel as soon as the cancellation request; is received. Int_t SetCancelDeferred(); Static method to set the cancellation response type of the calling thread; to deferred, i.e. cancel only at next cancellation point.; Returns 0 on success, otherwise an error number will be returned. Int_t CancelPoint(); Static method to set a cancellation point. Returns 0 on success, otherwise; an error number will be returned. Int_t CleanUpPush(void* free, void* arg = 0); Static method which pushes thread cleanup method on stack.; Returns 0 in case of success and -1 in case of error. Int_t CleanUpPop(Int_t exe = 0); Static method which pops thread cleanup method off stack.; Returns 0 in case of success and -1 in case of error. Int_t CleanUp(); Static method to cleanup the calling thread. void AfterCancel(TThread* th); Static method which is called after the thread has been canceled. Int_t Exit(void* ret = 0); Static method which terminates the execution of the calling thread. Int_t Sleep(ULong_t secs, ULong_t nanos = 0); Static method to sleep the calling thread. Int_t GetTime(ULong_t* absSec, ULong_t* absNanoSec); Static method to get the current time. Returns; the number of seconds. Int_t Lock(); Static method to lock the main thread mutex. Int_t TryLock(); Static method to try to lock the main thread mutex. Int_t UnLock(); Static method to unlock the main thread mutex. vo",MatchSource.WIKI,root/html534/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TThread.html
https://root.cern/root/html534/TThread.html:12900,Availability,error,error,12900,"n success, otherwise; an error number will be returned. Int_t SetCancelOff(); Static method to turn off thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelOn(); Static method to turn on thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelAsynchronous(); Static method to set the cancellation response type of the calling thread; to asynchronous, i.e. cancel as soon as the cancellation request; is received. Int_t SetCancelDeferred(); Static method to set the cancellation response type of the calling thread; to deferred, i.e. cancel only at next cancellation point.; Returns 0 on success, otherwise an error number will be returned. Int_t CancelPoint(); Static method to set a cancellation point. Returns 0 on success, otherwise; an error number will be returned. Int_t CleanUpPush(void* free, void* arg = 0); Static method which pushes thread cleanup method on stack.; Returns 0 in case of success and -1 in case of error. Int_t CleanUpPop(Int_t exe = 0); Static method which pops thread cleanup method off stack.; Returns 0 in case of success and -1 in case of error. Int_t CleanUp(); Static method to cleanup the calling thread. void AfterCancel(TThread* th); Static method which is called after the thread has been canceled. Int_t Exit(void* ret = 0); Static method which terminates the execution of the calling thread. Int_t Sleep(ULong_t secs, ULong_t nanos = 0); Static method to sleep the calling thread. Int_t GetTime(ULong_t* absSec, ULong_t* absNanoSec); Static method to get the current time. Returns; the number of seconds. Int_t Lock(); Static method to lock the main thread mutex. Int_t TryLock(); Static method to try to lock the main thread mutex. Int_t UnLock(); Static method to unlock the main thread mutex. void * Function(void* ptr); Static method which is called by the system thread function and; which in turn calls the actual user function. void Ps(); Static method list",MatchSource.WIKI,root/html534/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TThread.html
https://root.cern/root/html534/TThread.html:13046,Availability,error,error,13046,"; otherwise an error number will be returned. Int_t SetCancelOn(); Static method to turn on thread cancellation. Returns 0 on success,; otherwise an error number will be returned. Int_t SetCancelAsynchronous(); Static method to set the cancellation response type of the calling thread; to asynchronous, i.e. cancel as soon as the cancellation request; is received. Int_t SetCancelDeferred(); Static method to set the cancellation response type of the calling thread; to deferred, i.e. cancel only at next cancellation point.; Returns 0 on success, otherwise an error number will be returned. Int_t CancelPoint(); Static method to set a cancellation point. Returns 0 on success, otherwise; an error number will be returned. Int_t CleanUpPush(void* free, void* arg = 0); Static method which pushes thread cleanup method on stack.; Returns 0 in case of success and -1 in case of error. Int_t CleanUpPop(Int_t exe = 0); Static method which pops thread cleanup method off stack.; Returns 0 in case of success and -1 in case of error. Int_t CleanUp(); Static method to cleanup the calling thread. void AfterCancel(TThread* th); Static method which is called after the thread has been canceled. Int_t Exit(void* ret = 0); Static method which terminates the execution of the calling thread. Int_t Sleep(ULong_t secs, ULong_t nanos = 0); Static method to sleep the calling thread. Int_t GetTime(ULong_t* absSec, ULong_t* absNanoSec); Static method to get the current time. Returns; the number of seconds. Int_t Lock(); Static method to lock the main thread mutex. Int_t TryLock(); Static method to try to lock the main thread mutex. Int_t UnLock(); Static method to unlock the main thread mutex. void * Function(void* ptr); Static method which is called by the system thread function and; which in turn calls the actual user function. void Ps(); Static method listing the existing threads. void ** Tsd(void* dflt, Int_t k); Static method returning a pointer to thread specific data container; of the calling th",MatchSource.WIKI,root/html534/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TThread.html
https://root.cern/root/html534/TThread.html:14415,Availability,error,error,14415,"p the calling thread. Int_t GetTime(ULong_t* absSec, ULong_t* absNanoSec); Static method to get the current time. Returns; the number of seconds. Int_t Lock(); Static method to lock the main thread mutex. Int_t TryLock(); Static method to try to lock the main thread mutex. Int_t UnLock(); Static method to unlock the main thread mutex. void * Function(void* ptr); Static method which is called by the system thread function and; which in turn calls the actual user function. void Ps(); Static method listing the existing threads. void ** Tsd(void* dflt, Int_t k); Static method returning a pointer to thread specific data container; of the calling thread.; k should be between 0 and kMaxUserThreadSlot for user application.; (and between kMaxUserThreadSlot and kMaxThreadSlot for ROOT libraries).; See ROOT::EThreadSlotReservation. void Printf(const char *va_(fmt), ...); Static method providing a thread safe printf. Appends a newline. void ErrorHandler(int level, const char* location, const char* fmt, va_list ap) const; Thread specific error handler function.; It calls the user set error handler in the main thread. void DoError(Int_t level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler. User has to specify the class name as; part of the location, just like for the global Info(), Warning() and; Error() functions. Int_t XARequest(const char* xact, Int_t nb, void** ar, Int_t* iret); Static method used to allow commands to be executed by the main thread. void XAction(); Static method called via the thread timer to execute in the main; thread certain commands. This to avoid sophisticated locking and; possible deadlocking. void SetComment(const char* txt = 0). TThread& operator=(const TThread& ). void Delete(Option_t* option = """"); { TObject::Delete(option); }. EPriority GetPriority() const; { return fPriority; }. EState GetState() const; { return fState; }. Long_t GetId() const; { return fId; }. void ps(); { Ps(); }. » Author: Fons Rademakers 02",MatchSource.WIKI,root/html534/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TThread.html
https://root.cern/root/html534/TThread.html:14462,Availability,error,error,14462,"get the current time. Returns; the number of seconds. Int_t Lock(); Static method to lock the main thread mutex. Int_t TryLock(); Static method to try to lock the main thread mutex. Int_t UnLock(); Static method to unlock the main thread mutex. void * Function(void* ptr); Static method which is called by the system thread function and; which in turn calls the actual user function. void Ps(); Static method listing the existing threads. void ** Tsd(void* dflt, Int_t k); Static method returning a pointer to thread specific data container; of the calling thread.; k should be between 0 and kMaxUserThreadSlot for user application.; (and between kMaxUserThreadSlot and kMaxThreadSlot for ROOT libraries).; See ROOT::EThreadSlotReservation. void Printf(const char *va_(fmt), ...); Static method providing a thread safe printf. Appends a newline. void ErrorHandler(int level, const char* location, const char* fmt, va_list ap) const; Thread specific error handler function.; It calls the user set error handler in the main thread. void DoError(Int_t level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler. User has to specify the class name as; part of the location, just like for the global Info(), Warning() and; Error() functions. Int_t XARequest(const char* xact, Int_t nb, void** ar, Int_t* iret); Static method used to allow commands to be executed by the main thread. void XAction(); Static method called via the thread timer to execute in the main; thread certain commands. This to avoid sophisticated locking and; possible deadlocking. void SetComment(const char* txt = 0). TThread& operator=(const TThread& ). void Delete(Option_t* option = """"); { TObject::Delete(option); }. EPriority GetPriority() const; { return fPriority; }. EState GetState() const; { return fState; }. Long_t GetId() const; { return fId; }. void ps(); { Ps(); }. » Author: Fons Rademakers 02/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thr",MatchSource.WIKI,root/html534/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TThread.html
https://root.cern/root/html534/TThread.html:10403,Modifiability,variab,variables,10403,"d(const char* thname, TThread::VoidRtnFunc_t fn, void* arg = 0, TThread::EPriority pri = kNormalPriority); Create thread with a name. Specify the function or static class method; to be executed by the thread and a pointer to the argument structure.; The user function should return a void*. To start the thread call Run(). TThread(const char* thname, TThread::VoidRtnFunc_t fn, void* arg = 0, TThread::EPriority pri = kNormalPriority); Create a detached thread with a name. Specify the function or static; class method to be executed by the thread and a pointer to the argument; structure. To start the thread call Run(). void Initialize(); Initialize the Thread package. This initializes the TThread and ROOT; global mutexes to make parts of ROOT thread safe/aware. This call is; implicit in case a TThread is created. Bool_t IsInitialized(); Return true, if the TThread objects have been initialize. If false,; the process is (from ROOT's point of view) single threaded. void Init(); Initialize global state and variables once. void Constructor(); Common thread constructor. ~TThread(); Cleanup the thread. Int_t Delete(TThread*& th); Static method to delete the specified thread.; Returns -1 in case the thread was running and has been killed. Returns; 0 in case the thread has been Delete and Cleaned up. The th pointer is; not valid anymore in that case. Int_t Exists(); Static method to check if threads exist.; Returns the number of running threads. void SetPriority(TThread::EPriority pri); Set thread priority. TThread * GetThread(Long_t id); Static method to find a thread by id. TThread * GetThread(const char* name); Static method to find a thread by name. TThread * Self(); Static method returning pointer to current thread. Long_t Join(void** ret = 0); Join this thread. Long_t Join(Long_t id, void** ret = 0); Static method to join a thread by id. Long_t SelfId(); Static method returning the id for the current thread. Int_t Run(void* arg = 0); Start the thread. This starts the static",MatchSource.WIKI,root/html534/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TThread.html
https://root.cern/root/html534/TThread.html:10144,Safety,safe,safe,10144,"l Run(). TThread(TThread::VoidRtnFunc_t fn, void* arg = 0, TThread::EPriority pri = kNormalPriority); Create a detached thread. Specify the function or static class method; to be executed by the thread and a pointer to the argument structure.; To start the thread call Run(). TThread(const char* thname, TThread::VoidRtnFunc_t fn, void* arg = 0, TThread::EPriority pri = kNormalPriority); Create thread with a name. Specify the function or static class method; to be executed by the thread and a pointer to the argument structure.; The user function should return a void*. To start the thread call Run(). TThread(const char* thname, TThread::VoidRtnFunc_t fn, void* arg = 0, TThread::EPriority pri = kNormalPriority); Create a detached thread with a name. Specify the function or static; class method to be executed by the thread and a pointer to the argument; structure. To start the thread call Run(). void Initialize(); Initialize the Thread package. This initializes the TThread and ROOT; global mutexes to make parts of ROOT thread safe/aware. This call is; implicit in case a TThread is created. Bool_t IsInitialized(); Return true, if the TThread objects have been initialize. If false,; the process is (from ROOT's point of view) single threaded. void Init(); Initialize global state and variables once. void Constructor(); Common thread constructor. ~TThread(); Cleanup the thread. Int_t Delete(TThread*& th); Static method to delete the specified thread.; Returns -1 in case the thread was running and has been killed. Returns; 0 in case the thread has been Delete and Cleaned up. The th pointer is; not valid anymore in that case. Int_t Exists(); Static method to check if threads exist.; Returns the number of running threads. void SetPriority(TThread::EPriority pri); Set thread priority. TThread * GetThread(Long_t id); Static method to find a thread by id. TThread * GetThread(const char* name); Static method to find a thread by name. TThread * Self(); Static method returning pointer ",MatchSource.WIKI,root/html534/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TThread.html
https://root.cern/root/html534/TThread.html:14280,Safety,safe,safe,14280,"s the execution of the calling thread. Int_t Sleep(ULong_t secs, ULong_t nanos = 0); Static method to sleep the calling thread. Int_t GetTime(ULong_t* absSec, ULong_t* absNanoSec); Static method to get the current time. Returns; the number of seconds. Int_t Lock(); Static method to lock the main thread mutex. Int_t TryLock(); Static method to try to lock the main thread mutex. Int_t UnLock(); Static method to unlock the main thread mutex. void * Function(void* ptr); Static method which is called by the system thread function and; which in turn calls the actual user function. void Ps(); Static method listing the existing threads. void ** Tsd(void* dflt, Int_t k); Static method returning a pointer to thread specific data container; of the calling thread.; k should be between 0 and kMaxUserThreadSlot for user application.; (and between kMaxUserThreadSlot and kMaxThreadSlot for ROOT libraries).; See ROOT::EThreadSlotReservation. void Printf(const char *va_(fmt), ...); Static method providing a thread safe printf. Appends a newline. void ErrorHandler(int level, const char* location, const char* fmt, va_list ap) const; Thread specific error handler function.; It calls the user set error handler in the main thread. void DoError(Int_t level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler. User has to specify the class name as; part of the location, just like for the global Info(), Warning() and; Error() functions. Int_t XARequest(const char* xact, Int_t nb, void** ar, Int_t* iret); Static method used to allow commands to be executed by the main thread. void XAction(); Static method called via the thread timer to execute in the main; thread certain commands. This to avoid sophisticated locking and; possible deadlocking. void SetComment(const char* txt = 0). TThread& operator=(const TThread& ). void Delete(Option_t* option = """"); { TObject::Delete(option); }. EPriority GetPriority() const; { return fPriority; }. EState GetState() const; { ",MatchSource.WIKI,root/html534/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TThread.html
https://root.cern/root/html534/TThread.html:14991,Safety,avoid,avoid,14991,"tic method to unlock the main thread mutex. void * Function(void* ptr); Static method which is called by the system thread function and; which in turn calls the actual user function. void Ps(); Static method listing the existing threads. void ** Tsd(void* dflt, Int_t k); Static method returning a pointer to thread specific data container; of the calling thread.; k should be between 0 and kMaxUserThreadSlot for user application.; (and between kMaxUserThreadSlot and kMaxThreadSlot for ROOT libraries).; See ROOT::EThreadSlotReservation. void Printf(const char *va_(fmt), ...); Static method providing a thread safe printf. Appends a newline. void ErrorHandler(int level, const char* location, const char* fmt, va_list ap) const; Thread specific error handler function.; It calls the user set error handler in the main thread. void DoError(Int_t level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler. User has to specify the class name as; part of the location, just like for the global Info(), Warning() and; Error() functions. Int_t XARequest(const char* xact, Int_t nb, void** ar, Int_t* iret); Static method used to allow commands to be executed by the main thread. void XAction(); Static method called via the thread timer to execute in the main; thread certain commands. This to avoid sophisticated locking and; possible deadlocking. void SetComment(const char* txt = 0). TThread& operator=(const TThread& ). void Delete(Option_t* option = """"); { TObject::Delete(option); }. EPriority GetPriority() const; { return fPriority; }. EState GetState() const; { return fState; }. Long_t GetId() const; { return fId; }. void ps(); { Ps(); }. » Author: Fons Rademakers 02/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id$ » Last generated: 2015-03-15 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TThread.html
https://root.cern/root/html534/TThreadFactory.html:577,Availability,avail,available,577,". TThreadFactory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TThreadFactory. class TThreadFactory: public TNamed. TThreadFactory. This ABC is a factory for thread components. Depending on which; factory is active one gets either Posix or Win32 threads. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TThreadFactory(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual TConditionImp*CreateConditionImp(TMutexImp* m); virtual TMutexImp*CreateMutexImp(Bool_t recursive); virtual TThreadImp*CreateThreadImp(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TOb",MatchSource.WIKI,root/html534/TThreadFactory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TThreadFactory.html
https://root.cern/root/html534/TThreadFactory.html:1697,Availability,error,error,1697,"voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual TConditionImp*CreateConditionImp(TMutexImp* m); virtual TMutexImp*CreateMutexImp(Bool_t recursive); virtual TThreadImp*CreateThreadImp(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObj",MatchSource.WIKI,root/html534/TThreadFactory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TThreadFactory.html
https://root.cern/root/html534/TThreadFactory.html:1781,Availability,error,error,1781," b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual TConditionImp*CreateConditionImp(TMutexImp* m); virtual TMutexImp*CreateMutexImp(Bool_t recursive); virtual TThreadImp*CreateThreadImp(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(",MatchSource.WIKI,root/html534/TThreadFactory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TThreadFactory.html
https://root.cern/root/html534/TThreadImp.html:671,Availability,avail,available,671,". TThreadImp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TThreadImp. class TThreadImp: public TObject. TThreadImp. This class implements threads. A thread is an execution environment; much lighter than a process. A single process can have multiple; threads. The actual work is done via the TThreadImp class (either; TPosixThread or TWin32Thread). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TThreadImp(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Int_tCancelPoint(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(void** main); virtual Int_tCleanUpPop(void** main, Int_t exe); virtual Int_tCleanUpPush(void** main, void* free, void* arg); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Int_tExit(void* ",MatchSource.WIKI,root/html534/TThreadImp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TThreadImp.html
https://root.cern/root/html534/TThreadImp.html:1813,Availability,error,error,1813,"ion_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Int_tCancelPoint(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(void** main); virtual Int_tCleanUpPop(void** main, Int_t exe); virtual Int_tCleanUpPush(void** main, void* free, void* arg); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Int_tExit(void* ret); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsF",MatchSource.WIKI,root/html534/TThreadImp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TThreadImp.html
https://root.cern/root/html534/TThreadImp.html:1897,Availability,error,error,1897,"int(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(void** main); virtual Int_tCleanUpPop(void** main, Int_t exe); virtual Int_tCleanUpPush(void** main, void* free, void* arg); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Int_tExit(void* ret); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* ",MatchSource.WIKI,root/html534/TThreadImp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TThreadImp.html
https://root.cern/root/html534/TTimer.html:4986,Availability,error,error,4986,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TTimeGetAbsTime() const; const char*GetCommand() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; TObject*GetObject(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TTimeGetTime() const; UInt_tGetTimerID(); virtual const char*TObject::GetTitle() const; virtual UInt_t",MatchSource.WIKI,root/html534/TTimer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTimer.html
https://root.cern/root/html534/TTimer.html:5070,Availability,error,error,5070,"t(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TTimeGetAbsTime() const; const char*GetCommand() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; TObject*GetObject(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TTimeGetTime() const; UInt_tGetTimerID(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); vir",MatchSource.WIKI,root/html534/TTimer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTimer.html
https://root.cern/root/html534/TTimer.html:1064,Safety,timeout,timeout,1064,"file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TTimer. class TTimer: public TSysEvtHandler. TTimer. Handles synchronous and a-synchronous timer events.; 1. synchronous timer is registered into TSystem and is processed; within the standard ROOT event-loop.; 2. asynchronous timer is passed to the operating system which sends; an external signal to ROOT and thus interrupts its event-loop. You can use this class in one of the following ways:; - Sub-class TTimer and override the Notify() method.; - Re-implement the TObject::HandleTimer() method in your class; and pass a pointer to this object to timer, see the SetObject(); method.; - Pass an interpreter command to timer, see SetCommand() method.; - Create a TTimer, connect its Timeout() signal to the; appropriate methods. Then when the time is up it will emit a; Timeout() signal and call connected slots. Minimum timeout interval is defined in TSystem::ESysConstants as; kItimerResolution (currently 10 ms). Signal/slots example:; TTimer *timer = new TTimer();; timer->Connect(""Timeout()"", ""myObjectClassName"",; myObject, ""TimerDone()"");; timer->Start(2000, kTRUE); // 2 seconds single-shot. To emit the Timeout signal repeadetly with minimum timeout:; timer->Start(0, kFALSE);. Function Members (Methods); public:. TTimer(Long_t milliSec = 0, Bool_t mode = kTRUE); TTimer(TObject* obj, Long_t milliSec, Bool_t mode = kTRUE); TTimer(const char* command, Long_t milliSec, Bool_t mode = kTRUE); virtual~TTimer(); voidTObject::AbstractMethod(const char* method) const; voidTSysEvtHandler::Activate(); virtual voidTSysEvtHandler::Activated()SIGNAL ; virtual voidAdd(); virtual voidTSysEvtHandler::Added()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual void",MatchSource.WIKI,root/html534/TTimer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTimer.html
https://root.cern/root/html534/TTimer.html:1394,Safety,timeout,timeout,1394,"o TSystem and is processed; within the standard ROOT event-loop.; 2. asynchronous timer is passed to the operating system which sends; an external signal to ROOT and thus interrupts its event-loop. You can use this class in one of the following ways:; - Sub-class TTimer and override the Notify() method.; - Re-implement the TObject::HandleTimer() method in your class; and pass a pointer to this object to timer, see the SetObject(); method.; - Pass an interpreter command to timer, see SetCommand() method.; - Create a TTimer, connect its Timeout() signal to the; appropriate methods. Then when the time is up it will emit a; Timeout() signal and call connected slots. Minimum timeout interval is defined in TSystem::ESysConstants as; kItimerResolution (currently 10 ms). Signal/slots example:; TTimer *timer = new TTimer();; timer->Connect(""Timeout()"", ""myObjectClassName"",; myObject, ""TimerDone()"");; timer->Start(2000, kTRUE); // 2 seconds single-shot. To emit the Timeout signal repeadetly with minimum timeout:; timer->Start(0, kFALSE);. Function Members (Methods); public:. TTimer(Long_t milliSec = 0, Bool_t mode = kTRUE); TTimer(TObject* obj, Long_t milliSec, Bool_t mode = kTRUE); TTimer(const char* command, Long_t milliSec, Bool_t mode = kTRUE); virtual~TTimer(); voidTObject::AbstractMethod(const char* method) const; voidTSysEvtHandler::Activate(); virtual voidTSysEvtHandler::Activated()SIGNAL ; virtual voidAdd(); virtual voidTSysEvtHandler::Added()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; Bool_tCheckTimer(const TTime& now); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const ch",MatchSource.WIKI,root/html534/TTimer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTimer.html
https://root.cern/root/html534/TTimer.html:11612,Safety,timeout,timeout,11612," kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TTimefAbsTimeabsolute time out time in ms; TStringfCommandinterpreter command to be executed; Bool_tfIntSyscallstrue is a-synchronous timer is to interrupt system calls; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TObject*fObjectobject to be notified (if any); Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tfSynctrue if synchrounous timer; TTimefTimetime out time in ms; UInt_tfTimeIDthe system ID of this timer (for WIN32); Bool_tfTimeouttrue if timer has timed out; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTimer(Long_t milliSec = 0, Bool_t mode = kTRUE); Create timer that times out in ms milliseconds. If milliSec is 0; then the timeout will be the minimum timeout (see TSystem::ESysConstants,; i.e. 10 ms). If mode == kTRUE then the timer is synchronous else; a-synchronous. The default is synchronous. Add a timer to the system; eventloop by calling TurnOn(). Set command to be executed from Notify(); or set the object whose HandleTimer() method will be called via Notify(),; derive from TTimer and override Notify() or connect slots to the; signals Timeout(), TurnOn() and TurnOff(). TTimer(TObject* obj, Long_t milliSec, Bool_t mode = kTRUE); Create timer that times out in ms milliseconds. If mode == kTRUE then; the timer is synchronous else a-synchronous. The default is synchronous.; Add a timer to the system eventloop by calling TurnOn().; The object's HandleTimer() will be called by Notify(). TTimer(const char* command, Long_t milliSec, Bool_t mode = kTRUE); Create timer that times out in ms milliseconds. If mode == kTRUE then; the timer is synchronous else a-synchronous. The default is synchronous.; Add a timer to the system event",MatchSource.WIKI,root/html534/TTimer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTimer.html
https://root.cern/root/html534/TTimer.html:11640,Safety,timeout,timeout,11640," kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TTimefAbsTimeabsolute time out time in ms; TStringfCommandinterpreter command to be executed; Bool_tfIntSyscallstrue is a-synchronous timer is to interrupt system calls; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TObject*fObjectobject to be notified (if any); Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tfSynctrue if synchrounous timer; TTimefTimetime out time in ms; UInt_tfTimeIDthe system ID of this timer (for WIN32); Bool_tfTimeouttrue if timer has timed out; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTimer(Long_t milliSec = 0, Bool_t mode = kTRUE); Create timer that times out in ms milliseconds. If milliSec is 0; then the timeout will be the minimum timeout (see TSystem::ESysConstants,; i.e. 10 ms). If mode == kTRUE then the timer is synchronous else; a-synchronous. The default is synchronous. Add a timer to the system; eventloop by calling TurnOn(). Set command to be executed from Notify(); or set the object whose HandleTimer() method will be called via Notify(),; derive from TTimer and override Notify() or connect slots to the; signals Timeout(), TurnOn() and TurnOff(). TTimer(TObject* obj, Long_t milliSec, Bool_t mode = kTRUE); Create timer that times out in ms milliseconds. If mode == kTRUE then; the timer is synchronous else a-synchronous. The default is synchronous.; Add a timer to the system eventloop by calling TurnOn().; The object's HandleTimer() will be called by Notify(). TTimer(const char* command, Long_t milliSec, Bool_t mode = kTRUE); Create timer that times out in ms milliseconds. If mode == kTRUE then; the timer is synchronous else a-synchronous. The default is synchronous.; Add a timer to the system event",MatchSource.WIKI,root/html534/TTimer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTimer.html
https://root.cern/root/html534/TTimer.html:13528,Safety,timeout,timeout,13528,"TRUE then; the timer is synchronous else a-synchronous. The default is synchronous.; Add a timer to the system eventloop by calling TurnOn().; The interpreter will execute command from Notify(). Bool_t CheckTimer(const TTime& now); Check if timer timed out. Bool_t Notify(); Notify when timer times out. The timer is always reset. To stop; the timer call TurnOff(). Make sure to call Reset() also in derived; Notify() so timers will keep working repeatedly. void Reset(); Reset the timer. void SetCommand(const char* command); Set the interpreter command to be executed at time out. Removes the; object to be notified (if it was set). void SetObject(TObject* object); Set the object to be notified at time out. Removes the command to; be executed (if it was set). void SetInterruptSyscalls(Bool_t set = kTRUE); When the argument is true the a-synchronous timer (SIGALRM) signal; handler is set so that interrupted syscalls will not be restarted; by the kernel. This is typically used in case one wants to put a; timeout on an I/O operation. By default interrupted syscalls will; be restarted. void Start(Long_t milliSec = -1, Bool_t singleShot = kFALSE); Starts the timer with a milliSec timeout. If milliSec is 0; then the timeout will be the minimum timeout (see TSystem::ESysConstants,; i.e. 10 ms), if milliSec is -1 then the time interval as previously; specified (in ctor or SetTime()) will be used.; If singleShot is kTRUE, the timer will be activated only once,; otherwise it will continue until it is stopped.; See also TurnOn(), Stop(), TurnOff(). void TurnOff(); Remove timer from system timer list. This requires that a timer; has been placed in the system timer list (using TurnOn()).; If a TTimer subclass is placed on another list, override TurnOff() to; remove the timer from the correct list. void TurnOn(); Add the timer to the system timer list. If a TTimer subclass has to be; placed on another list, override TurnOn() to add the timer to the correct; list. void SingleShot(Int_t ",MatchSource.WIKI,root/html534/TTimer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTimer.html
https://root.cern/root/html534/TTimer.html:13704,Safety,timeout,timeout,13704,"he interpreter will execute command from Notify(). Bool_t CheckTimer(const TTime& now); Check if timer timed out. Bool_t Notify(); Notify when timer times out. The timer is always reset. To stop; the timer call TurnOff(). Make sure to call Reset() also in derived; Notify() so timers will keep working repeatedly. void Reset(); Reset the timer. void SetCommand(const char* command); Set the interpreter command to be executed at time out. Removes the; object to be notified (if it was set). void SetObject(TObject* object); Set the object to be notified at time out. Removes the command to; be executed (if it was set). void SetInterruptSyscalls(Bool_t set = kTRUE); When the argument is true the a-synchronous timer (SIGALRM) signal; handler is set so that interrupted syscalls will not be restarted; by the kernel. This is typically used in case one wants to put a; timeout on an I/O operation. By default interrupted syscalls will; be restarted. void Start(Long_t milliSec = -1, Bool_t singleShot = kFALSE); Starts the timer with a milliSec timeout. If milliSec is 0; then the timeout will be the minimum timeout (see TSystem::ESysConstants,; i.e. 10 ms), if milliSec is -1 then the time interval as previously; specified (in ctor or SetTime()) will be used.; If singleShot is kTRUE, the timer will be activated only once,; otherwise it will continue until it is stopped.; See also TurnOn(), Stop(), TurnOff(). void TurnOff(); Remove timer from system timer list. This requires that a timer; has been placed in the system timer list (using TurnOn()).; If a TTimer subclass is placed on another list, override TurnOff() to; remove the timer from the correct list. void TurnOn(); Add the timer to the system timer list. If a TTimer subclass has to be; placed on another list, override TurnOn() to add the timer to the correct; list. void SingleShot(Int_t milliSec, const char* receiver_class, void* receiver, const char* method); This static function calls a slot after a given time interval.; Creat",MatchSource.WIKI,root/html534/TTimer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTimer.html
https://root.cern/root/html534/TTimer.html:13740,Safety,timeout,timeout,13740,"er timed out. Bool_t Notify(); Notify when timer times out. The timer is always reset. To stop; the timer call TurnOff(). Make sure to call Reset() also in derived; Notify() so timers will keep working repeatedly. void Reset(); Reset the timer. void SetCommand(const char* command); Set the interpreter command to be executed at time out. Removes the; object to be notified (if it was set). void SetObject(TObject* object); Set the object to be notified at time out. Removes the command to; be executed (if it was set). void SetInterruptSyscalls(Bool_t set = kTRUE); When the argument is true the a-synchronous timer (SIGALRM) signal; handler is set so that interrupted syscalls will not be restarted; by the kernel. This is typically used in case one wants to put a; timeout on an I/O operation. By default interrupted syscalls will; be restarted. void Start(Long_t milliSec = -1, Bool_t singleShot = kFALSE); Starts the timer with a milliSec timeout. If milliSec is 0; then the timeout will be the minimum timeout (see TSystem::ESysConstants,; i.e. 10 ms), if milliSec is -1 then the time interval as previously; specified (in ctor or SetTime()) will be used.; If singleShot is kTRUE, the timer will be activated only once,; otherwise it will continue until it is stopped.; See also TurnOn(), Stop(), TurnOff(). void TurnOff(); Remove timer from system timer list. This requires that a timer; has been placed in the system timer list (using TurnOn()).; If a TTimer subclass is placed on another list, override TurnOff() to; remove the timer from the correct list. void TurnOn(); Add the timer to the system timer list. If a TTimer subclass has to be; placed on another list, override TurnOn() to add the timer to the correct; list. void SingleShot(Int_t milliSec, const char* receiver_class, void* receiver, const char* method); This static function calls a slot after a given time interval.; Created internal timer will be deleted after that. TTimer(const TTimer& ). TTimer& operator=(const TTimer",MatchSource.WIKI,root/html534/TTimer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTimer.html
https://root.cern/root/html534/TTimer.html:13768,Safety,timeout,timeout,13768,"er timed out. Bool_t Notify(); Notify when timer times out. The timer is always reset. To stop; the timer call TurnOff(). Make sure to call Reset() also in derived; Notify() so timers will keep working repeatedly. void Reset(); Reset the timer. void SetCommand(const char* command); Set the interpreter command to be executed at time out. Removes the; object to be notified (if it was set). void SetObject(TObject* object); Set the object to be notified at time out. Removes the command to; be executed (if it was set). void SetInterruptSyscalls(Bool_t set = kTRUE); When the argument is true the a-synchronous timer (SIGALRM) signal; handler is set so that interrupted syscalls will not be restarted; by the kernel. This is typically used in case one wants to put a; timeout on an I/O operation. By default interrupted syscalls will; be restarted. void Start(Long_t milliSec = -1, Bool_t singleShot = kFALSE); Starts the timer with a milliSec timeout. If milliSec is 0; then the timeout will be the minimum timeout (see TSystem::ESysConstants,; i.e. 10 ms), if milliSec is -1 then the time interval as previously; specified (in ctor or SetTime()) will be used.; If singleShot is kTRUE, the timer will be activated only once,; otherwise it will continue until it is stopped.; See also TurnOn(), Stop(), TurnOff(). void TurnOff(); Remove timer from system timer list. This requires that a timer; has been placed in the system timer list (using TurnOn()).; If a TTimer subclass is placed on another list, override TurnOff() to; remove the timer from the correct list. void TurnOn(); Add the timer to the system timer list. If a TTimer subclass has to be; placed on another list, override TurnOn() to add the timer to the correct; list. void SingleShot(Int_t milliSec, const char* receiver_class, void* receiver, const char* method); This static function calls a slot after a given time interval.; Created internal timer will be deleted after that. TTimer(const TTimer& ). TTimer& operator=(const TTimer",MatchSource.WIKI,root/html534/TTimer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTimer.html
https://root.cern/root/html534/TTimeStamp.html:5438,Availability,error,error,5438," 8*60*60;; TTimeStamp(year,month,day,hour,min,sec,nsec,kTRUE,8*60*60);. TTimeStamp(UInt_t date, UInt_t time, UInt_t nsec, Bool_t isUTC = kTRUE, Int_t secOffset = 0); Create a TTimeStamp and set it to the specified date, time, nanosec.; If !isUTC then it is assumed to be the standard local time zone. TTimeStamp(UInt_t tloc, Bool_t isUTC = kTRUE, Int_t secOffset = 0, Bool_t dosDate = kFALSE); Create a TTimeStamp and set it to tloc which must be a time_t value; returned by time(). This value is the number of seconds since the EPOCH; (i.e. 00:00:00 on Jan 1m 1970). If dosDate is true then the input; is a dosDate value. Double_t AsGMST(Double_t UT1Offset = 0) const; Return Greenwich mean sidereal time (GMST) in hour-angle. Return value; will always be between 0 and 24 (hours). Sidereal time is most accurately; calculated from UT1. If fSec and fNanoSec are in UTC (which they are by; default), the optional argument UT1Offset can be supplied (in; milliseconds). If UT1Offset is not supplied, conversion has maximum error; of 1s. If offset is supplied error can be reduced to us level. Values for; UT1Offset can be found in IERS Bulletin B:; ftp://ftp.iers.org/products/eop/bulletinb/format_2009; The conversion to sidereal time used here is given by; Aoki et. al. Astron. Astrophys. 105, 359-362 (1982); http://adsabs.harvard.edu/abs/1982A%26A...105..359A. Double_t AsGAST(Double_t UT1Offset = 0) const; Return Greenwich apparant sidereal time (GAST) in hour-angle. Return; value will always be between 0 and 24 (hours). Sidereal time is most; accurately calculated from UT1. If fSec and fNanoSec are in UTC (which; they are by default), the optional argument UT1Offset can be supplied (in; milliseconds). If UT1Offset is not supplied, conversion has maximum error; of 1s. If offset is supplied error can be reduced to us level. Values for; UT1Offset can be found in IERS Bulletin B:; ftp://ftp.iers.org/products/eop/bulletinb/format_2009; Equation of the equinoxes is given by USNO:; http://aa.",MatchSource.WIKI,root/html534/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTimeStamp.html
https://root.cern/root/html534/TTimeStamp.html:5474,Availability,error,error,5474,"*60*60);. TTimeStamp(UInt_t date, UInt_t time, UInt_t nsec, Bool_t isUTC = kTRUE, Int_t secOffset = 0); Create a TTimeStamp and set it to the specified date, time, nanosec.; If !isUTC then it is assumed to be the standard local time zone. TTimeStamp(UInt_t tloc, Bool_t isUTC = kTRUE, Int_t secOffset = 0, Bool_t dosDate = kFALSE); Create a TTimeStamp and set it to tloc which must be a time_t value; returned by time(). This value is the number of seconds since the EPOCH; (i.e. 00:00:00 on Jan 1m 1970). If dosDate is true then the input; is a dosDate value. Double_t AsGMST(Double_t UT1Offset = 0) const; Return Greenwich mean sidereal time (GMST) in hour-angle. Return value; will always be between 0 and 24 (hours). Sidereal time is most accurately; calculated from UT1. If fSec and fNanoSec are in UTC (which they are by; default), the optional argument UT1Offset can be supplied (in; milliseconds). If UT1Offset is not supplied, conversion has maximum error; of 1s. If offset is supplied error can be reduced to us level. Values for; UT1Offset can be found in IERS Bulletin B:; ftp://ftp.iers.org/products/eop/bulletinb/format_2009; The conversion to sidereal time used here is given by; Aoki et. al. Astron. Astrophys. 105, 359-362 (1982); http://adsabs.harvard.edu/abs/1982A%26A...105..359A. Double_t AsGAST(Double_t UT1Offset = 0) const; Return Greenwich apparant sidereal time (GAST) in hour-angle. Return; value will always be between 0 and 24 (hours). Sidereal time is most; accurately calculated from UT1. If fSec and fNanoSec are in UTC (which; they are by default), the optional argument UT1Offset can be supplied (in; milliseconds). If UT1Offset is not supplied, conversion has maximum error; of 1s. If offset is supplied error can be reduced to us level. Values for; UT1Offset can be found in IERS Bulletin B:; ftp://ftp.iers.org/products/eop/bulletinb/format_2009; Equation of the equinoxes is given by USNO:; http://aa.usno.navy.mil/faq/docs/GAST.php. Double_t AsLMST(Double_t Lon",MatchSource.WIKI,root/html534/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTimeStamp.html
https://root.cern/root/html534/TTimeStamp.html:6182,Availability,error,error,6182,"ll always be between 0 and 24 (hours). Sidereal time is most accurately; calculated from UT1. If fSec and fNanoSec are in UTC (which they are by; default), the optional argument UT1Offset can be supplied (in; milliseconds). If UT1Offset is not supplied, conversion has maximum error; of 1s. If offset is supplied error can be reduced to us level. Values for; UT1Offset can be found in IERS Bulletin B:; ftp://ftp.iers.org/products/eop/bulletinb/format_2009; The conversion to sidereal time used here is given by; Aoki et. al. Astron. Astrophys. 105, 359-362 (1982); http://adsabs.harvard.edu/abs/1982A%26A...105..359A. Double_t AsGAST(Double_t UT1Offset = 0) const; Return Greenwich apparant sidereal time (GAST) in hour-angle. Return; value will always be between 0 and 24 (hours). Sidereal time is most; accurately calculated from UT1. If fSec and fNanoSec are in UTC (which; they are by default), the optional argument UT1Offset can be supplied (in; milliseconds). If UT1Offset is not supplied, conversion has maximum error; of 1s. If offset is supplied error can be reduced to us level. Values for; UT1Offset can be found in IERS Bulletin B:; ftp://ftp.iers.org/products/eop/bulletinb/format_2009; Equation of the equinoxes is given by USNO:; http://aa.usno.navy.mil/faq/docs/GAST.php. Double_t AsLMST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local mean sidereal time (LMST) in hour-angle, given a longitude; in degrees. Return value will always be between 0 and 24 (hours).; Sidereal time is most accurately calculated from UT1. If fSec and; fNanoSec are in UTC (which they are by default), the optional argument; UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. Double_t AsLAST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local appara",MatchSource.WIKI,root/html534/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTimeStamp.html
https://root.cern/root/html534/TTimeStamp.html:6218,Availability,error,error,6218,"ccurately; calculated from UT1. If fSec and fNanoSec are in UTC (which they are by; default), the optional argument UT1Offset can be supplied (in; milliseconds). If UT1Offset is not supplied, conversion has maximum error; of 1s. If offset is supplied error can be reduced to us level. Values for; UT1Offset can be found in IERS Bulletin B:; ftp://ftp.iers.org/products/eop/bulletinb/format_2009; The conversion to sidereal time used here is given by; Aoki et. al. Astron. Astrophys. 105, 359-362 (1982); http://adsabs.harvard.edu/abs/1982A%26A...105..359A. Double_t AsGAST(Double_t UT1Offset = 0) const; Return Greenwich apparant sidereal time (GAST) in hour-angle. Return; value will always be between 0 and 24 (hours). Sidereal time is most; accurately calculated from UT1. If fSec and fNanoSec are in UTC (which; they are by default), the optional argument UT1Offset can be supplied (in; milliseconds). If UT1Offset is not supplied, conversion has maximum error; of 1s. If offset is supplied error can be reduced to us level. Values for; UT1Offset can be found in IERS Bulletin B:; ftp://ftp.iers.org/products/eop/bulletinb/format_2009; Equation of the equinoxes is given by USNO:; http://aa.usno.navy.mil/faq/docs/GAST.php. Double_t AsLMST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local mean sidereal time (LMST) in hour-angle, given a longitude; in degrees. Return value will always be between 0 and 24 (hours).; Sidereal time is most accurately calculated from UT1. If fSec and; fNanoSec are in UTC (which they are by default), the optional argument; UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. Double_t AsLAST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local apparant sidereal time (LAST) in hour-angle, given a; longitude in ",MatchSource.WIKI,root/html534/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTimeStamp.html
https://root.cern/root/html534/TTimeStamp.html:6896,Availability,error,error,6896,"in hour-angle. Return; value will always be between 0 and 24 (hours). Sidereal time is most; accurately calculated from UT1. If fSec and fNanoSec are in UTC (which; they are by default), the optional argument UT1Offset can be supplied (in; milliseconds). If UT1Offset is not supplied, conversion has maximum error; of 1s. If offset is supplied error can be reduced to us level. Values for; UT1Offset can be found in IERS Bulletin B:; ftp://ftp.iers.org/products/eop/bulletinb/format_2009; Equation of the equinoxes is given by USNO:; http://aa.usno.navy.mil/faq/docs/GAST.php. Double_t AsLMST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local mean sidereal time (LMST) in hour-angle, given a longitude; in degrees. Return value will always be between 0 and 24 (hours).; Sidereal time is most accurately calculated from UT1. If fSec and; fNanoSec are in UTC (which they are by default), the optional argument; UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. Double_t AsLAST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local apparant sidereal time (LAST) in hour-angle, given a; longitude in degrees. Return value will always be between 0 and 24; (hours). Sidereal time is most accurately calculated from UT1. If fSec; and fNanoSec are in UTC (which they are by default), the optional; argument UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. const Char_t * AsString(Option_t* option = """") const; Return the date & time as a string. Result is pointer to a statically allocated string.; User should copy this into ",MatchSource.WIKI,root/html534/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTimeStamp.html
https://root.cern/root/html534/TTimeStamp.html:6931,Availability,error,error,6931,"hours). Sidereal time is most; accurately calculated from UT1. If fSec and fNanoSec are in UTC (which; they are by default), the optional argument UT1Offset can be supplied (in; milliseconds). If UT1Offset is not supplied, conversion has maximum error; of 1s. If offset is supplied error can be reduced to us level. Values for; UT1Offset can be found in IERS Bulletin B:; ftp://ftp.iers.org/products/eop/bulletinb/format_2009; Equation of the equinoxes is given by USNO:; http://aa.usno.navy.mil/faq/docs/GAST.php. Double_t AsLMST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local mean sidereal time (LMST) in hour-angle, given a longitude; in degrees. Return value will always be between 0 and 24 (hours).; Sidereal time is most accurately calculated from UT1. If fSec and; fNanoSec are in UTC (which they are by default), the optional argument; UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. Double_t AsLAST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local apparant sidereal time (LAST) in hour-angle, given a; longitude in degrees. Return value will always be between 0 and 24; (hours). Sidereal time is most accurately calculated from UT1. If fSec; and fNanoSec are in UTC (which they are by default), the optional; argument UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. const Char_t * AsString(Option_t* option = """") const; Return the date & time as a string. Result is pointer to a statically allocated string.; User should copy this into their own buffer before calling; this method again. Option ""l""",MatchSource.WIKI,root/html534/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTimeStamp.html
https://root.cern/root/html534/TTimeStamp.html:7525,Availability,error,error,7525,"et = 0) const; Return local mean sidereal time (LMST) in hour-angle, given a longitude; in degrees. Return value will always be between 0 and 24 (hours).; Sidereal time is most accurately calculated from UT1. If fSec and; fNanoSec are in UTC (which they are by default), the optional argument; UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. Double_t AsLAST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local apparant sidereal time (LAST) in hour-angle, given a; longitude in degrees. Return value will always be between 0 and 24; (hours). Sidereal time is most accurately calculated from UT1. If fSec; and fNanoSec are in UTC (which they are by default), the optional; argument UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. const Char_t * AsString(Option_t* option = """") const; Return the date & time as a string. Result is pointer to a statically allocated string.; User should copy this into their own buffer before calling; this method again. Option ""l"" returns it in local zone format; (can be applied to default or compact format). Default format is RFC822 compliant:; ""Mon, 02 Jan 2001 18:11:12 +0000 (GMT) +999999999 nsec""; ""Mon, 02 Jan 2001 10:11:12 -0800 (PST) +999999999 nsec"". Option ""c"" compact is (almost) ISO 8601 compliant:; ""2001-01-02 18:11:12.9999999999Z""; ""2001-01-02 10:11:12.9999999999-0800"" if PST; * uses ""-"" as date separator as specified in ISO 8601; * uses ""."" rather than preferred "","" for decimal separator; * -HHMM is the difference between local and UTC (if behind, + if ahead).; The ""-HHMM"" i",MatchSource.WIKI,root/html534/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTimeStamp.html
https://root.cern/root/html534/TTimeStamp.html:7560,Availability,error,error,7560,"angle, given a longitude; in degrees. Return value will always be between 0 and 24 (hours).; Sidereal time is most accurately calculated from UT1. If fSec and; fNanoSec are in UTC (which they are by default), the optional argument; UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. Double_t AsLAST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local apparant sidereal time (LAST) in hour-angle, given a; longitude in degrees. Return value will always be between 0 and 24; (hours). Sidereal time is most accurately calculated from UT1. If fSec; and fNanoSec are in UTC (which they are by default), the optional; argument UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. const Char_t * AsString(Option_t* option = """") const; Return the date & time as a string. Result is pointer to a statically allocated string.; User should copy this into their own buffer before calling; this method again. Option ""l"" returns it in local zone format; (can be applied to default or compact format). Default format is RFC822 compliant:; ""Mon, 02 Jan 2001 18:11:12 +0000 (GMT) +999999999 nsec""; ""Mon, 02 Jan 2001 10:11:12 -0800 (PST) +999999999 nsec"". Option ""c"" compact is (almost) ISO 8601 compliant:; ""2001-01-02 18:11:12.9999999999Z""; ""2001-01-02 10:11:12.9999999999-0800"" if PST; * uses ""-"" as date separator as specified in ISO 8601; * uses ""."" rather than preferred "","" for decimal separator; * -HHMM is the difference between local and UTC (if behind, + if ahead).; The ""-HHMM"" is replaced with ""Z"" if given as UTC.; To be strictly conformin",MatchSource.WIKI,root/html534/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTimeStamp.html
https://root.cern/root/html534/TTimeStamp.html:5487,Energy Efficiency,reduce,reduced,5487,"*60*60);. TTimeStamp(UInt_t date, UInt_t time, UInt_t nsec, Bool_t isUTC = kTRUE, Int_t secOffset = 0); Create a TTimeStamp and set it to the specified date, time, nanosec.; If !isUTC then it is assumed to be the standard local time zone. TTimeStamp(UInt_t tloc, Bool_t isUTC = kTRUE, Int_t secOffset = 0, Bool_t dosDate = kFALSE); Create a TTimeStamp and set it to tloc which must be a time_t value; returned by time(). This value is the number of seconds since the EPOCH; (i.e. 00:00:00 on Jan 1m 1970). If dosDate is true then the input; is a dosDate value. Double_t AsGMST(Double_t UT1Offset = 0) const; Return Greenwich mean sidereal time (GMST) in hour-angle. Return value; will always be between 0 and 24 (hours). Sidereal time is most accurately; calculated from UT1. If fSec and fNanoSec are in UTC (which they are by; default), the optional argument UT1Offset can be supplied (in; milliseconds). If UT1Offset is not supplied, conversion has maximum error; of 1s. If offset is supplied error can be reduced to us level. Values for; UT1Offset can be found in IERS Bulletin B:; ftp://ftp.iers.org/products/eop/bulletinb/format_2009; The conversion to sidereal time used here is given by; Aoki et. al. Astron. Astrophys. 105, 359-362 (1982); http://adsabs.harvard.edu/abs/1982A%26A...105..359A. Double_t AsGAST(Double_t UT1Offset = 0) const; Return Greenwich apparant sidereal time (GAST) in hour-angle. Return; value will always be between 0 and 24 (hours). Sidereal time is most; accurately calculated from UT1. If fSec and fNanoSec are in UTC (which; they are by default), the optional argument UT1Offset can be supplied (in; milliseconds). If UT1Offset is not supplied, conversion has maximum error; of 1s. If offset is supplied error can be reduced to us level. Values for; UT1Offset can be found in IERS Bulletin B:; ftp://ftp.iers.org/products/eop/bulletinb/format_2009; Equation of the equinoxes is given by USNO:; http://aa.usno.navy.mil/faq/docs/GAST.php. Double_t AsLMST(Double_t Lon",MatchSource.WIKI,root/html534/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTimeStamp.html
https://root.cern/root/html534/TTimeStamp.html:6231,Energy Efficiency,reduce,reduced,6231,"ccurately; calculated from UT1. If fSec and fNanoSec are in UTC (which they are by; default), the optional argument UT1Offset can be supplied (in; milliseconds). If UT1Offset is not supplied, conversion has maximum error; of 1s. If offset is supplied error can be reduced to us level. Values for; UT1Offset can be found in IERS Bulletin B:; ftp://ftp.iers.org/products/eop/bulletinb/format_2009; The conversion to sidereal time used here is given by; Aoki et. al. Astron. Astrophys. 105, 359-362 (1982); http://adsabs.harvard.edu/abs/1982A%26A...105..359A. Double_t AsGAST(Double_t UT1Offset = 0) const; Return Greenwich apparant sidereal time (GAST) in hour-angle. Return; value will always be between 0 and 24 (hours). Sidereal time is most; accurately calculated from UT1. If fSec and fNanoSec are in UTC (which; they are by default), the optional argument UT1Offset can be supplied (in; milliseconds). If UT1Offset is not supplied, conversion has maximum error; of 1s. If offset is supplied error can be reduced to us level. Values for; UT1Offset can be found in IERS Bulletin B:; ftp://ftp.iers.org/products/eop/bulletinb/format_2009; Equation of the equinoxes is given by USNO:; http://aa.usno.navy.mil/faq/docs/GAST.php. Double_t AsLMST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local mean sidereal time (LMST) in hour-angle, given a longitude; in degrees. Return value will always be between 0 and 24 (hours).; Sidereal time is most accurately calculated from UT1. If fSec and; fNanoSec are in UTC (which they are by default), the optional argument; UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. Double_t AsLAST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local apparant sidereal time (LAST) in hour-angle, given a; longitude in ",MatchSource.WIKI,root/html534/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTimeStamp.html
https://root.cern/root/html534/TTimeStamp.html:6945,Energy Efficiency,reduce,reduced,6945,"hours). Sidereal time is most; accurately calculated from UT1. If fSec and fNanoSec are in UTC (which; they are by default), the optional argument UT1Offset can be supplied (in; milliseconds). If UT1Offset is not supplied, conversion has maximum error; of 1s. If offset is supplied error can be reduced to us level. Values for; UT1Offset can be found in IERS Bulletin B:; ftp://ftp.iers.org/products/eop/bulletinb/format_2009; Equation of the equinoxes is given by USNO:; http://aa.usno.navy.mil/faq/docs/GAST.php. Double_t AsLMST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local mean sidereal time (LMST) in hour-angle, given a longitude; in degrees. Return value will always be between 0 and 24 (hours).; Sidereal time is most accurately calculated from UT1. If fSec and; fNanoSec are in UTC (which they are by default), the optional argument; UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. Double_t AsLAST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local apparant sidereal time (LAST) in hour-angle, given a; longitude in degrees. Return value will always be between 0 and 24; (hours). Sidereal time is most accurately calculated from UT1. If fSec; and fNanoSec are in UTC (which they are by default), the optional; argument UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. const Char_t * AsString(Option_t* option = """") const; Return the date & time as a string. Result is pointer to a statically allocated string.; User should copy this into their own buffer before calling; this method again. Option ""l""",MatchSource.WIKI,root/html534/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTimeStamp.html
https://root.cern/root/html534/TTimeStamp.html:7574,Energy Efficiency,reduce,reduced,7574,"angle, given a longitude; in degrees. Return value will always be between 0 and 24 (hours).; Sidereal time is most accurately calculated from UT1. If fSec and; fNanoSec are in UTC (which they are by default), the optional argument; UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. Double_t AsLAST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local apparant sidereal time (LAST) in hour-angle, given a; longitude in degrees. Return value will always be between 0 and 24; (hours). Sidereal time is most accurately calculated from UT1. If fSec; and fNanoSec are in UTC (which they are by default), the optional; argument UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. const Char_t * AsString(Option_t* option = """") const; Return the date & time as a string. Result is pointer to a statically allocated string.; User should copy this into their own buffer before calling; this method again. Option ""l"" returns it in local zone format; (can be applied to default or compact format). Default format is RFC822 compliant:; ""Mon, 02 Jan 2001 18:11:12 +0000 (GMT) +999999999 nsec""; ""Mon, 02 Jan 2001 10:11:12 -0800 (PST) +999999999 nsec"". Option ""c"" compact is (almost) ISO 8601 compliant:; ""2001-01-02 18:11:12.9999999999Z""; ""2001-01-02 10:11:12.9999999999-0800"" if PST; * uses ""-"" as date separator as specified in ISO 8601; * uses ""."" rather than preferred "","" for decimal separator; * -HHMM is the difference between local and UTC (if behind, + if ahead).; The ""-HHMM"" is replaced with ""Z"" if given as UTC.; To be strictly conformin",MatchSource.WIKI,root/html534/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTimeStamp.html
https://root.cern/root/html534/TTimeStamp.html:7829,Energy Efficiency,allocate,allocated,7829,"ed (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. Double_t AsLAST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local apparant sidereal time (LAST) in hour-angle, given a; longitude in degrees. Return value will always be between 0 and 24; (hours). Sidereal time is most accurately calculated from UT1. If fSec; and fNanoSec are in UTC (which they are by default), the optional; argument UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. const Char_t * AsString(Option_t* option = """") const; Return the date & time as a string. Result is pointer to a statically allocated string.; User should copy this into their own buffer before calling; this method again. Option ""l"" returns it in local zone format; (can be applied to default or compact format). Default format is RFC822 compliant:; ""Mon, 02 Jan 2001 18:11:12 +0000 (GMT) +999999999 nsec""; ""Mon, 02 Jan 2001 10:11:12 -0800 (PST) +999999999 nsec"". Option ""c"" compact is (almost) ISO 8601 compliant:; ""2001-01-02 18:11:12.9999999999Z""; ""2001-01-02 10:11:12.9999999999-0800"" if PST; * uses ""-"" as date separator as specified in ISO 8601; * uses ""."" rather than preferred "","" for decimal separator; * -HHMM is the difference between local and UTC (if behind, + if ahead).; The ""-HHMM"" is replaced with ""Z"" if given as UTC.; To be strictly conforming it should use ""T"" instead of the; blank separating the date and time. Option ""2"" returns as {sec,nsec} integers. Option ""s"" returns ""2001-01-02 18:11:12"" with an implied UTC,; overrides ""l"" option. Internally uses a circular list of buffers to avoid pr",MatchSource.WIKI,root/html534/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTimeStamp.html
https://root.cern/root/html534/TTimeStamp.html:12909,Integrability,rout,routine,12909," | 1970 2000 2001 .. 2037. ""year"" | 138...1969 | 1970 .. 2037 | ...; true | undefined | 1970 .. 2037 | undefined. void Set(Int_t date, Int_t time, Int_t nsec, Bool_t isUTC, Int_t secOffset); Set date/time from integers of the form [yy]YYMMDD and HHMMSS,; assume UTC (UTC) components:. MM: 01=January .. 12=December; DD: 01 .. 31. HH: 00=midnight .. 23; MM: 00 .. 59; SS: 00 .. 69. Date must be in format 980418 or 19980418; 1001127 or 20001127 (i.e. year 100 = 2000),; time must be in format 224512 (second precision),; date must be >= 700101. void Set(UInt_t tloc, Bool_t isUTC, Int_t secOffset, Bool_t dosDate); The input arg is a time_t value returned by time() or a value; returned by Convert(). This value is the number of seconds since; the EPOCH (i.e. 00:00:00 on Jan 1m 1970). If dosDate is true then; the input is a dosDate value. void NormalizeNanoSec(); Ensure that the fNanoSec field is in range [0,999999999]. time_t MktimeFromUTC(tm_t* tmstruct); Equivalent of standard routine ""mktime"" but; using the assumption that tm struct is filled with UTC, not local, time. This version *ISN'T* configured to handle every possible; weirdness of out-of-range values in the case of normalizing; the tm struct. This version *DOESN'T* correctly handle values that can't be; fit into a time_t (i.e. beyond year 2038-01-18 19:14:07, or; before the start of Epoch). Int_t GetDayOfYear(Int_t day, Int_t month, Int_t year); Get the day of the year represented by day, month and year.; Valid return values range between 1 and 366, where January 1 = 1. Int_t GetDayOfWeek(Int_t day, Int_t month, Int_t year); Method is using Zeller's formula for calculating the day number.; Valid return values range between 1 and 7, where Monday = 1. Int_t GetWeek(Int_t day, Int_t month, Int_t year); Get the week of the year. Valid week values are between 1 and 53.; The return value is the year*100+week (1 Jan may be in the last; week of the previous year so the year must be returned too). Bool_t IsLeapYear(Int_t ye",MatchSource.WIKI,root/html534/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTimeStamp.html
https://root.cern/root/html534/TTimeStamp.html:336,Modifiability,extend,extends,336,". TTimeStamp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TTimeStamp. class TTimeStamp. The TTimeStamp encapsulates seconds and ns since EPOCH. This extends (and isolates) struct timespec; struct timespec; {; time_t tv_sec; /* seconds *; long tv_nsec; /* nanoseconds *; }; time_t seconds is relative to Jan 1, 1970 00:00:00 UTC. No accounting of leap seconds is made. Due to ROOT/CINT limitations TTimeStamp does not explicitly; hold a timespec struct; attempting to do so means the Streamer; must be hand written. Instead we have chosen to simply contain; similar fields within the private area of this class. NOTE: the use of time_t (and its default implementation as a 32 int); implies overflow conditions occurs somewhere around; Jan 18, 19:14:07, 2038.; If this experiment is still going when it becomes significant; someone will have to deal with it. Function Members (Methods); public:. TTimeStamp(); TTimeStamp(const timespec_t& ts); TTimeStamp(const TTimeStamp&); TTimeStamp(time_t t, Int_t nsec); TTimeStamp(UInt_t tloc, Bool_t isUTC = kTRUE, Int_t secOffset = 0, Bool_t dosDate = kFALSE); TTimeStamp(UInt_t date, UInt_t time, UInt_t nsec, Bool_t isUTC = kTRUE, Int_t secOffset = 0); TTimeStamp(UInt_t year, UInt_t month, UInt_t day, UInt_t hour, UInt_t min, UInt_t sec, UInt_t nsec = 0, Bool_t isUTC = kTRUE, Int_t secOffset = 0); virtual~TTimeStamp(); voidAdd(const TTimeStamp& offset); Double_tAsDouble() const; Double_tAsGAST(Double_t UT1Offset = 0) const; Double_tAsGMST(Double_t UT1Offset = 0) const; Double_tAsJulianDate() const; Double_tAsLAST(Double_t Longitude, Double_t UT1Offset = 0) const; Double_tAsLMST(Double_t Longitude, Double_t UT1Offset = 0) const; const char*AsString(Option_t* option = """") const; static TClass*Class(); voidCopy(TTimeStamp& ts) const; static voidDumpTMStruct(const ",MatchSource.WIKI,root/html534/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTimeStamp.html
https://root.cern/root/html534/TTimeStamp.html:13025,Modifiability,config,configured,13025,", Int_t nsec, Bool_t isUTC, Int_t secOffset); Set date/time from integers of the form [yy]YYMMDD and HHMMSS,; assume UTC (UTC) components:. MM: 01=January .. 12=December; DD: 01 .. 31. HH: 00=midnight .. 23; MM: 00 .. 59; SS: 00 .. 69. Date must be in format 980418 or 19980418; 1001127 or 20001127 (i.e. year 100 = 2000),; time must be in format 224512 (second precision),; date must be >= 700101. void Set(UInt_t tloc, Bool_t isUTC, Int_t secOffset, Bool_t dosDate); The input arg is a time_t value returned by time() or a value; returned by Convert(). This value is the number of seconds since; the EPOCH (i.e. 00:00:00 on Jan 1m 1970). If dosDate is true then; the input is a dosDate value. void NormalizeNanoSec(); Ensure that the fNanoSec field is in range [0,999999999]. time_t MktimeFromUTC(tm_t* tmstruct); Equivalent of standard routine ""mktime"" but; using the assumption that tm struct is filled with UTC, not local, time. This version *ISN'T* configured to handle every possible; weirdness of out-of-range values in the case of normalizing; the tm struct. This version *DOESN'T* correctly handle values that can't be; fit into a time_t (i.e. beyond year 2038-01-18 19:14:07, or; before the start of Epoch). Int_t GetDayOfYear(Int_t day, Int_t month, Int_t year); Get the day of the year represented by day, month and year.; Valid return values range between 1 and 366, where January 1 = 1. Int_t GetDayOfWeek(Int_t day, Int_t month, Int_t year); Method is using Zeller's formula for calculating the day number.; Valid return values range between 1 and 7, where Monday = 1. Int_t GetWeek(Int_t day, Int_t month, Int_t year); Get the week of the year. Valid week values are between 1 and 53.; The return value is the year*100+week (1 Jan may be in the last; week of the previous year so the year must be returned too). Bool_t IsLeapYear(Int_t year); Is the given year a leap year.; The calendar year is 365 days long, unless the year is exactly divisible; by 4, in which case an extra day i",MatchSource.WIKI,root/html534/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTimeStamp.html
https://root.cern/root/html534/TTimeStamp.html:8812,Safety,avoid,avoid,8812,"ically allocated string.; User should copy this into their own buffer before calling; this method again. Option ""l"" returns it in local zone format; (can be applied to default or compact format). Default format is RFC822 compliant:; ""Mon, 02 Jan 2001 18:11:12 +0000 (GMT) +999999999 nsec""; ""Mon, 02 Jan 2001 10:11:12 -0800 (PST) +999999999 nsec"". Option ""c"" compact is (almost) ISO 8601 compliant:; ""2001-01-02 18:11:12.9999999999Z""; ""2001-01-02 10:11:12.9999999999-0800"" if PST; * uses ""-"" as date separator as specified in ISO 8601; * uses ""."" rather than preferred "","" for decimal separator; * -HHMM is the difference between local and UTC (if behind, + if ahead).; The ""-HHMM"" is replaced with ""Z"" if given as UTC.; To be strictly conforming it should use ""T"" instead of the; blank separating the date and time. Option ""2"" returns as {sec,nsec} integers. Option ""s"" returns ""2001-01-02 18:11:12"" with an implied UTC,; overrides ""l"" option. Internally uses a circular list of buffers to avoid problems; using AsString multiple times in a single statement. void Copy(TTimeStamp& ts) const; Copy this to ts. UInt_t GetDate(Bool_t inUTC = kTRUE, Int_t secOffset = 0, UInt_t* year = 0, UInt_t* month = 0, UInt_t* day = 0) const; Return date in form of 19971224 (i.e. 24/12/1997),; if non-zero pointers supplied for year, month, day fill those as well. UInt_t GetTime(Bool_t inUTC = kTRUE, Int_t secOffset = 0, UInt_t* hour = 0, UInt_t* min = 0, UInt_t* sec = 0) const; Return time in form of 123623 (i.e. 12:36:23),; if non-zero pointers supplied for hour, min, sec fill those as well. Int_t GetDayOfYear(Bool_t inUTC = kTRUE, Int_t secOffset = 0) const; Get the day of the year represented by this time stamp value.; Valid return values range between 1 and 366, where January 1 = 1. Int_t GetDayOfWeek(Bool_t inUTC = kTRUE, Int_t secOffset = 0) const; Method is using Zeller's formula for calculating the day number.; Valid return values range between 1 and 7, where Monday = 1. Int_t GetMonth(Bool_t ",MatchSource.WIKI,root/html534/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTimeStamp.html
https://root.cern/root/html534/TTimeStamp.html:728,Usability,simpl,simply,728,". TTimeStamp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TTimeStamp. class TTimeStamp. The TTimeStamp encapsulates seconds and ns since EPOCH. This extends (and isolates) struct timespec; struct timespec; {; time_t tv_sec; /* seconds *; long tv_nsec; /* nanoseconds *; }; time_t seconds is relative to Jan 1, 1970 00:00:00 UTC. No accounting of leap seconds is made. Due to ROOT/CINT limitations TTimeStamp does not explicitly; hold a timespec struct; attempting to do so means the Streamer; must be hand written. Instead we have chosen to simply contain; similar fields within the private area of this class. NOTE: the use of time_t (and its default implementation as a 32 int); implies overflow conditions occurs somewhere around; Jan 18, 19:14:07, 2038.; If this experiment is still going when it becomes significant; someone will have to deal with it. Function Members (Methods); public:. TTimeStamp(); TTimeStamp(const timespec_t& ts); TTimeStamp(const TTimeStamp&); TTimeStamp(time_t t, Int_t nsec); TTimeStamp(UInt_t tloc, Bool_t isUTC = kTRUE, Int_t secOffset = 0, Bool_t dosDate = kFALSE); TTimeStamp(UInt_t date, UInt_t time, UInt_t nsec, Bool_t isUTC = kTRUE, Int_t secOffset = 0); TTimeStamp(UInt_t year, UInt_t month, UInt_t day, UInt_t hour, UInt_t min, UInt_t sec, UInt_t nsec = 0, Bool_t isUTC = kTRUE, Int_t secOffset = 0); virtual~TTimeStamp(); voidAdd(const TTimeStamp& offset); Double_tAsDouble() const; Double_tAsGAST(Double_t UT1Offset = 0) const; Double_tAsGMST(Double_t UT1Offset = 0) const; Double_tAsJulianDate() const; Double_tAsLAST(Double_t Longitude, Double_t UT1Offset = 0) const; Double_tAsLMST(Double_t Longitude, Double_t UT1Offset = 0) const; const char*AsString(Option_t* option = """") const; static TClass*Class(); voidCopy(TTimeStamp& ts) const; static voidDumpTMStruct(const ",MatchSource.WIKI,root/html534/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTimeStamp.html
https://root.cern/root/html534/TTimeStamp.html:3905,Usability,simpl,simply,3905,"secOffset = 0) const; static time_tMktimeFromUTC(tm_t* tmstruct); doubleoperator double() const; TTimeStamp&operator=(const TTimeStamp&); voidPrint(Option_t* option = """") const; voidSet(); voidSet(UInt_t tloc, Bool_t isUTC, Int_t secOffset, Bool_t dosDate); voidSet(Int_t date, Int_t time, Int_t nsec, Bool_t isUTC, Int_t secOffset); voidSet(Int_t year, Int_t month, Int_t day, Int_t hour, Int_t min, Int_t sec, Int_t nsec, Bool_t isUTC, Int_t secOffset); voidSetNanoSec(Int_t nsec); voidSetSec(Int_t sec); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. voidNormalizeNanoSec(). Data Members; private:. Int_tfNanoSecnanoseconds; Int_tfSecseconds. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTimeStamp(); Default ctor. Create a TTimeStamp and set it to the current time; (as best possible). The nanosecond part is faked so that subsequenct; calls simply add 1 to ensure that sequential calls are distinct; (and sortable). TTimeStamp(UInt_t year, UInt_t month, UInt_t day, UInt_t hour, UInt_t min, UInt_t sec, UInt_t nsec = 0, Bool_t isUTC = kTRUE, Int_t secOffset = 0); Create a TTimeStamp and set it to the specified year, month,; day, time, hour, minute, second and nanosec.; If !isUTC then it is assumed to be the standard local time zone. If local time is PST then one can use; TTimeStamp(year,month,day,hour,min,sec,nsec,kFALSE,0);; or; Int_t secOffset = 8*60*60;; TTimeStamp(year,month,day,hour,min,sec,nsec,kTRUE,8*60*60);. TTimeStamp(UInt_t date, UInt_t time, UInt_t nsec, Bool_t isUTC = kTRUE, Int_t secOffset = 0); Create a TTimeStamp and set it to the specified date, time, nanosec.; If !isUTC then it is assumed to be the standard local time zone. TTimeStamp(UInt_t tloc, Bool_t isUTC = kTRUE, Int_t secOffset = 0, Bool_t dosDate = kFALSE); Create a TTimeStamp and set it to tloc which must be a time_t value; returned by time(). This value is ",MatchSource.WIKI,root/html534/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTimeStamp.html
https://root.cern/root/html534/TTimeStamp.html:11376,Usability,simpl,simply,11376,"e an extra day is added to February to make the year; 366 days long. If the year is the last year of a century, eg. 1700, 1800,; 1900, 2000, then it is only a leap year if it is exactly divisible by; 400. Therefore, 1900 wasn't a leap year but 2000 was. The reason for; these rules is to bring the average length of the calendar year into; line with the length of the Earth's orbit around the Sun, so that the; seasons always occur during the same months each year. Int_t GetZoneOffset(); Static method returning local (current) time zone offset from UTC.; This is the value in seconds one must add to the local time to arrive at; Coordinated Universal Time, so it is negative east of the Prime Meridian. void Add(const TTimeStamp& offset); Add ""offset"" as a delta time. void Print(Option_t* option = """") const; Print date and time. void Set(); Set Date/Time to current time as reported by the system.; No accounting for nanoseconds with std ANSI functions,; ns part faked so that subsequent calls simply add 1 to it; this ensures that calls within the same second come back; distinct (and sortable). Time is since Jan 1, 1970. void Set(Int_t year, Int_t month, Int_t day, Int_t hour, Int_t min, Int_t sec, Int_t nsec, Bool_t isUTC, Int_t secOffset); Set Date/Time from components. Month & day both use normal 1..12 and 1..31 counting,; hours, min, sec run from 0 to 23, 59, 59 respectively,; secOffset provides method for adjusting for alternative timezones. ""year"" | 0 1 ... 37 | 38...69 | 70 .. 100 101 .. 137; true | 2000 2001 2037 | undefined | 1970 2000 2001 .. 2037. ""year"" | 138...1969 | 1970 .. 2037 | ...; true | undefined | 1970 .. 2037 | undefined. void Set(Int_t date, Int_t time, Int_t nsec, Bool_t isUTC, Int_t secOffset); Set date/time from integers of the form [yy]YYMMDD and HHMMSS,; assume UTC (UTC) components:. MM: 01=January .. 12=December; DD: 01 .. 31. HH: 00=midnight .. 23; MM: 00 .. 59; SS: 00 .. 69. Date must be in format 980418 or 19980418; 1001127 or 20001127 (i.e. year",MatchSource.WIKI,root/html534/TTimeStamp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTimeStamp.html
https://root.cern/root/html534/TToggle.html:2095,Availability,error,error,2095," TToggle(); TToggle(const TToggle&); ~TToggle(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const cha",MatchSource.WIKI,root/html534/TToggle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TToggle.html
https://root.cern/root/html534/TToggle.html:2179,Availability,error,error,2179,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TMethodCall*GetGetter() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Long_tGetOffValue(); virtual Long_tGetOnValue(); virtual Option_t*TObject::GetOption() const; TMethodCall*GetSetter() const; virtual Bool_tGetState(); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetValue(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtu",MatchSource.WIKI,root/html534/TToggle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TToggle.html
https://root.cern/root/html534/TToggle.html:734,Deployability,toggle,toggle,734,". TToggle. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TToggle. class TToggle: public TNamed. TToggle. This class defines toggling facility for both - object's method or; variables.; Assume that user provides an object with a two-state field , and; methods to Get/Set value of this field. This object enables to switch; values via this method when the only thing you know about the field; is the name of the method (or method itself) which sets the field.; This facility is required in context Pop-Up menu, when the only; information about how to toggle a field is a name of methhod which; sets it.; This class may be also used for toggling an integer variable,; which may be important while building universal objects...; When user provides a ""set-method"" of name SetXXX this object tries; automaticaly find a matching ""get-method"" by lookin for a method; with name GetXXX, IsXXX or HasXXX for given object. Function Members (Methods); public:. TToggle(); TToggle(const TToggle&); ~TToggle(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const cha",MatchSource.WIKI,root/html534/TToggle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TToggle.html
https://root.cern/root/html534/TToggle.html:7810,Deployability,toggle,toggle,7810,"e object this Toggle belongs to; TMethodCall*fSetterMethod to Set a value of fObject;; Int_t*fTglVariableAlternatively: pointer to an integer value to be Toggled instead of TObjectl; TStringTNamed::fTitleobject title. private:. Long_tfOffValueValue recognized as switched OFF(Def=0); Long_tfOnValueValue recognized as switched ON (Def=1); Bool_tfStateObject's state - ""a local copy""; Long_tfValueLocal copy of a value returned by called function. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TToggle(); TToggle default constructor. You have to initialize it before using; by making a call to SetToggledVariable() or SetToggledObject(). void SetToggledVariable(Int_t& var); Initializes object for use with a variable - you pass it via reference; so it will be modified by Toggle. Bool_t GetState(); Returns the state of Toggle according to its current value and; fOnValue, returns true if they match. void SetState(Bool_t state); Sets the value of toggle to fOnValue or fOffValue according to passed; argument. void SetValue(Long_t val); Sets the value of toggle and modifies its state according to whether; the value is equal to fOnValue. void Toggle(); Toggles the Values and State of this object and connected data!. void SetToggledObject(TObject* obj, TMethod* anymethod); Initializes it to toggle an object's datamember using this object's; method. TToggle(). Bool_t IsInitialized(); {return fInitialized;}. void SetOnValue(Long_t lon); {fOnValue=lon;}. Long_t GetOnValue(); {return fOnValue;}. void SetOffValue(Long_t lof); {fOffValue=lof;}. Long_t GetOffValue(); {return fOffValue;}. Int_t GetValue(); {return fValue;}. TMethodCall * GetGetter() const; { return fGetter; }. TMethodCall * GetSetter() const; { return fSetter; }. » Author: Piotr Golonka 30/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-03-15 16:40; This page has been automatically generated. For comments or",MatchSource.WIKI,root/html534/TToggle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TToggle.html
https://root.cern/root/html534/TToggle.html:7918,Deployability,toggle,toggle,7918,"lVariableAlternatively: pointer to an integer value to be Toggled instead of TObjectl; TStringTNamed::fTitleobject title. private:. Long_tfOffValueValue recognized as switched OFF(Def=0); Long_tfOnValueValue recognized as switched ON (Def=1); Bool_tfStateObject's state - ""a local copy""; Long_tfValueLocal copy of a value returned by called function. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TToggle(); TToggle default constructor. You have to initialize it before using; by making a call to SetToggledVariable() or SetToggledObject(). void SetToggledVariable(Int_t& var); Initializes object for use with a variable - you pass it via reference; so it will be modified by Toggle. Bool_t GetState(); Returns the state of Toggle according to its current value and; fOnValue, returns true if they match. void SetState(Bool_t state); Sets the value of toggle to fOnValue or fOffValue according to passed; argument. void SetValue(Long_t val); Sets the value of toggle and modifies its state according to whether; the value is equal to fOnValue. void Toggle(); Toggles the Values and State of this object and connected data!. void SetToggledObject(TObject* obj, TMethod* anymethod); Initializes it to toggle an object's datamember using this object's; method. TToggle(). Bool_t IsInitialized(); {return fInitialized;}. void SetOnValue(Long_t lon); {fOnValue=lon;}. Long_t GetOnValue(); {return fOnValue;}. void SetOffValue(Long_t lof); {fOffValue=lof;}. Long_t GetOffValue(); {return fOffValue;}. Int_t GetValue(); {return fValue;}. TMethodCall * GetGetter() const; { return fGetter; }. TMethodCall * GetSetter() const; { return fSetter; }. » Author: Piotr Golonka 30/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-03-15 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TToggle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TToggle.html
https://root.cern/root/html534/TToggle.html:8157,Deployability,toggle,toggle,8157,"lVariableAlternatively: pointer to an integer value to be Toggled instead of TObjectl; TStringTNamed::fTitleobject title. private:. Long_tfOffValueValue recognized as switched OFF(Def=0); Long_tfOnValueValue recognized as switched ON (Def=1); Bool_tfStateObject's state - ""a local copy""; Long_tfValueLocal copy of a value returned by called function. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TToggle(); TToggle default constructor. You have to initialize it before using; by making a call to SetToggledVariable() or SetToggledObject(). void SetToggledVariable(Int_t& var); Initializes object for use with a variable - you pass it via reference; so it will be modified by Toggle. Bool_t GetState(); Returns the state of Toggle according to its current value and; fOnValue, returns true if they match. void SetState(Bool_t state); Sets the value of toggle to fOnValue or fOffValue according to passed; argument. void SetValue(Long_t val); Sets the value of toggle and modifies its state according to whether; the value is equal to fOnValue. void Toggle(); Toggles the Values and State of this object and connected data!. void SetToggledObject(TObject* obj, TMethod* anymethod); Initializes it to toggle an object's datamember using this object's; method. TToggle(). Bool_t IsInitialized(); {return fInitialized;}. void SetOnValue(Long_t lon); {fOnValue=lon;}. Long_t GetOnValue(); {return fOnValue;}. void SetOffValue(Long_t lof); {fOffValue=lof;}. Long_t GetOffValue(); {return fOffValue;}. Int_t GetValue(); {return fValue;}. TMethodCall * GetGetter() const; { return fGetter; }. TMethodCall * GetSetter() const; { return fSetter; }. » Author: Piotr Golonka 30/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-03-15 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TToggle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TToggle.html
https://root.cern/root/html534/TToggle.html:358,Modifiability,variab,variables,358,". TToggle. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TToggle. class TToggle: public TNamed. TToggle. This class defines toggling facility for both - object's method or; variables.; Assume that user provides an object with a two-state field , and; methods to Get/Set value of this field. This object enables to switch; values via this method when the only thing you know about the field; is the name of the method (or method itself) which sets the field.; This facility is required in context Pop-Up menu, when the only; information about how to toggle a field is a name of methhod which; sets it.; This class may be also used for toggling an integer variable,; which may be important while building universal objects...; When user provides a ""set-method"" of name SetXXX this object tries; automaticaly find a matching ""get-method"" by lookin for a method; with name GetXXX, IsXXX or HasXXX for given object. Function Members (Methods); public:. TToggle(); TToggle(const TToggle&); ~TToggle(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const cha",MatchSource.WIKI,root/html534/TToggle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TToggle.html
https://root.cern/root/html534/TToggle.html:839,Modifiability,variab,variable,839,". TToggle. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TToggle. class TToggle: public TNamed. TToggle. This class defines toggling facility for both - object's method or; variables.; Assume that user provides an object with a two-state field , and; methods to Get/Set value of this field. This object enables to switch; values via this method when the only thing you know about the field; is the name of the method (or method itself) which sets the field.; This facility is required in context Pop-Up menu, when the only; information about how to toggle a field is a name of methhod which; sets it.; This class may be also used for toggling an integer variable,; which may be important while building universal objects...; When user provides a ""set-method"" of name SetXXX this object tries; automaticaly find a matching ""get-method"" by lookin for a method; with name GetXXX, IsXXX or HasXXX for given object. Function Members (Methods); public:. TToggle(); TToggle(const TToggle&); ~TToggle(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const cha",MatchSource.WIKI,root/html534/TToggle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TToggle.html
https://root.cern/root/html534/TToggle.html:7570,Modifiability,variab,variable,7570," kWriteDelete; };. protected:. TMethodCall*fGetterMethod to Get a value of fObject;; Bool_tfInitializedTrue if either SetToggledObject or SetToggledVariable called - enables Toggle() method.; TStringTNamed::fNameobject identifier; TObject*fObjectThe object this Toggle belongs to; TMethodCall*fSetterMethod to Set a value of fObject;; Int_t*fTglVariableAlternatively: pointer to an integer value to be Toggled instead of TObjectl; TStringTNamed::fTitleobject title. private:. Long_tfOffValueValue recognized as switched OFF(Def=0); Long_tfOnValueValue recognized as switched ON (Def=1); Bool_tfStateObject's state - ""a local copy""; Long_tfValueLocal copy of a value returned by called function. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TToggle(); TToggle default constructor. You have to initialize it before using; by making a call to SetToggledVariable() or SetToggledObject(). void SetToggledVariable(Int_t& var); Initializes object for use with a variable - you pass it via reference; so it will be modified by Toggle. Bool_t GetState(); Returns the state of Toggle according to its current value and; fOnValue, returns true if they match. void SetState(Bool_t state); Sets the value of toggle to fOnValue or fOffValue according to passed; argument. void SetValue(Long_t val); Sets the value of toggle and modifies its state according to whether; the value is equal to fOnValue. void Toggle(); Toggles the Values and State of this object and connected data!. void SetToggledObject(TObject* obj, TMethod* anymethod); Initializes it to toggle an object's datamember using this object's; method. TToggle(). Bool_t IsInitialized(); {return fInitialized;}. void SetOnValue(Long_t lon); {fOnValue=lon;}. Long_t GetOnValue(); {return fOnValue;}. void SetOffValue(Long_t lof); {fOffValue=lof;}. Long_t GetOffValue(); {return fOffValue;}. Int_t GetValue(); {return fValue;}. TMethodCall * GetGetter() const; { return fGetter; }. TMethodCall * GetSetter() c",MatchSource.WIKI,root/html534/TToggle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TToggle.html
https://root.cern/root/html534/TToggleGroup.html:1563,Availability,error,error,1563,"ethod(const char* method) const; virtual Int_tAdd(TToggle* t, Bool_t select = 1); virtual voidTObject::AppendPad(Option_t* option = """"); virtual TToggle*At(Int_t idx); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteAll(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TToggle*First(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual Int_tGetTogglesCount(); virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual Int_tIndexOf(TToggle* t); ",MatchSource.WIKI,root/html534/TToggleGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TToggleGroup.html
https://root.cern/root/html534/TToggleGroup.html:1647,Availability,error,error,1647,"rtual voidTObject::AppendPad(Option_t* option = """"); virtual TToggle*At(Int_t idx); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteAll(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TToggle*First(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual Int_tGetTogglesCount(); virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual Int_tIndexOf(TToggle* t); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Boo",MatchSource.WIKI,root/html534/TToggleGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TToggleGroup.html
https://root.cern/root/html534/TToggleGroup.html:6310,Deployability,toggle,togglegroup,6310,"t::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TOrdCollection*fToggleslist of TToggle objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TToggleGroup(); Constructor. TToggleGroup(const TToggleGroup& ); Copy constructor. TToggleGroup & operator=(const TToggleGroup& ); Assignment operator. ~TToggleGroup(); Deletes togglegroup but does not disposes toggled objects!. Int_t Add(TToggle* t, Bool_t select = 1); Add a new toggle. Int_t InsertAt(TToggle* t, Int_t pos, Bool_t select = 1); Add a new toggle at a specific position. void Select(Int_t idx); Select a toggle. void Select(TToggle* t); Selector a toggle. void DeleteAll(); Disposes of all objects and clears array. Int_t GetTogglesCount(); {return fToggles->GetSize();}. TToggle * At(Int_t idx); {return (TToggle*)fToggles->At(idx);}. void Remove(TToggle* t); {fToggles->Remove(t);}. void Remove(Int_t pos); {fToggles->RemoveAt(pos);}. TToggle * First(); {return (TToggle*)fToggles->First();}. TToggle * Last(); {return (TToggle*)fToggles->Last();}. Int_t IndexOf(TToggle* t); {return fToggles->IndexOf(t);}. » Author: Piotr Golonka 31/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-03-15 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or",MatchSource.WIKI,root/html534/TToggleGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TToggleGroup.html
https://root.cern/root/html534/TToggleGroup.html:6344,Deployability,toggle,toggled,6344,"t::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TOrdCollection*fToggleslist of TToggle objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TToggleGroup(); Constructor. TToggleGroup(const TToggleGroup& ); Copy constructor. TToggleGroup & operator=(const TToggleGroup& ); Assignment operator. ~TToggleGroup(); Deletes togglegroup but does not disposes toggled objects!. Int_t Add(TToggle* t, Bool_t select = 1); Add a new toggle. Int_t InsertAt(TToggle* t, Int_t pos, Bool_t select = 1); Add a new toggle at a specific position. void Select(Int_t idx); Select a toggle. void Select(TToggle* t); Selector a toggle. void DeleteAll(); Disposes of all objects and clears array. Int_t GetTogglesCount(); {return fToggles->GetSize();}. TToggle * At(Int_t idx); {return (TToggle*)fToggles->At(idx);}. void Remove(TToggle* t); {fToggles->Remove(t);}. void Remove(Int_t pos); {fToggles->RemoveAt(pos);}. TToggle * First(); {return (TToggle*)fToggles->First();}. TToggle * Last(); {return (TToggle*)fToggles->Last();}. Int_t IndexOf(TToggle* t); {return fToggles->IndexOf(t);}. » Author: Piotr Golonka 31/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-03-15 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or",MatchSource.WIKI,root/html534/TToggleGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TToggleGroup.html
https://root.cern/root/html534/TToggleGroup.html:6414,Deployability,toggle,toggle,6414," bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TOrdCollection*fToggleslist of TToggle objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TToggleGroup(); Constructor. TToggleGroup(const TToggleGroup& ); Copy constructor. TToggleGroup & operator=(const TToggleGroup& ); Assignment operator. ~TToggleGroup(); Deletes togglegroup but does not disposes toggled objects!. Int_t Add(TToggle* t, Bool_t select = 1); Add a new toggle. Int_t InsertAt(TToggle* t, Int_t pos, Bool_t select = 1); Add a new toggle at a specific position. void Select(Int_t idx); Select a toggle. void Select(TToggle* t); Selector a toggle. void DeleteAll(); Disposes of all objects and clears array. Int_t GetTogglesCount(); {return fToggles->GetSize();}. TToggle * At(Int_t idx); {return (TToggle*)fToggles->At(idx);}. void Remove(TToggle* t); {fToggles->Remove(t);}. void Remove(Int_t pos); {fToggles->RemoveAt(pos);}. TToggle * First(); {return (TToggle*)fToggles->First();}. TToggle * Last(); {return (TToggle*)fToggles->Last();}. Int_t IndexOf(TToggle* t); {return fToggles->IndexOf(t);}. » Author: Piotr Golonka 31/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-03-15 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TToggleGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TToggleGroup.html
https://root.cern/root/html534/TToggleGroup.html:6490,Deployability,toggle,toggle,6490," bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TOrdCollection*fToggleslist of TToggle objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TToggleGroup(); Constructor. TToggleGroup(const TToggleGroup& ); Copy constructor. TToggleGroup & operator=(const TToggleGroup& ); Assignment operator. ~TToggleGroup(); Deletes togglegroup but does not disposes toggled objects!. Int_t Add(TToggle* t, Bool_t select = 1); Add a new toggle. Int_t InsertAt(TToggle* t, Int_t pos, Bool_t select = 1); Add a new toggle at a specific position. void Select(Int_t idx); Select a toggle. void Select(TToggle* t); Selector a toggle. void DeleteAll(); Disposes of all objects and clears array. Int_t GetTogglesCount(); {return fToggles->GetSize();}. TToggle * At(Int_t idx); {return (TToggle*)fToggles->At(idx);}. void Remove(TToggle* t); {fToggles->Remove(t);}. void Remove(Int_t pos); {fToggles->RemoveAt(pos);}. TToggle * First(); {return (TToggle*)fToggles->First();}. TToggle * Last(); {return (TToggle*)fToggles->Last();}. Int_t IndexOf(TToggle* t); {return fToggles->IndexOf(t);}. » Author: Piotr Golonka 31/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-03-15 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TToggleGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TToggleGroup.html
https://root.cern/root/html534/TToggleGroup.html:6554,Deployability,toggle,toggle,6554," bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TOrdCollection*fToggleslist of TToggle objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TToggleGroup(); Constructor. TToggleGroup(const TToggleGroup& ); Copy constructor. TToggleGroup & operator=(const TToggleGroup& ); Assignment operator. ~TToggleGroup(); Deletes togglegroup but does not disposes toggled objects!. Int_t Add(TToggle* t, Bool_t select = 1); Add a new toggle. Int_t InsertAt(TToggle* t, Int_t pos, Bool_t select = 1); Add a new toggle at a specific position. void Select(Int_t idx); Select a toggle. void Select(TToggle* t); Selector a toggle. void DeleteAll(); Disposes of all objects and clears array. Int_t GetTogglesCount(); {return fToggles->GetSize();}. TToggle * At(Int_t idx); {return (TToggle*)fToggles->At(idx);}. void Remove(TToggle* t); {fToggles->Remove(t);}. void Remove(Int_t pos); {fToggles->RemoveAt(pos);}. TToggle * First(); {return (TToggle*)fToggles->First();}. TToggle * Last(); {return (TToggle*)fToggles->Last();}. Int_t IndexOf(TToggle* t); {return fToggles->IndexOf(t);}. » Author: Piotr Golonka 31/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-03-15 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TToggleGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TToggleGroup.html
https://root.cern/root/html534/TToggleGroup.html:6598,Deployability,toggle,toggle,6598," bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TOrdCollection*fToggleslist of TToggle objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TToggleGroup(); Constructor. TToggleGroup(const TToggleGroup& ); Copy constructor. TToggleGroup & operator=(const TToggleGroup& ); Assignment operator. ~TToggleGroup(); Deletes togglegroup but does not disposes toggled objects!. Int_t Add(TToggle* t, Bool_t select = 1); Add a new toggle. Int_t InsertAt(TToggle* t, Int_t pos, Bool_t select = 1); Add a new toggle at a specific position. void Select(Int_t idx); Select a toggle. void Select(TToggle* t); Selector a toggle. void DeleteAll(); Disposes of all objects and clears array. Int_t GetTogglesCount(); {return fToggles->GetSize();}. TToggle * At(Int_t idx); {return (TToggle*)fToggles->At(idx);}. void Remove(TToggle* t); {fToggles->Remove(t);}. void Remove(Int_t pos); {fToggles->RemoveAt(pos);}. TToggle * First(); {return (TToggle*)fToggles->First();}. TToggle * Last(); {return (TToggle*)fToggles->Last();}. Int_t IndexOf(TToggle* t); {return fToggles->IndexOf(t);}. » Author: Piotr Golonka 31/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-03-15 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TToggleGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TToggleGroup.html
https://root.cern/root/html534/TToggleGroup.html:6652,Usability,clear,clears,6652," bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TOrdCollection*fToggleslist of TToggle objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TToggleGroup(); Constructor. TToggleGroup(const TToggleGroup& ); Copy constructor. TToggleGroup & operator=(const TToggleGroup& ); Assignment operator. ~TToggleGroup(); Deletes togglegroup but does not disposes toggled objects!. Int_t Add(TToggle* t, Bool_t select = 1); Add a new toggle. Int_t InsertAt(TToggle* t, Int_t pos, Bool_t select = 1); Add a new toggle at a specific position. void Select(Int_t idx); Select a toggle. void Select(TToggle* t); Selector a toggle. void DeleteAll(); Disposes of all objects and clears array. Int_t GetTogglesCount(); {return fToggles->GetSize();}. TToggle * At(Int_t idx); {return (TToggle*)fToggles->At(idx);}. void Remove(TToggle* t); {fToggles->Remove(t);}. void Remove(Int_t pos); {fToggles->RemoveAt(pos);}. TToggle * First(); {return (TToggle*)fToggles->First();}. TToggle * Last(); {return (TToggle*)fToggles->Last();}. Int_t IndexOf(TToggle* t); {return fToggles->IndexOf(t);}. » Author: Piotr Golonka 31/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-03-15 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/TToggleGroup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TToggleGroup.html
https://root.cern/root/html534/TTRAP.html:2779,Availability,error,error,2779,"ethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTBRIK::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tGetAlpha1() const; virtual Float_tGetAlpha2() const; virtual Float_tGetBl1() const; virtual Float_tGetBl2() const; virtual const TBuffer3D&TBRIK::GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tTBRIK::GetDx() const; Float_tTBRIK::GetDy() const; Float_tTBRIK::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual Float_tGetH1() const; virtual Float_tGetH2() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAtt",MatchSource.WIKI,root/html534/TTRAP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTRAP.html
https://root.cern/root/html534/TTRAP.html:2863,Availability,error,error,2863,"""); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTBRIK::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tGetAlpha1() const; virtual Float_tGetAlpha2() const; virtual Float_tGetBl1() const; virtual Float_tGetBl2() const; virtual const TBuffer3D&TBRIK::GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tTBRIK::GetDx() const; Float_tTBRIK::GetDy() const; Float_tTBRIK::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual Float_tGetH1() const; virtual Float_tGetH2() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual W",MatchSource.WIKI,root/html534/TTRAP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTRAP.html
https://root.cern/root/html534/TTRD1.html:1848,Availability,error,error,1848,"ethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTBRIK::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const TBuffer3D&TBRIK::GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tTBRIK::GetDx() const; virtual Float_tGetDx2() const; Float_tTBRIK::GetDy() const; Float_tTBRIK::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const",MatchSource.WIKI,root/html534/TTRD1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTRD1.html
https://root.cern/root/html534/TTRD1.html:1932,Availability,error,error,1932,"""); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTBRIK::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const TBuffer3D&TBRIK::GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tTBRIK::GetDx() const; virtual Float_tGetDx2() const; Float_tTBRIK::GetDy() const; Float_tTBRIK::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tTShape::GetNumber() const",MatchSource.WIKI,root/html534/TTRD1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTRD1.html
https://root.cern/root/html534/TTRD2.html:1959,Availability,error,error,1959,"ethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTBRIK::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const TBuffer3D&TBRIK::GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tTBRIK::GetDx() const; Float_tGetDx2() const; Float_tTBRIK::GetDy() const; Float_tGetDy2() const; Float_tTBRIK::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetM",MatchSource.WIKI,root/html534/TTRD2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTRD2.html
https://root.cern/root/html534/TTRD2.html:2043,Availability,error,error,2043,"""); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTBRIK::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const TBuffer3D&TBRIK::GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tTBRIK::GetDx() const; Float_tGetDx2() const; Float_tTBRIK::GetDy() const; Float_tGetDy2() const; Float_tTBRIK::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tTShape::Ge",MatchSource.WIKI,root/html534/TTRD2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTRD2.html
https://root.cern/root/html534/TTree.html:15855,Availability,error,error,15855,"t_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tDraw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDropBaskets(); virtual voidDropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); virtual voidDropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual voidDropBuffers(Int_t nbytes); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*FindBranch(const char* name); virtual TLeaf*FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tFit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Int_tFlushBaskets() const; virtual const char*GetAlias(const char* aliasName) const; virtual Long64_tGetAutoFlush() const; virtual Long64_tGetAutoSave() const; virtual TBranch*GetBranch(const char* name); virtual TBranchRef*GetBranchRef() const; virtual Bool_tGetBranchStatus(cons",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:15939,Availability,error,error,15939,"nt_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tDraw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDropBaskets(); virtual voidDropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); virtual voidDropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual voidDropBuffers(Int_t nbytes); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*FindBranch(const char* name); virtual TLeaf*FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tFit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Int_tFlushBaskets() const; virtual const char*GetAlias(const char* aliasName) const; virtual Long64_tGetAutoFlush() const; virtual Long64_tGetAutoSave() const; virtual TBranch*GetBranch(const char* name); virtual TBranchRef*GetBranchRef() const; virtual Bool_tGetBranchStatus(const char* branchname) const; static Int_tGetBranchStyle(); virtual Long64_tGetCacheSiz",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:42059,Availability,recover,recovered,42059,"ve tree header every fAutoSave bytes. When large Trees are produced, it is safe to activate the AutoSave; procedure. Some branches may have buffers holding many entries.; If fAutoSave is negative, AutoSave is automatically called by; TTree::Fill when the number of bytes generated since the previous; AutoSave is greater than -fAutoSave bytes.; If fAutoSave is positive, AutoSave is automatically called by; TTree::Fill every N entries.; This function may also be invoked by the user.; Each AutoSave generates a new key on the file.; Once the key with the tree header has been written, the previous cycle; (if any) is deleted. Note that calling TTree::AutoSave too frequently (or similarly calling; TTree::SetAutoSave with a small value) is an expensive operation.; You should make tests for your own application to find a compromise; between speed and the quantity of information you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE mode.; The Tree will be recovered at the status corresponding to the last AutoSave. if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; This allows another process to analyze the Tree while the Tree is being filled. if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; the current basket are closed-out and written to disk individually. By default the previous header is deleted after having written the new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number of bytes is null, an error has occurred while writing; the header to the file. How to write a Tree in one process and view it from another process. The follo",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:42135,Availability,recover,recovered,42135,"e branches may have buffers holding many entries.; If fAutoSave is negative, AutoSave is automatically called by; TTree::Fill when the number of bytes generated since the previous; AutoSave is greater than -fAutoSave bytes.; If fAutoSave is positive, AutoSave is automatically called by; TTree::Fill every N entries.; This function may also be invoked by the user.; Each AutoSave generates a new key on the file.; Once the key with the tree header has been written, the previous cycle; (if any) is deleted. Note that calling TTree::AutoSave too frequently (or similarly calling; TTree::SetAutoSave with a small value) is an expensive operation.; You should make tests for your own application to find a compromise; between speed and the quantity of information you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE mode.; The Tree will be recovered at the status corresponding to the last AutoSave. if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; This allows another process to analyze the Tree while the Tree is being filled. if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; the current basket are closed-out and written to disk individually. By default the previous header is deleted after having written the new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number of bytes is null, an error has occurred while writing; the header to the file. How to write a Tree in one process and view it from another process. The following two scripts illustrate how to do this.; The script treew.C is executed by process1, treer.C by process2. ----- scri",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:42899,Availability,error,error,42899,"mation you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE mode.; The Tree will be recovered at the status corresponding to the last AutoSave. if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; This allows another process to analyze the Tree while the Tree is being filled. if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; the current basket are closed-out and written to disk individually. By default the previous header is deleted after having written the new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number of bytes is null, an error has occurred while writing; the header to the file. How to write a Tree in one process and view it from another process. The following two scripts illustrate how to do this.; The script treew.C is executed by process1, treer.C by process2. ----- script treew.C; void treew() {; TFile f(""test.root"",""recreate"");; TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; Float_t px, py, pz;; for ( Int_t i=0; i<10000000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ntuple->Fill(px,py,pz,random,i);; if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; }; }. ----- script treer.C; void treer() {; TFile f(""test.root"");; TTree *ntuple = (TTree*)f.Get(""ntuple"");; TCanvas c1;; Int_t first = 0;; while(1) {; if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; first = (Int_t)ntuple->GetEntries();; c1.Update();; gSystem->Sleep(1000); //sleep 1 second; ntuple->Refresh();; }; }. TBranch* Branc",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:52054,Availability,avail,available,52054,"e; branches (TBranchElement). To get the old behaviour, you can:; - call BranchOld or; - call TTree::SetBranchStyle(0). Note that with the new style, classname does not need to derive from TObject.; It must derived from TObject if the branch style has been set to 0 (old). Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the addobj parameter in; the case of new-style branches. Use splitlevel < 0 instead of splitlevel=0 when the class; has a custom Streamer. Note: if the split level is set to the default (99), TTree::Branch will; not issue a warning if the class can not be split. TBranch* BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); Create a new TTree BranchObject. Build a TBranchObject for an object of class classname.; addobj is the address of a pointer to an object of class classname.; IMPORTANT: classname must derive from TObject.; The class dictionary must be available (ClassDef in class header). This option requires access to the library where the corresponding class; is defined. Accessing one single data member in the object implies; reading the full object.; See the next Branch constructor for a more efficient storage; in case the entry consists of arrays of identical objects. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1)",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:55128,Availability,avail,available,55128,"vel = 99); Create a new TTree BranchElement. WARNING about this new function. This function is designed to replace the internal; implementation of the old TTree::Branch (whose implementation; has been moved to BranchOld). NOTE: The 'Bronch' method supports only one possible calls; signature (where the object type has to be specified; explicitly and the address must be the address of a pointer).; For more flexibility use 'Branch'. Use Bronch only in (rare); cases (likely to be legacy cases) where both the new and old; implementation of Branch needs to be used at the same time. This function is far more powerful than the old Branch; function. It supports the full C++, including STL and has; the same behaviour in split or non-split mode. classname does; not have to derive from TObject. The function is based on; the new TStreamerInfo. Build a TBranchElement for an object of class classname. addr is the address of a pointer to an object of class; classname. The class dictionary must be available (ClassDef; in class header). Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the addr parameter. This option requires access to the library where the; corresponding class is defined. Accessing one single data; member in the object implies reading the full object. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:57409,Availability,failure,failure,57409,"e is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. Use splitlevel < 0 instead of splitlevel=0 when the class; has a custom Streamer. Note: if the split level is set to the default (99), TTree::Branch will; not issue a warning if the class can not be split. TBranch* BronchExec(const char* name, const char* classname, void* addobj, Bool_t isptrptr, Int_t bufsize, Int_t splitlevel); Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. void Browse(TBrowser* ); Browse content of the TTree. Int_t BuildIndex(const char* majorname, const char* minorname = ""0""); Build a Tree Index (default is TTreeIndex).; See a description of the parameters and functionality in; TTreeIndex::TTreeIndex(). The return value is the number of entries in the Index (< 0 indicates failure). A TTreeIndex object pointed by fTreeIndex is created.; This object will be automatically deleted by the TTree destructor.; See also comments in TTree::SetTreeIndex(). TStreamerInfo* BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); Build StreamerInfo for class cl.; pointer is an optional argument that may contain a pointer to an object of cl. TFile* ChangeFile(TFile* file); Called by TTree::Fill() when file has reached its maximum fgMaxTreeSize.; Create a new file. If the original file is named ""myfile.root"",; subsequent files are named ""myfile_1.root"", ""myfile_2.root"", etc. Returns a pointer to the new file. Currently, the automatic change of file is restricted; to the case where the tree is in the top level directory.; The file should not contain sub-directories. Before switching to a new file, the tree header is written; to the current file, then the current file is closed. To process the multiple files created by ",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:59796,Availability,error,error,59796,"'t do:; TFile *file = new TFile(""myfile.root"",""recreate"");; TTree *T = new TTree(""T"",""title"");; T->Fill(); //loop; file->Write();; file->Close();; but do the following:; TFile *file = new TFile(""myfile.root"",""recreate"");; TTree *T = new TTree(""T"",""title"");; T->Fill(); //loop; file = T->GetCurrentFile(); //to get the pointer to the current file; file->Write();; file->Close();. Int_t CheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, Bool_t ptr); Check whether or not the address described by the last 3 parameters; matches the content of the branch. If a Data Model Evolution conversion; is involved, reset the fInfo of the branch.; The return values are:; kMissingBranch (-5) : Missing branch; kInternalError (-4) : Internal error (could not find the type corresponding to a data type number); kMissingCompiledCollectionProxy (-3) : Missing compiled collection proxy for a compiled collection; kMismatch (-2) : Non-Class Pointer type given does not match the type expected by the branch; kClassMismatch (-1) : Class Pointer type given does not match the type expected by the branch; kMatch (0) : perfect match; kMatchConversion (1) : match with (I/O) conversion; kMatchConversionCollection (2) : match with (I/O) conversion of the content of a collection; kMakeClass (3) : MakeClass mode so we can not check.; kVoidPtr (4) : void* passed so no check was made.; kNoCheck (5) : Underlying TBranch not yet available so no check was made. TTree* CloneTree(Long64_t nentries = -1, Option_t* option = """"); Create a clone of this tree and copy nentries. By default copy all entries.; The compression level of the cloned tree is set to the destination; file's compression level. NOTE: Only active branches are copied.; NOTE: If the TTree is a TChain, the structure of the first TTree; is used for the copy. IMPORTANT: The cloned tree stays connected with this tree until; this tree is deleted. In particular, any changes in; branch addresses in this tree are forwarded to the; ",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:60474,Availability,avail,available,60474,"lass* ptrClass, EDataType datatype, Bool_t ptr); Check whether or not the address described by the last 3 parameters; matches the content of the branch. If a Data Model Evolution conversion; is involved, reset the fInfo of the branch.; The return values are:; kMissingBranch (-5) : Missing branch; kInternalError (-4) : Internal error (could not find the type corresponding to a data type number); kMissingCompiledCollectionProxy (-3) : Missing compiled collection proxy for a compiled collection; kMismatch (-2) : Non-Class Pointer type given does not match the type expected by the branch; kClassMismatch (-1) : Class Pointer type given does not match the type expected by the branch; kMatch (0) : perfect match; kMatchConversion (1) : match with (I/O) conversion; kMatchConversionCollection (2) : match with (I/O) conversion of the content of a collection; kMakeClass (3) : MakeClass mode so we can not check.; kVoidPtr (4) : void* passed so no check was made.; kNoCheck (5) : Underlying TBranch not yet available so no check was made. TTree* CloneTree(Long64_t nentries = -1, Option_t* option = """"); Create a clone of this tree and copy nentries. By default copy all entries.; The compression level of the cloned tree is set to the destination; file's compression level. NOTE: Only active branches are copied.; NOTE: If the TTree is a TChain, the structure of the first TTree; is used for the copy. IMPORTANT: The cloned tree stays connected with this tree until; this tree is deleted. In particular, any changes in; branch addresses in this tree are forwarded to the; clone trees, unless a branch in a clone tree has had; its address changed, in which case that change stays in; effect. When this tree is deleted, all the addresses of; the cloned tree are reset to their default values. If 'option' contains the word 'fast' and nentries is -1, the; cloning will be done without unzipping or unstreaming the baskets; (i.e., a direct copy of the raw bytes on disk). When 'fast' is specified, 'optio",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:66697,Availability,error,error,66697,"rate file. The input file was generated by running the program in; $ROOTSYS/test/Event in this way:. ./Event 1000 1 1 1. copytree3. Example macro to copy a subset of a tree to a new tree. Only selected entries are copied to the new tree.; NOTE that only the active branches are copied. TBasket* CreateBasket(TBranch* ); Create a basket for this tree and given branch. void Delete(Option_t* option = """"); Delete this tree from memory or/and disk. if option == ""all"" delete Tree object from memory AND from disk; all baskets on disk are deleted. All keys with same name; are deleted.; if option =="""" only Tree object in memory is deleted. void DirectoryAutoAdd(TDirectory* ); Called by TKey and TObject::Clone to automatically add us to a directory; when we are read from a file. Long64_t Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Draw expression varexp for specified entries.; Returns -1 in case of error or number of selected events in case of success. This function accepts TCut objects as arguments.; Useful to use the string operator +; example:; ntuple.Draw(""x"",cut1+cut2+cut3);. Long64_t Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Draw expression varexp for specified entries.; Returns -1 in case of error or number of selected events in case of success. varexp is an expression of the general form; - ""e1"" produces a 1-d histogram (TH1F) of expression ""e1""; - ""e1:e2"" produces an unbinned 2-d scatter-plot (TGraph) of ""e1""; on the y-axis versus ""e2"" on the x-axis; - ""e1:e2:e3"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1""; versus ""e2"" versus ""e3"" on the x-, y-, z-axis, respectively.; - ""e1:e2:e3:e4"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1""; versus ""e2"" versus ""e3"" and ""e4"" mapped on the color number.; (to create histograms in the 2, 3, and 4 dimensional case, see section ""Savin",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:67090,Availability,error,error,67090,"ion = """"); Delete this tree from memory or/and disk. if option == ""all"" delete Tree object from memory AND from disk; all baskets on disk are deleted. All keys with same name; are deleted.; if option =="""" only Tree object in memory is deleted. void DirectoryAutoAdd(TDirectory* ); Called by TKey and TObject::Clone to automatically add us to a directory; when we are read from a file. Long64_t Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Draw expression varexp for specified entries.; Returns -1 in case of error or number of selected events in case of success. This function accepts TCut objects as arguments.; Useful to use the string operator +; example:; ntuple.Draw(""x"",cut1+cut2+cut3);. Long64_t Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Draw expression varexp for specified entries.; Returns -1 in case of error or number of selected events in case of success. varexp is an expression of the general form; - ""e1"" produces a 1-d histogram (TH1F) of expression ""e1""; - ""e1:e2"" produces an unbinned 2-d scatter-plot (TGraph) of ""e1""; on the y-axis versus ""e2"" on the x-axis; - ""e1:e2:e3"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1""; versus ""e2"" versus ""e3"" on the x-, y-, z-axis, respectively.; - ""e1:e2:e3:e4"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1""; versus ""e2"" versus ""e3"" and ""e4"" mapped on the color number.; (to create histograms in the 2, 3, and 4 dimensional case, see section ""Saving; the result of Draw to an histogram""). Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim distribution of y versus sqrt(x); = px:py:pz:2.5*E produces a 3-d scatter-plot of px vs py ps pz; and the color number of each marker will be 2.5*E.; If the color number is negative it is set to 0.; If ",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:70335,Availability,error,error,70335,"e expression may be of the form:; value*(boolean expression); if boolean expression is true, the histogram is filled with; a weight = value.; Examples:; selection1 = ""x<y && sqrt(z)>3.2""; selection2 = ""(x+y)*(sqrt(z)>3.2)""; selection1 returns a weight = 0 or 1; selection2 returns a weight = x+y if sqrt(z)>3.2; returns a weight = 0 otherwise. option is the drawing option.; - See TH1::Draw for the list of all drawing options.; - If option COL is specified when varexp has three fields:; tree.Draw(""e1:e2:e3"","""",""col"");; a 2D scatter is produced with e1 vs e2, and e3 is mapped on the color; table. The colors for e3 are evaluated once in linear scale before; painting. Therefore changing the pad to log scale along Z as no effect; on the colors.; - If option contains the string ""goff"", no graphics is generated. nentries is the number of entries to process (default is all); first is the first entry to process (default is 0). This function returns the number of selected entries. It returns -1; if an error occurs. Drawing expressions using arrays and array elements. Let assumes, a leaf fMatrix, on the branch fEvent, which is a 3 by 3 array,; or a TClonesArray.; In a TTree::Draw expression you can now access fMatrix using the following; syntaxes:. String passed What is used for each entry of the tree. ""fMatrix"" the 9 elements of fMatrix; ""fMatrix[][]"" the 9 elements of fMatrix; ""fMatrix[2][2]"" only the elements fMatrix[2][2]; ""fMatrix[1]"" the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2]; ""fMatrix[1][]"" the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2]; ""fMatrix[][0]"" the 3 elements fMatrix[0][0], fMatrix[1][0] and fMatrix[2][0]. ""fEvent.fMatrix...."" same as ""fMatrix..."" (unless there is more than one leaf named fMatrix!). In summary, if a specific index is not specified for a dimension, TTree::Draw; will loop through all the indices along this dimension. Leaving off the; last (right most) dimension of specifying then with the two characters '[]'; is equi",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:79759,Availability,avail,available,79759,"; Sum$(formula): return the sum of the value of the elements of the formula given; as a parameter. For example the mean for all the elements in; one entry can be calculated with:; Sum$(formula)/Length$(formula); Min$(formula): return the minimun (within one TTree entry) of the value of the; elements of the formula given as a parameter.; Max$(formula): return the maximum (within one TTree entry) of the value of the; elements of the formula given as a parameter.; MinIf$(formula,condition); MaxIf$(formula,condition): return the minimum (maximum) (within one TTree entry); of the value of the elements of the formula given as a parameter; if they match the condition. If no element matches the condition,; the result is zero. To avoid the resulting peak at zero, use the; pattern:; tree->Draw(""MinIf$(formula,condition)"",""condition"");; which will avoid calculation MinIf$ for the entries that have no match; for the condition. Alt$(primary,alternate) : return the value of ""primary"" if it is available; for the current iteration otherwise return the value of ""alternate"".; For example, with arr1[3] and arr2[2]; tree->Draw(""arr1+Alt$(arr2,0)"");; will draw arr1[0]+arr2[0] ; arr1[1]+arr2[1] and arr1[2]+0; Or with a variable size array arr3; tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); As a comparison; tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the; actual_size_of_arr3 is greater or equal to 3.; Note that the array in 'primary' is flattened/linearized thus using; Alt$ with multi-dimensional arrays of different dimensions in unlikely; to yield the expected results. To visualize a bit more what elements; would be matched by TTree::Draw, TTree::Scan can be used:; tree->Scan(""arr1:Alt$(arr2,0)"");; will print on one line the value of arr1 and (arr2,0) that will be; matched by; tree->Draw(""arr1-Alt$(arr2,0)"");. The ternary operator is not directly suppor",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:81580,Availability,avail,available,81580,"lt$(arr2,0)"");; will print on one line the value of arr1 and (arr2,0) that will be; matched by; tree->Draw(""arr1-Alt$(arr2,0)"");. The ternary operator is not directly supported in TTree::Draw however, to plot the; equivalent of 'var2<20 ? -99 : var1', you can use:; tree->Draw(""(var2<20)*99+(var2>=20)*var1"","""");. Drawing a user function accessing the TTree data directly. If the formula contains a file name, TTree::MakeProxy will be used; to load and execute this file. In particular it will draw the; result of a function with the same name as the file. The function; will be executed in a context where the name of the branches can; be used as a C++ variable. For example draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. The main features of this facility are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). See TTree::MakeProxy for more details. Making a Profile histogram. In case of a 2-Dim expression, one can generate a TProfile histogram; instead of a TH2F histogram by specyfying option=prof or option=profs; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of y:x>>pf; where pf is an existing TProfile histogram. Making a 2D Profile histogram. In case of a 3-Dim expression, one can generate a TProfile2D histogram; instead of a TH3F hist",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:81980,Availability,avail,available,81980,"(var2>=20)*var1"","""");. Drawing a user function accessing the TTree data directly. If the formula contains a file name, TTree::MakeProxy will be used; to load and execute this file. In particular it will draw the; result of a function with the same name as the file. The function; will be executed in a context where the name of the branches can; be used as a C++ variable. For example draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. The main features of this facility are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). See TTree::MakeProxy for more details. Making a Profile histogram. In case of a 2-Dim expression, one can generate a TProfile histogram; instead of a TH2F histogram by specyfying option=prof or option=profs; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of y:x>>pf; where pf is an existing TProfile histogram. Making a 2D Profile histogram. In case of a 3-Dim expression, one can generate a TProfile2D histogram; instead of a TH3F histogram by specifying option=prof or option=profs.; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of z:y:x>>pf; where pf is a",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:82278,Availability,error,error,82278,"of the branches can; be used as a C++ variable. For example draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. The main features of this facility are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). See TTree::MakeProxy for more details. Making a Profile histogram. In case of a 2-Dim expression, one can generate a TProfile histogram; instead of a TH2F histogram by specyfying option=prof or option=profs; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of y:x>>pf; where pf is an existing TProfile histogram. Making a 2D Profile histogram. In case of a 3-Dim expression, one can generate a TProfile2D histogram; instead of a TH3F histogram by specifying option=prof or option=profs.; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of z:y:x>>pf; where pf is an existing TProfile2D histogram. Making a 5D plot using GL. If option GL5D is specified together with 5 variables, a 5D plot is drawn; using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example. Making a parallel coordinates plot. In case of a 2-Dim or more expression with the option=para, one can generate; a parallel coor",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:82722,Availability,error,error,82722,"h1analysis.C. The main features of this facility are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). See TTree::MakeProxy for more details. Making a Profile histogram. In case of a 2-Dim expression, one can generate a TProfile histogram; instead of a TH2F histogram by specyfying option=prof or option=profs; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of y:x>>pf; where pf is an existing TProfile histogram. Making a 2D Profile histogram. In case of a 3-Dim expression, one can generate a TProfile2D histogram; instead of a TH3F histogram by specifying option=prof or option=profs.; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of z:y:x>>pf; where pf is an existing TProfile2D histogram. Making a 5D plot using GL. If option GL5D is specified together with 5 variables, a 5D plot is drawn; using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example. Making a parallel coordinates plot. In case of a 2-Dim or more expression with the option=para, one can generate; a parallel coordinates plot. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Making a candle sticks chart. In case of a 2-Dim or more expression with the option=candle, one can generate; a candle sticks chart. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Normalizing the output histogram ",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:83384,Availability,error,error,83384,"etails on the differences.; The option=prof is automatically selected in case of y:x>>pf; where pf is an existing TProfile histogram. Making a 2D Profile histogram. In case of a 3-Dim expression, one can generate a TProfile2D histogram; instead of a TH3F histogram by specifying option=prof or option=profs.; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of z:y:x>>pf; where pf is an existing TProfile2D histogram. Making a 5D plot using GL. If option GL5D is specified together with 5 variables, a 5D plot is drawn; using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example. Making a parallel coordinates plot. In case of a 2-Dim or more expression with the option=para, one can generate; a parallel coordinates plot. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Making a candle sticks chart. In case of a 2-Dim or more expression with the option=candle, one can generate; a candle sticks chart. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Normalizing the output histogram to 1. When option contains ""norm"" the output histogram is normalized to 1. Saving the result of Draw to a TEventList, a TEntryList or a TEntryListArray. TTree::Draw can be used to fill a TEventList object (list of entry numbers); instead of histogramming one variable.; If varexp0 has the form >>elist , a TEventList object named ""elist""; is created in the current directory. elist will contain the list; of entry numbers satisfying the current selection.; If option ""entrylist"" is used, a TEntryList object is created; If the selection contains arrays, vectors or any container class and option; ""entrylistarray",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:83684,Availability,error,error,83684,"=profs.; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of z:y:x>>pf; where pf is an existing TProfile2D histogram. Making a 5D plot using GL. If option GL5D is specified together with 5 variables, a 5D plot is drawn; using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example. Making a parallel coordinates plot. In case of a 2-Dim or more expression with the option=para, one can generate; a parallel coordinates plot. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Making a candle sticks chart. In case of a 2-Dim or more expression with the option=candle, one can generate; a candle sticks chart. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Normalizing the output histogram to 1. When option contains ""norm"" the output histogram is normalized to 1. Saving the result of Draw to a TEventList, a TEntryList or a TEntryListArray. TTree::Draw can be used to fill a TEventList object (list of entry numbers); instead of histogramming one variable.; If varexp0 has the form >>elist , a TEventList object named ""elist""; is created in the current directory. elist will contain the list; of entry numbers satisfying the current selection.; If option ""entrylist"" is used, a TEntryList object is created; If the selection contains arrays, vectors or any container class and option; ""entrylistarray"" is used, a TEntryListArray object is created; containing also the subentries satisfying the selection, i.e. the indices of; the branches which hold containers classes.; Example:; tree.Draw("">>yplus"",""y>0""); will create a TEventList object named ""yplus"" in the current directory.; In an interactive ",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:90452,Availability,error,error,90452,"tViewer""; - type the command ""TTreeViewer TV(treeName)""; - execute statement ""tree->StartViewer();"". void DropBaskets(); Remove some baskets from memory. void DropBuffers(Int_t nbytes); Drop branch buffers to accommodate nbytes below MaxVirtualsize. Int_t Fill(); Fill all branches. This function loops on all the branches of this tree. For; each branch, it copies to the branch buffer (basket) the current; values of the leaves data types. If a leaf is a simple data type,; a simple conversion to a machine independent format has to be done. This machine independent version of the data is copied into a; basket (each branch has its own basket). When a basket is full; (32k worth of data by default), it is then optionally compressed; and written to disk (this operation is also called committing or; 'flushing' the basket). The committed baskets are then; immediately removed from memory. The function returns the number of bytes committed to the; individual branches. If a write error occurs, the number of bytes returned is -1. If no data are written, because, e.g., the branch is disabled,; the number of bytes returned is 0. The baskets are flushed and the Tree header saved at regular intervals. At regular intervals, when the amount of data written so far is; greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; This makes future reading faster as it guarantees that baskets belonging to nearby; entries will be on the same disk region.; When the first call to flush the baskets happen, we also take this opportunity; to optimize the baskets buffers.; We also check if the amount of data written is greater than fAutoSave (see SetAutoSave).; In this case we also write the Tree header. This makes the Tree recoverable up to this point; in case the program writing the Tree crashes.; The decisions to FlushBaskets and Auto Save can be made based either on the number; of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries; written (fAutoF",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:91213,Availability,recover,recoverable,91213,"n is also called committing or; 'flushing' the basket). The committed baskets are then; immediately removed from memory. The function returns the number of bytes committed to the; individual branches. If a write error occurs, the number of bytes returned is -1. If no data are written, because, e.g., the branch is disabled,; the number of bytes returned is 0. The baskets are flushed and the Tree header saved at regular intervals. At regular intervals, when the amount of data written so far is; greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; This makes future reading faster as it guarantees that baskets belonging to nearby; entries will be on the same disk region.; When the first call to flush the baskets happen, we also take this opportunity; to optimize the baskets buffers.; We also check if the amount of data written is greater than fAutoSave (see SetAutoSave).; In this case we also write the Tree header. This makes the Tree recoverable up to this point; in case the program writing the Tree crashes.; The decisions to FlushBaskets and Auto Save can be made based either on the number; of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries; written (fAutoFlush and fAutoSave positive).; Note that the user can decide to call FlushBaskets and AutoSave in her event loop; base on the number of events written instead of the number of bytes written. Note that calling FlushBaskets too often increases the IO time.; Note that calling AutoSave too often increases the IO time and also the file size. TBranch* FindBranch(const char* name); Return the branch that correspond to the path 'branchname', which can; include the name of the tree or the omitted name of the parent branches.; In case of ambiguity, returns the first match. TLeaf* FindLeaf(const char* name); FIXME: Describe this function. Int_t Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:93136,Availability,error,error,93136,"t_t Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Fit a projected item(s) from a tree. funcname is a TF1 function. See TTree::Draw() for explanations of the other parameters. By default the temporary histogram created is called htemp.; If varexp contains >>hnew , the new histogram created is called hnew; and it is kept in the current directory. The function returns the number of selected entries. Example:; tree.Fit(pol4,sqrt(x)>>hsqrt,y>0); will fit sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. See also TTree::UnbinnedFit. Return status. The function returns the status of the histogram fit (see TH1::Fit); If no entries were selected, the function returns -1;; (i.e. fitResult is null is the fit is OK). Int_t FlushBaskets() const; Write to disk all the basket that have not yet been individually written. Return the number of bytes written or -1 in case of write error. const char* GetAlias(const char* aliasName) const; Returns the expanded value of the alias. Search in the friends if any. TBranch* GetBranch(const char* name); Return pointer to the branch with the given name in this tree or its friends. Bool_t GetBranchStatus(const char* branchname) const; Return status of branch with name branchname.; 0 if branch is not activated; 1 if branch is activated. Int_t GetBranchStyle(); Static function returning the current branch style.; style = 0 old Branch; style = 1 new Bronch. Long64_t GetCacheAutoSize(Bool_t withDefault = kFALSE) const; Used for automatic sizing of the cache.; Estimates a suitable size for the tree cache based on AutoFlush.; A cache sizing factor is taken from the configuration. If this yields zero; and withDefault is true the historical algoirthm for default size is used. TFile* GetCurrentFile() const; Return pointer to the current file. Long64_t GetEntries(const char* selection); Return the number of",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:94165,Availability,error,errors,94165,"tAlias(const char* aliasName) const; Returns the expanded value of the alias. Search in the friends if any. TBranch* GetBranch(const char* name); Return pointer to the branch with the given name in this tree or its friends. Bool_t GetBranchStatus(const char* branchname) const; Return status of branch with name branchname.; 0 if branch is not activated; 1 if branch is activated. Int_t GetBranchStyle(); Static function returning the current branch style.; style = 0 old Branch; style = 1 new Bronch. Long64_t GetCacheAutoSize(Bool_t withDefault = kFALSE) const; Used for automatic sizing of the cache.; Estimates a suitable size for the tree cache based on AutoFlush.; A cache sizing factor is taken from the configuration. If this yields zero; and withDefault is true the historical algoirthm for default size is used. TFile* GetCurrentFile() const; Return pointer to the current file. Long64_t GetEntries(const char* selection); Return the number of entries matching the selection.; Return -1 in case of errors. If the selection uses any arrays or containers, we return the number; of entries where at least one element match the selection.; GetEntries is implemented using the selector class TSelectorEntries,; which can be used directly (see code in TTreePlayer::GetEntries) for; additional option.; If SetEventList was used on the TTree or TChain, only that subset; of entries will be considered. Long64_t GetEntriesFriend() const; Return pointer to the 1st Leaf named name in any Branch of this Tree or; any branch in the list of friend trees. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all branches of entry and return total number of bytes read. getall = 0 : get only active branches; getall = 1 : get all branches. The function returns the number of bytes read from the input buffer.; If entry does not exist the function returns 0.; If an I/O error occurs, the function returns -1. If the Tree has friends, also read the friends entry. To activate/deactivate one or more b",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:95028,Availability,error,error,95028,"ile. Long64_t GetEntries(const char* selection); Return the number of entries matching the selection.; Return -1 in case of errors. If the selection uses any arrays or containers, we return the number; of entries where at least one element match the selection.; GetEntries is implemented using the selector class TSelectorEntries,; which can be used directly (see code in TTreePlayer::GetEntries) for; additional option.; If SetEventList was used on the TTree or TChain, only that subset; of entries will be considered. Long64_t GetEntriesFriend() const; Return pointer to the 1st Leaf named name in any Branch of this Tree or; any branch in the list of friend trees. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all branches of entry and return total number of bytes read. getall = 0 : get only active branches; getall = 1 : get all branches. The function returns the number of bytes read from the input buffer.; If entry does not exist the function returns 0.; If an I/O error occurs, the function returns -1. If the Tree has friends, also read the friends entry. To activate/deactivate one or more branches, use TBranch::SetBranchStatus; For example, if you have a Tree with several hundred branches, and you; are interested only by branches named ""a"" and ""b"", do; mytree.SetBranchStatus(""*"",0); //disable all branches; mytree.SetBranchStatus(""a"",1);; mytree.SetBranchStatus(""b"",1);; when calling mytree.GetEntry(i); only branches ""a"" and ""b"" will be read. WARNING!!; If your Tree has been created in split mode with a parent branch ""parent."",; mytree.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; mytree.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative is to call directly; brancha.GetEntry(i); branchb.GetEntry(i);. IMPORTANT NOTE. By default, GetEntry reuses the space allocated by the previous obj",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:98383,Availability,avail,available,98383," TClonesArray *fTracks in the Event example). If ""->"" is not; specified, the pointer member is read via buf >> pointer. In this case; the pointer may be null. Note that the option with ""->"" is faster to; read or write and it also consumes less space in the file. OPTION 2. The option AutoDelete is set; TBranch *branch = T.GetBranch(""event"");; branch->SetAddress(&event);; branch->SetAutoDelete(kTRUE);; for (Long64_t i=0;i<nentries;i++) {; T.GetEntry(i);; // the object event has been filled at this point; }; In this case, at each iteration, the object event is deleted by GetEntry; and a new instance of Event is created and filled. OPTION 3. Same as option 1, but you delete yourself the event.; for (Long64_t i=0;i<nentries;i++) {; delete event;; event = 0; // EXTREMELY IMPORTANT; T.GetEntry(i);; // the object event has been filled at this point; }. It is strongly recommended to use the default option 1. It has the; additional advantage that functions like TTree::Draw (internally calling; TTree::GetEntry) will be functional even when the classes in the file are; not available. Note: See the comments in TBranchElement::SetAddress() for the; object ownership policy of the underlying (user) data. TEntryList* GetEntryList(); Returns the entry list, set to this tree. Long64_t GetEntryNumber(Long64_t entry) const; Return entry number corresponding to entry. if no TEntryList set returns entry; else returns the entry number corresponding to the list index=entry. Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor = 0) const; Return entry number corresponding to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Long64_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that maches val, it returns directly t",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:104557,Availability,error,error,104557,"t* GetUserInfo(); Return a pointer to the list containing user objects associated to this tree. The list is automatically created if it does not exist. WARNING: By default the TTree destructor will delete all objects added; to this list. If you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void ImportClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; The function returns the total number of baskets read into memory; if negative an error occurred while loading the branches.; This method may be called to force branch baskets in memory; when random access to branch entries is required.; If random access to only a few branches is required, you should; call directly TBranch::LoadBaskets. Long64_t LoadTree(Long64_t entry); Set current entry. Returns -2 if entry does not exist (just as TChain::LoadTree()). Note: This function is overloaded in TChain. Long64_t LoadTreeFriend(Long64_t entry, TTree* T); Load entry on behalf of our master tree, we may use an index. Called by LoadTree() when the masterTree looks for the entry; number in a friend tree (us) corresponding to the passed entry; number in the masterTree. If we have no index, our entry number and the masterTree entry; number are the same. If we *do* have an index, we must find the (major, minor) value pair; in masterTree to locate our corresponding entry. Int_t MakeClass(const char* classname = 0, Option_t* option = """"); Generate a skeleton an",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:109341,Availability,error,errors,109341,"ed in the current directory or in 'path/' if it is specified.; The class generated will be named 'fileprefix'. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source files which will be included by the generated skeleton.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the; system 'unroll' classes that are not split. Unrolling a class; allows direct access to its data members (this emulates the behavior; of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bounds errors; * ability to use the branch data as an object (when the user code is available). For example with Event.root, if; Double_t somePx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somePx will updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. These two functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For ex",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:109418,Availability,avail,available,109418,"ed in the current directory or in 'path/' if it is specified.; The class generated will be named 'fileprefix'. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source files which will be included by the generated skeleton.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the; system 'unroll' classes that are not split. Unrolling a class; allows direct access to its data members (this emulates the behavior; of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bounds errors; * ability to use the branch data as an object (when the user code is available). For example with Event.root, if; Double_t somePx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somePx will updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. These two functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For ex",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:110157,Availability,avail,available,110157,"TreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bounds errors; * ability to use the branch data as an object (when the user code is available). For example with Event.root, if; Double_t somePx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somePx will updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. These two functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:111914,Availability,avail,available,111914,"ify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. Int_t MakeSelector(const char* selector = 0); Generate skeleton selector class for this tree. The following files are produced: selector.h and selector.C.; If selector is 0, the selector will be called ""nameoftree"". The generated code in selector.h includes the following:; - Identification of the original Tree and Input file name; - Definition of selector class (data and functions); - The following class functions:; - constructor and destructor; - void Begin(TTree *tree); - void SlaveBegin(TTree *tree); - void Init(TTree *tree); - Bool_t Notify(); - Bool_t Process(Long64_t entry); - void Terminate(); - void SlaveTerminate(). The class selector derives from TSelector.; The generated code in selector.C includes empty functions defined above. To use this function:; - connect your Tree file (eg: TFile f(""myfile.root"");); - T->MakeSelector(""myselect""",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:117009,Availability,error,error,117009,"nt a summary of the tree contents. If option contains ""all"" friend trees are also printed.; If option contains ""toponly"" only the top level branches are printed.; If option contains ""clusters"" information about the cluster of baskets is printed. Wildcarding can be used to print only a subset of the branches, e.g.,; T.Print(""Elec*"") will print all branches with name starting with ""Elec"". void PrintCacheStats(Option_t* option = """") const; print statistics about the TreeCache for this tree, like; ******TreeCache statistics for file: cms2.root ******; Reading 73921562 bytes in 716 transactions; Average transaction = 103.242405 Kbytes; Number of blocks in current cache: 202, total size : 6001193. if option = ""a"" the list of blocks in the cache is printed. Long64_t Process(const char* filename, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Process this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically l",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:119422,Availability,error,error,119422,"twice with the same selector file; in the same script. If this is required, proceed as indicated in NOTE1,; by getting a pointer to the corresponding TSelector,eg; workaround 1. void stubs1() {; TSelector *selector = TSelector::GetSelector(""h1test.C"");; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(selector);; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(selector);; }; or use ACLIC to compile the selector; workaround 2. void stubs2() {; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(""h1test.C+"");; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(""h1test.C+"");; }. Long64_t Process(void* selector, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Process this tree executing the code in the specified selector.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The TSelector class has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If the Tree (Chain) has an associated EventList, the loop is on the nentries; of the EventList, starting at firstentry, otherwise the loop is on the; specified Tree entries. Long64_t Project(const char* hname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Make a projection of a tree using selections. Depend",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:127284,Availability,recover,recover,127284,"oFlush mechanism is disabled. Flushing the buffers at regular intervals optimize the location of; consecutive entries on the disk by creating clusters of baskets. A cluster of baskets is a set of baskets that contains all; the data for a (consecutive) set of entries and that is stored; consecutively on the disk. When reading all the branches, this; is the minimum set of baskets that the TTreeCache will read. void SetAutoSave(Long64_t autos = -300000000); This function may be called at the start of a program to change; the default value for fAutoSave (and for SetAutoSave) is -300000000, ie 300 MBytes; When filling the Tree the branch buffers as well as the Tree header; will be flushed to disk when the watermark is reached.; If fAutoSave is positive the watermark is reached when a multiple of fAutoSave; entries have been written.; If fAutoSave is negative the watermark is reached when -fAutoSave bytes; have been written to the file.; In case of a program crash, it will be possible to recover the data in the Tree; up to the last AutoSave point. void SetBasketSize(const char* bname, Int_t buffsize = 16000); Set a branch's basket size. bname is the name of a branch.; if bname=""*"", apply to all branches.; if bname=""xxx*"", apply to all branches with name starting with xxx; see TRegexp for wildcarding options; buffsize = branc basket size. Int_t SetBranchAddress(const char* bname, void** add, TBranch** ptr = 0); Change branch address, dealing with clone trees properly.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the; meaning of the addr parameter and the object ownership policy. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Verify the validity of the type of addr before calling SetBranchAddress.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:131395,Availability,error,error,131395,"the branch based on match of the branch; 'name' and not on the branch hierarchy! In order to be able to; selectively enable a top level object that is 'split' you need to make; sure the name of the top level branch is prefixed to the sub-branches'; name (by adding a dot ('.') at the end of the Branch creation and use the; corresponding bname. I.e If your Tree has been created in split mode with a parent branch ""parent.""; (note the trailing dot).; T.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void Se",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:139711,Availability,error,error,139711,"unc->SetParLimits(4,-10,-4);; func->SetParLimits(5, 1,1);; With this setup, parameters 0->3 can vary freely; Parameter 4 has boundaries [-10,-4] with initial value -8; Parameter 5 is fixed to 100. For the fit to be meaningful, the function must be self-normalized. i.e. It must have the same integral regardless of the parameter; settings. Otherwise the fit will effectively just maximize the; area. It is mandatory to have a normalization variable; which is fixed for the fit. e.g. TF1* f1 = new TF1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; f1->SetParameters(1, 3.1, 0.01);; f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1; data->UnbinnedFit(""f1"", ""jpsimass"", ""jpsipt>3.0"");. 1, 2 and 3 Dimensional fits are supported.; See also TTree::Fit. Return status. The function return the status of the fit in the following form; fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult; The fitResult is 0 is the fit is OK.; The fitResult is negative in case of an error not connected with the fit.; The number of entries used in the fit can be obtained via; mytree.GetSelectedRows();; If the number of selected entries is null the function returns -1. void UseCurrentStyle(); Replace current attributes by current style. Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Write this object to the current directory. For more see TObject::Write; Write calls TTree::FlushBaskets before writing the tree. Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); Write this object to the current directory. For more see TObject::Write; If option & kFlushBasket, call FlushBasket before writing the tree. TTree(const TTree& tt). TTree& operator=(const TTree& tt). void AddTotBytes(Int_t tot); { fTotBytes += tot; }. void AddZipBytes(Int_t zip); { fZipBytes += zip; }. Int_t Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"). Int_t Branch(TList* list, Int_t bufsize = 32000, Int_",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:8020,Deployability,update,update,8020,"ess(Void *address); In case of dynamic structures changing with each entry for example, one must; redefine the branch address before filling the branch again.; This is done via the TBranch::SetAddress member function. ==> tree->Fill(); loops on all defined branches and for each branch invokes the Fill function. See also the class TNtuple (a simple Tree with branches of floats); and the class TNtupleD (a simple Tree with branches of doubles). Adding a Branch to an Existing Tree. You may want to add a branch to an existing tree. For example,; if one variable in the tree was computed with a certain algorithm,; you may want to try another algorithm and compare the results.; One solution is to add a new branch, fill it, and save the tree.; The code below adds a simple branch to an existing tree.; Note the kOverwrite option in the Write method, it overwrites the; existing tree. If it is not specified, two copies of the tree headers; are saved. void tree3AddBranch(){; TFile f(""tree3.root"", ""update"");. Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. //read the number of entries in the t3; Long64_t nentries = t3->GetEntries();. for (Long64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk losing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt to write the tree fails, and the; original data is erased.; In addition, adding a branch to a tree enlarges the tree and increases; the amount of memory needed to read an entry, and therefore decreases; the performance. For the",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:26279,Deployability,update,updateExisting,26279,"rtual voidSetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); Int_tSetBranchAddress(const char* bname, void** add, TBranch** ptr = 0); virtual Int_tSetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidSetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidSetBranchStyle(Int_t style = 1); virtual voidSetCacheEntryRange(Long64_t first, Long64_t last); virtual voidSetCacheLearnEntries(Int_t n = 10); virtual voidSetCacheSize(Long64_t cachesize = -1); virtual voidSetChainOffset(Long64_t offset = 0); virtual voidSetCircular(Long64_t maxEntries); virtual voidSetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidSetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidSetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tSetEntries(Long64_t n = -1); virtual voidSetEntryList(TEntryList* list, Option_t* opt = """"); virtual voidSetEstimate(Long64_t nentries = 1000000); virtual voidSetEventList(TEventList* list); virtual voidSetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineColorAlpha(Color_t lcolor, Float_t lalpha); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidSetMakeClass(Int_t make); virtual voidTAttMarker::SetMarkerAttrib",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:93868,Deployability,configurat,configuration,93868,"ram fit (see TH1::Fit); If no entries were selected, the function returns -1;; (i.e. fitResult is null is the fit is OK). Int_t FlushBaskets() const; Write to disk all the basket that have not yet been individually written. Return the number of bytes written or -1 in case of write error. const char* GetAlias(const char* aliasName) const; Returns the expanded value of the alias. Search in the friends if any. TBranch* GetBranch(const char* name); Return pointer to the branch with the given name in this tree or its friends. Bool_t GetBranchStatus(const char* branchname) const; Return status of branch with name branchname.; 0 if branch is not activated; 1 if branch is activated. Int_t GetBranchStyle(); Static function returning the current branch style.; style = 0 old Branch; style = 1 new Bronch. Long64_t GetCacheAutoSize(Bool_t withDefault = kFALSE) const; Used for automatic sizing of the cache.; Estimates a suitable size for the tree cache based on AutoFlush.; A cache sizing factor is taken from the configuration. If this yields zero; and withDefault is true the historical algoirthm for default size is used. TFile* GetCurrentFile() const; Return pointer to the current file. Long64_t GetEntries(const char* selection); Return the number of entries matching the selection.; Return -1 in case of errors. If the selection uses any arrays or containers, we return the number; of entries where at least one element match the selection.; GetEntries is implemented using the selector class TSelectorEntries,; which can be used directly (see code in TTreePlayer::GetEntries) for; additional option.; If SetEventList was used on the TTree or TChain, only that subset; of entries will be considered. Long64_t GetEntriesFriend() const; Return pointer to the 1st Leaf named name in any Branch of this Tree or; any branch in the list of friend trees. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all branches of entry and return total number of bytes read. getall = 0 : get only act",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:109561,Deployability,update,updated,109561,"keleton.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the; system 'unroll' classes that are not split. Unrolling a class; allows direct access to its data members (this emulates the behavior; of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bounds errors; * ability to use the branch data as an object (when the user code is available). For example with Event.root, if; Double_t somePx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somePx will updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. These two functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Also, optionally, the generated selector will also call methods named; macrofilename_method",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:123351,Deployability,update,updated,123351,"is created for each variable in the expression.; The total number of rows read from the file is returned. FILLING a TTree WITH MULTIPLE INPUT TEXT FILES. To fill a TTree with multiple input text files, proceed as indicated above; for the first input file and omit the second argument for subsequent calls; T.ReadFile(""file1.dat"",""branch descriptor"");; T.ReadFile(""file2.dat"");. char GetNewlineValue(istream& inputStream); Determine which newline this file is using.; Return '\r' for Windows '\r\n' as that already terminates. Long64_t ReadStream(istream& inputStream, const char* branchDescriptor = """", char delimiter = ' '); Create or simply read branches from an input stream. See reference information for TTree::ReadFile. void RecursiveRemove(TObject* obj); Make sure that obj (which is being deleted or will soon be) is no; longer referenced by this TTree. void Refresh(); Refresh contents of this tree and its branches from the current status on disk. One can call this function in case the tree file is being; updated by another process. void RemoveFriend(TTree* ); Remove a friend from the list of friends. void Reset(Option_t* option = """"); Reset baskets, buffers and entries count in all branches and leaves. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this TTree after a merge (keep the customization but; forget the data). void ResetBranchAddress(TBranch* ); Tell all of our branches to set their addresses to zero. Note: If any of our branches own any objects, they are deleted. void ResetBranchAddresses(); Tell all of our branches to drop their current objects and allocate new ones. Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Loop over tree entries and print entries passing selection. If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::S",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:133612,Deployability,update,updateExisting,133612,"er branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE 4:; A circular Tree can still be saved in a file. When read back,; it is still a circular Tree and can be filled again. void SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999); Set the debug level and the debug range. For entries in the debug range, the functions TBranchElement::Fill; and TBranchElement::GetEntry will print the number of bytes filled; or read for each branch. void SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); Update the default value for the branch's fEntryOffsetLen.; If updateExisting is true, also update all the existing branches.; If newdefault is less than 10, the new default value will be 10. void SetDirectory(TDirectory* dir); Change the tree's directory. Remove reference to this tree from current directory and; add reference to new directory dir. The dir parameter can; be 0 in which case the tree does not belong to any directory. Long64_t SetEntries(Long64_t n = -1); Change number of entries in the tree. If n >= 0, set number of entries in the tree = n. If n < 0, set number of entries in the tree to match the; number of entries in each branch. (default for n is -1). This function should be called only when one fills each branch; independently via TBranch::Fill without calling TTree::Fill.; Calling TTree::SetEntries() make sense only if the number of entries; in each branch is identical, a warning is issued otherwise.; The function returns the number of entries. void SetEn",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:133701,Deployability,update,updateExisting,133701,"having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE 4:; A circular Tree can still be saved in a file. When read back,; it is still a circular Tree and can be filled again. void SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999); Set the debug level and the debug range. For entries in the debug range, the functions TBranchElement::Fill; and TBranchElement::GetEntry will print the number of bytes filled; or read for each branch. void SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); Update the default value for the branch's fEntryOffsetLen.; If updateExisting is true, also update all the existing branches.; If newdefault is less than 10, the new default value will be 10. void SetDirectory(TDirectory* dir); Change the tree's directory. Remove reference to this tree from current directory and; add reference to new directory dir. The dir parameter can; be 0 in which case the tree does not belong to any directory. Long64_t SetEntries(Long64_t n = -1); Change number of entries in the tree. If n >= 0, set number of entries in the tree = n. If n < 0, set number of entries in the tree to match the; number of entries in each branch. (default for n is -1). This function should be called only when one fills each branch; independently via TBranch::Fill without calling TTree::Fill.; Calling TTree::SetEntries() make sense only if the number of entries; in each branch is identical, a warning is issued otherwise.; The function returns the number of entries. void SetEntryList(TEntryList* list, Option_t* opt = """"); Set an EntryList. void SetEventList(TEventList* list); Th",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:133730,Deployability,update,update,133730,"having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE 4:; A circular Tree can still be saved in a file. When read back,; it is still a circular Tree and can be filled again. void SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999); Set the debug level and the debug range. For entries in the debug range, the functions TBranchElement::Fill; and TBranchElement::GetEntry will print the number of bytes filled; or read for each branch. void SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); Update the default value for the branch's fEntryOffsetLen.; If updateExisting is true, also update all the existing branches.; If newdefault is less than 10, the new default value will be 10. void SetDirectory(TDirectory* dir); Change the tree's directory. Remove reference to this tree from current directory and; add reference to new directory dir. The dir parameter can; be 0 in which case the tree does not belong to any directory. Long64_t SetEntries(Long64_t n = -1); Change number of entries in the tree. If n >= 0, set number of entries in the tree = n. If n < 0, set number of entries in the tree to match the; number of entries in each branch. (default for n is -1). This function should be called only when one fills each branch; independently via TBranch::Fill without calling TTree::Fill.; Calling TTree::SetEntries() make sense only if the number of entries; in each branch is identical, a warning is issued otherwise.; The function returns the number of entries. void SetEntryList(TEntryList* list, Option_t* opt = """"); Set an EntryList. void SetEventList(TEventList* list); Th",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:5098,Energy Efficiency,allocate,allocated,5098,"each data member or object; of the object itself. In case the object member is a TClonesArray,; the mechanism described in case C is applied to this array.; * if splitlevel=2 ,this branch will automatically be split; into subbranches, with one subbranch for each data member or object; of the object itself. In case the object member is a TClonesArray,; it is processed as a TObject*, only one branch. Note: The pointer whose address is passed to TTree::Branch must not; be destroyed (i.e. go out of scope) until the TTree is deleted or; TTree::ResetBranchAddress is called. Note: The pointer p_object must be initialized before calling TTree::Branch; Do either:; MyDataClass* p_object = 0;; tree->Branch(branchname, &p_object);; Or; MyDataClass* p_object = new MyDataClass;; tree->Branch(branchname, &p_object);; Whether the pointer is set to zero or not, the ownership of the object; is not taken over by the TTree. I.e. eventhough an object will be allocated; by TTree::Branch if the pointer p_object is zero, the object will <b>not</b>; be deleted when the TTree is deleted. ==> Case C. MyClass object;; TBranch *branch = tree->Branch(branchname, &object, bufsize, splitlevel). Note: The 2nd parameter must be the address of a valid object.; The object must not be destroyed (i.e. be deleted) until the TTree; is deleted or TTree::ResetBranchAddress is called. * if splitlevel=0, the object is serialized in the branch buffer.; * if splitlevel=1 (default), this branch will automatically be split; into subbranches, with one subbranch for each data member or object; of the object itself. In case the object member is a TClonesArray,; the mechanism described in case C is applied to this array.; * if splitlevel=2 ,this branch will automatically be split; into subbranches, with one subbranch for each data member or object; of the object itself. In case the object member is a TClonesArray,; it is processed as a TObject*, only one branch. ==> Case D. TBranch *branch = tree->Branch(branchname,c",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:33834,Energy Efficiency,allocate,allocated,33834,s explicitly given by user; Long64_tfChainOffset! Offset of 1st entry of this Tree in a TChain; TList*fClones! List of cloned trees which share our addresses; Long64_t*fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tfDebug! Debug level; Long64_tfDebugMax! Last entry number to debug; Long64_tfDebugMin! First entry number to debug; Int_tfDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*fDirectory! Pointer to directory holding this tree; Long64_tfEntriesNumber of entries; TEntryList*fEntryList! Pointer to event selection list (if one); Long64_tfEstimateNumber of entries to estimate histogram limits; TEventList*fEventList! Pointer to event selection list (if one); Int_tfFileNumber! current file number (if file extensions); Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Long64_tfFlushedBytesNumber of autoflushed bytes; UInt_tfFriendLockStatus! Record which method is locking the friend recursion; TList*fFriendspointer to list of friend elements; TArrayIfIndexIndex of sorted values; TArrayDfIndexValuesSorted index values; TObjArrayfLeavesDirect pointers to individual branch leaves; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tfMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tfMaxClusterRange! Memory allocated for the cluster range.; Long64_tfMaxEntriesMaximum number of entries in case of circular buffers; Long64_tfMaxEntryLoopMaximum number of entries to process; Long64_tfMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tfNClusterRangeNumber of Cluster range in addition to the one defined by 'AutoFlush'; TStringTNamed::fNameobject id,MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:52303,Energy Efficiency,efficient,efficient,52303,"o 0 (old). Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the addobj parameter in; the case of new-style branches. Use splitlevel < 0 instead of splitlevel=0 when the class; has a custom Streamer. Note: if the split level is set to the default (99), TTree::Branch will; not issue a warning if the class can not be split. TBranch* BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); Create a new TTree BranchObject. Build a TBranchObject for an object of class classname.; addobj is the address of a pointer to an object of class classname.; IMPORTANT: classname must derive from TObject.; The class dictionary must be available (ClassDef in class header). This option requires access to the library where the corresponding class; is defined. Accessing one single data member in the object implies; reading the full object.; See the next Branch constructor for a more efficient storage; in case the entry consists of arrays of identical objects. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes an",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:54741,Energy Efficiency,power,powerful,54741," objects. At each Tree::Fill, the branch numbers containing the; referenced objects are saved to the TBranchRef basket.; When the Tree header is saved (via TTree::Write), the branch; is saved keeping the information with the pointers to the branches; having referenced objects. TBranch* Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); Create a new TTree BranchElement. WARNING about this new function. This function is designed to replace the internal; implementation of the old TTree::Branch (whose implementation; has been moved to BranchOld). NOTE: The 'Bronch' method supports only one possible calls; signature (where the object type has to be specified; explicitly and the address must be the address of a pointer).; For more flexibility use 'Branch'. Use Bronch only in (rare); cases (likely to be legacy cases) where both the new and old; implementation of Branch needs to be used at the same time. This function is far more powerful than the old Branch; function. It supports the full C++, including STL and has; the same behaviour in split or non-split mode. classname does; not have to derive from TObject. The function is based on; the new TStreamerInfo. Build a TBranchElement for an object of class classname. addr is the address of a pointer to an object of class; classname. The class dictionary must be available (ClassDef; in class header). Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the addr parameter. This option requires access to the library where the; corresponding class is defined. Accessing one single data; member in the object implies reading the full object. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of th",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:96012,Energy Efficiency,allocate,allocated,96012," If an I/O error occurs, the function returns -1. If the Tree has friends, also read the friends entry. To activate/deactivate one or more branches, use TBranch::SetBranchStatus; For example, if you have a Tree with several hundred branches, and you; are interested only by branches named ""a"" and ""b"", do; mytree.SetBranchStatus(""*"",0); //disable all branches; mytree.SetBranchStatus(""a"",1);; mytree.SetBranchStatus(""b"",1);; when calling mytree.GetEntry(i); only branches ""a"" and ""b"" will be read. WARNING!!; If your Tree has been created in split mode with a parent branch ""parent."",; mytree.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; mytree.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative is to call directly; brancha.GetEntry(i); branchb.GetEntry(i);. IMPORTANT NOTE. By default, GetEntry reuses the space allocated by the previous object; for each branch. You can force the previous object to be automatically; deleted if you call mybranch.SetAutoDelete(kTRUE) (default is kFALSE).; Example:; Consider the example in $ROOTSYS/test/Event.h; The top level branch in the tree T is declared with:; Event *event = 0; //event must be null or point to a valid object; //it must be initialized; T.SetBranchAddress(""event"",&event);; When reading the Tree, one can choose one of these 3 options:. OPTION 1. for (Long64_t i=0;i<nentries;i++) {; T.GetEntry(i);; // the object event has been filled at this point; }; The default (recommended). At the first entry an object of the class; Event will be created and pointed by event. At the following entries,; event will be overwritten by the new data. All internal members that are; TObject* are automatically deleted. It is important that these members; be in a valid state when GetEntry is called. Pointers must be correctly; initialized. However these internal members wil",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:110278,Energy Efficiency,efficient,efficient,110278,"chname' as if it was a data member; * protection against array out-of-bounds errors; * ability to use the branch data as an object (when the user code is available). For example with Event.root, if; Double_t somePx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somePx will updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. These two functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insur",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:110405,Energy Efficiency,efficient,efficient,110405,"). For example with Event.root, if; Double_t somePx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somePx will updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. These two functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the c",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:123930,Energy Efficiency,allocate,allocate,123930,"Stream, const char* branchDescriptor = """", char delimiter = ' '); Create or simply read branches from an input stream. See reference information for TTree::ReadFile. void RecursiveRemove(TObject* obj); Make sure that obj (which is being deleted or will soon be) is no; longer referenced by this TTree. void Refresh(); Refresh contents of this tree and its branches from the current status on disk. One can call this function in case the tree file is being; updated by another process. void RemoveFriend(TTree* ); Remove a friend from the list of friends. void Reset(Option_t* option = """"); Reset baskets, buffers and entries count in all branches and leaves. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this TTree after a merge (keep the customization but; forget the data). void ResetBranchAddress(TBranch* ); Tell all of our branches to set their addresses to zero. Note: If any of our branches own any objects, they are deleted. void ResetBranchAddresses(); Tell all of our branches to drop their current objects and allocate new ones. Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Loop over tree entries and print entries passing selection. If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. Bool_t SetAlias(const char* aliasName, const char* aliasFormula); Set a tree variable alias. Set an alias for an expression/formula based on the tree 'variables'. The content of 'aliasName' can be used in TTreeFormula (i.e. TTree::Draw,; TTree::Scan, TTreeViewer) and will be evaluated as the content of; 'aliasFormula'.; If the content of 'aliasFormula' only contains symbol names, periods and; array index specification (for example event.fTracks[3]), then; the content of 'aliasName' can be used as the start of symbol. If the alia",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:63433,Integrability,rout,routines,63433,"r of the first entry they contain). This means that on; the file the baskets will be in the order in which they will be; needed when reading the whole tree sequentially. For examples of CloneTree, see tutorials:. -- copytree. A macro to copy a subset of a TTree to a new TTree. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. -- copytree2. A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. void CopyAddresses(TTree* , Bool_t undo = kFALSE); Set branch addresses of passed tree equal to ours.; If undo is true, reset the branch address instead of copying them.; This insures 'separation' of a cloned tree from its original. Long64_t CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); Copy nentries from given tree to this tree.; This routines assumes that the branches that intended to be copied are; already connected. The typical case is that this tree was created using; tree->CloneTree(0). By default copy all entries. Returns number of bytes copied to this tree. If 'option' contains the word 'fast' and nentries is -1, the cloning will be; done without unzipping or unstreaming the baskets (i.e., a direct copy of the; raw bytes on disk). When 'fast' is specified, 'option' can also contains a sorting order for the; baskets in the output file. There are currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. See TTree::CloneTree for a detailed explanation of the semantics of these 3 options. If the tree or any of the underlying tree of the chain has an index, that index and any; index in the subsequent underlying TTree objects will be merged. There are currently three 'options' to control this merging:; NoIndex : all the TTreeIndex object are dropped.; DropIndexOnError : if any of the underlying TTr",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:68854,Integrability,depend,depend,68854,"sqrt(x) 2-Dim distribution of y versus sqrt(x); = px:py:pz:2.5*E produces a 3-d scatter-plot of px vs py ps pz; and the color number of each marker will be 2.5*E.; If the color number is negative it is set to 0.; If the color number is greater than the current number of colors; it is set to the highest color number.; The default number of colors is 50.; see TStyle::SetPalette for setting a new color palette. Note that the variables e1, e2 or e3 may contain a selection.; example, if e1= x*(y<0), the value histogrammed will be x if y<0; and will be 0 otherwise. The expressions can use all the operations and build-in functions; supported by TFormula (See TFormula::Analyze), including free; standing function taking numerical arguments (TMath::Bessel).; In addition, you can call member functions taking numerical; arguments. For example:; - ""TMath::BreitWigner(fPx,3,2)""; - ""event.GetHistogram().GetXaxis().GetXmax()""; Note: You can only pass expression that depend on the TTree's data; to static functions and you can only call non-static member function; with 'fixed' parameters. selection is an expression with a combination of the columns.; In a selection all the C++ operators are authorized.; The value corresponding to the selection expression is used as a weight; to fill the histogram.; If the expression includes only boolean operations, the result; is 0 or 1. If the result is 0, the histogram is not filled.; In general, the expression may be of the form:; value*(boolean expression); if boolean expression is true, the histogram is filled with; a weight = value.; Examples:; selection1 = ""x<y && sqrt(z)>3.2""; selection2 = ""(x+y)*(sqrt(z)>3.2)""; selection1 returns a weight = 0 or 1; selection2 returns a weight = x+y if sqrt(z)>3.2; returns a weight = 0 otherwise. option is the drawing option.; - See TH1::Draw for the list of all drawing options.; - If option COL is specified when varexp has three fields:; tree.Draw(""e1:e2:e3"","""",""col"");; a 2D scatter is produced with e1 vs e",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:81473,Integrability,interface,interface,81473,"ted results. To visualize a bit more what elements; would be matched by TTree::Draw, TTree::Scan can be used:; tree->Scan(""arr1:Alt$(arr2,0)"");; will print on one line the value of arr1 and (arr2,0) that will be; matched by; tree->Draw(""arr1-Alt$(arr2,0)"");. The ternary operator is not directly supported in TTree::Draw however, to plot the; equivalent of 'var2<20 ? -99 : var1', you can use:; tree->Draw(""(var2<20)*99+(var2>=20)*var1"","""");. Drawing a user function accessing the TTree data directly. If the formula contains a file name, TTree::MakeProxy will be used; to load and execute this file. In particular it will draw the; result of a function with the same name as the file. The function; will be executed in a context where the name of the branches can; be used as a C++ variable. For example draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. The main features of this facility are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). See TTree::MakeProxy for more details. Making a Profile histogram. In case of a 2-Dim expression, one can generate a TProfile histogram; instead of a TH2F histogram by specyfying option=prof or option=profs; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of y:x>>pf; where pf is an existing TProfile histogr",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:89247,Integrability,interface,interface,89247,"t > gr->Draw(""ap""); //draw graph in current pad; creates a TGraph object with a number of points corresponding to the; number of entries selected by the expression ""pz>4"", the x points of the graph; being the px values of the Tree and the y points the py values. Important note: By default TTree::Draw creates the arrays obtained; with GetW, GetV1, GetV2, GetV3, GetV4, GetVal with a length corresponding; to the parameter fEstimate. The content will be the last; GetSelectedRows() % GetEstimate(); values calculated.; By default fEstimate=1000000 and can be modified; via TTree::SetEstimate. To keep in memory all the results (in case; where there is only one result per entry), use; tree->SetEstimate(tree->GetEntries()+1); // same as tree->SetEstimate(-1);; You must call SetEstimate if the expected number of selected rows; you need to look at is greater than 1000000. You can use the option ""goff"" to turn off the graphics output; of TTree::Draw in the above example. Automatic interface to TTree::Draw via the TTreeViewer. A complete graphical interface to this function is implemented; in the class TTreeViewer.; To start the TTreeViewer, three possibilities:; - select TTree context menu item ""StartViewer""; - type the command ""TTreeViewer TV(treeName)""; - execute statement ""tree->StartViewer();"". void DropBaskets(); Remove some baskets from memory. void DropBuffers(Int_t nbytes); Drop branch buffers to accommodate nbytes below MaxVirtualsize. Int_t Fill(); Fill all branches. This function loops on all the branches of this tree. For; each branch, it copies to the branch buffer (basket) the current; values of the leaves data types. If a leaf is a simple data type,; a simple conversion to a machine independent format has to be done. This machine independent version of the data is copied into a; basket (each branch has its own basket). When a basket is full; (32k worth of data by default), it is then optionally compressed; and written to disk (this operation is also called committ",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:89314,Integrability,interface,interface,89314,"with a number of points corresponding to the; number of entries selected by the expression ""pz>4"", the x points of the graph; being the px values of the Tree and the y points the py values. Important note: By default TTree::Draw creates the arrays obtained; with GetW, GetV1, GetV2, GetV3, GetV4, GetVal with a length corresponding; to the parameter fEstimate. The content will be the last; GetSelectedRows() % GetEstimate(); values calculated.; By default fEstimate=1000000 and can be modified; via TTree::SetEstimate. To keep in memory all the results (in case; where there is only one result per entry), use; tree->SetEstimate(tree->GetEntries()+1); // same as tree->SetEstimate(-1);; You must call SetEstimate if the expected number of selected rows; you need to look at is greater than 1000000. You can use the option ""goff"" to turn off the graphics output; of TTree::Draw in the above example. Automatic interface to TTree::Draw via the TTreeViewer. A complete graphical interface to this function is implemented; in the class TTreeViewer.; To start the TTreeViewer, three possibilities:; - select TTree context menu item ""StartViewer""; - type the command ""TTreeViewer TV(treeName)""; - execute statement ""tree->StartViewer();"". void DropBaskets(); Remove some baskets from memory. void DropBuffers(Int_t nbytes); Drop branch buffers to accommodate nbytes below MaxVirtualsize. Int_t Fill(); Fill all branches. This function loops on all the branches of this tree. For; each branch, it copies to the branch buffer (basket) the current; values of the leaves data types. If a leaf is a simple data type,; a simple conversion to a machine independent format has to be done. This machine independent version of the data is copied into a; basket (each branch has its own basket). When a basket is full; (32k worth of data by default), it is then optionally compressed; and written to disk (this operation is also called committing or; 'flushing' the basket). The committed baskets are then; immediate",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:111807,Integrability,interface,interface,111807,"void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. Int_t MakeSelector(const char* selector = 0); Generate skeleton selector class for this tree. The following files are produced: selector.h and selector.C.; If selector is 0, the selector will be called ""nameoftree"". The generated code in selector.h includes the following:; - Identification of the original Tree and Input file name; - Definition of selector class (data and functions); - The following class functions:; - constructor and destructor; - void Begin(TTree *tree); - void SlaveBegin(TTree *tree); - void Init(TTree *tree); - Bool_t Notify(); - Bool_t Process(Long64_t entry); - void Terminate(); - void SlaveTerminate(). The class selector derives from TSelector.; The generated code in selector.C includes empty fun",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:131401,Integrability,message,message,131401,"the branch based on match of the branch; 'name' and not on the branch hierarchy! In order to be able to; selectively enable a top level object that is 'split' you need to make; sure the name of the top level branch is prefixed to the sub-branches'; name (by adding a dot ('.') at the end of the Branch creation and use the; corresponding bname. I.e If your Tree has been created in split mode with a parent branch ""parent.""; (note the trailing dot).; T.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void Se",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:132300,Integrability,interface,interface,132300,"0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE 4:; A circular Tree can still be saved in a file. When read back,; it is still a circular Tree and can be filled again. void SetDebug(Int",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:132395,Integrability,interface,interface,132395,"known branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE 4:; A circular Tree can still be saved in a file. When read back,; it is still a circular Tree and can be filled again. void SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999); Set the debug level and the debug range. For entries in t",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:1540,Modifiability,variab,variables,1540," Branch buffers may be; automatically written to disk or kept in memory until the Tree attribute; fMaxVirtualSize is reached. Variables of one branch are written to the; same buffer. A branch buffer is automatically compressed if the file; compression attribute is set (default). Branches may be written to different files (see TBranch::SetFile). The ROOT user can decide to make one single branch and serialize one; object into one single I/O buffer or to make several branches.; Making one single branch and one single buffer can be the right choice; when one wants to process only a subset of all entries in the tree.; (you know for example the list of entry numbers you want to process).; Making several branches is particularly interesting in the data analysis; phase, when one wants to histogram some attributes of an object (entry); without reading all the attributes. ==> TTree *tree = new TTree(name, title); Creates a Tree with name and title. Various kinds of branches can be added to a tree:; A - simple structures or list of variables. (may be for C or Fortran structures); B - any object (inheriting from TObject). (we expect this option be the most frequent); C - a ClonesArray. (a specialized object for collections of same class objects). ==> Case A. TBranch *branch = tree->Branch(branchname, address, leaflist, bufsize); * address is the address of the first item of a structure; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated b",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:1605,Modifiability,inherit,inheriting,1605,"ttribute; fMaxVirtualSize is reached. Variables of one branch are written to the; same buffer. A branch buffer is automatically compressed if the file; compression attribute is set (default). Branches may be written to different files (see TBranch::SetFile). The ROOT user can decide to make one single branch and serialize one; object into one single I/O buffer or to make several branches.; Making one single branch and one single buffer can be the right choice; when one wants to process only a subset of all entries in the tree.; (you know for example the list of entry numbers you want to process).; Making several branches is particularly interesting in the data analysis; phase, when one wants to histogram some attributes of an object (entry); without reading all the attributes. ==> TTree *tree = new TTree(name, title); Creates a Tree with name and title. Various kinds of branches can be added to a tree:; A - simple structures or list of variables. (may be for C or Fortran structures); B - any object (inheriting from TObject). (we expect this option be the most frequent); C - a ClonesArray. (a specialized object for collections of same class objects). ==> Case A. TBranch *branch = tree->Branch(branchname, address, leaflist, bufsize); * address is the address of the first item of a structure; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned inte",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:1944,Modifiability,variab,variable,1944,"ject into one single I/O buffer or to make several branches.; Making one single branch and one single buffer can be the right choice; when one wants to process only a subset of all entries in the tree.; (you know for example the list of entry numbers you want to process).; Making several branches is particularly interesting in the data analysis; phase, when one wants to histogram some attributes of an object (entry); without reading all the attributes. ==> TTree *tree = new TTree(name, title); Creates a Tree with name and title. Various kinds of branches can be added to a tree:; A - simple structures or list of variables. (may be for C or Fortran structures); B - any object (inheriting from TObject). (we expect this option be the most frequent); C - a ClonesArray. (a specialized object for collections of same class objects). ==> Case A. TBranch *branch = tree->Branch(branchname, address, leaflist, bufsize); * address is the address of the first item of a structure; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned in",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:2008,Modifiability,variab,variable,2008,"ject into one single I/O buffer or to make several branches.; Making one single branch and one single buffer can be the right choice; when one wants to process only a subset of all entries in the tree.; (you know for example the list of entry numbers you want to process).; Making several branches is particularly interesting in the data analysis; phase, when one wants to histogram some attributes of an object (entry); without reading all the attributes. ==> TTree *tree = new TTree(name, title); Creates a Tree with name and title. Various kinds of branches can be added to a tree:; A - simple structures or list of variables. (may be for C or Fortran structures); B - any object (inheriting from TObject). (we expect this option be the most frequent); C - a ClonesArray. (a specialized object for collections of same class objects). ==> Case A. TBranch *branch = tree->Branch(branchname, address, leaflist, bufsize); * address is the address of the first item of a structure; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned in",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:2030,Modifiability,variab,variable,2030,"ject into one single I/O buffer or to make several branches.; Making one single branch and one single buffer can be the right choice; when one wants to process only a subset of all entries in the tree.; (you know for example the list of entry numbers you want to process).; Making several branches is particularly interesting in the data analysis; phase, when one wants to histogram some attributes of an object (entry); without reading all the attributes. ==> TTree *tree = new TTree(name, title); Creates a Tree with name and title. Various kinds of branches can be added to a tree:; A - simple structures or list of variables. (may be for C or Fortran structures); B - any object (inheriting from TObject). (we expect this option be the most frequent); C - a ClonesArray. (a specialized object for collections of same class objects). ==> Case A. TBranch *branch = tree->Branch(branchname, address, leaflist, bufsize); * address is the address of the first item of a structure; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned in",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:2079,Modifiability,variab,variable,2079,"t of all entries in the tree.; (you know for example the list of entry numbers you want to process).; Making several branches is particularly interesting in the data analysis; phase, when one wants to histogram some attributes of an object (entry); without reading all the attributes. ==> TTree *tree = new TTree(name, title); Creates a Tree with name and title. Various kinds of branches can be added to a tree:; A - simple structures or list of variables. (may be for C or Fortran structures); B - any object (inheriting from TObject). (we expect this option be the most frequent); C - a ClonesArray. (a specialized object for collections of same class objects). ==> Case A. TBranch *branch = tree->Branch(branchname, address, leaflist, bufsize); * address is the address of the first item of a structure; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t); * If the address points to a single numerical variable, the leaflist is optional:; int value;; tre",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:2267,Modifiability,variab,variable,2267,"hen one wants to histogram some attributes of an object (entry); without reading all the attributes. ==> TTree *tree = new TTree(name, title); Creates a Tree with name and title. Various kinds of branches can be added to a tree:; A - simple structures or list of variables. (may be for C or Fortran structures); B - any object (inheriting from TObject). (we expect this option be the most frequent); C - a ClonesArray. (a specialized object for collections of same class objects). ==> Case A. TBranch *branch = tree->Branch(branchname, address, leaflist, bufsize); * address is the address of the first item of a structure; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t); * If the address points to a single numerical variable, the leaflist is optional:; int value;; tree->Branch(branchname, &value);; * If the address points to more than one numerical variable, we strongly recommend; that the variable be sorted in decreasing order of size. Any other o",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:2319,Modifiability,variab,variable,2319,"hen one wants to histogram some attributes of an object (entry); without reading all the attributes. ==> TTree *tree = new TTree(name, title); Creates a Tree with name and title. Various kinds of branches can be added to a tree:; A - simple structures or list of variables. (may be for C or Fortran structures); B - any object (inheriting from TObject). (we expect this option be the most frequent); C - a ClonesArray. (a specialized object for collections of same class objects). ==> Case A. TBranch *branch = tree->Branch(branchname, address, leaflist, bufsize); * address is the address of the first item of a structure; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t); * If the address points to a single numerical variable, the leaflist is optional:; int value;; tree->Branch(branchname, &value);; * If the address points to more than one numerical variable, we strongly recommend; that the variable be sorted in decreasing order of size. Any other o",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:2342,Modifiability,variab,variable,2342,"tributes. ==> TTree *tree = new TTree(name, title); Creates a Tree with name and title. Various kinds of branches can be added to a tree:; A - simple structures or list of variables. (may be for C or Fortran structures); B - any object (inheriting from TObject). (we expect this option be the most frequent); C - a ClonesArray. (a specialized object for collections of same class objects). ==> Case A. TBranch *branch = tree->Branch(branchname, address, leaflist, bufsize); * address is the address of the first item of a structure; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t); * If the address points to a single numerical variable, the leaflist is optional:; int value;; tree->Branch(branchname, &value);; * If the address points to more than one numerical variable, we strongly recommend; that the variable be sorted in decreasing order of size. Any other order will; result in a non-portable (even between CINT and compiled code on the platform); ",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:3042,Modifiability,variab,variable,3042,"ze); * address is the address of the first item of a structure; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t); * If the address points to a single numerical variable, the leaflist is optional:; int value;; tree->Branch(branchname, &value);; * If the address points to more than one numerical variable, we strongly recommend; that the variable be sorted in decreasing order of size. Any other order will; result in a non-portable (even between CINT and compiled code on the platform); TTree (i.e. you will not be able to read it back on a platform with a different; padding strategy). ==> Case B. TBranch *branch = tree->Branch(branchname, &p_object, bufsize, splitlevel); TBranch *branch = tree->Branch(branchname, className, &p_object, bufsize, splitlevel); * p_object is a pointer to an object.; * If className is not specified, Branch uses the type of p_object to determine the; type of the object.; * If className is used to specify explicitly the o",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:3177,Modifiability,variab,variable,3177,"ze); * address is the address of the first item of a structure; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t); * If the address points to a single numerical variable, the leaflist is optional:; int value;; tree->Branch(branchname, &value);; * If the address points to more than one numerical variable, we strongly recommend; that the variable be sorted in decreasing order of size. Any other order will; result in a non-portable (even between CINT and compiled code on the platform); TTree (i.e. you will not be able to read it back on a platform with a different; padding strategy). ==> Case B. TBranch *branch = tree->Branch(branchname, &p_object, bufsize, splitlevel); TBranch *branch = tree->Branch(branchname, className, &p_object, bufsize, splitlevel); * p_object is a pointer to an object.; * If className is not specified, Branch uses the type of p_object to determine the; type of the object.; * If className is used to specify explicitly the o",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:3219,Modifiability,variab,variable,3219,"ze); * address is the address of the first item of a structure; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t); * If the address points to a single numerical variable, the leaflist is optional:; int value;; tree->Branch(branchname, &value);; * If the address points to more than one numerical variable, we strongly recommend; that the variable be sorted in decreasing order of size. Any other order will; result in a non-portable (even between CINT and compiled code on the platform); TTree (i.e. you will not be able to read it back on a platform with a different; padding strategy). ==> Case B. TBranch *branch = tree->Branch(branchname, &p_object, bufsize, splitlevel); TBranch *branch = tree->Branch(branchname, className, &p_object, bufsize, splitlevel); * p_object is a pointer to an object.; * If className is not specified, Branch uses the type of p_object to determine the; type of the object.; * If className is used to specify explicitly the o",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:3305,Modifiability,portab,portable,3305,"iable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t); * If the address points to a single numerical variable, the leaflist is optional:; int value;; tree->Branch(branchname, &value);; * If the address points to more than one numerical variable, we strongly recommend; that the variable be sorted in decreasing order of size. Any other order will; result in a non-portable (even between CINT and compiled code on the platform); TTree (i.e. you will not be able to read it back on a platform with a different; padding strategy). ==> Case B. TBranch *branch = tree->Branch(branchname, &p_object, bufsize, splitlevel); TBranch *branch = tree->Branch(branchname, className, &p_object, bufsize, splitlevel); * p_object is a pointer to an object.; * If className is not specified, Branch uses the type of p_object to determine the; type of the object.; * If className is used to specify explicitly the object type, the className must; be of a type related to the one pointed to by the pointer. It should be either; a parent or derived class.; * if splitlevel=0, the object is serialized in the branch buffer.; * if splitlevel=1, this branch will automatically be split; into subbranches, with one subbranch for each data member or object; of the object itself. In case the object member is a TClonesArray,; the mechanism described in case C is applied to this array.; * if splitlevel=2 ,",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:7575,Modifiability,variab,variable,7575," std::deque, std::set or std::multiset containing pointers to objects.; If the splitlevel is a value bigger than 100 (TTree::kSplitCollectionOfPointers); then the collection will be written in split mode, e.g. if it contains objects of; any types deriving from TTrack this function will sort the objects; based on their type and store them in separate branches in split; mode. ==> branch->SetAddress(Void *address); In case of dynamic structures changing with each entry for example, one must; redefine the branch address before filling the branch again.; This is done via the TBranch::SetAddress member function. ==> tree->Fill(); loops on all defined branches and for each branch invokes the Fill function. See also the class TNtuple (a simple Tree with branches of floats); and the class TNtupleD (a simple Tree with branches of doubles). Adding a Branch to an Existing Tree. You may want to add a branch to an existing tree. For example,; if one variable in the tree was computed with a certain algorithm,; you may want to try another algorithm and compare the results.; One solution is to add a new branch, fill it, and save the tree.; The code below adds a simple branch to an existing tree.; Note the kOverwrite option in the Write method, it overwrites the; existing tree. If it is not specified, two copies of the tree headers; are saved. void tree3AddBranch(){; TFile f(""tree3.root"", ""update"");. Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. //read the number of entries in the t3; Long64_t nentries = t3->GetEntries();. for (Long64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk losing the; original tre",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:8737,Modifiability,extend,extend,8737," new branch, fill it, and save the tree.; The code below adds a simple branch to an existing tree.; Note the kOverwrite option in the Write method, it overwrites the; existing tree. If it is not specified, two copies of the tree headers; are saved. void tree3AddBranch(){; TFile f(""tree3.root"", ""update"");. Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. //read the number of entries in the t3; Long64_t nentries = t3->GetEntries();. for (Long64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk losing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt to write the tree fails, and the; original data is erased.; In addition, adding a branch to a tree enlarges the tree and increases; the amount of memory needed to read an entry, and therefore decreases; the performance. For these reasons, ROOT offers the concept of friends for trees (and chains).; We encourage you to use TTree::AddFriend rather than adding a branch manually. /*. */. A simple example with histograms and a tree*-*-*-; *-* ===========================================. This program creates :; - a one dimensional histogram; - a two dimensional histogram; - a profile histogram; - a tree. These objects are filled with some random numbers and saved on a file. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. #include ""TFile.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TProfile.h""; #include ""TRandom.h""; #include ""TTree.h"". //____________________________________________________________",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:37688,Modifiability,variab,variable,37688,"emove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the TTree::AddFriend; method. The tree in the diagram below has two friends (friend_tree1 and; friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. /*; ; */. The AddFriend method has two parameters, the first is the tree name and the; second is the name of the ROOT file where the friend tree is saved.; AddFriend automatically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias in the context of the friendship:. tree.AddFriend(""t",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:38151,Modifiability,variab,variables,38151,"ned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the TTree::AddFriend; method. The tree in the diagram below has two friends (friend_tree1 and; friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. /*; ; */. The AddFriend method has two parameters, the first is the tree name and the; second is the name of the ROOT file where the friend tree is saved.; AddFriend automatically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias in the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify which tree to use in; the Draw method, use the syntax:. <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can; leave out the tree and/or branch name.; For example, these commands generate a 3-d scatter plot of variable ""var""; in the TTree",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:38773,Modifiability,variab,variables,38773,"ps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the TTree::AddFriend; method. The tree in the diagram below has two friends (friend_tree1 and; friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. /*; ; */. The AddFriend method has two parameters, the first is the tree name and the; second is the name of the ROOT file where the friend tree is saved.; AddFriend automatically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias in the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify which tree to use in; the Draw method, use the syntax:. <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can; leave out the tree and/or branch name.; For example, these commands generate a 3-d scatter plot of variable ""var""; in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in; TTree ft2. tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");. /*; ; */. The picture illustrates the access of the tree and its friends with a; Draw command.; When AddFriend is called, the ROOT file is automatically opened and the; friend tree (ft1) is read into memory. The new friend (ft1) is added to; the list of friends of tree.; The number of entries in the friend must be equal or greater to the number; of entries of the original tree. If the friend tree has fewer entries a; warning is given and the mi",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:38919,Modifiability,variab,variablename,38919,"damaging it. To add a friend to the list, you can use the TTree::AddFriend; method. The tree in the diagram below has two friends (friend_tree1 and; friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. /*; ; */. The AddFriend method has two parameters, the first is the tree name and the; second is the name of the ROOT file where the friend tree is saved.; AddFriend automatically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias in the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify which tree to use in; the Draw method, use the syntax:. <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can; leave out the tree and/or branch name.; For example, these commands generate a 3-d scatter plot of variable ""var""; in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in; TTree ft2. tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");. /*; ; */. The picture illustrates the access of the tree and its friends with a; Draw command.; When AddFriend is called, the ROOT file is automatically opened and the; friend tree (ft1) is read into memory. The new friend (ft1) is added to; the list of friends of tree.; The number of entries in the friend must be equal or greater to the number; of entries of the original tree. If the friend tree has fewer entries a; warning is given and the missing entries are not included in the histogram.; To retrieve the list of friends from a tree use TTree::GetListOfFriends.; When the tree is written to file (TTree::Write), the friends list is saved; with it. An",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:38967,Modifiability,variab,variable,38967,"damaging it. To add a friend to the list, you can use the TTree::AddFriend; method. The tree in the diagram below has two friends (friend_tree1 and; friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. /*; ; */. The AddFriend method has two parameters, the first is the tree name and the; second is the name of the ROOT file where the friend tree is saved.; AddFriend automatically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias in the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify which tree to use in; the Draw method, use the syntax:. <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can; leave out the tree and/or branch name.; For example, these commands generate a 3-d scatter plot of variable ""var""; in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in; TTree ft2. tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");. /*; ; */. The picture illustrates the access of the tree and its friends with a; Draw command.; When AddFriend is called, the ROOT file is automatically opened and the; friend tree (ft1) is read into memory. The new friend (ft1) is added to; the list of friends of tree.; The number of entries in the friend must be equal or greater to the number; of entries of the original tree. If the friend tree has fewer entries a; warning is given and the missing entries are not included in the histogram.; To retrieve the list of friends from a tree use TTree::GetListOfFriends.; When the tree is written to file (TTree::Write), the friends list is saved; with it. An",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:39085,Modifiability,variab,variable,39085,"1 and; friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. /*; ; */. The AddFriend method has two parameters, the first is the tree name and the; second is the name of the ROOT file where the friend tree is saved.; AddFriend automatically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias in the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify which tree to use in; the Draw method, use the syntax:. <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can; leave out the tree and/or branch name.; For example, these commands generate a 3-d scatter plot of variable ""var""; in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in; TTree ft2. tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");. /*; ; */. The picture illustrates the access of the tree and its friends with a; Draw command.; When AddFriend is called, the ROOT file is automatically opened and the; friend tree (ft1) is read into memory. The new friend (ft1) is added to; the list of friends of tree.; The number of entries in the friend must be equal or greater to the number; of entries of the original tree. If the friend tree has fewer entries a; warning is given and the missing entries are not included in the histogram.; To retrieve the list of friends from a tree use TTree::GetListOfFriends.; When the tree is written to file (TTree::Write), the friends list is saved; with it. And when the tree is retrieved, the trees on the friends list are; also retrieved and the friendship restored.; When a tree is deleted, the ele",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:39126,Modifiability,variab,variable,39126,"1 and; friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. /*; ; */. The AddFriend method has two parameters, the first is the tree name and the; second is the name of the ROOT file where the friend tree is saved.; AddFriend automatically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias in the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify which tree to use in; the Draw method, use the syntax:. <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can; leave out the tree and/or branch name.; For example, these commands generate a 3-d scatter plot of variable ""var""; in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in; TTree ft2. tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");. /*; ; */. The picture illustrates the access of the tree and its friends with a; Draw command.; When AddFriend is called, the ROOT file is automatically opened and the; friend tree (ft1) is read into memory. The new friend (ft1) is added to; the list of friends of tree.; The number of entries in the friend must be equal or greater to the number; of entries of the original tree. If the friend tree has fewer entries a; warning is given and the missing entries are not included in the histogram.; To retrieve the list of friends from a tree use TTree::GetListOfFriends.; When the tree is written to file (TTree::Write), the friends list is saved; with it. And when the tree is retrieved, the trees on the friends list are; also retrieved and the friendship restored.; When a tree is deleted, the ele",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:39158,Modifiability,variab,variable,39158,"1 and; friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. /*; ; */. The AddFriend method has two parameters, the first is the tree name and the; second is the name of the ROOT file where the friend tree is saved.; AddFriend automatically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias in the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify which tree to use in; the Draw method, use the syntax:. <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can; leave out the tree and/or branch name.; For example, these commands generate a 3-d scatter plot of variable ""var""; in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in; TTree ft2. tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");. /*; ; */. The picture illustrates the access of the tree and its friends with a; Draw command.; When AddFriend is called, the ROOT file is automatically opened and the; friend tree (ft1) is read into memory. The new friend (ft1) is added to; the list of friends of tree.; The number of entries in the friend must be equal or greater to the number; of entries of the original tree. If the friend tree has fewer entries a; warning is given and the missing entries are not included in the histogram.; To retrieve the list of friends from a tree use TTree::GetListOfFriends.; When the tree is written to file (TTree::Write), the friends list is saved; with it. And when the tree is retrieved, the trees on the friends list are; also retrieved and the friendship restored.; When a tree is deleted, the ele",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:48247,Modifiability,variab,variables,48247,"();; a1->SetName(""a1"");; list->Add(a1);; TH1F *ha1a = new TH1F(""ha1a"",""ha1"",100,0,1);; TH1F *ha1b = new TH1F(""ha1b"",""ha1"",100,0,1);; a1->Add(ha1a);; a1->Add(ha1b);; TObjArray *b1 = new TObjArray();; b1->SetName(""b1"");; list->Add(b1);; TH1F *hb1a = new TH1F(""hb1a"",""hb1"",100,0,1);; TH1F *hb1b = new TH1F(""hb1b"",""hb1"",100,0,1);; b1->Add(hb1a);; b1->Add(hb1b);. TObjArray *a2 = new TObjArray();; a2->SetName(""a2"");; list->Add(a2);; TH1S *ha2a = new TH1S(""ha2a"",""ha2"",100,0,1);; TH1S *ha2b = new TH1S(""ha2b"",""ha2"",100,0,1);; a2->Add(ha2a);; a2->Add(ha2b);. T.Branch(list,16000,2);; T.Print();; }. Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); Create one branch for each element in the folder.; Returns the total number of branches created. TBranch* Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); Create a new TTree Branch. This Branch constructor is provided to support non-objects in; a Tree. The variables described in leaflist may be simple; variables or structures. // See the two following; constructors for writing objects in a Tree. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. * address is the address of the first item of a structure.; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a slash (/).; The variable type may be 0,1 or 2 characters. If no type is given,; the type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is assumed; of type F by default. The list of currently supported types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:48294,Modifiability,variab,variables,48294,"();; a1->SetName(""a1"");; list->Add(a1);; TH1F *ha1a = new TH1F(""ha1a"",""ha1"",100,0,1);; TH1F *ha1b = new TH1F(""ha1b"",""ha1"",100,0,1);; a1->Add(ha1a);; a1->Add(ha1b);; TObjArray *b1 = new TObjArray();; b1->SetName(""b1"");; list->Add(b1);; TH1F *hb1a = new TH1F(""hb1a"",""hb1"",100,0,1);; TH1F *hb1b = new TH1F(""hb1b"",""hb1"",100,0,1);; b1->Add(hb1a);; b1->Add(hb1b);. TObjArray *a2 = new TObjArray();; a2->SetName(""a2"");; list->Add(a2);; TH1S *ha2a = new TH1S(""ha2a"",""ha2"",100,0,1);; TH1S *ha2b = new TH1S(""ha2b"",""ha2"",100,0,1);; a2->Add(ha2a);; a2->Add(ha2b);. T.Branch(list,16000,2);; T.Print();; }. Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); Create one branch for each element in the folder.; Returns the total number of branches created. TBranch* Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); Create a new TTree Branch. This Branch constructor is provided to support non-objects in; a Tree. The variables described in leaflist may be simple; variables or structures. // See the two following; constructors for writing objects in a Tree. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. * address is the address of the first item of a structure.; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a slash (/).; The variable type may be 0,1 or 2 characters. If no type is given,; the type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is assumed; of type F by default. The list of currently supported types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:48614,Modifiability,variab,variable,48614,"ew TObjArray();; a2->SetName(""a2"");; list->Add(a2);; TH1S *ha2a = new TH1S(""ha2a"",""ha2"",100,0,1);; TH1S *ha2b = new TH1S(""ha2b"",""ha2"",100,0,1);; a2->Add(ha2a);; a2->Add(ha2b);. T.Branch(list,16000,2);; T.Print();; }. Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); Create one branch for each element in the folder.; Returns the total number of branches created. TBranch* Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); Create a new TTree Branch. This Branch constructor is provided to support non-objects in; a Tree. The variables described in leaflist may be simple; variables or structures. // See the two following; constructors for writing objects in a Tree. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. * address is the address of the first item of a structure.; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a slash (/).; The variable type may be 0,1 or 2 characters. If no type is given,; the type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is assumed; of type F by default. The list of currently supported types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t). Arrays of values are supported with the following syntax:; If leaf name has the form var[nelem], wh",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:48678,Modifiability,variab,variable,48678,"ew TObjArray();; a2->SetName(""a2"");; list->Add(a2);; TH1S *ha2a = new TH1S(""ha2a"",""ha2"",100,0,1);; TH1S *ha2b = new TH1S(""ha2b"",""ha2"",100,0,1);; a2->Add(ha2a);; a2->Add(ha2b);. T.Branch(list,16000,2);; T.Print();; }. Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); Create one branch for each element in the folder.; Returns the total number of branches created. TBranch* Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); Create a new TTree Branch. This Branch constructor is provided to support non-objects in; a Tree. The variables described in leaflist may be simple; variables or structures. // See the two following; constructors for writing objects in a Tree. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. * address is the address of the first item of a structure.; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a slash (/).; The variable type may be 0,1 or 2 characters. If no type is given,; the type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is assumed; of type F by default. The list of currently supported types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t). Arrays of values are supported with the following syntax:; If leaf name has the form var[nelem], wh",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:48700,Modifiability,variab,variable,48700,"ew TObjArray();; a2->SetName(""a2"");; list->Add(a2);; TH1S *ha2a = new TH1S(""ha2a"",""ha2"",100,0,1);; TH1S *ha2b = new TH1S(""ha2b"",""ha2"",100,0,1);; a2->Add(ha2a);; a2->Add(ha2b);. T.Branch(list,16000,2);; T.Print();; }. Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); Create one branch for each element in the folder.; Returns the total number of branches created. TBranch* Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); Create a new TTree Branch. This Branch constructor is provided to support non-objects in; a Tree. The variables described in leaflist may be simple; variables or structures. // See the two following; constructors for writing objects in a Tree. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. * address is the address of the first item of a structure.; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a slash (/).; The variable type may be 0,1 or 2 characters. If no type is given,; the type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is assumed; of type F by default. The list of currently supported types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t). Arrays of values are supported with the following syntax:; If leaf name has the form var[nelem], wh",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:48749,Modifiability,variab,variable,48749,"= new TH1S(""ha2b"",""ha2"",100,0,1);; a2->Add(ha2a);; a2->Add(ha2b);. T.Branch(list,16000,2);; T.Print();; }. Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); Create one branch for each element in the folder.; Returns the total number of branches created. TBranch* Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); Create a new TTree Branch. This Branch constructor is provided to support non-objects in; a Tree. The variables described in leaflist may be simple; variables or structures. // See the two following; constructors for writing objects in a Tree. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. * address is the address of the first item of a structure.; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a slash (/).; The variable type may be 0,1 or 2 characters. If no type is given,; the type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is assumed; of type F by default. The list of currently supported types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t). Arrays of values are supported with the following syntax:; If leaf name has the form var[nelem], where nelem is alphanumeric, then; if nelem is a leaf name, it is used as the variable size of the array,; otherw",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:48829,Modifiability,variab,variable,48829,"h(list,16000,2);; T.Print();; }. Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); Create one branch for each element in the folder.; Returns the total number of branches created. TBranch* Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); Create a new TTree Branch. This Branch constructor is provided to support non-objects in; a Tree. The variables described in leaflist may be simple; variables or structures. // See the two following; constructors for writing objects in a Tree. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. * address is the address of the first item of a structure.; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a slash (/).; The variable type may be 0,1 or 2 characters. If no type is given,; the type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is assumed; of type F by default. The list of currently supported types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t). Arrays of values are supported with the following syntax:; If leaf name has the form var[nelem], where nelem is alphanumeric, then; if nelem is a leaf name, it is used as the variable size of the array,; otherwise return 0.; If leaf name has the form var[nelem], where nelem is a non",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:48881,Modifiability,variab,variable,48881,"h(list,16000,2);; T.Print();; }. Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); Create one branch for each element in the folder.; Returns the total number of branches created. TBranch* Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); Create a new TTree Branch. This Branch constructor is provided to support non-objects in; a Tree. The variables described in leaflist may be simple; variables or structures. // See the two following; constructors for writing objects in a Tree. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. * address is the address of the first item of a structure.; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a slash (/).; The variable type may be 0,1 or 2 characters. If no type is given,; the type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is assumed; of type F by default. The list of currently supported types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t). Arrays of values are supported with the following syntax:; If leaf name has the form var[nelem], where nelem is alphanumeric, then; if nelem is a leaf name, it is used as the variable size of the array,; otherwise return 0.; If leaf name has the form var[nelem], where nelem is a non",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:48904,Modifiability,variab,variable,48904,"nt_t splitlevel = 99); Create one branch for each element in the folder.; Returns the total number of branches created. TBranch* Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); Create a new TTree Branch. This Branch constructor is provided to support non-objects in; a Tree. The variables described in leaflist may be simple; variables or structures. // See the two following; constructors for writing objects in a Tree. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. * address is the address of the first item of a structure.; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a slash (/).; The variable type may be 0,1 or 2 characters. If no type is given,; the type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is assumed; of type F by default. The list of currently supported types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t). Arrays of values are supported with the following syntax:; If leaf name has the form var[nelem], where nelem is alphanumeric, then; if nelem is a leaf name, it is used as the variable size of the array,; otherwise return 0.; If leaf name has the form var[nelem], where nelem is a non-negative integer, then; it is used as the fixed size of the array.; If leaf name has the f",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:49732,Modifiability,variab,variable,49732,"er :; The variable name and the variable type are separated by a slash (/).; The variable type may be 0,1 or 2 characters. If no type is given,; the type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is assumed; of type F by default. The list of currently supported types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer (Int_t); - i : a 32 bit unsigned integer (UInt_t); - F : a 32 bit floating point (Float_t); - D : a 64 bit floating point (Double_t); - L : a 64 bit signed integer (Long64_t); - l : a 64 bit unsigned integer (ULong64_t); - O : [the letter 'o', not a zero] a boolean (Bool_t). Arrays of values are supported with the following syntax:; If leaf name has the form var[nelem], where nelem is alphanumeric, then; if nelem is a leaf name, it is used as the variable size of the array,; otherwise return 0.; If leaf name has the form var[nelem], where nelem is a non-negative integer, then; it is used as the fixed size of the array.; If leaf name has the form of a multi-dimensional array (e.g. var[nelem][nelem2]); where nelem and nelem2 are non-negative integer) then; it is used as a 2 dimensional array of fixed size.; Any of other form is not supported. Note that the TTree will assume that all the item are contiguous in memory.; On some platform, this is not always true of the member of a struct or a class,; due to padding and alignment. Sorting your data member in order of decreasing; sizeof usually leads to their being contiguous in memory. * bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small ",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:68315,Modifiability,variab,variables,68315,"rsus ""e2"" on the x-axis; - ""e1:e2:e3"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1""; versus ""e2"" versus ""e3"" on the x-, y-, z-axis, respectively.; - ""e1:e2:e3:e4"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1""; versus ""e2"" versus ""e3"" and ""e4"" mapped on the color number.; (to create histograms in the 2, 3, and 4 dimensional case, see section ""Saving; the result of Draw to an histogram""). Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim distribution of y versus sqrt(x); = px:py:pz:2.5*E produces a 3-d scatter-plot of px vs py ps pz; and the color number of each marker will be 2.5*E.; If the color number is negative it is set to 0.; If the color number is greater than the current number of colors; it is set to the highest color number.; The default number of colors is 50.; see TStyle::SetPalette for setting a new color palette. Note that the variables e1, e2 or e3 may contain a selection.; example, if e1= x*(y<0), the value histogrammed will be x if y<0; and will be 0 otherwise. The expressions can use all the operations and build-in functions; supported by TFormula (See TFormula::Analyze), including free; standing function taking numerical arguments (TMath::Bessel).; In addition, you can call member functions taking numerical; arguments. For example:; - ""TMath::BreitWigner(fPx,3,2)""; - ""event.GetHistogram().GetXaxis().GetXmax()""; Note: You can only pass expression that depend on the TTree's data; to static functions and you can only call non-static member function; with 'fixed' parameters. selection is an expression with a combination of the columns.; In a selection all the C++ operators are authorized.; The value corresponding to the selection expression is used as a weight; to fill the histogram.; If the expression includes only boolean operations, the result; is 0 or 1. If the result is 0, the histogram is not filled.; In general, the",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:71343,Modifiability,variab,variable,71343,"s. Let assumes, a leaf fMatrix, on the branch fEvent, which is a 3 by 3 array,; or a TClonesArray.; In a TTree::Draw expression you can now access fMatrix using the following; syntaxes:. String passed What is used for each entry of the tree. ""fMatrix"" the 9 elements of fMatrix; ""fMatrix[][]"" the 9 elements of fMatrix; ""fMatrix[2][2]"" only the elements fMatrix[2][2]; ""fMatrix[1]"" the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2]; ""fMatrix[1][]"" the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2]; ""fMatrix[][0]"" the 3 elements fMatrix[0][0], fMatrix[1][0] and fMatrix[2][0]. ""fEvent.fMatrix...."" same as ""fMatrix..."" (unless there is more than one leaf named fMatrix!). In summary, if a specific index is not specified for a dimension, TTree::Draw; will loop through all the indices along this dimension. Leaving off the; last (right most) dimension of specifying then with the two characters '[]'; is equivalent. For variable size arrays (and TClonesArray) the range; of the first dimension is recalculated for each entry of the tree.; You can also specify the index as an expression of any other variables from the; tree. TTree::Draw also now properly handling operations involving 2 or more arrays. Let assume a second matrix fResults[5][2], here are a sample of some; of the possible combinations, the number of elements they produce and; the loop used:. expression element(s) Loop. ""fMatrix[2][1] - fResults[5][2]"" one no loop; ""fMatrix[2][] - fResults[5][2]"" three on 2nd dim fMatrix; ""fMatrix[2][] - fResults[5][]"" two on both 2nd dimensions; ""fMatrix[][2] - fResults[][1]"" three on both 1st dimensions; ""fMatrix[][2] - fResults[][]"" six on both 1st and 2nd dimensions of; fResults; ""fMatrix[][2] - fResults[3][]"" two on 1st dim of fMatrix and 2nd of; fResults (at the same time); ""fMatrix[][] - fResults[][]"" six on 1st dim then on 2nd dim. ""fMatrix[][fResult[][]]"" 30 on 1st dim of fMatrix then on both; dimensions of fResults. The value; if fResults[j][k] is used ",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:71523,Modifiability,variab,variables,71523,"TTree::Draw expression you can now access fMatrix using the following; syntaxes:. String passed What is used for each entry of the tree. ""fMatrix"" the 9 elements of fMatrix; ""fMatrix[][]"" the 9 elements of fMatrix; ""fMatrix[2][2]"" only the elements fMatrix[2][2]; ""fMatrix[1]"" the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2]; ""fMatrix[1][]"" the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2]; ""fMatrix[][0]"" the 3 elements fMatrix[0][0], fMatrix[1][0] and fMatrix[2][0]. ""fEvent.fMatrix...."" same as ""fMatrix..."" (unless there is more than one leaf named fMatrix!). In summary, if a specific index is not specified for a dimension, TTree::Draw; will loop through all the indices along this dimension. Leaving off the; last (right most) dimension of specifying then with the two characters '[]'; is equivalent. For variable size arrays (and TClonesArray) the range; of the first dimension is recalculated for each entry of the tree.; You can also specify the index as an expression of any other variables from the; tree. TTree::Draw also now properly handling operations involving 2 or more arrays. Let assume a second matrix fResults[5][2], here are a sample of some; of the possible combinations, the number of elements they produce and; the loop used:. expression element(s) Loop. ""fMatrix[2][1] - fResults[5][2]"" one no loop; ""fMatrix[2][] - fResults[5][2]"" three on 2nd dim fMatrix; ""fMatrix[2][] - fResults[5][]"" two on both 2nd dimensions; ""fMatrix[][2] - fResults[][1]"" three on both 1st dimensions; ""fMatrix[][2] - fResults[][]"" six on both 1st and 2nd dimensions of; fResults; ""fMatrix[][2] - fResults[3][]"" two on 1st dim of fMatrix and 2nd of; fResults (at the same time); ""fMatrix[][] - fResults[][]"" six on 1st dim then on 2nd dim. ""fMatrix[][fResult[][]]"" 30 on 1st dim of fMatrix then on both; dimensions of fResults. The value; if fResults[j][k] is used as the second; index of fMatrix. In summary, TTree::Draw loops through all unspecified dimensions. To; fi",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:72812,Modifiability,variab,variable,72812," one no loop; ""fMatrix[2][] - fResults[5][2]"" three on 2nd dim fMatrix; ""fMatrix[2][] - fResults[5][]"" two on both 2nd dimensions; ""fMatrix[][2] - fResults[][1]"" three on both 1st dimensions; ""fMatrix[][2] - fResults[][]"" six on both 1st and 2nd dimensions of; fResults; ""fMatrix[][2] - fResults[3][]"" two on 1st dim of fMatrix and 2nd of; fResults (at the same time); ""fMatrix[][] - fResults[][]"" six on 1st dim then on 2nd dim. ""fMatrix[][fResult[][]]"" 30 on 1st dim of fMatrix then on both; dimensions of fResults. The value; if fResults[j][k] is used as the second; index of fMatrix. In summary, TTree::Draw loops through all unspecified dimensions. To; figure out the range of each loop, we match each unspecified dimension; from left to right (ignoring ALL dimensions for which an index has been; specified), in the equivalent loop matched dimensions use the same index; and are restricted to the smallest range (of only the matched dimensions).; When involving variable arrays, the range can of course be different; for each entry of the tree. So the loop equivalent to ""fMatrix[][2] - fResults[3][]"" is:. for (Int_t i0; i < min(3,2); i++) {; use the value of (fMatrix[i0][2] - fMatrix[3][i0]); }. So the loop equivalent to ""fMatrix[][2] - fResults[][]"" is:. for (Int_t i0; i < min(3,5); i++) {; for (Int_t i1; i1 < 2; i1++) {; use the value of (fMatrix[i0][2] - fMatrix[i0][i1]); }; }. So the loop equivalent to ""fMatrix[][] - fResults[][]"" is:. for (Int_t i0; i < min(3,5); i++) {; for (Int_t i1; i1 < min(3,2); i1++) {; use the value of (fMatrix[i0][i1] - fMatrix[i0][i1]); }; }. So the loop equivalent to ""fMatrix[][fResults[][]]"" is:. for (Int_t i0; i0 < 3; i0++) {; for (Int_t j2; j2 < 5; j2++) {; for (Int_t j3; j3 < 2; j3++) {; i1 = fResults[j2][j3];; use the value of fMatrix[i0][i1]; }; }. Retrieving the result of Draw. By default the temporary histogram created is called ""htemp"", but only in; the one dimensional Draw(""e1"") it contains the TTree's data points. For; a two dimension",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:74505,Modifiability,variab,variable,74505,"+) {; for (Int_t j3; j3 < 2; j3++) {; i1 = fResults[j2][j3];; use the value of fMatrix[i0][i1]; }; }. Retrieving the result of Draw. By default the temporary histogram created is called ""htemp"", but only in; the one dimensional Draw(""e1"") it contains the TTree's data points. For; a two dimensional Draw, the data is filled into a TGraph which is named; ""Graph"". They can be retrieved by calling; TH1F *htemp = (TH1F*)gPad->GetPrimitive(""htemp""); // 1D; TGraph *graph = (TGraph*)gPad->GetPrimitive(""Graph""); // 2D. For a three and four dimensional Draw the TPolyMarker3D is unnamed, and; cannot be retrieved. gPad always contains a TH1 derived object called ""htemp"" which allows to; access the axes:; TGraph *graph = (TGraph*)gPad->GetPrimitive(""Graph""); // 2D; TH2F *htemp = (TH2F*)gPad->GetPrimitive(""htemp""); // empty, but has axes; TAxis *xaxis = htemp->GetXaxis();. Saving the result of Draw to an histogram. If varexp0 contains >>hnew (following the variable(s) name(s),; the new histogram created is called hnew and it is kept in the current; directory (and also the current pad). This works for all dimensions.; Example:; tree.Draw(""sqrt(x)>>hsqrt"",""y>0""); will draw sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. To retrieve it do:; TH1F *hsqrt = (TH1F*)gDirectory->Get(""hsqrt"");. The binning information is taken from the environment variables. Hist.Binning.?D.?. In addition, the name of the histogram can be followed by up to 9; numbers between '(' and ')', where the numbers describe the; following:. 1 - bins in x-direction; 2 - lower limit in x-direction; 3 - upper limit in x-direction; 4-6 same for y-direction; 7-9 same for z-direction. When a new binning is used the new value will become the default.; Values can be skipped.; Example:; tree.Draw(""sqrt(x)>>hsqrt(500,10,20)""); // plot sqrt(x) between 10 and 20 using 500 bins; tree.Draw(""sqrt(x):sin(y)>>hsqrt(100,10,60,50,.1,.5)""); // plot sqrt(x) against sin(y); // 100 bins in x-direction; lower limit on x",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:74915,Modifiability,variab,variables,74915," is named; ""Graph"". They can be retrieved by calling; TH1F *htemp = (TH1F*)gPad->GetPrimitive(""htemp""); // 1D; TGraph *graph = (TGraph*)gPad->GetPrimitive(""Graph""); // 2D. For a three and four dimensional Draw the TPolyMarker3D is unnamed, and; cannot be retrieved. gPad always contains a TH1 derived object called ""htemp"" which allows to; access the axes:; TGraph *graph = (TGraph*)gPad->GetPrimitive(""Graph""); // 2D; TH2F *htemp = (TH2F*)gPad->GetPrimitive(""htemp""); // empty, but has axes; TAxis *xaxis = htemp->GetXaxis();. Saving the result of Draw to an histogram. If varexp0 contains >>hnew (following the variable(s) name(s),; the new histogram created is called hnew and it is kept in the current; directory (and also the current pad). This works for all dimensions.; Example:; tree.Draw(""sqrt(x)>>hsqrt"",""y>0""); will draw sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. To retrieve it do:; TH1F *hsqrt = (TH1F*)gDirectory->Get(""hsqrt"");. The binning information is taken from the environment variables. Hist.Binning.?D.?. In addition, the name of the histogram can be followed by up to 9; numbers between '(' and ')', where the numbers describe the; following:. 1 - bins in x-direction; 2 - lower limit in x-direction; 3 - upper limit in x-direction; 4-6 same for y-direction; 7-9 same for z-direction. When a new binning is used the new value will become the default.; Values can be skipped.; Example:; tree.Draw(""sqrt(x)>>hsqrt(500,10,20)""); // plot sqrt(x) between 10 and 20 using 500 bins; tree.Draw(""sqrt(x):sin(y)>>hsqrt(100,10,60,50,.1,.5)""); // plot sqrt(x) against sin(y); // 100 bins in x-direction; lower limit on x-axis is 10; upper limit is 60; // 50 bins in y-direction; lower limit on y-axis is .1; upper limit is .5. By default, the specified histogram is reset.; To continue to append data to an existing histogram, use ""+"" in front; of the histogram name.; A '+' in front of the histogram name is ignored, when the name is followed by; binning informat",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:76641,Modifiability,variab,variable,76641,"inue to append data to an existing histogram, use ""+"" in front; of the histogram name.; A '+' in front of the histogram name is ignored, when the name is followed by; binning information as described in the previous paragraph.; tree.Draw(""sqrt(x)>>+hsqrt"",""y>0""); will not reset hsqrt, but will continue filling.; This works for 1-D, 2-D and 3-D histograms. Accessing collection objects. TTree::Draw default's handling of collections is to assume that any; request on a collection pertain to it content. For example, if fTracks; is a collection of Track objects, the following:; tree->Draw(""event.fTracks.fPx"");; will plot the value of fPx for each Track objects inside the collection.; Also; tree->Draw(""event.fTracks.size()"");; would plot the result of the member function Track::size() for each; Track object inside the collection.; To access information about the collection itself, TTree::Draw support; the '@' notation. If a variable which points to a collection is prefixed; or postfixed with '@', the next part of the expression will pertain to; the collection object. For example:; tree->Draw(""event.@fTracks.size()"");; will plot the size of the collection referred to by fTracks (i.e the number; of Track objects). Drawing 'objects'. When a class has a member function named AsDouble or AsString, requesting; to directly draw the object will imply a call to one of the 2 functions.; If both AsDouble and AsString are present, AsDouble will be used.; AsString can return either a char*, a std::string or a TString.s; For example, the following; tree->Draw(""event.myTTimeStamp"");; will draw the same histogram as; tree->Draw(""event.myTTimeStamp.AsDouble()"");; In addition, when the object is a type TString or std::string, TTree::Draw; will call respectively TString::Data and std::string::c_str(). If the object is a TBits, the histogram will contain the index of the bit; that are turned on. Retrieving information about the tree itself. You can refer to the tree (or chain) containing the d",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:78012,Modifiability,variab,variables,78012,"r AsString, requesting; to directly draw the object will imply a call to one of the 2 functions.; If both AsDouble and AsString are present, AsDouble will be used.; AsString can return either a char*, a std::string or a TString.s; For example, the following; tree->Draw(""event.myTTimeStamp"");; will draw the same histogram as; tree->Draw(""event.myTTimeStamp.AsDouble()"");; In addition, when the object is a type TString or std::string, TTree::Draw; will call respectively TString::Data and std::string::c_str(). If the object is a TBits, the histogram will contain the index of the bit; that are turned on. Retrieving information about the tree itself. You can refer to the tree (or chain) containing the data by using the; string 'This'.; You can then could any TTree methods. For example:; tree->Draw(""This->GetReadEntry()"");; will display the local entry numbers be read.; tree->Draw(""This->GetUserInfo()->At(0)->GetName()"");; will display the name of the first 'user info' object. Special functions and variables. Entry$: A TTree::Draw formula can use the special variable Entry$; to access the entry number being read. For example to draw every; other entry use:; tree.Draw(""myvar"",""Entry$%2==0"");. Entry$ : return the current entry number (== TTree::GetReadEntry()); LocalEntry$ : return the current entry number in the current tree of a; chain (== GetTree()->GetReadEntry()); Entries$ : return the total number of entries (== TTree::GetEntries()); Length$ : return the total number of element of this formula for this; entry (==TTreeFormula::GetNdata()); Iteration$: return the current iteration over this formula for this; entry (i.e. varies from 0 to Length$). Length$(formula): return the total number of element of the formula given as a; parameter.; Sum$(formula): return the sum of the value of the elements of the formula given; as a parameter. For example the mean for all the elements in; one entry can be calculated with:; Sum$(formula)/Length$(formula); Min$(formula): return the min",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:78073,Modifiability,variab,variable,78073,"to one of the 2 functions.; If both AsDouble and AsString are present, AsDouble will be used.; AsString can return either a char*, a std::string or a TString.s; For example, the following; tree->Draw(""event.myTTimeStamp"");; will draw the same histogram as; tree->Draw(""event.myTTimeStamp.AsDouble()"");; In addition, when the object is a type TString or std::string, TTree::Draw; will call respectively TString::Data and std::string::c_str(). If the object is a TBits, the histogram will contain the index of the bit; that are turned on. Retrieving information about the tree itself. You can refer to the tree (or chain) containing the data by using the; string 'This'.; You can then could any TTree methods. For example:; tree->Draw(""This->GetReadEntry()"");; will display the local entry numbers be read.; tree->Draw(""This->GetUserInfo()->At(0)->GetName()"");; will display the name of the first 'user info' object. Special functions and variables. Entry$: A TTree::Draw formula can use the special variable Entry$; to access the entry number being read. For example to draw every; other entry use:; tree.Draw(""myvar"",""Entry$%2==0"");. Entry$ : return the current entry number (== TTree::GetReadEntry()); LocalEntry$ : return the current entry number in the current tree of a; chain (== GetTree()->GetReadEntry()); Entries$ : return the total number of entries (== TTree::GetEntries()); Length$ : return the total number of element of this formula for this; entry (==TTreeFormula::GetNdata()); Iteration$: return the current iteration over this formula for this; entry (i.e. varies from 0 to Length$). Length$(formula): return the total number of element of the formula given as a; parameter.; Sum$(formula): return the sum of the value of the elements of the formula given; as a parameter. For example the mean for all the elements in; one entry can be calculated with:; Sum$(formula)/Length$(formula); Min$(formula): return the minimun (within one TTree entry) of the value of the; elements of the fo",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:79982,Modifiability,variab,variable,79982,"he formula given as a parameter.; Max$(formula): return the maximum (within one TTree entry) of the value of the; elements of the formula given as a parameter.; MinIf$(formula,condition); MaxIf$(formula,condition): return the minimum (maximum) (within one TTree entry); of the value of the elements of the formula given as a parameter; if they match the condition. If no element matches the condition,; the result is zero. To avoid the resulting peak at zero, use the; pattern:; tree->Draw(""MinIf$(formula,condition)"",""condition"");; which will avoid calculation MinIf$ for the entries that have no match; for the condition. Alt$(primary,alternate) : return the value of ""primary"" if it is available; for the current iteration otherwise return the value of ""alternate"".; For example, with arr1[3] and arr2[2]; tree->Draw(""arr1+Alt$(arr2,0)"");; will draw arr1[0]+arr2[0] ; arr1[1]+arr2[1] and arr1[2]+0; Or with a variable size array arr3; tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); As a comparison; tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the; actual_size_of_arr3 is greater or equal to 3.; Note that the array in 'primary' is flattened/linearized thus using; Alt$ with multi-dimensional arrays of different dimensions in unlikely; to yield the expected results. To visualize a bit more what elements; would be matched by TTree::Draw, TTree::Scan can be used:; tree->Scan(""arr1:Alt$(arr2,0)"");; will print on one line the value of arr1 and (arr2,0) that will be; matched by; tree->Draw(""arr1-Alt$(arr2,0)"");. The ternary operator is not directly supported in TTree::Draw however, to plot the; equivalent of 'var2<20 ? -99 : var1', you can use:; tree->Draw(""(var2<20)*99+(var2>=20)*var1"","""");. Drawing a user function accessing the TTree data directly. If the formula contains a file name, TTree::MakeProxy will be used; to load and execute this file. In par",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:81247,Modifiability,variab,variable,81247,"ill draw the sum arr3 for the index 0 to 2 only if the; actual_size_of_arr3 is greater or equal to 3.; Note that the array in 'primary' is flattened/linearized thus using; Alt$ with multi-dimensional arrays of different dimensions in unlikely; to yield the expected results. To visualize a bit more what elements; would be matched by TTree::Draw, TTree::Scan can be used:; tree->Scan(""arr1:Alt$(arr2,0)"");; will print on one line the value of arr1 and (arr2,0) that will be; matched by; tree->Draw(""arr1-Alt$(arr2,0)"");. The ternary operator is not directly supported in TTree::Draw however, to plot the; equivalent of 'var2<20 ? -99 : var1', you can use:; tree->Draw(""(var2<20)*99+(var2>=20)*var1"","""");. Drawing a user function accessing the TTree data directly. If the formula contains a file name, TTree::MakeProxy will be used; to load and execute this file. In particular it will draw the; result of a function with the same name as the file. The function; will be executed in a context where the name of the branches can; be used as a C++ variable. For example draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. The main features of this facility are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). See TTree::MakeProxy for more details. Making a Profile histogram. In case of a 2-Dim expression, one can generate a TProfile histogram; instead of a TH2F histogram by specyfying option=prof or option=profs; or ",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:82988,Modifiability,variab,variables,82988,"le). See TTree::MakeProxy for more details. Making a Profile histogram. In case of a 2-Dim expression, one can generate a TProfile histogram; instead of a TH2F histogram by specyfying option=prof or option=profs; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of y:x>>pf; where pf is an existing TProfile histogram. Making a 2D Profile histogram. In case of a 3-Dim expression, one can generate a TProfile2D histogram; instead of a TH3F histogram by specifying option=prof or option=profs.; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of z:y:x>>pf; where pf is an existing TProfile2D histogram. Making a 5D plot using GL. If option GL5D is specified together with 5 variables, a 5D plot is drawn; using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example. Making a parallel coordinates plot. In case of a 2-Dim or more expression with the option=para, one can generate; a parallel coordinates plot. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Making a candle sticks chart. In case of a 2-Dim or more expression with the option=candle, one can generate; a candle sticks chart. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Normalizing the output histogram to 1. When option contains ""norm"" the output histogram is normalized to 1. Saving the result of Draw to a TEventList, a TEntryList or a TEntryListArray. TTree::Draw can be used to fill a TEventList object (list of entry numbers); instead of histogramming one varia",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:83301,Modifiability,variab,variables,83301,"etails on the differences.; The option=prof is automatically selected in case of y:x>>pf; where pf is an existing TProfile histogram. Making a 2D Profile histogram. In case of a 3-Dim expression, one can generate a TProfile2D histogram; instead of a TH3F histogram by specifying option=prof or option=profs.; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of z:y:x>>pf; where pf is an existing TProfile2D histogram. Making a 5D plot using GL. If option GL5D is specified together with 5 variables, a 5D plot is drawn; using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example. Making a parallel coordinates plot. In case of a 2-Dim or more expression with the option=para, one can generate; a parallel coordinates plot. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Making a candle sticks chart. In case of a 2-Dim or more expression with the option=candle, one can generate; a candle sticks chart. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Normalizing the output histogram to 1. When option contains ""norm"" the output histogram is normalized to 1. Saving the result of Draw to a TEventList, a TEntryList or a TEntryListArray. TTree::Draw can be used to fill a TEventList object (list of entry numbers); instead of histogramming one variable.; If varexp0 has the form >>elist , a TEventList object named ""elist""; is created in the current directory. elist will contain the list; of entry numbers satisfying the current selection.; If option ""entrylist"" is used, a TEntryList object is created; If the selection contains arrays, vectors or any container class and option; ""entrylistarray",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:83601,Modifiability,variab,variables,83601,"=profs.; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of z:y:x>>pf; where pf is an existing TProfile2D histogram. Making a 5D plot using GL. If option GL5D is specified together with 5 variables, a 5D plot is drawn; using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example. Making a parallel coordinates plot. In case of a 2-Dim or more expression with the option=para, one can generate; a parallel coordinates plot. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Making a candle sticks chart. In case of a 2-Dim or more expression with the option=candle, one can generate; a candle sticks chart. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Normalizing the output histogram to 1. When option contains ""norm"" the output histogram is normalized to 1. Saving the result of Draw to a TEventList, a TEntryList or a TEntryListArray. TTree::Draw can be used to fill a TEventList object (list of entry numbers); instead of histogramming one variable.; If varexp0 has the form >>elist , a TEventList object named ""elist""; is created in the current directory. elist will contain the list; of entry numbers satisfying the current selection.; If option ""entrylist"" is used, a TEntryList object is created; If the selection contains arrays, vectors or any container class and option; ""entrylistarray"" is used, a TEntryListArray object is created; containing also the subentries satisfying the selection, i.e. the indices of; the branches which hold containers classes.; Example:; tree.Draw("">>yplus"",""y>0""); will create a TEventList object named ""yplus"" in the current directory.; In an interactive ",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:83983,Modifiability,variab,variable,83983,"using GL. If option GL5D is specified together with 5 variables, a 5D plot is drawn; using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example. Making a parallel coordinates plot. In case of a 2-Dim or more expression with the option=para, one can generate; a parallel coordinates plot. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Making a candle sticks chart. In case of a 2-Dim or more expression with the option=candle, one can generate; a candle sticks chart. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Normalizing the output histogram to 1. When option contains ""norm"" the output histogram is normalized to 1. Saving the result of Draw to a TEventList, a TEntryList or a TEntryListArray. TTree::Draw can be used to fill a TEventList object (list of entry numbers); instead of histogramming one variable.; If varexp0 has the form >>elist , a TEventList object named ""elist""; is created in the current directory. elist will contain the list; of entry numbers satisfying the current selection.; If option ""entrylist"" is used, a TEntryList object is created; If the selection contains arrays, vectors or any container class and option; ""entrylistarray"" is used, a TEntryListArray object is created; containing also the subentries satisfying the selection, i.e. the indices of; the branches which hold containers classes.; Example:; tree.Draw("">>yplus"",""y>0""); will create a TEventList object named ""yplus"" in the current directory.; In an interactive session, one can type (after TTree::Draw); yplus.Print(""all""); to print the list of entry numbers in the list.; tree.Draw("">>yplus"", ""y>0"", ""entrylist""); will create a TEntryList object names ""yplus"" in the current directory; tree.Draw("">>yplus"", ""y>0"", ""entrylistarray""); will create a TEntryListA",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:93868,Modifiability,config,configuration,93868,"ram fit (see TH1::Fit); If no entries were selected, the function returns -1;; (i.e. fitResult is null is the fit is OK). Int_t FlushBaskets() const; Write to disk all the basket that have not yet been individually written. Return the number of bytes written or -1 in case of write error. const char* GetAlias(const char* aliasName) const; Returns the expanded value of the alias. Search in the friends if any. TBranch* GetBranch(const char* name); Return pointer to the branch with the given name in this tree or its friends. Bool_t GetBranchStatus(const char* branchname) const; Return status of branch with name branchname.; 0 if branch is not activated; 1 if branch is activated. Int_t GetBranchStyle(); Static function returning the current branch style.; style = 0 old Branch; style = 1 new Bronch. Long64_t GetCacheAutoSize(Bool_t withDefault = kFALSE) const; Used for automatic sizing of the cache.; Estimates a suitable size for the tree cache based on AutoFlush.; A cache sizing factor is taken from the configuration. If this yields zero; and withDefault is true the historical algoirthm for default size is used. TFile* GetCurrentFile() const; Return pointer to the current file. Long64_t GetEntries(const char* selection); Return the number of entries matching the selection.; Return -1 in case of errors. If the selection uses any arrays or containers, we return the number; of entries where at least one element match the selection.; GetEntries is implemented using the selector class TSelectorEntries,; which can be used directly (see code in TTreePlayer::GetEntries) for; additional option.; If SetEventList was used on the TTree or TChain, only that subset; of entries will be considered. Long64_t GetEntriesFriend() const; Return pointer to the 1st Leaf named name in any Branch of this Tree or; any branch in the list of friend trees. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all branches of entry and return total number of bytes read. getall = 0 : get only act",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:107420,Modifiability,variab,variables,107420,"ated by this function.; In a ROOT session, you can do:; root > .L MyClass.C; root > MyClass* t = new MyClass;; root > t->GetEntry(12); // Fill data members of t with entry number 12.; root > t->Show(); // Show values of entry 12.; root > t->Show(16); // Read and show values of entry 16.; root > t->Loop(); // Loop on all entries. NOTE: Do not use the code generated for a single TTree which is part; of a TChain to process that entire TChain. The maximum dimensions; calculated for arrays on the basis of a single TTree from the TChain; might be (will be!) too small when processing all of the TTrees in; the TChain. You must use myChain.MakeClass() to generate the code,; not myTree.MakeClass(...). Int_t MakeCode(const char* filename = 0); Generate a skeleton function for this tree. The function code is written on filename.; If filename is 0, filename will be called nameoftree.C. The generated code includes the following:; - Identification of the original Tree and Input file name,; - Opening the Tree file,; - Declaration of Tree variables,; - Setting of branches addresses,; - A skeleton for the entry loop. To use this function:; - Open your Tree file (eg: TFile f(""myfile.root"");); - T->MakeCode(""MyAnalysis.C"");; where T is the name of the TTree in file myfile.root; and MyAnalysis.C the name of the file created by this function. NOTE: Since the implementation of this function, a new and better; function TTree::MakeClass() has been developed. Int_t MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); Generate a skeleton analysis class for this Tree using TBranchProxy. TBranchProxy is the base of a class hierarchy implementing an; indirect access to the content of the branches of a TTree. ""proxyClassname"" is expected to be of the form:; [path/]fileprefix; The skeleton will then be generated in the file:; fileprefix.h; located in the current directory or in 'path/' if it is specified.; The ",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:110176,Modifiability,variab,variables,110176,"TreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bounds errors; * ability to use the branch data as an object (when the user code is available). For example with Event.root, if; Double_t somePx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somePx will updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. These two functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:110250,Modifiability,variab,variable,110250,"chname' as if it was a data member; * protection against array out-of-bounds errors; * ability to use the branch data as an object (when the user code is available). For example with Event.root, if; Double_t somePx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somePx will updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. These two functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insur",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:111380,Modifiability,variab,variable,111380," if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. Int_t MakeSelector(const char* selector = 0); Generate skeleton selector class for this tree. The following files are produced: selector.h and selector.C.; If selector is 0, the selector will be called ""nameoftree"". The generated code in selector.h includes the following:; - Identification of the ",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:115204,Modifiability,variab,variables,115204,"che is deleted. Bool_t Notify(); Function called when loading a new class library. void OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.1, Option_t* option = """"); This function may be called after having filled some entries in a Tree; Using the information in the existing branch buffers, it will reassign; new branch buffer sizes to optimize time and memory. The function computes the best values for branch buffer sizes such that; the total buffer sizes is less than maxMemory and nearby entries written; at the same time.; In case the branch compression factor for the data written so far is less; than compMin, the compression is disabled. if option =""d"" an analysis report is printed. TPrincipal* Principal(const char* varexp = """", const char* selection = """", Option_t* option = ""np"", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" generate standard histograms; If option ""p"" and ""c"" generate code of conversion functions; return a pointer to the TPrincipal object. It is the user responsibility; to delete this object.; The option default value is ""np"". see TTree::Draw for explanation of the other parameters. The created object is named ""principal"" and a reference to it; is added to the list of specials Root objects.; you can retrieve a pointer to the created object via:; TPrincipal *principal =; (TPrincipal*)gROOT->GetListOfSpecials()->FindObject(""principal"");. void Print(Option_t* option = """") const; Print a summary of the tree contents. If option contains ""all"" friend trees are also printed.; If option contains ""toponly"" only the top level branches are printed.; If option contains ""clusters"" information",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:115292,Modifiability,variab,variables,115292,"che is deleted. Bool_t Notify(); Function called when loading a new class library. void OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.1, Option_t* option = """"); This function may be called after having filled some entries in a Tree; Using the information in the existing branch buffers, it will reassign; new branch buffer sizes to optimize time and memory. The function computes the best values for branch buffer sizes such that; the total buffer sizes is less than maxMemory and nearby entries written; at the same time.; In case the branch compression factor for the data written so far is less; than compMin, the compression is disabled. if option =""d"" an analysis report is printed. TPrincipal* Principal(const char* varexp = """", const char* selection = """", Option_t* option = ""np"", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" generate standard histograms; If option ""p"" and ""c"" generate code of conversion functions; return a pointer to the TPrincipal object. It is the user responsibility; to delete this object.; The option default value is ""np"". see TTree::Draw for explanation of the other parameters. The created object is named ""principal"" and a reference to it; is added to the list of specials Root objects.; you can retrieve a pointer to the created object via:; TPrincipal *principal =; (TPrincipal*)gROOT->GetListOfSpecials()->FindObject(""principal"");. void Print(Option_t* option = """") const; Print a summary of the tree contents. If option contains ""all"" friend trees are also printed.; If option contains ""toponly"" only the top level branches are printed.; If option contains ""clusters"" information",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:121282,Modifiability,variab,variable,121282,"00000000, Long64_t firstentry = 0); Make a projection of a tree using selections. Depending on the value of varexp (described in Draw) a 1-D, 2-D, etc.,; projection of the tree will be filled in histogram hname.; Note that the dimension of hname must match with the dimension of varexp. TSQLResult* Query(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Loop over entries and return a TSQLResult object containing entries following selection. Long64_t ReadFile(const char* filename, const char* branchDescriptor = """", char delimiter = ' '); Create or simply read branches from filename. if branchDescriptor = """" (default), it is assumed that the Tree descriptor; is given in the first line of the file with a syntax like; A/D:Table[2]/F:Ntracks/I:astring/C; otherwise branchDescriptor must be specified with the above syntax.; -If the type of the first variable is not specified, it is assumed to be ""/F""; -if the type of any other variable is not specified, the type of the previous; variable is assumed. eg; x:y:z (all variables are assumed of type ""F""; x/D:y:z (all variables are of type ""D""; x:y/D:z (x is type ""F"", y and z of type ""D"". delimiter allows for the use of another delimiter besides whitespace.; This provides support for direct import of common data file formats; like csv. If delimiter != ' ' and branchDescriptor == """", then the; branch description is taken from the first line in the file, but; delimiter is used for the branch names tokenization rather than ':'.; Note however that if the values in the first line do not use the; /[type] syntax, all variables are assumed to be of type ""F"".; If the filename ends with extensions .csv or .CSV and a delimiter is; not specified (besides ' '), the delimiter is automatically set to ','. Lines in the input file starting with ""#"" are ignored. Leading whitespace; for each column data is skipped. Empty lines are skipped. A TBranch object is created",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:121361,Modifiability,variab,variable,121361,"00000000, Long64_t firstentry = 0); Make a projection of a tree using selections. Depending on the value of varexp (described in Draw) a 1-D, 2-D, etc.,; projection of the tree will be filled in histogram hname.; Note that the dimension of hname must match with the dimension of varexp. TSQLResult* Query(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Loop over entries and return a TSQLResult object containing entries following selection. Long64_t ReadFile(const char* filename, const char* branchDescriptor = """", char delimiter = ' '); Create or simply read branches from filename. if branchDescriptor = """" (default), it is assumed that the Tree descriptor; is given in the first line of the file with a syntax like; A/D:Table[2]/F:Ntracks/I:astring/C; otherwise branchDescriptor must be specified with the above syntax.; -If the type of the first variable is not specified, it is assumed to be ""/F""; -if the type of any other variable is not specified, the type of the previous; variable is assumed. eg; x:y:z (all variables are assumed of type ""F""; x/D:y:z (all variables are of type ""D""; x:y/D:z (x is type ""F"", y and z of type ""D"". delimiter allows for the use of another delimiter besides whitespace.; This provides support for direct import of common data file formats; like csv. If delimiter != ' ' and branchDescriptor == """", then the; branch description is taken from the first line in the file, but; delimiter is used for the branch names tokenization rather than ':'.; Note however that if the values in the first line do not use the; /[type] syntax, all variables are assumed to be of type ""F"".; If the filename ends with extensions .csv or .CSV and a delimiter is; not specified (besides ' '), the delimiter is automatically set to ','. Lines in the input file starting with ""#"" are ignored. Leading whitespace; for each column data is skipped. Empty lines are skipped. A TBranch object is created",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:121414,Modifiability,variab,variable,121414,"00000000, Long64_t firstentry = 0); Make a projection of a tree using selections. Depending on the value of varexp (described in Draw) a 1-D, 2-D, etc.,; projection of the tree will be filled in histogram hname.; Note that the dimension of hname must match with the dimension of varexp. TSQLResult* Query(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Loop over entries and return a TSQLResult object containing entries following selection. Long64_t ReadFile(const char* filename, const char* branchDescriptor = """", char delimiter = ' '); Create or simply read branches from filename. if branchDescriptor = """" (default), it is assumed that the Tree descriptor; is given in the first line of the file with a syntax like; A/D:Table[2]/F:Ntracks/I:astring/C; otherwise branchDescriptor must be specified with the above syntax.; -If the type of the first variable is not specified, it is assumed to be ""/F""; -if the type of any other variable is not specified, the type of the previous; variable is assumed. eg; x:y:z (all variables are assumed of type ""F""; x/D:y:z (all variables are of type ""D""; x:y/D:z (x is type ""F"", y and z of type ""D"". delimiter allows for the use of another delimiter besides whitespace.; This provides support for direct import of common data file formats; like csv. If delimiter != ' ' and branchDescriptor == """", then the; branch description is taken from the first line in the file, but; delimiter is used for the branch names tokenization rather than ':'.; Note however that if the values in the first line do not use the; /[type] syntax, all variables are assumed to be of type ""F"".; If the filename ends with extensions .csv or .CSV and a delimiter is; not specified (besides ' '), the delimiter is automatically set to ','. Lines in the input file starting with ""#"" are ignored. Leading whitespace; for each column data is skipped. Empty lines are skipped. A TBranch object is created",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:121450,Modifiability,variab,variables,121450,"jection of the tree will be filled in histogram hname.; Note that the dimension of hname must match with the dimension of varexp. TSQLResult* Query(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Loop over entries and return a TSQLResult object containing entries following selection. Long64_t ReadFile(const char* filename, const char* branchDescriptor = """", char delimiter = ' '); Create or simply read branches from filename. if branchDescriptor = """" (default), it is assumed that the Tree descriptor; is given in the first line of the file with a syntax like; A/D:Table[2]/F:Ntracks/I:astring/C; otherwise branchDescriptor must be specified with the above syntax.; -If the type of the first variable is not specified, it is assumed to be ""/F""; -if the type of any other variable is not specified, the type of the previous; variable is assumed. eg; x:y:z (all variables are assumed of type ""F""; x/D:y:z (all variables are of type ""D""; x:y/D:z (x is type ""F"", y and z of type ""D"". delimiter allows for the use of another delimiter besides whitespace.; This provides support for direct import of common data file formats; like csv. If delimiter != ' ' and branchDescriptor == """", then the; branch description is taken from the first line in the file, but; delimiter is used for the branch names tokenization rather than ':'.; Note however that if the values in the first line do not use the; /[type] syntax, all variables are assumed to be of type ""F"".; If the filename ends with extensions .csv or .CSV and a delimiter is; not specified (besides ' '), the delimiter is automatically set to ','. Lines in the input file starting with ""#"" are ignored. Leading whitespace; for each column data is skipped. Empty lines are skipped. A TBranch object is created for each variable in the expression.; The total number of rows read from the file is returned. FILLING a TTree WITH MULTIPLE INPUT TEXT FILES. To fill a TTre",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:121498,Modifiability,variab,variables,121498,"jection of the tree will be filled in histogram hname.; Note that the dimension of hname must match with the dimension of varexp. TSQLResult* Query(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Loop over entries and return a TSQLResult object containing entries following selection. Long64_t ReadFile(const char* filename, const char* branchDescriptor = """", char delimiter = ' '); Create or simply read branches from filename. if branchDescriptor = """" (default), it is assumed that the Tree descriptor; is given in the first line of the file with a syntax like; A/D:Table[2]/F:Ntracks/I:astring/C; otherwise branchDescriptor must be specified with the above syntax.; -If the type of the first variable is not specified, it is assumed to be ""/F""; -if the type of any other variable is not specified, the type of the previous; variable is assumed. eg; x:y:z (all variables are assumed of type ""F""; x/D:y:z (all variables are of type ""D""; x:y/D:z (x is type ""F"", y and z of type ""D"". delimiter allows for the use of another delimiter besides whitespace.; This provides support for direct import of common data file formats; like csv. If delimiter != ' ' and branchDescriptor == """", then the; branch description is taken from the first line in the file, but; delimiter is used for the branch names tokenization rather than ':'.; Note however that if the values in the first line do not use the; /[type] syntax, all variables are assumed to be of type ""F"".; If the filename ends with extensions .csv or .CSV and a delimiter is; not specified (besides ' '), the delimiter is automatically set to ','. Lines in the input file starting with ""#"" are ignored. Leading whitespace; for each column data is skipped. Empty lines are skipped. A TBranch object is created for each variable in the expression.; The total number of rows read from the file is returned. FILLING a TTree WITH MULTIPLE INPUT TEXT FILES. To fill a TTre",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:122000,Modifiability,variab,variables,122000," or simply read branches from filename. if branchDescriptor = """" (default), it is assumed that the Tree descriptor; is given in the first line of the file with a syntax like; A/D:Table[2]/F:Ntracks/I:astring/C; otherwise branchDescriptor must be specified with the above syntax.; -If the type of the first variable is not specified, it is assumed to be ""/F""; -if the type of any other variable is not specified, the type of the previous; variable is assumed. eg; x:y:z (all variables are assumed of type ""F""; x/D:y:z (all variables are of type ""D""; x:y/D:z (x is type ""F"", y and z of type ""D"". delimiter allows for the use of another delimiter besides whitespace.; This provides support for direct import of common data file formats; like csv. If delimiter != ' ' and branchDescriptor == """", then the; branch description is taken from the first line in the file, but; delimiter is used for the branch names tokenization rather than ':'.; Note however that if the values in the first line do not use the; /[type] syntax, all variables are assumed to be of type ""F"".; If the filename ends with extensions .csv or .CSV and a delimiter is; not specified (besides ' '), the delimiter is automatically set to ','. Lines in the input file starting with ""#"" are ignored. Leading whitespace; for each column data is skipped. Empty lines are skipped. A TBranch object is created for each variable in the expression.; The total number of rows read from the file is returned. FILLING a TTree WITH MULTIPLE INPUT TEXT FILES. To fill a TTree with multiple input text files, proceed as indicated above; for the first input file and omit the second argument for subsequent calls; T.ReadFile(""file1.dat"",""branch descriptor"");; T.ReadFile(""file2.dat"");. char GetNewlineValue(istream& inputStream); Determine which newline this file is using.; Return '\r' for Windows '\r\n' as that already terminates. Long64_t ReadStream(istream& inputStream, const char* branchDescriptor = """", char delimiter = ' '); Create or simply",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:122354,Modifiability,variab,variable,122354,"of any other variable is not specified, the type of the previous; variable is assumed. eg; x:y:z (all variables are assumed of type ""F""; x/D:y:z (all variables are of type ""D""; x:y/D:z (x is type ""F"", y and z of type ""D"". delimiter allows for the use of another delimiter besides whitespace.; This provides support for direct import of common data file formats; like csv. If delimiter != ' ' and branchDescriptor == """", then the; branch description is taken from the first line in the file, but; delimiter is used for the branch names tokenization rather than ':'.; Note however that if the values in the first line do not use the; /[type] syntax, all variables are assumed to be of type ""F"".; If the filename ends with extensions .csv or .CSV and a delimiter is; not specified (besides ' '), the delimiter is automatically set to ','. Lines in the input file starting with ""#"" are ignored. Leading whitespace; for each column data is skipped. Empty lines are skipped. A TBranch object is created for each variable in the expression.; The total number of rows read from the file is returned. FILLING a TTree WITH MULTIPLE INPUT TEXT FILES. To fill a TTree with multiple input text files, proceed as indicated above; for the first input file and omit the second argument for subsequent calls; T.ReadFile(""file1.dat"",""branch descriptor"");; T.ReadFile(""file2.dat"");. char GetNewlineValue(istream& inputStream); Determine which newline this file is using.; Return '\r' for Windows '\r\n' as that already terminates. Long64_t ReadStream(istream& inputStream, const char* branchDescriptor = """", char delimiter = ' '); Create or simply read branches from an input stream. See reference information for TTree::ReadFile. void RecursiveRemove(TObject* obj); Make sure that obj (which is being deleted or will soon be) is no; longer referenced by this TTree. void Refresh(); Refresh contents of this tree and its branches from the current status on disk. One can call this function in case the tree file is being",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:124438,Modifiability,variab,variable,124438," Remove a friend from the list of friends. void Reset(Option_t* option = """"); Reset baskets, buffers and entries count in all branches and leaves. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this TTree after a merge (keep the customization but; forget the data). void ResetBranchAddress(TBranch* ); Tell all of our branches to set their addresses to zero. Note: If any of our branches own any objects, they are deleted. void ResetBranchAddresses(); Tell all of our branches to drop their current objects and allocate new ones. Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Loop over tree entries and print entries passing selection. If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. Bool_t SetAlias(const char* aliasName, const char* aliasFormula); Set a tree variable alias. Set an alias for an expression/formula based on the tree 'variables'. The content of 'aliasName' can be used in TTreeFormula (i.e. TTree::Draw,; TTree::Scan, TTreeViewer) and will be evaluated as the content of; 'aliasFormula'.; If the content of 'aliasFormula' only contains symbol names, periods and; array index specification (for example event.fTracks[3]), then; the content of 'aliasName' can be used as the start of symbol. If the alias 'aliasName' already existed, it is replaced by the new; value. When being used, the alias can be preceded by an eventual 'Friend Alias'; (see TTree::GetFriendAlias). Return true if it was added properly. For example:; tree->SetAlias(""x1"",""(tdc1[1]-tdc1[0])/49"");; tree->SetAlias(""y1"",""(tdc1[3]-tdc1[2])/47"");; tree->SetAlias(""x2"",""(tdc2[1]-tdc2[0])/49"");; tree->SetAlias(""y2"",""(tdc2[3]-tdc2[2])/47"");; tree->Draw(""y2-y1:x2-x1"");. tree->SetAlias(""theGoodTrack"",""event.fTracks[3]"");; tree->Draw(""theGoodTrack.fPx",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:124512,Modifiability,variab,variables,124512,"t baskets, buffers and entries count in all branches and leaves. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this TTree after a merge (keep the customization but; forget the data). void ResetBranchAddress(TBranch* ); Tell all of our branches to set their addresses to zero. Note: If any of our branches own any objects, they are deleted. void ResetBranchAddresses(); Tell all of our branches to drop their current objects and allocate new ones. Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Loop over tree entries and print entries passing selection. If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. Bool_t SetAlias(const char* aliasName, const char* aliasFormula); Set a tree variable alias. Set an alias for an expression/formula based on the tree 'variables'. The content of 'aliasName' can be used in TTreeFormula (i.e. TTree::Draw,; TTree::Scan, TTreeViewer) and will be evaluated as the content of; 'aliasFormula'.; If the content of 'aliasFormula' only contains symbol names, periods and; array index specification (for example event.fTracks[3]), then; the content of 'aliasName' can be used as the start of symbol. If the alias 'aliasName' already existed, it is replaced by the new; value. When being used, the alias can be preceded by an eventual 'Friend Alias'; (see TTree::GetFriendAlias). Return true if it was added properly. For example:; tree->SetAlias(""x1"",""(tdc1[1]-tdc1[0])/49"");; tree->SetAlias(""y1"",""(tdc1[3]-tdc1[2])/47"");; tree->SetAlias(""x2"",""(tdc2[1]-tdc2[0])/49"");; tree->SetAlias(""y2"",""(tdc2[3]-tdc2[2])/47"");; tree->Draw(""y2-y1:x2-x1"");. tree->SetAlias(""theGoodTrack"",""event.fTracks[3]"");; tree->Draw(""theGoodTrack.fPx""); // same as ""event.fTracks[3].fPx"". void SetAutoFlush(Long64_t autof = -300000",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:129351,Modifiability,variab,variables,129351," and the object ownership policy. Int_t SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); Verify the validity of the type of addr before calling SetBranchAddress.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the; meaning of the addr parameter and the object ownership policy. Int_t SetBranchAddressImp(TBranch* branch, void* addr, TBranch** ptr); Change branch address, dealing with clone trees properly.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the; meaning of the addr parameter and the object ownership policy. void SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); Set branch status to Process or DoNotProcess. When reading a Tree, by default, all branches are read.; One can speed up considerably the analysis phase by activating; only the branches that hold variables involved in a query. bname is the name of a branch.; if bname=""*"", apply to all branches.; if bname=""xxx*"", apply to all branches with name starting with xxx; see TRegexp for wildcarding options; status = 1 branch will be processed; = 0 branch will not be processed; Example:; Assume a tree T with sub-branches a,b,c,d,e,f,g,etc..; when doing T.GetEntry(i) all branches are read for entry i.; to read only the branches c and e, one can do; T.SetBranchStatus(""*"",0); //disable all branches; T.SetBranchStatus(""c"",1);; T.setBranchStatus(""e"",1);; T.GetEntry(i);. bname is interpreted as a wildcarded TRegexp (see TRegexp::MakeWildcard).; Thus, ""a*b"" or ""a.*b"" matches branches starting with ""a"" and ending with; ""b"", but not any other branch with an ""a"" followed at some point by a; ""b"". For this second behavior, use ""*a*b*"". Note that TRegExp does not; support '|', and so you cannot select, e.g. track and shower branches; with ""track|shower"". WARNING! WARNI",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:135019,Modifiability,variab,variable,135019,"r. The dir parameter can; be 0 in which case the tree does not belong to any directory. Long64_t SetEntries(Long64_t n = -1); Change number of entries in the tree. If n >= 0, set number of entries in the tree = n. If n < 0, set number of entries in the tree to match the; number of entries in each branch. (default for n is -1). This function should be called only when one fills each branch; independently via TBranch::Fill without calling TTree::Fill.; Calling TTree::SetEntries() make sense only if the number of entries; in each branch is identical, a warning is issued otherwise.; The function returns the number of entries. void SetEntryList(TEntryList* list, Option_t* opt = """"); Set an EntryList. void SetEventList(TEventList* list); This function transfroms the given TEventList into a TEntryList; The new TEntryList is owned by the TTree and gets deleted when the tree; is deleted. This TEntryList can be returned by GetEntryList() function. void SetEstimate(Long64_t nentries = 1000000); Set number of entries to estimate variable limits.; If n is -1, the estimate is set to be the current maximum; for the tree (i.e. GetEntries() + 1); If n is less than -1, the behavior is undefined. void SetFileNumber(Int_t number = 0); Set fFileNumber to number.; fFileNumber is used by TTree::Fill to set the file name; for a new file to be created when the current file exceeds fgTreeMaxSize.; (see TTree::ChangeFile); if fFileNumber=10, the new file name will have a suffix ""_11"",; ie, fFileNumber is incremented before setting the file name. void SetMakeClass(Int_t make); Set all the branches in this TTree to be in decomposed object mode; (also known as MakeClass mode). void SetMaxTreeSize(Long64_t maxsize = 1900000000); Set the maximum size in bytes of a Tree file (static function).; The default size is 100000000000LL, ie 100 Gigabytes. In TTree::Fill, when the file has a size > fgMaxTreeSize,; the function closes the current file and starts writing into; a new file with a name of the st",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:137918,Modifiability,variab,variable,137918,"y TTree::Draw to automatically weight each; selected entry in the resulting histogram. For example the equivalent of:. T.Draw(""x"", ""w""). is:. T.SetWeight(w);; T.Draw(""x"");. This function is redefined by TChain::SetWeight. In case of a; TChain, an option ""global"" may be specified to set the same weight; for all trees in the TChain instead of the default behaviour; using the weights of each tree in the chain (see TChain::SetWeight). void Show(Long64_t entry = -1, Int_t lenmax = 20); Print values of all active leaves for entry. if entry==-1, print current entry (default); if a leaf is an array, a maximum of lenmax elements is printed. void StartViewer(); Start the TTreeViewer on this tree. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. void StopCacheLearningPhase(); stop the cache learning phase. void Streamer(TBuffer& ); Stream a class object. Int_t UnbinnedFit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Unbinned fit of one or more variable(s) from a tree. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if you fit a function with 6 parameters, you can do:; func->SetParameters(0,3.1,1.e-6,0.1,-8,100);; func->SetParLimits(4,-10,-4);; func->SetParLimits(5, 1,1);; With this setup, parameters 0->3 can vary freely; Parameter 4 has ",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:138037,Modifiability,variab,variable,138037," option ""global"" may be specified to set the same weight; for all trees in the TChain instead of the default behaviour; using the weights of each tree in the chain (see TChain::SetWeight). void Show(Long64_t entry = -1, Int_t lenmax = 20); Print values of all active leaves for entry. if entry==-1, print current entry (default); if a leaf is an array, a maximum of lenmax elements is printed. void StartViewer(); Start the TTreeViewer on this tree. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. void StopCacheLearningPhase(); stop the cache learning phase. void Streamer(TBuffer& ); Stream a class object. Int_t UnbinnedFit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Unbinned fit of one or more variable(s) from a tree. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if you fit a function with 6 parameters, you can do:; func->SetParameters(0,3.1,1.e-6,0.1,-8,100);; func->SetParLimits(4,-10,-4);; func->SetParLimits(5, 1,1);; With this setup, parameters 0->3 can vary freely; Parameter 4 has boundaries [-10,-4] with initial value -8; Parameter 5 is fixed to 100. For the fit to be meaningful, the function must be self-normalized. i.e. It must have the same integral regardless of the parameter; settings. Otherwise the fit will effectiv",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:139146,Modifiability,variab,variable,139146,"ptions is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if you fit a function with 6 parameters, you can do:; func->SetParameters(0,3.1,1.e-6,0.1,-8,100);; func->SetParLimits(4,-10,-4);; func->SetParLimits(5, 1,1);; With this setup, parameters 0->3 can vary freely; Parameter 4 has boundaries [-10,-4] with initial value -8; Parameter 5 is fixed to 100. For the fit to be meaningful, the function must be self-normalized. i.e. It must have the same integral regardless of the parameter; settings. Otherwise the fit will effectively just maximize the; area. It is mandatory to have a normalization variable; which is fixed for the fit. e.g. TF1* f1 = new TF1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; f1->SetParameters(1, 3.1, 0.01);; f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1; data->UnbinnedFit(""f1"", ""jpsimass"", ""jpsipt>3.0"");. 1, 2 and 3 Dimensional fits are supported.; See also TTree::Fit. Return status. The function return the status of the fit in the following form; fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult; The fitResult is 0 is the fit is OK.; The fitResult is negative in case of an error not connected with the fit.; The number of entries used in the fit can be obtained via; mytree.GetSelectedRows();; If the number of selected entries is null the function returns -1. void UseCurrentStyle(); Replace current attributes by current style. Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Write this object to the current directory. For more see TObject::Write; Write calls TTree::FlushB",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:9001,Performance,perform,performance,9001,"o copies of the tree headers; are saved. void tree3AddBranch(){; TFile f(""tree3.root"", ""update"");. Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. //read the number of entries in the t3; Long64_t nentries = t3->GetEntries();. for (Long64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk losing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt to write the tree fails, and the; original data is erased.; In addition, adding a branch to a tree enlarges the tree and increases; the amount of memory needed to read an entry, and therefore decreases; the performance. For these reasons, ROOT offers the concept of friends for trees (and chains).; We encourage you to use TTree::AddFriend rather than adding a branch manually. /*. */. A simple example with histograms and a tree*-*-*-; *-* ===========================================. This program creates :; - a one dimensional histogram; - a two dimensional histogram; - a profile histogram; - a tree. These objects are filled with some random numbers and saved on a file. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. #include ""TFile.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TProfile.h""; #include ""TRandom.h""; #include ""TTree.h"". //______________________________________________________________________________; main(int argc, char **argv); {; // Create a new ROOT binary machine independent file.; // Note that this file may contain any kind of ROOT objects, histograms,trees; // pictures, graphics ",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:26019,Performance,cache,cachesize,26019,"t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Bool_tSetAlias(const char* aliasName, const char* aliasFormula); virtual voidSetAutoFlush(Long64_t autof = -30000000); virtual voidSetAutoSave(Long64_t autos = -300000000); virtual voidSetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); Int_tSetBranchAddress(const char* bname, void** add, TBranch** ptr = 0); virtual Int_tSetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidSetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidSetBranchStyle(Int_t style = 1); virtual voidSetCacheEntryRange(Long64_t first, Long64_t last); virtual voidSetCacheLearnEntries(Int_t n = 10); virtual voidSetCacheSize(Long64_t cachesize = -1); virtual voidSetChainOffset(Long64_t offset = 0); virtual voidSetCircular(Long64_t maxEntries); virtual voidSetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidSetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidSetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tSetEntries(Long64_t n = -1); virtual voidSetEntryList(TEntryList* list, Option_t* opt = """"); virtual voidSetEstimate(Long64_t nentries = 1000000); virtual voidSetEventList(TEventList* list); virtual voidSetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillColorAlpha(Color_t fcolor, Float_t falpha); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t ",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:30779,Performance,cache,cacheSize,30779,"ry = 0); virtual voidUseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tWrite(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tWrite(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidAddClone(TTree*); virtual TBranch*BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*BronchExec(const char* name, const char* classname, void* addobj, Bool_t isptrptr, Int_t bufsize, Int_t splitlevel); virtual Int_tCheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, Bool_t ptr); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Long64_tGetCacheAutoSize(Bool_t withDefault = kFALSE) const; virtual TLeaf*GetLeafImpl(const char* branchname, const char* leafname); charGetNewlineValue(istream& inputStream); TTreeCache*GetReadCache(TFile* file, Bool_t create = kFALSE); voidImportClusterRanges(TTree* fromtree); virtual voidKeepCircular(); voidTObject::MakeZombie(); voidMoveReadCache(TFile* src, TDirectory* dir); Int_tSetBranchAddressImp(TBranch* branch, void* addr, TBranch** ptr); voidSetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0). private:. TTree(const TTree& tt); TTree&operator=(const TTree& tt). Data Members; public:. enum ELockStatusBits { kFindBranch; kFindLeaf; kGetAlias; kGetBranch; kGetEntry; kGetEntryWithIndex; kGetFriend; kGetFriendAlias; kGetLeaf; kLoadTree; kPrint; kRemoveFriend; kSetBranchStatus; };; enu",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:32042,Performance,cache,cache,32042,d; kSetBranchStatus; };; enum ESetBranchAddressStatus { kMissingBranch; kInternalError; kMissingCompiledCollectionProxy; kMismatch; kClassMismatch; kMatch; kMatchConversion; kMatchConversionCollection; kMakeClass; kVoidPtr; kNoCheck; };; enum { kForceRead; kCircular; kSplitCollectionOfPointers; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*fAliasesList of aliases for expressions based on the tree branches.; Long64_tfAutoFlushAutoflush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced; Long64_tfAutoSaveAutosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced; TBranchRef*fBranchRefBranch supporting the TRefTable (if any); TObjArrayfBranchesList of Branches; Bool_tfCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tfCacheSize! Maximum size of file buffers; Bool_tfCacheUserSet! true if the cache setting was explicitly given by user; Long64_tfChainOffset! Offset of 1st entry of this Tree in a TChain; TList*fClones! List of cloned trees which share our addresses; Long64_t*fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tfDebug! Debug level; Long64_tfDebugMax! Last entry number to debug; Long64_tfDebugMin! First entry number to debug; Int_tfDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*fDirectory! Pointer to directory holding this tree; Long64_tfEntriesNumber of entries; TEntryList*fEntryList! Pointer to event selection list (if one); Long64_tfEstimateNumber of entries to estimate histogram limits; TEventList*fEventList! Pointer to event selection list (if one); Int_tfFileNumber! current file number (if f,MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:32172,Performance,cache,cache,32172,d; kSetBranchStatus; };; enum ESetBranchAddressStatus { kMissingBranch; kInternalError; kMissingCompiledCollectionProxy; kMismatch; kClassMismatch; kMatch; kMatchConversion; kMatchConversionCollection; kMakeClass; kVoidPtr; kNoCheck; };; enum { kForceRead; kCircular; kSplitCollectionOfPointers; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TList*fAliasesList of aliases for expressions based on the tree branches.; Long64_tfAutoFlushAutoflush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced; Long64_tfAutoSaveAutosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced; TBranchRef*fBranchRefBranch supporting the TRefTable (if any); TObjArrayfBranchesList of Branches; Bool_tfCacheDoAutoInit! true if cache auto creation or resize check is needed; Long64_tfCacheSize! Maximum size of file buffers; Bool_tfCacheUserSet! true if the cache setting was explicitly given by user; Long64_tfChainOffset! Offset of 1st entry of this Tree in a TChain; TList*fClones! List of cloned trees which share our addresses; Long64_t*fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.; Long64_t*fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.; Int_tfDebug! Debug level; Long64_tfDebugMax! Last entry number to debug; Long64_tfDebugMin! First entry number to debug; Int_tfDefaultEntryOffsetLenInitial Length of fEntryOffset table in the basket buffers; TDirectory*fDirectory! Pointer to directory holding this tree; Long64_tfEntriesNumber of entries; TEntryList*fEntryList! Pointer to event selection list (if one); Long64_tfEstimateNumber of entries to estimate histogram limits; TEventList*fEventList! Pointer to event selection list (if one); Int_tfFileNumber! current file number (if f,MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:34277,Performance,load,loading,34277,dex values; TObjArrayfLeavesDirect pointers to individual branch leaves; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tfMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tfMaxClusterRange! Memory allocated for the cluster range.; Long64_tfMaxEntriesMaximum number of entries in case of circular buffers; Long64_tfMaxEntryLoopMaximum number of entries to process; Long64_tfMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tfNClusterRangeNumber of Cluster range in addition to the one defined by 'AutoFlush'; TStringTNamed::fNameobject identifier; Int_tfNfill! Local for EntryLoop; TObject*fNotify! Object to be notified when loading a Tree; Int_tfPacketSize! Number of entries in one packet for parallel root; TVirtualPerfStats*fPerfStats! pointer to the current perf stats object; TVirtualTreePlayer*fPlayer! Pointer to current Tree player; Long64_tfReadEntry! Number of the entry being processed; Long64_tfSavedBytesNumber of autosaved bytes; Int_tfScanFieldNumber of runs before prompting in Scan; Int_tfTimerIntervalTimer interval in milliseconds; TStringTNamed::fTitleobject title; Long64_tfTotBytesTotal number of bytes in all branches before compression; Long64_tfTotalBuffers! Total number of bytes in branch buffers; TBuffer*fTransientBuffer! Pointer to the current transient buffer.; TVirtualIndex*fTreeIndexPointer to the tree Index (if any); Int_tfUpdateUpdate frequency for EntryLoop; TList*fUserInfopointer to a list of user objects associated to this Tree; Double_tfWeightTree weight (see TTree::SetWeight); Long64_tfZipBytesTotal number of bytes in all branches after compression; static Int_tfgBranchStyleOld/New branch style; static Long64_tfgMaxTreeSizeMaximum size of a file containg a Tree. Class Charts. Inheritance; Inherited Memb,MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:36258,Performance,cache,cache,36258,"of bytes in all branches after compression; static Int_tfgBranchStyleOld/New branch style; static Long64_tfgMaxTreeSizeMaximum size of a file containg a Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:36309,Performance,cache,cache,36309,"style; static Long64_tfgMaxTreeSizeMaximum size of a file containg a Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filenam",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:36397,Performance,cache,cache,36397,"ree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:;",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:36498,Performance,cache,cache,36498,"; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (curren",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:36586,Performance,cache,cache,36586,"urrent directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendE",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:36717,Performance,cache,cache,36717," The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:36772,Performance,cache,cache,36772," branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree kee",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:36866,Performance,cache,cache,36866,"ion assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship m",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:36979,Performance,cache,cache,36979,"chy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the ",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:37073,Performance,cache,cache,37073,"TransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the TTree::AddFr",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:62074,Performance,optimiz,optimize,62074,"; effect. When this tree is deleted, all the addresses of; the cloned tree are reset to their default values. If 'option' contains the word 'fast' and nentries is -1, the; cloning will be done without unzipping or unstreaming the baskets; (i.e., a direct copy of the raw bytes on disk). When 'fast' is specified, 'option' can also contain a sorting; order for the baskets in the output file. There are currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in the; output file in the same order as in the original file (i.e. the; baskets are sorted by their offset in the original file; Usually; this also means that the baskets are sorted by the index/number of; the _last_ entry they contain). When using SortBasketsByBranch all the baskets of each individual; branches are stored contiguously. This tends to optimize reading; speed when reading a small number (1->5) of branches, since all; their baskets will be clustered together instead of being spread; across the file. However it might decrease the performance when; reading more branches (or the full entry). When using SortBasketsByEntry the baskets with the lowest starting; entry are written first. (i.e. the baskets are sorted by the; index/number of the first entry they contain). This means that on; the file the baskets will be in the order in which they will be; needed when reading the whole tree sequentially. For examples of CloneTree, see tutorials:. -- copytree. A macro to copy a subset of a TTree to a new TTree. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. -- copytree2. A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. void CopyAddresses(TTree* , Bool_t undo = kFALSE); Set branch addresses of passed",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:62270,Performance,perform,performance,62270,"word 'fast' and nentries is -1, the; cloning will be done without unzipping or unstreaming the baskets; (i.e., a direct copy of the raw bytes on disk). When 'fast' is specified, 'option' can also contain a sorting; order for the baskets in the output file. There are currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. When using SortBasketsByOffset the baskets are written in the; output file in the same order as in the original file (i.e. the; baskets are sorted by their offset in the original file; Usually; this also means that the baskets are sorted by the index/number of; the _last_ entry they contain). When using SortBasketsByBranch all the baskets of each individual; branches are stored contiguously. This tends to optimize reading; speed when reading a small number (1->5) of branches, since all; their baskets will be clustered together instead of being spread; across the file. However it might decrease the performance when; reading more branches (or the full entry). When using SortBasketsByEntry the baskets with the lowest starting; entry are written first. (i.e. the baskets are sorted by the; index/number of the first entry they contain). This means that on; the file the baskets will be in the order in which they will be; needed when reading the whole tree sequentially. For examples of CloneTree, see tutorials:. -- copytree. A macro to copy a subset of a TTree to a new TTree. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. -- copytree2. A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. void CopyAddresses(TTree* , Bool_t undo = kFALSE); Set branch addresses of passed tree equal to ours.; If undo is true, reset the branch address instead of copying them.; This insures 'separation' of a cloned tree fro",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:81037,Performance,load,load,81037,"Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); As a comparison; tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the; actual_size_of_arr3 is greater or equal to 3.; Note that the array in 'primary' is flattened/linearized thus using; Alt$ with multi-dimensional arrays of different dimensions in unlikely; to yield the expected results. To visualize a bit more what elements; would be matched by TTree::Draw, TTree::Scan can be used:; tree->Scan(""arr1:Alt$(arr2,0)"");; will print on one line the value of arr1 and (arr2,0) that will be; matched by; tree->Draw(""arr1-Alt$(arr2,0)"");. The ternary operator is not directly supported in TTree::Draw however, to plot the; equivalent of 'var2<20 ? -99 : var1', you can use:; tree->Draw(""(var2<20)*99+(var2>=20)*var1"","""");. Drawing a user function accessing the TTree data directly. If the formula contains a file name, TTree::MakeProxy will be used; to load and execute this file. In particular it will draw the; result of a function with the same name as the file. The function; will be executed in a context where the name of the branches can; be used as a C++ variable. For example draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. The main features of this facility are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). See TTree::MakeProxy fo",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:81790,Performance,load,loading,81790,"(var2>=20)*var1"","""");. Drawing a user function accessing the TTree data directly. If the formula contains a file name, TTree::MakeProxy will be used; to load and execute this file. In particular it will draw the; result of a function with the same name as the file. The function; will be executed in a context where the name of the branches can; be used as a C++ variable. For example draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. The main features of this facility are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). See TTree::MakeProxy for more details. Making a Profile histogram. In case of a 2-Dim expression, one can generate a TProfile histogram; instead of a TH2F histogram by specyfying option=prof or option=profs; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of y:x>>pf; where pf is an existing TProfile histogram. Making a 2D Profile histogram. In case of a 3-Dim expression, one can generate a TProfile2D histogram; instead of a TH3F histogram by specifying option=prof or option=profs.; or option=profi or option=profg ; the trailing letter select the way; the bin error are computed, See TProfile2D::SetErrorOption for; details on the differences.; The option=prof is automatically selected in case of z:y:x>>pf; where pf is a",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:85871,Performance,load,loaded,85871,"e.Draw("">>yplus"", ""y>0"", ""entrylistarray""); will create a TEntryListArray object names ""yplus"" in the current directory. By default, the specified entry list is reset.; To continue to append data to an existing list, use ""+"" in front; of the list name;; tree.Draw("">>+yplus"",""y>0""); will not reset yplus, but will enter the selected entries at the end; of the existing list. Using a TEventList, TEntryList or TEntryListArray as Input. Once a TEventList or a TEntryList object has been generated, it can be used as input; for TTree::Draw. Use TTree::SetEventList or TTree::SetEntryList to set the; current event list; Example1:; TEventList *elist = (TEventList*)gDirectory->Get(""yplus"");; tree->SetEventList(elist);; tree->Draw(""py"");; Example2:; TEntryList *elist = (TEntryList*)gDirectory->Get(""yplus"");; tree->SetEntryList(elist);; tree->Draw(""py"");; If a TEventList object is used as input, a new TEntryList object is created; inside the SetEventList function. In case of a TChain, all tree headers are loaded; for this transformation. This new object is owned by the chain and is deleted; with it, unless the user extracts it by calling GetEntryList() function.; See also comments to SetEventList() function of TTree and TChain. If arrays are used in the selection criteria and TEntryListArray is not used,; all the entries that have at least one element of the array that satisfy the selection; are entered in the list.; Example:; tree.Draw("">>pyplus"",""fTracks.fPy>0"");; tree->SetEventList(pyplus);; tree->Draw(""fTracks.fPy"");; will draw the fPy of ALL tracks in event with at least one track with; a positive fPy. To select only the elements that did match the original selection; use TEventList::SetReapplyCut or TEntryList::SetReapplyCut.; Example:; tree.Draw("">>pyplus"",""fTracks.fPy>0"");; pyplus->SetReapplyCut(kTRUE);; tree->SetEventList(pyplus);; tree->Draw(""fTracks.fPy"");; will draw the fPy of only the tracks that have a positive fPy. To draw only the elements that match a selection in ",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:91028,Performance,optimiz,optimize,91028," to be done. This machine independent version of the data is copied into a; basket (each branch has its own basket). When a basket is full; (32k worth of data by default), it is then optionally compressed; and written to disk (this operation is also called committing or; 'flushing' the basket). The committed baskets are then; immediately removed from memory. The function returns the number of bytes committed to the; individual branches. If a write error occurs, the number of bytes returned is -1. If no data are written, because, e.g., the branch is disabled,; the number of bytes returned is 0. The baskets are flushed and the Tree header saved at regular intervals. At regular intervals, when the amount of data written so far is; greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; This makes future reading faster as it guarantees that baskets belonging to nearby; entries will be on the same disk region.; When the first call to flush the baskets happen, we also take this opportunity; to optimize the baskets buffers.; We also check if the amount of data written is greater than fAutoSave (see SetAutoSave).; In this case we also write the Tree header. This makes the Tree recoverable up to this point; in case the program writing the Tree crashes.; The decisions to FlushBaskets and Auto Save can be made based either on the number; of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries; written (fAutoFlush and fAutoSave positive).; Note that the user can decide to call FlushBaskets and AutoSave in her event loop; base on the number of events written instead of the number of bytes written. Note that calling FlushBaskets too often increases the IO time.; Note that calling AutoSave too often increases the IO time and also the file size. TBranch* FindBranch(const char* name); Return the branch that correspond to the path 'branchname', which can; include the name of the tree or the omitted name of the parent branches.; In cas",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:93754,Performance,cache,cache,93754,"ave the histogram as ""hsqrt"" in the current; directory. See also TTree::UnbinnedFit. Return status. The function returns the status of the histogram fit (see TH1::Fit); If no entries were selected, the function returns -1;; (i.e. fitResult is null is the fit is OK). Int_t FlushBaskets() const; Write to disk all the basket that have not yet been individually written. Return the number of bytes written or -1 in case of write error. const char* GetAlias(const char* aliasName) const; Returns the expanded value of the alias. Search in the friends if any. TBranch* GetBranch(const char* name); Return pointer to the branch with the given name in this tree or its friends. Bool_t GetBranchStatus(const char* branchname) const; Return status of branch with name branchname.; 0 if branch is not activated; 1 if branch is activated. Int_t GetBranchStyle(); Static function returning the current branch style.; style = 0 old Branch; style = 1 new Bronch. Long64_t GetCacheAutoSize(Bool_t withDefault = kFALSE) const; Used for automatic sizing of the cache.; Estimates a suitable size for the tree cache based on AutoFlush.; A cache sizing factor is taken from the configuration. If this yields zero; and withDefault is true the historical algoirthm for default size is used. TFile* GetCurrentFile() const; Return pointer to the current file. Long64_t GetEntries(const char* selection); Return the number of entries matching the selection.; Return -1 in case of errors. If the selection uses any arrays or containers, we return the number; of entries where at least one element match the selection.; GetEntries is implemented using the selector class TSelectorEntries,; which can be used directly (see code in TTreePlayer::GetEntries) for; additional option.; If SetEventList was used on the TTree or TChain, only that subset; of entries will be considered. Long64_t GetEntriesFriend() const; Return pointer to the 1st Leaf named name in any Branch of this Tree or; any branch in the list of friend trees. ",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:93801,Performance,cache,cache,93801," Return status. The function returns the status of the histogram fit (see TH1::Fit); If no entries were selected, the function returns -1;; (i.e. fitResult is null is the fit is OK). Int_t FlushBaskets() const; Write to disk all the basket that have not yet been individually written. Return the number of bytes written or -1 in case of write error. const char* GetAlias(const char* aliasName) const; Returns the expanded value of the alias. Search in the friends if any. TBranch* GetBranch(const char* name); Return pointer to the branch with the given name in this tree or its friends. Bool_t GetBranchStatus(const char* branchname) const; Return status of branch with name branchname.; 0 if branch is not activated; 1 if branch is activated. Int_t GetBranchStyle(); Static function returning the current branch style.; style = 0 old Branch; style = 1 new Bronch. Long64_t GetCacheAutoSize(Bool_t withDefault = kFALSE) const; Used for automatic sizing of the cache.; Estimates a suitable size for the tree cache based on AutoFlush.; A cache sizing factor is taken from the configuration. If this yields zero; and withDefault is true the historical algoirthm for default size is used. TFile* GetCurrentFile() const; Return pointer to the current file. Long64_t GetEntries(const char* selection); Return the number of entries matching the selection.; Return -1 in case of errors. If the selection uses any arrays or containers, we return the number; of entries where at least one element match the selection.; GetEntries is implemented using the selector class TSelectorEntries,; which can be used directly (see code in TTreePlayer::GetEntries) for; additional option.; If SetEventList was used on the TTree or TChain, only that subset; of entries will be considered. Long64_t GetEntriesFriend() const; Return pointer to the 1st Leaf named name in any Branch of this Tree or; any branch in the list of friend trees. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all branches of entry and",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:93830,Performance,cache,cache,93830,"ram fit (see TH1::Fit); If no entries were selected, the function returns -1;; (i.e. fitResult is null is the fit is OK). Int_t FlushBaskets() const; Write to disk all the basket that have not yet been individually written. Return the number of bytes written or -1 in case of write error. const char* GetAlias(const char* aliasName) const; Returns the expanded value of the alias. Search in the friends if any. TBranch* GetBranch(const char* name); Return pointer to the branch with the given name in this tree or its friends. Bool_t GetBranchStatus(const char* branchname) const; Return status of branch with name branchname.; 0 if branch is not activated; 1 if branch is activated. Int_t GetBranchStyle(); Static function returning the current branch style.; style = 0 old Branch; style = 1 new Bronch. Long64_t GetCacheAutoSize(Bool_t withDefault = kFALSE) const; Used for automatic sizing of the cache.; Estimates a suitable size for the tree cache based on AutoFlush.; A cache sizing factor is taken from the configuration. If this yields zero; and withDefault is true the historical algoirthm for default size is used. TFile* GetCurrentFile() const; Return pointer to the current file. Long64_t GetEntries(const char* selection); Return the number of entries matching the selection.; Return -1 in case of errors. If the selection uses any arrays or containers, we return the number; of entries where at least one element match the selection.; GetEntries is implemented using the selector class TSelectorEntries,; which can be used directly (see code in TTreePlayer::GetEntries) for; additional option.; If SetEventList was used on the TTree or TChain, only that subset; of entries will be considered. Long64_t GetEntriesFriend() const; Return pointer to the 1st Leaf named name in any Branch of this Tree or; any branch in the list of friend trees. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0); Read all branches of entry and return total number of bytes read. getall = 0 : get only act",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:99202,Performance,perform,performs,99202,"MPORTANT; T.GetEntry(i);; // the object event has been filled at this point; }. It is strongly recommended to use the default option 1. It has the; additional advantage that functions like TTree::Draw (internally calling; TTree::GetEntry) will be functional even when the classes in the file are; not available. Note: See the comments in TBranchElement::SetAddress() for the; object ownership policy of the underlying (user) data. TEntryList* GetEntryList(); Returns the entry list, set to this tree. Long64_t GetEntryNumber(Long64_t entry) const; Return entry number corresponding to entry. if no TEntryList set returns entry; else returns the entry number corresponding to the list index=entry. Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor = 0) const; Return entry number corresponding to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Long64_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that maches val, it returns directly the; index in the table.; If an entry corresponding to major and minor is not found, the function; returns the index of the major,minor pair immediately lower than the; requested value, ie it will return -1 if the pair is lower than; the first entry in the index. See also GetEntryNumberWithIndex. Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor = 0) const; Return entry number corresponding to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Long64_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pa",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:100021,Performance,perform,performs,100021," and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Long64_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that maches val, it returns directly the; index in the table.; If an entry corresponding to major and minor is not found, the function; returns the index of the major,minor pair immediately lower than the; requested value, ie it will return -1 if the pair is lower than; the first entry in the index. See also GetEntryNumberWithIndex. Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor = 0) const; Return entry number corresponding to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Long64_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that maches val, it returns directly the; index in the table, otherwise it returns -1. See also GetEntryNumberWithBestIndex. Int_t GetEntryWithIndex(Int_t major, Int_t minor = 0); Read entry corresponding to major and minor number. The function returns the total number of bytes read.; If the Tree has friend trees, the corresponding entry with; the index values (major,minor) is read. Note that the master Tree; and its friend may have different entry serial numbers corresponding; to (major,minor). TTree* GetFriend(const char* ) const; Return a pointer to the TTree friend whose name or alias is 'friendname. const char* GetFriendAlias(TTree* ) const; If the 'tree' is a friend, this method returns its alias name. This alias is an alternate name for the tree. It can be used in conjunction with a branch or leaf ",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:103455,Performance,cache,cache,103455,"ctoryName/TreeName. TLeaf* GetLeaf(const char* name); Return pointer to the 1st Leaf named name in any Branch of this; Tree or any branch in the list of friend trees. aname may be of the form branchname/leafname. Double_t GetMaximum(const char* columname); Return maximum of column with name columname.; if the Tree has an associated TEventList or TEntryList, the maximum; is computed for the entries in this list. Long64_t GetMaxTreeSize(); Static function which returns the tree file size limit in bytes. Double_t GetMinimum(const char* columname); Return minimum of column with name columname.; if the Tree has an associated TEventList or TEntryList, the minimum; is computed for the entries in this list. TVirtualTreePlayer* GetPlayer(); Load the TTreePlayer (if not already done). TTreeCache * GetReadCache(TFile* file, Bool_t create = kFALSE); Find and return the TTreeCache registered with the file and which may; contain branches for us. If create is true and there is no cache:; Create a new cache according to the autocache setting and return it. TList* GetUserInfo(); Return a pointer to the list containing user objects associated to this tree. The list is automatically created if it does not exist. WARNING: By default the TTree destructor will delete all objects added; to this list. If you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void ImportClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; T",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:103476,Performance,cache,cache,103476,"ctoryName/TreeName. TLeaf* GetLeaf(const char* name); Return pointer to the 1st Leaf named name in any Branch of this; Tree or any branch in the list of friend trees. aname may be of the form branchname/leafname. Double_t GetMaximum(const char* columname); Return maximum of column with name columname.; if the Tree has an associated TEventList or TEntryList, the maximum; is computed for the entries in this list. Long64_t GetMaxTreeSize(); Static function which returns the tree file size limit in bytes. Double_t GetMinimum(const char* columname); Return minimum of column with name columname.; if the Tree has an associated TEventList or TEntryList, the minimum; is computed for the entries in this list. TVirtualTreePlayer* GetPlayer(); Load the TTreePlayer (if not already done). TTreeCache * GetReadCache(TFile* file, Bool_t create = kFALSE); Find and return the TTreeCache registered with the file and which may; contain branches for us. If create is true and there is no cache:; Create a new cache according to the autocache setting and return it. TList* GetUserInfo(); Return a pointer to the list containing user objects associated to this tree. The list is automatically created if it does not exist. WARNING: By default the TTree destructor will delete all objects added; to this list. If you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void ImportClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; T",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:104578,Performance,load,loading,104578,"t* GetUserInfo(); Return a pointer to the list containing user objects associated to this tree. The list is automatically created if it does not exist. WARNING: By default the TTree destructor will delete all objects added; to this list. If you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void ImportClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; The function returns the total number of baskets read into memory; if negative an error occurred while loading the branches.; This method may be called to force branch baskets in memory; when random access to branch entries is required.; If random access to only a few branches is required, you should; call directly TBranch::LoadBaskets. Long64_t LoadTree(Long64_t entry); Set current entry. Returns -2 if entry does not exist (just as TChain::LoadTree()). Note: This function is overloaded in TChain. Long64_t LoadTreeFriend(Long64_t entry, TTree* T); Load entry on behalf of our master tree, we may use an index. Called by LoadTree() when the masterTree looks for the entry; number in a friend tree (us) corresponding to the passed entry; number in the masterTree. If we have no index, our entry number and the masterTree entry; number are the same. If we *do* have an index, we must find the (major, minor) value pair; in masterTree to locate our corresponding entry. Int_t MakeClass(const char* classname = 0, Option_t* option = """"); Generate a skeleton an",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:109217,Performance,load,loading,109217,"ed in the current directory or in 'path/' if it is specified.; The class generated will be named 'fileprefix'. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source files which will be included by the generated skeleton.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the; system 'unroll' classes that are not split. Unrolling a class; allows direct access to its data members (this emulates the behavior; of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bounds errors; * ability to use the branch data as an object (when the user code is available). For example with Event.root, if; Double_t somePx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somePx will updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. These two functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For ex",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:110293,Performance,cache,cache,110293,"chname' as if it was a data member; * protection against array out-of-bounds errors; * ability to use the branch data as an object (when the user code is available). For example with Event.root, if; Double_t somePx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somePx will updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. These two functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insur",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:111328,Performance,load,loaded,111328,"fficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. Int_t MakeSelector(const char* selector = 0); Generate skeleton selector class for this tree. The following files are produced: selector.h and selector.C.; If selector is 0, the selector will be called ""nameo",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:111472,Performance,load,loaded,111472,"r will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. Int_t MakeSelector(const char* selector = 0); Generate skeleton selector class for this tree. The following files are produced: selector.h and selector.C.; If selector is 0, the selector will be called ""nameoftree"". The generated code in selector.h includes the following:; - Identification of the original Tree and Input file name; - Definition of selector class (data and functions); - The following class functions:; - construc",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:114088,Performance,cache,cache,114088,"u can do:; root > T->Process(""myselect.C""). Bool_t MemoryFull(Int_t nbytes); Check if adding nbytes to memory we are still below MaxVirtualsize. TTree* MergeTrees(TList* list, Option_t* option = """"); Static function merging the trees in the TList into a new tree. Trees in the list can be memory or disk-resident trees.; The new tree is created in the current directory (memory if gROOT). Long64_t Merge(TCollection* list, Option_t* option = """"); Merge the trees in the TList into this tree. Returns the total number of entries in the merged tree. Long64_t Merge(TCollection* list, TFileMergeInfo* info); Merge the trees in the TList into this tree.; If info->fIsFirst is true, first we clone this TTree info the directory; info->fOutputDirectory and then overlay the new TTree information onto; this TTree object (so that this TTree object is now the appropriate to; use for further merging). Returns the total number of entries in the merged tree. void MoveReadCache(TFile* src, TDirectory* dir); Move a cache from a file to the current file in dir.; if src is null no operation is done, if dir is null or there is no; current file the cache is deleted. Bool_t Notify(); Function called when loading a new class library. void OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.1, Option_t* option = """"); This function may be called after having filled some entries in a Tree; Using the information in the existing branch buffers, it will reassign; new branch buffer sizes to optimize time and memory. The function computes the best values for branch buffer sizes such that; the total buffer sizes is less than maxMemory and nearby entries written; at the same time.; In case the branch compression factor for the data written so far is less; than compMin, the compression is disabled. if option =""d"" an analysis report is printed. TPrincipal* Principal(const char* varexp = """", const char* selection = """", Option_t* option = ""np"", Long64_t nentries = 1000000000, Long64_t firstentr",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:114220,Performance,cache,cache,114220,"memory we are still below MaxVirtualsize. TTree* MergeTrees(TList* list, Option_t* option = """"); Static function merging the trees in the TList into a new tree. Trees in the list can be memory or disk-resident trees.; The new tree is created in the current directory (memory if gROOT). Long64_t Merge(TCollection* list, Option_t* option = """"); Merge the trees in the TList into this tree. Returns the total number of entries in the merged tree. Long64_t Merge(TCollection* list, TFileMergeInfo* info); Merge the trees in the TList into this tree.; If info->fIsFirst is true, first we clone this TTree info the directory; info->fOutputDirectory and then overlay the new TTree information onto; this TTree object (so that this TTree object is now the appropriate to; use for further merging). Returns the total number of entries in the merged tree. void MoveReadCache(TFile* src, TDirectory* dir); Move a cache from a file to the current file in dir.; if src is null no operation is done, if dir is null or there is no; current file the cache is deleted. Bool_t Notify(); Function called when loading a new class library. void OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.1, Option_t* option = """"); This function may be called after having filled some entries in a Tree; Using the information in the existing branch buffers, it will reassign; new branch buffer sizes to optimize time and memory. The function computes the best values for branch buffer sizes such that; the total buffer sizes is less than maxMemory and nearby entries written; at the same time.; In case the branch compression factor for the data written so far is less; than compMin, the compression is disabled. if option =""d"" an analysis report is printed. TPrincipal* Principal(const char* varexp = """", const char* selection = """", Option_t* option = ""np"", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:114276,Performance,load,loading,114276,"tion = """"); Static function merging the trees in the TList into a new tree. Trees in the list can be memory or disk-resident trees.; The new tree is created in the current directory (memory if gROOT). Long64_t Merge(TCollection* list, Option_t* option = """"); Merge the trees in the TList into this tree. Returns the total number of entries in the merged tree. Long64_t Merge(TCollection* list, TFileMergeInfo* info); Merge the trees in the TList into this tree.; If info->fIsFirst is true, first we clone this TTree info the directory; info->fOutputDirectory and then overlay the new TTree information onto; this TTree object (so that this TTree object is now the appropriate to; use for further merging). Returns the total number of entries in the merged tree. void MoveReadCache(TFile* src, TDirectory* dir); Move a cache from a file to the current file in dir.; if src is null no operation is done, if dir is null or there is no; current file the cache is deleted. Bool_t Notify(); Function called when loading a new class library. void OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.1, Option_t* option = """"); This function may be called after having filled some entries in a Tree; Using the information in the existing branch buffers, it will reassign; new branch buffer sizes to optimize time and memory. The function computes the best values for branch buffer sizes such that; the total buffer sizes is less than maxMemory and nearby entries written; at the same time.; In case the branch compression factor for the data written so far is less; than compMin, the compression is disabled. if option =""d"" an analysis report is printed. TPrincipal* Principal(const char* varexp = """", const char* selection = """", Option_t* option = ""np"", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is fil",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:114576,Performance,optimiz,optimize,114576,"llection* list, Option_t* option = """"); Merge the trees in the TList into this tree. Returns the total number of entries in the merged tree. Long64_t Merge(TCollection* list, TFileMergeInfo* info); Merge the trees in the TList into this tree.; If info->fIsFirst is true, first we clone this TTree info the directory; info->fOutputDirectory and then overlay the new TTree information onto; this TTree object (so that this TTree object is now the appropriate to; use for further merging). Returns the total number of entries in the merged tree. void MoveReadCache(TFile* src, TDirectory* dir); Move a cache from a file to the current file in dir.; if src is null no operation is done, if dir is null or there is no; current file the cache is deleted. Bool_t Notify(); Function called when loading a new class library. void OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.1, Option_t* option = """"); This function may be called after having filled some entries in a Tree; Using the information in the existing branch buffers, it will reassign; new branch buffer sizes to optimize time and memory. The function computes the best values for branch buffer sizes such that; the total buffer sizes is less than maxMemory and nearby entries written; at the same time.; In case the branch compression factor for the data written so far is less; than compMin, the compression is disabled. if option =""d"" an analysis report is printed. TPrincipal* Principal(const char* varexp = """", const char* selection = """", Option_t* option = ""np"", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute the principal components; If option ""p"" and ""d"" print results of analysis; If option ""p"" and ""h"" generate standard histograms; If option ""p"" and ""c"" g",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:116686,Performance,cache,cache,116686,"xplanation of the other parameters. The created object is named ""principal"" and a reference to it; is added to the list of specials Root objects.; you can retrieve a pointer to the created object via:; TPrincipal *principal =; (TPrincipal*)gROOT->GetListOfSpecials()->FindObject(""principal"");. void Print(Option_t* option = """") const; Print a summary of the tree contents. If option contains ""all"" friend trees are also printed.; If option contains ""toponly"" only the top level branches are printed.; If option contains ""clusters"" information about the cluster of baskets is printed. Wildcarding can be used to print only a subset of the branches, e.g.,; T.Print(""Elec*"") will print all branches with name starting with ""Elec"". void PrintCacheStats(Option_t* option = """") const; print statistics about the TreeCache for this tree, like; ******TreeCache statistics for file: cms2.root ******; Reading 73921562 bytes in 716 transactions; Average transaction = 103.242405 Kbytes; Number of blocks in current cache: 202, total size : 6001193. if option = ""a"" the list of blocks in the cache is printed. Long64_t Process(const char* filename, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Process this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): cal",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:116762,Performance,cache,cache,116762,"ncipal"" and a reference to it; is added to the list of specials Root objects.; you can retrieve a pointer to the created object via:; TPrincipal *principal =; (TPrincipal*)gROOT->GetListOfSpecials()->FindObject(""principal"");. void Print(Option_t* option = """") const; Print a summary of the tree contents. If option contains ""all"" friend trees are also printed.; If option contains ""toponly"" only the top level branches are printed.; If option contains ""clusters"" information about the cluster of baskets is printed. Wildcarding can be used to print only a subset of the branches, e.g.,; T.Print(""Elec*"") will print all branches with name starting with ""Elec"". void PrintCacheStats(Option_t* option = """") const; print statistics about the TreeCache for this tree, like; ******TreeCache statistics for file: cms2.root ******; Reading 73921562 bytes in 716 transactions; Average transaction = 103.242405 Kbytes; Number of blocks in current cache: 202, total size : 6001193. if option = ""a"" the list of blocks in the cache is printed. Long64_t Process(const char* filename, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Process this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:117090,Performance,load,loaded,117090,"hes are printed.; If option contains ""clusters"" information about the cluster of baskets is printed. Wildcarding can be used to print only a subset of the branches, e.g.,; T.Print(""Elec*"") will print all branches with name starting with ""Elec"". void PrintCacheStats(Option_t* option = """") const; print statistics about the TreeCache for this tree, like; ******TreeCache statistics for file: cms2.root ******; Reading 73921562 bytes in 716 transactions; Average transaction = 103.242405 Kbytes; Number of blocks in current cache: 202, total size : 6001193. if option = ""a"" the list of blocks in the cache is printed. Long64_t Process(const char* filename, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Process this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more intere",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:117923,Performance,load,loaded,117923,"this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more interesting to invoke directly the other Process function; accepting a TSelector* as argument.eg; MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; selector->CallSomeFunction(..);; mytree.Process(selector,..);. NOTE2; One should not call this function twice with the same selector file; in the same script. If this is required, proceed as indicated in NOTE1,; by getting a pointer to the corresponding TSelector,eg; workaround 1. void stubs1() {; TSelector *selector = TSelector::GetSelector(""h1test.C"");; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(selector);; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(selector);; };",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:118018,Performance,load,loaded,118018,"se of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more interesting to invoke directly the other Process function; accepting a TSelector* as argument.eg; MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; selector->CallSomeFunction(..);; mytree.Process(selector,..);. NOTE2; One should not call this function twice with the same selector file; in the same script. If this is required, proceed as indicated in NOTE1,; by getting a pointer to the corresponding TSelector,eg; workaround 1. void stubs1() {; TSelector *selector = TSelector::GetSelector(""h1test.C"");; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(selector);; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(selector);; }; or use ACLIC to compile the selector; workaround 2. void stubs2() {; TFile *f1 = new TFile(""st",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:118129,Performance,load,loaded,118129,"low),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more interesting to invoke directly the other Process function; accepting a TSelector* as argument.eg; MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; selector->CallSomeFunction(..);; mytree.Process(selector,..);. NOTE2; One should not call this function twice with the same selector file; in the same script. If this is required, proceed as indicated in NOTE1,; by getting a pointer to the corresponding TSelector,eg; workaround 1. void stubs1() {; TSelector *selector = TSelector::GetSelector(""h1test.C"");; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(selector);; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(selector);; }; or use ACLIC to compile the selector; workaround 2. void stubs2() {; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(""h1test.C+"");; TFile *f2 = new TFile(""stubs_nood_le1_coa",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:126359,Performance,optimiz,optimize,126359,"e->Draw(""theGoodTrack.fPx""); // same as ""event.fTracks[3].fPx"". void SetAutoFlush(Long64_t autof = -30000000); This function may be called at the start of a program to change; the default value for fAutoFlush. CASE 1 : autof > 0. autof is the number of consecutive entries after which TTree::Fill will; flush all branch buffers to disk. CASE 2 : autof < 0. When filling the Tree the branch buffers will be flushed to disk when; more than autof bytes have been written to the file. At the first FlushBaskets; TTree::Fill will replace fAutoFlush by the current value of fEntries. Calling this function with autof<0 is interesting when it is hard to estimate; the size of one entry. This value is also independent of the Tree. The Tree is initialized with fAutoFlush=-30000000, ie that, by default,; the first AutoFlush will be done when 30 MBytes of data are written to the file. CASE 3 : autof = 0. The AutoFlush mechanism is disabled. Flushing the buffers at regular intervals optimize the location of; consecutive entries on the disk by creating clusters of baskets. A cluster of baskets is a set of baskets that contains all; the data for a (consecutive) set of entries and that is stored; consecutively on the disk. When reading all the branches, this; is the minimum set of baskets that the TTreeCache will read. void SetAutoSave(Long64_t autos = -300000000); This function may be called at the start of a program to change; the default value for fAutoSave (and for SetAutoSave) is -300000000, ie 300 MBytes; When filling the Tree the branch buffers as well as the Tree header; will be flushed to disk when the watermark is reached.; If fAutoSave is positive the watermark is reached when a multiple of fAutoSave; entries have been written.; If fAutoSave is negative the watermark is reached when -fAutoSave bytes; have been written to the file.; In case of a program crash, it will be possible to recover the data in the Tree; up to the last AutoSave point. void SetBasketSize(const char* bname, ",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:131600,Performance,cache,cachesize,131600,"me (by adding a dot ('.') at the end of the Branch creation and use the; corresponding bname. I.e If your Tree has been created in split mode with a parent branch ""parent.""; (note the trailing dot).; T.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buf",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:131646,Performance,cache,cache,131646,"me (by adding a dot ('.') at the end of the Branch creation and use the; corresponding bname. I.e If your Tree has been created in split mode with a parent branch ""parent.""; (note the trailing dot).; T.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buf",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:131658,Performance,cache,cachesize,131658,"e; corresponding bname. I.e If your Tree has been created in split mode with a parent branch ""parent.""; (note the trailing dot).; T.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is ca",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:131685,Performance,cache,cache,131685,"e; corresponding bname. I.e If your Tree has been created in split mode with a parent branch ""parent.""; (note the trailing dot).; T.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is ca",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:131716,Performance,cache,cachesize,131716,"nt branch ""parent.""; (note the trailing dot).; T.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; i",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:131877,Performance,cache,cacheSize,131877,"arent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time enviro",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:131918,Performance,cache,cache,131918,"arent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time enviro",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:132009,Performance,cache,cache,132009,"call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; ",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:132060,Performance,cache,cache,132060,"call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; ",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:132110,Performance,cache,cacheSize,132110,"on is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:132155,Performance,cache,cacheSize,132155,"ches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE ",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:132185,Performance,cache,cache,132185,"ches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE ",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:132197,Performance,cache,cache,132197," *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE 4:; A circular Tree can still be saved in a file. When r",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:132335,Performance,cache,cache,132335,"0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE 4:; A circular Tree can still be saved in a file. When read back,; it is still a circular Tree and can be filled again. void SetDebug(Int",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:137650,Performance,cache,cache,137650,"ex();; tree.SetTreeIndex(newIndex);; tree.Draw();; tree.SetTreeIndex(oldIndex);; tree.Draw(); etc. void SetWeight(Double_t w = 1, Option_t* option = """"); Set tree weight. The weight is used by TTree::Draw to automatically weight each; selected entry in the resulting histogram. For example the equivalent of:. T.Draw(""x"", ""w""). is:. T.SetWeight(w);; T.Draw(""x"");. This function is redefined by TChain::SetWeight. In case of a; TChain, an option ""global"" may be specified to set the same weight; for all trees in the TChain instead of the default behaviour; using the weights of each tree in the chain (see TChain::SetWeight). void Show(Long64_t entry = -1, Int_t lenmax = 20); Print values of all active leaves for entry. if entry==-1, print current entry (default); if a leaf is an array, a maximum of lenmax elements is printed. void StartViewer(); Start the TTreeViewer on this tree. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. void StopCacheLearningPhase(); stop the cache learning phase. void Streamer(TBuffer& ); Stream a class object. Int_t UnbinnedFit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Unbinned fit of one or more variable(s) from a tree. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if you fit a function with 6 parame",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:142657,Performance,perform,performance,142657,"urn fDebugMin; }. TDirectory * GetDirectory() const; { return fDirectory; }. Long64_t GetEntries() const; { return fEntries; }. Long64_t GetEntriesFast() const; { return fEntries; }. Long64_t GetEstimate() const; { return fEstimate; }. Int_t GetEvent(Long64_t entry = 0, Int_t getall = 0); { return GetEntry(entry, getall); }. TEventList * GetEventList() const; { return fEventList; }. Int_t GetFileNumber() const; { return fFileNumber; }. TH1 * GetHistogram(); { return GetPlayer()->GetHistogram(); }. Int_t * GetIndex(); { return &fIndex.fArray[0]; }. Double_t * GetIndexValues(); { return &fIndexValues.fArray[0]; }. TList * GetListOfClones(); { return fClones; }. TObjArray * GetListOfBranches(); { return &fBranches; }. TObjArray * GetListOfLeaves(); { return &fLeaves; }. TList * GetListOfFriends() const; { return fFriends; }. TList * GetListOfAliases() const; { return fAliases; }. Int_t GetMakeClass() const; GetMakeClass is left non-virtual for efficiency reason.; Making it virtual affects the performance of the I/O. { return fMakeClass; }. Long64_t GetMaxEntryLoop() const; { return fMaxEntryLoop; }. Long64_t GetMaxVirtualSize() const; { return fMaxVirtualSize; }. Int_t GetNbranches(); { return fBranches.GetEntriesFast(); }. TObject * GetNotify() const; { return fNotify; }. Int_t GetPacketSize() const; { return fPacketSize; }. TVirtualPerfStats * GetPerfStats() const; { return fPerfStats; }. Long64_t GetReadEntry() const; { return fReadEntry; }. Long64_t GetReadEvent() const; { return fReadEntry; }. Int_t GetScanField() const; { return fScanField; }. TTreeFormula * GetSelect(); { return GetPlayer()->GetSelect(); }. Long64_t GetSelectedRows(); { return GetPlayer()->GetSelectedRows(); }. Int_t GetTimerInterval() const; { return fTimerInterval; }. Long64_t GetTotBytes() const; { return fTotBytes; }. TTree * GetTree() const; { return const_cast<TTree*>(this); }. TVirtualIndex * GetTreeIndex() const; { return fTreeIndex; }. Int_t GetTreeNumber() const; { return 0; }. Int_t Ge",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:8597,Safety,risk,risk,8597,"tain algorithm,; you may want to try another algorithm and compare the results.; One solution is to add a new branch, fill it, and save the tree.; The code below adds a simple branch to an existing tree.; Note the kOverwrite option in the Write method, it overwrites the; existing tree. If it is not specified, two copies of the tree headers; are saved. void tree3AddBranch(){; TFile f(""tree3.root"", ""update"");. Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. //read the number of entries in the t3; Long64_t nentries = t3->GetEntries();. for (Long64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk losing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt to write the tree fails, and the; original data is erased.; In addition, adding a branch to a tree enlarges the tree and increases; the amount of memory needed to read an entry, and therefore decreases; the performance. For these reasons, ROOT offers the concept of friends for trees (and chains).; We encourage you to use TTree::AddFriend rather than adding a branch manually. /*. */. A simple example with histograms and a tree*-*-*-; *-* ===========================================. This program creates :; - a one dimensional histogram; - a two dimensional histogram; - a profile histogram; - a tree. These objects are filled with some random numbers and saved on a file. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. #include ""TFile.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TProfile.h""",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:9942,Safety,detect,detector,9942,"tree and increases; the amount of memory needed to read an entry, and therefore decreases; the performance. For these reasons, ROOT offers the concept of friends for trees (and chains).; We encourage you to use TTree::AddFriend rather than adding a branch manually. /*. */. A simple example with histograms and a tree*-*-*-; *-* ===========================================. This program creates :; - a one dimensional histogram; - a two dimensional histogram; - a profile histogram; - a tree. These objects are filled with some random numbers and saved on a file. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. #include ""TFile.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TProfile.h""; #include ""TRandom.h""; #include ""TTree.h"". //______________________________________________________________________________; main(int argc, char **argv); {; // Create a new ROOT binary machine independent file.; // Note that this file may contain any kind of ROOT objects, histograms,trees; // pictures, graphics objects, detector geometries, tracks, events, etc..; // This file is now becoming the current directory.; TFile hfile(""htree.root"",""RECREATE"",""Demo ROOT file with histograms & trees"");. // Create some histograms and a profile histogram; TH1F *hpx = new TH1F(""hpx"",""This is the px distribution"",100,-4,4);; TH2F *hpxpy = new TH2F(""hpxpy"",""py ps px"",40,-4,4,40,-4,4);; TProfile *hprof = new TProfile(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);. // Define some simple structures; typedef struct {Float_t x,y,z;} POINT;; typedef struct {; Int_t ntrack,nseg,nvertex;; UInt_t flag;; Float_t temperature;; } EVENTN;; static POINT point;; static EVENTN eventn;. // Create a ROOT Tree; TTree *tree = new TTree(""T"",""An example of ROOT tree with a few branches"");; tree->Branch(""point"",&point,""x:y:z"");; tree->Branch(""eventn"",&eventn,""ntrack/I:nseg:nvertex:flag/i:temperature/F"");; tree->Branch(""hpx"",""TH1F"",&hpx,128000,0);. Float_t px,py,pz;; static Float_t p[3];. //-----------",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:37953,Safety,risk,risk,37953,"subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the TTree::AddFriend; method. The tree in the diagram below has two friends (friend_tree1 and; friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. /*; ; */. The AddFriend method has two parameters, the first is the tree name and the; second is the name of the ROOT file where the friend tree is saved.; AddFriend automatically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias in the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify which tree to use in; the Draw method, use the syntax:. <treeName>.<branchname>.<varname>; If the var",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:41110,Safety,safe,safe,41110,"f the friend list are also deleted.; It is possible to declare a friend tree that has the same internal; structure (same branches and leaves) as the original tree, and compare the; same values by specifying the tree. tree.Draw(""var:ft1.var:ft2.var""). TFriendElement* AddFriend(const char* treename, TFile* file); Add a TFriendElement to the list of friends. The TFile is managed by the user (e.g. the user must delete the file).; For complete description see AddFriend(const char *, const char *).; This function:; -reads a Tree with name treename from the file; -adds the Tree to the list of friends. TFriendElement* AddFriend(TTree* tree, const char* alias = """", Bool_t warn = kFALSE); Add a TFriendElement to the list of friends. The TTree is managed by the user (e.g., the user must delete the file).; For a complete description see AddFriend(const char *, const char *). Long64_t AutoSave(Option_t* option = """"); AutoSave tree header every fAutoSave bytes. When large Trees are produced, it is safe to activate the AutoSave; procedure. Some branches may have buffers holding many entries.; If fAutoSave is negative, AutoSave is automatically called by; TTree::Fill when the number of bytes generated since the previous; AutoSave is greater than -fAutoSave bytes.; If fAutoSave is positive, AutoSave is automatically called by; TTree::Fill every N entries.; This function may also be invoked by the user.; Each AutoSave generates a new key on the file.; Once the key with the tree header has been written, the previous cycle; (if any) is deleted. Note that calling TTree::AutoSave too frequently (or similarly calling; TTree::SetAutoSave with a small value) is an expensive operation.; You should make tests for your own application to find a compromise; between speed and the quantity of information you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE m",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:42059,Safety,recover,recovered,42059,"ve tree header every fAutoSave bytes. When large Trees are produced, it is safe to activate the AutoSave; procedure. Some branches may have buffers holding many entries.; If fAutoSave is negative, AutoSave is automatically called by; TTree::Fill when the number of bytes generated since the previous; AutoSave is greater than -fAutoSave bytes.; If fAutoSave is positive, AutoSave is automatically called by; TTree::Fill every N entries.; This function may also be invoked by the user.; Each AutoSave generates a new key on the file.; Once the key with the tree header has been written, the previous cycle; (if any) is deleted. Note that calling TTree::AutoSave too frequently (or similarly calling; TTree::SetAutoSave with a small value) is an expensive operation.; You should make tests for your own application to find a compromise; between speed and the quantity of information you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE mode.; The Tree will be recovered at the status corresponding to the last AutoSave. if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; This allows another process to analyze the Tree while the Tree is being filled. if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; the current basket are closed-out and written to disk individually. By default the previous header is deleted after having written the new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number of bytes is null, an error has occurred while writing; the header to the file. How to write a Tree in one process and view it from another process. The follo",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:42135,Safety,recover,recovered,42135,"e branches may have buffers holding many entries.; If fAutoSave is negative, AutoSave is automatically called by; TTree::Fill when the number of bytes generated since the previous; AutoSave is greater than -fAutoSave bytes.; If fAutoSave is positive, AutoSave is automatically called by; TTree::Fill every N entries.; This function may also be invoked by the user.; Each AutoSave generates a new key on the file.; Once the key with the tree header has been written, the previous cycle; (if any) is deleted. Note that calling TTree::AutoSave too frequently (or similarly calling; TTree::SetAutoSave with a small value) is an expensive operation.; You should make tests for your own application to find a compromise; between speed and the quantity of information you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE mode.; The Tree will be recovered at the status corresponding to the last AutoSave. if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; This allows another process to analyze the Tree while the Tree is being filled. if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; the current basket are closed-out and written to disk individually. By default the previous header is deleted after having written the new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number of bytes is null, an error has occurred while writing; the header to the file. How to write a Tree in one process and view it from another process. The following two scripts illustrate how to do this.; The script treew.C is executed by process1, treer.C by process2. ----- scri",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:42722,Safety,safe,safer,42722,"g; TTree::SetAutoSave with a small value) is an expensive operation.; You should make tests for your own application to find a compromise; between speed and the quantity of information you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE mode.; The Tree will be recovered at the status corresponding to the last AutoSave. if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; This allows another process to analyze the Tree while the Tree is being filled. if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; the current basket are closed-out and written to disk individually. By default the previous header is deleted after having written the new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number of bytes is null, an error has occurred while writing; the header to the file. How to write a Tree in one process and view it from another process. The following two scripts illustrate how to do this.; The script treew.C is executed by process1, treer.C by process2. ----- script treew.C; void treew() {; TFile f(""test.root"",""recreate"");; TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; Float_t px, py, pz;; for ( Int_t i=0; i<10000000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ntuple->Fill(px,py,pz,random,i);; if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; }; }. ----- script treer.C; void treer() {; TFile f(""test.root"");; TTree *ntuple = (TTree*)f.Get(""ntuple"");; TCanvas c1;; Int_t first = 0;; while(1) {; if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; else nt",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:44283,Safety,detect,detection,44283," *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; Float_t px, py, pz;; for ( Int_t i=0; i<10000000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ntuple->Fill(px,py,pz,random,i);; if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; }; }. ----- script treer.C; void treer() {; TFile f(""test.root"");; TTree *ntuple = (TTree*)f.Get(""ntuple"");; TCanvas c1;; Int_t first = 0;; while(1) {; if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; first = (Int_t)ntuple->GetEntries();; c1.Update();; gSystem->Sleep(1000); //sleep 1 second; ntuple->Refresh();; }; }. TBranch* BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch() with added check that addobj matches className. See TTree::Branch() for other details. TBranch* BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. TBranch* BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. TBranch* BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. Int_t Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99); Deprecated function. Use next function instead. Int_t Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"); Create one branch for each element in the collection. Each entry in the collection becomes a top level branch if the; corresponding class is not a collection. If it is a collecti",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:44521,Safety,detect,detection,44521,"andom,i);; if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; }; }. ----- script treer.C; void treer() {; TFile f(""test.root"");; TTree *ntuple = (TTree*)f.Get(""ntuple"");; TCanvas c1;; Int_t first = 0;; while(1) {; if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; first = (Int_t)ntuple->GetEntries();; c1.Update();; gSystem->Sleep(1000); //sleep 1 second; ntuple->Refresh();; }; }. TBranch* BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch() with added check that addobj matches className. See TTree::Branch() for other details. TBranch* BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. TBranch* BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. TBranch* BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. Int_t Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99); Deprecated function. Use next function instead. Int_t Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"); Create one branch for each element in the collection. Each entry in the collection becomes a top level branch if the; corresponding class is not a collection. If it is a collection, the entry; in the collection becomes in turn top level branches, etc.; The splitlevel is decreased by 1 every time a new collection is found.; For example if list is a TObjArray*; - if splitlevel = 1, one top level branch",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:44756,Safety,detect,detection,44756,"raw(""px>>hpx"", """","""",10000000,first);; else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; first = (Int_t)ntuple->GetEntries();; c1.Update();; gSystem->Sleep(1000); //sleep 1 second; ntuple->Refresh();; }; }. TBranch* BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch() with added check that addobj matches className. See TTree::Branch() for other details. TBranch* BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. TBranch* BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. TBranch* BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. Int_t Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99); Deprecated function. Use next function instead. Int_t Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"); Create one branch for each element in the collection. Each entry in the collection becomes a top level branch if the; corresponding class is not a collection. If it is a collection, the entry; in the collection becomes in turn top level branches, etc.; The splitlevel is decreased by 1 every time a new collection is found.; For example if list is a TObjArray*; - if splitlevel = 1, one top level branch is created for each element; of the TObjArray.; - if splitlevel = 2, one top level branch is created for each array element.; if, in turn, one of the array elements is a TCollection, one top level; branch will be created for each elemen",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:46229,Safety,avoid,avoid,46229,"entry; in the collection becomes in turn top level branches, etc.; The splitlevel is decreased by 1 every time a new collection is found.; For example if list is a TObjArray*; - if splitlevel = 1, one top level branch is created for each element; of the TObjArray.; - if splitlevel = 2, one top level branch is created for each array element.; if, in turn, one of the array elements is a TCollection, one top level; branch will be created for each element of this collection. In case a collection element is a TClonesArray, the special Tree constructor; for TClonesArray is called.; The collection itself cannot be a TClonesArray. The function returns the total number of branches created. If name is given, all branch names will be prefixed with name_. IMPORTANT NOTE1: This function should not be called with splitlevel < 1. IMPORTANT NOTE2: The branches created by this function will have names; corresponding to the collection or object names. It is important; to give names to collections to avoid misleading branch names or; identical branch names. By default collections have a name equal to; the corresponding class name, e.g. the default name for a TList is ""TList"". And in general in any cases two or more master branches contain subbranches; with identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. Example--------------------------------------------------------------:. {; TTree T(""T"",""test list"");; TList *lis",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:79496,Safety,avoid,avoid,79496,"rrent iteration over this formula for this; entry (i.e. varies from 0 to Length$). Length$(formula): return the total number of element of the formula given as a; parameter.; Sum$(formula): return the sum of the value of the elements of the formula given; as a parameter. For example the mean for all the elements in; one entry can be calculated with:; Sum$(formula)/Length$(formula); Min$(formula): return the minimun (within one TTree entry) of the value of the; elements of the formula given as a parameter.; Max$(formula): return the maximum (within one TTree entry) of the value of the; elements of the formula given as a parameter.; MinIf$(formula,condition); MaxIf$(formula,condition): return the minimum (maximum) (within one TTree entry); of the value of the elements of the formula given as a parameter; if they match the condition. If no element matches the condition,; the result is zero. To avoid the resulting peak at zero, use the; pattern:; tree->Draw(""MinIf$(formula,condition)"",""condition"");; which will avoid calculation MinIf$ for the entries that have no match; for the condition. Alt$(primary,alternate) : return the value of ""primary"" if it is available; for the current iteration otherwise return the value of ""alternate"".; For example, with arr1[3] and arr2[2]; tree->Draw(""arr1+Alt$(arr2,0)"");; will draw arr1[0]+arr2[0] ; arr1[1]+arr2[1] and arr1[2]+0; Or with a variable size array arr3; tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); As a comparison; tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the; actual_size_of_arr3 is greater or equal to 3.; Note that the array in 'primary' is flattened/linearized thus using; Alt$ with multi-dimensional arrays of different dimensions in unlikely; to yield the expected results. To visualize a bit more what elements; would be matched by TTree::Draw, TTree::Scan can be used:; tree->Scan(""arr1:A",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:79614,Safety,avoid,avoid,79614,"rrent iteration over this formula for this; entry (i.e. varies from 0 to Length$). Length$(formula): return the total number of element of the formula given as a; parameter.; Sum$(formula): return the sum of the value of the elements of the formula given; as a parameter. For example the mean for all the elements in; one entry can be calculated with:; Sum$(formula)/Length$(formula); Min$(formula): return the minimun (within one TTree entry) of the value of the; elements of the formula given as a parameter.; Max$(formula): return the maximum (within one TTree entry) of the value of the; elements of the formula given as a parameter.; MinIf$(formula,condition); MaxIf$(formula,condition): return the minimum (maximum) (within one TTree entry); of the value of the elements of the formula given as a parameter; if they match the condition. If no element matches the condition,; the result is zero. To avoid the resulting peak at zero, use the; pattern:; tree->Draw(""MinIf$(formula,condition)"",""condition"");; which will avoid calculation MinIf$ for the entries that have no match; for the condition. Alt$(primary,alternate) : return the value of ""primary"" if it is available; for the current iteration otherwise return the value of ""alternate"".; For example, with arr1[3] and arr2[2]; tree->Draw(""arr1+Alt$(arr2,0)"");; will draw arr1[0]+arr2[0] ; arr1[1]+arr2[1] and arr1[2]+0; Or with a variable size array arr3; tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); As a comparison; tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the; actual_size_of_arr3 is greater or equal to 3.; Note that the array in 'primary' is flattened/linearized thus using; Alt$ with multi-dimensional arrays of different dimensions in unlikely; to yield the expected results. To visualize a bit more what elements; would be matched by TTree::Draw, TTree::Scan can be used:; tree->Scan(""arr1:A",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:91213,Safety,recover,recoverable,91213,"n is also called committing or; 'flushing' the basket). The committed baskets are then; immediately removed from memory. The function returns the number of bytes committed to the; individual branches. If a write error occurs, the number of bytes returned is -1. If no data are written, because, e.g., the branch is disabled,; the number of bytes returned is 0. The baskets are flushed and the Tree header saved at regular intervals. At regular intervals, when the amount of data written so far is; greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; This makes future reading faster as it guarantees that baskets belonging to nearby; entries will be on the same disk region.; When the first call to flush the baskets happen, we also take this opportunity; to optimize the baskets buffers.; We also check if the amount of data written is greater than fAutoSave (see SetAutoSave).; In this case we also write the Tree header. This makes the Tree recoverable up to this point; in case the program writing the Tree crashes.; The decisions to FlushBaskets and Auto Save can be made based either on the number; of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries; written (fAutoFlush and fAutoSave positive).; Note that the user can decide to call FlushBaskets and AutoSave in her event loop; base on the number of events written instead of the number of bytes written. Note that calling FlushBaskets too often increases the IO time.; Note that calling AutoSave too often increases the IO time and also the file size. TBranch* FindBranch(const char* name); Return the branch that correspond to the path 'branchname', which can; include the name of the tree or the omitted name of the parent branches.; In case of ambiguity, returns the first match. TLeaf* FindLeaf(const char* name); FIXME: Describe this function. Int_t Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:127284,Safety,recover,recover,127284,"oFlush mechanism is disabled. Flushing the buffers at regular intervals optimize the location of; consecutive entries on the disk by creating clusters of baskets. A cluster of baskets is a set of baskets that contains all; the data for a (consecutive) set of entries and that is stored; consecutively on the disk. When reading all the branches, this; is the minimum set of baskets that the TTreeCache will read. void SetAutoSave(Long64_t autos = -300000000); This function may be called at the start of a program to change; the default value for fAutoSave (and for SetAutoSave) is -300000000, ie 300 MBytes; When filling the Tree the branch buffers as well as the Tree header; will be flushed to disk when the watermark is reached.; If fAutoSave is positive the watermark is reached when a multiple of fAutoSave; entries have been written.; If fAutoSave is negative the watermark is reached when -fAutoSave bytes; have been written to the file.; In case of a program crash, it will be possible to recover the data in the Tree; up to the last AutoSave point. void SetBasketSize(const char* bname, Int_t buffsize = 16000); Set a branch's basket size. bname is the name of a branch.; if bname=""*"", apply to all branches.; if bname=""xxx*"", apply to all branches with name starting with xxx; see TRegexp for wildcarding options; buffsize = branc basket size. Int_t SetBranchAddress(const char* bname, void** add, TBranch** ptr = 0); Change branch address, dealing with clone trees properly.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the; meaning of the addr parameter and the object ownership policy. Int_t SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); Verify the validity of the type of addr before calling SetBranchAddress.; See TTree::CheckBranchAddressType for the semantic of the return value. Note: See the comments in TBranchElement::SetAddress() for the",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:140912,Safety,avoid,avoid,140912,"rns -1. void UseCurrentStyle(); Replace current attributes by current style. Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Write this object to the current directory. For more see TObject::Write; Write calls TTree::FlushBaskets before writing the tree. Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); Write this object to the current directory. For more see TObject::Write; If option & kFlushBasket, call FlushBasket before writing the tree. TTree(const TTree& tt). TTree& operator=(const TTree& tt). void AddTotBytes(Int_t tot); { fTotBytes += tot; }. void AddZipBytes(Int_t zip); { fZipBytes += zip; }. Int_t Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"). Int_t Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99). Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99). return Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); Overload to avoid confusion between this signature and the template instance. Int_t Debug() const; { return fDebug; }. void Draw(Option_t* opt); { Draw(opt, """", """", 1000000000, 0); }. Long64_t GetAutoFlush() const; {return fAutoFlush;}. Long64_t GetAutoSave() const; {return fAutoSave;}. TBranchRef * GetBranchRef() const; { return fBranchRef; }. Long64_t GetCacheSize() const; { return fCacheSize; }. TClusterIterator GetClusterIterator(Long64_t firstentry). Long64_t GetChainEntryNumber(Long64_t entry) const; { return entry; }. Long64_t GetChainOffset() const; { return fChainOffset; }. Int_t GetDefaultEntryOffsetLen() const; {return fDefaultEntryOffsetLen;}. Long64_t GetDebugMax() const; { return fDebugMax; }. Long64_t GetDebugMin() const; { return fDebugMin; }. TDirectory * GetDirectory() const; { return fDirectory; }. Long64_t GetEntries() const; { return fEntries; }. Long64_t GetEntriesFast() const; { return fEntries; }. Long64_t GetEstimate() const; { return fEstimate; }. Int_",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:6269,Security,access,access,6269,"ee->Branch(branchname, &object, bufsize, splitlevel). Note: The 2nd parameter must be the address of a valid object.; The object must not be destroyed (i.e. be deleted) until the TTree; is deleted or TTree::ResetBranchAddress is called. * if splitlevel=0, the object is serialized in the branch buffer.; * if splitlevel=1 (default), this branch will automatically be split; into subbranches, with one subbranch for each data member or object; of the object itself. In case the object member is a TClonesArray,; the mechanism described in case C is applied to this array.; * if splitlevel=2 ,this branch will automatically be split; into subbranches, with one subbranch for each data member or object; of the object itself. In case the object member is a TClonesArray,; it is processed as a TObject*, only one branch. ==> Case D. TBranch *branch = tree->Branch(branchname,clonesarray, bufsize, splitlevel); clonesarray is the address of a pointer to a TClonesArray.; The TClonesArray is a direct access list of objects of the same class.; For example, if the TClonesArray is an array of TTrack objects,; this function will create one subbranch for each data member of; the object TTrack. ==> Case E. TBranch *branch = tree->Branch( branchname, STLcollection, buffsize, splitlevel);; STLcollection is the address of a pointer to std::vector, std::list,; std::deque, std::set or std::multiset containing pointers to objects.; If the splitlevel is a value bigger than 100 (TTree::kSplitCollectionOfPointers); then the collection will be written in split mode, e.g. if it contains objects of; any types deriving from TTrack this function will sort the objects; based on their type and store them in separate branches in split; mode. ==> branch->SetAddress(Void *address); In case of dynamic structures changing with each entry for example, one must; redefine the branch address before filling the branch again.; This is done via the TBranch::SetAddress member function. ==> tree->Fill(); loops on all defi",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:37843,Security,access,access,37843,"f the subbranches are; also removed from the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the TTree::AddFriend; method. The tree in the diagram below has two friends (friend_tree1 and; friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. /*; ; */. The AddFriend method has two parameters, the first is the tree name and the; second is the name of the ROOT file where the friend tree is saved.; AddFriend automatically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias in the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify ",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:38137,Security,access,access,38137,"ned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted access to the friends data. In this way; it is much like adding another branch to the tree without taking the risk; of damaging it. To add a friend to the list, you can use the TTree::AddFriend; method. The tree in the diagram below has two friends (friend_tree1 and; friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m. /*; ; */. The AddFriend method has two parameters, the first is the tree name and the; second is the name of the ROOT file where the friend tree is saved.; AddFriend automatically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias in the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify which tree to use in; the Draw method, use the syntax:. <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can; leave out the tree and/or branch name.; For example, these commands generate a 3-d scatter plot of variable ""var""; in the TTree",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:39342,Security,access,access,39342,"ically opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias in the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify which tree to use in; the Draw method, use the syntax:. <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can; leave out the tree and/or branch name.; For example, these commands generate a 3-d scatter plot of variable ""var""; in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in; TTree ft2. tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");. /*; ; */. The picture illustrates the access of the tree and its friends with a; Draw command.; When AddFriend is called, the ROOT file is automatically opened and the; friend tree (ft1) is read into memory. The new friend (ft1) is added to; the list of friends of tree.; The number of entries in the friend must be equal or greater to the number; of entries of the original tree. If the friend tree has fewer entries a; warning is given and the missing entries are not included in the histogram.; To retrieve the list of friends from a tree use TTree::GetListOfFriends.; When the tree is written to file (TTree::Write), the friends list is saved; with it. And when the tree is retrieved, the trees on the friends list are; also retrieved and the friendship restored.; When a tree is deleted, the elements of the friend list are also deleted.; It is possible to declare a friend tree that has the same internal; structure (same branches and leaves) as the original tree, and compare the; same values by specifying the tree. tree.Draw(""var:ft1.var:ft2.v",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:50714,Security,access,access,50714,"n; if nelem is a leaf name, it is used as the variable size of the array,; otherwise return 0.; If leaf name has the form var[nelem], where nelem is a non-negative integer, then; it is used as the fixed size of the array.; If leaf name has the form of a multi-dimensional array (e.g. var[nelem][nelem2]); where nelem and nelem2 are non-negative integer) then; it is used as a 2 dimensional array of fixed size.; Any of other form is not supported. Note that the TTree will assume that all the item are contiguous in memory.; On some platform, this is not always true of the member of a struct or a class,; due to padding and alignment. Sorting your data member in order of decreasing; sizeof usually leads to their being contiguous in memory. * bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. TBranch* Branch(const char* name, const char* classname, void** obj, Int_t bufsize = 32000, Int_t splitlevel = 99); Create a new branch with the object of class classname at address addobj. WARNING:; Starting with Root version 3.01, the Branch function uses the new style; branches (TBranchElement). To get the old behaviour, you can:; - call BranchOld or; - call TTree::SetBranchStyle(0). Note that with the new style, classname does not need to derive from TObject.; It must derived from TObject if the branch style has been set to 0 (old). Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the addobj parameter in; the case of new-style branches. Use splitlevel < 0 instead of splitlevel=0 when the class; has a custom Streamer. Note: if the split level is set to the default (99), TTree::Branch will; not issue a warning if the class can not",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:52113,Security,access,access,52113,"chOld or; - call TTree::SetBranchStyle(0). Note that with the new style, classname does not need to derive from TObject.; It must derived from TObject if the branch style has been set to 0 (old). Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the addobj parameter in; the case of new-style branches. Use splitlevel < 0 instead of splitlevel=0 when the class; has a custom Streamer. Note: if the split level is set to the default (99), TTree::Branch will; not issue a warning if the class can not be split. TBranch* BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); Create a new TTree BranchObject. Build a TBranchObject for an object of class classname.; addobj is the address of a pointer to an object of class classname.; IMPORTANT: classname must derive from TObject.; The class dictionary must be available (ClassDef in class header). This option requires access to the library where the corresponding class; is defined. Accessing one single data member in the object implies; reading the full object.; See the next Branch constructor for a more efficient storage; in case the entry consists of arrays of identical objects. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, ",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:53514,Security,access,access,53514," different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. TBranch* BranchRef(); Build the optional branch supporting the TRefTable.; This branch will keep all the information to find the branches; containing referenced objects. At each Tree::Fill, the branch numbers containing the; referenced objects are saved to the TBranchRef basket.; When the Tree header is saved (via TTree::Write), the branch; is saved keeping the information with the pointers to the branches; having referenced objects. TBranch* Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); Create a new TTree BranchElement. WARNING about this new function. This function is designed to replace the internal; implementation of the old TTree::Branch (whose implementation; has been moved to BranchOld). NOTE: The 'Bronch' method supports only one possible calls; signature (where the object type has to be specified; explicitly and the ",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:55313,Security,access,access,55313,"oved to BranchOld). NOTE: The 'Bronch' method supports only one possible calls; signature (where the object type has to be specified; explicitly and the address must be the address of a pointer).; For more flexibility use 'Branch'. Use Bronch only in (rare); cases (likely to be legacy cases) where both the new and old; implementation of Branch needs to be used at the same time. This function is far more powerful than the old Branch; function. It supports the full C++, including STL and has; the same behaviour in split or non-split mode. classname does; not have to derive from TObject. The function is based on; the new TStreamerInfo. Build a TBranchElement for an object of class classname. addr is the address of a pointer to an object of class; classname. The class dictionary must be available (ClassDef; in class header). Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the addr parameter. This option requires access to the library where the; corresponding class is defined. Accessing one single data; member in the object implies reading the full object. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. bufsize is the buffer siz",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:56592,Security,access,access,56592," different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. Use splitlevel < 0 instead of splitlevel=0 when the class; has a custom Streamer. Note: if the split level is set to the default (99), TTree::Branch will; not issue a warning if the class can not be split. TBranch* BronchExec(const char* name, const char* classname, void* addobj, Bool_t isptrptr, Int_t bufsize, Int_t splitlevel); Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. void Browse(TBrowser* ); Browse content of the TTree. Int_t BuildIndex(const char* majorname, const char* minorname = ""0""); Build a Tree Index (default is TTreeIndex).; See a description of the parameters and functionality in; TTreeIndex::TTreeIndex(). The return value is the number of entries in the Index (< 0 indicates failure). A TTreeIndex object pointed by fTreeIndex is created.; This object will be automatically deleted by the TTree destructor.; See also comments in TT",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:69081,Security,authoriz,authorized,69081," number is negative it is set to 0.; If the color number is greater than the current number of colors; it is set to the highest color number.; The default number of colors is 50.; see TStyle::SetPalette for setting a new color palette. Note that the variables e1, e2 or e3 may contain a selection.; example, if e1= x*(y<0), the value histogrammed will be x if y<0; and will be 0 otherwise. The expressions can use all the operations and build-in functions; supported by TFormula (See TFormula::Analyze), including free; standing function taking numerical arguments (TMath::Bessel).; In addition, you can call member functions taking numerical; arguments. For example:; - ""TMath::BreitWigner(fPx,3,2)""; - ""event.GetHistogram().GetXaxis().GetXmax()""; Note: You can only pass expression that depend on the TTree's data; to static functions and you can only call non-static member function; with 'fixed' parameters. selection is an expression with a combination of the columns.; In a selection all the C++ operators are authorized.; The value corresponding to the selection expression is used as a weight; to fill the histogram.; If the expression includes only boolean operations, the result; is 0 or 1. If the result is 0, the histogram is not filled.; In general, the expression may be of the form:; value*(boolean expression); if boolean expression is true, the histogram is filled with; a weight = value.; Examples:; selection1 = ""x<y && sqrt(z)>3.2""; selection2 = ""(x+y)*(sqrt(z)>3.2)""; selection1 returns a weight = 0 or 1; selection2 returns a weight = x+y if sqrt(z)>3.2; returns a weight = 0 otherwise. option is the drawing option.; - See TH1::Draw for the list of all drawing options.; - If option COL is specified when varexp has three fields:; tree.Draw(""e1:e2:e3"","""",""col"");; a 2D scatter is produced with e1 vs e2, and e3 is mapped on the color; table. The colors for e3 are evaluated once in linear scale before; painting. Therefore changing the pad to log scale along Z as no effect; on",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:70539,Security,access,access,70539,"rt(z)>3.2)""; selection1 returns a weight = 0 or 1; selection2 returns a weight = x+y if sqrt(z)>3.2; returns a weight = 0 otherwise. option is the drawing option.; - See TH1::Draw for the list of all drawing options.; - If option COL is specified when varexp has three fields:; tree.Draw(""e1:e2:e3"","""",""col"");; a 2D scatter is produced with e1 vs e2, and e3 is mapped on the color; table. The colors for e3 are evaluated once in linear scale before; painting. Therefore changing the pad to log scale along Z as no effect; on the colors.; - If option contains the string ""goff"", no graphics is generated. nentries is the number of entries to process (default is all); first is the first entry to process (default is 0). This function returns the number of selected entries. It returns -1; if an error occurs. Drawing expressions using arrays and array elements. Let assumes, a leaf fMatrix, on the branch fEvent, which is a 3 by 3 array,; or a TClonesArray.; In a TTree::Draw expression you can now access fMatrix using the following; syntaxes:. String passed What is used for each entry of the tree. ""fMatrix"" the 9 elements of fMatrix; ""fMatrix[][]"" the 9 elements of fMatrix; ""fMatrix[2][2]"" only the elements fMatrix[2][2]; ""fMatrix[1]"" the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2]; ""fMatrix[1][]"" the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2]; ""fMatrix[][0]"" the 3 elements fMatrix[0][0], fMatrix[1][0] and fMatrix[2][0]. ""fEvent.fMatrix...."" same as ""fMatrix..."" (unless there is more than one leaf named fMatrix!). In summary, if a specific index is not specified for a dimension, TTree::Draw; will loop through all the indices along this dimension. Leaving off the; last (right most) dimension of specifying then with the two characters '[]'; is equivalent. For variable size arrays (and TClonesArray) the range; of the first dimension is recalculated for each entry of the tree.; You can also specify the index as an expression of any other variables from the",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:74232,Security,access,access,74232,"][]"" is:. for (Int_t i0; i < min(3,5); i++) {; for (Int_t i1; i1 < min(3,2); i1++) {; use the value of (fMatrix[i0][i1] - fMatrix[i0][i1]); }; }. So the loop equivalent to ""fMatrix[][fResults[][]]"" is:. for (Int_t i0; i0 < 3; i0++) {; for (Int_t j2; j2 < 5; j2++) {; for (Int_t j3; j3 < 2; j3++) {; i1 = fResults[j2][j3];; use the value of fMatrix[i0][i1]; }; }. Retrieving the result of Draw. By default the temporary histogram created is called ""htemp"", but only in; the one dimensional Draw(""e1"") it contains the TTree's data points. For; a two dimensional Draw, the data is filled into a TGraph which is named; ""Graph"". They can be retrieved by calling; TH1F *htemp = (TH1F*)gPad->GetPrimitive(""htemp""); // 1D; TGraph *graph = (TGraph*)gPad->GetPrimitive(""Graph""); // 2D. For a three and four dimensional Draw the TPolyMarker3D is unnamed, and; cannot be retrieved. gPad always contains a TH1 derived object called ""htemp"" which allows to; access the axes:; TGraph *graph = (TGraph*)gPad->GetPrimitive(""Graph""); // 2D; TH2F *htemp = (TH2F*)gPad->GetPrimitive(""htemp""); // empty, but has axes; TAxis *xaxis = htemp->GetXaxis();. Saving the result of Draw to an histogram. If varexp0 contains >>hnew (following the variable(s) name(s),; the new histogram created is called hnew and it is kept in the current; directory (and also the current pad). This works for all dimensions.; Example:; tree.Draw(""sqrt(x)>>hsqrt"",""y>0""); will draw sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. To retrieve it do:; TH1F *hsqrt = (TH1F*)gDirectory->Get(""hsqrt"");. The binning information is taken from the environment variables. Hist.Binning.?D.?. In addition, the name of the histogram can be followed by up to 9; numbers between '(' and ')', where the numbers describe the; following:. 1 - bins in x-direction; 2 - lower limit in x-direction; 3 - upper limit in x-direction; 4-6 same for y-direction; 7-9 same for z-direction. When a new binning is used the new value will become the defau",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:76549,Security,access,access,76549,"ns in y-direction; lower limit on y-axis is .1; upper limit is .5. By default, the specified histogram is reset.; To continue to append data to an existing histogram, use ""+"" in front; of the histogram name.; A '+' in front of the histogram name is ignored, when the name is followed by; binning information as described in the previous paragraph.; tree.Draw(""sqrt(x)>>+hsqrt"",""y>0""); will not reset hsqrt, but will continue filling.; This works for 1-D, 2-D and 3-D histograms. Accessing collection objects. TTree::Draw default's handling of collections is to assume that any; request on a collection pertain to it content. For example, if fTracks; is a collection of Track objects, the following:; tree->Draw(""event.fTracks.fPx"");; will plot the value of fPx for each Track objects inside the collection.; Also; tree->Draw(""event.fTracks.size()"");; would plot the result of the member function Track::size() for each; Track object inside the collection.; To access information about the collection itself, TTree::Draw support; the '@' notation. If a variable which points to a collection is prefixed; or postfixed with '@', the next part of the expression will pertain to; the collection object. For example:; tree->Draw(""event.@fTracks.size()"");; will plot the size of the collection referred to by fTracks (i.e the number; of Track objects). Drawing 'objects'. When a class has a member function named AsDouble or AsString, requesting; to directly draw the object will imply a call to one of the 2 functions.; If both AsDouble and AsString are present, AsDouble will be used.; AsString can return either a char*, a std::string or a TString.s; For example, the following; tree->Draw(""event.myTTimeStamp"");; will draw the same histogram as; tree->Draw(""event.myTTimeStamp.AsDouble()"");; In addition, when the object is a type TString or std::string, TTree::Draw; will call respectively TString::Data and std::string::c_str(). If the object is a TBits, the histogram will contain the index of the bit",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:78093,Security,access,access,78093,"to one of the 2 functions.; If both AsDouble and AsString are present, AsDouble will be used.; AsString can return either a char*, a std::string or a TString.s; For example, the following; tree->Draw(""event.myTTimeStamp"");; will draw the same histogram as; tree->Draw(""event.myTTimeStamp.AsDouble()"");; In addition, when the object is a type TString or std::string, TTree::Draw; will call respectively TString::Data and std::string::c_str(). If the object is a TBits, the histogram will contain the index of the bit; that are turned on. Retrieving information about the tree itself. You can refer to the tree (or chain) containing the data by using the; string 'This'.; You can then could any TTree methods. For example:; tree->Draw(""This->GetReadEntry()"");; will display the local entry numbers be read.; tree->Draw(""This->GetUserInfo()->At(0)->GetName()"");; will display the name of the first 'user info' object. Special functions and variables. Entry$: A TTree::Draw formula can use the special variable Entry$; to access the entry number being read. For example to draw every; other entry use:; tree.Draw(""myvar"",""Entry$%2==0"");. Entry$ : return the current entry number (== TTree::GetReadEntry()); LocalEntry$ : return the current entry number in the current tree of a; chain (== GetTree()->GetReadEntry()); Entries$ : return the total number of entries (== TTree::GetEntries()); Length$ : return the total number of element of this formula for this; entry (==TTreeFormula::GetNdata()); Iteration$: return the current iteration over this formula for this; entry (i.e. varies from 0 to Length$). Length$(formula): return the total number of element of the formula given as a; parameter.; Sum$(formula): return the sum of the value of the elements of the formula given; as a parameter. For example the mean for all the elements in; one entry can be calculated with:; Sum$(formula)/Length$(formula); Min$(formula): return the minimun (within one TTree entry) of the value of the; elements of the fo",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:80931,Security,access,accessing,80931,"[0] ; arr1[1]+arr2[1] and arr1[2]+0; Or with a variable size array arr3; tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); As a comparison; tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the; actual_size_of_arr3 is greater or equal to 3.; Note that the array in 'primary' is flattened/linearized thus using; Alt$ with multi-dimensional arrays of different dimensions in unlikely; to yield the expected results. To visualize a bit more what elements; would be matched by TTree::Draw, TTree::Scan can be used:; tree->Scan(""arr1:Alt$(arr2,0)"");; will print on one line the value of arr1 and (arr2,0) that will be; matched by; tree->Draw(""arr1-Alt$(arr2,0)"");. The ternary operator is not directly supported in TTree::Draw however, to plot the; equivalent of 'var2<20 ? -99 : var1', you can use:; tree->Draw(""(var2<20)*99+(var2>=20)*var1"","""");. Drawing a user function accessing the TTree data directly. If the formula contains a file name, TTree::MakeProxy will be used; to load and execute this file. In particular it will draw the; result of a function with the same name as the file. The function; will be executed in a context where the name of the branches can; be used as a C++ variable. For example draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. The main features of this facility are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the b",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:87355,Security,access,access,87355," ALL tracks in event with at least one track with; a positive fPy. To select only the elements that did match the original selection; use TEventList::SetReapplyCut or TEntryList::SetReapplyCut.; Example:; tree.Draw("">>pyplus"",""fTracks.fPy>0"");; pyplus->SetReapplyCut(kTRUE);; tree->SetEventList(pyplus);; tree->Draw(""fTracks.fPy"");; will draw the fPy of only the tracks that have a positive fPy. To draw only the elements that match a selection in case of arrays,; you can also use TEntryListArray (faster in case of a more general selection).; Example:; tree.Draw("">>pyplus"",""fTracks.fPy>0"", ""entrylistarray"");; tree->SetEntryList(pyplus);; tree->Draw(""fTracks.fPy"");. will draw the fPy of only the tracks that have a positive fPy,; but without redoing the selection. Note: Use tree->SetEventList(0) if you do not want use the list as input. How to obtain more info from TTree::Draw. Once TTree::Draw has been called, it is possible to access useful; information still stored in the TTree object via the following functions:; -GetSelectedRows() //return the number of values accepted by the; //selection expression. In case where no selection; //was specified, returns the number of values processed.; -GetV1() //returns a pointer to the double array of V1; -GetV2() //returns a pointer to the double array of V2; -GetV3() //returns a pointer to the double array of V3; -GetV4() //returns a pointer to the double array of V4; -GetW() //returns a pointer to the double array of Weights; //where weight equal the result of the selection expression.; where V1,V2,V3 correspond to the expressions in; TTree::Draw(""V1:V2:V3:V4"",selection);; If the expression has more than 4 component use GetVal(index). Example:; Root > ntuple->Draw(""py:px"",""pz>4"");; Root > TGraph *gr = new TGraph(ntuple->GetSelectedRows(),; ntuple->GetV2(), ntuple->GetV1());; Root > gr->Draw(""ap""); //draw graph in current pad; creates a TGraph object with a number of points corresponding to the; number of entries selected by the e",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:104674,Security,access,access,104674,"ly created if it does not exist. WARNING: By default the TTree destructor will delete all objects added; to this list. If you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void ImportClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; The function returns the total number of baskets read into memory; if negative an error occurred while loading the branches.; This method may be called to force branch baskets in memory; when random access to branch entries is required.; If random access to only a few branches is required, you should; call directly TBranch::LoadBaskets. Long64_t LoadTree(Long64_t entry); Set current entry. Returns -2 if entry does not exist (just as TChain::LoadTree()). Note: This function is overloaded in TChain. Long64_t LoadTreeFriend(Long64_t entry, TTree* T); Load entry on behalf of our master tree, we may use an index. Called by LoadTree() when the masterTree looks for the entry; number in a friend tree (us) corresponding to the passed entry; number in the masterTree. If we have no index, our entry number and the masterTree entry; number are the same. If we *do* have an index, we must find the (major, minor) value pair; in masterTree to locate our corresponding entry. Int_t MakeClass(const char* classname = 0, Option_t* option = """"); Generate a skeleton analysis class for this tree. The following files are produced: classname.h and classname.C.; If classname is 0, classnam",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:104723,Security,access,access,104723," this list. If you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void ImportClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; The function returns the total number of baskets read into memory; if negative an error occurred while loading the branches.; This method may be called to force branch baskets in memory; when random access to branch entries is required.; If random access to only a few branches is required, you should; call directly TBranch::LoadBaskets. Long64_t LoadTree(Long64_t entry); Set current entry. Returns -2 if entry does not exist (just as TChain::LoadTree()). Note: This function is overloaded in TChain. Long64_t LoadTreeFriend(Long64_t entry, TTree* T); Load entry on behalf of our master tree, we may use an index. Called by LoadTree() when the masterTree looks for the entry; number in a friend tree (us) corresponding to the passed entry; number in the masterTree. If we have no index, our entry number and the masterTree entry; number are the same. If we *do* have an index, we must find the (major, minor) value pair; in masterTree to locate our corresponding entry. Int_t MakeClass(const char* classname = 0, Option_t* option = """"); Generate a skeleton analysis class for this tree. The following files are produced: classname.h and classname.C.; If classname is 0, classname will be called ""nameoftree"". The generated code in classname.h includes the following:; - Identification ",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:108129,Security,access,access,108129,"e = 0); Generate a skeleton function for this tree. The function code is written on filename.; If filename is 0, filename will be called nameoftree.C. The generated code includes the following:; - Identification of the original Tree and Input file name,; - Opening the Tree file,; - Declaration of Tree variables,; - Setting of branches addresses,; - A skeleton for the entry loop. To use this function:; - Open your Tree file (eg: TFile f(""myfile.root"");); - T->MakeCode(""MyAnalysis.C"");; where T is the name of the TTree in file myfile.root; and MyAnalysis.C the name of the file created by this function. NOTE: Since the implementation of this function, a new and better; function TTree::MakeClass() has been developed. Int_t MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); Generate a skeleton analysis class for this Tree using TBranchProxy. TBranchProxy is the base of a class hierarchy implementing an; indirect access to the content of the branches of a TTree. ""proxyClassname"" is expected to be of the form:; [path/]fileprefix; The skeleton will then be generated in the file:; fileprefix.h; located in the current directory or in 'path/' if it is specified.; The class generated will be named 'fileprefix'. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source files which will be included by the generated skeleton.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the; system 'unroll' classes that are not split. Unrolling a class; allows direct access to its data members ",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:109090,Security,access,access,109090,"enting an; indirect access to the content of the branches of a TTree. ""proxyClassname"" is expected to be of the form:; [path/]fileprefix; The skeleton will then be generated in the file:; fileprefix.h; located in the current directory or in 'path/' if it is specified.; The class generated will be named 'fileprefix'. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source files which will be included by the generated skeleton.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the; system 'unroll' classes that are not split. Unrolling a class; allows direct access to its data members (this emulates the behavior; of TTreeFormula). The main features of this skeleton are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bounds errors; * ability to use the branch data as an object (when the user code is available). For example with Event.root, if; Double_t somePx = fTracks.fPx[2];; is executed by one of the method of the skeleton,; somePx will updated with the current value of fPx of the 3rd track. Both macrofilename and the optional cutfilename are expected to be; the name of source files which contain at least a free standing; function with the signature:; x_t macrofilename(); // i.e function with the same name as the file; and; y_t cutfilename(); // i.e function with the same name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. These two functions are ru",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:111361,Security,access,accessible,111361," if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. Int_t MakeSelector(const char* selector = 0); Generate skeleton selector class for this tree. The following files are produced: selector.h and selector.C.; If selector is 0, the selector will be called ""nameoftree"". The generated code in selector.h includes the following:; - Identification of the ",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:111558,Security,access,access,111558,"r will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; it is included before the declaration of the proxy class. This can; be used in particular to insure that the include files needed by; the macro file are properly loaded. The default histogram is accessible via the variable named 'htemp'. If the library of the classes describing the data in the branch is; loaded, the skeleton will add the needed #include statements and; give the ability to access the object stored in the branches. To draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. Int_t MakeSelector(const char* selector = 0); Generate skeleton selector class for this tree. The following files are produced: selector.h and selector.C.; If selector is 0, the selector will be called ""nameoftree"". The generated code in selector.h includes the following:; - Identification of the original Tree and Input file name; - Definition of selector class (data and functions); - The following class functions:; - construc",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:41817,Testability,test,tests,41817," (e.g., the user must delete the file).; For a complete description see AddFriend(const char *, const char *). Long64_t AutoSave(Option_t* option = """"); AutoSave tree header every fAutoSave bytes. When large Trees are produced, it is safe to activate the AutoSave; procedure. Some branches may have buffers holding many entries.; If fAutoSave is negative, AutoSave is automatically called by; TTree::Fill when the number of bytes generated since the previous; AutoSave is greater than -fAutoSave bytes.; If fAutoSave is positive, AutoSave is automatically called by; TTree::Fill every N entries.; This function may also be invoked by the user.; Each AutoSave generates a new key on the file.; Once the key with the tree header has been written, the previous cycle; (if any) is deleted. Note that calling TTree::AutoSave too frequently (or similarly calling; TTree::SetAutoSave with a small value) is an expensive operation.; You should make tests for your own application to find a compromise; between speed and the quantity of information you may loose in case of; a job crash. In case your program crashes before closing the file holding this tree,; the file will be automatically recovered when you will connect the file; in UPDATE mode.; The Tree will be recovered at the status corresponding to the last AutoSave. if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; This allows another process to analyze the Tree while the Tree is being filled. if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; the current basket are closed-out and written to disk individually. By default the previous header is deleted after having written the new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:43192,Testability,test,test,43192,"last AutoSave. if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; This allows another process to analyze the Tree while the Tree is being filled. if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; the current basket are closed-out and written to disk individually. By default the previous header is deleted after having written the new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number of bytes is null, an error has occurred while writing; the header to the file. How to write a Tree in one process and view it from another process. The following two scripts illustrate how to do this.; The script treew.C is executed by process1, treer.C by process2. ----- script treew.C; void treew() {; TFile f(""test.root"",""recreate"");; TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; Float_t px, py, pz;; for ( Int_t i=0; i<10000000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ntuple->Fill(px,py,pz,random,i);; if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; }; }. ----- script treer.C; void treer() {; TFile f(""test.root"");; TTree *ntuple = (TTree*)f.Get(""ntuple"");; TCanvas c1;; Int_t first = 0;; while(1) {; if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; first = (Int_t)ntuple->GetEntries();; c1.Update();; gSystem->Sleep(1000); //sleep 1 second; ntuple->Refresh();; }; }. TBranch* BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch() with added check that addobj matches className. See TTree::Branch() for other details. TBranch* BranchImp(const char* branchname, ",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:43561,Testability,test,test,43561," new header.; if option contains ""Overwrite"", the previous Tree header is deleted; before written the new header. This option is slightly faster, but; the default option is safer in case of a problem (disk quota exceeded); when writing the new header. The function returns the number of bytes written to the file.; if the number of bytes is null, an error has occurred while writing; the header to the file. How to write a Tree in one process and view it from another process. The following two scripts illustrate how to do this.; The script treew.C is executed by process1, treer.C by process2. ----- script treew.C; void treew() {; TFile f(""test.root"",""recreate"");; TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; Float_t px, py, pz;; for ( Int_t i=0; i<10000000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ntuple->Fill(px,py,pz,random,i);; if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; }; }. ----- script treer.C; void treer() {; TFile f(""test.root"");; TTree *ntuple = (TTree*)f.Get(""ntuple"");; TCanvas c1;; Int_t first = 0;; while(1) {; if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; first = (Int_t)ntuple->GetEntries();; c1.Update();; gSystem->Sleep(1000); //sleep 1 second; ntuple->Refresh();; }; }. TBranch* BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch() with added check that addobj matches className. See TTree::Branch() for other details. TBranch* BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.; See TTree::Branch for other details. TBranch* BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); Same as TTree::Branch but automatic detection of the class name.;",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:47209,Testability,test,test,47209,"ions to avoid misleading branch names or; identical branch names. By default collections have a name equal to; the corresponding class name, e.g. the default name for a TList is ""TList"". And in general in any cases two or more master branches contain subbranches; with identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. Example--------------------------------------------------------------:. {; TTree T(""T"",""test list"");; TList *list = new TList();. TObjArray *a1 = new TObjArray();; a1->SetName(""a1"");; list->Add(a1);; TH1F *ha1a = new TH1F(""ha1a"",""ha1"",100,0,1);; TH1F *ha1b = new TH1F(""ha1b"",""ha1"",100,0,1);; a1->Add(ha1a);; a1->Add(ha1b);; TObjArray *b1 = new TObjArray();; b1->SetName(""b1"");; list->Add(b1);; TH1F *hb1a = new TH1F(""hb1a"",""hb1"",100,0,1);; TH1F *hb1b = new TH1F(""hb1b"",""hb1"",100,0,1);; b1->Add(hb1a);; b1->Add(hb1b);. TObjArray *a2 = new TObjArray();; a2->SetName(""a2"");; list->Add(a2);; TH1S *ha2a = new TH1S(""ha2a"",""ha2"",100,0,1);; TH1S *ha2b = new TH1S(""ha2b"",""ha2"",100,0,1);; a2->Add(ha2a);; a2->Add(ha2b);. T.Branch(list,16000,2);; T.Print();; }. Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); Create one branch for each element in the folder.; Returns the total number of branches created. TBranch* Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); Create a new TTree Branch. This Branch constructor is provided to support no",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:62812,Testability,test,test,62812,"ets are sorted by their offset in the original file; Usually; this also means that the baskets are sorted by the index/number of; the _last_ entry they contain). When using SortBasketsByBranch all the baskets of each individual; branches are stored contiguously. This tends to optimize reading; speed when reading a small number (1->5) of branches, since all; their baskets will be clustered together instead of being spread; across the file. However it might decrease the performance when; reading more branches (or the full entry). When using SortBasketsByEntry the baskets with the lowest starting; entry are written first. (i.e. the baskets are sorted by the; index/number of the first entry they contain). This means that on; the file the baskets will be in the order in which they will be; needed when reading the whole tree sequentially. For examples of CloneTree, see tutorials:. -- copytree. A macro to copy a subset of a TTree to a new TTree. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. -- copytree2. A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. void CopyAddresses(TTree* , Bool_t undo = kFALSE); Set branch addresses of passed tree equal to ours.; If undo is true, reset the branch address instead of copying them.; This insures 'separation' of a cloned tree from its original. Long64_t CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); Copy nentries from given tree to this tree.; This routines assumes that the branches that intended to be copied are; already connected. The typical case is that this tree was created using; tree->CloneTree(0). By default copy all entries. Returns number of bytes copied to this tree. If 'option' contains the word 'fast' and nentries is -1, the cloning will be; done without unzipping or unstreaming the baskets (i.",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:63033,Testability,test,test,63033,"vidual; branches are stored contiguously. This tends to optimize reading; speed when reading a small number (1->5) of branches, since all; their baskets will be clustered together instead of being spread; across the file. However it might decrease the performance when; reading more branches (or the full entry). When using SortBasketsByEntry the baskets with the lowest starting; entry are written first. (i.e. the baskets are sorted by the; index/number of the first entry they contain). This means that on; the file the baskets will be in the order in which they will be; needed when reading the whole tree sequentially. For examples of CloneTree, see tutorials:. -- copytree. A macro to copy a subset of a TTree to a new TTree. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. -- copytree2. A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. void CopyAddresses(TTree* , Bool_t undo = kFALSE); Set branch addresses of passed tree equal to ours.; If undo is true, reset the branch address instead of copying them.; This insures 'separation' of a cloned tree from its original. Long64_t CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); Copy nentries from given tree to this tree.; This routines assumes that the branches that intended to be copied are; already connected. The typical case is that this tree was created using; tree->CloneTree(0). By default copy all entries. Returns number of bytes copied to this tree. If 'option' contains the word 'fast' and nentries is -1, the cloning will be; done without unzipping or unstreaming the baskets (i.e., a direct copy of the; raw bytes on disk). When 'fast' is specified, 'option' can also contains a sorting order for the; baskets in the output file. There are currently 3 supported sorting order:; SortBasketsByOffset (",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:65553,Testability,test,test,65553,"sIsIndexOnError [default]: In case of missing TTreeIndex, the resulting TTree index has gaps.; BuildIndexOnError : If any of the underlying TTree objects do not have a TTreeIndex,; all TTreeIndex are 'ignored' and the missing piece are rebuilt. TTree* CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Copy a tree with selection. IMPORTANT:. The returned copied tree stays connected with the original tree; until the original tree is deleted. In particular, any changes; to the branch addresses in the original tree are also made to; the copied tree. Any changes made to the branch addresses of the; copied tree are overridden anytime the original tree changes its; branch addresses. When the original tree is deleted, all the; branch addresses of the copied tree are set to zero. For examples of CopyTree, see the tutorials:. copytree. Example macro to copy a subset of a tree to a new tree. The input file was generated by running the program in; $ROOTSYS/test/Event in this way:. ./Event 1000 1 1 1. copytree2. Example macro to copy a subset of a tree to a new tree. One branch of the new tree is written to a separate file. The input file was generated by running the program in; $ROOTSYS/test/Event in this way:. ./Event 1000 1 1 1. copytree3. Example macro to copy a subset of a tree to a new tree. Only selected entries are copied to the new tree.; NOTE that only the active branches are copied. TBasket* CreateBasket(TBranch* ); Create a basket for this tree and given branch. void Delete(Option_t* option = """"); Delete this tree from memory or/and disk. if option == ""all"" delete Tree object from memory AND from disk; all baskets on disk are deleted. All keys with same name; are deleted.; if option =="""" only Tree object in memory is deleted. void DirectoryAutoAdd(TDirectory* ); Called by TKey and TObject::Clone to automatically add us to a directory; when we are read from a file. Long64_t Draw(const char* varexp, const TC",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:65788,Testability,test,test,65788," rebuilt. TTree* CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Copy a tree with selection. IMPORTANT:. The returned copied tree stays connected with the original tree; until the original tree is deleted. In particular, any changes; to the branch addresses in the original tree are also made to; the copied tree. Any changes made to the branch addresses of the; copied tree are overridden anytime the original tree changes its; branch addresses. When the original tree is deleted, all the; branch addresses of the copied tree are set to zero. For examples of CopyTree, see the tutorials:. copytree. Example macro to copy a subset of a tree to a new tree. The input file was generated by running the program in; $ROOTSYS/test/Event in this way:. ./Event 1000 1 1 1. copytree2. Example macro to copy a subset of a tree to a new tree. One branch of the new tree is written to a separate file. The input file was generated by running the program in; $ROOTSYS/test/Event in this way:. ./Event 1000 1 1 1. copytree3. Example macro to copy a subset of a tree to a new tree. Only selected entries are copied to the new tree.; NOTE that only the active branches are copied. TBasket* CreateBasket(TBranch* ); Create a basket for this tree and given branch. void Delete(Option_t* option = """"); Delete this tree from memory or/and disk. if option == ""all"" delete Tree object from memory AND from disk; all baskets on disk are deleted. All keys with same name; are deleted.; if option =="""" only Tree object in memory is deleted. void DirectoryAutoAdd(TDirectory* ); Called by TKey and TObject::Clone to automatically add us to a directory; when we are read from a file. Long64_t Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Draw expression varexp for specified entries.; Returns -1 in case of error or number of selected events in case of success. This function a",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:70031,Testability,log,log,70031,"; In a selection all the C++ operators are authorized.; The value corresponding to the selection expression is used as a weight; to fill the histogram.; If the expression includes only boolean operations, the result; is 0 or 1. If the result is 0, the histogram is not filled.; In general, the expression may be of the form:; value*(boolean expression); if boolean expression is true, the histogram is filled with; a weight = value.; Examples:; selection1 = ""x<y && sqrt(z)>3.2""; selection2 = ""(x+y)*(sqrt(z)>3.2)""; selection1 returns a weight = 0 or 1; selection2 returns a weight = x+y if sqrt(z)>3.2; returns a weight = 0 otherwise. option is the drawing option.; - See TH1::Draw for the list of all drawing options.; - If option COL is specified when varexp has three fields:; tree.Draw(""e1:e2:e3"","""",""col"");; a 2D scatter is produced with e1 vs e2, and e3 is mapped on the color; table. The colors for e3 are evaluated once in linear scale before; painting. Therefore changing the pad to log scale along Z as no effect; on the colors.; - If option contains the string ""goff"", no graphics is generated. nentries is the number of entries to process (default is all); first is the first entry to process (default is 0). This function returns the number of selected entries. It returns -1; if an error occurs. Drawing expressions using arrays and array elements. Let assumes, a leaf fMatrix, on the branch fEvent, which is a 3 by 3 array,; or a TClonesArray.; In a TTree::Draw expression you can now access fMatrix using the following; syntaxes:. String passed What is used for each entry of the tree. ""fMatrix"" the 9 elements of fMatrix; ""fMatrix[][]"" the 9 elements of fMatrix; ""fMatrix[2][2]"" only the elements fMatrix[2][2]; ""fMatrix[1]"" the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2]; ""fMatrix[1][]"" the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2]; ""fMatrix[][0]"" the 3 elements fMatrix[0][0], fMatrix[1][0] and fMatrix[2][0]. ""fEvent.fMatrix...."" same as ""fMatrix..",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:96233,Testability,test,test,96233,"have a Tree with several hundred branches, and you; are interested only by branches named ""a"" and ""b"", do; mytree.SetBranchStatus(""*"",0); //disable all branches; mytree.SetBranchStatus(""a"",1);; mytree.SetBranchStatus(""b"",1);; when calling mytree.GetEntry(i); only branches ""a"" and ""b"" will be read. WARNING!!; If your Tree has been created in split mode with a parent branch ""parent."",; mytree.SetBranchStatus(""parent"",1);; will not activate the sub-branches of ""parent"". You should do:; mytree.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative is to call directly; brancha.GetEntry(i); branchb.GetEntry(i);. IMPORTANT NOTE. By default, GetEntry reuses the space allocated by the previous object; for each branch. You can force the previous object to be automatically; deleted if you call mybranch.SetAutoDelete(kTRUE) (default is kFALSE).; Example:; Consider the example in $ROOTSYS/test/Event.h; The top level branch in the tree T is declared with:; Event *event = 0; //event must be null or point to a valid object; //it must be initialized; T.SetBranchAddress(""event"",&event);; When reading the Tree, one can choose one of these 3 options:. OPTION 1. for (Long64_t i=0;i<nentries;i++) {; T.GetEntry(i);; // the object event has been filled at this point; }; The default (recommended). At the first entry an object of the class; Event will be created and pointed by event. At the following entries,; event will be overwritten by the new data. All internal members that are; TObject* are automatically deleted. It is important that these members; be in a valid state when GetEntry is called. Pointers must be correctly; initialized. However these internal members will not be deleted if the; characters ""->"" are specified as the first characters in the comment; field of the data member declaration. If ""->"" is specified, the pointer member is read via pointer->Str",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:1511,Usability,simpl,simple,1511," Branch buffers may be; automatically written to disk or kept in memory until the Tree attribute; fMaxVirtualSize is reached. Variables of one branch are written to the; same buffer. A branch buffer is automatically compressed if the file; compression attribute is set (default). Branches may be written to different files (see TBranch::SetFile). The ROOT user can decide to make one single branch and serialize one; object into one single I/O buffer or to make several branches.; Making one single branch and one single buffer can be the right choice; when one wants to process only a subset of all entries in the tree.; (you know for example the list of entry numbers you want to process).; Making several branches is particularly interesting in the data analysis; phase, when one wants to histogram some attributes of an object (entry); without reading all the attributes. ==> TTree *tree = new TTree(name, title); Creates a Tree with name and title. Various kinds of branches can be added to a tree:; A - simple structures or list of variables. (may be for C or Fortran structures); B - any object (inheriting from TObject). (we expect this option be the most frequent); C - a ClonesArray. (a specialized object for collections of same class objects). ==> Case A. TBranch *branch = tree->Branch(branchname, address, leaflist, bufsize); * address is the address of the first item of a structure; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a; slash (/). The variable type must be 1 character. (Characters; after the first are legal and will be appended to the visible; name of the leaf, but have no effect.) If no type is given, the; type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is; assumed of type F by default. The list of currently supported; types is given below:; - C : a character string terminated b",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:7364,Usability,simpl,simple,7364,"ate one subbranch for each data member of; the object TTrack. ==> Case E. TBranch *branch = tree->Branch( branchname, STLcollection, buffsize, splitlevel);; STLcollection is the address of a pointer to std::vector, std::list,; std::deque, std::set or std::multiset containing pointers to objects.; If the splitlevel is a value bigger than 100 (TTree::kSplitCollectionOfPointers); then the collection will be written in split mode, e.g. if it contains objects of; any types deriving from TTrack this function will sort the objects; based on their type and store them in separate branches in split; mode. ==> branch->SetAddress(Void *address); In case of dynamic structures changing with each entry for example, one must; redefine the branch address before filling the branch again.; This is done via the TBranch::SetAddress member function. ==> tree->Fill(); loops on all defined branches and for each branch invokes the Fill function. See also the class TNtuple (a simple Tree with branches of floats); and the class TNtupleD (a simple Tree with branches of doubles). Adding a Branch to an Existing Tree. You may want to add a branch to an existing tree. For example,; if one variable in the tree was computed with a certain algorithm,; you may want to try another algorithm and compare the results.; One solution is to add a new branch, fill it, and save the tree.; The code below adds a simple branch to an existing tree.; Note the kOverwrite option in the Write method, it overwrites the; existing tree. If it is not specified, two copies of the tree headers; are saved. void tree3AddBranch(){; TFile f(""tree3.root"", ""update"");. Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. //read the number of entries in the t3; Long64_t nentries = t3->GetEntries();. for (Long64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; A",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:7428,Usability,simpl,simple,7428,"ate one subbranch for each data member of; the object TTrack. ==> Case E. TBranch *branch = tree->Branch( branchname, STLcollection, buffsize, splitlevel);; STLcollection is the address of a pointer to std::vector, std::list,; std::deque, std::set or std::multiset containing pointers to objects.; If the splitlevel is a value bigger than 100 (TTree::kSplitCollectionOfPointers); then the collection will be written in split mode, e.g. if it contains objects of; any types deriving from TTrack this function will sort the objects; based on their type and store them in separate branches in split; mode. ==> branch->SetAddress(Void *address); In case of dynamic structures changing with each entry for example, one must; redefine the branch address before filling the branch again.; This is done via the TBranch::SetAddress member function. ==> tree->Fill(); loops on all defined branches and for each branch invokes the Fill function. See also the class TNtuple (a simple Tree with branches of floats); and the class TNtupleD (a simple Tree with branches of doubles). Adding a Branch to an Existing Tree. You may want to add a branch to an existing tree. For example,; if one variable in the tree was computed with a certain algorithm,; you may want to try another algorithm and compare the results.; One solution is to add a new branch, fill it, and save the tree.; The code below adds a simple branch to an existing tree.; Note the kOverwrite option in the Write method, it overwrites the; existing tree. If it is not specified, two copies of the tree headers; are saved. void tree3AddBranch(){; TFile f(""tree3.root"", ""update"");. Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. //read the number of entries in the t3; Long64_t nentries = t3->GetEntries();. for (Long64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; A",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:7788,Usability,simpl,simple,7788,"ction will be written in split mode, e.g. if it contains objects of; any types deriving from TTrack this function will sort the objects; based on their type and store them in separate branches in split; mode. ==> branch->SetAddress(Void *address); In case of dynamic structures changing with each entry for example, one must; redefine the branch address before filling the branch again.; This is done via the TBranch::SetAddress member function. ==> tree->Fill(); loops on all defined branches and for each branch invokes the Fill function. See also the class TNtuple (a simple Tree with branches of floats); and the class TNtupleD (a simple Tree with branches of doubles). Adding a Branch to an Existing Tree. You may want to add a branch to an existing tree. For example,; if one variable in the tree was computed with a certain algorithm,; you may want to try another algorithm and compare the results.; One solution is to add a new branch, fill it, and save the tree.; The code below adds a simple branch to an existing tree.; Note the kOverwrite option in the Write method, it overwrites the; existing tree. If it is not specified, two copies of the tree headers; are saved. void tree3AddBranch(){; TFile f(""tree3.root"", ""update"");. Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. //read the number of entries in the t3; Long64_t nentries = t3->GetEntries();. for (Long64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk losing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:9182,Usability,simpl,simple,9182,"ong64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk losing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt to write the tree fails, and the; original data is erased.; In addition, adding a branch to a tree enlarges the tree and increases; the amount of memory needed to read an entry, and therefore decreases; the performance. For these reasons, ROOT offers the concept of friends for trees (and chains).; We encourage you to use TTree::AddFriend rather than adding a branch manually. /*. */. A simple example with histograms and a tree*-*-*-; *-* ===========================================. This program creates :; - a one dimensional histogram; - a two dimensional histogram; - a profile histogram; - a tree. These objects are filled with some random numbers and saved on a file. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. #include ""TFile.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TProfile.h""; #include ""TRandom.h""; #include ""TTree.h"". //______________________________________________________________________________; main(int argc, char **argv); {; // Create a new ROOT binary machine independent file.; // Note that this file may contain any kind of ROOT objects, histograms,trees; // pictures, graphics objects, detector geometries, tracks, events, etc..; // This file is now becoming the current directory.; TFile hfile(""htree.root"",""RECREATE"",""Demo ROOT file with histograms & trees"");. // Create some histograms and a profile histogram; TH1F *hpx = new TH1F(""hpx"",""This is the px distribution"",10",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:10397,Usability,simpl,simple,10397,"-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. #include ""TFile.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TProfile.h""; #include ""TRandom.h""; #include ""TTree.h"". //______________________________________________________________________________; main(int argc, char **argv); {; // Create a new ROOT binary machine independent file.; // Note that this file may contain any kind of ROOT objects, histograms,trees; // pictures, graphics objects, detector geometries, tracks, events, etc..; // This file is now becoming the current directory.; TFile hfile(""htree.root"",""RECREATE"",""Demo ROOT file with histograms & trees"");. // Create some histograms and a profile histogram; TH1F *hpx = new TH1F(""hpx"",""This is the px distribution"",100,-4,4);; TH2F *hpxpy = new TH2F(""hpxpy"",""py ps px"",40,-4,4,40,-4,4);; TProfile *hprof = new TProfile(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);. // Define some simple structures; typedef struct {Float_t x,y,z;} POINT;; typedef struct {; Int_t ntrack,nseg,nvertex;; UInt_t flag;; Float_t temperature;; } EVENTN;; static POINT point;; static EVENTN eventn;. // Create a ROOT Tree; TTree *tree = new TTree(""T"",""An example of ROOT tree with a few branches"");; tree->Branch(""point"",&point,""x:y:z"");; tree->Branch(""eventn"",&eventn,""ntrack/I:nseg:nvertex:flag/i:temperature/F"");; tree->Branch(""hpx"",""TH1F"",&hpx,128000,0);. Float_t px,py,pz;; static Float_t p[3];. //--------------------Here we start a loop on 1000 events; for ( Int_t i=0; i<1000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->::Rndm(1);. // Fill histograms; hpx->Fill(px);; hpxpy->Fill(px,py,1);; hprof->Fill(px,pz,1);. // Fill structures; p[0] = px;; p[1] = py;; p[2] = pz;; point.x = 10*(random-1);;; point.y = 5*random;; point.z = 20*random;; eventn.ntrack = Int_t(100*random);; eventn.nseg = Int_t(2*eventn.ntrack);; eventn.nvertex = 1;; eventn.flag = Int_t(random+0.5);; eventn.temperature = 20+random;. // Fill the tree. For each event, save the 2 s",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:11523,Usability,simpl,simple,11523,"} EVENTN;; static POINT point;; static EVENTN eventn;. // Create a ROOT Tree; TTree *tree = new TTree(""T"",""An example of ROOT tree with a few branches"");; tree->Branch(""point"",&point,""x:y:z"");; tree->Branch(""eventn"",&eventn,""ntrack/I:nseg:nvertex:flag/i:temperature/F"");; tree->Branch(""hpx"",""TH1F"",&hpx,128000,0);. Float_t px,py,pz;; static Float_t p[3];. //--------------------Here we start a loop on 1000 events; for ( Int_t i=0; i<1000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->::Rndm(1);. // Fill histograms; hpx->Fill(px);; hpxpy->Fill(px,py,1);; hprof->Fill(px,pz,1);. // Fill structures; p[0] = px;; p[1] = py;; p[2] = pz;; point.x = 10*(random-1);;; point.y = 5*random;; point.z = 20*random;; eventn.ntrack = Int_t(100*random);; eventn.nseg = Int_t(2*eventn.ntrack);; eventn.nvertex = 1;; eventn.flag = Int_t(random+0.5);; eventn.temperature = 20+random;. // Fill the tree. For each event, save the 2 structures and 3 objects; // In this simple example, the objects hpx, hprof and hpxpy are slightly; // different from event to event. We expect a big compression factor!; tree->Fill();; }; //--------------End of the loop. tree->Print();. // Save all objects in this file; hfile.Write();. // Close the file. Note that this is automatically done when you leave; // the application.; hfile.Close();. return 0;; }. Function Members (Methods); public:. TTree(); TTree(const char* name, const char* title, Int_t splitlevel = 99); virtual~TTree(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); virtual voidAddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual TFriendElement*AddFriend(const char* treename, const char* filename = """"); virtual TFriendElement*AddFriend(const char* treename, TFile* file); virtual TFriendElement*AddFriend(TTree* tree, const char* alias = """", Bool_t warn = kFALSE); virtual voidAddTotBytes(Int_t tot); virtual voidAddZipByte",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:14443,Usability,undo,undo,14443,"t char* classname, void** obj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual TBranch*BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*BranchRef(); virtual TBranch*Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidBrowse(TBrowser*); virtual Int_tBuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual TFile*ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidCopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tCopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*CreateBasket(TBranch*); Int_tDebug() const; virtual voidDelete(Option_t* option = """")MENU ; virtual voidDirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tDraw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:46658,Usability,simpl,simply,46658,"ill be created for each element of this collection. In case a collection element is a TClonesArray, the special Tree constructor; for TClonesArray is called.; The collection itself cannot be a TClonesArray. The function returns the total number of branches created. If name is given, all branch names will be prefixed with name_. IMPORTANT NOTE1: This function should not be called with splitlevel < 1. IMPORTANT NOTE2: The branches created by this function will have names; corresponding to the collection or object names. It is important; to give names to collections to avoid misleading branch names or; identical branch names. By default collections have a name equal to; the corresponding class name, e.g. the default name for a TList is ""TList"". And in general in any cases two or more master branches contain subbranches; with identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. Example--------------------------------------------------------------:. {; TTree T(""T"",""test list"");; TList *list = new TList();. TObjArray *a1 = new TObjArray();; a1->SetName(""a1"");; list->Add(a1);; TH1F *ha1a = new TH1F(""ha1a"",""ha1"",100,0,1);; TH1F *ha1b = new TH1F(""ha1b"",""ha1"",100,0,1);; a1->Add(ha1a);; a1->Add(ha1b);; TObjArray *b1 = new TObjArray();; b1->SetName(""b1"");; list->Add(b1);; TH1F *hb1a = new TH1F(""hb1a"",""hb1"",100,0,1);; TH1F *hb1b = new TH1F(""hb1b"",""hb1"",100,0,1);; b1->Add(hb1a);; b1->Add(hb1b);. TObjArray *a2 = n",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:48286,Usability,simpl,simple,48286,"();; a1->SetName(""a1"");; list->Add(a1);; TH1F *ha1a = new TH1F(""ha1a"",""ha1"",100,0,1);; TH1F *ha1b = new TH1F(""ha1b"",""ha1"",100,0,1);; a1->Add(ha1a);; a1->Add(ha1b);; TObjArray *b1 = new TObjArray();; b1->SetName(""b1"");; list->Add(b1);; TH1F *hb1a = new TH1F(""hb1a"",""hb1"",100,0,1);; TH1F *hb1b = new TH1F(""hb1b"",""hb1"",100,0,1);; b1->Add(hb1a);; b1->Add(hb1b);. TObjArray *a2 = new TObjArray();; a2->SetName(""a2"");; list->Add(a2);; TH1S *ha2a = new TH1S(""ha2a"",""ha2"",100,0,1);; TH1S *ha2b = new TH1S(""ha2b"",""ha2"",100,0,1);; a2->Add(ha2a);; a2->Add(ha2b);. T.Branch(list,16000,2);; T.Print();; }. Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); Create one branch for each element in the folder.; Returns the total number of branches created. TBranch* Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); Create a new TTree Branch. This Branch constructor is provided to support non-objects in; a Tree. The variables described in leaflist may be simple; variables or structures. // See the two following; constructors for writing objects in a Tree. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. * address is the address of the first item of a structure.; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a slash (/).; The variable type may be 0,1 or 2 characters. If no type is given,; the type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is assumed; of type F by default. The list of currently supported types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:52768,Usability,simpl,simply,52768,"dobj, Int_t bufsize = 32000, Int_t splitlevel = 1); Create a new TTree BranchObject. Build a TBranchObject for an object of class classname.; addobj is the address of a pointer to an object of class classname.; IMPORTANT: classname must derive from TObject.; The class dictionary must be available (ClassDef in class header). This option requires access to the library where the corresponding class; is defined. Accessing one single data member in the object implies; reading the full object.; See the next Branch constructor for a more efficient storage; in case the entry consists of arrays of identical objects. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. TBranch* BranchRef(); Build the optional branch supporting the TRefTable.; This branch will keep all the information to find the branches; containing referenced objects. At each T",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:55846,Usability,simpl,simply,55846,"iour in split or non-split mode. classname does; not have to derive from TObject. The function is based on; the new TStreamerInfo. Build a TBranchElement for an object of class classname. addr is the address of a pointer to an object of class; classname. The class dictionary must be available (ClassDef; in class header). Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the addr parameter. This option requires access to the library where the; corresponding class is defined. Accessing one single data; member in the object implies reading the full object. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. Use splitlevel < 0 instead of splitlevel=0 when the class; has a custom Streamer. Note: if the split level is set to the default (99), TTree::Branch will; not issue a warning if t",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:63103,Usability,undo,undo,63103," number (1->5) of branches, since all; their baskets will be clustered together instead of being spread; across the file. However it might decrease the performance when; reading more branches (or the full entry). When using SortBasketsByEntry the baskets with the lowest starting; entry are written first. (i.e. the baskets are sorted by the; index/number of the first entry they contain). This means that on; the file the baskets will be in the order in which they will be; needed when reading the whole tree sequentially. For examples of CloneTree, see tutorials:. -- copytree. A macro to copy a subset of a TTree to a new TTree. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. -- copytree2. A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. void CopyAddresses(TTree* , Bool_t undo = kFALSE); Set branch addresses of passed tree equal to ours.; If undo is true, reset the branch address instead of copying them.; This insures 'separation' of a cloned tree from its original. Long64_t CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); Copy nentries from given tree to this tree.; This routines assumes that the branches that intended to be copied are; already connected. The typical case is that this tree was created using; tree->CloneTree(0). By default copy all entries. Returns number of bytes copied to this tree. If 'option' contains the word 'fast' and nentries is -1, the cloning will be; done without unzipping or unstreaming the baskets (i.e., a direct copy of the; raw bytes on disk). When 'fast' is specified, 'option' can also contains a sorting order for the; baskets in the output file. There are currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. See TTree::CloneTree for a detailed explanat",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:63174,Usability,undo,undo,63174,"ad of being spread; across the file. However it might decrease the performance when; reading more branches (or the full entry). When using SortBasketsByEntry the baskets with the lowest starting; entry are written first. (i.e. the baskets are sorted by the; index/number of the first entry they contain). This means that on; the file the baskets will be in the order in which they will be; needed when reading the whole tree sequentially. For examples of CloneTree, see tutorials:. -- copytree. A macro to copy a subset of a TTree to a new TTree. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. -- copytree2. A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in; $ROOTSYS/test/Event with: Event 1000 1 1 1. void CopyAddresses(TTree* , Bool_t undo = kFALSE); Set branch addresses of passed tree equal to ours.; If undo is true, reset the branch address instead of copying them.; This insures 'separation' of a cloned tree from its original. Long64_t CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); Copy nentries from given tree to this tree.; This routines assumes that the branches that intended to be copied are; already connected. The typical case is that this tree was created using; tree->CloneTree(0). By default copy all entries. Returns number of bytes copied to this tree. If 'option' contains the word 'fast' and nentries is -1, the cloning will be; done without unzipping or unstreaming the baskets (i.e., a direct copy of the; raw bytes on disk). When 'fast' is specified, 'option' can also contains a sorting order for the; baskets in the output file. There are currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. See TTree::CloneTree for a detailed explanation of the semantics of these 3 options. If the tree or any of the underlying tree of",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:67774,Usability,simpl,simplest,67774,"uple.Draw(""x"",cut1+cut2+cut3);. Long64_t Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Draw expression varexp for specified entries.; Returns -1 in case of error or number of selected events in case of success. varexp is an expression of the general form; - ""e1"" produces a 1-d histogram (TH1F) of expression ""e1""; - ""e1:e2"" produces an unbinned 2-d scatter-plot (TGraph) of ""e1""; on the y-axis versus ""e2"" on the x-axis; - ""e1:e2:e3"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1""; versus ""e2"" versus ""e3"" on the x-, y-, z-axis, respectively.; - ""e1:e2:e3:e4"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1""; versus ""e2"" versus ""e3"" and ""e4"" mapped on the color number.; (to create histograms in the 2, 3, and 4 dimensional case, see section ""Saving; the result of Draw to an histogram""). Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim distribution of y versus sqrt(x); = px:py:pz:2.5*E produces a 3-d scatter-plot of px vs py ps pz; and the color number of each marker will be 2.5*E.; If the color number is negative it is set to 0.; If the color number is greater than the current number of colors; it is set to the highest color number.; The default number of colors is 50.; see TStyle::SetPalette for setting a new color palette. Note that the variables e1, e2 or e3 may contain a selection.; example, if e1= x*(y<0), the value histogrammed will be x if y<0; and will be 0 otherwise. The expressions can use all the operations and build-in functions; supported by TFormula (See TFormula::Analyze), including free; standing function taking numerical arguments (TMath::Bessel).; In addition, you can call member functions taking numerical; arguments. For example:; - ""TMath::BreitWigner(fPx,3,2)""; - ""event.GetHistogram().GetXaxis().GetXmax()""; Note: You can only pass expression th",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:89926,Usability,simpl,simple,89926,"imate(tree->GetEntries()+1); // same as tree->SetEstimate(-1);; You must call SetEstimate if the expected number of selected rows; you need to look at is greater than 1000000. You can use the option ""goff"" to turn off the graphics output; of TTree::Draw in the above example. Automatic interface to TTree::Draw via the TTreeViewer. A complete graphical interface to this function is implemented; in the class TTreeViewer.; To start the TTreeViewer, three possibilities:; - select TTree context menu item ""StartViewer""; - type the command ""TTreeViewer TV(treeName)""; - execute statement ""tree->StartViewer();"". void DropBaskets(); Remove some baskets from memory. void DropBuffers(Int_t nbytes); Drop branch buffers to accommodate nbytes below MaxVirtualsize. Int_t Fill(); Fill all branches. This function loops on all the branches of this tree. For; each branch, it copies to the branch buffer (basket) the current; values of the leaves data types. If a leaf is a simple data type,; a simple conversion to a machine independent format has to be done. This machine independent version of the data is copied into a; basket (each branch has its own basket). When a basket is full; (32k worth of data by default), it is then optionally compressed; and written to disk (this operation is also called committing or; 'flushing' the basket). The committed baskets are then; immediately removed from memory. The function returns the number of bytes committed to the; individual branches. If a write error occurs, the number of bytes returned is -1. If no data are written, because, e.g., the branch is disabled,; the number of bytes returned is 0. The baskets are flushed and the Tree header saved at regular intervals. At regular intervals, when the amount of data written so far is; greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; This makes future reading faster as it guarantees that baskets belonging to nearby; entries will be on the same disk region.; When the first c",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:89947,Usability,simpl,simple,89947,"imate(tree->GetEntries()+1); // same as tree->SetEstimate(-1);; You must call SetEstimate if the expected number of selected rows; you need to look at is greater than 1000000. You can use the option ""goff"" to turn off the graphics output; of TTree::Draw in the above example. Automatic interface to TTree::Draw via the TTreeViewer. A complete graphical interface to this function is implemented; in the class TTreeViewer.; To start the TTreeViewer, three possibilities:; - select TTree context menu item ""StartViewer""; - type the command ""TTreeViewer TV(treeName)""; - execute statement ""tree->StartViewer();"". void DropBaskets(); Remove some baskets from memory. void DropBuffers(Int_t nbytes); Drop branch buffers to accommodate nbytes below MaxVirtualsize. Int_t Fill(); Fill all branches. This function loops on all the branches of this tree. For; each branch, it copies to the branch buffer (basket) the current; values of the leaves data types. If a leaf is a simple data type,; a simple conversion to a machine independent format has to be done. This machine independent version of the data is copied into a; basket (each branch has its own basket). When a basket is full; (32k worth of data by default), it is then optionally compressed; and written to disk (this operation is also called committing or; 'flushing' the basket). The committed baskets are then; immediately removed from memory. The function returns the number of bytes committed to the; individual branches. If a write error occurs, the number of bytes returned is -1. If no data are written, because, e.g., the branch is disabled,; the number of bytes returned is 0. The baskets are flushed and the Tree header saved at regular intervals. At regular intervals, when the amount of data written so far is; greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; This makes future reading faster as it guarantees that baskets belonging to nearby; entries will be on the same disk region.; When the first c",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:120980,Usability,simpl,simply,120980,"te(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If the Tree (Chain) has an associated EventList, the loop is on the nentries; of the EventList, starting at firstentry, otherwise the loop is on the; specified Tree entries. Long64_t Project(const char* hname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Make a projection of a tree using selections. Depending on the value of varexp (described in Draw) a 1-D, 2-D, etc.,; projection of the tree will be filled in histogram hname.; Note that the dimension of hname must match with the dimension of varexp. TSQLResult* Query(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Loop over entries and return a TSQLResult object containing entries following selection. Long64_t ReadFile(const char* filename, const char* branchDescriptor = """", char delimiter = ' '); Create or simply read branches from filename. if branchDescriptor = """" (default), it is assumed that the Tree descriptor; is given in the first line of the file with a syntax like; A/D:Table[2]/F:Ntracks/I:astring/C; otherwise branchDescriptor must be specified with the above syntax.; -If the type of the first variable is not specified, it is assumed to be ""/F""; -if the type of any other variable is not specified, the type of the previous; variable is assumed. eg; x:y:z (all variables are assumed of type ""F""; x/D:y:z (all variables are of type ""D""; x:y/D:z (x is type ""F"", y and z of type ""D"". delimiter allows for the use of another delimiter besides whitespace.; This provides support for direct import of common data file formats; like csv. If delimiter != ' ' and branchDescriptor == """", then the; branch description is taken from the first line in the file, but; delimiter is used for the branch names tokenization rather than ':'.; Note however that if the valu",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:122970,Usability,simpl,simply,122970,"the values in the first line do not use the; /[type] syntax, all variables are assumed to be of type ""F"".; If the filename ends with extensions .csv or .CSV and a delimiter is; not specified (besides ' '), the delimiter is automatically set to ','. Lines in the input file starting with ""#"" are ignored. Leading whitespace; for each column data is skipped. Empty lines are skipped. A TBranch object is created for each variable in the expression.; The total number of rows read from the file is returned. FILLING a TTree WITH MULTIPLE INPUT TEXT FILES. To fill a TTree with multiple input text files, proceed as indicated above; for the first input file and omit the second argument for subsequent calls; T.ReadFile(""file1.dat"",""branch descriptor"");; T.ReadFile(""file2.dat"");. char GetNewlineValue(istream& inputStream); Determine which newline this file is using.; Return '\r' for Windows '\r\n' as that already terminates. Long64_t ReadStream(istream& inputStream, const char* branchDescriptor = """", char delimiter = ' '); Create or simply read branches from an input stream. See reference information for TTree::ReadFile. void RecursiveRemove(TObject* obj); Make sure that obj (which is being deleted or will soon be) is no; longer referenced by this TTree. void Refresh(); Refresh contents of this tree and its branches from the current status on disk. One can call this function in case the tree file is being; updated by another process. void RemoveFriend(TTree* ); Remove a friend from the list of friends. void Reset(Option_t* option = """"); Reset baskets, buffers and entries count in all branches and leaves. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this TTree after a merge (keep the customization but; forget the data). void ResetBranchAddress(TBranch* ); Tell all of our branches to set their addresses to zero. Note: If any of our branches own any objects, they are deleted. void ResetBranchAddresses(); Tell all of our branches to drop their current objects and alloca",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:132456,Usability,learn,learning,132456,"known branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. void SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes). void SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if needed. If autocache is true:; this will be an automatically create cache, possibly replacing an; existing autocreated cache with a larger one. The size is calculated,; cacheSize is unused. If autocache is false:; cacheSize is used to size the cache. This cache should never be; automatically adjusted. void SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE 4:; A circular Tree can still be saved in a file. When read back,; it is still a circular Tree and can be filled again. void SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999); Set the debug level and the debug range. For entries in t",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTree.html:137656,Usability,learn,learning,137656,"ex();; tree.SetTreeIndex(newIndex);; tree.Draw();; tree.SetTreeIndex(oldIndex);; tree.Draw(); etc. void SetWeight(Double_t w = 1, Option_t* option = """"); Set tree weight. The weight is used by TTree::Draw to automatically weight each; selected entry in the resulting histogram. For example the equivalent of:. T.Draw(""x"", ""w""). is:. T.SetWeight(w);; T.Draw(""x"");. This function is redefined by TChain::SetWeight. In case of a; TChain, an option ""global"" may be specified to set the same weight; for all trees in the TChain instead of the default behaviour; using the weights of each tree in the chain (see TChain::SetWeight). void Show(Long64_t entry = -1, Int_t lenmax = 20); Print values of all active leaves for entry. if entry==-1, print current entry (default); if a leaf is an array, a maximum of lenmax elements is printed. void StartViewer(); Start the TTreeViewer on this tree. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. void StopCacheLearningPhase(); stop the cache learning phase. void Streamer(TBuffer& ); Stream a class object. Int_t UnbinnedFit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Unbinned fit of one or more variable(s) from a tree. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if you fit a function with 6 parame",MatchSource.WIKI,root/html534/TTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTree.html
https://root.cern/root/html534/TTreeCache.html:10750,Availability,error,error,10750,"ic TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDisable(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDropBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual voidDropBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTObject::Dump() constMENU ; virtual voidEnable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Bool_tFillBuffer(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTFileCacheRead::GetBufferSize() const; virtual Long64_tTFileCacheRead::GetBytesRead() const; virtual Long64_tTFileCacheRead::GetBytesReadExtra() const; const TObjArray*GetCachedBranches() const; TTreeCache::EPrefillTypeGetConfiguredPrefillType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetEfficiency() const; Double_tGetEfficiencyRel() const; virtual Int_tGetEntryMax() const; virtual Int_tGetEntryMin() const; TFile*TFileCacheRead::GetFile() const; virtual const char*TObject::GetIconName() const; static Int_tGetLearnEntries(); virtual T",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:10834,Availability,error,error,10834,"t::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDisable(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDropBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual voidDropBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTObject::Dump() constMENU ; virtual voidEnable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Bool_tFillBuffer(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTFileCacheRead::GetBufferSize() const; virtual Long64_tTFileCacheRead::GetBytesRead() const; virtual Long64_tTFileCacheRead::GetBytesReadExtra() const; const TObjArray*GetCachedBranches() const; TTreeCache::EPrefillTypeGetConfiguredPrefillType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetEfficiency() const; Double_tGetEfficiencyRel() const; virtual Int_tGetEntryMax() const; virtual Int_tGetEntryMin() const; TFile*TFileCacheRead::GetFile() const; virtual const char*TObject::GetIconName() const; static Int_tGetLearnEntries(); virtual TTreeCache::EPrefillTypeGetLearnPrefill() const; virtual const char*TObject::GetName(",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:24635,Availability,failure,failure,24635,"Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default pref",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:3995,Deployability,configurat,configurations,3995," take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches t",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:4443,Integrability,interface,interface,4443," the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+""",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:3910,Modifiability,variab,variable,3910," with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Proces",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:3995,Modifiability,config,configurations,3995," take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches t",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:4171,Modifiability,layers,layers,4171,"fer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache ",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:25735,Modifiability,variab,variable,25735,"ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). void Disable(); {fEnabled = kFALSE;}. void Enable(); {fEnabled = kTRUE;}. const TObjArray * GetCachedBranches() const; { return fBranches; }. EPrefillType ",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:385,Performance,cache,cache,385,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default ",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:645,Performance,cache,cache,645,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default ",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:678,Performance,perform,performance,678,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default ",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:752,Performance,latency,latency,752,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default ",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:781,Performance,cache,cache,781,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default ",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:925,Performance,cache,cache,925,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default ",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:1188,Performance,cache,cache,1188,"class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analy",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:1354,Performance,cache,cache,1354,"ead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KByt",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:1446,Performance,cache,cache,1446,"rom the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:2062,Performance,cache,cached,2062,"leted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers f",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:2504,Performance,perform,performance,2504,"eCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maxi",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:2748,Performance,perform,performance,2748,"ent. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:2828,Performance,latency,latency,2828,"ent. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:2877,Performance,latency,latency,2877,"ange is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:2934,Performance,cache,cache,2934,"ange is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:3609,Performance,cache,cache,3609,"ys written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the ex",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:3748,Performance,cache,cache,3748,"g; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers for the selected branches; such that instead of transfering 1000 buffers of 10 Kbytes, it will be able; to transfer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branche",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:4488,Performance,cache,cache,4488," the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+""",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:4853,Performance,cache,cache,4853,"ee is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to proc",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:4964,Performance,cache,cache,4964,"configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take ",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:5008,Performance,cache,cache,5008,"configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take ",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:5186,Performance,cache,cache,5186,"ions the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",ne",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:5322,Performance,cache,cachesize,5322,"nches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",nentries,efirst);; // in the TSelector::Process we read only 2 branches; TBranch *b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; TBranch *b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ...",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:5373,Performance,cache,cachesize,5373,"nches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",nentries,efirst);; // in the TSelector::Process we read only 2 branches; TBranch *b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; TBranch *b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ...",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:5454,Performance,cache,cache,5454,"nches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",nentries,efirst);; // in the TSelector::Process we read only 2 branches; TBranch *b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; TBranch *b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ...",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:5737,Performance,cache,cache,5737,"lly. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",nentries,efirst);; // in the TSelector::Process we read only 2 branches; TBranch *b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; TBranch *b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... here you process your entry; --. 3- with your own event loop. --example 3a; in your analysis loop, you always use 2 branches. You want to prefetch; the branch buffers for these 2 branches only.; --; TTree *T = (TTree*)f->Get(""mytree"");; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(b1,kTRUE); //<<<add branch1 and branch2 to the cache; T->AddBranchToCache(b2,kTRUE); //<<<; T->",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:5911,Performance,cache,cachesize,5911,"lly. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",nentries,efirst);; // in the TSelector::Process we read only 2 branches; TBranch *b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; TBranch *b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... here you process your entry; --. 3- with your own event loop. --example 3a; in your analysis loop, you always use 2 branches. You want to prefetch; the branch buffers for these 2 branches only.; --; TTree *T = (TTree*)f->Get(""mytree"");; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(b1,kTRUE); //<<<add branch1 and branch2 to the cache; T->AddBranchToCache(b2,kTRUE); //<<<; T->",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:6040,Performance,cache,cachesize,6040,"lly. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",nentries,efirst);; // in the TSelector::Process we read only 2 branches; TBranch *b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; TBranch *b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... here you process your entry; --. 3- with your own event loop. --example 3a; in your analysis loop, you always use 2 branches. You want to prefetch; the branch buffers for these 2 branches only.; --; TTree *T = (TTree*)f->Get(""mytree"");; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(b1,kTRUE); //<<<add branch1 and branch2 to the cache; T->AddBranchToCache(b2,kTRUE); //<<<; T->",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:6715,Performance,cache,cachesize,6715,"last = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",nentries,efirst);; // in the TSelector::Process we read only 2 branches; TBranch *b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; TBranch *b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... here you process your entry; --. 3- with your own event loop. --example 3a; in your analysis loop, you always use 2 branches. You want to prefetch; the branch buffers for these 2 branches only.; --; TTree *T = (TTree*)f->Get(""mytree"");; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(b1,kTRUE); //<<<add branch1 and branch2 to the cache; T->AddBranchToCache(b2,kTRUE); //<<<; T->StopCacheLearningPhase(); //<<<; for (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i); //<<< important call when calling TBranch::GetEntry after; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --; --example 3b; in your analysis loop, you always use 2 branches in the main loop.; you also call some analysis functions where a few more branches will be read.; but you do not know a priori which ones. There is no point in prefetching; branches that will be used very rarely.; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:6766,Performance,cache,cachesize,6766,"last = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",nentries,efirst);; // in the TSelector::Process we read only 2 branches; TBranch *b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; TBranch *b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... here you process your entry; --. 3- with your own event loop. --example 3a; in your analysis loop, you always use 2 branches. You want to prefetch; the branch buffers for these 2 branches only.; --; TTree *T = (TTree*)f->Get(""mytree"");; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(b1,kTRUE); //<<<add branch1 and branch2 to the cache; T->AddBranchToCache(b2,kTRUE); //<<<; T->StopCacheLearningPhase(); //<<<; for (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i); //<<< important call when calling TBranch::GetEntry after; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --; --example 3b; in your analysis loop, you always use 2 branches in the main loop.; you also call some analysis functions where a few more branches will be read.; but you do not know a priori which ones. There is no point in prefetching; branches that will be used very rarely.; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:6852,Performance,cache,cache,6852,"last = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",nentries,efirst);; // in the TSelector::Process we read only 2 branches; TBranch *b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; TBranch *b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... here you process your entry; --. 3- with your own event loop. --example 3a; in your analysis loop, you always use 2 branches. You want to prefetch; the branch buffers for these 2 branches only.; --; TTree *T = (TTree*)f->Get(""mytree"");; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(b1,kTRUE); //<<<add branch1 and branch2 to the cache; T->AddBranchToCache(b2,kTRUE); //<<<; T->StopCacheLearningPhase(); //<<<; for (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i); //<<< important call when calling TBranch::GetEntry after; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --; --example 3b; in your analysis loop, you always use 2 branches in the main loop.; you also call some analysis functions where a few more branches will be read.; but you do not know a priori which ones. There is no point in prefetching; branches that will be used very rarely.; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:7809,Performance,cache,cachesize,7809,"important call when calling TBranch::GetEntry after; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --; --example 3b; in your analysis loop, you always use 2 branches in the main loop.; you also call some analysis functions where a few more branches will be read.; but you do not know a priori which ones. There is no point in prefetching; branches that will be used very rarely.; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->SetCacheLearnEntries(5); //<<< we can take the decision after 5 entries; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; for (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; //at this point we may call a user function where a few more branches; //will be read conditionally. These branches will be put in the cache; //if they have been used in the first 10 entries; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --. SPECIAL CASES WHERE TreeCache should not be activated. When reading only a small fraction of all entries such that not all branch; buffers are read, it might be faster to run without a cache. HOW TO VERIFY That the TreeCache has been used and check its performance. Once your analysis loop has terminated, you c",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:7860,Performance,cache,cachesize,7860,"important call when calling TBranch::GetEntry after; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --; --example 3b; in your analysis loop, you always use 2 branches in the main loop.; you also call some analysis functions where a few more branches will be read.; but you do not know a priori which ones. There is no point in prefetching; branches that will be used very rarely.; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->SetCacheLearnEntries(5); //<<< we can take the decision after 5 entries; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; for (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; //at this point we may call a user function where a few more branches; //will be read conditionally. These branches will be put in the cache; //if they have been used in the first 10 entries; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --. SPECIAL CASES WHERE TreeCache should not be activated. When reading only a small fraction of all entries such that not all branch; buffers are read, it might be faster to run without a cache. HOW TO VERIFY That the TreeCache has been used and check its performance. Once your analysis loop has terminated, you c",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:8299,Performance,cache,cache,8299,"(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --; --example 3b; in your analysis loop, you always use 2 branches in the main loop.; you also call some analysis functions where a few more branches will be read.; but you do not know a priori which ones. There is no point in prefetching; branches that will be used very rarely.; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->SetCacheLearnEntries(5); //<<< we can take the decision after 5 entries; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; for (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; //at this point we may call a user function where a few more branches; //will be read conditionally. These branches will be put in the cache; //if they have been used in the first 10 entries; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --. SPECIAL CASES WHERE TreeCache should not be activated. When reading only a small fraction of all entries such that not all branch; buffers are read, it might be faster to run without a cache. HOW TO VERIFY That the TreeCache has been used and check its performance. Once your analysis loop has terminated, you can access/print the number; of effective system reads for a given file with a code like; (where TFile* f is a pointer to your file). printf(""Reading %lld bytes in %d transactions\n"",f->GetBytesRead(), f->GetReadCalls());. Function Members (Methods); public:. TTreeCache(); TTreeCache(TTree* tree, Int_t buffersize = 0); virtual~TTreeCache(); voidTObject::AbstractM",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:8867,Performance,cache,cache,8867,"nt_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->SetCacheLearnEntries(5); //<<< we can take the decision after 5 entries; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; for (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; //at this point we may call a user function where a few more branches; //will be read conditionally. These branches will be put in the cache; //if they have been used in the first 10 entries; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --. SPECIAL CASES WHERE TreeCache should not be activated. When reading only a small fraction of all entries such that not all branch; buffers are read, it might be faster to run without a cache. HOW TO VERIFY That the TreeCache has been used and check its performance. Once your analysis loop has terminated, you can access/print the number; of effective system reads for a given file with a code like; (where TFile* f is a pointer to your file). printf(""Reading %lld bytes in %d transactions\n"",f->GetBytesRead(), f->GetReadCalls());. Function Members (Methods); public:. TTreeCache(); TTreeCache(TTree* tree, Int_t buffersize = 0); virtual~TTreeCache(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch* b, Bool_t subgbranches = kFALSE); virtual voidAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::Class",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:8935,Performance,perform,performance,8935,"<< we can take the decision after 5 entries; TBranch *b1 = T->GetBranch(""branch1"");; TBranch *b2 = T->GetBranch(""branch2"");; for (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; //at this point we may call a user function where a few more branches; //will be read conditionally. These branches will be put in the cache; //if they have been used in the first 10 entries; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --. SPECIAL CASES WHERE TreeCache should not be activated. When reading only a small fraction of all entries such that not all branch; buffers are read, it might be faster to run without a cache. HOW TO VERIFY That the TreeCache has been used and check its performance. Once your analysis loop has terminated, you can access/print the number; of effective system reads for a given file with a code like; (where TFile* f is a pointer to your file). printf(""Reading %lld bytes in %d transactions\n"",f->GetBytesRead(), f->GetReadCalls());. Function Members (Methods); public:. TTreeCache(); TTreeCache(TTree* tree, Int_t buffersize = 0); virtual~TTreeCache(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch* b, Bool_t subgbranches = kFALSE); virtual voidAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newn",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:17291,Performance,cache,cache,17291,,MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:17829,Performance,cache,cache,17829,,MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:17894,Performance,cache,cache,17894,,MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:18256,Performance,cache,cache,18256,ng; Bool_tfAutoCreated! true if cache was automatically created; Bool_tTFileCacheRead::fBIsSorted; Bool_tTFileCacheRead::fBIsTransferred; Int_t*TFileCacheRead::fBLen; Int_tTFileCacheRead::fBNb; Int_tTFileCacheRead::fBNseek; Int_tTFileCacheRead::fBNtot; Long64_t*TFileCacheRead::fBPos; Long64_t*TFileCacheRead::fBSeek; Int_t*TFileCacheRead::fBSeekIndex; Int_t*TFileCacheRead::fBSeekLen; Int_t*TFileCacheRead::fBSeekPos; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort; Int_t*TFileCacheRead::fBSeekSortLen; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains someth,MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:18461,Performance,cache,cache,18461,acheRead::fBNseek; Int_tTFileCacheRead::fBNtot; Long64_t*TFileCacheRead::fBPos; Long64_t*TFileCacheRead::fBSeek; Int_t*TFileCacheRead::fBSeekIndex; Int_t*TFileCacheRead::fBSeekLen; Int_t*TFileCacheRead::fBSeekPos; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort; Int_t*TFileCacheRead::fBSeekSortLen; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPr,MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:18479,Performance,cache,cached,18479, Int_tTFileCacheRead::fBNtot; Long64_t*TFileCacheRead::fBPos; Long64_t*TFileCacheRead::fBSeek; Int_t*TFileCacheRead::fBSeekIndex; Int_t*TFileCacheRead::fBSeekLen; Int_t*TFileCacheRead::fBSeekPos; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort; Int_t*TFileCacheRead::fBSeekSortLen; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks ,MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:18553,Performance,cache,cache,18553,leCacheRead::fBSeek; Int_t*TFileCacheRead::fBSeekIndex; Int_t*TFileCacheRead::fBSeekLen; Int_t*TFileCacheRead::fBSeekPos; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort; Int_t*TFileCacheRead::fBSeekSortLen; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int,MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:18597,Performance,cache,cache,18597,BSeekIndex; Int_t*TFileCacheRead::fBSeekLen; Int_t*TFileCacheRead::fBSeekPos; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort; Int_t*TFileCacheRead::fBSeekSortLen; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cach,MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:18642,Performance,cache,cache,18642,Int_t*TFileCacheRead::fBSeekPos; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort; Int_t*TFileCacheRead::fBSeekSortLen; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadN,MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:18693,Performance,cache,cache,18693,d::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort; Int_t*TFileCacheRead::fBSeekSortLen; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; ,MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:19039,Performance,cache,cache,19039,ufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase ; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fP,MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:19091,Performance,cache,cache,19091,d size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase ; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch!Object that does the asynchronous reading in,MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:19444,Performance,cache,cache,19444, of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase ; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch!Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.,MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:19596,Performance,cache,cache,19596, of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase ; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch!Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.,MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:19683,Performance,cache,cached,19683, of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase ; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch!Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.,MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:19773,Performance,cache,cached,19773, of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase ; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch!Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.,MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:20343,Performance,cache,cache,20343,"dNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase ; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch!Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypefPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tfReadDirectionSet! read direction established; Bool_tfReverseRead! reading in reverse mode ; Long64_t*TFileCacheRead::fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*TFileCacheRead::fSeekIndex[fNseek] sorted index table of fSeek; Int_t*TFileCacheRead::fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*TFileCacheRead::fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); TTree*fTree! pointer to the current Tree; static Int_tfgLearnEntriesnumber of entries used for learning mode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be s",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:21480,Performance,cache,cache,21480," Long64_t*TFileCacheRead::fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*TFileCacheRead::fSeekIndex[fNseek] sorted index table of fSeek; Int_t*TFileCacheRead::fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*TFileCacheRead::fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); TTree*fTree! pointer to the current Tree; static Int_tfgLearnEntriesnumber of entries used for learning mode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch)",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:21656,Performance,cache,cache,21656,"n[fNseek] Length of buffers to be prefetched; Int_t*TFileCacheRead::fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); TTree*fTree! pointer to the current Tree; static Int_tfgLearnEntriesnumber of entries used for learning mode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are tak",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:22037,Performance,cache,cache,22037,"he current Tree; static Int_tfgLearnEntriesnumber of entries used for learning mode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetc",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:22193,Performance,cache,cache,22193,"s; Libraries. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the pr",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:22373,Performance,cache,cache,22373,"ile destructor). void AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of ",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:22753,Performance,cache,cache,22753,"works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:22821,Performance,cache,cache,22821,"r ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:22859,Performance,cache,cache,22859,"r ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:22931,Performance,cache,cache,22931,"branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 ",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:22985,Performance,cache,cache,22985,"(i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:23089,Performance,cache,cache,23089,"* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cac",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:23325,Performance,cache,cache,23325,"nch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, ",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:23453,Performance,cache,cache,23453," pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at p",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:23528,Performance,cache,cache,23528,"ook over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from th",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:23633,Performance,cache,cache,23633,"branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:24018,Performance,cache,cache,24018,"number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the br",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:24095,Performance,cache,cache,24095,"re; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:24165,Performance,cache,cachedbranches,24165,"uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static funct",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:24210,Performance,cache,cached,24210,"uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static funct",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:24524,Performance,cache,cache,24524,"; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the p",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:24662,Performance,cache,cache,24662,"Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default pref",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:24690,Performance,cache,cache,24690,"Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default pref",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:24796,Performance,cache,cache,24796,"....: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void St",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:24937,Performance,optimiz,optimize,24937,"with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned befo",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:25430,Performance,cache,cache,25430,"64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void Learn",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:25596,Performance,cache,cache,25596,"ed branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache& o",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:25887,Performance,cache,cache,25887,"mber to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). void Disable(); {fEnabled = kFALSE;}. void Enable(); {fEnabled = kTRUE;}. const TObjArray * GetCachedBranches() const; { return fBranches; }. EPrefillType GetConfiguredPrefillType() const. Int_t GetEntryMin() const; {return fEntryMin;}. Int_t GetEntryMax() const; {return fEntryMax;}. EPrefillType GetLearnP",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:26367,Performance,cache,cache,26367,"l(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). void Disable(); {fEnabled = kFALSE;}. void Enable(); {fEnabled = kTRUE;}. const TObjArray * GetCachedBranches() const; { return fBranches; }. EPrefillType GetConfiguredPrefillType() const. Int_t GetEntryMin() const; {return fEntryMin;}. Int_t GetEntryMax() const; {return fEntryMax;}. EPrefillType GetLearnPrefill() const; {return fPrefillType;}. TTree * GetTree() const; {return fTree;}. Bool_t IsAutoCreated() const; {return fAutoCreated;}. Bool_t IsEnabled() const; {return fEnabled;}. Bool_t IsLearning() const; {return fIsLearning;}. void SetAutoCreated(Bool_t val); {fAutoCreated = val;}. » Author: Rene Brun 04/06/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last genera",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:4223,Safety,predict,predict,4223,"fer one single large buffer of 10 Mbytes in one single transaction.; Not only the TreeCache minimizes the number of transfers, but in addition; it can sort the blocks to be read in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache ",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:5164,Safety,risk,risk,5164,"ions the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"",kTRUE); //<<< add all branches to the cache; T->Process('myselector.C+"");; //in the TSelector::Process function we read all branches; T->GetEntry(i);; -- ... here you process your entry. --example 2b; in the Process function we read a subset of the branches.; Only the branches used in the first entry will be put in the cache; --; TTree *T = (TTree*)f->Get(""mytree"");; //we want to process only the 200 first entries; Long64_t nentries=200;; int efirst= 0;; int elast = efirst+nentries;; Int_t cachesize = 10000000; //10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process('myselector.C+"","""",ne",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:723,Security,access,accessed,723,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default ",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:8996,Security,access,access,8996,"or (Long64_t i=0;i<nentries;i++) {; T->LoadTree(i);; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; //at this point we may call a user function where a few more branches; //will be read conditionally. These branches will be put in the cache; //if they have been used in the first 10 entries; if (some condition not met) continue;; //here we read the full event only in some rare cases.; //there is no point in caching the other branches as it might be; //more economical to read only the branch buffers really used.; T->GetEntry(i);; .. process the rare but interesting cases.; ... here you process your entry; }; --. SPECIAL CASES WHERE TreeCache should not be activated. When reading only a small fraction of all entries such that not all branch; buffers are read, it might be faster to run without a cache. HOW TO VERIFY That the TreeCache has been used and check its performance. Once your analysis loop has terminated, you can access/print the number; of effective system reads for a given file with a code like; (where TFile* f is a pointer to your file). printf(""Reading %lld bytes in %d transactions\n"",f->GetBytesRead(), f->GetReadCalls());. Function Members (Methods); public:. TTreeCache(); TTreeCache(TTree* tree, Int_t buffersize = 0); virtual~TTreeCache(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch* b, Bool_t subgbranches = kFALSE); virtual voidAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) c",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:525,Usability,learn,learning,525,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default ",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:546,Usability,learn,learning,546,". TTreeCache. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCache. class TTreeCache: public TFileCacheRead. TTreeCache. A specialized TFileCacheRead object for a TTree; This class acts as a file cache, registering automatically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default ",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:1365,Usability,learn,learning,1365,"rom the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:1672,Usability,learn,learning,1672,"icular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be writ",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:1782,Usability,learn,learning,1782,"TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:1924,Usability,learn,learning,1924,"bject is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local ",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:1959,Usability,learn,learning,1959,"bject is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local ",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:4412,Usability,learn,learning,4412," in increasing order such that the file; is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TreeCache in; reading ahead as much data as they can and return to the application; the maximum data specified in the cache and have the next chunk of data ready; when the next request comes. HOW TO USE the TreeCache. A few use cases are discussed below. A cache may be created with automatic sizing; when a TTree is used:. Caches are created and automatically sized for TTrees when TTreeCache.Size or; the environment variable ROOT_TTREECACHE_SIZE is set to a sizing factor. But there are many possible configurations where manual control may be wanted.; In some applications you know a priori the list of branches to read. In other; applications the analysis loop calls several layers of user functions where it; is impossible to predict a priori which branches will be used. This; is probably the most frequent case. In this case ROOT I/O will flag used; branches automatically when a branch buffer is read during the learning phase.; The TreeCache interface provides functions to instruct the cache about the used; branches if they are known a priori. In the examples below, portions of analysis; code are shown. The few statements involving the TreeCache are marked with //<<<. 1- with TTree::Draw. the TreeCache is automatically used by TTree::Draw. The function knows; which branches are used in the query and it puts automatically these branches; in the cache. The entry range is also known automatically. 2- with TTree::Process and TSelectors. You must enable the cache and tell the system which branches to cache; and also specify the entry range. It is important to specify the entry range; in case you process only a subset of the events, otherwise you run the risk; to store in the cache entries that you do not need. --example 2a; --; TTree *T = (TTree*)f->Get(""mytree"");; Long64_t nentries = T->GetEntries();; Int_t cachesize = 10000000; //10 MBytes; T->SetCacheS",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:19051,Usability,learn,learning,19051,nt_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase ; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch!Object,MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:19935,Usability,learn,learning,19935, of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase ; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch!Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.,MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:21092,Usability,learn,learning,21092,"dNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase ; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch!Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypefPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tfReadDirectionSet! read direction established; Bool_tfReverseRead! reading in reverse mode ; Long64_t*TFileCacheRead::fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*TFileCacheRead::fSeekIndex[fNseek] sorted index table of fSeek; Int_t*TFileCacheRead::fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*TFileCacheRead::fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); TTree*fTree! pointer to the current Tree; static Int_tfgLearnEntriesnumber of entries used for learning mode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be s",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:22051,Usability,learn,learning,22051,"he current Tree; static Int_tfgLearnEntriesnumber of entries used for learning mode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetc",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:22767,Usability,learn,learning,22767,"works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:24779,Usability,simpl,simply,24779,"....: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void St",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:24786,Usability,clear,clear,24786,"....: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void St",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:25233,Usability,learn,learning,25233,"g; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will creat",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:25377,Usability,learn,learning,25377,"64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void Learn",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:25920,Usability,learn,learning,25920,"mber to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). void Disable(); {fEnabled = kFALSE;}. void Enable(); {fEnabled = kTRUE;}. const TObjArray * GetCachedBranches() const; { return fBranches; }. EPrefillType GetConfiguredPrefillType() const. Int_t GetEntryMin() const; {return fEntryMin;}. Int_t GetEntryMax() const; {return fEntryMax;}. EPrefillType GetLearnP",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:26039,Usability,learn,learning,26039,"the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). void Disable(); {fEnabled = kFALSE;}. void Enable(); {fEnabled = kTRUE;}. const TObjArray * GetCachedBranches() const; { return fBranches; }. EPrefillType GetConfiguredPrefillType() const. Int_t GetEntryMin() const; {return fEntryMin;}. Int_t GetEntryMax() const; {return fEntryMax;}. EPrefillType GetLearnPrefill() const; {return fPrefillType;}. TTree * GetTree() const; {return fTree;}. Bool_t IsAutoCreated() ",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCache.html:26458,Usability,learn,learning,26458,"which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). void Disable(); {fEnabled = kFALSE;}. void Enable(); {fEnabled = kTRUE;}. const TObjArray * GetCachedBranches() const; { return fBranches; }. EPrefillType GetConfiguredPrefillType() const. Int_t GetEntryMin() const; {return fEntryMin;}. Int_t GetEntryMax() const; {return fEntryMax;}. EPrefillType GetLearnPrefill() const; {return fPrefillType;}. TTree * GetTree() const; {return fTree;}. Bool_t IsAutoCreated() const; {return fAutoCreated;}. Bool_t IsEnabled() const; {return fEnabled;}. Bool_t IsLearning() const; {return fIsLearning;}. void SetAutoCreated(Bool_t val); {fAutoCreated = val;}. » Author: Rene Brun 04/06/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-03-15 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ",MatchSource.WIKI,root/html534/TTreeCache.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCache.html
https://root.cern/root/html534/TTreeCacheUnzip.html:2739,Availability,error,error,2739,"lassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTTreeCache::Disable(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTTreeCache::DropBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual voidTTreeCache::DropBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTObject::Dump() constMENU ; virtual voidTTreeCache::Enable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Bool_tFillBuffer(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTFileCacheRead::GetBufferSize() const; virtual Long64_tTFileCacheRead::GetBytesRead() const; virtual Long64_tTFileCacheRead::GetBytesReadExtra() const; const TObjArray*TTreeCache::GetCachedBranches() const; TTreeCache::EPrefillTypeTTreeCache::GetConfiguredPrefillType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTTreeCache::GetEfficiency() const; Double_tTTreeCache::GetEfficiencyRel() const; virtual Int_tTTreeCache::GetEntryMax() const; virtual Int_tTTreeCache::GetEntryMin() const; TFile*TFileCacheRead::GetFile() const; virtual const cha",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:2823,Availability,error,error,2823,"t::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTTreeCache::Disable(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTTreeCache::DropBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual voidTTreeCache::DropBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTObject::Dump() constMENU ; virtual voidTTreeCache::Enable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Bool_tFillBuffer(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTFileCacheRead::GetBufferSize() const; virtual Long64_tTFileCacheRead::GetBytesRead() const; virtual Long64_tTFileCacheRead::GetBytesReadExtra() const; const TObjArray*TTreeCache::GetCachedBranches() const; TTreeCache::EPrefillTypeTTreeCache::GetConfiguredPrefillType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTTreeCache::GetEfficiency() const; Double_tTTreeCache::GetEfficiencyRel() const; virtual Int_tTTreeCache::GetEntryMax() const; virtual Int_tTTreeCache::GetEntryMin() const; TFile*TFileCacheRead::GetFile() const; virtual const char*TObject::GetIconName() const; static Int_tTTreeCache::GetLearnEntries(); virtual T",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:18451,Availability,error,error,18451,"y important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nb",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:20640,Availability,failure,failure,20640," must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of th",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:21513,Availability,error,error,21513,"_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This fun",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:22503,Availability,error,error,22503,"fer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This func is supposed to compete among an indefinite number of threads to get a chunk to inflate; in order to accommodate multiple unzippers; Since everything is so async, we cannot use a fixed buffer, we are forced to keep; the individual chunks as separate blocks, whose summed size does not exceed the maximum; allowed. The pointers are kept globally in the array fUnzipChunks. void Print(Option_t* option = """") const. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). TTreeCacheUnzip(const TTreeCacheUnzip& ). TTreeCacheUnzip& operator=(const TTreeCacheUnzip& ). EParUnzipMode GetParallelUnzip(); Methods related to the thread. Int_t GetNUnzip(); Methods to get stats. { return fNUnzip; }. Int_t GetNFound(); { return fNFound; }. Int_t GetNMissed(); { return fNMissed; }. » Author: Rene Brun 04/06/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-03-15 16:40; This pa",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:17155,Deployability,update,update,17155,"onstructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. Bool_t FillBuffer(). void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional t",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:19993,Energy Efficiency,adapt,adapted,19993,"already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original valu",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:20886,Energy Efficiency,allocate,allocate,20886,"he arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all t",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:21551,Energy Efficiency,allocate,allocate,21551,"_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This fun",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:22195,Energy Efficiency,allocate,allocate,22195,"nd also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This func is supposed to compete among an indefinite number of threads to get a chunk to inflate; in order to accommodate multiple unzippers; Since everything is so async, we cannot use a fixed buffer, we are forced to keep; the individual chunks as separate blocks, whose summed size does not exceed the maximum; allowed. The pointers are kept globally in the array fUnzipChunks. void Print(Option_t* option = """") const. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). TTreeCacheUnzip(const TTreeCacheUnzip& ). TTreeCacheUnzip& operator=(const TTreeCacheUnzip& ). EParUnzipMode GetParallelUnzip(); Methods",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:595,Integrability,synchroniz,synchronized,595,". TTreeCacheUnzip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCacheUnzip. class TTreeCacheUnzip: public TTreeCache. Parallel Unzipping. TTreeCache has been specialised in order to let additional threads; free to unzip in advance its content. In this implementation we; support up to 10 threads, but right now it makes more sense to; limit their number to 1-2. The application reading data is carefully synchronized, in order to:; - if the block it wants is not unzipped, it self-unzips it without; waiting; - if the block is being unzipped in parallel, it waits only; for that unzip to finish; - if the block has already been unzipped, it takes it. This is supposed to cancel a part of the unzipping latency, at the; expenses of cpu time. The default parameters are the same of the prev version, i.e. 20%; of the TTreeCache cache size. To change it use; TTreeCache::SetUnzipBufferSize(Long64_t bufferSize); where bufferSize must be passed in bytes. Function Members (Methods); public:. TTreeCacheUnzip(); TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); virtual~TTreeCacheUnzip(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual voidAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObjec",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:17431,Modifiability,variab,variable,17431,"st of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. Bool_t FillBuffer(). void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:18874,Modifiability,variab,variable,18874,"ssing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical reco",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:19993,Modifiability,adapt,adapted,19993,"already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original valu",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:893,Performance,latency,latency,893,". TTreeCacheUnzip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCacheUnzip. class TTreeCacheUnzip: public TTreeCache. Parallel Unzipping. TTreeCache has been specialised in order to let additional threads; free to unzip in advance its content. In this implementation we; support up to 10 threads, but right now it makes more sense to; limit their number to 1-2. The application reading data is carefully synchronized, in order to:; - if the block it wants is not unzipped, it self-unzips it without; waiting; - if the block is being unzipped in parallel, it waits only; for that unzip to finish; - if the block has already been unzipped, it takes it. This is supposed to cancel a part of the unzipping latency, at the; expenses of cpu time. The default parameters are the same of the prev version, i.e. 20%; of the TTreeCache cache size. To change it use; TTreeCache::SetUnzipBufferSize(Long64_t bufferSize); where bufferSize must be passed in bytes. Function Members (Methods); public:. TTreeCacheUnzip(); TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); virtual~TTreeCacheUnzip(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual voidAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObjec",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:1017,Performance,cache,cache,1017,"heUnzip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TTreeCacheUnzip. class TTreeCacheUnzip: public TTreeCache. Parallel Unzipping. TTreeCache has been specialised in order to let additional threads; free to unzip in advance its content. In this implementation we; support up to 10 threads, but right now it makes more sense to; limit their number to 1-2. The application reading data is carefully synchronized, in order to:; - if the block it wants is not unzipped, it self-unzips it without; waiting; - if the block is being unzipped in parallel, it waits only; for that unzip to finish; - if the block has already been unzipped, it takes it. This is supposed to cancel a part of the unzipping latency, at the; expenses of cpu time. The default parameters are the same of the prev version, i.e. 20%; of the TTreeCache cache size. To change it use; TTreeCache::SetUnzipBufferSize(Long64_t bufferSize); where bufferSize must be passed in bytes. Function Members (Methods); public:. TTreeCacheUnzip(); TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); virtual~TTreeCacheUnzip(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual voidAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTFileCacheRead::AddNoCacheBytesRead(Long64_t len); virtual voidTFileCacheRead::AddNoCacheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TO",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:10311,Performance,queue,queue,10311,,MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:10528,Performance,cache,cache,10528,,MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:11096,Performance,cache,cache,11096,,MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:11173,Performance,cache,cache,11173,,MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:11535,Performance,cache,cache,11535,automatically created; Bool_tTFileCacheRead::fBIsSorted; Bool_tTFileCacheRead::fBIsTransferred; Int_t*TFileCacheRead::fBLen; Int_tTFileCacheRead::fBNb; Int_tTFileCacheRead::fBNseek; Int_tTFileCacheRead::fBNtot; Long64_t*TFileCacheRead::fBPos; Long64_t*TFileCacheRead::fBSeek; Int_t*TFileCacheRead::fBSeekIndex; Int_t*TFileCacheRead::fBSeekLen; Int_t*TFileCacheRead::fBSeekPos; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort; Int_t*TFileCacheRead::fBSeekSortLen; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache ,MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:11765,Performance,cache,cache,11765,Read::fBPos; Long64_t*TFileCacheRead::fBSeek; Int_t*TFileCacheRead::fBSeekIndex; Int_t*TFileCacheRead::fBSeekLen; Int_t*TFileCacheRead::fBSeekPos; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort; Int_t*TFileCacheRead::fBSeekSortLen; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length,MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:11783,Performance,cache,cached,11783,4_t*TFileCacheRead::fBSeek; Int_t*TFileCacheRead::fBSeekIndex; Int_t*TFileCacheRead::fBSeekLen; Int_t*TFileCacheRead::fBSeekPos; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort; Int_t*TFileCacheRead::fBSeekSortLen; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; T,MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:11869,Performance,cache,cache,11869,BSeekIndex; Int_t*TFileCacheRead::fBSeekLen; Int_t*TFileCacheRead::fBSeekPos; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort; Int_t*TFileCacheRead::fBSeekSortLen; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists.,MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:11925,Performance,cache,cache,11925,BSeekIndex; Int_t*TFileCacheRead::fBSeekLen; Int_t*TFileCacheRead::fBSeekPos; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort; Int_t*TFileCacheRead::fBSeekSortLen; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists.,MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:11982,Performance,cache,cache,11982,BSeekIndex; Int_t*TFileCacheRead::fBSeekLen; Int_t*TFileCacheRead::fBSeekPos; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort; Int_t*TFileCacheRead::fBSeekSortLen; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists.,MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:12045,Performance,cache,cache,12045,BSeekIndex; Int_t*TFileCacheRead::fBSeekLen; Int_t*TFileCacheRead::fBSeekPos; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort; Int_t*TFileCacheRead::fBSeekSortLen; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists.,MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:12468,Performance,cache,cache,12468,BSeekIndex; Int_t*TFileCacheRead::fBSeekLen; Int_t*TFileCacheRead::fBSeekPos; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort; Int_t*TFileCacheRead::fBSeekSortLen; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists.,MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:12532,Performance,cache,cache,12532,BSeekIndex; Int_t*TFileCacheRead::fBSeekLen; Int_t*TFileCacheRead::fBSeekPos; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort; Int_t*TFileCacheRead::fBSeekSortLen; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists.,MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:12916,Performance,cache,cache,12916,anual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the cache; Int_tTTreeCache::fNReadPrefNumber of blocks that were prefetched; Int_tfNStalls! number of hits which caused a stall; Int_tfNUnzip! number of blocks that were unzipped; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tTTreeCache::fNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tfNseekMax! fNseek can change so we need to know its max size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase ; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch!Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode ; Long64_t*TFileCacheRead::fSeek[fNseek],MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:12982,Performance,cache,cache,12982,anual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the cache; Int_tTTreeCache::fNReadPrefNumber of blocks that were prefetched; Int_tfNStalls! number of hits which caused a stall; Int_tfNUnzip! number of blocks that were unzipped; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tTTreeCache::fNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tfNseekMax! fNseek can change so we need to know its max size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase ; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch!Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode ; Long64_t*TFileCacheRead::fSeek[fNseek],MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:13149,Performance,cache,cache,13149,anual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the cache; Int_tTTreeCache::fNReadPrefNumber of blocks that were prefetched; Int_tfNStalls! number of hits which caused a stall; Int_tfNUnzip! number of blocks that were unzipped; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tTTreeCache::fNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tfNseekMax! fNseek can change so we need to know its max size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase ; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch!Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode ; Long64_t*TFileCacheRead::fSeek[fNseek],MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:13428,Performance,cache,cache,13428,anual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the cache; Int_tTTreeCache::fNReadPrefNumber of blocks that were prefetched; Int_tfNStalls! number of hits which caused a stall; Int_tfNUnzip! number of blocks that were unzipped; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tTTreeCache::fNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tfNseekMax! fNseek can change so we need to know its max size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase ; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch!Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode ; Long64_t*TFileCacheRead::fSeek[fNseek],MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:13515,Performance,cache,cached,13515,anual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the cache; Int_tTTreeCache::fNReadPrefNumber of blocks that were prefetched; Int_tfNStalls! number of hits which caused a stall; Int_tfNUnzip! number of blocks that were unzipped; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tTTreeCache::fNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tfNseekMax! fNseek can change so we need to know its max size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase ; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch!Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode ; Long64_t*TFileCacheRead::fSeek[fNseek],MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:13605,Performance,cache,cached,13605,anual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the cache; Int_tTTreeCache::fNReadPrefNumber of blocks that were prefetched; Int_tfNStalls! number of hits which caused a stall; Int_tfNUnzip! number of blocks that were unzipped; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tTTreeCache::fNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tfNseekMax! fNseek can change so we need to know its max size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase ; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch!Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode ; Long64_t*TFileCacheRead::fSeek[fNseek],MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:14350,Performance,cache,cache,14350,"x size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase ; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch!Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode ; Long64_t*TFileCacheRead::fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*TFileCacheRead::fSeekIndex[fNseek] sorted index table of fSeek; Int_t*TFileCacheRead::fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*TFileCacheRead::fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); Long64_tfTotalUnzipBytes! The total sum of the currently unzipped blks; TTree*TTreeCache::fTree! pointer to the current Tree; Long64_tfUnzipBufferSize! Max Size for the ready unzipped blocks (default is 2*fBufferSize); char**fUnzipChunks! [fNseek] Individual unzipped chunks. Their summed size is kept under control.; TCondition*fUnzipDoneConditionUsed to wait for an unzip tour to finish. Gives the Async feel.; Int_t*fUnzipLen! [fNseek] Length of the unzipped buffers; TCondition*fUnzipStartConditionUsed to signal the threads to start.; Byte_t*fUnzipStatus! [fNSeek] For each blk, tells us if it's unzipped or pending; TThread*fUnzipThread[10]; static Int_tTTreeCache::fgLearnEntriesnumber of entries used fo",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:16508,Performance,cache,cache,16508,"the unzipped buffers; TCondition*fUnzipStartConditionUsed to signal the threads to start.; Byte_t*fUnzipStatus! [fNSeek] For each blk, tells us if it's unzipped or pending; TThread*fUnzipThread[10]; static Int_tTTreeCache::fgLearnEntriesnumber of entries used for learning mode; static TTreeCacheUnzip::EParUnzipModefgParallelIndicate if we want to activate the parallelism; static Double_tfgRelBuffSizeThis is the percentage of the TTreeCacheUnzip that will be used. private:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. Bool_t FillBuffer(). void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we chang",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:16684,Performance,cache,cache,16684," TThread*fUnzipThread[10]; static Int_tTTreeCache::fgLearnEntriesnumber of entries used for learning mode; static TTreeCacheUnzip::EParUnzipModefgParallelIndicate if we want to activate the parallelism; static Double_tfgRelBuffSizeThis is the percentage of the TTreeCacheUnzip that will be used. private:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. Bool_t FillBuffer(). void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to pro",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:16893,Performance,optimiz,optimize,16893,"le_tfgRelBuffSizeThis is the percentage of the TTreeCacheUnzip that will be used. private:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. Bool_t FillBuffer(). void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; whe",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:17232,Performance,cache,cache,17232,"onstructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. Bool_t FillBuffer(). void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional t",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:17600,Performance,queue,queue,17600," branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. Bool_t FillBuffer(). void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits fo",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:17837,Performance,queue,queue,17837,"Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:18602,Performance,queue,queue,18602,"CacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must ",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:19106,Performance,queue,queue,19106,"ding unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void Res",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:19353,Performance,cache,cache,19353," _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is co",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:20124,Performance,cache,cache,20124,"ueue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets th",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:20168,Performance,cache,cache,20168,"ueue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets th",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:20241,Performance,cache,cache,20241,"aving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the p",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:20676,Performance,cache,cache,20676," must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of th",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:20708,Performance,cache,cache,20708," must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of th",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:21268,Performance,cache,cache,21268,"the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:21340,Performance,cache,cache,21340,"ompletely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the tra",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:21928,Performance,cache,cache,21928,"0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This func is supposed to compete among an indefinite number of threads to get a chunk to inflate; in order to accommodate multiple unzippers; Since everything is so async, we cannot use a fixed buffer, we are forced to keep; the individual chunks as separate blocks, whose summed size does not exceed the maximum; allowed. The pointers ar",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:22053,Performance,cache,cache,22053,"(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This func is supposed to compete among an indefinite number of threads to get a chunk to inflate; in order to accommodate multiple unzippers; Since everything is so async, we cannot use a fixed buffer, we are forced to keep; the individual chunks as separate blocks, whose summed size does not exceed the maximum; allowed. The pointers are kept globally in the array fUnzipChunks. void Print(Option_t* option = """") const. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). TTreeCacheUnzip(const TTreeCac",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:22094,Performance,cache,cache,22094,"(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This func is supposed to compete among an indefinite number of threads to get a chunk to inflate; in order to accommodate multiple unzippers; Since everything is so async, we cannot use a fixed buffer, we are forced to keep; the individual chunks as separate blocks, whose summed size does not exceed the maximum; allowed. The pointers are kept globally in the array fUnzipChunks. void Print(Option_t* option = """") const. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). TTreeCacheUnzip(const TTreeCac",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:22213,Performance,cache,cache,22213,"nd also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This func is supposed to compete among an indefinite number of threads to get a chunk to inflate; in order to accommodate multiple unzippers; Since everything is so async, we cannot use a fixed buffer, we are forced to keep; the individual chunks as separate blocks, whose summed size does not exceed the maximum; allowed. The pointers are kept globally in the array fUnzipChunks. void Print(Option_t* option = """") const. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). TTreeCacheUnzip(const TTreeCacheUnzip& ). TTreeCacheUnzip& operator=(const TTreeCacheUnzip& ). EParUnzipMode GetParallelUnzip(); Methods",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:22280,Performance,cache,cache,22280,"times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This func is supposed to compete among an indefinite number of threads to get a chunk to inflate; in order to accommodate multiple unzippers; Since everything is so async, we cannot use a fixed buffer, we are forced to keep; the individual chunks as separate blocks, whose summed size does not exceed the maximum; allowed. The pointers are kept globally in the array fUnzipChunks. void Print(Option_t* option = """") const. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). TTreeCacheUnzip(const TTreeCacheUnzip& ). TTreeCacheUnzip& operator=(const TTreeCacheUnzip& ). EParUnzipMode GetParallelUnzip(); Methods related to the thread. Int_t GetNUnzip(); Methods to get stats. { return fNUnzip; }. Int_t GetNFound(); { return fNFound; }. Int_t GetNMisse",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:18139,Safety,detect,detection,18139,"the buffers. void UpdateBranches(TTree* tree); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful to see if we have to process; it. void WaitUnzipStartSignal(); Here the threads sleep waiting for some blocks to unzip. void SendUnzipStartSignal(Bool_t broadcast); This will send the signal corresponfing to the queue... normally used; when we want to start processing the list of buffers. Int_t SetParallelUnzip(TTreeCacheUnzip::EParUnzipMode option = TTreeCacheUnzip::kEnable); Static function that(de)activates multithreading unzipping; The possible options are:; kEnable _Enable_ it, which causes an automatic detection and launches the; additional thread if the number of cores in the machine is greater than one; kDisable _Disable_ will not activate the additional thread.; kForce _Force_ will start the additional thread even if there is only one core.; the default will be taken as kEnable.; returns 0 if there was an error, 1 otherwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the que",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:19493,Testability,log,logical,19493,"therwise. Int_t StartThreadUnzip(Int_t nthreads); The Thread is only a part of the TTreeCache but it is the part that; waits for info in the queue and process it... unfortunatly, a Thread is; not an object an we have to deal with it in the old C-Style way; Returns 0 if the thread was initialized or 1 if it was already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about ",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:19876,Testability,log,logical,19876,"already running. Int_t StopThreadUnzip(); To stop the thread we only need to change the value of the variable; fActiveThread to false and the loop will stop (of course, we will have); to do the cleaning after that.; Note: The syncronization part is important here or we will try to delete; teh object while it's still processing the queue. void* UnzipLoop(void* arg); This is a static function.; This is the call that will be executed in the Thread generated by; StartThreadTreeCacheUnzip... what we want to do is to inflate the next; series of buffers leaving them in the second cache.; Returns 0 when it finishes. Int_t GetRecordHeader(char* buf, Int_t maxbytes, Int_t& nbytes, Int_t& objlen, Int_t& keylen); Read the logical record header from the buffer buf.; That must be the pointer tho the header part not the object by itself and; must contain data of at least maxbytes; Returns nread;; In output arguments:; nbytes : number of bytes in record; if negative, this is a deleted record; if 0, cannot read record, wrong value of argument first; objlen : uncompressed object size; keylen : length of logical record header; Note that the arguments objlen and keylen are returned only; if maxbytes >=16; Note: This was adapted from TFile... so some things dont apply. void ResetCache(); This will delete the list of buffers that are in the unzipping cache; and will reset certain values in the cache.; This name is ambiguos because the method doesn't reset the whole cache,; only the part related to the unzipping; Note: This method is completely different from TTreeCache::ResetCache(),; in that method we were cleaning the prefetching buffer while here we; delete the information about the unzipped buffers. Int_t GetUnzipBuffer(char** buf, Long64_t pos, Int_t len, Bool_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original valu",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:12480,Usability,learn,learning,12480,BSeekIndex; Int_t*TFileCacheRead::fBSeekLen; Int_t*TFileCacheRead::fBSeekPos; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort; Int_t*TFileCacheRead::fBSeekSortLen; Int_tfBlocksToGo; TList*TTreeCache::fBrNames! list of branch names in the cache; TObjArray*TTreeCache::fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Int_tfCycle; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Bool_tTTreeCache::fEnabled! cache enabled for cached reading; Long64_tTTreeCache::fEntryCurrent! current lowest entry number in the cache; Long64_tTTreeCache::fEntryMax! last entry in the cache; Long64_tTTreeCache::fEntryMin! first entry in the cache; Long64_tTTreeCache::fEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tTTreeCache::fFillTimes! how many times we can fill the current buffer; Bool_tTTreeCache::fFirstBuffer! true if first buffer is used for prefetching; Long64_tTTreeCache::fFirstEntry! save the value of the first entry; Bool_tTTreeCache::fFirstTime! save the fact that we processes the first entry; TMutex*fIOMutex; Bool_tTTreeCache::fIsLearning! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists.,MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:13846,Usability,learn,learning,13846,anual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the cache; Int_tTTreeCache::fNReadPrefNumber of blocks that were prefetched; Int_tfNStalls! number of hits which caused a stall; Int_tfNUnzip! number of blocks that were unzipped; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tTTreeCache::fNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tfNseekMax! fNseek can change so we need to know its max size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase ; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch!Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypeTTreeCache::fPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode ; Long64_t*TFileCacheRead::fSeek[fNseek],MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
https://root.cern/root/html534/TTreeCacheUnzip.html:15741,Usability,learn,learning,15741,"on of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); Long64_tfTotalUnzipBytes! The total sum of the currently unzipped blks; TTree*TTreeCache::fTree! pointer to the current Tree; Long64_tfUnzipBufferSize! Max Size for the ready unzipped blocks (default is 2*fBufferSize); char**fUnzipChunks! [fNseek] Individual unzipped chunks. Their summed size is kept under control.; TCondition*fUnzipDoneConditionUsed to wait for an unzip tour to finish. Gives the Async feel.; Int_t*fUnzipLen! [fNseek] Length of the unzipped buffers; TCondition*fUnzipStartConditionUsed to signal the threads to start.; Byte_t*fUnzipStatus! [fNSeek] For each blk, tells us if it's unzipped or pending; TThread*fUnzipThread[10]; static Int_tTTreeCache::fgLearnEntriesnumber of entries used for learning mode; static TTreeCacheUnzip::EParUnzipModefgParallelIndicate if we want to activate the parallelism; static Double_tfgRelBuffSizeThis is the percentage of the TTreeCacheUnzip that will be used. private:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. Bool_t FillBuffer",MatchSource.WIKI,root/html534/TTreeCacheUnzip.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/TTreeCacheUnzip.html
